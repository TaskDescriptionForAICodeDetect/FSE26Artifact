[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct line\n{\n    double a,b,c;\n};\n\nconst int MAX_N = 100005;\nconst int sign[] = {1,-1};\n\nvector<line> tangent(double x1,double y1,double r1,double x2,double y2,double r2)\n{\n    vector<line> vec;\n    double p,q,r;\n    double a = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    rep(i,2){\n        double b = (x2-x1)*(r1*r1+sign[i]*r1*r2);\n        double c = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (y2-y1)*(y2-y1)*r1*r1;\n        rep(j,2){\n            if(b*b - a*c < -EPS){\n                break;\n            }\n            p = (-b + sign[j]*sqrt(b*b-a*c)) / a;\n            if(abs(y1-y2) < EPS){\n                q = 0;\n            }else{\n                q = (r1*r1 + sign[i]*r1*r2 - p*(x2-x1)) / (y2-y1);\n            }\n            r = -r1*r1 - p*x1 - q*y1;\n            vec.push_back((line){p,q,r});\n        }\n    }\n    return vec;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        int X[51],Y[51],R[51],M[51];\n    \trep(i,n){\n    \t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&M[i]);\n    \t}\n        if(n == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        int res = 0;\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                vector<line> u,v;\n                u = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]);\n                v = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]+M[j]);\n                rep(k,u.size()){\n                    v.push_back(u[k]);\n                }\n                rep(k,v.size()){\n                    int bf = 2;\n                    double aa = v[k].a,bb = v[k].b,cc = v[k].c;\n                    double d = sqrt(aa*aa+bb*bb);\n                    rep(l,n){\n                        if(l != i && l != j){\n                            if(abs(aa*X[l] + bb*Y[l] + cc) / d > R[l] - EPS && abs(aa*X[l] + bb*Y[l] + cc) / d < R[l]+M[l]+EPS){\n                                bf++;\n                            }\n                        }\n                    }\n                    res = max(res,bf);\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  elem rEx1 = sqrt( D*D + r2*r2 );\n  elem rEx2 = sqrt( D*D + 2*r2*r2 - r1*r1 );\n  intersection_circles( circle(c1.c, rEx1), c2, pcross );\n  intersection_circles( circle(c2.c, rEx2), c1, pcross2 );\n  ret[0] = line(pcross2.second,pcross.first);\n  ret[1] = line(pcross2.first,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n\n  //internal\n  point In((r2*c1.c+r1*c2.c)/(r1+r2));\n  elem rIn = sqrt( pow(abs(c1.c-In),2.0)-(r1*r1) );\n  intersection_circles( circle(In,rIn), c1, pcross );\n  ret[2] = line(In,pcross.first);\n  ret[3] = line(In,pcross.second);\n\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>100000) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\t//deleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble rts=r2*rs;\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+rts)*(r1+rts)+1e-9);\n\t\tdouble xf=r1*(xx*(r1+rts)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+rts)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(fabs(yf)>fabs(xf)){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  /*\n\t\t  cout<<xx*xx+yy*yy-(r1+r2)*(r1+r2)<<' '<<xf<<' '<<yf<<' ';\n\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  */\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nVP crosspointCL(const C &c, const L &l){\n    VP ret;\n    P mid = projection(l, c.p);\n    double d = distanceLP(l, c.p);\n    if(EQ(d, c.r)){\n        ret.push_back(mid);\n    }else if(d < c.r){\n        double len = sqrt(c.r*c.r -d*d);\n        ret.push_back(mid +len*unit(l[1]-l[0]));\n        ret.push_back(mid -len*unit(l[1]-l[0]));\n    }\n    return ret;\n}\n\nvector<L> getTangentLine(const C &c, const P &p){\n    vector<L> ret;\n    P dir = p -c.p;\n    if(c.r < abs(dir) +EPS){\n        P a = c.p + c.r*unit(dir);\n        VP cp = crosspointCL(C(c.p, abs(dir)), L(a, a+dir*P(0,1)));\n        for(int i=0; i<(int)cp.size(); i++){\n            ret.push_back(L(p, c.p +c.r*unit(cp[i]-c.p)));\n        }\n    }\n    return ret;\n}\n\nvector<L> getCommonTangentLine(C a, C b){\n    vector<L> ret;\n    if(a.p==b.p && EQ(a.r, b.r)) return ret;\n    if(a.r < b.r) swap(a,b);\n    P ab = b.p -a.p;\n    double d = abs(ab);\n    if(d+EPS > a.r+b.r){\n        ret = getTangentLine(a, a.p +a.r/(a.r+b.r)*ab);\n    }\n    if(d+EPS > a.r-b.r){\n        if(EQ(a.r, b.r)){\n            P normal = unit(ab)*P(0,1)*a.r;\n            ret.push_back(L(a.p +normal, b.p +normal));\n            ret.push_back(L(a.p -normal, b.p -normal));\n        }else{\n            vector<L> tmp = getTangentLine(a, a.p +a.r/(a.r-b.r)*ab);\n            copy(tmp.begin(), tmp.end(), back_inserter(ret));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<C> jewel(n*2);\n        for(int i=0; i<n; i++){\n            int x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewel[2*i] = C(P(x,y), r);\n            jewel[2*i+1] = C(P(x,y), r+m);\n        }\n\n        vector<L> tangent;\n        tangent.reserve(5000);\n        for(int i=0; i<2*n; i++){\n            for(int j=i+1; j<2*n; j++){\n                vector<L> tmp = getCommonTangentLine(jewel[i], jewel[j]);\n                copy(tmp.begin(), tmp.end(), back_inserter(tangent));\n            }\n        }\n        int ansmax = 1;\n        for(int i=0; i<(int)tangent.size(); i++){\n            int ans=0;\n            for(int j=0; j<n; j++){\n                if(distanceLP(tangent[i], jewel[2*j].p) +EPS > jewel[2*j].r &&\n                   distanceLP(tangent[i], jewel[2*j+1].p) < jewel[2*j+1].r +EPS){\n                    ans++;\n                }\n            }\n            ansmax = max(ansmax, ans);\n        }\n        cout << ansmax << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;     \ntypedef complex<D> P;  \ntypedef pair<P, P> L;  \nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) { return (conj(a)*b).Y;}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1,p-a1)/norm(a2-a1)*(a2-a1);\n}\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L>ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;\n    }\n  }\n  return ls;\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    P p[n];\n    double r[n],a,b;\n    int cost[n],sum=1;\n    rep(i,n){\n      cin>>a>>b>>r[i]>>cost[i];\n      p[i]=P(a,b);\n    }\n    rep(i,n)for(int j=i+1;j<n;j++){\n      vector<L>l=tangentLines(p[i],r[i],p[j],r[j]);\n      vector<L>l1=tangentLines(p[i],r[i]+cost[i],p[j],r[j]+cost[j]);\n      rep(k,l.size()){\n        int t=0;\n        rep(u,n)if(distLP(l[k].first,l[k].second,p[u])>=r[u]-EPS&&distLP(l[k].first,l[k].second,p[u])<=r[u]+cost[u]+EPS)t++;\n        sum=max(sum,t);\n      }\n      rep(k,l1.size()){\n        int t=0;\n        rep(u,n)if(distLP(l1[k].first,l1[k].second,p[u])>=r[u]-EPS&&distLP(l1[k].first,l1[k].second,p[u])<=r[u]+cost[u]+EPS)t++;\n        sum=max(sum,t);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &rpoint;\ntypedef pair<point,point> line;\n\ndouble cross(rpoint va, rpoint vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble distance_l_p(rpoint a, rpoint b, rpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nline tangent(point p, double r, double theta){\n\tpoint a = polar(r, theta);\n\tpoint b( imag(a), -real(a) );\n\n\treturn make_pair(p + a, p + a + b);\n}\n\nvector<line> common_tangent(point p1, double r1, point p2, double r2){\n\tvector<line> ret;\n\n\tp2 -= p1;\n\tdouble a = arg(p2);\n\tdouble b = (r1 - r2) / abs(p2);\n\tif( b < -1.0 || b > 1.0 ){ return ret; }\n\tdouble c = asin(b) - asin(1.0);\n\tret.push_back( tangent(p1, r1, a - c) );\n\tret.push_back( tangent(p1, r1, a + c) );\n\n\tb = (r1 + r2) / abs(p2);\n\tif( b < -1.0 || b > 1.0 ){ return ret; }\n\tc = asin(b) - asin(1.0);\n\tret.push_back( tangent(p1, r1, a - c) );\n\tret.push_back( tangent(p1, r1, a + c) );\n\treturn ret;\n}\n\nint n;\npoint p[50];\ndouble r[50];\ndouble m[50];\nint ans;\n\n\nvoid check(rpoint p1, double r1, rpoint p2, double r2){\n\tvector<line> v = common_tangent(p1, r1, p2, r2);\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tint c = 0;\n\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tdouble d = distance_l_p(v[i].first, v[i].second, p[j]);\n\t\t\tif( d > r[j] - EPS && d < m[j] + EPS ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = max(ans, c);\n\t}\n}\n\nint main(){\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tans = 1;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x, &y, &r[i], &m[i]);\n\t\t\tm[i] += r[i];\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; ++i)\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tcheck(p[i], r[i], p[j], r[j]);\n\t\t\tcheck(p[i], r[i], p[j], m[j]);\n\t\t\tcheck(p[i], m[i], p[j], r[j]);\n\t\t\tcheck(p[i], m[i], p[j], m[j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i, a) for(int i=0;i<(int)(a);i++)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n\n\ntypedef double D;\nconst D EPS = 1e-12;\ntypedef complex<D> P;\n\nnamespace std{\n  bool operator<(const P &a, const P &b){\n    return real(a) == real(b) ? imag(a) < imag(b): real(a) < real(b);\n  }\n}\n\nP unit(P p){ return p / abs(p);}\npair<P, P> norm(P p){ return make_pair(p*P(0, 1), p*P(0, -1));}\n\nD dot(P x, P y){ return real(conj(x)*y);}\nD cross(P x, P y){ return imag(conj(x)*y);}\n\nP rotate(P v, double s){\n  return P(real(v)*cos(s) - imag(v) * sin(s), real(v) * sin(s) + imag(v) * cos(s));\n}\n\nD arg(P a, P b, P c){ return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nD arg(D a, D b, D c){ return acos((b*b+c*c-a*a)/(2*b*c));}\n\ntypedef pair<P, P> L;\ntypedef pair<P, D> C;\n\nbool in_cir(C c, P x){ return (abs(x-c.fs) + EPS < c.sc);}\nbool on_cir(C c, P x){ return EQ(abs(x - c.fs), c.sc); }\n\nvector<L>adj_line(C c, P p){\n  vector<L>res;\n  if(in_cir(c,p)) return res;\n  if(on_cir(c, p)){\n    pair<P, P> n = norm(c.fs-p);\n    res.pb(L(n.fs + p, p));\n    return res;\n  }\n  D x = c.sc, z = abs(c.fs-p);\n  D y = sqrt(z*z-x*x);\n  D s = arg(y, x, z);\n  P v = unit(p -c.fs) * c.sc;\n\n  res.pb(L(rotate(v, s) + c.fs, p));\n  res.pb(L(rotate(v, -s) + c.fs, p));\n  return res;\n}\n\nvector<L> common_adj_line(C a, C b){\n  vector<L> res;\n  if(a.sc + EPS < b.sc) return common_adj_line(b, a);\n  if(EQ(real(a.fs), real(b.fs)) && EQ(imag(a.fs), imag(b.fs)) && EQ(a.sc, b.sc)) return res;\n  P pos = (b.fs - a.fs) * a.sc/(a.sc + b.sc) + a.fs;\n  if(!in_cir(a, pos)) res = adj_line(a, pos);\n\n  if(EQ(a.sc, b.sc)){\n    pair<P, P> n = norm(unit(b.fs - a.fs) * a.sc);\n    res.pb(L(a.fs+n.fs, b.fs + n.fs));\n    res.pb(L(a.fs + n.sc, b.fs + n.sc));\n  }else{\n    D c = abs(b.fs - a.fs);\n    pos = unit(b.fs-a.fs)*( (a.sc * c) / (a.sc - b.sc) ) + a.fs;\n    if(!in_cir(a, pos)){\n      vector<L>tmp = adj_line(a, pos);\n      rep(i, tmp.sz) res.pb(tmp[i]);\n    }\n  }\n  return res;\n}\n\nD dis(L a, P x){\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n  \nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<double> r(N);\n    vector<double> m(N);\n    vector<P> p(N);\n    rep(i, N){\n      int x, y;\n      cin >> x >> y >> r[i] >> m[i];\n      m[i] += r[i];\n      p[i] = P(x, y);\n    }\n\n    vector<L>cans;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tauto c1 = common_adj_line(C(p[i], r[i]), C(p[j], r[j]));\n\tcans.insert(cans.end(), c1.begin(), c1.end());\n\tauto c2 = common_adj_line(C(p[i], m[i]), C(p[j], r[j]));\n\tcans.insert(cans.end(), c2.begin(), c2.end());\t\n\tauto c3 = common_adj_line(C(p[i], r[i]), C(p[j], m[j]));\n\tcans.insert(cans.end(), c3.begin(), c3.end());\t\n\tauto c4 = common_adj_line(C(p[i], m[i]), C(p[j], m[j]));\n\tcans.insert(cans.end(), c4.begin(), c4.end());\t\n      }\n    }\n\n    int res = 1;\n    // cout << cans.size() << endl;\n    for(const auto &can : cans){\n      int cnt = 0;\n      for(int i=0;i<N;i++){\n\tD d = dis(can, p[i]);\n\t// cout << r[i] - EPS << \" \" << d << \" \" << m[i] + EPS << endl;\t\n\tif((r[i] + EPS < d || EQ(r[i], d)) && (d + EPS <  m[i] || EQ(d, m[i]))){\n\t  cnt++;\n\t}\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n// 2円の接線を求める。\nvector<Line> getTangentialLine(Circle a, Circle b)\n{\n\tvector<Line> ret;\n\tP2 v = b.c - a.c;\n\tdouble d = v.length();\n\tdouble bt = v.arg();\n\n\tif (d - abs(a.r - b.r) > EPS) // 外接線2本\n\t{\n\t\tdouble dt = acos((a.r - b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c + P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c + P2::polar(b.r, t2)));\n\t}\n\telse if (d - abs(a.r - b.r) > -EPS) // 外接線1本 (内接)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\tif (d - (a.r + b.r) > EPS) // 内接線2本 (離れている)\n\t{\n\t\tdouble dt = acos((a.r + b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c - P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c - P2::polar(b.r, t2)));\n\t}\n\telse if (d - (a.r + b.r) > -EPS) // 内接線1本 (接している)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\treturn ret;\n}\n\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct xyrm{ P2 p; double r, m; int i; };\n\t\tvector<xyrm> gems;\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(double, x, y, r, m);\n\t\t\tgems.push_back({ P2(x, y), r, m, _ });\n\t\t}\n\t\tint result = 1;\n\t\tfor (auto i : gems) for (auto j : gems)\n\t\t{\n\t\t\t//WRITE(\"i:\", i.i, \"j:\", j.i);\n\t\t\tauto cand = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r));\n\t\t\tauto cand2 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r));\n\t\t\tauto cand3 = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r + j.m));\n\t\t\tauto cand4 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r + j.m));\n\n\t\t\tvector<Line> lines;\n\t\t\tcopy(allof(cand), back_inserter(lines));\n\t\t\tcopy(allof(cand2), back_inserter(lines));\n\t\t\tcopy(allof(cand3), back_inserter(lines));\n\t\t\tcopy(allof(cand4), back_inserter(lines));\n\n\t\t\tfor (auto l : lines)\n\t\t\t{\n\t\t\t\t//WRITE(l.p, l.d);\n\t\t\t\tresult = max<int>(result, count_if(allof(gems), PREDICATE(xyrm, g, inRange(getDistance(l, g.p), g.r, g.r + g.m))));\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2201&lang=jp\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<Circle> Cir(2*N); vector<int> m(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r >> m[i];\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\n\t\t\tCir[i + N] = Circle(Point(x, y), r + m[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < 2*N;i++) {\n\t\t\tfor (int j = i + 1; j < 2*N;j++) {\n\t\t\t\tauto cp = tangent_cc(Cir[i], Cir[j]);\n\t\t\t\tfor (auto l : cp) {\n\t\t\t\t\tif (isnan(l.a.imag()) || isnan(l.a.real()) || isnan(l.b.imag()) || isnan(l.b.real()))continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int k = 0; k < N;k++) {\n\t\t\t\t\t\tld dist = dist_lp(l, Cir[k].p);\n\t\t\t\t\t\tif (dist < (Cir[k].r + eps))continue;\n\t\t\t\t\t\tif (dist > (Cir[k].r + m[k] + eps)) continue;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,e,d;\n\t\t\tcin>>a>>b>>e>>d;\n\t\t\tc.pb(C(P(a,b),e));\n\t\t\tc.pb(C(P(a,b),e+d));\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L>l,tmp;\n\t\trep(i,c.size())loop(j,i+1,c.size()){\n\t\t\ttmp=tangentCC(c[i],c[j]);\n\t\t\trep(i,tmp.size())l.pb(tmp[i]);\n\t\t}\n\t\tint out=0;\n\t\trep(i,l.size()){\n\t\t\tL t=l[i];\n\t\t\tint co=0;\n\t\t\trep(j,c.size()){\n\t\t\t\tdouble d=distanceLP(t,c[j].c);\n\t\t\t\tif(d+EPS>c[j].r&&d<c[j+1].r+EPS)co++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n// ÀW(xNg)\ntypedef complex<double> P;\n// ½p`(¶ñ]ðOñÆ·é)\ntypedef vector<P> G;\n// ¼ü\nstruct L : public vector<P>\n{\n\tL(P a, P b) { push_back(a); push_back(b); }\n};\n\n\n// î{Ö(è)\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\nvector<L> common_lineCC(P a, double ra, P b, double rb)\n{\n\tdouble k,kc; P s,t;\n\tkc = atan2(Y(b-a),X(b-a));\n\n\tvector<L> ret;\n\n\tfor(int i=-1; i<=1; i+=2)\n\tfor(int j=-1; j<=1; j+=2)\n\t{\n\t\tk = kc + j*asin( (rb+i*ra)/abs(b-a) );\n\t\ts = a  + polar( ra, k-i*j*PI/2);\n\t\tt = s  + polar(100.0, k);\n\n\t\tret.push_back( L(s,t) );\n\t}\n\n\treturn ret;\n}\n\ndouble s_distLP(P a, P b, P p)\n{\n\treturn abs(cross(b-a, p-a))/abs(b-a);\n}\n\n\nP p[64];\ndouble r[64],m[64];\nvector<L> line;\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> X(p[i]) >> Y(p[i]) >> r[i] >> m[i];\n\t\t}\n\n\t\tif(N==1)\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint mx=0,tm;\n\t\tfor(int i=0; i<N-1; i++)\n\t\tfor(int j=i+1; j<N; j++)\n\t\t{\n\t\t\tdouble ra[] = {r[i], r[i]+m[i]};\n\t\t\tdouble rb[] = {r[j], r[j]+m[j]};\n\n\t\t\tfor(int ii=0; ii<2; ii++)\n\t\t\tfor(int jj=0; jj<2; jj++)\n\t\t\t{\n\t\t\t\tline = common_lineCC(p[i],ra[ii],p[j],rb[jj]);\n\n\t\t\t\tfor(int k=0; k<4; k++)\n\t\t\t\t{\n\t\t\t\t\ttm=0; double dis;\n\t\t\t\t\tfor(int n=0; n<N; n++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis = s_distLP(line[k][0],line[k][1],p[n]);\n\t\t\t\t\t\tif( r[n]-EPS <= dis && dis<=r[n]+m[n]+EPS )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmx = max(tm,mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2012/12/15\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// 邱壼?縺ィ邱壼?縺ョ莠、蟾ョ蛻、螳壹?\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// 逶エ邱壹→蜀??莠、蟾ョ蛻、螳壹?謌サ繧雁?縺ッ莠、轤ケ縺ョ謨ー縲?int isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// 蜀?→蜀??莠、蟾ョ蛻、螳壹?\n//  0 : 莠、蟾ョ縲∝?蛹?↑縺?//  1 : 螟夜Κ縺ァ1轤ケ縺ィ謗・縺吶ｋ\n//  2 : 2轤ケ縺ァ莠、蟾ョ\n// -1 : 蜀?桁縺励※謗・縺吶ｋ\n// -2 : 螳悟?縺ォ蜀?桁\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// 逶エ邱壹→逶エ邱壹?莠、轤ケ縲?P getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross 縺ョ隨ヲ蜿キ髢「菫ゅ≠繧?  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// 逶エ邱壹→蜀??莠、轤ケ縲?vector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// 蜀?→蜀??莠、轤ケ縲?vector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\n\n// 2縺、縺ョ繝吶け繝医Ν縺ョ縺ェ縺呵ァ?0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// 繝吶け繝医Ν(1, 0)繧貞渕貅悶→縺励◆繝吶け繝医Ν縺ョ隗貞コヲ(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2縺、縺ョ逶エ邱壹↓謗・縺吶ｋ蜊雁セв縺ョ蜀?C getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = getAngle(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.o = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 繝倥Ο繝ウ縺ョ蜈ャ蠑上ｒ逕ィ縺?※荳芽ァ貞ス「縺ョ3霎コ縺ョ髟キ縺輔°繧蛾擇遨阪ｒ豎ゅａ繧?double heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// 螟夊ァ貞ス「縺ョ髱「遨?double getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// 荳芽ァ貞ス「縺ョ蜀?磁蜀??蜊雁セ?double getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nvector<L> getLine(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  int c = isIntersect(a, b);\n\n  if (c == -2) {\n    // there are no lines\n  } else if (abs(c) == 1) {\n    P cp = getCrossP(a, b)[0];\n    P base = b.o - a.o;\n    P n(-base.imag(), base.real());\n    res.push_back(L(cp, cp + n));\n  } else {\n    {\n      if (a.r == b.r) {\n        P base = b.o - a.o;\n        P n(-base.imag(), base.real());\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, b.o + n * a.r));\n        res.push_back(L(a.o - n * a.r, b.o - n * a.r));\n      } else {\n        double h = b.r - a.r;\n        double x = sqrt(norm(a.o - b.o) - h * h);\n        vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n        for (int i = 0; i < ps.size(); ++i) {\n          P n = ps[i] - b.o;\n          n /= abs(n);\n          res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n        }\n      }\n    }\n    {\n      double h = b.r + a.r;\n      double x = sqrt(norm(a.o - b.o) - h * h);\n      vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n      for (int i = 0; i < ps.size(); ++i) {\n        P n = b.o - ps[i];\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n      }\n    }\n  }\n\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconstexpr double eps = 1e-7;\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };ttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }ttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }ttt point<T> operator - (pca a) { return { -a.x, -a.y }; }ttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }ttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }ttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }ttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }ttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }ttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }ttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }ttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }ttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }ttt double length(pca p) { return sqrt(length_squared(p)); }ttt point<T> normalized(pca a) { return (1 / length(a)) * a; }ttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }ttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }ttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }template <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> struct line { point<T> a, b; };template <typename T> struct segment { point<T> a, b; };template <typename T> T length_squared(const segment<T> & p) { return length_squared(p.a - p.b); }template <typename T> double length(const segment<T> & p) { return length(p.a - p.b); }\ntemplate <typename T>T sq(T x) { return x * x; }\ntemplate <typename T>point<T> rotate_90(point<T> const & a) {return { - a.y, a.x };}template <typename T>point<T> rotate_270(point<T> const & a) {return { a.y, - a.x };}template <typename T>point<T> rotate_180(point<T> const & a) {return { - a.x, - a.y };}point<double> rotate(point<double> const & a, double th) {return {a.x * cos(th) - a.y * sin(th),a.x * sin(th) + a.y * cos(th) };}\nbool does_include(circle<double> const & a, point<double> const & b) {return length(a.p - b) < a.r + eps;}bool is_on_circumference(point<double> const & a, circle<double> const & b) {return std::abs(length(b.p - a) - b.r) < eps;}// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {return length(a.p - b.p) < std::abs(a.r - b.r) + eps;}// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {return length(a.p - b.p) < a.r + b.r + eps;}// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;}// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;}std::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {std::vector<point<double> > result;if (not does_intersect(a,b)) {// nop\n} else if (does_include(a,b) and not does_inscribe(a,b)) {// truly included\n// nop\n} else if (does_inscribe(a,b) or does_circumscribe(a,b)) {result.push_back(a.r * normalized(b.p - a.p));} else {//       c\n//      /|        // a.r / |  b.r\n//    /th|          //   a-------b\n//       l\ndouble l = length(b.p - a.p);double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\ndouble as = sqrt( sq(a.r) - sq(ac) );point<double> e = normalized(b.p - a.p);result.push_back(a.p + ac*e + as*rotate_90(e));result.push_back(a.p + ac*e + as*rotate_270(e));}return result;}std::vector<line<double> > common_tangents(circle<double> const & a, point<double> const & b) {std::vector<line<double> > result;if (does_include(a,b) and not is_on_circumference(b,a)) {// truly included\n// nop\n} else if (is_on_circumference(b,a)) {point<double> e = normalized(a.p - b);result.push_back({b + rotate_90(e),b + rotate_270(e) });} else {double theta = acos(a.r / length(b - a.p));result.push_back({ b, b + rotate(a.p - b, + theta) });result.push_back({ b, b + rotate(a.p - b, - theta) });}return result;}std::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {point<double> p = (a.r / (a.r + b.r)) * (b.p - a.p);return common_tangents(a,p);}std::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {if (b.r < a.r) std::swap(a,b);std::vector<line<double> > result;if (does_include(a,b) and not does_inscribe(b,a)) {// truly included\n// nop\n} else if (does_inscribe(b,a)) {point<double> e = normalized(a.p - b.p);result.push_back({b.p + a.r*e + rotate_90(e),b.p + a.r*e + rotate_270(e) });} else {point<double> d = b.p - a.p;double theta = asin((b.r - a.r) / length(d));point<double> dp = rotate(d, theta);point<double> dm = rotate(d, theta);point<double> ep = rotate_90(normalized(dp));point<double> em = rotate_270(normalized(dm));result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });}return result;}std::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {std::vector<line<double> > result;for (auto l : common_inner_tangents(a,b)) result.push_back(l);for (auto l : common_outer_tangents(a,b)) result.push_back(l);return result;}double distance(line<double> const & a, point<double> const & b) {point<double> p = b   - a.a;point<double> q = a.b - a.a;return std::abs( cross(p, normalized(q)) );}\nusing namespace std;\nusing namespace boost;\nint main() {\n    int age = 0;\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point<double> > p(n); vector<double> r(n), m(n);\n        for (int i : irange(0,n)) cin >> p[i] >> r[i] >> m[i];\n        if (n <= 2) {\n            cout << n << endl;\n            continue;\n        }\n        vector<circle<double> > cs(2*n);\n        for (int i : irange(0,n)) {\n            cs[2*i].p = p[i];\n            cs[2*i].r = r[i];\n            cs[2*i+1].p = p[i];\n            cs[2*i+1].r = r[i]+m[i];\n        }\n        vector<line<double> > ls;\n        for (int i : irange(0,2*n)) {\n            for (int j : irange(i+1,2*n)) {\n                for (auto l : common_tangents(cs[i], cs[j])) {\n                    ls.push_back(l);\n                }\n            }\n        }\n        int result = 0;\n        for (auto l : ls) {\n            int jewels = 0;\n            for (int i : irange(0,n)) {\n                double d = distance(l, p[i]);\n                if (r[i] < d + eps and d < r[i]+m[i] + eps) {\n                    jewels += 1;\n                }\n            }\n            result = max(result, jewels);\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\nusing namespace std;\n#define int long long\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-13;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\t\t\t\t\t   // 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n\n\nD distLP(P a1, P a2, P p) {\n\treturn abs(proj(a1, a2, p) - p);\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<L> tangentLines(P a, D ar, P b, D br) {\n\tvector<L> ls;\n\tD d = abs(b - a);\n\tfor (int i = 0; i < 2; i++) {\n\t\tD sin = (ar - (1 - i * 2)*br) / d;\n\t\tif (!LE(sin*sin, 1)) break;\n\t\tD cos = sqrt(max(1 - sin*sin, 0.0));\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tP n = (b - a) * P(sin, (1 - j * 2)*cos) / d;\n\t\t\tls.push_back(L(a + ar*n, b + (1 - i * 2)*br*n));\n\t\t\tif (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n\t\t}\n\t}\n\treturn ls;\n}\n\nsigned main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> m(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t}\n\t\tint res = 1;\n\t\tvector<L> ls;\n\t\tvector<L> tls;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\ttls = tangentLines(P(x[i], y[i]), r[i], P(x[j], y[j]), r[j] + m[j]);\n\t\t\t\tfor (auto l : tls) ls.push_back(l);\n\t\t\t\ttls = tangentLines(P(x[i], y[i]), r[i] + m[i], P(x[j], y[j]), r[j]);\n\t\t\t\tfor (auto l : tls) ls.push_back(l);\n\t\t\t\ttls = tangentLines(P(x[i], y[i]), r[i], P(x[j], y[j]), r[j]);\n\t\t\t\tfor (auto l : tls) ls.push_back(l);\n\t\t\t\ttls = tangentLines(P(x[i], y[i]), r[i] + m[i], P(x[j], y[j]), r[j] + m[j]);\n\t\t\t\tfor (auto l : tls) ls.push_back(l);\n\t\t\t}\n\t\t}\n\t\tfor (auto l : ls) {\n\t\t\tint tmp = 0;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tdouble t = distLP(l.first, l.second, P(x[k], y[k]));\n\t\t\t\tif (t > r[k] - EPS && t < r[k] + m[k] + EPS) {\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//You should copy the whole file because yank can copy only up to 50 lines or so.\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> point;\ntypedef point vec;\ntypedef array<point, 2> line;\ntypedef vector<point> poly;\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > EPS) return CCW; // ccw\n\tif (cross(b, c) < -EPS) return CW; // cw\n\tif (dot(b, c) < 0) return CAB; // c - a - b\n\tif (norm(b) < norm(c)) return ABC; // a - b - c\n\treturn ERROR;\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nline CapCS(circle c, line s) {\n\tpoint inf(INF, INF);\n\tvector<point> cros = CrosspointCS(c, s);\n\tif (cros.empty()) return line{inf, inf};\n\n\tif (cros.size() == 1) {\n\t\tdouble ad = abs(s[0]-c.c);\n\t\tdouble bd = abs(s[1]-c.c);\n\t\tif (ad < min(bd, c.r)) cros.emplace_back(s[0]);\n\t\telse if (bd < min(ad, c.r)) cros.emplace_back(s[1]);\n\t\telse {\n\t\t\tpoint p = cros[0];\n\t\t\tcros.emplace_back(p); // avoid an undefined behavior\n\t\t}\n\t}\n\n\tif (cros[1] < cros[0]) {\n\t\tswap(cros[0], cros[1]);\n\t}\n\n\treturn line{cros[0], cros[1]};\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\nvoid solve(int n){\n\tvector<line> v;\n\tint ans=0;\n\tcircle c[50][2];\n\tfor(int i=0;i<n;++i){\n\t\tdouble x,y,r,s;\n\t\tcin>>x>>y>>r>>s;\n\t\tc[i][0]=((circle){point (x,y),r});//inside\n\t\tc[i][1]=((circle){point (x,y),r+s});//outside\n\t}\n\tif(n<=2){//to avoid bugs\n\t\tcout<<n<<endl;\n\t\treturn;\n\t}\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\tfor(int l=0;l<2;++l){\n\t\t\t\t\tvector<line> w=CommonTangents(c[i][k],c[j][l]);\n\t\t\t\t\tfor(int m=0;m<w.size();++m){\n\t\t\t\t\t\tv.pb(w[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int m=0;m<v.size();++m){\n\t\tint a=0;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(CrosspointCL(c[i][0],v[m]).size()<2&&CrosspointCL(c[i][1],v[m]).size()>0){\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,a);\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 保存 linesOfCommonTangent のデバッグをせよ\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point {\npublic:\n\n  double x,y;\n \n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point(Point const &p) : x(p.x), y(p.y) {}\n\n  Point operator + (const Point &p) const {\n    return Point( x+p.x , y+p.y );\n  }\n  Point operator - (const Point &p) const {\n    return Point( x-p.x , y-p.y );\n  }\n  Point operator * (double a) const {\n    return Point( a*x , a*y );\n  }\n  Point operator / (double a) const {\n    return Point( x/a , y/a );\n  }\n\n  double abs() {\n    return sqrt(norm());\n  }\n  double norm() {\n    return x*x+y*y;\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return equal( x,p.x )&& equal( y,p.y );\n  }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a,Vector b) {\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b) {\n  return a.x*b.y - b.x*a.y;\n}\n\nstruct Circle {\n  Circle(Point p, double r) : p(p), r(r) {}\n  Point p; double r;\n};\nbool operator < (const Circle& a, const Circle& b) { return a.r<b.r; }\n\ntypedef Point Vector;\nVector polar(double a, double rad) {\n  return Vector(a*cos(rad), a*sin(rad));\n}\n\nVector rotate(const Vector &v, double rad) {\n  return Vector(cos(rad)*v.x-sin(rad)*v.y, sin(rad)*v.x+cos(rad)*v.y);\n}\n\n#define SQ(x) ((x)*(x))\ndouble distancePP(const Point &a, const Point &b) {\n  return sqrt(SQ(a.x-b.x) + SQ(a.y-b.y));\n}\n\nstruct Line : public vector<Point>\n{\n  Line(Point a, Point b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\nPoint proj(const Line &l, const Point &p) {\n  double k = dot(p - l[0], l[0]-l[1]) / (l[0]-l[1]).norm();\n  return l[0] + (l[0]-l[1])*k;\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return (p-proj(l, p)).abs();\n}\n\nvector<Line> linesOfCommonTangent(Circle a, Circle b) {\n  \n  vector<Line> ret;\n  \n  // on\n  const Circle &mx = max(a, b);\n  const Circle &mn = min(a, b);\n  double d = distancePP(a.p, b.p);\n  double rdif = mx.r - mn.r;\n  double rad = asin(rdif/d);\n  \n  Vector V1(mx.p-mn.p); rotate(V1, rad);\n  Vector V2(V1); rotate((V2/V2.abs())*mn.r, M_PI/2.);\n  ret.push_back(Line(V2, V2+V1));\n  \n  V1 = mx.p-mn.p; rotate(V1, -rad);\n  V2 = V1; rotate((V2/V2.abs())*mn.r, -M_PI/2.);\n  ret.push_back(Line(V2, V2+V1));\n  \n  // cross\n  double rsum = mx.r+mn.r;\n  rad = acos(rsum/d);\n  V1 = mn.p-mx.p; rotate(V1, rad);\n  V2 = V1; rotate(V2, -M_PI/2.); V2 = (V2 / V2.abs()) * mx.r;\n  ret.push_back(Line(V2, V2+V1));\n  \n  rad = M_PI/2.-rad;\n  V1 = mx.p-mn.p; rotate(V1, -rad); V1 = (V1 / V1.abs()) * mn.r;\n  V2 = V1; rotate(V2, M_PI/2.);\n  ret.push_back(Line(V2, V2+V1));\n  \n  return ret;\n}\n\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    vector<Circle> cls;\n    double x, y, r, m; cin >> x >> y >> r >> m;\n    cls.push_back(Circle(Point(x, y), r));\n    cls.push_back(Circle(Point(x, y), r+m));\n  \n    vector<Line> lines;\n    for(int i=0; i<cls.size(); i++)\n      for(int j=i+1; j<cls.size(); j++) {\n        vector<Line> ls = (linesOfCommonTangent(cls[i], cls[j]));\n        for(int k=0; k<ls.size(); k++) {\n          lines.push_back(ls[k]);\n          cout << \"(\" << ls[k][0].x << \", \" << ls[k][0].y << \")\" << endl;\n          cout << \"(\" << ls[k][1].x << \", \" << ls[k][1].y << \")\" << endl;\n        }\n      }\n  \n    int ans = 0;\n    for(int i=0; i<lines.size(); i++) {\n      int cnt = 0;\n      for(int j=0; j<cls.size(); j++) {\n        if(distanceLP(lines[i], cls[j].p) <= cls[j].r + EPS) cnt ++;\n      }\n      ans = max(ans, cnt);\n    }\n  \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <complex>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\n\n\n\nconst double EPS = 1e-5;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nvector<C> houseki;\nvector<C> power;\nint N;\n\nvoid init() {\n  houseki.clear();\n  power.clear();\n}\n\nvector<L> lines(C c1, C c2) {\n  P o1 = c1.p;\n  P o2 = c2.p;\n  double r1 = c1.r;\n  double r2 = c2.r;\n  double d = abs(o1 - o2);\n\n  if (d > r1 + r2) {\n    \n  }\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n/*\nP reflection(const L &l, const P &p) {\n  return p + 2 * (projection(l, p) - p);\n}\n*/\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n\nbool intersectA(C c, L l) {\n  double d = distanceLP(l, c.p);\n  double r = c.r;\n  return r - d > EPS;\n}\nbool intersectB(C c, L l) {\n  double d = distanceLP(l, c.p);\n  double r = c.r;\n  return r - d > -EPS;\n}\n\nvector<L> commonTangents(const C& c1, const C& c2)\n{\n  P o1 = c1.p;\n  P o2 = c2.p;\n  double r1 = c1.r;\n  double r2 = c2.r;\n    double a = abs(o2 - o1);\n    if (a < EPS) { return vector<L>(); }\n\n    vector<L> rslt;\n    P rot = (o2 - o1) / a;\n    \n    double xs[] = {r1 * (r1 + r2) / a, r1 * (r1 - r2) / a};\n    for (int i = 0; i < 2; ++i) {\n        double x1 = xs[i];\n        if (x1 < -r1 || r1 < x1) { continue; }\n\n        double ys[] = {sqrt(r1 * r1 - x1 * x1), -sqrt(r1 * r1 - x1 * x1)};\n        for (int j = 0; j < 2; ++j) {\n            double y1 = ys[j];\n            // これは接点が１つしかない場合。y1 が 0 になる。\n            if (abs(y1) < EPS) {\n                rslt.push_back(L(P(x1, 0), P(x1, 1)));\n                break;\n            }\n            \n            double x2 = (a * y1 * y1 + x1 * r1 * r1) / (r1 * r1);\n            if (x2 < a - r2 || a + r2 < x2) { continue; }\n            double y2 = (r1 * r1 - x1 * x2) / y1;\n            P p1 = P(x1, y1) * rot + o1;\n            P p2 = P(x2, y2) * rot + o1;\n            rslt.push_back(L(p1, p2));\n        }\n    }\n\n    return rslt;\n}\n\nvoid solve() {\n  if (N == 1) {\n    printf(\"1\\n\");\n    return;\n  }\n  vector<C> circles(houseki.begin(), houseki.end());\n  circles.insert(circles.end(), power.begin(), power.end());\n  int mn = 0;\n  for (int i = 0; i < circles.size(); i++) {\n    for (int j = i + 1; j < circles.size(); j++) {\n      vector<L> ls = commonTangents(circles[i], circles[j]);\n      for (int k = 0; k < ls.size(); k++) {\n        int cnt = 0;\n        for (int m = 0; m < N; m++) {\n          if (!intersectA(houseki[m], ls[k]) &&\n              intersectB(power[m], ls[k])) {\n            cnt++;\n          }\n        }\n        mn = max(cnt, mn);\n      }\n    }\n  }\n  printf(\"%d\\n\", mn);\n}\n\nint main() {\n  while (true) {\n    cin >> N;\n    init();\n\n    if (N == 0) {\n      return 0;\n    }\n    for (int i = 0;  i < N; i++) {\n      int x, y, r, m;\n      cin >> x >> y >> r >> m;\n      houseki.push_back(C(P(x, y), r));\n      power.push_back(C(P(x, y), r + m));\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator<(const P& a,const P& b) {\n    return abs(a.real()-b.real()<EPS)?a.imag()<b.imag():a.real()<b.real();\n  }\n};\n\nstruct Circle {\n  P c;\n  double r;\n  Circle( P c=P(0,0), double r=0 ):c(c),r(r){}\n};\n\ndouble dot( P a, P b ){ return a.real() * b.real() + a.imag() * b.imag(); }\n\nP rotate( P v, double rad ){\n  return v * P( cos(rad), sin(rad) );\n}\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n \nP reflect(P p, L l){\n  return p + (proj(p,l) - p) * 2.0;\n}\n \nvector<L> tangentCC( Circle p, Circle q ){\n  vector<L> ret;\n  if( p.r < q.r ) swap( p, q );\n  //外接線\n  P v = q.c - p.c;\n  //cout << p.c << \" - \" << q.c << \" \"<<  v << endl;\n  if( abs( abs(v) + q.r - p.r ) < EPS ) {//外接戦一つ\n    P p1 = p.c + v/abs(v) * ( abs(v) + q.r );\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L( p1, p2) );\n    return ret;\n  } else if( abs(v) + q.r < p.r ) return ret; //接戦無し \n  double z = sqrt( abs(norm(v) - (p.r-q.r)*(p.r-q.r)) );\n  v = rotate( -v, acos(min(1.0,z/abs(v))) )/abs(v) * z + q.c - p.c;\n  if( abs(v)<EPS ){ v = q.c - p.c; v = P( -v.imag(), v.real() ); }   \n  v /= abs(v);\n  //cout << \"rotate: \" << v << endl;\n  L s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );\n  //内接線\n  v = q.c - p.c;\n  if( abs( abs(v) - p.r-q.r ) < EPS ){//内接線一つ\n    P p1 = p.c + v/abs(v) * p.r;\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L(p1,p2) );\n    return ret;\n  } else if( abs(v) - p.r-q.r < EPS ){//内接線なし\n    return ret;\n  }\n  P v1 = rotate( v, acos((p.r+q.r)/abs(v)) )/abs(v);\n  P p1 = p.c + v1 * p.r;\n  P p3 = reflect( p1, L(p.c,q.c) );\n  v1 = rotate( -v, acos((p.r+q.r)/abs(v)) )/abs(v);\n  P p2 = q.c + v1 * q.r;\n  P p4 = reflect( p2, L(p.c, q.c) ); \n  ret.push_back( L( p1,p2 ) );\n  ret.push_back( L( p3,p4 ) );\n  return ret;\n}\n\nint N;\n\nint main(){\n  while(cin >> N && N){\n    vector<Circle> C;\n    vector<Circle> M;\n    for(int i=0;i<N;i++){\n      int x,y,r,m;\n      cin >> x >> y >> r >> m;\n      C.push_back( Circle( P(x,y), r ) );\n      M.push_back( Circle( P(x,y), r+m ) );\n    }  \n\n\n    vector<L> line;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<L> nl = tangentCC( C[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( C[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n      }\n    }\n\n    if( N < 2 ) {\n      cout << N << endl;\n      continue;\n    }\n\n    int res = 0;\n    for(int i=0;i<(int)line.size();i++){\n      int cnt = 0;\n      //cout << line[i].first << \" - \" << line[i].second << endl;\n      for(int j=0;j<N;j++){\n        double x = abs(C[j].c - proj( C[j].c, line[i] ));        \n        //cout << j << \": \" << x << \"  \"<< C[j].r << \" \" << M[j].r << endl;\n        if( C[j].r < x+EPS && x < M[j].r+EPS ) cnt++;\n      }\n      res = max( res, cnt );\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(cross((l.b - l.a), (p - l.a))) / abs(l.b - l.a);\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tif(dot((s.b - s.a), (p - s.a)) < 0) return abs(p - s.a);\n\tif(dot((s.a - s.b), (p - s.b)) < 0) return abs(p - s.b);\n\treturn dist(line(s.a, s.b), p);\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline bool intersect(const circle& c, const segment& s) {\n\treturn dist(s, c.c) < c.r + EPS;\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn abs(res) * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\n// 三角形と点の包含関係，境界は含まない．\n// 含める場合は == -1を <= 0とする．\nbool contain_triangle(const polygon& triangle, const point& p) {\n\tconst int d1 = ccw(p, triangle[0], triangle[1]), d2 = ccw(p, triangle[1], triangle[2]), d3 = ccw(p, triangle[2], triangle[0]);\n\treturn !(d1 * d2 == -1 || d2 * d3 == -1 || d3 * d1 == -1);\n}\n\n// 多角形と点の包含関係．境界を含む．\nbool contain(const polygon& P, const point& p) {\n\tconst int n = P.size();\n\tbool res = false;\n\tfor(int i = 0; i < n; ++i) {\n\t\tpoint v1 = P[i] - p, v2 = P[(i + 1) % n] - p;\n\t\tif(v1.y > v2.y)\n\t\t\tswap(v1, v2);\n\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS)\n\t\t\tres = !res;\n\n\t\tif(abs(cross(v1, v2)) < EPS && dot(v1, v2) < EPS)\n\t\t\treturn true; // 境界を含まないなら，falseにする．\n\t}\n\n\treturn res;\n}\n\nint cnt(const vector<circle>& jewels, const vector<circle>& mags, const vector<line>& vl) {\n\tint res = 0;\n\tfor(int i = 0; i < (int)vl.size(); ++i) {\n\t\tint cnt = 0;\n\t\tfor(int j = 0; j < (int)jewels.size(); ++j) {\n\t\t\tconst double d = dist(vl[i], jewels[j].c);\n\t\t\tif(jewels[j].r < d + EPS && d < mags[j].r + EPS)\n\t\t\t\t++cnt;\n\t\t}\n\t\tchmax(res, cnt);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<circle> jewels, mags;\n\t\tjewels.reserve(n);\n\t\tmags.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tconst point pos(x, y);\n\t\t\tjewels.push_back(circle(pos, r));\n\t\t\tmags.push_back(circle(pos, r + m));\n\t\t}\n\n\t\tint ans = (n > 1 ? 2 : 1);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tchmax(ans, cnt(jewels, mags, tangent(jewels[i], jewels[j])));\n\t\t\t\tchmax(ans, cnt(jewels, mags, tangent(jewels[i], mags[j])));\n\t\t\t\tchmax(ans, cnt(jewels, mags, tangent(mags[i], jewels[j])));\n\t\t\t\tchmax(ans, cnt(jewels, mags, tangent(mags[i], mags[j])));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define EPS (1e-12)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n    Point operator / ( Point p ) { return Point((x*p.x+y*p.y)/(p.x*p.x+p.y*p.y), (y*p.x-x*p.y)/(p.x*p.x+p.y*p.y)); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble arg(Vector p){ return atan2(p.y, p.x); }\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// verified by 920, 833, uoa2062\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n// 10514\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getTangentPoints(Point p, Circle c){\n  double d = abs(c.c - p);\n  double t = arg(c.c - p);\n  double b = sqrt(d*d - c.r * c.r);\n  double a = asin(c.r / d);\n  Point p1 = p + polar(b, t + a);\n  Point p2 = p + polar(b, t - a);\n  return make_pair(p1, p2);\n}\n\n/*\n return tangent points on c1\n */\nvector<Point> getCommonTangent(Circle c1, Circle c2){\n  vector<Point> tp;\n  Point base = c2.c - c1.c;\n  double l = abs(base);\n  double a = arg(base); // base alpha\n  if ( abs(c1.r - c2.r) < l  ){\n    double th1 = acos((c1.r - c2.r)/l);\n    tp.push_back(c1.c + polar(c1.r, a + th1));\n    tp.push_back(c1.c + polar(c1.r, a - th1));\n    if ( c1.r + c2.r < l ){\n      double th2 = acos((c1.r + c2.r)/l);\n      tp.push_back(c1.c + polar(c1.r, a + th2));\n      tp.push_back(c1.c + polar(c1.r, a - th2));\n    }\n  }\n\n  if ( (equals(l, abs(c1.r - c2.r)) || equals(c1.r + c2.r, l) ) && !equals(l, 0) ) {\n    tp.push_back(c1.c + polar(c1.r, a));\n  }\n  \n  return tp;\n}\n\nint N;\nCircle C[50];\nCircle T[100]; // target circle\nint M[50];\n\nint solve(){\n  if ( N == 1 ) return 1;\n  vector<Line> L;\n\n  for ( int i = 0; i < N; i++ ) {\n    T[i] = C[i];\n    T[i+N] = Circle(C[i].c, C[i].r + M[i]);\n  }\n\n  for ( int i = 0; i < 2*N-1; i++ ){\n    for ( int j = i+1; j < 2*N; j++ ){\n      vector<Point> ap = getCommonTangent(T[i], T[j]);\n      for ( int k = 0; k < ap.size(); k++ ){\n\tVector v = ap[k] - T[i].c;\n\tv = polar(abs(v), arg(v) + acos(-1)/2.0);\n\tL.push_back(Line(ap[k], ap[k] + v));\n      }\n    }\n  }\n\n  int ans = 0;\n  for ( int l = 0; l < L.size(); l++ ){\n    int cnt = 0;\n    for ( int i = 0; i < N; i++ ){\n      double d = getDistanceLP(L[l], C[i].c);\n      if ( dle(C[i].r, d) && dle(d, C[i].r + M[i]) ) cnt++;\n    }\n    ans = max(ans, cnt);\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    for ( int i = 0; i < N; i++ ){\n      cin >> C[i].c.x >> C[i].c.y >> C[i].r >> M[i];\n    }\n    cout << solve() << endl;\n  }\n\t\t\t  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (a.p - b.p)/d;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*v*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*v*P(0, 1)));\n\t} else {\n\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\t//P q = a.p + v*t;\n\tP q = (a.p*b.r + b.p*a.r)/(a.r+b.r);\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2012/12/15\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// 邱壼?縺ィ邱壼?縺ョ莠、蟾ョ蛻、螳壹?\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// 逶エ邱壹→蜀??莠、蟾ョ蛻、螳壹?謌サ繧雁?縺ッ莠、轤ケ縺ョ謨ー縲?int isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// 蜀?→蜀??莠、蟾ョ蛻、螳壹?\n//  0 : 莠、蟾ョ縲∝?蛹?↑縺?//  1 : 螟夜Κ縺ァ1轤ケ縺ィ謗・縺吶ｋ\n//  2 : 2轤ケ縺ァ莠、蟾ョ\n// -1 : 蜀?桁縺励※謗・縺吶ｋ\n// -2 : 螳悟?縺ォ蜀?桁\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// 逶エ邱壹→逶エ邱壹?莠、轤ケ縲?P getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross 縺ョ隨ヲ蜿キ髢「菫ゅ≠繧?  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// 逶エ邱壹→蜀??莠、轤ケ縲?vector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// 蜀?→蜀??莠、轤ケ縲?vector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\n\n// 2縺、縺ョ繝吶け繝医Ν縺ョ縺ェ縺呵ァ?0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// 繝吶け繝医Ν(1, 0)繧貞渕貅悶→縺励◆繝吶け繝医Ν縺ョ隗貞コヲ(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2縺、縺ョ逶エ邱壹↓謗・縺吶ｋ蜊雁セв縺ョ蜀?C getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = getAngle(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.o = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 繝倥Ο繝ウ縺ョ蜈ャ蠑上ｒ逕ィ縺?※荳芽ァ貞ス「縺ョ3霎コ縺ョ髟キ縺輔°繧蛾擇遨阪ｒ豎ゅａ繧?double heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// 螟夊ァ貞ス「縺ョ髱「遨?double getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// 荳芽ァ貞ス「縺ョ蜀?磁蜀??蜊雁セ?double getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nvector<L> getLine(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  int c = isIntersect(a, b);\n\n  if (c == -2) {\n    // there are no lines\n  } else if (abs(c) == 1) {\n    P cp = getCrossP(a, b)[0];\n    P base = b.o - a.o;\n    P n(-base.imag(), base.real());\n    res.push_back(L(cp, cp + n));\n  } else {\n    {\n      if (a.r == b.r) {\n        P base = b.o - a.o;\n        P n(-base.imag(), base.real());\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, b.o + n * a.r));\n        res.push_back(L(a.o - n * a.r, b.o - n * a.r));\n      } else {\n        double h = b.r - a.r;\n        double x = sqrt(norm(a.o - b.o) - h * h);\n        vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n        for (int i = 0; i < ps.size(); ++i) {\n          P n = ps[i] - b.o;\n          n /= abs(n);\n          res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n        }\n      }\n    }\n    {\n      double h = b.r + a.r;\n      double x = sqrt(norm(a.o - b.o) - h * h);\n      vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n      for (int i = 0; i < ps.size(); ++i) {\n        P n = b.o - ps[i];\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n      }\n    }\n  }\n\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-5)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool iscrossCL1(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\nbool iscrossCL2(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<eps)return true;\n  return false;\n}\n\nvector<Line> getLines(Circle a,Circle b){\n  vector<Line> V;\n  double d=abs(b.c-a.c);\n  Vector v=(b.c-a.c)/d,v1=v*a.r,v2=v*b.r;\n  double c,s;\n  Point p1,p2;\n\n  c=sqrt(d*d-(a.r-b.r)*(a.r-b.r));\n  s=(180*asin(c/d))/pi;\n\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,180+s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,180-s);\n  V.push_back(Line(p1,p2));\n\n  c=sqrt(d*d-(a.r+b.r)*(a.r+b.r));\n  s=(180*asin(c/d))/pi;\n\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,360-s);\n  V.push_back(Line(p1,p2));\n\n  return V;\n}\n\nint main()\n{\n  int n,a,b,c,d;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<pair<Circle,Circle> > v;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d;\n      v.push_back(mp(Circle(Point(a,b),c),Circle(Point(a,b),c+d)));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tvector<Line> V;\n\tvector<Line> v1=getLines(v[i].f,v[j].f);\n\tvector<Line> v2=getLines(v[i].f,v[j].s);\n\tvector<Line> v3=getLines(v[i].s,v[j].f);\n\tvector<Line> v4=getLines(v[i].s,v[j].s);\n\tV.insert(V.begin(),v1.begin(),v1.end());\n\tV.insert(V.begin(),v2.begin(),v2.end());\n\tV.insert(V.begin(),v3.begin(),v3.end());\n\tV.insert(V.begin(),v4.begin(),v4.end());\n\tfor(int k=0;k<V.size();k++){\n\t  int sum=0;\n\t  for(int z=0;z<n;z++){\n\t    if(!iscrossCL1(v[z].f,V[k]) && iscrossCL2(v[z].s,V[k]))sum++;\n\t  }\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n#include<complex>\ntypedef complex<ld> Point;\nconst ld pi = acos(-1.0);\nld dot(Point a, Point b) { return real(conj(a)*b); }\nld cross(Point a, Point b) { return imag(conj(a)*b); }\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nstruct Line {\n\tPoint a, b;\n};\nstruct Circle {\n\tPoint p; ld r;\n};\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//counter clockwise\n\tif (cross(b, c) < -eps)return -1;//clock wise\n\tif (dot(b, c) < 0)return 2;//c--a--b on line\n\tif (norm(b) < norm(c))return -2;//a--b--c on line\n\treturn 0; //a--c--b on line\n}\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r*c.r);\n\tif (isnan(l))return res;\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line{ p, p + v1 });\n\tif (l < eps)return res;\n\tres.push_back(Line{ p,p + v2 });\n\treturn res;\n}\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p*c2.r + c2.p*c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p*c2.r + c2.p*c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1)*c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1)*c1.r;\n\t\tres.push_back(Line{ q1,q1 + v });\n\t\tres.push_back(Line{ q2,q2 + v });\n\t}\n\treturn res;\n}\nint n;\nint calc(Line &l, vector<Circle> &c, vector<ld> &adr) {\n\tint ret = 0;\n\trep(i, n) {\n\t\tld dist = dist_lp(l, c[i].p);\n\t\tif (c[i].r - eps <= dist && dist <= c[i].r + adr[i] + eps)ret++;\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tvector<Circle> c(n);\n\tvector<ld> adr(n);\n\trep(i, n) {\n\t\tld x, y, r, m; cin >> x >> y >> r >> m;\n\t\tc[i] = { {x,y},r };\n\t\tadr[i] = m;\n\t}\n\tint ans = 1;\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(l, 2) {\n\t\t\t\t\tCircle le = c[i];\n\t\t\t\t\tle.r += adr[i] * k;\n\t\t\t\t\tCircle ri = c[j];\n\t\t\t\t\tri.r += adr[j] * l;\n\t\t\t\t\tvector<Line> v = tangent_cc(le, ri);\n\t\t\t\t\trep(x, v.size()) {\n\t\t\t\t\t\tLine &L = v[x];\n\t\t\t\t\t\tint num = calc(L, c, adr);\n\t\t\t\t\t\tans = max(ans, num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\t//init();\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint N;\ndouble r[100],m[50];\nP p[50];\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tdouble x,y;\n\t\trep(i,N){\n\t\t\tcin>>x>>y>>r[i]>>m[i];\n\t\t\tp[i]=p[N+i]=P(x,y);\n\t\t\tr[N+i]=r[i]+m[i];\n\t\t}\n\t\tint ans=0;\n\t\trep(i,N*2)for(int j=i+1;j<N*2;j++){\n\t\t\tP p1=p[i],r1=r[i],p2=p[j],r2=r[j],p3=p2-p1;\n\t\t\tP P1=p1+p3/abs(p3)*r1*P(0.0,1.0),P2=p1+(p3)/abs(p3)*r1/P(0.0,1.0);\n\t\t\tP P3=p2+p3/abs(p3)*r2*P(0.0,1.0),P4=p2+(p3)/abs(p3)*r2/P(0.0,1.0);\n\t\t\tL l[]={L(P1,P3),L(P1,P4),L(P2,P3),L(P2,P4)};\n\t\t\trep(h,4){\n\t\t\t\tint res=0;\n\t\t\t\trep(k,N)if(r[k]-EPS<distanceLP(l[h],p[k])&&distanceLP(l[h],p[k])<r[k]+m[k]+EPS)res++;\n\t\t\t\tans=max(ans,res);\n\t\t\t}\n\t\t}\n\t\tcout<<(ans>0?ans:1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  elem rEx1 = pow( pow(D,2.0) - pow((r2-r1),2.0) + pow(r1,2.0), 0.5);\n  elem rEx2 = pow( pow(D,2.0) - pow((r2-r1),2.0) + pow(r2,2.0), 0.5);\n  intersection_circles( circle(c1.c, rEx1), c2, pcross );\n  intersection_circles( circle(c2.c, rEx2), c1, pcross2 );\n  ret[0] = line(pcross2.second,pcross.first);\n  ret[1] = line(pcross2.first,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n\n  //internal\n  point In((r2*c1.c+r1*c2.c)/(r1+r2));\n  elem rIn = pow( pow(abs(c1.c-In),2.0)-(r1*r1), 0.5 );\n  intersection_circles( circle(In,rIn), c1, pcross );\n  ret[2] = line(In,pcross.first);\n  ret[3] = line(In,pcross.second);\n\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  /*\n  int num;\n  line test[4];\n  num = circles_tangential( circle(point(1,1),1), circle(point(4,4),4), test );\n  for(int i = 0; i < num; ++i){\n    cout << \"TANGENTIAL \" << i << \":\" << test[i].first << \"-\" << test[i].second << endl;\n  }\n  cout << endl;\n  return 0;\n  */\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(){\n\t\tcout << p1 << ' ' << p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint turn(Point p,double t){\n\treturn p*exp(Point(.0,t*M_PI/180.0));\n}\n\nvector<Line> tangentCircleCircle(Circle a,Circle b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.p-b.p);\n\tvector<Line>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/M_PI;\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),t),b.p+turn(b.r/d*(a.p-b.p),t)));\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),-t),b.p+turn(b.r/d*(a.p-b.p),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tPoint p=a.p+a.r/d*(b.p-a.p);\n\t\tl.push_back(Line(p,p+turn(b.p-a.p,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/M_PI;\n\t\tdouble t2=180-t1;\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),t1),b.p+turn(b.r/d*(a.p-b.p),-t2)));\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),-t1),b.p+turn(b.r/d*(a.p-b.p),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tPoint p=a.p+a.r/d*(b.p-a.p);\n\t\tl.push_back(Line(p,p+turn(b.p-a.p,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<Circle> cs(n);\n\t\tvector<double> m(n);\n\t\trep(i,n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r >> m[i];\n\t\t\tcs[i] = Circle(Point(x, y), r);\n\t\t}\n\n\t\tif(n == 1){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<Line> ls;\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tvector<Circle> a(2, cs[i]), b(2, cs[j]);\n\t\t\t\ta[1].r+=m[i];\n\t\t\t\tb[1].r+=m[j];\n\n\t\t\t\tfor(auto k : a){\n\t\t\t\t\tfor(auto l : b){\n\t\t\t\t\t\tfor(auto line :  tangentCircleCircle(k,l)){\n\t\t\t\t\t\t\tls.emplace_back(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i,ls.size()){\n\t\t\tint sum = 0;\n\t\t\trep(j,n){\n\t\t\t\tdouble dis = distanceLPoint(ls[i], cs[j].p);\n\t\t\t\tif(dis >= cs[j].r - EPS and dis <= cs[j].r + m[j] + EPS){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef double D;\n//typedef pair<int,int> P;\n//typedef long long ll;\n//typedef vector<int> vi;\n//typedef vector<string> vs;\nconst D EPS = 1e-8;\nconst int INF = 1e8;\nconst D PI =acos(-1);\n\ntypedef complex<D>P;\nP unit(P p){return p/abs(p);}\npair<P, P> norm(P p){return make_pair(p*P(0, 1), p*P(0, -1));}\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nP rotate(P v,double s){\n    return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\nD arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nD arg(D a,D b,D c){return acos((b*b+c*c-a*a)/(2*b*c));}\n\ntypedef pair<P, P>L;\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if (cross(b,c)>EPS) return 1; //counter clockwise\n    if (cross(b,c)<-EPS) return -1; //clockwise\n    if (dot(b, c)<-EPS) return 2; //c−−a−−b on line\n    if (abs(b)<abs(c)) return -2; //a−−b−−c on line\n    return 0; //on segment\n}\n\nD line_dis(L a,P x){return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);}\n\ntypedef pair<P, D>C;\nbool in_cir(C c,P x){return (abs(x-c.fs) +EPS < c.sc);}\nbool on_cir(C c,P x){return EQ(abs(x-c.fs),c.sc);}\nvector<L> adj_line(C c,P p){\n    vector<L> res;\n    if(in_cir(c,p))return res;\n    if(on_cir(c,p)){\n        pair<P,P> n = norm(c.fs-p);\n        res.pb(L(n.fs+p,p));\n        return res;\n    }\n    D x = c.sc, z = abs(c.fs-p); D y = sqrt(z*z-x*x);\n    D s = arg(y,x,z);\n    P v = unit(p-c.fs)*c.sc;\n    res.pb(L(rotate(v,s)+c.fs,p));\n    res.pb(L(rotate(v,-s)+c.fs,p));\n    return res;\n}\n\nvector<P> cp_cir_to_line(C a, L l){\n    vector<P> v;\n    D d = line_dis(l,a.fs);\n    if(d < a.sc + EPS){\n        P x = a.sc*unit(l.sc - l.fs);\n        if(ccw(l.fs,l.sc,a.fs) == 1)x = a.fs + x*P(0,-1);\n        else x = a.fs + x*P(0,1);\n        if(d + EPS < a.sc){\n            D y = sqrt(a.sc*a.sc - d*d);\n            D s = arg(y,d,a.sc);\n            v.pb(rotate(x,s));\n            v.pb(rotate(x,-s));\n        }else if(EQ(d,a.sc))v.pb(x);\n    }\n    return v;\n}\n\nvector<L> common_adj_line(C a,C b){\n    vector<L> res;\n    if(a.sc+EPS<b.sc)return common_adj_line(b,a);\n    if(EQ(real(a.fs),real(b.fs)) && EQ(imag(a.fs),imag(b.fs)) && EQ(a.sc,b.sc))return res;\n    P pos = (b.fs-a.fs)*a.sc/(a.sc+b.sc)+a.fs;\n    if(!in_cir(a,pos))res = adj_line(a,pos);\n    if(EQ(a.sc,b.sc)){\n        pair<P,P> n = norm(unit(b.fs-a.fs)*a.sc);\n        res.pb(L(a.fs+n.fs,b.fs+n.fs)); res.pb(L(a.fs+n.sc,b.fs+n.sc));\n    }else{\n        D c = abs(b.fs-a.fs);\n        pos = unit(b.fs-a.fs)*((a.sc*c)/(a.sc-b.sc))+a.fs;\n        if(!in_cir(a,pos)){\n            vector<L> tmp = adj_line(a,pos);\n            rep(i,tmp.sz)res.pb(tmp[i]);\n        } \n    }\n    return res;\n}\n\nint N;\nC R[50], M[50];\n\nint check(L l){\n    int cnt = 0;\n    for(int i=0;i<N;i++){\n        if(cp_cir_to_line(R[i], l).size() <= 1 && cp_cir_to_line(M[i], l).size() >= 1){\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n\n    while(cin>>N,N){\n        for(int i=0;i<N;i++){\n            int x, y, r, m;\n            cin>>x>>y>>r>>m;\n            R[i].fs = P(x, y);\n            R[i].sc = r;\n            M[i] = R[i];\n            M[i].sc += m;\n        }\n        int ans = 1;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                vector<L>v;\n                v = common_adj_line(R[i], R[j]);\n                for(int k=0;k<v.size();k++){\n                    ans = max(ans, check(v[k]));\n                }\n                v = common_adj_line(R[i], M[j]);\n                for(int k=0;k<v.size();k++){\n                    ans = max(ans, check(v[k]));\n                }\n                v = common_adj_line(M[i], R[j]);\n                for(int k=0;k<v.size();k++){\n                    ans = max(ans, check(v[k]));\n                }\n                v = common_adj_line(M[i], M[j]);\n                for(int k=0;k<v.size();k++){\n                    ans = max(ans, check(v[k]));\n                }\n                \n            }\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define SZ(R) (R).size()\n#define curr(P, i) P[(i)%SZ(P)]\n#define next(P, i) curr(P, (i+1))\n#define prev(P, i) curr(P, (i-1+SZ(P)))\n\nusing D = double;\nusing P = complex<D>;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b); \n  }\n}\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nstruct L : vector<P> {\n  L(const P& a, const P& b) {\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct C {\n  P p;\n  D r;\n};\n\nP makeP(D arg, D r = 1.0) {\n  return r * P{cos(arg), sin(arg)};\n}\n\nP rotP(const P& p, D arg) {\n  return p * makeP(arg);\n}\n\nD getArg(const P& p) {\n  return atan2(y(p), x(p));\n}\n\nint getSigneture(D d) {\n  int ret = 0;\n  if(d > 0) ret = 1;\n  if(d < 0) ret = -1;\n  return ret;\n}\n\nD SQ(D d) {\n  return d*d;\n}\n\nvector<L> commonTang(C c1, C c2) {\n  vector<L> ret;\n  if(c1.r > c2.r) swap(c1, c2);\n  P sub = c1.p;\n  c1.p -= sub;\n  c2.p -= sub;\n  D arg1 = getArg(c2.p);\n  c2.p = rotP(c2.p, -arg1);\n  int sigX = getSigneture(x(c2.p));\n\n  D x2 = abs(x(c2.p)), r1 = c1.r, r2 = c2.r;\n\n  if(abs(SQ(x2)-SQ(r2-r1)) < EPS) {\n    D arg2 = asin((r2-r1)/x2);\n    ret.push_back({rotP(P{0., r1}, arg2), rotP(P{sqrt(SQ(x2)-SQ(r2-r1)), r1}, arg2)});\n  }\n  else if(SQ(x2) > SQ(r2-r1)) {\n    D arg2 = asin((r2-r1)/x2);\n    ret.push_back({rotP(P{0., +r1}, +arg2), rotP(P{sqrt(SQ(x2)-SQ(r2-r1)), +r1}, +arg2)});\n    ret.push_back({rotP(P{0., -r1}, -arg2), rotP(P{sqrt(SQ(x2)-SQ(r2-r1)), -r1}, -arg2)});\n  }\n  if(abs(r1+r2-x2) < EPS) {\n    D arg2 = PI / 2 - asin((r1+r2)/x2);\n    D len = sqrt(SQ(r1*x2)/SQ(r1+r2)-SQ(r1)) + sqrt(SQ(r2*x2)/SQ(r1+r2)-SQ(r2));\n    ret.push_back({rotP(P{0., r1}, -arg2), rotP(P{len, r1}, -arg2)});\n  }\n  else if(x2 > r1 + r2) {\n    D arg2 = PI / 2 - asin((r1+r2)/x2);\n    D len = sqrt(SQ(r1*x2)/SQ(r1+r2)-SQ(r1)) + sqrt(SQ(r2*x2)/SQ(r1+r2)-SQ(r2));\n    ret.push_back({rotP(P{0., +r1}, -arg2), rotP(P{len, +r1}, -arg2)});\n    ret.push_back({rotP(P{0., -r1}, -arg2), rotP(P{len, -r1}, +arg2)});\n  }\n  for(auto& l : ret) {\n    if(sigX == -1) l[1] = P{-x(l[1]), y(l[1])};\n    rep(i, 2) {\n      l[i] = rotP(l[i], arg1);\n      l[i] += sub;\n    }\n  }\n  return ret;\n}\nP proj(const L& l, const P& p) {\n  P v = l[0]-l[1];\n  D t = dot(p-l[0], v) / norm(v);\n  return l[0] + t*v;\n}\nD distLP(const L& l, const P& p){\n  return abs(p-proj(l, p));\n}\nint relLC(const L& l, const C& c) {\n  if(abs(distLP(l, c.p) - c.r) < EPS) return +1;\n  if(distLP(l, c.p) > c.r+EPS) return 0;\n  return 2;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    vector<vector<C>> cs(2);\n    vector<D> ms(n);\n    rep(i, n) {\n      D x, y, r, m;\n      cin >> x >> y >> r >> m;\n      cs[0].push_back(C{P{x, y}, r});\n      cs[1].push_back(C{P{x, y}, r+m});\n      ms[i] = m;\n    }\n    if(n == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    auto cnt = [&](const L& l) {\n      int ret = 0;\n      rep(i, n) {\n\tauto& c = cs[0][i];\n\tif(distLP(l, c.p) > c.r - EPS && distLP(l, c.p) < c.r + ms[i] + EPS) ret++;\n      }\n      return ret;\n    };\n    int ans = 0;\n    rep(i, n) rep(j, i) {\n      auto ls = commonTang(cs[0][i], cs[0][j]);\n      for(auto& l : ls) ans = max(ans, cnt(l));\n    }\n    rep(i, n) rep(j, i) {\n      auto ls = commonTang(cs[1][i], cs[1][j]);\n      for(auto& l : ls) ans = max(ans, cnt(l));\n    }\n    rep(i, n) rep(j, n) {\n      if(i == j) continue;\n      auto ls = commonTang(cs[0][i], cs[1][j]);\n      for(auto& l : ls) ans = max(ans, cnt(l));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\nvector<L> getLine(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  int c = isIntersect(a, b);\n\n  if (c == -2) {\n    // there are no lines\n  } else if (abs(c) == 1) {\n    P cp = getCrossP(a, b)[0];\n    P base = b.o - a.o;\n    P n(-base.imag(), base.real());\n    res.push_back(L(cp, cp + n));\n  } else {\n    {\n      if (a.r == b.r) {\n        P base = b.o - a.o;\n        P n(-base.imag(), base.real());\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, b.o + n * a.r));\n        res.push_back(L(a.o - n * a.r, b.o - n * a.r));\n      } else {\n        double h = b.r - a.r;\n        double x = sqrt(norm(a.o - b.o) - h * h);\n        vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n        for (int i = 0; i < ps.size(); ++i) {\n          P n = ps[i] - b.o;\n          n /= abs(n);\n          res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n        }\n      }\n    }\n    {\n      double h = b.r + a.r;\n      double x = sqrt(norm(a.o - b.o) - h * h);\n      vector<P> ps = getCrossP(C(b.o, h), C(a.o, x));\n      for (int i = 0; i < ps.size(); ++i) {\n        P n = b.o - ps[i];\n        n /= abs(n);\n        res.push_back(L(a.o + n * a.r, ps[i] + n * a.r));\n      }\n    }\n  }\n\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getLine(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+r2)*(r1+r2));\n\t\tdouble xf=r1*(xx*(r1+r2*rs)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+r2*rs)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(fabs(yf)>fabs(xf)){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  //\t\t  cout<<xx*xx+yy*yy-(r1+r2)*(r1+r2)<<' '<<xf<<' '<<yf<<' ';\n\t\t  //\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-9;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\t//cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\t//cout << \"ok\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t//cout << \"ng\" << endl;\n\t\t}\n\t}\n\t\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r+eps){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r2/(r1+r2)*p1+r1/(r1+r2)*p2;\n\t//cout << \"aaa \" << endl;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\t//cout << \"bbb \" << endl;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tC(P p, R r):P(p),r(r){}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tvector<L> CommonTangent(C c1, C c2){\n\t\tif(c1.r > c2.r) swap(c1, c2);\n\t\tdouble d = abs(c1-c2);\n\t\tvector<L> res;\n\t\tif(d < EPS) return res;\n\t\tif(d + EPS > c1.r + c2.r){\n\t\t\t// 内接線\n\t\t\tP crs = (c1*c2.r + c2*c1.r) / (c1.r + c2.r);\n\t\t\tdouble rad = asin(c1.r/abs(crs-c1));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., rad)));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., -rad)));\n\t\t}\n\t\tif(c1.r + d + EPS > c2.r){\n\t\t\t// 外接線\n\t\t\tdouble rad = 0.5*PI+asin((c2.r-c1.r) / d);\n\t\t\tP v = unit(c2-c1)*polar(1., rad);\n\t\t\tif(c1.r + d - EPS < c2.r){\n\t\t\t\tres.push_back(L(c1+v*c1.r, c1+v*c1.r+(c1-c2)*P(0, 1)));\n\t\t\t}else{\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t\tv = 2.*proj(v, c2-c1) - v;\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n;\nvector<pair<C, C>> jewel;\n\nmain(){\n\twhile(cin >> n, n){\n\t\tjewel.clear();\n\t\tREP(i, n){\n\t\t\tint x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tjewel.emplace_back(C(P(x, y), r), C(P(x, y), r+m));\n\t\t}\n\t\tvector<L> cand;\n\t\tREP(i, n)REP(j, i){\n\t\t\tREP(k, 4){\n\t\t\t\tC &c1 = (k&1) ? jewel[i].first : jewel[i].second;\n\t\t\t\tC &c2 = (k&2) ? jewel[j].first : jewel[j].second;\n\t\t\t\tvector<L> c = CommonTangent(c1, c2);\n\t\t\t\tcand.insert(cand.end(), ALL(c));\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, cand.size()) {\n\t\t\tans = max(ans, (int)count_if(ALL(jewel), [&](const pair<C, C> &jewel){\n\t\t\t\tR d = dist2(cand[i], jewel.first);\n\t\t\t\treturn jewel.first.r*jewel.first.r < d+EPS && d-EPS < jewel.second.r*jewel.second.r;\n\t\t\t}));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,e,d;\n\t\t\tcin>>a>>b>>e>>d;\n\t\t\tc.pb(C(P(a,b),e));\n\t\t\tc.pb(C(P(a,b),e+d));\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L>l,tmp;\n\t\trep(i,c.size())loop(j,i+1,c.size()){\n\t\t\ttmp=tangentCC(c[i],c[j]);\n\t\t\trep(k,tmp.size()){\n\t\t\t\tl.pb(tmp[k]);\n\t\t\t}\n\t\t}\n\t\tint out=0;\n\t\trep(i,l.size()){\n\t\t\tL t=l[i];\n\t\t\tint co=0;\n\t\t\trep(j,c.size()){\n\t\t\t\tdouble d=distanceLP(t,c[j].c);\n\t\t\t\tif(d+EPS>c[j].r&&d<c[j+1].r+EPS)co++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n      }\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        pv.push_back(resl[k].first);\n        pv.push_back(resl[k].second);\n      }\n\n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        pv.push_back(resl[k].first);\n        pv.push_back(resl[k].second);\n      }\n    }\n  }\n\n  pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      L l = L(pv[i], pv[j]);\n      int sum = 0;\n      for(int k=0;k<n;k++){\n        if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n          sum++;\n        }\n      }\n      ans = max(ans, sum);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;     \ntypedef complex<D> P;  \ntypedef pair<P, P> L;  \nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) { return (conj(a)*b).Y;}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1,p-a1)/norm(a2-a1)*(a2-a1);\n}\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L>ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;\n    }\n  }\n  return ls;\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    P p[n];\n    double r[n],a,b;\n    int cost[n],sum=1;\n    rep(i,n){\n      cin>>a>>b>>r[i]>>cost[i];\n      p[i]=P(a,b);\n    }\n    rep(i,n)for(int j=i+1;j<n;j++){\n      vector<L>l=tangentLines(p[i],r[i],p[j],r[j]);\n      rep(k,l.size()){\n        int t=0;\n        rep(u,n)if(distLP(l[k].first,l[k].second,p[u])>=r[u]-EPS&&distLP(l[k].first,l[k].second,p[u])<=r[u]+cost[u]+EPS)t++;\n        sum=max(sum,t);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    double diff = a - b;\n    if(abs(diff) < EPS) return 0;\n    else if(diff < 0) return -1;\n    return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nint ccw(const P& a, P b, P c)\n{\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) {\n    return +1;\n  } else if (cross(b, c) < -EPS) {\n    return -1;\n  } else if (dot(b, c) < -EPS) {\n    return +2;\n  } else if (dot(b, b) + EPS < dot(c, c)) {\n    return -2;\n  } else {\n    return 0;\n  }\n}\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct circle/*{{{*/\n{\n  P o;\n  double r;\n  circle() {}\n  circle(const P& p, double x) : o(p), r(x) {}\n\n  // POJ 1375 Intervals\n  // 点 p を通る2つの接線\n  pair<P,P> tangent(const P& p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L*L - r*r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M*(v*polar(1.0, theta)), p + M*(v*polar(1.0, -theta)));\n  }\n\n  pair<line,line> outer_tangent_parallel(const circle &c) const {\n      const P d = o - c.o;\n      const P v = d * P(0, 1) * r / abs(d);\n      return make_pair(line(o+v, c.o+v), line(o-v, c.o-v));\n  }\n\n  pair<line,line> outer_tangent(const circle &c) const {\n      if(cmp(r, c.r) == 0) return outer_tangent_parallel(c);\n      if(r > c.r) return c.outer_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 - c.r/r;\n      const P base = c.o + d+d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair<line,line> inner_tangent(const circle &c) const {\n      if(r > c.r) return c.inner_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 + c.r/r;\n      const P base = c.o + d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // POJ 1418 Viva Confetti\n  // POJ 2149 Inherit the Spheres\n  inline bool intersects(const circle& c) const\n  {\n    return !contains(c) && !c.contains(*this) && abs(o - c.o) <= r + c.r;\n  }\n\n  inline bool independent(const circle &c) const {\n      return abs(o-c.o) > r+c.r;\n  }\n\n  pair<P,P> intersection(const circle& c) const\n  {\n    // assert(intersects(c))\n    const double d = abs(o - c.o);\n    const double cos_ = (d*d + r*r - c.r*c.r) / (2*d);\n    const double sin_ = sqrt(r*r - cos_*cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e*P(cos_, sin_), o + e*P(cos_, -sin_));\n  }\n\n  inline bool contains(const circle& c) const\n  {\n    return abs(o - c.o)+c.r <= r;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return abs(ln.distance(o)) <= r;\n  }\n\n  inline double distance(const line &ln) const {\n      return abs(ln.distance(o));\n  }\n\n  pair<P,P> intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r*r - d*d);\n    return make_pair(h + l*ab, h - l*ab);\n  }\n};/*}}}*/\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n    if(c1.independent(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inner = c1.inner_tangent(c2);\n        lines.push_back(inner.first);\n        lines.push_back(inner.second);\n    } else if(c1.intersects(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inter = c1.intersection(c2);\n        lines.push_back(line(inter.first, inter.second));\n    } \n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<circle,circle>> jewels;\n    vector<line> lines;\n    for(int i = 0; i < N; ++i) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        const P center(x, y);\n        pair<circle,circle> jewel = make_pair(circle(center, r), circle(center, r+m));\n        for(const auto &other : jewels) {\n            enum_event(jewel.first, other.first, lines);\n            enum_event(jewel.first, other.second, lines);\n            enum_event(jewel.second, other.first, lines);\n            enum_event(jewel.second, other.second, lines);\n        }\n        jewels.push_back(jewel);\n    }\n\n    int ans = 1;\n    for(auto &l : lines) {\n        int cnt = count_if(jewels.begin(), jewels.end(), [&](const pair<circle,circle> &j){\n                return cmp(j.first.r, j.first.distance(l)) <= 0 && \n                cmp(j.second.r, j.second.distance(l)) >= 0;\n                });\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,double> P1;\nconst double EPS = 1e-8;\ntypedef pair<P,P> L;\nint n,m[51];\n\n\n//kaitenn\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n \n//???\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\nCircle c[2][51];\n \nL getIntangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double w=a.r+b.r;\n  double h=sqrt(max(0.0,norm(base)-w*w));\n  P k=base*P(w,h*f)/norm(base);\n  return L(a.c+k*a.r,b.c-k*b.r);\n}\n \nL getOuttangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double h=b.r-a.r;\n  double w=sqrt(max(0.0,norm(base)-h*h));\n  P k=base*P(w,h*f)/norm(base)*P(0,f);\n  return L(a.c+k*a.r,b.c+k*b.r);\n}\n \nvector<L> tangentCC(Circle a,Circle b){\n  double dis=abs(a.c-b.c),R=a.r+b.r;\n  vector<L> res;\n  if(dis>R+EPS)res.push_back(getIntangent(a,b));\n  if(dis>R-EPS)res.push_back(getIntangent(a,b,-1));\n  if(dis>abs(a.r-b.r)+EPS)res.push_back(getOuttangent(a,b));\n  if(dis>abs(a.r-b.r)-EPS)res.push_back(getOuttangent(a,b,-1));\n  return res;\n}\n\nint cal(P a,P b){\n  int res=0;\n  b-=a;\n  for(int i=0;i<n;i++){\n    P t=(c[0][i].c-a)*conj(b)/abs(b);\n    if(c[0][i].r<=abs(t.imag())+EPS&&abs(t.imag())<=c[1][i].r+EPS)res++;\n  }\n  return res;\n}\n \nint main(){\n  while(cin>>n,n){\n\n    for(int i=0,a,b,r,m;i<n;i++){\n      cin>>a>>b>>r>>m;\n      c[0][i]=Circle(P(a,b),r);\n      c[1][i]=Circle(P(a,b),r+m);\n    }\n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tfor(int k=0;k<4;k++){\n\t  vector <L> res=tangentCC(c[k%2][i],c[(k>>1)%2][j]);\n\t  for(int l=0;l<res.size();l++) ans=max(ans,cal(res[i].first,res[i].second));\n\t}\n      }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconstexpr double eps = 1e-7;\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };ttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }ttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }ttt point<T> operator - (pca a) { return { -a.x, -a.y }; }ttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }ttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }ttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }ttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }ttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }ttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }ttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }ttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }ttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }ttt double length(pca p) { return sqrt(length_squared(p)); }ttt point<T> normalized(pca a) { return (1 / length(a)) * a; }ttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }ttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }ttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }template <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> struct line { point<T> a, b; };template <typename T> struct segment { point<T> a, b; };template <typename T> T length_squared(const segment<T> & p) { return length_squared(p.a - p.b); }template <typename T> double length(const segment<T> & p) { return length(p.a - p.b); }\ntemplate <typename T>T sq(T x) { return x * x; }\ntemplate <typename T>point<T> rotate_90(point<T> const & a) {return { - a.y, a.x };}template <typename T>point<T> rotate_270(point<T> const & a) {return { a.y, - a.x };}template <typename T>point<T> rotate_180(point<T> const & a) {return { - a.x, - a.y };}point<double> rotate(point<double> const & a, double th) {return {a.x * cos(th) - a.y * sin(th),a.x * sin(th) + a.y * cos(th) };}\nbool does_include(circle<double> const & a, point<double> const & b) {return length(a.p - b) < a.r + eps;}bool is_on_circumference(point<double> const & a, circle<double> const & b) {return std::abs(length(b.p - a) - b.r) < eps;}// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {return length(a.p - b.p) < std::abs(a.r - b.r) + eps;}// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {return length(a.p - b.p) < a.r + b.r + eps;}// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;}// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;}std::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {std::vector<point<double> > result;if (not does_intersect(a,b)) {// nop\n} else if (does_include(a,b) and not does_inscribe(a,b)) {// truly included\n// nop\n} else if (does_inscribe(a,b) or does_circumscribe(a,b)) {result.push_back(a.r * normalized(b.p - a.p));} else {//       c\n//      /|        // a.r / |  b.r\n//    /th|          //   a-------b\n//       l\ndouble l = length(b.p - a.p);double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\ndouble as = sqrt( sq(a.r) - sq(ac) );point<double> e = normalized(b.p - a.p);result.push_back(a.p + ac*e + as*rotate_90(e));result.push_back(a.p + ac*e + as*rotate_270(e));}return result;}std::vector<line<double> > common_tangents(circle<double> const & a, point<double> const & b) {std::vector<line<double> > result;if (does_include(a,b) and not is_on_circumference(b,a)) {// truly included\n// nop\n} else if (is_on_circumference(b,a)) {point<double> e = normalized(a.p - b);result.push_back({b + rotate_90(e),b + rotate_270(e) });} else {double theta = asin(a.r / length(b - a.p));result.push_back({ b, b + rotate(a.p - b, + theta) });result.push_back({ b, b + rotate(a.p - b, - theta) });}return result;}std::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);return common_tangents(a,p);}std::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {if (b.r < a.r) std::swap(a,b);std::vector<line<double> > result;if (does_include(a,b) and not does_inscribe(b,a)) {// truly included\n// nop\n} else if (does_inscribe(b,a)) {point<double> e = normalized(a.p - b.p);result.push_back({b.p + a.r*e + rotate_90(e),b.p + a.r*e + rotate_270(e) });} else {point<double> d = b.p - a.p;double theta = asin((b.r - a.r) / length(d));point<double> dp = rotate(d, + theta);point<double> dm = rotate(d, - theta);point<double> ep = rotate_90(normalized(dp));point<double> em = rotate_270(normalized(dm));result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });}return result;}std::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {std::vector<line<double> > result;for (auto l : common_inner_tangents(a,b)) result.push_back(l);for (auto l : common_outer_tangents(a,b)) result.push_back(l);return result;}double distance(line<double> const & a, point<double> const & b) {point<double> p = b   - a.a;point<double> q = a.b - a.a;return std::abs( cross(p, q) / length(q) );}\nusing namespace std;\nusing namespace boost;\nint main() {\n    int age = 0;\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point<double> > p(n); vector<double> r(n), m(n);\n        for (int i : irange(0,n)) cin >> p[i] >> r[i] >> m[i];\n        if (n <= 2) {\n            cout << n << endl;\n            continue;\n        }\n        vector<circle<double> > cs(2*n);\n        for (int i : irange(0,n)) {\n            cs[2*i].p = p[i];\n            cs[2*i].r = r[i];\n            cs[2*i+1].p = p[i];\n            cs[2*i+1].r = r[i]+m[i];\n        }\n        vector<line<double> > ls;\n        for (int i : irange(0,2*n)) {\n            for (int j : irange(i+1,2*n)) {\n                for (auto l : common_tangents(cs[i], cs[j])) {\n                    ls.push_back(l);\n                }\n            }\n        }\n        int result = 0;\n        for (auto l : ls) {\n            int jewels = 0;\n            for (int i : irange(0,n)) {\n                double d = distance(l, p[i]);\n                if (r[i] < d + eps and d < r[i]+m[i] + eps) {\n                    jewels += 1;\n                }\n            }\n            result = max(result, jewels);\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\nconst double EPS = 1e-12;\n\nint cmp(double a, double b) {\n    const double diff = a - b;\n    if(fabs(diff) < EPS) return 0;\n    else if(diff < 0) return -1;\n    else return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct circle/*{{{*/\n{\n  P o;\n  double r;\n  circle() {}\n  circle(const P& p, double x) : o(p), r(x) {}\n\n  // POJ 1375 Intervals\n  // 点 p を通る2つの接線\n  pair<P,P> tangent(const P& p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L*L - r*r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M*(v*polar(1.0, theta)), p + M*(v*polar(1.0, -theta)));\n  }\n\n  pair<line,line> outer_tangent_parallel(const circle &c) const {\n      const P d = o - c.o;\n      const P v = d * P(0, 1) * r / abs(d);\n      return make_pair(line(o+v, c.o+v), line(o-v, c.o-v));\n  }\n\n  pair<line,line> outer_tangent(const circle &c) const {\n      if(cmp(r, c.r) == 0) return outer_tangent_parallel(c);\n      if(r > c.r) return c.outer_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 - c.r/r;\n      const P base = c.o + d+d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair<line,line> inner_tangent(const circle &c) const {\n      if(r > c.r) return c.inner_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 + c.r/r;\n      const P base = c.o + d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // POJ 1418 Viva Confetti\n  // POJ 2149 Inherit the Spheres\n  inline bool intersects(const circle& c) const\n  {\n    return !contains(c) && !c.contains(*this) && cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  inline bool independent(const circle &c) const {\n      return cmp(abs(o-c.o), r+c.r) > 0;\n  }\n\n  pair<P,P> intersection(const circle& c) const\n  {\n    // assert(intersects(c))\n    const double d = abs(o - c.o);\n    const double cos_ = (d*d + r*r - c.r*c.r) / (2*d);\n    const double sin_ = sqrt(r*r - cos_*cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e*P(cos_, sin_), o + e*P(cos_, -sin_));\n  }\n\n  inline bool contains(const circle& c) const\n  {\n    return cmp(abs(o - c.o)+c.r, r) < 0;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return cmp(abs(ln.distance(o)), r) <= 0;\n  }\n\n  inline double distance(const line &ln) const {\n      return abs(ln.distance(o));\n  }\n\n  pair<P,P> intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r*r - d*d);\n    return make_pair(h + l*ab, h - l*ab);\n  }\n};/*}}}*/\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n    if(c1.independent(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inner = c1.inner_tangent(c2);\n        lines.push_back(inner.first);\n        lines.push_back(inner.second);\n    } else if(c1.intersects(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inter = c1.intersection(c2);\n        lines.push_back(line(inter.first, inter.second));\n    } \n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<circle,circle>> jewels;\n    vector<line> lines;\n    for(int i = 0; i < N; ++i) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        const P center(x, y);\n        pair<circle,circle> jewel = make_pair(circle(center, r), circle(center, r+m));\n        for(const auto &other : jewels) {\n            enum_event(jewel.first, other.first, lines);\n            enum_event(jewel.first, other.second, lines);\n            enum_event(jewel.second, other.first, lines);\n            enum_event(jewel.second, other.second, lines);\n        }\n        jewels.push_back(jewel);\n    }\n\n    int ans = 1;\n    for(auto &l : lines) {\n        int cnt = count_if(jewels.begin(), jewels.end(), [&](const pair<circle,circle> &j){\n                return cmp(j.first.r, j.first.distance(l)) <= 0 && \n                cmp(j.second.r, j.second.distance(l)) >= 0;\n                });\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n  return res;\n}\n\ndouble getDistanceSP(L s, P p){\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\n\nCircle c[N][2];\n\nint main(){\n  int n,x,y,r,m;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>r>>m;\n      c[i][0]=Circle(P(x,y),r);\n      c[i][1]=Circle(P(x,y),r+m);\n    }\n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<2;j++)\n\tfor(int k=i+1;k<n;k++)\n\t  for(int l=0;l<2;l++){\n\t    vector<L> r=tangentCC(c[i][j],c[k][l]);\n\t    for(int a=0;a<r.size();a++){\n\t      int sum=0;\n\t      for(int b=0;b<n;b++){\n\t\tdouble d=getDistanceSP(r[b],c[b][0].c);\n\t\tif(c[b][0].r<=d&&d<=c[b][1].r)sum++;\n\t      }\n\t      ans=max(ans,sum);\n\t    }\n\t  }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nbool EQ(double a, double b) { return abs(a - b) < EPS; }\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point& p, double r) : p(p), r(r) {}\n};\nbool contains(const Circle& c, const Point& p) { return norm(c.p - p) < c.r + EPS; }\nbool contains(const Circle& a, const Circle& b) { return b.r + norm(a.p - b.p) < a.r + EPS; }\nbool intersects(const Circle& a, const Circle& b) {\n    if (contains(a, b) || contains(b, a)) return false;\n    return norm(a.p - b.p) < a.r + b.r + EPS;\n}\nostream& operator<<(ostream& os, const Circle& c) {\n    return os << \"Circle[\" << c.p << \",\" << c.r << \"]\";\n}\nistream& operator>>(istream& is, Circle& c) {\n    return is >> c.p >> c.r;\n}\n\nvector<Point> crosspoints(const Circle& a, const Circle& b) {\n    if (!intersects(a, b)) return vector<Point>();\n    double d = norm(b.p - a.p);\n    double x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n    double y = sqrt(a.r * a.r - x * x);\n    Point v = b.p - a.p;\n    vector<Point> ret(2);\n    Point e = v / d;\n    ret[0] = a.p + e * x + rot90(e) * y;\n    ret[1] = a.p + e * x - rot90(e) * y;\n    return ret;\n}\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n};\nostream& operator<<(ostream& os, const Line& l) {\n    return os << \"Line(\" << l.a << \",\" << l.b << \")\";\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\n\nvector<Line> tangent(const Circle& c, const Point& p) {\n    /** pを通るcの接線を返す.\n     *    返り値の2直線l, mについて l.a == m.a == p */\n    double l1 = norm(c.p - p);\n    double l2 = sqrt(l1 * l1 - c.r * c.r);\n    double d1 = (l2 * l2) / l1;\n    double d2 = (c.r * l2) / l1;\n    Point u = (c.p - p) / norm(c.p - p);\n    Point b = p + u * d1;\n\n    /* uと直交する単位ベクトル */\n    Point o1 = Point(u.y, -u.x),\n          o2 = Point(-u.y, u.x);\n\n    Point a1 = b + o1 * d2,\n          a2 = b + o2 * d2;\n    vector<Line> ret(2);\n    ret[0] = Line(p, a1);\n    ret[1] = Line(p, a2);\n    return ret;\n}\n\nvector<Line> common_tangent(const Circle& a, const Circle& b) {\n    vector<Line> ret;\n    vector<Point> ps;\n    Point v = b.p - a.p;\n    double d = norm(v);\n    if (!EQ(a.r, b.r)) ps.push_back(a.p + v * a.r / (a.r - b.r));\n    if (!intersects(a, b)) ps.push_back(a.p + v * a.r / (a.r + b.r));\n    for (int i = 0; i < ps.size(); i++) {\n        Point& p = ps[i];\n        vector<Line> ts = tangent(a, p);\n        ret.insert(ret.end(), ts.begin(), ts.end());\n    }\n    if (EQ(a.r, b.r)) {\n        ret.push_back(Line(a.p + rot90(v) / d * a.r, b.p + rot90(v) / d * b.r));\n        ret.push_back(Line(a.p - rot90(v) / d * a.r, b.p - rot90(v) / d * b.r));\n    }\n    return ret;\n}\n\nint N;\nvector<Circle> js; // jewels\nvector<double> ms; // magnets' strength\n\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    js.clear(); js.resize(N);\n    ms.clear(); ms.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> js[i] >> ms[i];\n    }\n    return true;\n}\n\ndouble dist(const Line& l, const Point& p) {\n    Point a = projection(l, p);\n    return norm(a - p);\n}\n\nbool check(const Line& l, int index) {\n    Circle a = js[index];\n    Circle b = js[index]; b.r += ms[index];\n    if (dist(l, a.p) + EPS < a.r) {\n        return false;\n    }\n    return dist(l, b.p) < b.r + EPS;\n}\n\nint count(const Line& l) {\n    int ret = 0;\n    for (int i = 0; i < N; i++) {\n        if (check(l, i)) ret++;\n    }\n    return ret;\n}\n\nvoid solve() {\n    vector<Line> ls;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            vector<Circle> as;\n            as.push_back(js[i]);\n            as.push_back(Circle(js[i].p, js[i].r + ms[i]));\n            vector<Circle> bs;\n            bs.push_back(js[j]);\n            bs.push_back(Circle(js[j].p, js[j].r + ms[j]));\n            for (int k = 0; k < 2; k++) {\n                for (int l = 0; l < 2; l++) {\n                    if (intersects(as[k], bs[l])) {\n                        vector<Point> ps = crosspoints(as[k], bs[l]);\n                        ls.push_back(Line(ps[0], ps[1]));\n                    } else {\n                        vector<Line> ts = common_tangent(as[k], bs[l]);\n                        ls.insert(ls.end(), ts.begin(), ts.end());\n                    }\n                }\n            }\n        }\n    }\n    int ans = 1;\n    for (int i = 0; i < ls.size(); i++) {\n        ans = max(ans, count(ls[i]));\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b){};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<double> x(n), y(n), r(n), m(n);\n\t\tvector<Circle> gem;\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i]));\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i] + m[i]));\n\t\t}\n\t\tvector<Line> ls;\n\t\tREP(i, gem.size())REP(j, i)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tauto tmp = tangent_cc(gem[i], gem[j]);\n\t\t\tREP(k, tmp.size()) ls.push_back(tmp[k]);\n\t\t}\n\t\tint ans = 1;\n\n\t\tREP(i, ls.size())\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tdouble d = dist_lp(ls[i], Point(x[j],y[j]));\n\t\t\t\tif (d - r[j] > -EPS && d - r[j] - m[j] < EPS) cnt++;\n\t\t\t}\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool iscrossCL1(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\nbool iscrossCL2(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<=eps)return true;\n  return false;\n}\n\nvector<Line> getLines(Circle a,Circle b){\n  vector<Line> V;\n  if(a.r<b.r)swap(a,b);\n  double d=abs(b.c-a.c),r=a.r/(double)(a.r+b.r);\n  Vector v=(b.c-a.c),v1,v2;\n  double c=sqrt(d*d-(a.r-b.r)*(a.r-b.r));\n  double s;\n  if(b.r==a.r)s=90;\n  else s=(180*asin(c/((a.r-b.r)*d)))/pi;\n  Point p1,p2;\n  //printf(\"%.10f %.10f %.10f\\n\",d,c,s);\n  v=v/abs(v);\n  v1=v*a.r,v2=v*b.r;\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,180+s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,180-s);\n  V.push_back(Line(p1,p2));\n  v=v*d*r;\n  Point p=a.c+v;\n  c=sqrt(abs(v)*abs(v)-a.r*a.r);\n  s=(180*asin(c/abs(v)))/pi;\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,360-s);\n  V.push_back(Line(p1,p2));\n  return V;\n}\n\nint main()\n{\n  int n,a,b,c,d;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<pair<Circle,Circle> > v;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d;\n      v.push_back(mp(Circle(Point(a,b),c),Circle(Point(a,b),c+d)));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<Line> V;\n\tvector<Line> v1=getLines(v[i].f,v[j].f);\n\tvector<Line> v2=getLines(v[i].f,v[j].s);\n\tvector<Line> v3=getLines(v[i].s,v[j].f);\n\tvector<Line> v4=getLines(v[i].s,v[j].s);\n\tV.insert(V.begin(),v1.begin(),v1.end());\n\tV.insert(V.begin(),v2.begin(),v2.end());\n\tV.insert(V.begin(),v3.begin(),v3.end());\n\tV.insert(V.begin(),v4.begin(),v4.end());\n\tfor(int k=0;k<V.size();k++){\n\t  int sum=0;\n\t  for(int z=0;z<n;z++){\n\t    if(!iscrossCL1(v[z].f,V[k]) && iscrossCL2(v[z].s,V[k]))sum++;\n\t  }\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n#define mkp make_pair\n#define PB push_back\n#define ALL(v) v.begin(),v.end()\n#define maxs(a,b) (a=max(a,b))\n#define mins(a,b) (a=min(a,b))\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<vector<int>> vvint;\ntypedef pair<int, int> pii;\n// typedef pair<,pii> P;\n\ntypedef complex<double> P;\n\n#define EPS (1e-8)\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ntemplate<class T>\nT sq(T a){\n\treturn a*a;\n}\n\ndouble dd[]={1,-1};\n\nbool check(P a,P b,P p,double r,double c){\n\tdouble d = distance_l_p(a,b,p);\n\tif(r-d>EPS){\n\t\treturn false;\n\t}\n\tif(c-(d-r)>-EPS) return true;\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<pair<P, P>> v(n);\n\t\tvector<pair<P, P>> w;\n\t\trep(i, n) {\n\t\t\tdouble a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tv[i] = mkp(P(a, b), P(c, d));\n\t\t\tw.PB(mkp(P(a,b),P(c+d,d)));\n\t\t\tw.PB(v[i]);\n\t\t}\n\t\tvector<pair<P,P>> line;\n\t\trep(i,w.size()){\n\t\t\trep(j,i){\n\t\t\t\tdouble xp=w[j].F.real()-w[i].F.real();\n\t\t\t\tdouble yp=w[j].F.imag()-w[i].F.imag();\n\t\t\t\tdouble r = w[i].S.real();\n\t\t\t\tdouble R = w[j].S.real();\n\t\t\t\t// cout<<xp<<\" \"<<yp<<\" \"<<endl;\n\t\t\t\tif(sq(xp)+sq(yp)-sq(r+R)>=0){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tdouble xq,yq,xx,yy;\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\txq = r*(xp*(r+R)+dd[k]*yp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\tyq = r*(yp*(r+R)-dd[k]*xp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\t// cout<<\"xq yq \"<<xq<<\" \"<<yq<<endl;\n\t\t\t\t\t\tp = P(xq,yq) * P(0,1) + P(xq,yq) + w[i].F;\n\t\t\t\t\t\tline.PB(mkp(P(xq,yq)+w[i].F,p));\n\t\t\t\t\t\t// cout<<i<<\" \"<<j<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tR=-R;\n\t\t\t\tif(sq(xp)+sq(yp)-sq(r+R)>=0){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tdouble xq,yq,xx,yy;\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\txq = r*(xp*(r+R)+dd[k]*yp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\tyq = r*(yp*(r+R)-dd[k]*xp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\t// cout<<\"xq yq \"<<xq<<\" \"<<yq<<endl;\n\t\t\t\t\t\tp = P(xq,yq) * P(0,1) + P(xq,yq) + w[i].F;\n\t\t\t\t\t\tline.PB(mkp(P(xq,yq)+w[i].F,p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(auto z:line){\n\t\t\t// cout<<z.F<<\" \"<<z.S<<endl;\n\t\t\tint tmp = 0;\n\t\t\trep(i,n){\n\t\t\t\tif(check(z.F,z.S,v[i].F,v[i].S.real(),v[i].S.imag())){\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxs(ans,tmp);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst long double eps = 1e-9;\nconst long double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// 以下 幾何部分\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P> Pol;\n\n// ソートのキー\nB cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\nB cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\nint ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > 0)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < 0)      return RIGHT;   // clockwise\n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  aとbの線分判定はこれ\n}\n\n// 線分 直線\n\t// 点と直線の距離\n\t// 点と線分の距離\n\t// 直線と直線の距離\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// 交点\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// 点と直線と線分関連の交差判定\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 点と直線と線分関連の距離\n\nD dLP(L l,P p){ return abs(ep(vec(l),p-l.first)) /abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n\n// 円\n// Verify AOJ 1183\n\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//共通内接線\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// 共通外接線\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//接点を共有する接線\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\nint n;\n\nC jewel[110];\nint m[55];\n\nint check(L in){\n\tint res=0;\n\trep(i,n){\n\t\tD dis=dLP(in,jewel[i].c);\n\t\tif(jewel[i].r-eps<=dis && dis<=jewel[i+n].r+eps)\n\t\t\tres++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n ,n){\n\t\tint ans=1;\n\t\trep(i,n){\n\t\t\tC in;\n\t\t\tcin >> in.c.X >> in.c.Y >> in.r;\n\t\t\tjewel[i]=in;\n\t\t\tcin >> m[i];\n\t\t\tin.r+=m[i];\n\t\t\tjewel[i+n]=in;\n\t\t}\n\t\t\n\t\trep(i,2*n)rep(j,i){\n\t\t\tVL lines=common_tan(jewel[i],jewel[j]);\n\t\t\trep(k,lines.size())\n\t\t\t\tans=max(ans,check(lines[k]));\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = long double;\nconst T INF = 1e10;\nconst T EPS = 1e-10;\nconst T PI = acos(-1.0);\nT torad(int deg) {return (T)(deg) * PI / 180;}\nT todeg(T ang) {return ang * 180 / PI;}\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(T(1), a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline P linearTransform(P p, P q, P fp, P fq, P r) { return fp + (r - p) * (fq - fp) / (q - p); }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    istream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L() = default;\n    explicit L(P a, P b) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    bool onLine(P p) { return abs(side(p)) < EPS; }\n    bool onSegment(P p) { return onLine(p) && dot(this->operator[](0) - p, this->operator[](1) - p) <= EPS; }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C() = default;\n    C(P p, T r) : P(p), r(r) {}\n    friend istream& operator>>(istream& is, C& c) { P p; T r; is >> p >> r; c = C(p, r); return is; }\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return 1;         // counter clockwise\n    if (cross(b, c) < -EPS) return -1;       // clockwise\n    if (dot(b, c) < -EPS) return 2;          // c--a--b on line\n    if (norm(b) < norm(c) - EPS) return -2;  // a--b--c on line or a==b\n    return 0;                                // a--c--b on line or a==c or b==c\n}\n\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n\nvector<P> tangentPoints(C c, P p) {\n    if (eq(abs(p - c), c.r)) return vector<P>{p};\n    vector<P> res;\n    T t = acos(c.r / abs(p - c));\n    P q = (p - c) / abs(p - c) * c.r;\n    res.push_back(c + q * polar(T(1), t));\n    res.push_back(c + q * polar(T(1), -t));\n    sort(res.begin(), res.end(), cmpX);\n    return res;\n}\nvector<L> tangentLines(C c1, C c2, bool inner) {\n    if (abs(isInterCC(c1, c2)) <= 1) return vector<L>();\n    if (inner) c2.r = -c2.r;\n    vector<L> res;\n    P d = c2 - c1;\n    T dr = c1.r - c2.r, d2 = norm(d), h2 = d2 - dr * dr;\n    if (d2 == 0 || h2 < 0) { assert(h2 != 0); return res; }\n    for (T sign : {-1, 1}) {\n        P v = (d * dr + rot90(d) * sqrt(h2) * sign) / d2;\n        res.emplace_back(c1 + v * c1.r, c2 + v * c2.r);\n    }\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    while (cin >> N, N) {\n        vector<C> cs(N);\n        vector<int> m(N);\n        REP (i, N) cin >> cs[i] >> m[i];\n        REP (i, N) cs.emplace_back(cs[i], cs[i].r + m[i]);\n\n        if (N == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        auto count = [&](L& l) -> int {\n            int res = 0;\n            REP (i, N) {\n                T d = abs(cs[i] - l.proj(cs[i]));\n                res += (d >= cs[i].r - EPS && d <= cs[i].r + m[i] + EPS);\n            }\n            return res;\n        };\n        int ans = 0;\n        REP (i, cs.size()) FOR (j, i + 1, cs.size()) {\n            for (auto l : tangentLines(cs[i], cs[j], true)) {\n                ans = max(ans, count(l));\n            }\n            for (auto l : tangentLines(cs[i], cs[j], false)) {\n                ans = max(ans, count(l));\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP rot90(P p) { return P(-p.y, p.x); }\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n// 円と点\n// pがcの外側にあることを仮定している\nvector<P> tCP(C c, P p) {\n  vector<P> res;\n  D d = abs(c.p - p);\n  if(sig(d,c.r) < 0) return res;\n  D rc = c.r*c.r/d;\n  D rs = sqrt(max(0.0, c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  res.emplace_back(c.p + v*rc + rot90(v)*rs);\n  res.emplace_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  // どちらかの円が他方の円に囲まれているときは外接線は無い\n  if(sig(abs(a.r - b.r), abs(a.p - b.p)) >= 0) return res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  // 円が交差しているときは内接線は無い\n  if(sig(abs(a.r + b.r), abs(a.p - b.p)) >= 0) return res;\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCC(C a, C b) {\n  vector<L> res;\n  for(L l : tCCout(a, b)) res.push_back(l);\n  for(L l : tCCin(a, b)) res.push_back(l);\n  return res;\n}\n\nvoid dcircle(double x, double y, double r) {\n  cerr << \"circle(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << r*50 << \");\" << endl;\n}\nvoid dline(double x, double y, double a, double b) {\n  cerr << \"line(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << a*50+1000 << \",\" << b*50+1000 << \");\" << endl;\n}\n\nint main() {\n  for(int N; cin >> N, N; ) {\n    int x[2*N], y[2*N], r[2*N], m[2*N];\n    for(int i = 0; i < N; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      x[N+i] = x[i];\n      y[N+i] = y[i];\n      r[N+i] = r[i] + m[i];\n      // dcircle(x[i], y[i], r[i]);\n    }\n    int ans = 0;\n    for(int i = 0; i < 2*N; ++i) {\n      for(int j = i + 1; j < 2*N; ++j) {\n        vector<L> tangent = tCC(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]));\n        for(L l : tangent) {\n          // cerr << \"L = { { x = \" << l.a.x << \", y = \" << l.a.y << \" }, { \" << l.b.x << \", y = \" << l.b.y << \" } }\" << endl;\n          int tmp = 0;\n          for(int k = 0; k < N; ++k) {\n            D d = dLP(l, P(x[k], y[k]));\n            if(sig(d,r[k]) >= 0 && sig(d, m[k]+r[k]) <= 0) {\n              tmp++;\n            }\n          }\n\n#if 0\n          if(tmp == 6) {\n            dcircle(x[i], y[i], r[i]);\n            dcircle(x[j], y[j], r[j]);\n            dline(l.a.x, l.a.y, l.b.x, l.b.y);\n          }\n#endif\n          ans = max(ans, tmp);\n        }\n      }\n    }\n#if 1\n    if(N == 1) {\n      cout << 1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP rot90(P p) { return P(-p.y, p.x); }\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n// 円と点\n// pがcの外側にあることを仮定している\nvector<P> tCP(C c, P p) {\n  vector<P> res;\n  D d = abs(c.p - p);\n  if(sig(d,c.r) < 0) return res;\n  D rc = c.r*c.r/d;\n  D rs = sqrt(max(0.0, c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  res.emplace_back(c.p + v*rc + rot90(v)*rs);\n  res.emplace_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  // どちらかの円が他方の円に囲まれているときは外接線は無い\n  if(sig(abs(a.r - b.r), abs(a.p - b.p)) >= 0) return res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  // 円が交差しているときは内接線は無い\n  if(sig(abs(a.r + b.r), abs(a.p - b.p)) >= 0) return res;\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCC(C a, C b) {\n  vector<L> res;\n  for(L l : tCCout(a, b)) res.push_back(l);\n  for(L l : tCCin(a, b)) res.push_back(l);\n  return res;\n}\n\nvoid dcircle(double x, double y, double r) {\n  cerr << \"circle(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << r*50 << \");\" << endl;\n}\nvoid dline(double x, double y, double a, double b) {\n  cerr << \"line(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << a*50+1000 << \",\" << b*50+1000 << \");\" << endl;\n}\n\nint main() {\n  for(int N; cin >> N, N; ) {\n    int x[2*N], y[2*N], r[2*N], m[2*N];\n    for(int i = 0; i < N; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      x[N+i] = x[i];\n      y[N+i] = y[i];\n      r[N+i] = r[i] + m[i];\n      // dcircle(x[i], y[i], r[i]);\n    }\n    int ans = 0;\n    for(int i = 0; i < 2*N; ++i) {\n      for(int j = i + 1; j < 2*N; ++j) {\n        vector<L> tangent = tCC(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]));\n        for(L l : tangent) {\n          // cerr << \"L = { { x = \" << l.a.x << \", y = \" << l.a.y << \" }, { \" << l.b.x << \", y = \" << l.b.y << \" } }\" << endl;\n          int tmp = 0;\n          for(int k = 0; k < N; ++k) {\n            D d = dLP(l, P(x[k], y[k]));\n            if(sig(d,r[k]) >= 0 && sig(d, m[k]+r[k]) <= 0) {\n              tmp++;\n            }\n          }\n\n#if 0\n          if(tmp == 6) {\n            dcircle(x[i], y[i], r[i]);\n            dcircle(x[j], y[j], r[j]);\n            dline(l.a.x, l.a.y, l.b.x, l.b.y);\n          }\n#endif\n          ans = max(ans, tmp);\n        }\n      }\n    }\n#if 1\n    if(N == 1) {\n      cout << 1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst long double eps = 1e-10;\nconst long double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// 以下 幾何部分\ntemplate<class T> bool operator< (T a, T b){return (a-b) < -eps;}\ntemplate<class T> bool operator<=(T a, T b){return (a-b) < eps;}\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P> Pol;\n\n// ソートのキー\nB cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\nB cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\nint ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > 0)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < 0)      return RIGHT;   // clockwise\n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  aとbの線分判定はこれ\n}\n\n// 線分 直線\n\t// 点と直線の距離\n\t// 点と線分の距離\n\t// 直線と直線の距離\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// 交点\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// 点と直線と線分関連の交差判定\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 点と直線と線分関連の距離\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n\n// 円\n// Verify AOJ 1183\n\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//共通内接線\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// 共通外接線\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//接点を共有する接線\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\nint n;\n\nC jewel[110];\nint m[55];\n\nint check(L in){\n\tint res=0;\n\trep(i,n){\n\t\tD dis=dLP(in,jewel[i].c);\n\t\tif(jewel[i].r<=dis && dis<=jewel[i+n].r)\n\t\t\tres++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n ,n){\n\t\tint ans=1;\n\t\trep(i,n){\n\t\t\tC in;\n\t\t\tcin >> in.c.X >> in.c.Y >> in.r;\n\t\t\tjewel[i]=in;\n\t\t\tcin >> m[i];\n\t\t\tin.r+=m[i];\n\t\t\tjewel[i+n]=in;\n\t\t}\n\t\t\n\t\trep(i,2*n)rep(j,i){\n\t\t\tVL lines=common_tan(jewel[i],jewel[j]);\n\t\t\trep(k,lines.size())\n\t\t\t\tans=max(ans,check(lines[k]));\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosθ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinθ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2点を結ぶ直線\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n    double dist(const Point& p) const{ // 点との距離\n        return abs(a * p.x + b * p.y + c) / sqrt(a * a + b * b);\n    }\n    void shift(const Point& p){ // 平行移動\n        c -= a * p.x + b * p.y;\n    }\n};\n\nvector<Line> solve(const Point& c1, double r1, const Point& c2, double r2)\n{\n    Point c = c2 - c1;\n    double len2 = c.y * c.y + c.x * c.x;\n    vector<Line> ret;\n    if(len2 < EPS)\n        return ret;\n\n    // 共通外接線\n    double d = len2 - pow(r1 - r2, 2);\n    if(d > EPS){\n        ret.push_back(Line((c.x * (r1 - r2) + c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 - r2) - c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n        ret.push_back(Line((c.x * (r1 - r2) - c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 - r2) + c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n    }else if(d > -EPS){\n        ret.push_back(Line((c.x * (r1 - r2)) * r1 / c.length(),\n                           (c.y * (r1 - r2)) * r1 / c.length(),\n                           - r1 * r1));\n    }\n    \n    // 共通内接線\n    d = len2 - pow(r1 + r2, 2);\n    if(d > EPS){\n        ret.push_back(Line((c.x * (r1 + r2) + c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 + r2) - c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n        ret.push_back(Line((c.x * (r1 + r2) - c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 + r2) + c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n    }else if(d > -EPS){\n        ret.push_back(Line((c.x * (r1 + r2)) * r1 / c.length(),\n                           (c.y * (r1 + r2)) * r1 / c.length(),\n                           - r1 * r1));\n    }\n\n    for(unsigned i=0; i<ret.size(); ++i)\n        ret[i].shift(c1);\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        if(n == 1){\n            cout << 1 << endl;\n            continue;\n        }\n\n        vector<Point> c(n);\n        vector<double> r(n), m(n);\n        for(int i=0; i<n; ++i)\n            cin >> c[i].x >> c[i].y >> r[i] >> m[i];\n\n        int ret = 0;\n        for(int s=0; s<n; ++s){\n            for(int t=0; t<s; ++t){\n                for(int k=0; k<4; ++k){\n                    double a = r[s];\n                    double b = r[t];\n                    if(k & 1)\n                        a += m[s];\n                    if(k & 2)\n                        b += m[t];\n                    vector<Line> line = solve(c[s], a, c[t], b);\n\n\n                    for(unsigned i=0; i<line.size(); ++i){\n                        int tmp = 0;\n                        for(int j=0; j<n; ++j){\n                            double d = line[i].dist(c[j]);\n                            if(r[j] - EPS < d && d < r[j] + m[j] + EPS)\n                                ++ tmp;\n                        }\n                        ret = max(ret, tmp);\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>10000) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle() {}\n    Circle(const Point& p, Real r) : p(p), r(r) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nvector<Line> common_tangent(const Circle& c1, const Circle& c2) {\n    vector<Line> lines;\n    Point u = c2.p - c1.p;\n    Real d = abs(u);\n    if (eq(d, 0.0)) return lines;\n    u /= d;\n    for (Real s : { -1, 1 }) {\n        Real h = (c1.r + s * c2.r) / d;\n        if (eq(abs(h), 1.0)) {\n            lines.emplace_back(\n                    c1.p + u * h * c1.r,\n                    c1.p + u * h * c1.r + rotate(u, PI / 2.0));\n        } else if (abs(h) < 1) {\n            Real a = acos(h);\n            lines.emplace_back(\n                    c1.p + u * polar(c1.r, a),\n                    c2.p - s * u * polar(c2.r, a));\n            lines.emplace_back(\n                    c1.p + u * polar(c1.r, -a),\n                    c2.p - s * u * polar(c2.r, -a));\n        }\n    }\n    return lines;\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n            B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<Circle> circles(2*n);\n        vector<Point> points(n);\n        vector<double> r(n), m(n);\n        REP(i, n) {\n            double x, y;\n            cin >> x >> y >> r[i] >> m[i];\n            m[i] += r[i];\n            points[i] = Point{ x, y };\n            circles[2*i] = Circle{ points[i], r[i] };\n            circles[2*i+1] = Circle{ points[i], m[i] };\n        }\n\n        if (n == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        int ans = 0;\n        REP(i, 2*n) {\n            FOR(j, i+1, 2*n) {\n                vector<Line> lines = common_tangent(circles[i], circles[j]);\n                for (Line& line : lines) {\n                    int total = 0;\n                    REP(k, n) {\n                        double d = distance(line, points[k]);\n                        if (r[k] < d + EPS and d < m[k] + EPS) ++total;\n                    }\n                    chmax(ans, total);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-5)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool iscrossCL1(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\nbool iscrossCL2(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<eps)return true;\n  return false;\n}\n\n// ??¢???????????? return 4\n// ?????\\?????? return 3\n// ????????? return 2\n// ?????\\?????? return 1\n// ?????? return 0\nint intersect(Circle a,Circle b){\n  double dis=abs(a.c-b.c),sumr=a.r+b.r,minr=min(a.r,b.r),maxr=max(a.r,b.r);\n  if((sumr-dis)<-eps)return 4;\n  if(equals(sumr,dis))return 3;\n  if((maxr-(dis+minr))<-eps)return 2;\n  if(equals(dis+minr,maxr))return 1;\n  return 0;\n}\n\nvector<Line> getCommonTangent(Circle a,Circle b){\n  vector<Line> vp;\n  int intersection=intersect(a,b);\n  if(intersection==0)return vp;\n  if(intersection==1){\n    Vector v=b.c-a.c;\n    if(b.r<a.r)v=(v*a.r)/abs(v);\n    else v=(v*a.r*(-1))/abs(v);\n    vp.push_back(Line(a.c+v,a.c+v));\n    return vp;\n  }\n  if(intersection==3){\n    Vector v=b.c-a.c;\n    v=v*a.r/abs(v);\n    vp.push_back(Line(a.c+v,a.c+v));\n  }\n  double d=abs(b.c-a.c),c,s;\n  Vector v=(b.c-a.c)/d,v1=v*a.r,v2=v*b.r;\n  Point p1,p2;\n\n  c=sqrt(d*d-(a.r-b.r)*(a.r-b.r));\n  s=(180*asin(c/d))/pi;\n\n  if(a.r<b.r){\n    vp.push_back(Line(rotate(a.c,a.c+v1,180-s),rotate(b.c,b.c-v2,360-s)));\n    vp.push_back(Line(rotate(a.c,a.c+v1,180+s),rotate(b.c,b.c-v2,s)));\n  }\n  else {\n    vp.push_back(Line(rotate(a.c,a.c+v1,s),rotate(b.c,b.c-v2,180+s)));\n    vp.push_back(Line(rotate(a.c,a.c+v1,360-s),rotate(b.c,b.c-v2,180-s)));\n  }\n  if(intersection==2 || intersection==3)return vp;\n  \n  c=sqrt(d*d-(a.r+b.r)*(a.r+b.r));\n  s=(180*asin(c/d))/pi;\n  \n  vp.push_back(Line(rotate(a.c,a.c+v1,s),rotate(b.c,b.c-v2,s)));\n  vp.push_back(Line(rotate(a.c,a.c+v1,360-s),rotate(b.c,b.c-v2,360-s)));\n  \n  return vp;\n}\n\nint main()\n{\n  int n,a,b,c,d;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<pair<Circle,Circle> > v;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d;\n      v.push_back(mp(Circle(Point(a,b),c),Circle(Point(a,b),c+d)));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<Line> V;\n\tvector<Line> v1=getCommonTangent(v[i].f,v[j].f);\n\tvector<Line> v2=getCommonTangent(v[i].f,v[j].s);\n\tvector<Line> v3=getCommonTangent(v[i].s,v[j].f);\n\tvector<Line> v4=getCommonTangent(v[i].s,v[j].s);\n\tV.insert(V.begin(),v1.begin(),v1.end());\n\tV.insert(V.begin(),v2.begin(),v2.end());\n\tV.insert(V.begin(),v3.begin(),v3.end());\n\tV.insert(V.begin(),v4.begin(),v4.end());\n\tfor(int k=0;k<V.size();k++){\n\t  int sum=0;\n\t  for(int z=0;z<n;z++){\n\t    if(!iscrossCL1(v[z].f,V[k]) && iscrossCL2(v[z].s,V[k]))sum++;\n\t  }\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2015/05/29\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P p;\n  double r;\n  C() {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\n// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\nint contain(C c, P p) {\n  if(abs(c.p - p) - c.r <  -eps) return 2;\n  if(abs(c.p - p) - c.r >  eps) return 0;\n  return 1;\n}\n\n// 轤ケ縺悟、夊ァ貞ス「縺ョ蜀?Κ/蠅?阜/螟夜Κ縺ョ縺ゥ縺薙↓縺ゅｋ縺九ｒ蛻、螳壹☆繧具シ?// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\n// by Spaghetti Source\nint contain(const vector<P> &g, const P &p) {\n  int n = g.size();\n  int in = 0;\n  for(int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() < eps && eps < b.imag() && cross(a, b) < -eps) in = !in;\n    if(abs(cross(a, b)) < eps && dot(a, b) < eps) return 1;\n  }\n  return in * 2;\n}\n\n// 邱壼?縺ィ邱壼?縺ョ莠、蟾ョ蛻、螳壹?\n// T蟄励ｄL蟄励∩縺溘＞縺ォ縺ェ縺」縺ヲ縺?ｋ譎ゅｂtrue繧定ソ斐☆縺後?\n// 縺薙ｌ繧帝勁螟悶＠縺溘＞蝣エ蜷医↓ <= 繧?< 縺ォ螟画峩縺励※繧ゅ≧縺セ縺上＞縺九↑縺??\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// 逶エ邱壹→蜀??莠、蟾ョ蛻、螳壹?謌サ繧雁?縺ッ莠、轤ケ縺ョ謨ー縲?int isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.p);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// 蜀?→蜀??莠、蟾ョ蛻、螳壹?\n//  0 : 莠、蟾ョ縲∝?蛹?↑縺?//  1 : 螟夜Κ縺ァ1轤ケ縺ィ謗・縺吶ｋ\n//  2 : 2轤ケ縺ァ莠、蟾ョ\n// -1 : 蜀?桁縺励※謗・縺吶ｋ\n// -2 : 螳悟?縺ォ蜀?桁\nint isIntersect(C a, C b) {\n  double x = a.p.real() - b.p.real();\n  double y = a.p.imag() - b.p.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// 逶エ邱壹→逶エ邱壹?莠、轤ケ縲?P getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross 縺ョ隨ヲ蜿キ髢「菫ゅ≠繧?  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// 逶エ邱壹→蜀??莠、轤ケ縲?vector<P> getCrossPLC(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.p);\n  double dist = getDistanceLP(s1, s2, c.p);\n  if (equals(dist, c.r)) {\n    v.push_back(p);\n  } else if (dist < c.r) {\n    double h = abs(p - c.p);\n    double d = sqrt(c.r * c.r - h * h);\n    P base = s2 - s1;\n    // push_back縺吶ｋ鬆?分縺ッ驥崎ヲ?    v.push_back(p - d * base / abs(base));\n    v.push_back(p + d * base / abs(base));\n  }\n  return v;\n}\n\n// 蜀?→蜀??莠、轤ケ縲?vector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.p - c2.p);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.p - c1.p;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.p + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.p + A*base + h*n);\n    v.push_back(c1.p + A*base - h*n);\n  }\n  return v;\n}\n\n// 2縺、縺ョ繝吶け繝医Ν縺ョ縺ェ縺呵ァ?0 <= rad <= PI)\n// AOJ2233縺ァ繝舌げ縺」縺溘?縺ァ譖エ譁ー(2015/05/29)\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\n// a -> b 縺ク縺ョ隗貞コヲ縺ョ遘サ蜍暮?(0 <= rad < 2*PI)\ndouble getAngleVector(P a, P b) {\n  double A = arg(a);\n  double B = arg(b);\n  double rad = B-A;\n  rad = fmod(rad, M_PI*2.0);\n  if(rad < 0.0) rad += M_PI*2.0;\n  return rad;\n}\n\n// 2縺、縺ョ逶エ邱壹↓謗・縺吶ｋ蜊雁セв縺ョ蜀?C getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = arg(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.p = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 繝倥Ο繝ウ縺ョ蜈ャ蠑上ｒ逕ィ縺?※荳芽ァ貞ス「縺ョ3霎コ縺ョ髟キ縺輔°繧蛾擇遨阪ｒ豎ゅａ繧?double heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// 螟夊ァ貞ス「縺ョ髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\ndouble getTriArea(P a, P b, P c) {\n  return cross(b-a, c-a) / 2.0;\n}\n\ndouble getSectorArea(P a, P b, C c) {\n  return getAngleVector(a-c.p, b-c.p) * c.r * c.r / 2.0;\n}\n\ndouble getBowArea(P a, P b, C c) { // a,b is a chord of c.\n  return getSectorArea(a, b, c) - getTriArea(a, b, c.p);\n}\n\ndouble getArea(P a, P b, C c) {\n  int d = 1;\n  if(cross(a,b) < 0.0) {\n    d = -1;\n    swap(a, b);\n  }\n  if(cross(a, b) < eps) return 0;\n\n  G t(3);\n  t[0] = P(0, 0), t[1] = a, t[2] = b;\n\n  if(contain(c, t[0]) && contain(c, t[1]) && contain(c, t[2])) {\n    return d * getTriArea(t[0], t[1], t[2]);\n  }\n\n  if(getDistanceSP(t[0], t[1], c.p) - c.r > -eps &&\n     getDistanceSP(t[1], t[2], c.p) - c.r > -eps &&\n     getDistanceSP(t[2], t[0], c.p) - c.r > -eps) {\n    if(cross(t[1] - t[0], c.p - t[0]) > -eps &&\n       cross(t[2] - t[1], c.p - t[1]) > -eps &&\n       cross(t[0] - t[2], c.p - t[2]) > -eps) {\n      return d * (c.r * c.r * M_PI);\n    } else {\n      return 0;\n    }\n  }\n\n  double S = c.r * c.r * M_PI;\n  vector<P> cp(6);\n  vector<int> exist(6);\n  for(int i = 0; i < 3; ++i) {\n    P p = t[i], q = t[(i+1)%3];\n    if(getDistanceLP(p, q, c.p) - c.r > -eps) {\n      if(cross(q - p, c.p - p) < 0) return 0;\n      continue;\n    }\n    if(getDistanceSP(p, q, c.p) - c.r > -eps) continue;\n    vector<P> v = getCrossPLC(t[i], t[(i+1)%3], c);\n    if(v.size() == 2 && !equals(v[0], v[1])) {\n      S -= getBowArea(v[0], v[1], c);\n      for(int j = 0; j < v.size(); ++j) {\n        int k = (i*2 + j*3) % 6;\n        cp[k] = v[j];\n        exist[k] = true;\n      }\n    }\n  }\n  for(int i = 0; i < 3; ++i) {\n    int a = i*2, b = i*2+1;\n    if(!exist[a] || !exist[b]) continue;\n    if(contain(c, t[i]) == 2 && !equals(cp[a], cp[b])) {\n      S += getBowArea(cp[a], cp[b], c) + getTriArea(t[i], cp[a], cp[b]);\n    }\n  }\n  return S * d;\n}\n\n// 螟夊ァ貞ス「縺ィ蜀??蜈ア騾夐Κ蛻??髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(G g, C c) {\n  int n = g.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += getArea(g[i], g[(i+1)%n], c);\n  }\n  return res;\n}\n\n// 荳芽ァ貞ス「縺ョ蜀?磁蜀??蜊雁セ?double getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// 繧ュ繝」繝ェ繝代?豕輔ｒ逕ィ縺?※螟夊ァ貞ス「縺ョ譛?ｂ驕?＞?帝?轤ケ縺ョ霍晞屬繧定ソ斐☆\n// O(NlogN)\n// by Ari book\ndouble caliper(const vector<P> &ps) {\n  vector<P> qs = convex_hull(ps);\n  int n = qs.size();\n  if(n == 2) {\n    return abs(qs[0] - qs[1]);\n  }\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k) {\n    if(!(qs[i] < qs[k])) i = k;\n    if(qs[j] < qs[k]) j = k;\n  }\n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(qs[i] - qs[j]));\n    if(cross((qs[(i+1)%n] - qs[i]), (qs[(j+1)%n] - qs[j])) < 0) {\n      i = (i+1)%n;\n    } else {\n      j = (j+1)%n;\n    }\n  }\n  return res;\n}\n\nvector<L> getTangent(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  if (a.p == b.p) return res;\n  P base = b.p - a.p;\n  for (double s = -1; s <= 1; ++++s) {\n    double c, d, ee;\n    ee = norm(base);\n    d = b.r + a.r * s;\n    if (ee - d * d < 0.0) continue;\n    c = sqrt(ee - d * d);\n    if (c < eps) {\n      P v = base * P(0, 1);\n      P m = b.p - base * b.r / abs(base);\n      res.push_back(L(m, m + v));\n    } else {\n      for (double t = -1; t <= 1; ++++t) {\n        P rotate(c / sqrt(ee), d / sqrt(ee) * t);\n        P v = -base * rotate * s;\n        P nv = v / abs(v) * P(0, t);\n        res.push_back(L(a.p + nv * a.r, b.p - nv * b.r * s));\n      }\n    }\n  }\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      double x, y;\n      cin >> x >> y >> r[i] >> m[i];\n      p[i] = P(x, y);\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif(intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\t   min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n// 2????????????2??¬?????±?????\\???\nvector<L> tangentCC(C c1, C c2){\n\tif(c1.r < c2.r) swap(c1, c2);\n\tdouble dist = abs(c1.p - c2.p);\n\tvector<L> ret;\n\n\tif(dist > c1.r + c2.r){\n\t\t// ??\\????????????\n\t\tP cp = c1.p + (c2.p - c1.p) * c1.r / (c1.r + c2.r);\n\t\tP v = cp - c1.p;\n\t\tdouble d = abs(v);\n\t\tdouble theta = acos(c1.r / d);\n\t\tP p1 = c1.p + v * polar(1.0, theta) / d * c1.r;\n\t\tP p2 = c1.p + v * polar(1.0, -theta) / d * c1.r;\n\n\t\tret.push_back(L(p1, cp));\n\t\tret.push_back(L(p2, cp));\n\t}\n\n\tif(dist + c2.r > c1.r) {\n\t\tP v = c2.p - c1.p;\n\t\tdouble d = abs(v);\n\t\tdouble theta = acos((c1.r - c2.r) / d);\n\t\tfor(int i = -1; i <= 1; i += 2) {\n\t\t\tP x = v * polar(1.0, theta * i) / d;\n\t\t\tP p1 = c1.p + x * c1.r;\n\t\t\tP p2 = c2.p + x * c2.r;\n\t\t\tret.push_back(L(p1, p2));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < ret.size(); i++) {\n\t\t//cerr << abs(distanceLP(ret[i], c1.p) - c1.r) << endl;\n\t\tassert(abs(distanceLP(ret[i], c1.p) - c1.r) < EPS);\n\t\t//cerr << abs(distanceLP(ret[i], c2.p) - c2.r) << endl;\n\t\tassert(abs(distanceLP(ret[i], c2.p) - c2.r) < EPS);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<C> c;\n\t\tvector<double> m(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r >> m[i];\n\t\t\tc.push_back(C(P(x, y), r));\n\t\t}\n\n\t\tif(N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = i + 1; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < 2; k++) {\n\t\t\t\t\tfor(int l = 0; l < 2; l++) {\n\t\t\t\t\t\tC c1 = c[i], c2 = c[j];\n\t\t\t\t\t\tif(k) c1.r += m[i];\n\t\t\t\t\t\tif(l) c2.r += m[j];\n\t\t\t\t\t\tvector<L> ls = tangentCC(c1, c2);\n\t\t\t\t\t\tfor(auto line : ls) {\n\t\t\t\t\t\t\tint sum = 2;\n\t\t\t\t\t\t\tfor(int x = 0; x < N; x++) {\n\t\t\t\t\t\t\t\tif(x == i || x == j) continue;\n\t\t\t\t\t\t\t\tdouble d = distanceLP(line, c[x].p);\n\t\t\t\t\t\t\t\tif(c[x].r <= d && d <= c[x].r + m[x]) sum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, sum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate<typename T,std::size_t N>\nstruct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\ntemplate<typename T>\nstruct _v_traits<T,1> {using type = std::vector<T>;};\ntemplate<typename T,std::size_t N=1>\nusing vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// rotate by theta (-pi,+pi)\n// arg will return angle of point\npoint rotate(point p,double theta){\n    double cos_theta = cos(theta),\n           sin_theta = sin(theta);\n    return point(p.real()*cos_theta - p.imag()*sin_theta,\n                 p.real()*sin_theta + p.imag()*cos_theta);\n}\nconst double EPS = 1e-6;\n// 二つの円の共通接線\n//  ふつうは4つ？\nvector<pair<point,point> > common_tangent_of_two_circles(point c1,double r1,point c2,double r2){\n    // shift c2 by c1.\n    point nc = c2 - c1;\n    // c.img == 0\n    double ar = arg(nc);\n    point c = rotate(nc,ar);\n\n    vector<pair<point,point> > ret;\n    vector<double> xs;\n    for(int sign=-1;sign<=1;sign+=2){\n        xs.push_back((r1*r1 + sign*r1*r2)/c.real());\n    }\n    for(double x1 : xs){\n        double y2 = r1*r1 - x1*x1;\n        for(int sign=-1;sign<=1;sign+=2){\n            double y1 = sign*sqrt(y2);\n            // x1*x + y1*y = r1*r1 is such line\n            point h = point(x1,y1);\n            point t = point(0,r1*r1/y1); // tekito\n            if(abs(y1) < EPS){\n                t = point(x1,y1+1);\n            }\n\n            ret.push_back(make_pair(h,t));\n        }\n    }\n    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair<point,point> p){\n            return make_pair(rotate(p.first,-ar)+c1,\n                             rotate(p.second,-ar)+c1);\n        });\n    return ret;\n}\n\nstruct Jewel {\n    point p;\n    double r;\n    double m;\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true){\n        int N; cin >> N;\n        if(N == 0) break;\n        vector<Jewel> jewels;\n        for(int i=0;i<N;i++){\n            double x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewels.push_back(Jewel{point(x,y),r,m});\n        }\n\n        vector<pair<point,double> > circles;\n        for(auto& j : jewels){\n            circles.push_back(make_pair(j.p,j.r));\n            circles.push_back(make_pair(j.p,j.r + j.m));\n        }\n        int maxi = min(2ll,N);\n        for(int i=0;i<circles.size();i++){\n            int skip = (i%2 == 0)?2:1;\n            for(int j=i+skip;j<circles.size();j++){\n                auto lines = common_tangent_of_two_circles(circles[i].first,circles[i].second,\n                                                           circles[j].first,circles[j].second);\n                for(pair<point,point>& line : lines){\n                    int cnt = 0;\n                    for(auto& jewel : jewels){\n                        double d = dist_line_and_point(line.first,line.second,jewel.p);\n                        if(jewel.r < d + EPS and d < jewel.r + jewel.m + EPS){\n                            cnt++;\n                        }\n                    }\n                    maxi = max(maxi,cnt);\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\nPoint rotate90(const Point &p){ return Point(-p.y,p.x); }\n\nstruct Line{\n    Point s,t;\n    Line(){}\n    Line(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Line &l,const Point &p){\n    Point b = l.t-l.s;\n    double t = dot(p-l.s,b)/norm(b);\n    return l.s+b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n    return abs(p-projection(l,p));\n}\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p,double r) : p(p),r(r) {}\n};\n\nvector<Point> tangentCP(const Circle &c,const Point &p){\n    double x = norm(p - c.p);\n    double d = x - c.r*c.r;\n    if(d < -EPS) return vector<Point>();\n    d = max(d, 0.0);\n    Point p1 = (p-c.p)*(c.r*c.r/x);\n    Point p2 = rotate90((p-c.p)*(-c.r*sqrt(d)/x));\n    vector<Point> res;\n    res.push_back(c.p + p1 - p2);\n    res.push_back(c.p + p1 + p2);\n    return res;\n}\n\nvector<Line> tangentCC(const Circle &a,const Circle &b){\n    vector<Line> res;\n    vector<Point> ps,qs;\n    if(abs(b.p-a.p) < EPS) return res;\n    if(abs(a.r - b.r) < EPS){\n        Point dir = b.p-a.p;\n        dir = rotate90(dir*(a.r/abs(dir)));\n        res.push_back(Line(a.p+dir,b.p+dir));\n        res.push_back(Line(a.p-dir,b.p-dir));\n    }else{\n        Point p = a.p*(-b.r) + b.p*a.r;\n        p = p*(1.0/(a.r-b.r));\n        ps = tangentCP(a,p);\n        qs = tangentCP(b,p);\n        int n = ps.size(), m = qs.size();\n        for(int i = 0 ; i < min(n,m) ; i++){\n            res.push_back(Line(ps[i],qs[i]));\n        }\n    }\n    Point p = a.p*b.r + b.p*a.r;\n    p = p*(1.0/(a.r+b.r));\n    ps = tangentCP(a,p);\n    qs = tangentCP(b,p);\n    int n = ps.size(), m = qs.size();\n    for(int i = 0 ; i < min(n,m) ; i++){\n        res.push_back(Line(ps[i],qs[i]));\n    }\n    return res;\n}\n\nstruct Data{\n    Circle c;\n    double m;\n    Data(){}\n};\n\nvector<Line> getTCC(const Point &p1,double r1,\n                    const Point &p2,double r2){\n    Circle c1(p1,r1),c2(p2,r2);\n    vector<Line> res = tangentCC(c1,c2);\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N, N){\n        vector<Data> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].c.p.x >> v[i].c.p.y >> v[i].c.r >> v[i].m;\n            v[i].m += v[i].c.r;\n        }\n        vector<Line> lines;\n        for(int i = 0 ; i < N ; i++){\n            for(int j = i+1 ; j < N ; j++){\n                Point p1 = v[i].c.p, p2 = v[j].c.p;\n                double r1 = v[i].c.r, r2 = v[j].c.r;\n                double m1 = v[i].m, m2 = v[j].m;\n                vector<Line> l;\n                l = getTCC(p1,r1,p2,r2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,r1,p2,m2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,m1,p2,r2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,m1,p2,m2);\n                lines.insert(lines.end(),l.begin(),l.end());\n            }\n        }\n        int res = 1;\n        for(int i = 0 ; i < (int)lines.size() ; i++){\n            int cnt = 0;\n            for(int j = 0 ; j < N ; j++){\n                double d = distanceLP(lines[i],v[j].c.p);\n                if(le(v[j].c.r,d) && le(d,v[j].m)) cnt++;\n            }\n            res = max(res,cnt);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n  return res;\n}\n\ndouble getDistanceSP(L s, P p){\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));\n}\n\nCircle c[N][2];\n\nint main(){\n  int n,x,y,r,m;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>r>>m;\n      c[i][0]=Circle(P(x,y),r);\n      c[i][1]=Circle(P(x,y),r+m);\n    }\n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<2;j++)\n\tfor(int k=i+1;k<n;k++)\n\t  for(int l=0;l<2;l++){\n\t    vector<L> r=tangentCC(c[i][j],c[k][l]);\n\t    for(int a=0;a<r.size();a++){\n\t      int sum=0;\n\t      for(int b=0;b<n;b++){\n\t\tdouble d=getDistanceSP(r[a],c[b][0].c);\n\t\tif(c[b][0].r-EPS<=d&&d<=c[b][1].r+EPS)sum++;\n\t      }\n\t      ans=max(ans,sum);\n\t    }\n\t  }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b){};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(double(l))) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<double> x(n), y(n), r(n), m(n);\n\t\tvector<Circle> gem;\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i]));\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i] + m[i]));\n\t\t}\n\t\tvector<Line> ls;\n\t\tREP(i, gem.size())REP(j, i)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tauto tmp = tangent_cc(gem[i], gem[j]);\n\t\t\tREP(k, tmp.size()) ls.push_back(tmp[k]);\n\t\t}\n\t\tint ans = 1;\n\n\t\tREP(i, ls.size())\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tdouble d = dist_lp(ls[i], Point(x[j],y[j]));\n\t\t\t\tif (d - r[j] > -EPS && d - r[j] - m[j] < EPS) cnt++;\n\t\t\t}\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-8)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nPoint rotate(Point p, double th) {\n  // th[rad]\n  return Point(cos(th)*p.x-sin(th)*p.y, sin(th)*p.x+cos(th)*p.y);\n}\nPoint rotate90(Point p) {\n  return Point(-p.y, p.x);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s = Point(), Point t = Point()):s(s), t(t){}\n};\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n  Vector base = s.t - s.s;\n  double r = dot(p - s.s, base) / norm(base);\n  return s.s + base * r;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.t - l.s, p - l.s) / abs(l.t - l.s));\n}\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle(Point p = Point(), double r = 0.0):p(p), r(r){}\n};\n\nbool intersect(Circle c1, Circle c2) {\n  double d = getDistance(c1.p, c2.p);\n  return le(d, c1.r+c2.r) && !lt(d, fabs(c1.r-c2.r));\n}\n\nvector<Point> getCrossPointsCL(Circle c, Line l) {\n  vector<Point> res;\n  Vector pr = project(l, c.p);\n  if(lt(c.r, abs(c.p-pr))) return res;\n  Vector e = (l.t-l.s)/abs(l.t-l.s);\n  double base = sqrt(c.r*c.r-norm(pr-c.p));\n  res.push_back(pr+e*base);\n  if(!eq(base, 0)) res.push_back(pr-e*base);\n  return res;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n  Vector a = p-c.p;\n  vector<Point> res;\n  double x = norm(a);\n  double d = x-c.r*c.r;\n  if(d < -EPS) return res;\n  d = max(d, 0.0);\n  Point p1 = a*(c.r*c.r/x);\n  Point p2 = rotate90(a)*(-c.r*sqrt(d)/x);\n  res.emplace_back(c.p+p1-p2);\n  res.emplace_back(c.p+p1+p2);\n  return res;\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n  vector<Line> res;\n  vector<Point> ps, qs;\n  if(abs(c2.p-c1.p) < EPS) return res;\n  // ?????\\???\n  if(abs(c1.r-c2.r) < EPS) {\n    Point dir = c2.p-c1.p;\n    dir = rotate90(dir*(c1.r/abs(dir)));\n    res.emplace_back(c1.p+dir, c2.p+dir);\n    res.emplace_back(c1.p-dir, c2.p-dir);\n  } else {\n    Point p = c1.p*(-c2.r)+c2.p*c1.r;\n    p = p*(1.0/(c1.r-c2.r));\n    ps = tangentCP(c1, p);\n    qs = tangentCP(c2, p);\n    int n = ps.size(), m = qs.size();\n    for(int i = 0; i < min(n, m); i++) {\n      res.emplace_back(ps[i], qs[i]);\n    }\n  }\n  // ?????\\???\n  Point p = c1.p*c2.r+c2.p*c1.r;\n  p = p*(1.0/(c1.r+c2.r));\n  ps = tangentCP(c1, p);\n  qs = tangentCP(c2, p);\n  int n = ps.size(), m = qs.size();\n  for(int i = 0; i < min(n, m); i++) {\n    res.emplace_back(ps[i], qs[i]);\n  }\n  return res;\n}\n\nint N;\nvector<Circle> C;\nvector<double> m;\n\nint getJewels(Line l) {\n  int res = 0;\n  rep(i, N) {\n    double dist = getDistanceLP(l, C[i].p);\n    if(lt(dist, C[i].r)) continue;\n    if(le(dist, m[i]+C[i].r)) res++;\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    resz(C, N);\n    resz(m, N);\n    rep(i, N) cin >> C[i].p.x >> C[i].p.y >> C[i].r >> m[i];\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    int ans = 0;\n    rep(i, N) reps(j, i+1, N) {\n      Circle c1(C[i].p, C[i].r+m[i]), c2(C[j].p, C[j].r+m[j]);\n      vector<Line> L1 = tangentCC(C[i], C[j]);\n      for(Line l : L1) chmax(ans, getJewels(l));\n      vector<Line> L2 = tangentCC(C[i], c2);\n      for(Line l : L2) chmax(ans, getJewels(l));\n      vector<Line> L3 = tangentCC(c1, C[j]);\n      for(Line l : L3) chmax(ans, getJewels(l));\n      vector<Line> L4 = tangentCC(c1, c2);\n      for(Line l : L4) chmax(ans, getJewels(l));\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t円と円の共通接線\n\n\t説明\n\t\t円と円の共通接線を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（接線の場合）\n\t戻り値\n\t\t接線の本数\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n*/\nint tangent(const circle<double> &C1, const circle<double> &C2, vector< line<double> > &res ){\n\tdouble d=abs(C1.c-C2.c);\n\tif (d<EPS ) return 0;\t// C1,C2 は同心円上にある\n\n\tint c = 0;\n\t// 内接線\n\tif(C1.r+C2.r<d-EPS ){\n\t\tdouble t=acos((C1.r+C2.r)/d);\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c), t),C2.c+rot(C2.r/d*(C1.c-C2.c), t)});\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c),-t),C2.c+rot(C2.r/d*(C1.c-C2.c),-t)});\n\t\tc+=2;\n\t}else\n\tif (C1.r+C2.r<d+EPS ){\n\t\tpoint<double> p=C1.c+C2.r/d*(C2.c-C1.c);\n\t\tres.push_back (line<double>{p,p+rot(C2.c-C1.c,PI/2)});\n\t\tc++;\n\t} // end if\n\t\n\t// 外接線\n\tif (abs(C1.r-C2.r)<d-EPS ){\n\t\tdouble t1=acos((C1.r-C2.r)/d),t2=PI-t1;\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c), t1),C2.c+rot(C2.r/d*(C1.c-C2.c),-t2)});\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c),-t1),C2.c+rot(C2.r/d*(C1.c-C2.c), t2)});\n\t\tc+=2;\n\t}else\n\tif (abs(C1.r-C2.r)<d+EPS ){\n\t\tpoint<double> p=C1.c+C1.r/d*(C2.c-C1.c);\n\t\tres.push_back((line<double>){p,p+rot(C2.c-C1.c,PI/2)});\n\t\tc++;\n\t} // end if\n\t\n\treturn c;\n}\n\nstruct Jew{\n\tcircle<double> c;\n\tdouble m;\n//\tJew(circle<double> c, double m):circle<double>(c),m(m){}\n};\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2201\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tvector<Jew> jew(n);\n\t\trep (i, n ){\n\t\t\tint x, y, r, m;\n\t\t\tscanf (\"%d %d %d %d\", &x, &y, &r, &m );\n\t\t\tjew[i].c.c.x\t= (double)x;\n\t\t\tjew[i].c.c.y\t= (double)y;\n\t\t\tjew[i].c.r\t\t= (double)r;\n\t\t\tjew[i].m\t\t= (double)m;\n\t\t} // end rep\n\t\tint ans = 1;\n\t\trep (i, n ){\n\t\t\tfor (int j = i+1; j < n; j++ ){\n\t\t\t\tJew j1 = jew[i], j2 = jew[j];\n\t\t\t\tcircle<double> c1 = j1.c, c2 = j2.c;\n\t\t\t\tJew j3 = jew[i], j4 = jew[j];\n\t\t\t\tcircle<double> c3=(circle<double>){(point<double>)j3.c.c, (double)j3.c.r+j3.m};\n\t\t\t\tcircle<double> c4=(circle<double>){(point<double>)j4.c.c, (double)j4.c.r+j4.m};\n\t\t\t\t\t\t\t\n\t\t\t\tvector< line<double> > l1, l2; l1.clear();l2.clear();\n\t\t\t\tint cnt1 = tangent (c1, c2, l1 );\n\t\t\t\tint cnt2 = tangent (c3, c4, l2 );\n\t\t\t\trep (a, cnt1 ){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep (b, n ){\n\t\t\t\t\t\tdouble dis = dist (l1[a], jew[b].c.c );\n\t\t\t\t\t\tif (dis + EPS > jew[b].c.r && dis < jew[b].c.r + jew[b].m + EPS ) cnt++;\n\t\t\t\t\t} // end rep\n\t\t\t\t\tans = max (ans, cnt );\n\t\t\t\t} // end rep\n\t\t\t\trep (a, cnt2 ){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\trep (b, n ){\n\t\t\t\t\t\tdouble dis = dist (l2[a], jew[b].c.c );\n\t\t\t\t\t\tif (dis + EPS > jew[b].c.r && dis < jew[b].c.r + jew[b].m + EPS ) cnt++;\n\t\t\t\t\t} // end rep\n\t\t\t\t\tans = max (ans, cnt );\n\t\t\t\t} // end rep\n\t\t\t} // end for\n\t\t} // end rep\n\t\tprintf (\"%d\\n\", ans );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  elem rEx1 = sqrt( D*D + r2*r2 );\n  elem rEx2 = sqrt( D*D + r1*r1 );\n  intersection_circles( circle(c1.c, rEx1), c2, pcross );\n  intersection_circles( circle(c2.c, rEx2), c1, pcross2 );\n  ret[0] = line(pcross2.second,pcross.first);\n  ret[1] = line(pcross2.first,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n\n  //internal\n  point In((r2*c1.c+r1*c2.c)/(r1+r2));\n  elem rIn = sqrt( pow(abs(c1.c-In),2.0)-(r1*r1) );\n  intersection_circles( circle(In,rIn), c1, pcross );\n  ret[2] = line(In,pcross.first);\n  ret[3] = line(In,pcross.second);\n\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\ntypedef complex<ld> Point;\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine () : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle () : p(Point(0, 0)), r(0) {}\n\tCircle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll (Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps){\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d,\tc.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0,\t1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j,n) res += cross(p[j], p[(j+1)%n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i,n) {\n\t\tPoint A = ps[i], B = ps[(i+1)%n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tld angle = vec[j+1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i,1024) REP(j,1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld,int,bool>>> tup(N);\n\tREP(i,s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i,N) sort(ALL(tup[i]));\n\tREP(i,N) {\n\t\tREP(j,tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i,N) REP(j,i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back((Edge){from, to});\n\t\t\tg[to].push_back((Edge){to, from});\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct Jewel {\n    vector<Circle> c;\n    double ml, mr;\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    while (cin >> n, n) {\n        vector<Jewel> v;\n        REP(i, n) {\n            double x, y, r, m; cin >> x >> y >> r >> m;\n            v.pb({{{{x, y}, r}, {{x, y}, m+r}}, r, m+r});\n        }\n        vector<Line> lines;\n        REP(i, n) FOR(j, i+1, n) {\n            REP(a, 2) REP(b, 2) {\n                vector<Line> kh = tangent_cc(v[i].c[a], v[j].c[b]);\n                EACH(l, kh) lines.pb(l);\n            }\n        }\n        int ans = 0;\n        EACH(l, lines) {\n            int a = 0;\n            REP(i, n) {\n                double len = dist_lp(l, v[i].c[0].p);\n                if (v[i].ml-eps <= len && len <= v[i].mr+eps) {\n                    ++a;\n                }\n            }\n            ans = max(ans, a);\n        }\n        if (n == 1) ans = 1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define PI 4.0*atan(1.0)\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint N,bug=0;\ndouble r[100],m[50];\nP p[100];\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tdouble x,y;\n\t\trep(i,N){\n\t\t\tcin>>x>>y>>r[i]>>m[i];\n\t\t\tp[i]=p[N+i]=P(x,y);\n\t\t\tr[N+i]=r[i]+m[i];\n\t\t}\n\t\tint ans=0;\n\t\trep(i,N*2)for(int j=i+1;j<N*2;j++){\n\t\t\tif(j==i+N)continue;\n\t\t\tP p1=p[i],p2=p[j],p3=p2-p1;\n\t\t\tdouble r1=r[i],r2=r[j],d=abs(p3);\n\t\t\tint flag=r1+r2<d+1e-5;\n\t\t\tdouble t1=asin((r2-r1)/d)+PI/2.0,t2=(r1+r2<d?PI/2.0-asin((r1+r2)/d):0.0);//cout<<t1<<\" \"<<t2<<\" \"<<(r1+r2)/d<<endl;\n\t\t\tP P1=p1+p3/abs(p3)*r1*P(cos(t1),sin(t1)),P2=p2+p3/abs(p3)*r2*P(cos(t1),sin(t1));\n\t\t\tP P3=p1+p3/abs(p3)*r1/P(cos(t1),sin(t1)),P4=p2+p3/abs(p3)*r2/P(cos(t1),sin(t1));\n\t\t\tP P5=p1+p3/abs(p3)*r1*P(cos(t2),sin(t2)),P6=p2-p3/abs(p3)*r2*P(cos(t2),sin(t2));\n\t\t\tP P7=p1+p3/abs(p3)*r1/P(cos(t2),sin(t2)),P8=p2-p3/abs(p3)*r2/P(cos(t2),sin(t2));\n\t\t\tL l[]={L(P1,P2),L(P3,P4),L(P5,P6),L(P7,P8)};\n\t\t\trep(h,4){\n\t\t\t\tif(!flag&&(h==2||h==3))continue;\n\t\t\t\tint res=0;if(bug)cout<<i<<\" \"<<j<<\" \"<<h<<\" \";\n\t\t\t\t\t\trep(k,N){if(r[k]-EPS<distanceLP(l[h],p[k])&&distanceLP(l[h],p[k])<r[k]+m[k]+EPS){res++;if(bug)cout<<\"o\";}if(bug)cout<<m[k]<<\":\"<<distanceLP(l[h],p[k])-r[k]<<\" \";if(abs(r[k]-distanceLP(l[h],p[k]))>EPS&&abs(r[k]-distanceLP(l[h],p[k]))<EPS/*||i==19&&j==52&&h==2*/){cout<<fixed<<setprecision(10)<<i<<\" \"<<j<<\" \"<<h<<\" \"<<k<<\":\"<<distanceLP(l[h],p[k])<<\" \"<<r[k]<<\" \"<<r[k]+m[k]<<endl;}}if(bug)cout<<endl;\n\t\t\t\tans=max(ans,res);\n\t\t\t\t//if(res==10)cout<<i<<\" \"<<j<<\" \"<<h<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<(ans>0?ans:1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n// üªÌWresÅüªlÆdÈéüªð}[WµCresðXV·é\nvoid mergeLine(vector<L> &res, L l){\n\tint n = res.size();\n\tvector<L>::iterator it = res.begin();\n\twhile(it!=res.end()){\n\t\tif(ssOverlap((*it), l)){\n\t\t\tP dir(l.q-l.p);\n\t\t\tdouble m = 0.0, M = 1.0;\n\t\t\tm = min(m, real((it->p-l.p)/dir));\n\t\t\tM = max(M, real((it->p-l.p)/dir));\n\t\t\tm = min(m, real((it->q-l.p)/dir));\n\t\t\tM = max(M, real((it->q-l.p)/dir));\n\t\t\tl = L(l.p+m*dir,l.p+M*dir);\n\t\t\tit = res.erase(it);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n\tres.push_back(l);\n}\n\n// ¤ÊÚüðÔ·\nvector<L> getCommonTangent(C c1, C c2){\n\tvector<L> ans;\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return ans;\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tans.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tans.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n\treturn ans;\n}\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tvector<L> l[4];\n\t\t\t\tl[0] = getCommonTangent(C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tl[1] = getCommonTangent(C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tl[2] = getCommonTangent(C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tl[3] = getCommonTangent(C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tFOR(k, 4){\n\t\t\t\t\tFOR(s,SIZE(l[k])){\n\t\t\t\t\t\tall.push_back(l[k][s]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t\tif(i==18){\n\t\t\t\t\t//cout<<\"dist \"<<d<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<\"a[\"<<i<<\"]\"<<count;\n\t\t\t//cout<<\": (\"<<all[i].p.real()<<\",\"<<all[i].p.imag()<<\"), \";\n\t\t\t//cout<<\"(\"<<all[i].q.real()<<\",\"<<all[i].q.imag()<<\")\"<<endl;\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<cstdio>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\nP unit(P p){return p / abs(p);}  \npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\ndouble dot(P x,P y){return real(conj(x)*y);}\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nP rotate(P v,double s){\n  return P(real(v)*cos(s)+imag(v)*sin(s),imag(v)*cos(s)-real(v)*sin(s));\n}\n\n//for triangle\n\n//return seta A\ndouble arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool orth(L a,L b){return abs(dot(a.fs-a.sc,b.fs-b.sc))<EPS;}\nbool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ndouble line_dis(L a,P x){return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);}\n\nP line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\ndouble seg_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d * abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n//for circle\nbool in_cir(C c,P x){return (abs(x-c.fs) +EPS < c.sc);}\nbool on_cir(C c,P x){return EQ(abs(x-c.fs),c.sc);}\n\nvector<L> adj_line(C c,P p){\n  vector<L> res;\n  if(in_cir(c,p))return res;\n  if(on_cir(c,p)){\n    pair<P,P> n = norm(c.fs-p);\n    res.pb(L(n.fs+p,p));\n    return res;\n  }\n  double x,y,z;\n  x = c.sc;\n  z = abs(c.fs-p);\n  y = sqrt(z*z-x*x);\n  double s = arg(y,x,z);\n  P v = unit(p-c.fs)*c.sc;\n\n  res.pb(L(rotate(v,s)+c.fs,p));\n  res.pb(L(rotate(v,-s)+c.fs,p));\n  return res;\n}\n\nvector<L> common_adj_line(C a,C b){\n  vector<L> res;\n  if(a.sc+EPS<b.sc)return common_adj_line(b,a);\n  if(EQ(real(a.fs),real(b.fs)) && EQ(imag(a.fs),imag(b.fs)) && EQ(a.sc,b.sc))return res;\n\n  P pos = (b.fs-a.fs)*a.sc/(a.sc+b.sc);\n  if(!in_cir(a,pos))res = adj_line(a,pos);\n\n  if(EQ(a.sc,b.sc)){\n    pair<P,P> n = norm(unit(b.fs-a.fs)*a.sc);\n    res.pb(L(a.fs+n.fs,b.fs+n.fs));\n    res.pb(L(a.fs+n.sc,b.fs+n.sc)); \n  }else{\n    double c = abs(b.fs-a.fs);\n    pos = unit(b.fs-a.fs)*( (a.sc*c)/(a.sc-b.sc) );\n    if(!in_cir(a,pos)){\n      vector<L> tmp = adj_line(a,pos);\n      FOR(i,0,tmp.sz)res.pb(tmp[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  double x[50],y[50],r[50],m[50];\n  C c[50];\n\n  while(scanf(\"%d\",&n) && n){\n    FOR(i,0,n){\n      scanf(\"%lf %lf %lf %lf\",&x[i],&y[i],&r[i],&m[i]);\n      c[i] = C(P(x[i],y[i]),r[i]);\n    }\n\n    if(n==1){\n      printf(\"1\\n\");\n      continue;\n    }\n    int ans = 0;\n\n    FOR(i,0,n){\n      FOR(j,i+1,n){\n\tvector<L> x,l = common_adj_line(c[i],c[j]);\n\tc[i].sc += m[i];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[j].sc += m[j];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[i].sc -= m[i];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[j].sc -= m[j];\n\n\tFOR(k,0,l.sz){\n\t  int tmp = 0;\n\t  FOR(h,0,n){\n\t    double dis = line_dis(l[k],c[h].fs);\n\t    //cout << dis << endl;\n\t    if(r[h] < dis+EPS && dis < r[h]+m[h]+EPS)tmp++;\n\t  }\n\t  ans = max(ans,tmp);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  point Ex(r1*(c1.c+c2.c)/(r1+r2));\n  elem rEx = sqrt( pow(abs(c1.c-Ex),2.0)-(r1*r1) );\n  intersection_circles( circle(Ex,rEx), c1, pcross );\n  ret[0] = line(Ex,pcross.first);\n  ret[1] = line(Ex,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  //internal\n  elem rIn1 = sqrt( D*D + r2*r2 );\n  elem rIn2 = sqrt( D*D + r1*r1 );\n  intersection_circles( circle(c1.c, rIn1), c2, pcross );\n  intersection_circles( circle(c2.c, rIn2), c1, pcross2 );\n  ret[2] = line(pcross2.second,pcross.first);\n  ret[3] = line(pcross2.first,pcross.second);\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>in;\n\t\tvector<C>je;\n\t\tvi r(n),m(n);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y>>r[i]>>m[i];\n\t\t\t\n\t\t\tje.pb(C(P(x,y),r[i]));\n\t\t\tin.pb(C(P(x,y),r[i]));\n\t\t\tin.pb(C(P(x,y),m[i]+r[i]));\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint out=0;\n\t\trep(i,in.size())loop(j,i+1,in.size()){\n\t\t\tvector<L>l=tangentCC(in[i],in[j]);\n\t\t\trep(k,l.size()){\n\t\t\t\tint co=0;\n\t\t\t\trep(q,n){\n\t\t\t\t\tdouble dis=distanceLP(l[k],je[q].c);\n\t\t\t\t\tif(dis<EPS+m[q]+r[q]&&r[q]<EPS+dis)co++;\n\t\t\t\t}\n\t\t\t\tout=max(out,co);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\tif(dot(l.q-l.p,p-l.p)<-EPS) return abs(p-l.p);\n\tif(dot(l.p-l.q,p-l.q)<-EPS) return abs(p-l.q);\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n// üªÌWresÅüªlÆdÈéüªð}[WµCresðXV·é\nvoid mergeLine(vector<L> &res, L l){\n\tint n = res.size();\n\tvector<L>::iterator it = res.begin();\n\twhile(it!=res.end()){\n\t\tif(ssOverlap((*it), l)){\n\t\t\tP dir(l.q-l.p);\n\t\t\tdouble m = 0.0, M = 1.0;\n\t\t\tm = min(m, real((it->p-l.p)/dir));\n\t\t\tM = max(M, real((it->p-l.p)/dir));\n\t\t\tm = min(m, real((it->q-l.p)/dir));\n\t\t\tM = max(M, real((it->q-l.p)/dir));\n\t\t\tl = L(l.p+m*dir,l.p+M*dir);\n\t\t\tit = res.erase(it);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n\tres.push_back(l);\n}\n\n// ¤ÊÚüðÔ·\nvector<L> getCommonTangent(C c1, C c2){\n\tvector<L> ans;\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return ans;\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tans.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tans.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n\treturn ans;\n}\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFOR(i, n-1){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tvector<L> l[4];\n\t\t\t\tl[0] = getCommonTangent(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]));\n\t\t\t\tl[1] = getCommonTangent(C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]));\n\t\t\t\tl[2] = getCommonTangent(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tl[3] = getCommonTangent(C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tFOR(k, 4){\n\t\t\t\t\tFOR(s,SIZE(l[k])){\n\t\t\t\t\t\tall.push_back(l[k][s]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<=d+EPS && d-EPS<=r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>100000) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n/*\n -1 -> a > b\n 0 -> a near b\n 1 -> a < b\n */\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//return number of cross point\nint crossCC(const C &c, const C &d, R &l, R &r) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        assert(false);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l = bth-th;\n    r = bth+th;\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nint commonInternalTangent(const C &c, const C &d, L &l, L &r) {\n    R di = abs(c.p - d.p);\n    if (sgn(di, c.r + d.r) == 1) return 0;\n    R th = sacos((c.r+d.r) / di);\n    l.x = c.p + polar(c.r, arg(d.p-c.p)-th);\n    l.y = l.x + polar<R>(1, arg(d.p-c.p)-th + PI/2);\n    r.x = c.p + polar(c.r, arg(d.p-c.p)+th);\n    r.y = r.x + polar<R>(1, arg(d.p-c.p)+th - PI/2);\n    if (sgn(di, c.r+d.r) == 0) return 1;\n    return 2;\n}\n\nint commonExternalTangent(const C &c, const C &d, L &l, L &r) {\n    R di = abs(c.p - d.p);\n    if (sgn(di, abs(c.r - d.r)) == 1) return 0;\n    R th = sacos((c.r-d.r) / di);\n    l.x = c.p + polar(c.r, arg(d.p-c.p)-th);\n    l.y = l.x + polar<R>(1, arg(d.p-c.p)-th + PI/2);\n    r.x = c.p + polar(c.r, arg(d.p-c.p)+th);\n    r.y = r.x + polar<R>(1, arg(d.p-c.p)+th - PI/2);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nconst int MN = 55;\n\nP p[MN];\nR r[MN], m[MN];\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n    vector<C> c;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y >> r[i] >> m[i];\n        p[i] = P(x, y);\n        c.push_back(C(p[i], r[i]));\n        c.push_back(C(p[i], r[i]+m[i]));\n    }\n\n    int u = (int)c.size();\n\n    vector<L> vl;\n    for (int i = 0; i < u; i++) {\n        P pp = c[i].p + P(c[i].r, 0);\n        vl.push_back(L(pp, pp+P(0, 1)));\n    }\n    for (int i = 0; i < u; i++) {\n        for (int j = i+1; j < u; j++) {\n            L l, r;\n            if (commonExternalTangent(c[i], c[j], l, r)) {\n                vl.push_back(l); vl.push_back(r);\n            }\n            if (commonInternalTangent(c[i], c[j], l, r)) {\n                vl.push_back(l); vl.push_back(r);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (L l: vl) {\n        int sm = 0;\n        for (int i = 0; i < n; i++) {\n            R len = distLP(l, p[i]);\n            if (sgn(r[i], len) != -1 && sgn(len, r[i]+m[i]) != -1) sm++;\n        }\n        ma = max(ma, sm);\n    }\n    printf(\"%d\\n\", ma);\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.01){\n\t\t\t\tdouble a = (-1) * tan(M_PI/2 + j);\n\t\t\t\tdouble b = 1.0;\n\t\t\t\tdouble c = (x[i]-r[i]*cos(j)) * tan(M_PI/2 + j) - y[i] - r[i] * sin(j);\n\t\t\t\tdouble ab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(d >= r[k] && d <= r[k]+m[k]){\n\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\nline tangent(const circle &c, const double &th) {\n    point h = c.o+polar(c.r,th);\n    point p = polar(c.r,th)*point(0,1);\n    return line(h-p,h+p);\n}\n\nvector<line> common_tangent(const circle &c, const circle &d) {\n    vector<line> res;\n    long double dist = abs(d.o - c.o), th = arg(d.o - c.o);\n    if (abs(c.r - d.r) < dist) { // outer\n        long double dth = acosl((c.r - d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    if (abs(c.r + d.r) < dist) {\n        long double dth = acos((c.r + d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    return res;\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    vector<long double> m(n);\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r >> m[i];\n        cs.push_back(circle(point(x,y),r));\n    }\n\n    vector<line> ls;\n    vector<pii> idx;\n    rep(i,0,n) rep(j,i+1,n){\n        auto tmp=common_tangent(cs[i],cs[j]);\n        ls.insert(ls.end(),tmp.begin(),tmp.end());\n        idx.push_back(make_pair(i,j));\n    }\n\n    int ans=1;\n    rep(i,0,ls.size()){\n        auto &l=ls[i];\n        int cnt=0;\n        rep(j,0,n){\n            auto &c=cs[j];\n            long double d=distanceLP(l,c.o)-c.r;\n            if(j==idx[i].first or j==idx[i].second or (0<=d and d<=m[j])) ++cnt;\n        }\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\ntypedef double D;\n\nconst D pi=3.14159265358979;\n\n\nstruct P{\n\tD x,y,n,n2;\n\tP(){}\n\tP(D ix,D iy){\n\t\tx=ix; y=iy;\n\t\tn2=x*x+y*y;\n\t\tn=sqrt(n2);\n\t}\n\tP to(P a){\n\t\treturn (a-(*this));\n\t}\n\tP operator+(P a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator-(P a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP scalar(D a){\n\t\treturn P(x*a,y*a);\n\t}\n\tD dot(P a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tD cross(P a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tD theta(P a){\n\t\tD s = (cross(a)/(n*a.n))>0.0?1:-1;\n\t\treturn acos(max(-1.0,min(1.0,dot(a)/(n*a.n))))*s;\n\t}\n\tstatic P polar(D r,D t){\n\t\treturn P(r*cos(t),r*sin(t));\n\t}\n\tP turn(D t){\n\t\treturn P(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tP tolen(D a){\n\t\treturn this->scalar(a/n);\n\t}\n\tbool  operator<(P a) const{\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(P a)const{ return (a<(*this)); }\t\n};\n\nstruct L{\n\tP p,q,v;\n\tL(){}\n\tL(P ip,P iq){\n\t\tp=ip; q=iq;\n\t\tv=p.to(q);\n\t}\n\tbool iscross(L a){\n\t\tD da,db;\n\t\tda=v.cross(p.to(a.p));\n\t\tdb=v.cross(p.to(a.q));\n\t\tif(da*db>=0)return false;\n\t\tda=a.v.cross(a.p.to(p));\n\t\tdb=a.v.cross(a.p.to(q));\n\t\treturn (da*db<0);\n\t}\n\n\tD dist(P a){\n\t\tif(p.to(a).dot(p.to(q))<0)return p.to(a).n;\n\t\tif(q.to(a).dot(q.to(p))<0)return q.to(a).n;\n\t\treturn abs(v.cross(p.to(a))/v.n);\n\t}\n\tD dist(L a){\n\t\tif(iscross(a))return 0;\n\t\treturn min(min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tP crosspos(L a){\n\t\treturn (p+v.scalar(a.v.cross(a.p-p)/a.v.cross(v)));\n\t}\n\tL bisection(){//垂直二等分線\n\t\t//半時計回りに90度回った向きの。\n\t\tP fr=(p+q).scalar(0.5);\n\t\tP to=fr+P(-v.y,v.x);\n\t\treturn L(fr,to);\n\t}\n};\n\n\nD lowofcos(D a,D b,D c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct C{\n\tP p;\n\tD r;\n\tL koten(C a){\n\t\tP cv=p.to(a.p);\n\t\tD br=atan2(cv.y,cv.x);\n\t\tD dr=acos(lowofcos( r, cv.n, a.r));\n\t\tP p1= p+P::polar(r,br+dr);\n\t\tP p2= p+P::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn L(p1,p2);\n\t}\n\tC(){}\n\tC(P ip,D ir){\n\t\tp=ip; r=ir;\n\t}\n\tvector<L> tangs(C a){ //接線たち\n\t\t//validate AOJ 2201\n\t\tC b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<L> res;\n\t\tif((a.p-b.p).n-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).n-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).n<1e-6)return res; //全く同じ円。\n\t\t\tP rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(L(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tP cv=b.p-a.p;\n\t\t\tD th=acos((a.r-b.r)/cv.n);\n\t\t\tP p1 = cv.turn(th);\n\t\t\tres.push_back(L(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tP p2 = cv.turn(-th);\n\t\t\tres.push_back(L(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).n-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).n-(a.r+b.r)<1e-6){\n\t\t\tP rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(L(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tP cv=b.p-a.p;\n\t\t\tD th=acos((a.r+b.r)/cv.n);\n\t\t\tP p1 = cv.turn(th);\n\t\t\tres.push_back(L(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tP p2 = cv.turn(-th);\n\t\t\tres.push_back(L(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<C> cs;\n\t\tvector<double> ms;\n\t\trep(i,n){\n\t\t\tdouble x,y,r,m;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&r,&m);\n\t\t\tcs.push_back(C(P(x,y),r));\n\t\t\tms.push_back(m);\n\t\t}\n\t\trep(i,n){\n\t\t\tC nc = cs[i];\n\t\t\tcs.push_back(C(nc.p,nc.r+ms[i]));\n\t\t}\n\t\tint ans = 1;\n\t\trep(i,n*2){\n\t\t\trep(j,i){\n\t\t\t\tvector<L> ts = cs[i].tangs(cs[j]);\n\t\t\t\t//printf(\"%d %d : %d\\n\",i,j,ts.size());\n\t\t\t\trep(k,ts.size()){\n\t\t\t\t\tL nl = ts[k];\n\t\t\t\t\tint ns=0;\n\t\t\t\t\trep(a,n){\n\t\t\t\t\t\tdouble td = nl.dist(cs[a].p);\n\t\t\t\t\t\tdouble r = cs[a].r;\n\t\t\t\t\t\t//printf(\"%d %d %d : %lf %lf %lf\\n\",i,j,a,r,td,r+ms[a]);\n\t\t\t\t\t\tif(r<td+1e-6 && td<r+ms[a]+1e-6)ns++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int maxn = 100 + 5;\nconst double PI = acos(-1);\n\nstruct Point\n{\n    double x, y;\n    Point(){}\n    Point(double x_, double y_):x(x_),y(y_){}\n};\ntypedef Point Vector;\nint n;\n\nstruct Circle:public Point\n{\n    Point c;\n    double r, m;\n    Circle(){}\n    Circle(Point c, double r, double m):c(c.x, c.y),r(r),m(m){}\n    Point getPoint(double a) {\n        return Point(c.x + cos(a) * r, c.y + sin(a) * r);\n    }\n};\nvector<Circle> p;\n\nVector operator + (Vector a, Vector b)  { return Vector(a.x + b.x, a.y + b.y); }\nVector operator - (Point a, Point b)    { return Point(a.x - b.x, a.y - b.y); }\nVector operator * (Vector a, double p)  { return Vector(a.x * p, a.y * p); }\nVector operator / (Vector a, double p)  { return Vector(a.x / p, a.y / p); }\n\nbool operator < (const Point& a, const Point& b)\n{\n    return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nconst double eps = 1e-12;\nint dcmp(double x)\n{\n    if(fabs(x) < eps)    return 0;\n    else                return x < 0 ? -1 : 1;\n}\n\nbool operator == (const Point& a, const Point& b)\n{\n    return dcmp(a.x - b.x) == 0 && dcmp(a.y - b.y) == 0;\n}\n\ndouble dot(Vector a, Vector b)      { return a.x * b.x + a.y * b.y; }\ndouble length(Vector a)             { return sqrt(dot(a, a)); }\ndouble angle(Vector a, Vector b)    { return acos(dot(a, b) / length(a) / length(b)); }\ndouble angle(Vector v)              { return atan2(v.y, v.x); }\ndouble cross(Vector a, Vector b)    { return a.x * b.y - b.x * a.y; }\ndouble dist(Point p1,Point p2)      { return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)); }\n\ndouble distToLine(Point p, Point a, Point b) {\n\tVector v1 = b - a, v2 = p - a;\n\treturn fabs(cross(v1, v2)) / length(v1);\n}\n\nint getTangents(Circle A, Circle B, vector<Point>& a, vector<Point>& b)\n{\n\tint cnt = 0;\n\tif(A.r < B.r) { swap(A, B); swap(a, b); }\n\tint d2 = (A.c.x - B.c.x)*(A.c.x - B.c.x) + (A.c.y - B.c.y)*(A.c.y - B.c.y);\n\tint rdiff = A.r - B.r;\n\tint rsum = A.r + B.r;\n\tif(d2 < rdiff * rdiff)\treturn 0;\n\n\tdouble base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);\n\tif(d2 == 0 && A.r == B.r)\treturn -1;\n\tif(d2 == rdiff * rdiff) {\n\t\ta.push_back(A.getPoint(base));\n\t\tb.push_back(B.getPoint(base));\n\t\treturn 1;\n\t}\n\n\t//有共切?\n\tdouble ang = acos((A.r - B.r) / sqrt(d2));\n\ta.push_back(A.getPoint(base + ang));\tb.push_back(B.getPoint(base + ang));\n\ta.push_back(A.getPoint(base - ang));\tb.push_back(B.getPoint(base - ang));\n\n\tif(d2 == rsum * rsum) {\n\t\ta.push_back(A.getPoint(base));\n\t\tb.push_back(B.getPoint(PI + base));\n\t} else if(d2 > rsum * rsum) {\n\t\tdouble ang = acos((A.r + B.r) / sqrt(d2));\n\t\ta.push_back(A.getPoint(base + ang));\tb.push_back(B.getPoint(PI + base + ang));\n\t\ta.push_back(A.getPoint(base - ang));\tb.push_back(B.getPoint(PI + base - ang));\n\t}\n\treturn a.size();\n}\n\nint cmp(double a, double b)\n{\n\tconst double diff = a - b;\n\tif (fabs(diff) < eps)\n\t\treturn 0;\n\telse if (diff < 0)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\nint calculate(const Point& a, const Point& b)\n{\n\tint res = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tdouble d = distToLine(p[i].c, a, b);\n\t\tif(cmp(d, p[i].r) >= 0 && cmp(d, p[i].r + p[i].m) <= 0)\tres++;\n\t\tif(cmp(d, p[i].r) < 0)\treturn -1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n    while(~scanf(\"%d\", &n)) {\n\t\tif(n == 0)\tbreak;\n\t\tp.clear();\n\t\tdouble x, y, r, m;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x, &y, &r, &m);\n\t\t\tp.push_back(Circle(Point(x, y), r, m));\n\t\t}\n\n\t\tvector<Point> a, b;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tCircle A1 = p[i], A2 = p[i];\n\t\t\t\tCircle B1 = p[j], B2 = p[j];\n\t\t\t\tB2.r += B2.m;\tA2.r += A2.m;\n\n\t\t\t\tgetTangents(A1, B1, a, b);\n\t\t\t\tgetTangents(A1, B2, a, b);\n\t\t\t\tgetTangents(A2, B1, a, b);\n\t\t\t\tgetTangents(A2, B2, a, b);\n\t\t\t}\n\t\t}\n\n\t\tint num = a.size(), ans = 1;\n\t\tfor(int i = 0; i < num; i++) {\n\t\t\tans = max(ans, calculate(a[i], b[i]));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cmath>\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\ndouble dot(P x, P y){return real(conj(x)*y);}\ndouble cross(P x, P y){return imag(conj(x)*y);}\n\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c));}\n\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\ndouble line_dis(L a,P x){return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);}\n\n//for circle\nbool in_cir(C c,P x){return (abs(x-c.fs) + EPS < c.sc);}\nbool on_cir(C c,P x){return EQ(abs(x-c.fs),c.sc);}\n\nvector<L> adj_line(C c,P p){\n  vector<L> res;\n  if(in_cir(c,p))return res;\n  if(on_cir(c,p)){\n    pair<P,P> n = norm(c.fs-p);\n    res.pb(L(n.fs+p,p));\n    return res;\n  }\n  double x,y,z;\n  x = c.sc;\n  z = abs(c.fs-p);\n  y = sqrt(z*z-x*x);\n  double s = arg(y,x,z);\n  P v = unit(p-c.fs)*c.sc;\n\n  res.pb(L(rotate(v,s)+c.fs,p));\n  res.pb(L(rotate(v,-s)+c.fs,p));\n  return res;\n}\n\nvector<L> common_adj_line(C a,C b){\n  vector<L> res;\n  if(a.sc+EPS<b.sc)return common_adj_line(b,a);\n  if(EQ(real(a.fs),real(b.fs)) && EQ(imag(a.fs),imag(b.fs)) && EQ(a.sc,b.sc))return res;\n\n  P pos = (b.fs-a.fs)*a.sc/(a.sc+b.sc)+a.fs;\n  if(!in_cir(a,pos))res = adj_line(a,pos);\n\n  if(EQ(a.sc,b.sc)){\n    pair<P,P> n = norm(unit(b.fs-a.fs)*a.sc);\n    res.pb(L(a.fs+n.fs,b.fs+n.fs));\n    res.pb(L(a.fs+n.sc,b.fs+n.sc));\n  }else{\n    double c = abs(b.fs-a.fs);\n    pos = unit(b.fs-a.fs)*( (a.sc*c)/(a.sc-b.sc) )+a.fs;\n    if(!in_cir(a,pos)){\n      vector<L> tmp = adj_line(a,pos);\n      FOR(i,0,tmp.size())res.pb(tmp[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  C c1[100],c2[100];\n  double x[100],y[100],r[100],m[100];\n  vector<L> v,hoge;\n \n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      c1[i] = C(P(x[i],y[i]),r[i]);\n      c2[i] = C(P(x[i],y[i]),r[i]+m[i]);\n    }\n\n    int ans = 1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tv = common_adj_line(c1[i],c1[j]);\n\thoge = common_adj_line(c1[i],c2[j]);\n\tfor(int k=0;k<(int)hoge.size();k++)v.pb(hoge[k]);\n\thoge = common_adj_line(c2[i],c1[j]);\n\tfor(int k=0;k<(int)hoge.size();k++)v.pb(hoge[k]);\n\thoge = common_adj_line(c2[i],c2[j]);\n\tfor(int k=0;k<(int)hoge.size();k++)v.pb(hoge[k]);\n\n\tfor(int k=0;k<(int)v.size();k++){\n\t  int num = 0;\n\t  for(int l=0;l<n;l++){\n\t    double dis = line_dis(v[k],c1[l].fs);\n\n\t    if(r[l] < dis + EPS && dis < r[l]+m[l] +EPS)num++;\n\t  }\n\t  ans = max(ans,num);\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\t\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 2 円の共通接線\n//\n// verified:\n//   AOJ 2201 Immortal Jewels\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2201\n//\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\n\n\n///////////////////////\n// 接線\n///////////////////////\n\n// 点と円\nvector<Point> tanline(const Point &p, const Circle &c) {\n    vector<Point> res;\n    DD d = norm(p - c);\n    DD l = d - c.r * c.r;\n    if (l < -EPS) return res;\n    if (l <= 0.0) l = 0.0;\n    Point cq = (p - c) * (c.r * c.r / d);\n    Point qs = rot90((p - c) * (c.r * sqrt(l) / d));\n    Point s1 = c + cq + qs, s2 = c + cq - qs;\n    res.push_back(s1);\n    res.push_back(s2);\n    return res;\n}\n\n// 円と円の共通接線\nvector<Line> comtanline(Circle a, Circle b) {\n    vector<Line> res;\n    if (abs(a - b) > abs(a.r - b.r) + EPS) {\n        if (abs(a.r - b.r) < EPS) {\n            Point dir = b - a;\n            dir = rot90(dir * (a.r / abs(dir)));\n            res.push_back(Line(a + dir, b + dir));\n            res.push_back(Line(a - dir, b - dir));\n        }\n        else {\n            Point p = a * -b.r + b * a.r;\n            p = p * (1.0 / (a.r - b.r));\n            vector<Point> bs = tanline(p, a);\n            vector<Point> as = tanline(p, b);\n            for (int i = 0; i < min(as.size(), bs.size()); ++i) {\n                res.push_back(Line(bs[i], as[i]));\n            }\n        }\n    }\n    if (abs(a - b) > a.r + b.r + EPS) {\n        Point p = a * b.r + b * a.r;\n        p = p * (1.0 / (a.r + b.r));\n        vector<Point> bs = tanline(p, a);\n        vector<Point> as = tanline(p, b);\n        for (int i = 0; i < min(as.size(), bs.size()); ++i) {\n            res.push_back(Line(bs[i], as[i]));\n        }\n    }\n    return res;\n}\n\n\n\n\n///////////////////////\n// ソルバー\n///////////////////////\n\n// 距離\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\n\n// カウント\nint count(Line l, vector<Circle> vec, vector<DD> d) {\n    int res = 0;\n    //cout << endl;\n    for (int i = 0; i < vec.size(); ++i) {\n        DD dis = distancePL(vec[i], l);\n        if (dis >= vec[i].r - EPS && dis <= vec[i].r + d[i] + EPS) ++res;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while (cin >> N) {\n        if (N == 0) break;\n        \n        vector<Circle> vec(N);\n        vector<DD> d(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> vec[i].x >> vec[i].y >> vec[i].r >> d[i];\n        }\n        if (N == 1) cout << 1 << endl;\n        else {\n            int res = 0;\n            for (int i = 0; i < N; ++i) {\n                for (int j = i+1; j < N; ++j) {\n                    vector<Circle> I(2, vec[i]); I[1].r += d[i];\n                    vector<Circle> J(2, vec[j]); J[1].r += d[j];\n                    for (int p = 0; p < 2; ++p) {\n                        for (int q = 0; q < 2; ++q) {\n                            vector<Line> L = comtanline(I[p], J[q]);\n                            for (int k = 0; k < L.size(); ++k) {\n                                int tmp = count(L[k], vec, d);\n                                res = max(res, tmp);\n                            }\n                        }\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\n#define ISEQ(c) (c).begin(), (c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nnamespace Ps{\n\ttypedef long double D;\n\ttypedef complex<D> P;\n\tconst D EPS = 3*1e-2;\n\tconst D INF = 1e20;\n\n#define X real()\n#define Y imag()\n\n\ttemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\ttemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\n\ttemplate<typename T> double norm(T a){ return a*a;}\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\tint ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t}\n\n\t//浮動小数点modで非負の値のみかえす．\n\tdouble pfmod(double v,double MOD){\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t}\n\n\t//[0,PI)\n\tdouble AbsArg(double a){\n\t  \tdouble ret=pfmod(max(a,-a),2*M_PI);\n\t  \treturn min(ret,2*M_PI-ret);\n\t}\n\t\n}\nusing namespace Ps;\n\n\nnamespace Ls{\n\tstruct L : public vector<P> {\n\t  L(const P &a, const P &b) {\n\t    push_back(a); push_back(b);\n\t  }\n\t};\n\n\t//直線へ射影した時の点\n\tP projection(const L &l, const P &p) {\n\t  D t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\t  return l[0] + t*(l[0]-l[1]);\n\t}\n\n\tD distanceLP(const L &l, const P &p) {\n\t  return abs(p - projection(l, p));\n\t}\n\n}\nusing namespace Ls;\n\n\n\nnamespace std{\n\tbool operator < (const P& a,const P& b){\n    \t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  \t}\n  \tbool operator == (const P& a,const P& b){\n    \t\treturn eq(a,b);\n   \t}\n};\n\nnamespace Cs{\n\tstruct C {\n \t\t P o; D r;\n \t\t C(const P &o,D r) : o(o), r(r) { }\n\t};\n\n\t// 包含関係\n\tenum RELATION{INCOMPARABLE=0,SAME=1,CONTAIN=2,OVER=4};\n\tpair<RELATION,int> cRel(const C& c1,const C& c2){\n\t\tD d=abs(c1.o-c2.o);\n\t\tif(eq(c1.o,c2.o) && eq(c1.r,c2.r))return make_pair(SAME,1<<28);// c1 == c2\n\t\tif(sig(d,c1.r-c2.r)<0)return make_pair(OVER,0); // c2 ⊆ c1\n\t\tif(sig(d,c2.r-c1.r)<0)return make_pair(CONTAIN,0); // c1 ⊆ c2\n\t\tif(sig(d,c1.r-c2.r)==0)return make_pair(OVER,1);// c2 ⊆ c1,1点で接する\n\t\tif(sig(d,c2.r-c1.r)==0)return make_pair(CONTAIN,1);// c1 ⊆ c2,1点で接する\n\t\tif(sig(d,c1.r+c2.r)==0)return make_pair(INCOMPARABLE,1);// 1点で接する\n\t\tif(sig(d,c1.r+c2.r)<0)return make_pair(INCOMPARABLE,2);//  2点で接する\n\t\treturn make_pair(INCOMPARABLE,0);// 交わらない\n\t}\n\n\t// 点p を通る 円c の接点\n\tvector<P> ContactCP(const C& c,const P& p){\n\t\tvector<P> res;\n\t\tD d=abs(c.o-p);\n\t\tif(sig(c.r,d)==0){\n\t\t\tres.push_back(p);return res;\n\t\t}\n\t\tif(sig(c.r,d)>0)return res;\n\n\t\tD theta=acos(c.r/d),phi=arg(p-c.o);\n\t\tres.push_back(c.o + polar(c.r,phi+ theta));res.push_back(c.o + polar(c.r,phi- theta));\t\t\n\t\treturn res;\n\t}\n\n\t//共通接線  仮定：2円は異なる．\n\tvector<L> ContactCC(const C& c1,const C& c2){\n\t\tpair<RELATION,int> rel=cRel(c1, c2);\n\t\tvector<L> res;\n\t\tif(rel.first==SAME)return res;\n\t\tP dir=c2.o - c1.o;\n\t\t//external\n\t\tif(rel.first==INCOMPARABLE || rel.second>0){\n\t\t\tD th=arg(dir),a=acos((c2.r-c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a)));\n\t\t}\n\t\t//internal\n\t\tif(rel.first==INCOMPARABLE && rel.second<2){\n\t\t\tD th=arg(dir),a=acos((c2.r+c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a + M_PI)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a + M_PI)));\n\t\t}\n\t\treturn res;\n\t}\n\n}\nusing namespace Cs;\n\nnamespace std{\n  \tbool operator == (const C& a,const C& b){\n    \treturn cRel(a,b).first==SAME;\n   \t}\n};\n\n\nint main() {\n\tifstream cin(\"in\");\n\tofstream cout( \"out\" );\n\twhile(true){\n\t\tint N;cin >> N;if(N==0)break;\n\t\tvector<C> cs1,cs2,cs;\n\t\tREP(i,N){\n\t\t\tD x,y,r,m;cin >> x >> y >>r >> m;\n\t\t\tcs1.push_back(C(P(x,y),r));cs2.push_back(C(P(x,y),r+m));\n\t\t\tcs.push_back(C(P(x,y),r));cs.push_back(C(P(x,y),r+m));\n\t\t}\n\n\t\tint Mv=0;if(N==1)Mv=max(Mv,1);\n\t\tREP(i,2*N)REP(j,2*N){\n\t\t\tvector<L> ls=ContactCC(cs[i],cs[j]);\n\t\t\tREP(k,ls.size()){\n\t\t\t\tint c=0;\n\t\t\t\tREP(s,N){\n\t\t\t\t\tD d=distanceLP(ls[k],cs2[s].o);\n\t\t//\t\tcout <<\"d: \"<<i<<\" \"<<j <<\" \"<<s<<\":\"<<distanceLP(ls[k],cs1[s].o)<<endl;\n\t\t\t\t\tif(sig(cs1[s].r,d)<=0 && sig(d,cs2[s].r)<=0)c++;\n\n\t\t\t\t}\n\t\t\t\tMv=max(Mv,c);\n\t\t\t}\n\t\t}\n\n\t\tcout << Mv <<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (a.p - b.p)/d;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*v*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*v*P(0, 1)));\n\t} else {\n\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tif(sig(abs(a.r + b.r), abs(a.p - b.p)) >= 0) return res;\n\t\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\tP q = a.p + v*t;\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=i+1; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\nbool equal(double a, double b) { return fabs(a - b) < EPS; }\n\n// テァツつケテ」ツつッテ」ツδゥテ」ツつケ\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// テ・ツ環?ァツョツ? テヲツクツ崚ァツョツ? テ」ツつケテ」ツつォテ」ツδゥテ」ツδシテ・ツ??\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// テヲツッツ氾ィツシツεヲツシツ氾ァツョツ療・ツュツ?\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\n// テ・ツ篠淌ァツつケテ」ツ?凝」ツつ嘉」ツ?ョティツキツ敕ゥツ崢「(テァツオツカテ・ツッツセテ・ツ?、)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2テァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble abs(P a, P b) {\n\treturn abs(a - b);\n}\n// テ」ツδ偲」ツδォテ」ツδ?\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n// テ・ツ?湘ィツァツ?\ndouble arg(const P& z) {\n\treturn atan2(z.y, z.x);\n}\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォ a テ」ツ?ョテ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツつ津ヲツアツづ」ツつ?」ツつ?\nP unit(P a) {\n\treturn a / abs(a);\n}\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォ a テ」ツ?ョテヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0, +1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n// テ・ツ??ァツゥツ?(dot product) : aテ」ツδサb = |a||b|cosテ篠?\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// テ・ツ、ツ姪ァツゥツ?(cross product) : aテδ傭 = |a||b|sinテ篠?\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?(Counter Clock Wise)\n// CW : テヲツ卍づィツィツ暗・ツ崢榲」ツつ?(Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3テァツつケテ」ツ?古」ツ?ゥテ」ツ?。テ」ツつ嘉・ツ崢榲」ツつ甘」ツ?ァテ」ツ?づ」ツつ凝」ツ?凝ィツソツ氾」ツ?? 3テァツつケテ」ツ??テァツ崢エテァツキツ堙」ツ?ォテ、ツケツ療」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?ィテ」ツ?催」ツ?ッ ON テ」ツつ津ィツソツ氾」ツ??\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n\tif( cross(b,c) < -EPS ) return CW;  // CW : テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// テ・ツ篠淌ァツつケテ」ツつ津ィツサツクテ」ツ?ォテァツつケ p テ」ツつ津ィツァツ津・ツコツヲ a (テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)テ」ツ??」ツ?妥・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?淌ァツつケテ」ツつ津ィツソツ氾」ツ??\nP rot(P p, double a){\n\treturn P(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n// テァツつケ a テ」ツつ津ィツサツクテ」ツ?ォテァツつケ b テ」ツつ津ィツァツ津・ツコツヲ angle (テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)テ」ツ??」ツ?妥・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?淌ァツつケテ」ツつ津ィツソツ氾」ツ??\nP rot(P a, P b, double angle){\n\treturn rot(b - a, angle) + a;\n}\n\n// テァツ崢エテァツキツ堙」ツつッテ」ツδゥテ」ツつケ\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\n// テァツ崢エテァツキツ?a テ」ツ?ィテァツ崢エテァツキツ?b テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectLL(const Line& a, const Line& b) {\n\treturn abs(cross(a[1] - a[0], b[1] - b[0])) > EPS || abs(cross(a[1] - a[0], b[0] - a[0])) < EPS;\n}\n// テァツ崢エテァツキツ?l テ」ツ?ィ テァツキツ堙・ツ按?s テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectLS(const Line& l, const Line& s) {\n\treturn cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n// テァツ崢エテァツキツ?l テ、ツクツ甘」ツ?ォテァツつケ p テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool intersectLP(const Line& l, const P& p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n// テァツキツ堙・ツ按?s テ」ツ?ィ テァツキツ堙・ツ按?t テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectSS(const Line& s, const Line& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// テァツキツ堙・ツ按?s テ、ツクツ甘」ツ?ォテァツつケ p テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\nP reflection(const Line& l, const P& p) {\n\treturn p + 2 * (projection(l, p) - p);\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLP(const Line& l, const P& p) {\n\treturn abs(p - projection(l, p));\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLL(const Line& l, const Line& m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLS(const Line& l, const Line& s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n// テァツキツ堙・ツ按?」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceSS(const Line& s, const Line& t) {\n\tif (intersectSS(s, t)) return 0;\n\tdouble a = min(distanceSP(s, t[0]), distanceSP(s, t[1]));\n\tdouble b = min(distanceSP(t, s[0]), distanceSP(t, s[1]));\n\treturn min(a, b);\n}\n// テ・ツ??」ツつッテ」ツδゥテ」ツつケ\nstruct Circle{\n\tP p;\n\tdouble r;\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n};\n\n// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?古、ツコツ、テ」ツつ湘」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nint is_intersect(const Circle &a, const Circle &b) {\n\tdouble x = a.p.x - b.p.x;\n\tdouble y = a.p.y - b.p.y;\n\tdouble s = a.r + b.r;\n\tdouble d = x * x + y * y;\n\ts *= s;\n\tif( equal(d, s) ) return 1;\n\tif( d > s ) return 0;\n\tdouble r = abs(a.r - b.r);\n\tr *= r;\n\tif( equal(d, r) ) return -1;\n\tif(d > r) return 2;\n\treturn -2;\n}\n\n// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?ョテ・ツ?アテゥツ?堙ヲツ篠・テァツキツ堙」ツつ津ヲツアツづ」ツつ?」ツつ?(テァツオツ静ヲツ楪愿」ツ?ッ res テ」ツ?ォティツソツ氾」ツ??\nvoid common_tangent(Circle a, Circle b, vector<Line> &res) {\n\tif(a.r > b.r) swap(a, b);\n\tdouble d = abs(b.p - a.p);\n\tdouble th;\n\tP v, n;\n\tint t = is_intersect(a, b);\n\t\n\t// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?古ァツュツ嘉」ツ?療」ツ??」ツ?ィテ」ツ?催」ツ?ィテ・ツ個?・ツ青ォテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテ・ツ?アテゥツ?堙ヲツ篠・テァツキツ堙」ツ?ェテ」ツ??\n\tif( equal(a.p.x, b.p.x) && equal(a.p.y, b.p.y) && equal(a.r, b.r) ){\n\t\treturn ;\n\t}\n\tif( t == -2 ) return ;\n\t\n\tif(t == 0 || t == 1 || t == 2) {\n\t\tth = asin( (b.r - a.r) / d );\n\t\tv = rot(a.p, b.p, th) - a.p;\n\t\tn = P(-v.y, v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p + n * a.r, b.p + n * b.r) );\n\t\t\n\t\tv = rot(a.p, b.p, -th) - a.p;\n\t\tn = P(v.y, -v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p + n * a.r, b.p + n * b.r) );\n\t}\n\t\n\tif(t == 0) {\n\t\tth = asin( (b.r + a.r) / d );\n\t\tv = rot(a.p, b.p, th) - a.p;\n\t\tn = P(-v.y, v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p - n * a.r, b.p + n * b.r) );\n\t\t\n\t\tv = rot(a.p, b.p, -th) - a.p;\n\t\tn = P(v.y, -v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p - n * a.r, b.p + n * b.r));\n\t}\n\t\n\tif(t == 1) {\n\t\tn = b.p - a.p;\n\t\tn /= abs(n);\n\t\tv = P(-n.y, n.x);\n\t\tres.push_back( Line(a.p + n * a.r, a.p + n * a.r + v) );\n\t}\n\t\n\tif(t == -1) {\n\t\tn = a.p - b.p;\n\t\tn /= abs(n);\n\t\tv = P(-n.y, n.x);\n\t\tres.push_back( Line(a.p + n * a.r, a.p + n * a.r + v) );\n\t}\n}\n\n\nint main(){\n\tint N, x[51], y[51], r[51], m[51];\n\twhile( cin >> N , N ){\n\t\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\n\t\tif( N == 1 ){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<Line> res;\n\t\tfor(int i = 0 ; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tCircle c1(P(x[i], y[i]), r[i]);\n\t\t\t\tCircle c2(P(x[i], y[i]), r[i] + m[i]);\n\t\t\t\tCircle c3(P(x[j], y[j]), r[j]);\n\t\t\t\tCircle c4(P(x[j], y[j]), r[j] + m[j]);\n\t\t\t\tcommon_tangent(c1, c3, res);\n\t\t\t\tif( m[j] != 0 ) common_tangent(c1, c4, res);\n\t\t\t\tif( m[i] != 0 ) common_tangent(c2, c3, res);\n\t\t\t\tif( m[i] != 0 && m[j] != 0 ) common_tangent(c2, c4, res);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < res.size(); i++){\n\t\t\tLine &l = res[i];\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdouble d = distanceLP(res[i], P(x[j], y[j]));\n\t\t\t\tif( r[j] <= d + EPS && d - EPS <= r[j] + m[j] ){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool near(point a,point b){ eq(abs(b-a),0); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(0, 0), b(0, 0) {}\n\tLine(Point _a, Point _b) : a(_a), b(_b) {}\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tassert(d != 0.0);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tres.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> v = is_lc(c, s), res;\n\tfor (size_t k = 0; k < v.size(); k++) {\n\t\tif (ccw(s.a, v[k], s.b) == -2) {\n\t\t\tres.push_back(v[k]);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) return res;\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back((Line) { p, p + v1 });\n\tif (l < eps) return res;\n\tres.push_back((Line) { p, p + v2 });\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back((Line) { q1, q1 + v });\n\t\tres.push_back((Line) { q2, q2 + v });\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N), r(N), m(N);\n\t\tvector<Circle> cs;\n\t\tvector<Line> en;\n\t\tcs.reserve(100), en.reserve(10000);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\tcs.push_back((Circle) { Point(x[i], y[i]), r[i] });\n\t\t\tcs.push_back((Circle) { Point(x[i], y[i]), r[i] + m[i] });\n\t\t}\n\t\tif (N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < N * 2; i++) {\n\t\t\tfor (int j = i + 1; j < N * 2; j++) {\n\t\t\t\tauto tmp = tangent_cc(cs[i], cs[j]);\n\t\t\t\tfor (auto &l : tmp) {\n\t\t\t\t\ten.push_back(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (auto &l : en) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint dist = dist_lp(l, Point(x[i], y[i]));\n\t\t\t\tif (dist > r[i] - eps && dist < r[i] + m[i] + eps) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, sum);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L {                 /* üª */\n\tdouble angle; // deleteSameLineðgpµÈ¢Àèsv\n\tP p, q;\n\tL(P p, P q) : p(p), q(q), angle(arg(q-p)) {}\n\tbool operator < (const L &l) const { \n\t\treturn angle < l.angle;\n    }\n};\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\n// px\\[gðÀ·êÎ¬»}êéª¸s·éEEE\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tfor(int i=0; i<n; i++){\n\t\tif(imag(res[i].p) > imag(res[i].q)){\n\t\t\tP temp = res[i].p;\n\t\t\tres[i].p = res[i].q;\n\t\t\tres[i].q = temp;\n\t\t}\n\t}\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( abs(res[i].angle - (*it).angle) > EPS ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\t//deleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//You should copy the whole file because yank can copy only up to 50 lines or so.\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> point;\ntypedef point vec;\ntypedef array<point, 2> line;\ntypedef vector<point> poly;\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > EPS) return CCW; // ccw\n\tif (cross(b, c) < -EPS) return CW; // cw\n\tif (dot(b, c) < 0) return CAB; // c - a - b\n\tif (norm(b) < norm(c)) return ABC; // a - b - c\n\treturn ERROR;\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nline CapCS(circle c, line s) {\n\tpoint inf(INF, INF);\n\tvector<point> cros = CrosspointCS(c, s);\n\tif (cros.empty()) return line{inf, inf};\n\n\tif (cros.size() == 1) {\n\t\tdouble ad = abs(s[0]-c.c);\n\t\tdouble bd = abs(s[1]-c.c);\n\t\tif (ad < min(bd, c.r)) cros.emplace_back(s[0]);\n\t\telse if (bd < min(ad, c.r)) cros.emplace_back(s[1]);\n\t\telse {\n\t\t\tpoint p = cros[0];\n\t\t\tcros.emplace_back(p); // avoid an undefined behavior\n\t\t}\n\t}\n\n\tif (cros[1] < cros[0]) {\n\t\tswap(cros[0], cros[1]);\n\t}\n\n\treturn line{cros[0], cros[1]};\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\nvoid solve(int n){\n\tvector<line> v;\n\tint ans=0;\n\tcircle c[50][2];\n\tfor(int i=0;i<n;++i){\n\t\tdouble x,y,r,s;\n\t\tcin>>x>>y>>r>>s;\n\t\tc[i][0]=((circle){point (x,y),r});//inside\n\t\tc[i][1]=((circle){point (x,y),r+s});//outside\n\t}\n\tif(n<=2){//to avoid bugs\n\t\tcout<<n<<endl;\n\t\treturn;\n\t}\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\tfor(int l=0;l<2;++l){\n\t\t\t\t\tvector<line> w=CommonTangents(c[i][k],c[j][l]);\n\t\t\t\t\tfor(int m=0;m<w.size();++m){\n\t\t\t\t\t\tv.pb(w[m]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int m=0;m<v.size();++m){\n\t\tint a=0;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(CrosspointCL(c[i][0],v[m]).size()<2&&CrosspointCL(c[i][1],v[m]).size()>0){\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,a);\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<map>\n#include<math.h>\nusing namespace std;\nnamespace geo{\n\n\ttypedef complex<double> P;\n\ttypedef vector<P> Poly;\n\tconst double eps = 1e-8;\n\ttypedef pair<P, P> Line;\n\ttypedef pair<P, double> Circle;\n#define mp(a,b) make_pair(a,b)\n\n\t//?????????????????????????????????????????¨???\n\tinline void x(P& p, double n){ p.real(n); }\n\tinline void y(P& p, double n){ p.imag(n); }\n\tinline double x(P& p){ return p.real(); }\n\tinline double y(P& p){ return p.imag(); }\n\n\t//????????????a??¨b?????????\n\tinline double dot(const P a, const  P b){//A dot B\n\t\treturn a.real()*b.real() + a.imag()*b.imag();\n\t}\n\n\t//????????????a??¨b?????????\n\tinline double cross(const P a, const P b){//A cross B\n\t\treturn a.real()*b.imag() - a.imag()*b.real();\n\t}\n\n\n\t// ???a,b???????????´?????¨???c??¨????????¢\n\tdouble distance(P p, Line l) {\n\t\tauto c = p;\n\t\tauto a = l.first;\n\t\tauto b = l.second;\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\n\t// ?????????????????¨??????????????????????????????????????????\n\tint comp(const P &l, const P &r){\n\t\tif (l.real() == r.real())\n\t\t\treturn(l.imag() < r.imag());\n\t\treturn(l.real() < r.real());\n\t}\n\n\t// ??????p??????????????????????¨?????????§Poly???????´?\n\t// Poly p : ?????¨????????????\n\t// ???????????§O(nlogn)\n\tinline Poly convex_hull(Poly& p){\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(p.begin(), p.end(), comp);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\twhile (k > 1 && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\twhile (k > t && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\n\n\t// ???p?????????????????¨????????¨????????????true\n\t// Poly l : ???????¨????????????????,????????°n\n\t// P p    : ???????????????????????????\n\t// ?????¨??§????????¢?´¢ O(log n)\n\tinline bool convex_in(const Poly& l, const P& p){\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tdouble A, C;\n\t\tconst P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1){\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0){\n\t\t\t\tif (A > -eps&&C < -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (C < -eps || A > -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -eps);\n\t}\n\n\n\t// ??????l?????¢????????????\n\t// Poly l : ???????¨????????????????,????????°n\n\t// O(n)\n\tinline double convex_area(const Poly& l){\n\t\tdouble res = 0;\n\t\tint n = (int)l.size();\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\n\t//???p????????????c?????\\?????????????±?????????????\n\tinline vector<Line> tangent_line(Circle c, P p){\n\t\tvector<Line> res;\n\t\tP Mp = c.first;\n\t\tdouble r = c.second;\n\t\tP v = p - Mp, e;\n\t\tdouble dist = abs(v);\n\t\tif (dist > r + eps){\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv *= r / dist;\n\t\t\tx(e, _cos*x(v) - _sin*y(v));\n\t\t\ty(e, _sin*x(v) + _cos*y(v));\n\t\t\tres.push_back(mp(p, Mp + e));\n\t\t\tx(e, _cos*x(v) + _sin*y(v));\n\t\t\ty(e, -_sin*x(v) + _cos*y(v));\n\t\t\tres.push_back(mp(p, Mp + e));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tinline vector<Line> inner_common_tangent_line(Circle p, Circle q){\n\t\tvector<Line> res;\n\t\tP Mp = p.first, Mq = q.first;\n\t\tdouble Rp = p.second, Rq = q.second;\n\t\tdouble dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + eps){\n\t\t\tP mid = (Rp*Mq + Rq*Mp) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tinline vector<Line> outer_common_tangent_line(Circle p, Circle q){\n\t\tvector<Line> res;\n\t\tP Mp = p.first, Mq = q.first;\n\t\tdouble Rp = p.second, Rq = q.second;\n\t\tP v = Mp - Mq;\n\t\tdouble dist = abs(v);\n\t\tif (dist > Rp - Rq + eps){\n\t\t\tif (abs(Rp - Rq) < eps){\n\t\t\t\tP e = v*P(0, 1);\n\t\t\t\te /= dist;\n\t\t\t\tres.push_back(mp(Mp + e, Mq + e));\n\t\t\t\tres.push_back(mp(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n}\nusing namespace std;\n\ninline int check(geo::Line l,vector<geo::Circle>& cd, vector<geo::Circle>& cm){\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++){\n\t\tdouble d = geo::distance( cd[i].first,l);\n\t//\tcout << d << \" \";\n\t\tif (d<cm[i].second +geo::eps&&d>cd[i].second-geo::eps)\n\t\t\tres++;\n\t}\n\t//cout << endl;\n\treturn res;\n\n\n}\nint main(){\n\t//ifstream cin(\"in.txt\");ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::Circle> cd(N);\n\t\tvector<geo::Circle> cm(N);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tgeo::x(cd[i].first, x);\n\t\t\tgeo::y(cd[i].first, y);\n\t\t\tgeo::x(cm[i].first, x);\n\t\t\tgeo::y(cm[i].first, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d+m;\n\t\t}\n\t\tif (N == 1){\n\t\t\tif (cm[0].second < geo::eps)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (i != j){\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1){\n\t\t\t\t\t\tres=max(check(it, cd, cm),res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();\tcout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-8;\nconst R PI=3.14159265358979323846264338327950288;\nenum { TURE = 1, FALSE = 0, BORDER= -1};\ninline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\ninline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\ninline R inp(const P &a,const P &b){return (conj(a)*b).X;}\ninline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline P unit(const P & p){return p/abs(p);}\ninline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\nstruct L :public vector<P>{\n  L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n  L(){}\n  P dir()const {return at(1)-at(0);}\n  int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n};\nstruct S: public L {\n    S(const P &p1, const P &p2): L(p1,p2){}\n    S(){}\n    int online(const P &p) const{\n        if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n        return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n    }\n};\nstruct C :public P{\n  C(){}\n  C(const P &p,const R r):P(p),r(r){}\n  R r;\n  int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n};\n//inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\ninline int intersect (const C &a,const C &b){\n  return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n}\n  inline R dist2(const L &l,const P &p){\n    return norm(outp(l.dir(),p-l[0]))/norm(l.dir());\n  }\n  inline int intersect(const C &c,const L &l){\n    return less(dist2(l,c),c.r*c.r);\n  }\n\ninline S crosspoint(const C &c1,const C &c2){\n  if(!intersect(c1,c2)) return S();\n  R d=abs(c1-c2);\n  R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n  R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n  P u=unit(c2-c1);\n  return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n}\n\n// inline S crosspoint(const C &c,const L &l){\n//   R d2=dist2(l,c);\n//   if(c.r*c.r+EPS < d2) return S();\n//   P m= proj(c,l);\n//   P u = unit(l[1]-l[0]);\n//   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n//   return S(m+u*d,m-u*d);\n// }\n\nS circlePPR(const P& a, const P& b, R r){\n    return crosspoint( C(a,r), C(b,r) );\n}\n\n  vector<L> CommonTangent(C c1,C c2){\n    if(c1.r > c2.r) swap(c1,c2);\n    R d=abs(c1-c2);\n    vector<L> res;\n    if(d<EPS) return res;\n    if(d + EPS > c1.r + c2.r){\n      P crs=(c1*c2.r + c2*c1.r)/(c1.r+c2.r);\n      R rad = asin(c1.r/abs(crs-c1));\n      res.pb(L(crs,crs+(c1-crs)*polar((R)1,rad)));\n      res.pb(L(crs,crs+(c1-crs)*polar((R)1,-rad)));\n    }\n    if(c1.r+d+EPS > c2.r){\n      R rad=0.5*PI+asin((c2.r-c1.r)/d);\n      P v=unit(c2-c1)*polar((R)1,rad);\n      if(c1.r+d-EPS < c2.r){\n\tres.pb(L(c1+v*c1.r, c1+v*c1.r+(c1-c2)*P(0,1)));\n      }else{\n\tres.pb(L(c1+v*c1.r,c2+v*c2.r));\n\tv=(R)2.*proj(v,c2-c1)-v;\n\tres.pb(L(c1+v*c1.r,c2+v*c2.r));\n      }\n    }\n    return res;\n  }\n}\nusing namespace geom;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<C> in(n),out(n);\n    double x,y,r,m;\n    rep(i,n){\n      cin>>x>>y>>r>>m;\n      in[i]=C(P(x,y),r);\n      out[i]=C(P(x,y),r+m);\n    }\n    int re=1;\n    rep(i,n) rep(j,i){\n      for(C c1:{in[i],out[i]})\n\tfor(C c2:{in[j],out[j]}){\n\t  vector<L> cand=CommonTangent(c1,c2);\n\t  for(L line:cand){\n\t    int cnt=0;\n\t    rep(k,n) if(intersect(in[k],line)<=0 && intersect(out[k],line)) ++cnt;\n\t    if(cnt==6,0){\n\t      cout<<c1<<\",\"<<c2<<\":\"<<cand.size()<<endl;\n\t      for(auto x:line) cout<<x<<\",\";cout<<endl;\n\t    }\n\t    re=max(re,cnt);\n\t  }\n\t}\n    }\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>100) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n      }\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        pv.push_back(resl[k].first);\n        pv.push_back(resl[k].second);\n      }\n      /*\n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        pv.push_back(resl[k].first);\n        pv.push_back(resl[k].second);\n        }*/\n    }\n  }\n\n  pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      L l = L(pv[i], pv[j]);\n      int sum = 0;\n      for(int k=0;k<n;k++){\n        if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n          sum++;\n        }\n      }\n      ans = max(ans, sum);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosθ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinθ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2点を結ぶ直線\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n    double dist(const Point& p) const{ // 点との距離\n        return abs(a * p.x + b * p.y + c) / sqrt(a * a + b * b);\n    }\n    void shift(const Point& p){ // 平行移動\n        c -= a * p.x + b * p.y;\n    }\n};\n\nvector<Line> solve(const Point& c1, double r1, const Point& c2, double r2)\n{\n    Point c = c2 - c1;\n    double len2 = c.y * c.y + c.x * c.x;\n    vector<Line> ret;\n    if(len2 < EPS)\n        return ret;\n\n    // 共通外接線\n    double d = len2 - pow(r1 - r2, 2);\n    if(d > EPS){\n        ret.push_back(Line((c.x * (r1 - r2) + c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 - r2) - c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n        ret.push_back(Line((c.x * (r1 - r2) - c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 - r2) + c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n    }else if(d > -EPS){\n        ret.push_back(Line((c.x * (r1 - r2)) * r1 / c.length(),\n                           (c.y * (r1 - r2)) * r1 / c.length(),\n                           - r1 * r1));\n    }\n    \n    // 共通内接線\n    d = len2 - pow(r1 + r2, 2);\n    if(d > EPS){\n        ret.push_back(Line((c.x * (r1 + r2) + c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 + r2) - c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n        ret.push_back(Line((c.x * (r1 + r2) - c.y * sqrt(d)) * r1 / len2,\n                           (c.y * (r1 + r2) + c.x * sqrt(d)) * r1 / len2,\n                           - r1 * r1));\n    }else if(d > -EPS){\n        ret.push_back(Line((c.x * (r1 + r2)) * r1 / c.length(),\n                           (c.y * (r1 + r2)) * r1 / c.length(),\n                           - r1 * r1));\n    }\n\n    for(unsigned i=0; i<ret.size(); ++i)\n        ret[i].shift(c1);\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Point> c(n);\n        vector<double> r(n), m(n);\n        for(int i=0; i<n; ++i)\n            cin >> c[i].x >> c[i].y >> r[i] >> m[i];\n\n        if(n == 1){\n            cout << 1 << endl;\n            continue;\n        }\n\n        int ret = 0;\n        for(int s=0; s<n; ++s){\n            for(int t=0; t<s; ++t){\n                for(int k=0; k<4; ++k){\n                    double a = r[s];\n                    double b = r[t];\n                    if(k & 1)\n                        a += m[s];\n                    if(k & 2)\n                        b += m[t];\n                    vector<Line> line = solve(c[s], a, c[t], b);\n\n\n                    for(unsigned i=0; i<line.size(); ++i){\n                        int tmp = 0;\n                        for(int j=0; j<n; ++j){\n                            double d = line[i].dist(c[j]);\n                            if(r[j] - EPS < d && d < r[j] + m[j] + EPS)\n                                ++ tmp;\n                        }\n                        ret = max(ret, tmp);\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  elem rIn1 = sqrt( D*D + r2*r2 );\n  elem rIn2 = sqrt( D*D + r1*r1 );\n  intersection_circles( circle(c1.c, rIn1), c2, pcross );\n  intersection_circles( circle(c2.c, rIn2), c1, pcross2 );\n  ret[0] = line(pcross2.second,pcross.first);\n  ret[1] = line(pcross2.first,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n\n  //internal\n  point Ex((r2*c1.c+r1*c2.c)/(r1+r2));\n  elem rEx = sqrt( pow(abs(c1.c-Ex),2.0)-(r1*r1) );\n  intersection_circles( circle(Ex,rEx), c1, pcross );\n  ret[2] = line(Ex,pcross.first);\n  ret[3] = line(Ex,pcross.second);\n\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\n\n\nint main(void){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<circle> cs;\n\t\trep(i,n){\n\t\t\tdouble x,y,r,m;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&r,&m); x+=10; y+=10;\n\t\t\tcs.push_back(circle(pos(x,y),r));\n\t\t\tcs.push_back(circle(pos(x,y),r+m));\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\trep(i,2*n){\n\t\t\trep(j,i){\n\t\t\t\tif(i%2==1 && i-1==j)continue;\n\t\t\t\tvector<line> ls=cs[i].tangs(cs[j]);\n\t\t\t\trep(k,ls.size()){\n\t\t\t\t\t//inithtml();\n\t\t\t\t\tline e=ls[k];\n\t\t\t\t\te = line(e.p+e.vec.tolen(-3000),e.p+e.vec.tolen(3000));\n\t\t\t\t\t//e.outh(10);\n\t\t\t\t\t\n\t\t\t\t\tint na=0;\n\t\t\t\t\trep(p,n){\n\t\t\t\t\t\t//cs[p*2].outh(10);\n\t\t\t\t\t\t//cs[p*2+1].outh(10);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdouble d=e.dist(cs[p*2].p);\n\t\t\t\t\t\tif(d+1e-6<cs[p*2].r)continue;\n\t\t\t\t\t\tif(cs[p*2+1].r+1e-6<d)continue;\n\t\t\t\t\t\tna++;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,na);\n\t\t\t\t\t//printf(\"na %d %d %d %s %d\\n\",i,j,k,e.str().c_str(),na);\n\t\t\t\t\t/*\n\t\t\t\t\tchar buf[20];\n\t\t\t\t\tsprintf(buf,\"o_%d_%d_%d\",i,j,k);\n\t\t\t\t\touthtml(buf,10);\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に点tを角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n  //平行でない前提\n  Point intersectionPoint(Line l){\n    return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n  }\n\n  //射影\n  Point project(Point p){\n    Point base=b-a;\n    Real t=(p-a).dot(base)/base.dot(base);\n    return a+base*t;\n  }\n\n  //p1,p2を通る直線を対称軸として点Qと線対称の座標R\n  Point symmetry(Point Q){\n    return Q+(project(Q)-Q)*2;\n  }\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n\n  Line tangent(Real theta){\n    Point a(r*cos(theta),r*sin(theta));\n    Point b(a.y,-a.x);\n    return Line(p+a,p+a+b);\n  }\n  \n  vector<Line> commonTangent(Circle x){\n    vector<Line>res;\n    x.p=x.p-p;\n    Real a=x.p.arg();\n    Real b[2]={(r-x.r),(r+x.r)};\n    for(int i=0;i<2;i++){\n      b[i]/=x.p.norm();\n      if(sgn(b[i],-1.0)<0 || sgn(b[i],1.0)>0)return res;\n      Real c=asin(b[i])-asin(1.0);\n      res.push_back(tangent(a-c));\n      res.push_back(tangent(a+c));\n    }\n    return res;\n  }\n  \n};\n\nint n;\nvector<Circle>c;\nvector<Real>m;\n\nvector<Line> enumerate(){\n  vector<Line>res;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      vector<Line>tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r+=m[i];\n      tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r-=m[i];\n    }\n  }\n  return res;\n}\n\nint count(Line l){\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    Real d=l.dist(c[i].p)-c[i].r;\n    cnt+=(sgn(d)>=0 && sgn(d,m[i])<=0);\n  }\n  return cnt;\n}\n\nint main(void){\n\n  while(cin >> n,n){\n    c.resize(n);\n    m.resize(n);\n\n    for(int i=0;i<n;i++)\n      cin >> c[i].p.x >> c[i].p.y >> c[i].r >> m[i];\n    \n    vector<Line>res=enumerate();\n    \n    int cnt=0;\n    for(int i=0;i<res.size();i++){\n      cnt=max(cnt,count(res[i]));\n    }\n    cout << max(1,cnt) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-12;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\t//cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\t//cout << \"ok\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t//cout << \"ng\" << endl;\n\t\t}\n\t}\n\t\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r+eps){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r2/(r1+r2)*p1+r1/(r1+r2)*p2;\n\t//cout << \"aaa \" << endl;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\t//cout << \"bbb \" << endl;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-6;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\t//cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\t//cout << \"ok\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t//cout << \"ng\" << endl;\n\t\t}\n\t}\n\t\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r2/(r1+r2)*p1+r1/(r1+r2)*p2;\n\t//cout << \"aaa \" << endl;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\t//cout << \"bbb \" << endl;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// dot of a and b\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// cross of a and b\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\t//norm::��Βl��2��\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Circle> c;\n        vector<ld> m(n);\n        for(int i=0;i<n;i++){\n            ld x,y,r;\n            cin>>x>>y>>r>>m[i];\n            c.push_back(Circle(Point(x,y),r));\n        }\n        if(n==1){\n            cout<<1<<endl;\n            continue;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                vector<Line> ls=tangent_cc(c[i],c[j]);\n                for(int k=0;k<(int)ls.size();k++){\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        ld d=dist_lp(ls[k],c[idx].p);\n                        if(c[idx].r<d+eps && d-c[idx].r<m[idx]+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nPoint rotate(Point p, double th) {\n  // th[rad]\n  return Point(cos(th)*p.x-sin(th)*p.y, sin(th)*p.x+cos(th)*p.y);\n}\nPoint rotate90(Point p) {\n  return Point(-p.y, p.x);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s = Point(), Point t = Point()):s(s), t(t){}\n};\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n  Vector base = s.t - s.s;\n  double r = dot(p - s.s, base) / norm(base);\n  return s.s + base * r;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.t - l.s, p - l.s) / abs(l.t - l.s));\n}\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle(Point p = Point(), double r = 0.0):p(p), r(r){}\n};\n\nbool intersect(Circle c1, Circle c2) {\n  double d = getDistance(c1.p, c2.p);\n  return le(d, c1.r+c2.r) && !lt(d, fabs(c1.r-c2.r));\n}\n\nvector<Point> getCrossPointsCL(Circle c, Line l) {\n  vector<Point> res;\n  Vector pr = project(l, c.p);\n  if(lt(c.r, abs(c.p-pr))) return res;\n  Vector e = (l.t-l.s)/abs(l.t-l.s);\n  double base = sqrt(c.r*c.r-norm(pr-c.p));\n  res.push_back(pr+e*base);\n  if(!eq(base, 0)) res.push_back(pr-e*base);\n  return res;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n  Vector a = p-c.p;\n  vector<Point> res;\n  double x = norm(a);\n  double d = x-c.r*c.r;\n  if(d < -EPS) return res;\n  d = max(d, 0.0);\n  Point p1 = a*(c.r*c.r/x);\n  Point p2 = rotate90(a)*(-c.r*sqrt(d)/x);\n  res.emplace_back(c.p+p1-p2);\n  res.emplace_back(c.p+p1+p2);\n  return res;\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n  vector<Line> res;\n  vector<Point> ps, qs;\n  if(abs(c2.p-c1.p) < EPS) return res;\n  // ?????\\???\n  if(abs(c1.r-c2.r) < EPS) {\n    Point dir = c2.p-c1.p;\n    dir = rotate90(dir*(c1.r/abs(dir)));\n    res.emplace_back(c1.p+dir, c2.p+c1.r);\n    res.emplace_back(c1.p-dir, c2.p-c1.r);\n  } else {\n    Point p = c1.p*(-c2.r)+c2.p*c1.r;\n    p = p*(1.0/(c1.r-c2.r));\n    ps = tangentCP(c1, p);\n    qs = tangentCP(c2, p);\n    int n = ps.size(), m = qs.size();\n    for(int i = 0; i < min(n, m); i++) {\n      res.emplace_back(ps[i], qs[i]);\n    }\n  }\n  // ?????\\???\n  Point p = c1.p*c2.r+c2.p*c1.r;\n  p = p*(1.0/(c1.r+c2.r));\n  ps = tangentCP(c1, p);\n  qs = tangentCP(c2, p);\n  int n = ps.size(), m = qs.size();\n  for(int i = 0; i < min(n, m); i++) {\n    res.emplace_back(ps[i], qs[i]);\n  }\n  return res;\n}\n\nint N;\nvector<Circle> C;\nvector<double> m;\n\nint getJewels(Line l) {\n  int res = 0;\n  rep(i, N) {\n    double dist = getDistanceLP(l, C[i].p);\n    if(lt(dist, C[i].r)) continue;\n    if(le(dist-C[i].r, m[i])) res++;\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    resz(C, N);\n    resz(m, N);\n    rep(i, N) {\n      cin >> C[i].p.x >> C[i].p.y >> C[i].r >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    int ans = 0;\n    rep(i, N) reps(j, i+1, N) {\n      Circle c1(C[i].p, C[i].r+m[i]), c2(C[j].p, C[j].r+m[j]);\n      vector<Line> L1 = tangentCC(C[i], C[j]);\n      for(Line l : L1) chmax(ans, getJewels(l));\n      vector<Line> L2 = tangentCC(C[i], c2);\n      for(Line l : L2) chmax(ans, getJewels(l));\n      vector<Line> L3 = tangentCC(c1, C[j]);\n      for(Line l : L3) chmax(ans, getJewels(l));\n      vector<Line> L4 = tangentCC(c1, c2);\n      for(Line l : L4) chmax(ans, getJewels(l));\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*P(0, 1)));\n\t} else {\n\t\tD d = abs(b.p - a.p);\n\t\tP v = (a.p - b.p)/d;\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\t//P q = a.p + v*t;\n\tP q = (a.p*b.r + b.p*a.r)/(a.r+b.r);\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distLP(Point a1, Point a2, Point p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<Line> tangentLines(Point a, double ar, Point b, double br) {\n  vector<Line> ls;\n  double d = abs(b-a);\n  rep (i,2) {\n    double sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    double cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      Point n = (b-a) * Point(sin, (1-j*2)*cos) / d;\n      ls.push_back(Line(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<Point> c(n);\n        vector<int> r(n),m(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y >>r[i] >>m[i];\n            c[i] = Point(x,y);\n        }\n\n        int ans = 1;\n        rep(i,n)rep(j,n)if(i!=j){\n            rep(ii,2)rep(jj,2){\n                vector<Line> ls = tangentLines(c[i],r[i]+ii*m[i],c[j],r[j]+jj*m[j]);\n                for(const auto &l:ls){\n                    int tt = 0;\n                    rep(k,n){\n                        double d = distLP(l.fi,l.se,c[k]);\n                        if(LE(0,d-r[k]) && LE(d-r[k],m[k])) ++tt;\n                    }\n                    ans = max(ans,tt);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// last update 2015/05/29\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P p;\n  double r;\n  C() {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\n// 0:?????¨, 1:?¢????, 2:?????¨\nint contain(C c, P p) {\n  if(abs(c.p - p) - c.r <  -eps) return 2;\n  if(abs(c.p - p) - c.r >  eps) return 0;\n  return 1;\n}\n\n// ??????????§???¢????????¨/?¢????/?????¨???????????????????????????????????????\n// 0:?????¨, 1:?¢????, 2:?????¨\n// by Spaghetti Source\nint contain(const vector<P> &g, const P &p) {\n  int n = g.size();\n  int in = 0;\n  for(int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() < eps && eps < b.imag() && cross(a, b) < -eps) in = !in;\n    if(abs(cross(a, b)) < eps && dot(a, b) < eps) return 1;\n  }\n  return in * 2;\n}\n\n// ????????¨????????????????????????\n// T??????L????????????????????£???????????????true???????????????\n// ??????????????????????????´?????? <= ??? < ????????´?????????????????????????????????\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// ??´?????¨????????????????????????????????????????????°???\nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.p);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// ?????¨?????????????????????\n//  0 : ?????????????????????\n//  1 : ?????¨??§1?????¨??\\??????\n//  2 : 2?????§??????\n// -1 : ??????????????\\??????\n// -2 : ?????¨?????????\nint isIntersect(C a, C b) {\n  double x = a.p.real() - b.p.real();\n  double y = a.p.imag() - b.p.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// ??´?????¨??´???????????????\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross ????¬??????¢?????????\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// ??´?????¨???????????????\nvector<P> getCrossPLC(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.p);\n  double dist = getDistanceLP(s1, s2, c.p);\n  if (equals(dist, c.r)) {\n    v.push_back(p);\n  } else if (dist < c.r) {\n    double h = abs(p - c.p);\n    double d = sqrt(c.r * c.r - h * h);\n    P base = s2 - s1;\n    // push_back?????????????????????\n    v.push_back(p - d * base / abs(base));\n    v.push_back(p + d * base / abs(base));\n  }\n  return v;\n}\n\n// ?????¨???????????????\nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.p - c2.p);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.p - c1.p;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.p + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.p + A*base + h*n);\n    v.push_back(c1.p + A*base - h*n);\n  }\n  return v;\n}\n\n// 2????????????????????????????§?(0 <= rad <= PI)\n// AOJ2233??§?????°??£????????§??´??°(2015/05/29)\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\n// a -> b ???????§????????§???????(0 <= rad < 2*PI)\ndouble getAngleVector(P a, P b) {\n  double A = arg(a);\n  double B = arg(b);\n  double rad = B-A;\n  rad = fmod(rad, M_PI*2.0);\n  if(rad < 0.0) rad += M_PI*2.0;\n  return rad;\n}\n\n// 2????????´????????\\????????????r??????\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = arg(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.p = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// ??????????????¬????????¨??????????§???¢???3????????????????????¢???????±???????\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// ????§???¢?????¢???(?¬??????????)\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\ndouble getTriArea(P a, P b, P c) {\n  return cross(b-a, c-a) / 2.0;\n}\n\ndouble getSectorArea(P a, P b, C c) {\n  return getAngleVector(a-c.p, b-c.p) * c.r * c.r / 2.0;\n}\n\ndouble getBowArea(P a, P b, C c) { // a,b is a chord of c.\n  return getSectorArea(a, b, c) - getTriArea(a, b, c.p);\n}\n\ndouble getArea(P a, P b, C c) {\n  int d = 1;\n  if(cross(a,b) < 0.0) {\n    d = -1;\n    swap(a, b);\n  }\n  if(cross(a, b) < eps) return 0;\n\n  G t(3);\n  t[0] = P(0, 0), t[1] = a, t[2] = b;\n\n  if(contain(c, t[0]) && contain(c, t[1]) && contain(c, t[2])) {\n    return d * getTriArea(t[0], t[1], t[2]);\n  }\n\n  if(getDistanceSP(t[0], t[1], c.p) - c.r > -eps &&\n     getDistanceSP(t[1], t[2], c.p) - c.r > -eps &&\n     getDistanceSP(t[2], t[0], c.p) - c.r > -eps) {\n    if(cross(t[1] - t[0], c.p - t[0]) > -eps &&\n       cross(t[2] - t[1], c.p - t[1]) > -eps &&\n       cross(t[0] - t[2], c.p - t[2]) > -eps) {\n      return d * (c.r * c.r * M_PI);\n    } else {\n      return 0;\n    }\n  }\n\n  double S = c.r * c.r * M_PI;\n  vector<P> cp(6);\n  vector<int> exist(6);\n  for(int i = 0; i < 3; ++i) {\n    P p = t[i], q = t[(i+1)%3];\n    if(getDistanceLP(p, q, c.p) - c.r > -eps) {\n      if(cross(q - p, c.p - p) < 0) return 0;\n      continue;\n    }\n    if(getDistanceSP(p, q, c.p) - c.r > -eps) continue;\n    vector<P> v = getCrossPLC(t[i], t[(i+1)%3], c);\n    if(v.size() == 2 && !equals(v[0], v[1])) {\n      S -= getBowArea(v[0], v[1], c);\n      for(int j = 0; j < v.size(); ++j) {\n        int k = (i*2 + j*3) % 6;\n        cp[k] = v[j];\n        exist[k] = true;\n      }\n    }\n  }\n  for(int i = 0; i < 3; ++i) {\n    int a = i*2, b = i*2+1;\n    if(!exist[a] || !exist[b]) continue;\n    if(contain(c, t[i]) == 2 && !equals(cp[a], cp[b])) {\n      S += getBowArea(cp[a], cp[b], c) + getTriArea(t[i], cp[a], cp[b]);\n    }\n  }\n  return S * d;\n}\n\n// ????§???¢??¨????????±?????¨????????¢???(?¬??????????)\ndouble getArea(G g, C c) {\n  int n = g.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += getArea(g[i], g[(i+1)%n], c);\n  }\n  return res;\n}\n\n// ????§???¢????????\\????????????\ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// ?????£?????????????????¨??????????§???¢????????????????????????????????¢?????????\n// O(NlogN)\n// by Ari book\ndouble caliper(const vector<P> &ps) {\n  vector<P> qs = convex_hull(ps);\n  int n = qs.size();\n  if(n == 2) {\n    return abs(qs[0] - qs[1]);\n  }\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k) {\n    if(!(qs[i] < qs[k])) i = k;\n    if(qs[j] < qs[k]) j = k;\n  }\n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(qs[i] - qs[j]));\n    if(cross((qs[(i+1)%n] - qs[i]), (qs[(j+1)%n] - qs[j])) < 0) {\n      i = (i+1)%n;\n    } else {\n      j = (j+1)%n;\n    }\n  }\n  return res;\n}\n\nvector<L> getTangent(C a, C b) {\n  vector<L> res;\n  if (a.r > b.r) swap(a, b);\n  if (a.p == b.p) return res;\n  P base = b.p - a.p;\n  for (double s = -1; s <= 1; ++++s) {\n    double c, d, ee;\n    ee = norm(base);\n    d = b.r + a.r * s;\n    if (ee - d * d < 0.0) continue;\n    c = sqrt(ee - d * d);\n    if (c < eps) {\n      P v = base * P(0, 1);\n      P m = b.p - base * b.r / abs(base);\n      res.push_back(L(m, m + v));\n    } else {\n      for (double t = -1; t <= 1; ++++t) {\n        P rotate(c / sqrt(ee), d / sqrt(ee) * t);\n        P v = -base * rotate * s;\n        P nv = v / abs(v) * P(0, t);\n        res.push_back(L(a.p + nv * a.r, b.p - nv * b.r * s));\n      }\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      double x, y;\n      cin >> x >> y >> r[i] >> m[i];\n      p[i] = P(x, y);\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include\"2D.h\"\nusing namespace std;\n\ninline int check(geo::Line l,vector<geo::Circle>& cd, vector<geo::Circle>& cm){\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++){\n\t\tdouble d = geo::distance( cd[i].first,l);\n\t\t//cout << d << \" \";\n\t\tif (d<cm[i].second +geo::eps&&d>cd[i].second-geo::eps)\n\t\t\tres++;\n\t}\n//\tcout << endl;\n\treturn res;\n\n\n}\nint main(){\n\t//ifstream cin(\"in.txt\");ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::Circle> cd(N);\n\t\tvector<geo::Circle> cm(N);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tgeo::x(cd[i].first, x);\n\t\t\tgeo::y(cd[i].first, y);\n\t\t\tgeo::x(cm[i].first, x);\n\t\t\tgeo::y(cm[i].first, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d+m;\n\t\t}\n\t\tif (N == 1){\n\t\t\tif (cm[0].second < geo::eps)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (i != j){\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1){\n\t\t\t\t\t\tres=max(check(it, cd, cm),res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();\tcout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-12;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\t//cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\t//cout << \"ok\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t//cout << \"ng\" << endl;\n\t\t}\n\t}\n\t\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r2/(r1+r2)*p1+r1/(r1+r2)*p2;\n\t//cout << \"aaa \" << endl;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\t//cout << \"bbb \" << endl;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _ª½p`ÌÉ¶Ý·é©Ç¤©\nbool isInPolygon(vector<P> &points,P s){\n\tif(points.size()==1)return false;\n\tvector<P> v;\n\tfor(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n\tint sign=0;\n\tfor(int i=1;i<=(int)v.size();i++){\n\t\tint prv=(i-1+v.size())%v.size();\n\t\tint cur=i%v.size();\n\t\tdouble c=cross(v[prv],v[cur]);\n\t\tif(EQ(c,0))continue;\n\t\telse if(sign==0){\n\t\t\tif(c>0)sign=1;\n\t\t\telse sign=-1;\n\t\t}\n\t\telse{\n\t\t\tif(sign==-1&&c>0)return false;\n\t\t\telse if(sign==1&&c<0)return false;\n\t\t}\n\t}\n\treturn true;\n}\nstruct Rec{\n\tvector<P> p;\n};\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}// aÆbÌé`ªÚµÄ¢é©Ç¤©(Ç¿ç©ªÇ¿©çðÜñÅ¢éàÌàÓ­Þ\nbool isTouchRectangle(Rec &a,Rec &b){\n\t// aÌe¸_ªbÌÉ¶ÝµÄ¢é©`FbN\n\tfor(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n\t// t\n\tfor(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n\t// eÓª¼ûÌÇê©ÌÓÆÚµÄ¢é©\n\tfor(int i=0;i<4;i++){\n\t\tint curi=i;\n\t\tint prvi=(i-1+4)%4;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint curj=j;\n\t\t\tint prvj=(j-1+4)%4;\n\t\t\tif(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n\t\t}\n\t}\n\treturn false;\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// PÊxNgðßé\nP normalVector(P p){\n\treturn p/abs(p);\n}\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P tmp){\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n// ÀWÌñ](ÀWpÉ é_ð,¼vñèÉa(WA)ñ])\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // üªªÉÜÜêéÆ«A±±ÌRgAEgðÍ¸¹Îtrue(ð·)ÆÈé\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// é`ÌÉ_ª¶Ý·é©Ç¤©\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn sum/2;\n}\n// 2xNgÔÌpx\n// a©çbÖ¶üèÅ½x©(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n// 2ÂÌxNgÌdÈÁÄ¢éªÌ·³ðÔ·\n// àµdÈÁÄ¢È¯êÎ0ðÔ·\ndouble multipleLength(P a,P b,P c,P d){\n    Edge e1=make_pair(a,b);\n    Edge e2=make_pair(c,d);\n    // ½sÅ é©Ç¤©\n    if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n        &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n        return 0;\n    double dist=0;\n    // ¼ûæÁÄ¢é\n    if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0))\n        dist=abs(e2.first-e2.second);\n    else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0))\n        dist=abs(e1.first-e1.second);\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n        // Ç¿çªüãÉ é©\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.first);\n        else\n            dist=abs(e1.second-e2.first);\n    }\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.second);\n        else\n            dist=abs(e1.second-e2.second);\n    }\n    return dist;\n}\n// 2_ðÊé¼arÌ~Ì_ðßé\npair<P,P> calcCircleCenterPoint(P dot1,P dot2,double r){\n    double v=abs(dot1-dot2);\n    double x = sqrt(r*r - (v/2)*(v/2));\n    // ñgÌPÊ@üxNg\n    P hose[2];\n    double x1=-(dot1.imag()-dot2.imag());\n    double y1=(dot1.real() - dot2.real());\n    hose[0]=P(x1,y1);\n    double y2=-y1;\n    double x2=-x1;\n    hose[1]=P(x2,y2);\n    double dd1=abs(hose[0]);\n    double dd2=abs(hose[1]);\n    hose[0]/=dd1;hose[0]*=x;\n    hose[1]/=dd2;hose[1]*=x;\n    P tmp=(dot1+dot2);\n    tmp/=2;\n    hose[0]+=tmp;\n    hose[1]+=tmp;\n    return make_pair(hose[0],hose[1]);\n}\n// 4üªª[_ÈOÅNXµÄ¢é©Ç¤©ð»è\nbool checkCross(const vector<Edge> &vec){\n    for(int i=0;i<vec.size();i++){\n        for(int j=i+1;j<vec.size();j++){\n            // üªªNXµÄ¢é©Ç¤©\n            if(is_intersected_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second)){\n                // µÄ¢éêA[_ÈOÅNXµÄ¢éÈçAfalse\n                P p=intersection_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second);\n                if(!(EQ(p,vec[i].first)||EQ(p,vec[i].second)))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n// ø«Å^¦çê½4ÂÌ_ªé`ðìéÇ¤©ð»è\nbool checkRec(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ±±Å·×ÄÌüªªNX·é©Ç¤©ðvZ\n        if(checkCross(ve)){\n            // üªÌ·³ðmF\n            if(EQ(abs(ve[0].first-ve[0].second),abs(ve[2].first-ve[2].second)))\n                if(EQ(abs(ve[1].first-ve[1].second),abs(ve[3].first-ve[3].second)))\n                    // ¼s\n                    if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                        if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                        return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// ø«Å^¦çê½4ÂÌ_ª³û`ðìé©Ç¤©ð»è\nbool checkSqu(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ±±Å·×ÄÌüªªNX·é©Ç¤©ðvZ\n        if(checkCross(ve)){\n            // üªÌ·³ðmF\n            double d=abs(ve[0].first-ve[0].second);\n            for(int i=1;i<4;i++){\n                double d2=abs(ve[i].first-ve[i].second);\n                if(!EQ(d,d2))return false;\n            }\n            // ¼smF\n            if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                    return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// ñ~Ì¤ÊÚüð\\¬·é4¼üðßé(ñ~Í¨Ý¢Úµ½èÇ¿ç©ðÓ­ñ¾èµÈ¢)\nvector<pair<P,P> > calcCommonTangentialLine(P p1,double r1,P p2,double r2){\n\tvector<pair<P,P> > res;\n\tif(r1>r2){\n\t\tswap(r1,r2);\n\t\tswap(p1,p2);\n\t}\n\t// ¤ÊOÚü\n\t{\n\t\tdouble d=abs(p1-p2);\n\t\tdouble a=abs(r1-r2);\n\t\tdouble b=sqrt(d*d-a*a);\n\t\tdouble sita=acos(b/d);\n\t\tP e=normalVector(roundPoint((roundPoint((p2-p1),sita)),PI/2));\n\t\tres.push_back(make_pair(e*r1+p1,e*r2+p2));\n\t\tP e2=normalVector(roundPoint((roundPoint((p2-p1),-sita)),-PI/2));\n\t\tres.push_back(make_pair(e2*r1+p1,e2*r2+p2));\n\t}\n\t// ¤ÊàÚü\n\t{\n\t\tP cp=(r1*p1+r2*p2)/(r1+r2);\n\t\tdouble u=abs(cp-p1);\n\t\tdouble sita=acos(r1/u);\n\t\tP e=normalVector(roundPoint(cp-p1,sita));\n\t\tres.push_back(make_pair(e*r1+p1,-e*r2+p2));\n\t\tP e2=normalVector(roundPoint(cp-p1,-sita));\n\t\tres.push_back(make_pair(e2*r1+p1,-e2*r2+p2));\n\t}\n\treturn res;\n}\n\nclass Circle{\npublic:\n\tdouble r;\n\tdouble m;\n\tP p;\n};\nCircle cs[100];\n\nint main(){\n\tint N;\n\twhile(cin>>N&&N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y>>cs[i].r>>cs[i].m;\n\t\t\tcs[i].p=P(x,y);\n\t\t}\n\t\tif(N==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint maxC=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tfor(int p=0;p<2;p++){\n\t\t\t\t\tfor(int q=0;q<2;q++){\n\t\t\t\t\t\tdouble a=p?cs[i].m:0;\n\t\t\t\t\t\tdouble b=q?cs[j].m:0;\n\t\t\t\t\t\tvector<pair<P,P> > res\n\t\t\t\t\t\t=calcCommonTangentialLine(cs[i].p,cs[i].r+a,cs[j].p,cs[j].r+b);\n\t\t\t\t\t\t// »ê¼êÌÚüÉÂ¢Ä²×é\n\t\t\t\t\t\tfor(int k=0;k<(int)res.size();k++){\n\t\t\t\t\t\t\t// ±ÌÚüÅ¢­ÂÆêé©\n\t\t\t\t\t\t\tint cnt=0;\n\t\t\t\t\t\t\tP p1=res[k].first;\n\t\t\t\t\t\t\tP p2=res[k].second;\n\t\t\t\t\t\t\tfor(int l=0;l<N;l++){\n\t\t\t\t\t\t\t\tdouble d=distance_l_p(res[k].first,res[k].second,cs[l].p)-cs[l].r;\n\t\t\t\t\t\t\t\tif(EQ(d,0)||EQ(d,cs[l].m)||(d>0&&d<cs[l].m))cnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmaxC=max(maxC,cnt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<maxC<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst double EPS = 1e-8;\n\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\nstruct Circle {\n    Point c; double r;\n    Circle () {}\n    Circle (const Point &c, double r) : c(c), r(r) {}\n};\n\n\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\ndouble dot (const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool parallelLL (const Line &l, const Line &m) {\n    return abs(cross(l[1] - l[0],m[1] - m[0])) > EPS ;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS (const Line &l, const Line &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP (const Line &l, const Point &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP (const Line &s, const Point &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nPoint reflection(const Line &l, const Point &p) {\n    return p + 2.0 * (projection(l, p) - p);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const Line &l, const Line &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const Line &l, const Line &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const Point &p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n            min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(const Line &l, const Line &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble area (const Polygon &g) {\n    double sum = 0;\n    for (int i = 0; i < g.size(); i++) \n        sum += cross(g[i], g[(i+1)%g.size()]);\n    return abs(sum)/2;\n}\n\n// O(N log N)\nPolygon convexHull (Polygon g) {\n    int n = g.size(), k = 0;\n    sort(g.begin(), g.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = g[i++]) //lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], g[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = g[i--]) //upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], g[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n\n//O(N)\n//return left of l in g\nPolygon convexCut (const Polygon &g, const Line &l) {\n    Polygon ret;\n    for (int i = 0; i < g.size(); i++) {\n        Point a = g[i], b = g[(i+1)%g.size()];\n        if (ccw(l[0], l[1], a) != -1) ret.push_back(a);\n        if (ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n            ret.push_back(crosspoint(Line(a,b), l));\n    }\n    return ret;\n}\n\n//?????¨????§???¢???????????????\nbool inPolygon (const Polygon &g, const Point &p) {\n    double sum = 0.0;\n    int n = g.size();\n    for (int i = 0; i < g.size(); i++) {\n        int j = (i+1)%n;\n        if (intersectSP(Line(g[i], g[j]), p)) return true;\n        sum += arg((g[j]-p)/(g[i]-p));\n    }\n    return abs(sum) > 1;\n}\n\n//??????????????????????±???????\nvector<Point> normal (const Point &p) {\n    vector<Point> res;\n    res.push_back( Point(-imag(p), real(p)));\n    res.push_back( Point(imag(p), -real(p)));\n    return res;\n}\n\n//2??????????????????????±??????????\nvector<Point> bisector (const Point &a, const Point &b) {\n    vector<Point> res;\n    vector<Point> normals = normal(a-b);\n    Point center = (a+b)/2;\n    res.push_back(normals[0]);\n    res.push_back(normals[1]);\n    return res;\n}\n\n\n// ??????????????????????¬??????????\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// ?????????????????????????????????\nbool equal(double a, double b){ \n    return abs(b - a) < EPS;\n}\n\n\n// ????????\\??? (????????????????§?th????????§??\\????????\\???)\nLine circleTangent(Circle& C, double th){\n    Point p0 = C.c + polar(C.r, th);\n    Point p1 = p0 + polar(1.0, th + M_PI / 2);\n    return Line(p0, p1);\n}\n\n// ?????????????????±?????\\??? (C?????????????????\\????????????????????????????§??????????)\nvector<double> commonTangents(const Circle &C, const Circle &D){\n    vector<double> res;\n    Point v = D.c - C.c;\n    double l = abs(v); // ??????????????????????????¢\n    double a = arg(v); // ?????????????????????????§?\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // ????????? or ?????\\ or ??¢????????????\n        // ??????????????´??\\???\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // ??¢????????????\n            // ??????????????´??\\???\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((equal(abs(C.r - D.r), l) || equal(C.r + D.r, l)) && sign(l) != 0){\n        // ?????\\ or ?????\\\n        // ???????????\\???\n        res.push_back(a);\n    }\n    return res;\n}\n\n\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n    vector<Point> ret;\n    Point center = projection(l, c.c);\n    double d = abs(center - c.c);\n    double t = sqrt(c.r * c.r - d * d);\n    if (isnan(t)) { return ret; }\n    Point vect = (l[1] - l[0]);\n    vect /= abs(vect);\n    ret.push_back(center - vect * t);//\n    if (t > EPS) {\n        ret.push_back(center + vect * t);\n    }\n    return ret;\n}\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n    vector<Point> ret;\n    double d = abs(c1.c - c2.c);\n    if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n    double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point start = c1.c + (c2.c - c1.c) / d * x;\n    Point vect = (c1.c - c2.c) * Point(0.0, 1.0);\n    return crosspointLC(Line(start, start + vect), c1);\n}\n\nvector<Circle> inc, outc;\nint check(Circle c1, Circle c2){\n    int res = 0;\n\n    //cout << \"calc\" << real(c1.c) << \":\" << real(c2.c) << endl;\n    vector<double> l = commonTangents(c1, c2);\n    FOR(e, l){\n        double x = *e;\n        Point p = Point(real(c1.c) + c1.r * cos(x), imag(c1.c) + c1.r * sin(x));\n        Point p2 = Point(real(p) - c1.r * sin(x), imag(p) + c1.r * cos(x));\n        Line l = Line(p, p2);\n        //cout << real(p) << \":\" << imag(p) << endl;\n        //cout << real(p2) << \":\" << imag(p2) << endl;\n        int re = 0; \n        REP(i, inc.size()){\n            double d = distanceLP(l, inc[i].c);\n            //cout << d << \":\";\n            if((d - inc[i].r > -EPS) && (-EPS < outc[i].r - d)) re++;\n        }\n        //cout << endl;\n        res = max(res, re);\n    }\n    //cout << res << endl;\n    return res;\n}\n\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        inc = vector<Circle>(n);\n        outc = vector<Circle>(n);\n        REP(i, n){\n            int x, y, r, m;\n            cin >> x >> y >> r >> m;\n            inc[i] = Circle(Point(x, y), r);\n            outc[i] = Circle(Point(x, y), r + m); \n        }\n    \n        if(n == 1){\n            cout << \"1\" << endl;\n            continue;\n        }\n\n        int ans = 0;\n        REP(i, n){\n            REP(j, n){\n                if(i == j) continue;\n                ans = max(ans, check(inc[i], inc[j]));\n                ans = max(ans, check(outc[i], outc[j]));\n            }\n        }\n        REP(i, n){\n            for(int j = i + 1; j < n; j++){\n                ans = max(ans, check(inc[i], outc[j]));\n                ans = max(ans, check(outc[i], inc[j]));\n            }\n        }\n        cout << ans << endl;\t\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n#define mkp make_pair\n#define PB push_back\n#define ALL(v) v.begin(),v.end()\n#define maxs(a,b) (a=max(a,b))\n#define mins(a,b) (a=min(a,b))\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<vector<int>> vvint;\ntypedef pair<int, int> pii;\n// typedef pair<,pii> P;\n\ntypedef complex<double> P;\n\n#define EPS (1e-8)\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ntemplate<class T>\nT sq(T a){\n\treturn a*a;\n}\n\ndouble dd[]={1,-1};\n\nbool check(P a,P b,P p,double r,double c){\n\tdouble d = distance_l_p(a,b,p);\n\tif(r-d>EPS){\n\t\treturn false;\n\t}\n\tif(c-(d-r)>-EPS) return true;\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<pair<P, P>> v(n);\n\t\tvector<pair<P, P>> w;\n\t\trep(i, n) {\n\t\t\tdouble a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tv[i] = mkp(P(a, b), P(c, d));\n\t\t\tw.PB(mkp(P(a,b),P(c+d,d)));\n\t\t\tw.PB(v[i]);\n\t\t}\n\t\tvector<pair<P,P>> line;\n\t\trep(i,w.size()){\n\t\t\trep(j,i){\n\t\t\t\tdouble xp=w[j].F.real()-w[i].F.real();\n\t\t\t\tdouble yp=w[j].F.imag()-w[i].F.imag();\n\t\t\t\tdouble r = w[i].S.real();\n\t\t\t\tdouble R = w[j].S.real();\n\t\t\t\t// cout<<xp<<\" \"<<yp<<\" \"<<endl;\n\t\t\t\tif(sq(xp)+sq(yp)-sq(r+R)>=0){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tdouble xq,yq,xx,yy;\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\txq = r*(xp*(r+R)+dd[k]*yp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\tyq = r*(yp*(r+R)-dd[k]*xp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\t// cout<<\"xq yq \"<<xq<<\" \"<<yq<<endl;\n\t\t\t\t\t\tp = P(xq,yq) * P(0,1) + P(xq,yq) + w[i].F;\n\t\t\t\t\t\tline.PB(mkp(P(xq,yq)+w[i].F,p));\n\t\t\t\t\t\t// cout<<i<<\" \"<<j<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tR=-R;\n\t\t\t\tif(sq(xp)+sq(yp)-sq(r+R)>=0){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tdouble xq,yq,xx,yy;\n\t\t\t\t\t\tP p;\n\t\t\t\t\t\txq = r*(xp*(r+R)+dd[k]*yp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\tyq = r*(yp*(r+R)-dd[k]*xp*sqrt(sq(xp)+sq(yp)-sq(r+R)))/(sq(xp)+sq(yp));\n\t\t\t\t\t\t// cout<<\"xq yq \"<<xq<<\" \"<<yq<<endl;\n\t\t\t\t\t\tp = P(xq,yq) * P(0,1) + P(xq,yq) + w[i].F;\n\t\t\t\t\t\tline.PB(mkp(P(xq,yq)+w[i].F,p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(auto z:line){\n\t\t\t// cout<<z.F<<\" \"<<z.S<<endl;\n\t\t\tint tmp = 0;\n\t\t\trep(i,n){\n\t\t\t\tif(check(z.F,z.S,v[i].F,v[i].S.real(),v[i].S.imag())){\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxs(ans,tmp);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\tif (rs[i][0]-1e-6<=w&&w<=rs[i][1]+1e-6)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=-c;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t+1;\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (norm(q-p)<r*r){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (norm(q-p)==r*r){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r1/(r1+r2)*p2+r2/(r1+r2)*p2;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2015/05/29\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P p;\n  double r;\n  C() {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\n// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\nint contain(C c, P p) {\n  if(abs(c.p - p) - c.r <  -eps) return 2;\n  if(abs(c.p - p) - c.r >  eps) return 0;\n  return 1;\n}\n\n// 轤ケ縺悟、夊ァ貞ス「縺ョ蜀?Κ/蠅?阜/螟夜Κ縺ョ縺ゥ縺薙↓縺ゅｋ縺九ｒ蛻、螳壹☆繧具シ?// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\n// by Spaghetti Source\nint contain(const vector<P> &g, const P &p) {\n  int n = g.size();\n  int in = 0;\n  for(int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() < eps && eps < b.imag() && cross(a, b) < -eps) in = !in;\n    if(abs(cross(a, b)) < eps && dot(a, b) < eps) return 1;\n  }\n  return in * 2;\n}\n\n// 邱壼?縺ィ邱壼?縺ョ莠、蟾ョ蛻、螳壹?\n// T蟄励ｄL蟄励∩縺溘＞縺ォ縺ェ縺」縺ヲ縺?ｋ譎ゅｂtrue繧定ソ斐☆縺後?\n// 縺薙ｌ繧帝勁螟悶＠縺溘＞蝣エ蜷医↓ <= 繧?< 縺ォ螟画峩縺励※繧ゅ≧縺セ縺上＞縺九↑縺??\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// 逶エ邱壹→蜀??莠、蟾ョ蛻、螳壹?謌サ繧雁?縺ッ莠、轤ケ縺ョ謨ー縲?int isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.p);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// 蜀?→蜀??莠、蟾ョ蛻、螳壹?\n//  0 : 莠、蟾ョ縲∝?蛹?↑縺?//  1 : 螟夜Κ縺ァ1轤ケ縺ィ謗・縺吶ｋ\n//  2 : 2轤ケ縺ァ莠、蟾ョ\n// -1 : 蜀?桁縺励※謗・縺吶ｋ\n// -2 : 螳悟?縺ォ蜀?桁\nint isIntersect(C a, C b) {\n  double x = a.p.real() - b.p.real();\n  double y = a.p.imag() - b.p.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// 逶エ邱壹→逶エ邱壹?莠、轤ケ縲?P getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross 縺ョ隨ヲ蜿キ髢「菫ゅ≠繧?  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// 逶エ邱壹→蜀??莠、轤ケ縲?vector<P> getCrossPLC(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.p);\n  double dist = getDistanceLP(s1, s2, c.p);\n  if (equals(dist, c.r)) {\n    v.push_back(p);\n  } else if (dist < c.r) {\n    double h = abs(p - c.p);\n    double d = sqrt(c.r * c.r - h * h);\n    P base = s2 - s1;\n    // push_back縺吶ｋ鬆?分縺ッ驥崎ヲ?    v.push_back(p - d * base / abs(base));\n    v.push_back(p + d * base / abs(base));\n  }\n  return v;\n}\n\n// 蜀?→蜀??莠、轤ケ縲?vector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.p - c2.p);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.p - c1.p;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.p + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.p + A*base + h*n);\n    v.push_back(c1.p + A*base - h*n);\n  }\n  return v;\n}\n\n// 2縺、縺ョ繝吶け繝医Ν縺ョ縺ェ縺呵ァ?0 <= rad <= PI)\n// AOJ2233縺ァ繝舌げ縺」縺溘?縺ァ譖エ譁ー(2015/05/29)\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\n// a -> b 縺ク縺ョ隗貞コヲ縺ョ遘サ蜍暮?(0 <= rad < 2*PI)\ndouble getAngleVector(P a, P b) {\n  double A = arg(a);\n  double B = arg(b);\n  double rad = B-A;\n  rad = fmod(rad, M_PI*2.0);\n  if(rad < 0.0) rad += M_PI*2.0;\n  return rad;\n}\n\n// 2縺、縺ョ逶エ邱壹↓謗・縺吶ｋ蜊雁セв縺ョ蜀?C getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = arg(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.p = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 繝倥Ο繝ウ縺ョ蜈ャ蠑上ｒ逕ィ縺?※荳芽ァ貞ス「縺ョ3霎コ縺ョ髟キ縺輔°繧蛾擇遨阪ｒ豎ゅａ繧?double heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// 螟夊ァ貞ス「縺ョ髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\ndouble getTriArea(P a, P b, P c) {\n  return cross(b-a, c-a) / 2.0;\n}\n\ndouble getSectorArea(P a, P b, C c) {\n  return getAngleVector(a-c.p, b-c.p) * c.r * c.r / 2.0;\n}\n\ndouble getBowArea(P a, P b, C c) { // a,b is a chord of c.\n  return getSectorArea(a, b, c) - getTriArea(a, b, c.p);\n}\n\ndouble getArea(P a, P b, C c) {\n  int d = 1;\n  if(cross(a,b) < 0.0) {\n    d = -1;\n    swap(a, b);\n  }\n  if(cross(a, b) < eps) return 0;\n\n  G t(3);\n  t[0] = P(0, 0), t[1] = a, t[2] = b;\n\n  if(contain(c, t[0]) && contain(c, t[1]) && contain(c, t[2])) {\n    return d * getTriArea(t[0], t[1], t[2]);\n  }\n\n  if(getDistanceSP(t[0], t[1], c.p) - c.r > -eps &&\n     getDistanceSP(t[1], t[2], c.p) - c.r > -eps &&\n     getDistanceSP(t[2], t[0], c.p) - c.r > -eps) {\n    if(cross(t[1] - t[0], c.p - t[0]) > -eps &&\n       cross(t[2] - t[1], c.p - t[1]) > -eps &&\n       cross(t[0] - t[2], c.p - t[2]) > -eps) {\n      return d * (c.r * c.r * M_PI);\n    } else {\n      return 0;\n    }\n  }\n\n  double S = c.r * c.r * M_PI;\n  vector<P> cp(6);\n  vector<int> exist(6);\n  for(int i = 0; i < 3; ++i) {\n    P p = t[i], q = t[(i+1)%3];\n    if(getDistanceLP(p, q, c.p) - c.r > -eps) {\n      if(cross(q - p, c.p - p) < 0) return 0;\n      continue;\n    }\n    if(getDistanceSP(p, q, c.p) - c.r > -eps) continue;\n    vector<P> v = getCrossPLC(t[i], t[(i+1)%3], c);\n    if(v.size() == 2 && !equals(v[0], v[1])) {\n      S -= getBowArea(v[0], v[1], c);\n      for(int j = 0; j < v.size(); ++j) {\n        int k = (i*2 + j*3) % 6;\n        cp[k] = v[j];\n        exist[k] = true;\n      }\n    }\n  }\n  for(int i = 0; i < 3; ++i) {\n    int a = i*2, b = i*2+1;\n    if(!exist[a] || !exist[b]) continue;\n    if(contain(c, t[i]) == 2 && !equals(cp[a], cp[b])) {\n      S += getBowArea(cp[a], cp[b], c) + getTriArea(t[i], cp[a], cp[b]);\n    }\n  }\n  return S * d;\n}\n\n// 螟夊ァ貞ス「縺ィ蜀??蜈ア騾夐Κ蛻??髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(G g, C c) {\n  int n = g.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += getArea(g[i], g[(i+1)%n], c);\n  }\n  return res;\n}\n\n// 荳芽ァ貞ス「縺ョ蜀?磁蜀??蜊雁セ?double getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// 繧ュ繝」繝ェ繝代?豕輔ｒ逕ィ縺?※螟夊ァ貞ス「縺ョ譛?ｂ驕?＞?帝?轤ケ縺ョ霍晞屬繧定ソ斐☆\n// O(NlogN)\n// by Ari book\ndouble caliper(const vector<P> &ps) {\n  vector<P> qs = convex_hull(ps);\n  int n = qs.size();\n  if(n == 2) {\n    return abs(qs[0] - qs[1]);\n  }\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k) {\n    if(!(qs[i] < qs[k])) i = k;\n    if(qs[j] < qs[k]) j = k;\n  }\n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(qs[i] - qs[j]));\n    if(cross((qs[(i+1)%n] - qs[i]), (qs[(j+1)%n] - qs[j])) < 0) {\n      i = (i+1)%n;\n    } else {\n      j = (j+1)%n;\n    }\n  }\n  return res;\n}\n\nvector<L> getTangent(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  if (a.p == b.p) return res;\n  P base = b.p - a.p;\n  for (double s = -1; s <= 1; ++++s) {\n    double c, d, ee;\n    ee = norm(base);\n    d = b.r + a.r * s;\n    if (ee - d * d < 0.0) continue;\n    c = sqrt(ee - d * d);\n    if (c < eps) {\n      P v = base * P(0, 1);\n      P m = b.p - base * b.r / abs(base);\n      res.push_back(L(m, m + v));\n    } else {\n      for (double t = -1; t <= 1; ++++t) {\n        P rotate(c / sqrt(ee), d / sqrt(ee) * t);\n        P v = -base * rotate * s;\n        P nv = v / abs(v) * P(0, t);\n        res.push_back(L(a.p + nv * a.r, b.p - nv * b.r * s));\n      }\n    }\n  }\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n\tvector<L> tmp;\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n\tdouble d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n\tif((equals(d, r[i]) || d > r[i]) &&\n\t   (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\n// 誤差を加味した符号判定\nint sign(double a){\n  if(a > EPS) return +1;\n  if(a < -EPS) return -1;\n  return 0;\n}\n\n// 誤差を加味した同一判定\nbool equal(double a, double b){ \n  return abs(b - a) < EPS;\n}\nbool operator==(const Point& a, const Point& b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n// 比較演算子\nnamespace std{\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n// 内積・外積\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\n// 点の回転\nPoint rotate(Point a, double b){\n  return a * polar(1.0, b);\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上(またはb == c)\n}\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\n// 注意: 端点で交わったり重なったりする場合も交差していると判定する(?)\n\n// 二直線の平行判定\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + 2.0 * (projection(l, p) - p);\n}\n\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return abs(p - projection(l, p));\n}\n\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return paralell(l, m) ? distanceLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return abs(r - p); // 垂線が線分に交わるとき\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n  if(sign(A) == 0) assert(false); // 直線が交わらない\n  return m[0] + m.vector() * B / A;\n}\nstruct Circle {\n  Point c;\n  double r;\n  Circle() {}\n  Circle(Point c, double r) : c(c), r(r) { }\n};\n\n// 円と点の交差判定(境界を含む)\nbool containCP(const Circle& C, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return sign(abs(C.c - p) - C.r) <= 0;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool intersectCC(const Circle& C, const Circle& D){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  double e = abs(C.c - D.c);\n  return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\nint N;\nPoint ps[100];\ndouble r[100][2];\nint count(Line l){\n  int res = 0;\n  REP(i, N){\n    double d = distanceLP(l, ps[i]);\n    if(sign(d - r[i][0]) >= 0 && sign(r[i][1] - d) >= 0){\n      res++;\n    }\n  }\n  return res;\n}\n// 円の接線\nLine circle_tangent(Circle& C, double th){\n  Point p0 = C.c + polar(C.r, th);\n  Point p1 = p0 + polar(1.0, th + M_PI / 2);\n  Line l(p0, p1);\n  assert(equal(distanceLP(l, C.c), C.r));\n  return Line(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\nvector<double> two_circles_tangents(Circle& C, Circle& D){\n  vector<double> res;\n  Point v = D.c - C.c;\n  double l = abs(v); // 二円の中心間の距離\n  double a = arg(v); // 二円の中心間の偏角\n  if(sign(l - abs(C.r - D.r)) > 0){\n    // 交わる or 外接 or 離れている\n    // 二つの外側接線\n    double a1 = acos((C.r - D.r) / l);\n    res.push_back(a + a1);\n    res.push_back(a - a1);\n    if(sign(l - (C.r + D.r)) > 0){\n      // 離れている\n      // 二つの内側接線\n      double a2 = acos((C.r + D.r) / l);\n      res.push_back(a + a2);\n      res.push_back(a - a2);\n    }\n  }\n  if((equal(abs(C.r - D.r), l) || equal(C.r + D.r, l)) && sign(l) != 0){\n    // 内接 or 外接\n    // 一つの接線\n    res.push_back(a);\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> N && N){\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag() >> r[i][0] >> r[i][1];\n    REP(i, N) r[i][1] += r[i][0];\n    int ans = 0;\n    REP(i, N) REP(j, N) REP(k, 2) REP(l, 2){\n      Circle C(ps[i], r[i][k]);\n      Circle D(ps[j], r[j][l]);\n      vector<double> args = two_circles_tangents(C, D);\n      args.push_back(0); // 適当な接線\n      FORIT(arg, args){\n        Line t_line = circle_tangent(C, *arg);\n        ans = max(ans, count(t_line));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Point = std::complex<ld>;\nconst ld pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\nbool isis_ls(Line l, Line s) {\n  return isis_ll(l, s) &&\n         (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\nbool isis_sp(Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nPoint proj(Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\nPoint is_ll(Line l, Line m) {\n  Point lv = l.b - l.a, mv = m.b - m.a;\n  assert(cross(lv, mv) != 0);\n  return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\nld dist_lp(Line l, Point p) { return abs(p - proj(l, p)); }\nld dist_ll(Line l, Line m) { return isis_ll(l, m) ? 0 : dist_lp(l, m.a); }\nld dist_ls(Line l, Line s) {\n  return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\nld dist_sp(Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\nld dist_ss(Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return std::min(\n      {dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\nLine bisector(Point a, Point b) {\n  Point mid = (a + b) * Point(0.5, 0);\n  return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\nld degree_ll(Line l, Line m) {\n  ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n  if (cos_shita < -1.0) cos_shita = -1.0;\n  if (cos_shita > 1.0) cos_shita = 1.0;\n  ld shita = acos(cos_shita);\n  return shita;\n}\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\nstd::vector<Point> is_cc(Circle c1, Circle c2) {\n  std::vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps)\n    dfr = 0.0;\n  else if (dfr < 0.0)\n    return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.emplace_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.emplace_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\nstd::vector<Point> is_lc(Circle c, Line l) {\n  std::vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.emplace_back(proj(l, c.p) + len * nor);\n    res.emplace_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nstd::vector<Point> is_sc(Circle c, Line l) {\n  std::vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.emplace_back(p);\n  return res;\n}\nstd::vector<Line> tangent_cp(Circle c, Point p) {\n  std::vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) {\n    return ret;\n  }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.emplace_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.emplace_back(Line(p, p + v2));\n  return ret;\n}\nstd::vector<Line> tangent_cc(Circle c1, Circle c2) {\n  std::vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    std::vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), nret.begin(), nret.end());\n  } else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.emplace_back(Line(q1, q1 + v));\n    ret.emplace_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\nvoid solve(int n) {\n  vector<Point> p(n);\n  vector<int> r(n), m(n);\n  for(int i=0;i<n;++i) {\n    p[i] = input_point();\n    cin >> r[i] >> m[i];\n  }\n  if(n == 1) {\n    cout << 1 << endl;\n    return;\n  }\n  vector<Circle> c1(n), c2(n);\n  for(int i=0;i<n;++i) {\n    c1[i] = Circle(p[i], r[i]);\n    c2[i] = Circle(p[i], r[i] + m[i]);\n  }\n  int ans = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      vector<vector<Line>> v;\n      v.emplace_back(tangent_cc(c1[i], c1[j]));\n      v.emplace_back(tangent_cc(c1[i], c2[j]));\n      v.emplace_back(tangent_cc(c2[i], c1[j]));\n      v.emplace_back(tangent_cc(c2[i], c2[j]));\n      for(int k=0;k<4;++k) {\n        for(int l=0;l<(int)(v[k].size());++l) {\n          int now = 0;\n          for(int q=0;q<n;++q) {\n            ld dist = dist_lp(v[k][l], p[q]);\n            if(r[q] - eps < dist && dist < r[q] + m[q] + eps) now++;\n          }\n          ans = max(ans, now);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,e,d;\n\t\t\tcin>>a>>b>>e>>d;\n\t\t\tc.pb(C(P(a,b),e));\n\t\t\tc.pb(C(P(a,b),e+d));\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L>l,tmp;\n\t\trep(i,c.size())loop(j,i+1,c.size()){\n\t\t\ttmp=tangentCC(c[i],c[j]);\n\t\t\trep(k,tmp.size())l.pb(tmp[k]);\n\t\t}\n\t\tint out=0;\n\t\trep(i,l.size()){\n\t\t\tL t=l[i];\n\t\t\tint co=0;\n\t\t\trep(j,c.size()){\n\t\t\t\tdouble d=distanceLP(t,c[j].c);\n\t\t\t\tif(d+EPS>c[j].r&&d<c[j+1].r+EPS)co++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tB comp(const P& l, const P& r) { return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\t//Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n\n\t//A dot B\n\tIL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n\tIL int sgn(P a, P b, P c) {\n\t\tif (cross(b - a, c - a) > EPS)return 1;\n\t\tif (cross(b - a, c - a) < -EPS)return -1;\n\t\tif (dot(b - a, c - a) < -EPS)return 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)return -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l) {\n\t\tDCl(a, b, l);\n\t\treturn cross(b - a, p - a) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) {\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) {\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS) return abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS) return abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\n\tIL B is_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn\n\t\t\tabs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls) {\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn cross(a - b, c - b) * cross(a - b, d - b) <EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t\t\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q) {\n\t\tif (is_LS_LS(p, q))return 0;\n\t\treturn min({\n\t\t\tdistance_P_LS(p.fi,q),\n\t\t\tdistance_P_LS(p.se,q),\n\t\t\tdistance_P_LS(q.fi,p),\n\t\t\tdistance_P_LS(q.se,p)\n\t\t});\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_point_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d <EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tD rs = sqrt(rp*rp - rc*rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn{ cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff };\n\t}\n\tIL D ccw(P a, P b, P c) {\n\t\treturn cross(b - a, c - a);\n\t}\n\tIL Poly convex_hull(Poly& p) {\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(ALL(p),comp);\n\t\tREP(i, n) {\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tREP(j, n - 1) {\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly& l, P& p) {\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1) {\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0) {\n\t\t\t\tif (A > -EPS&&C < -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (C < -EPS || A > -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n\t}\n\tIL D convex_area(Poly& l) {\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\tFOR(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tinline vector<L> tangent_line(C c, P p) {\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist > r + EPS) {\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\t{\n\t\t\t\tP e = P(_cos*v.X + _sin*v.Y, -_sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + EPS) {\n\t\t\tP mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist > Rp - Rq + EPS) {\n\t\t\tif (abs(Rp - Rq) < EPS) {\n\t\t\t\tP e = v*P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nIL int check(geo::L l, vector<geo::C>& cd, vector<geo::C>& cm) {\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble d = geo::distance_P_L(cd[i].first, l);\n\t\t//  cout << d << \" \";\n\t\tif (d<cm[i].second + geo::EPS&&d>cd[i].second - geo::EPS)\n\t\t\tres++;\n\t}\n\t//cout << endl;\n\treturn res;\n\n\n}\nint main() {\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::C> cd(N);\n\t\tvector<geo::C> cm(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tcd[i].first = geo::P(x, y);\n\t\t\tcm[i].first = geo::P(x, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d + m;\n\t\t}\n\t\tif (N == 1) {\n\t\t\tif (cm[0].second < geo::EPS)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();  cout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n\tint par = 0;\n\trep(i, 0, s.size()) {\n\t\tchar x = s[i];\n\t\tif (par == 0 && x == ',') {\n\t\t\tcerr << \" = \" << head << \", \";\n\t\t\tdump_impl(s.substr(i + 1), tail...);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (x == '(') par++;\n\t\t\tif (x == ')') par--;\n\t\t\tcerr << x;\n\t\t}\n\t}\n}\n#define dump(...) do { cerr << \"# \"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << endl; } while(0)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\n//#define double long double\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n// 点\n#define X real()\n#define Y imag()\nusing Point = complex<double>;\nbool operator==(const Point& p1, const Point& p2) { return equals(p1.X, p2.X) && equals(p1.Y, p2.Y); }\nbool cmpx(const Point& p1, const Point& p2) {\n\treturn p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y; // x昇順 -> y昇順\n}\nbool cmpy(const Point& p1, const Point& p2) {\n\treturn p1.Y != p2.Y ? p1.Y < p2.Y : p1.X < p2.X; // y昇順 -> x昇順\n}\nbool operator<(const Point& p1, const Point& p2) {\n\treturn cmpx(p1, p2); // 問題に応じて cmpy\n}\nbool operator>(const Point& p1, const Point& p2) { return p2 < p1; }\ninline istream& operator >> (istream& is, Point& p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\ninline ostream& operator << (ostream& os, const Point& p) { os << p.X << ' ' << p.Y; return os; }\n\n// ベクトル\nusing Vector = Point;\nVector rotate(Vector vec, double rad) { return Vector(vec.X * cos(rad) - vec.Y * sin(rad), vec.X * sin(rad) + vec.Y * cos(rad)); }\nVector unit(Vector vec) { return vec / abs(vec); }\n// 内積（dot product）\ndouble dot(Vector a, Vector b) { return a.X * b.X + a.Y * b.Y; }\n// 外積（cross product）の大きさ（正負あり）\ndouble cross(Vector a, Vector b) { return a.X * b.Y - a.Y * b.X; }\n\n// 直線\nstruct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\n\n// 線分\nstruct Segment :public Line {\n\tusing Line::Line;\n\tSegment() {}\n\tSegment(const Line& L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n// 円\nstruct Circle {\n\tPoint c; // center\n\tdouble r; // radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\n// 多角形\nusing Polygon = vector<Point>;\n\n// degree to radian\ndouble rad(double deg) { return PI * deg / 180; }\n// radian to degree\ndouble deg(double rad) { return rad / PI * 180; }\n\n// 2つのベクトルの角度\ndouble angle(Vector a, Vector b) {\n\tdouble lena = abs(a), lenb = abs(b);\n\tif (lena == 0 || lenb == 0)return 0; //解なし\n\tdouble costheta = dot(a, b) / (lena * lenb);\n\tif (equals(costheta, 1))costheta = 1; //誤差対策\n\treturn acos(costheta);\n}\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.X && p.X <= x2 && y1 <= p.Y && p.Y <= y2;\n}\n\n// 直交判定\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n// 平行判定（非交差判定）\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n// 射影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n// 反射\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\n// 線分(p0,p1)に対するp2の位置関係\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (norm(a) < norm(b))return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (norm(a) < norm(b))return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n// 線分と線分の交差判定\nbool intersect(Segment a, Segment b) {\n\tPoint p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n// (交差判定続く)\n\n// 2点間の距離\ndouble get_distance(Point a, Point b) { return abs(a - b); }\n\n// 直線と点の距離\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n\n// 線分と点の距離\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn get_distance(Line(s), p);\n}\n\n// 線分と線分の距離\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n// 円と直線の交差判定\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n\n// 円と円の交差判定 共通接線の数\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r + EPS)return 4;\n\tif (d > c1.r + c2.r - EPS)return 3;\n\tif (equals(d + c1.r, c2.r) || equals(d + c2.r, c1.r))return 1;\n\tif (d + c1.r - EPS < c2.r || d + c2.r - EPS < c1.r)return 0;\n\treturn 2;\n}\n\n// 線分と線分の交点\nPoint get_cross_point(Segment a, Segment b) {\n\tassert(intersect(a, b));\n\tVector base = b.p2 - b.p1;\n\tdouble area1 = abs(cross(base, a.p1 - b.p1));\n\tdouble area2 = abs(cross(base, a.p2 - b.p1));\n\tdouble t = area1 / (area1 + area2);\n\treturn a.p1 + (a.p2 - a.p1) * t;\n}\n\n// 円と直線の交点\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n// 円と円の交点\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r - c2.r * c2.r + d * d) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// 点の内包\nenum { OUT = 0, ON, IN };\nint contains(const Polygon& pl, Point p) {\n\tint n = pl.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = pl[i] - p, b = pl[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS)return ON;\n\t\tif (a.Y > b.Y)swap(a, b);\n\t\tif (a.Y < EPS && EPS<b.Y && cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& p) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t\ta += cross(p[i], p[(i + 1) % p.size()]);\n\treturn fabs(a / 2.0);\n}\n\n// 凸性判定（反時計回り）\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n// 凸包\n// Graham scan https://en.wikipedia.org/wiki/Graham_scan\n// 辺上の点を含めない\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end(), cmpx);\n\tPolygon up;\n\tfor (Point& p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point& p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //反時計回りに\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n// 凸包\n// Graham scan https://en.wikipedia.org/wiki/Graham_scan\n// 辺上の点を含む\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end(), cmpx);\n\tPolygon up;\n\tfor (Point& p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point& p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //反時計回りに\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n// 凸多角形の最遠頂点対間距離\n// calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end(), cmpx);\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I && j == J));\n\treturn maxd;\n}\n\n// 多角形を(0,0)を中心として回転\nPolygon rotate(const Polygon& P, double rad) {\n\tPolygon ret;\n\tfor (auto& p : P)\n\t\tret.emplace_back(p.X * cos(rad) - p.Y * sin(rad), p.X * sin(rad) + p.Y * cos(rad));\n\treturn ret;\n}\n\n// Heron's formula\ndouble area(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// 多角形の重心\nPoint center(const Polygon& P) {\n\tPoint ret;\n\tfor (auto& p : P)ret = ret + p;\n\tret = ret / (double)P.size();\n\treturn ret;\n}\n\n// ある点を通る円の接線\nvector<Line> tangentLines(Circle c, Point p) {\n\tVector v = c.c - p;\n\tdouble d = abs(v);\n\t// 点が内部にある\n\tif (d < c.r - EPS)\n\t\treturn {};\n\t// 点が円周にある\n\telse if (d < c.r + EPS) {\n\t\tPoint p2 = unit(rotate(v, PI / 2)) + p;\n\t\treturn { Line(p, p2) };\n\t}\n\t// 点が外部にある\n\telse {\n\t\tdouble alpha = asin(c.r / d);\n\t\tdouble e = sqrt(d * d - c.r * c.r);\n\t\tPoint t1 = p + unit(rotate(v, alpha)) * e,\n\t\t\tt2 = p + unit(rotate(v, -alpha)) * e;\n\t\treturn { Line(t1, p), Line(t2, p) };\n\t}\n}\n\n// 円と円の共通接線\nvector<Line> tangentLines(Circle c1, Circle c2) {\n\tint cnt = intersect(c1, c2);\n\tvector<Line> ret;\n\tif (cnt >= 3) {\n\t\tPoint m = (c2.r * c1.c + c1.r * c2.c) / (c1.r + c2.r);\n\t\tvector<Line> l = tangentLines(c1, m);\n\t\tret.insert(ret.end(), l.begin(), l.end());\n\t}\n\tif (cnt >= 1) {\n\t\tif (abs(c1.r - c2.r) < EPS) {\n\t\t\tVector v = unit(rotate(c1.c - c2.c, PI / 2));\n\t\t\tret.emplace_back(c1.c + v, c1.c - v);\n\t\t\tret.emplace_back(c2.c + v, c2.c - v);\n\t\t}\n\t\telse {\n\t\t\tPoint m = c1.c + (c1.c - c2.c) * c1.r / (c2.r - c1.r);\n\t\t\tvector<Line> l = tangentLines(c1, m);\n\t\t\tret.insert(ret.end(), l.begin(), l.end());\n\t\t}\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tfor (int N; cin >> N && N;) {\n\t\tvector<Circle> C(N);\n\t\tvector<double> r(N);\n\t\trep(i, 0, N) {\n\t\t\tdouble x, y; cin >> x >> y;\n\t\t\tC[i].c = Point(x, y);\n\t\t\tcin >> r[i];\n\t\t\tcin >> C[i].r; // m\n\t\t\tC[i].r += r[i];\n\t\t}\n\t\tvector<Circle> CC = C;\n\t\trep(i, 0, N)CC[i].r = r[i];\n\n\t\tvector<double> beta;\n\t\trep(i, 0, N)rep(j, i + 1, N) {\n\t\t\tauto lines = tangentLines(C[i], C[j]);\n\t\t\tfor (auto line : lines) {\n\t\t\t\tVector v = line.p2 - line.p1;\n\t\t\t\tdouble b = atan2(v.Y, v.X);\n\t\t\t\tif (b < 0)\n\t\t\t\t\tb += PI * 2;\n\t\t\t\tbeta.push_back(b);\n\t\t\t}\n\t\t\tlines = tangentLines(CC[i], CC[j]);\n\t\t\tfor (auto line : lines) {\n\t\t\t\tVector v = line.p2 - line.p1;\n\t\t\t\tdouble b = atan2(v.Y, v.X);\n\t\t\t\tif (b < 0)\n\t\t\t\t\tb += PI * 2;\n\t\t\t\tbeta.push_back(b);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<pair<double, double>>> v;\n\t\tvector<double> points;\n\n\t\tstatic const double PI = acos(-1);\n\n\t\tfor (auto b : beta) {\n\t\t\tif (equals(b, 0))continue;\n\t\t\tvector<pair<double, double>> t;\n\t\t\trep(i, 0, N) {\n\t\t\t\tdouble mm = abs(C[i].r / sin(b));\n\t\t\t\tdouble rr = abs(r[i] / sin(b));\n\t\t\t\tdouble x = C[i].c.X;\n\t\t\t\tif (!(equals(abs(b), PI / 2) || equals(abs(b), 3 * PI / 2)))\n\t\t\t\t\tx -= C[i].c.Y / tan(b);\n\t\t\t\tdouble l1, r1, l2, r2;\n\t\t\t\tl1 = x - mm;\n\t\t\t\tr1 = x - rr;\n\t\t\t\tl2 = x + rr;\n\t\t\t\tr2 = x + mm;\n\t\t\t\tt.emplace_back(l1, r1);\n\t\t\t\tt.emplace_back(l2, r2);\n\t\t\t\tpoints.push_back(l1);\n\t\t\t\tpoints.push_back(l2);\n\t\t\t\tpoints.push_back(r1);\n\t\t\t\tpoints.push_back(r2);\n\t\t\t}\n\t\t\tv.push_back(t);\n\t\t}\n\n\t\t// y intercept\n\t\tvector<pair<double, double>> t;\n\t\trep(i, 0, N) {\n\t\t\tdouble l1, r1, l2, r2;\n\t\t\tdouble y = C[i].c.Y;\n\t\t\tl1 = y - C[i].r;\n\t\t\tr1 = y - r[i];\n\t\t\tl2 = y + r[i];\n\t\t\tr2 = y + C[i].r;\n\t\t\tt.emplace_back(l1, r1);\n\t\t\tt.emplace_back(l2, r2);\n\t\t\tpoints.push_back(l1);\n\t\t\tpoints.push_back(l2);\n\t\t\tpoints.push_back(r1);\n\t\t\tpoints.push_back(r2);\n\t\t}\n\t\tv.push_back(t);\n\n\t\tint ans = 0;\n\t\tfor (auto t : v) {\n\n\t\t\tsort(t.begin(), t.end());\n\n\t\t\tpriority_queue<double, vector<double>, greater<double>> pq;\n\n\t\t\tfor (auto p : t) {\n\t\t\t\twhile (pq.size() && pq.top() + EPS < p.first)pq.pop();\n\t\t\t\tpq.emplace(p.second);\n\t\t\t\tans = max(ans, (int)pq.size());\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    double diff = a - b;\n    if(abs(diff) < EPS) return 0;\n    else if(diff < 0) return -1;\n    return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct circle/*{{{*/\n{\n  P o;\n  double r;\n  circle() {}\n  circle(const P& p, double x) : o(p), r(x) {}\n\n  // POJ 1375 Intervals\n  // 点 p を通る2つの接線\n  pair<P,P> tangent(const P& p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L*L - r*r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M*(v*polar(1.0, theta)), p + M*(v*polar(1.0, -theta)));\n  }\n\n  pair<line,line> outer_tangent_parallel(const circle &c) const {\n      const P d = o - c.o;\n      const P v = d * P(0, 1) * r / abs(d);\n      return make_pair(line(o+v, c.o+v), line(o-v, c.o-v));\n  }\n\n  pair<line,line> outer_tangent(const circle &c) const {\n      if(cmp(r, c.r) == 0) return outer_tangent_parallel(c);\n      if(r > c.r) return c.outer_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 - c.r/r;\n      const P base = c.o + d+d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair<line,line> inner_tangent(const circle &c) const {\n      if(r > c.r) return c.inner_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 + c.r/r;\n      const P base = c.o + d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // POJ 1418 Viva Confetti\n  // POJ 2149 Inherit the Spheres\n  inline bool intersects(const circle& c) const\n  {\n    return !contains(c) && !c.contains(*this) && cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  inline bool independent(const circle &c) const {\n      return cmp(abs(o-c.o), r+c.r) > 0;\n  }\n\n  pair<P,P> intersection(const circle& c) const\n  {\n    // assert(intersects(c))\n    const double d = abs(o - c.o);\n    const double cos_ = (d*d + r*r - c.r*c.r) / (2*d);\n    const double sin_ = sqrt(r*r - cos_*cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e*P(cos_, sin_), o + e*P(cos_, -sin_));\n  }\n\n  inline bool contains(const circle& c) const\n  {\n    return cmp(abs(o - c.o)+c.r, r) < 0;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return cmp(abs(ln.distance(o)), r) <= 0;\n  }\n\n  inline double distance(const line &ln) const {\n      return abs(ln.distance(o));\n  }\n\n  pair<P,P> intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r*r - d*d);\n    return make_pair(h + l*ab, h - l*ab);\n  }\n};/*}}}*/\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n    if(c1.independent(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inner = c1.inner_tangent(c2);\n        lines.push_back(inner.first);\n        lines.push_back(inner.second);\n    } else if(c1.intersects(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inter = c1.intersection(c2);\n        lines.push_back(line(inter.first, inter.second));\n    } \n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<circle,circle>> jewels;\n    vector<line> lines;\n    for(int i = 0; i < N; ++i) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        const P center(x, y);\n        pair<circle,circle> jewel = make_pair(circle(center, r), circle(center, r+m));\n        for(const auto &other : jewels) {\n            enum_event(jewel.first, other.first, lines);\n            enum_event(jewel.first, other.second, lines);\n            enum_event(jewel.second, other.first, lines);\n            enum_event(jewel.second, other.second, lines);\n        }\n        jewels.push_back(jewel);\n    }\n\n    int ans = 1;\n    for(auto &l : lines) {\n        int cnt = count_if(jewels.begin(), jewels.end(), [&](const pair<circle,circle> &j){\n                return cmp(j.first.r, j.first.distance(l)) <= 0 && \n                cmp(j.second.r, j.second.distance(l)) >= 0;\n                });\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n#define EPS (1e-5)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y) :x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n\n    bool operator < (const Point &p) const{\n        return x!=p.x?x<p.x:y<p.y;\n        //grid-point only\n        //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n    }\n};\n\nstruct EndPoint{\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n    bool operator<(const EndPoint &ep)const{\n        if(p.y==ep.p.y) return st<ep.st;\n        return p.y<ep.p.y;\n    }\n};\n\nistream &operator >> (istream &is,Point &p){\n    is>>p.x>>p.y;\n    return is;\n}\n\nostream &operator << (ostream &os,Point p){\n    os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n    return os;\n}\n\nbool sort_x(Point a,Point b){\n    return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n    return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n    for(int i=0;i<(int)p.size();i++) is>>p[i];\n    return is;\n}\n\nstruct Segment{\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n    is>>s.p1>>s.p2;\n    return is;\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n    is>>c.c>>c.r;\n    return is;\n}\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n    return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1-p0;\n    Vector b = p2-p0;\n    if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n    if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n    if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n    int n=p.size();\n    for(int i=0;i<n;i++)\n        if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n    return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    double d=abs(c1.c-c2.c);\n    double r=c1.r+c2.r;\n    if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n    if(d>r) return ICC_SEPERATE;\n    if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n    if(d+c2.r<c1.r) return ICC_CONTAIN;\n    return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n    return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n    if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n    double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n    if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n    Point h=project(s,c.c);\n    if(dot(s.p1-h,s.p2-h)<0) return 2;\n    return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(intersectSS(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    for(int k=0;k<2;k++){\n        if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n        if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n        swap(s1,s2);\n    }\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n    double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n    double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n    if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n    return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n    Polygon ps;\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    if(equals(getDistanceLP(l,c.c),c.r)){\n        ps.emplace_back(pr);\n        return ps;\n    }\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    ps.emplace_back(pr+e*base);\n    ps.emplace_back(pr-e*base);\n    return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n    Line l(s);\n    Polygon res=getCrossPointCL(c,l);\n    if(intersectCS(c,s)==2) return res;\n    if(res.size()>1u){\n        if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n        res.pop_back();\n    }\n    return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n    Polygon p(2);\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    p[0]=c1.c+polar(c1.r,t+a);\n    p[1]=c1.c+polar(c1.r,t-a);\n    return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size()<3) return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2;i<(int)s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n    return l;\n}\n\nPolygon convex_hull(Polygon ps){\n    int n=ps.size();\n    sort(ps.begin(),ps.end(),sort_y);\n    int k=0;\n    Polygon qs(n*2);\n    for(int i=0;i<n;i++){\n        while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n        while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\ndouble diameter(Polygon s){\n    Polygon p=s;\n    int n=p.size();\n    if(n==2) return abs(p[0]-p[1]);\n    int i=0,j=0;\n    for(int k=0;k<n;k++){\n        if(p[i]<p[k]) i=k;\n        if(!(p[j]<p[k])) j=k;\n    }\n    double res=0;\n    int si=i,sj=j;\n    while(i!=sj||j!=si){\n        res=max(res,abs(p[i]-p[j]));\n        if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n            i=(i+1)%n;\n        }else{\n            j=(j+1)%n;\n        }\n    }\n    return res;\n}\n\nbool isConvex(Polygon p){\n    bool f=1;\n    int n=p.size();\n    for(int i=0;i<n;i++){\n        int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n        f&=t!=CCW_CLOCKWISE;\n    }\n    return f;\n}\n\ndouble area(Polygon s){\n    double res=0;\n    for(int i=0;i<(int)s.size();i++){\n        res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n    }\n    return res;\n}\n\ndouble area(Circle c1,Circle c2){\n    double d=abs(c1.c-c2.c);\n    if(c1.r+c2.r<=d+EPS) return 0;\n    if(d<=abs(c1.r-c2.r)){\n        double r=min(c1.r,c2.r);\n        return PI*r*r;\n    }\n    double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n    double th=acos(rc/c1.r);\n    double ph=acos((d-rc)/c2.r);\n    return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n    Polygon q;\n    for(int i=0;i<(int)p.size();i++){\n        Point a=p[i],b=p[(i+1)%p.size()];\n        if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n        if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n            q.push_back(getCrossPointLL(Line(a,b),l));\n    }\n    return q;\n}\n\nLine bisector(Point p1,Point p2){\n    Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n    Polygon p=getCrossPointCC(c1,c2);\n    if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n    return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n    Vector res;\n    res.x=cos(theta)*v.x-sin(theta)*v.y;\n    res.y=sin(theta)*v.x+cos(theta)*v.y;\n    return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n    vector<Line> res;\n    if(isParallel(l1,l2)){\n        double d=getDistanceLP(l1,l2.p1)/2.0;\n        Vector v1=l1.p2-l1.p1;\n        v1=v1/v1.abs()*d;\n        Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n        double d1=getDistanceLP(l1,p);\n        double d2=getDistanceLP(l2,p);\n        if(abs(d1-d2)>d){\n            p=l2.p1+translate(v1,-90.0*(PI/180.0));\n        }\n        res.push_back(Line(p,p+v1));\n    }else{\n        Point p=getCrossPointLL(l1,l2);\n        Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n        v1=v1/v1.abs();\n        v2=v2/v2.abs();\n        res.push_back(Line(p,p+(v1+v2)));\n        res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n    }\n    return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n    Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n    Polygon p=getCrossPointCC(c1,c2);\n    sort(p.begin(),p.end());\n    return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n    vector<Line> ls;\n    if(c1.r<c2.r) swap(c1,c2);\n    double g=norm(c1.c-c2.c);\n    if(equals(g,0)) return ls;\n    Point u=(c2.c-c1.c)/sqrt(g);\n    Point v=orth(u);\n    for(int s=1;s>=-1;s-=2){\n        double h=(c1.r+s*c2.r)/sqrt(g);\n        if(equals(1-h*h,0)){\n            ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n        }else if(1-h*h>0){\n            Point uu=u*h,vv=v*sqrt(1-h*h);\n            ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n            ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n        }\n    }\n\n    return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n    if(r<0){\n        r=a.size();\n        sort(a.begin(),a.end(),sort_x);\n    }\n    if(r-l<=1) return abs(a[0]-a[1]);\n    int m=(l+r)>>1;\n    double x=a[m].x;\n    double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n    Polygon b;\n    for(int i=l;i<r;i++){\n        if(fabs(a[i].x-x)>=d) continue;\n        for(int j=0;j<(int)b.size();j++){\n            double dy=a[i].y-next(b.rbegin(),j)->y;\n            if(dy>=d) break;\n            d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n        }\n        b.emplace_back(a[i]);\n    }\n    return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n    int n=ss.size();\n    for(int i=0;i<n;i++){\n        ps.emplace_back(ss[i].p1);\n        ps.emplace_back(ss[i].p2);\n        for(int j=i+1;j<n;j++)\n            if(intersectSS(ss[i],ss[j]))\n                ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n    }\n    sort(ps.begin(),ps.end());\n    ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n    vector<vector<int> > G(ps.size());\n    for(int i=0;i<n;i++){\n        vector<pair<double,int> > ls;\n        for(int j=0;j<(int)ps.size();j++)\n            if(getDistanceSP(ss[i],ps[j])<EPS)\n                ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n        sort(ls.begin(),ls.end());\n        for(int j=0;j+1<(int)ls.size();j++){\n            int a=ls[j].second,b=ls[j+1].second;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n    }\n    for(auto &v:G){\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\nconst int BTM = 0;\nconst int LFT = 1;\nconst int RGH = 2;\nconst int TOP = 3;\n\nint n=ss.size();\nvector<EndPoint> ep;\nfor(int i=0;i<n;i++){\nif(ss[i].p1.y==ss[i].p2.y){\nif(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\nep.emplace_back(ss[i].p1,i,LFT);\nep.emplace_back(ss[i].p2,i,RGH);\n}else{\nif(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\nep.emplace_back(ss[i].p1,i,BTM);\nep.emplace_back(ss[i].p2,i,TOP);\n}\n}\nsort(ep.begin(),ep.end());\n\nset<int> bt;\nbt.insert(INF);\n\nint cnt=0;\nfor(int i=0;i<n*2;i++){\nif(ep[i].st==TOP){\nbt.erase(ep[i].p.x);\n}else if(ep[i].st==BTM){\nbt.emplace(ep[i].p.x);\n}else if(ep[i].st==LFT){\nauto b=bt.lower_bound(ss[ep[i].seg].p1.x);\nauto e=bt.upper_bound(ss[ep[i].seg].p2.x);\ncnt+=distance(b,e);\n}\n}\n\nreturn cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n    if(ps.size()<3u) return 0;\n    function<double(Circle, Point, Point)> dfs=\n            [&](Circle c,Point a,Point b){\n                Vector va=c.c-a,vb=c.c-b;\n                double f=cross(va,vb),res=0;\n                if(equals(f,0.0)) return res;\n                if(max(abs(va),abs(vb))<c.r+EPS) return f;\n                Vector d(dot(va,vb),cross(va,vb));\n                if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n                    return c.r*c.r*atan2(d.y,d.x);\n                auto u=getCrossPointCS(c,Segment(a,b));\n                if(u.empty()) return res;\n                if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n                u.emplace(u.begin(),a);\n                u.emplace_back(b);\n                for(int i=1;i<(int)u.size();i++)\n                    res+=dfs(c,u[i-1],u[i]);\n                return res;\n            };\n    double res=0;\n    for(int i=0;i<(int)ps.size();i++)\n        res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n    return res/2;\n}\n\nvector<Line> tangentCL(Circle c, Line l) {\n    Vector v = l.p1-l.p2;\n    Point p1 = c.c+v, p2 = c.c-v;\n    Line l2 = bisector(p1, p2);\n    auto pts = getCrossPointCL(c, l2);\n    vector<Line> res({Line(pts[0], pts[0]+v), Line(pts[1], pts[1]+v)});\n    return res;\n}\n\nint main(void) {\n    int64 N;\n    while (cin >> N && N) {\n        vector<Circle> cs(N);\n        vector<Circle> ccs(2*N);\n        vector<double> ms(N);\n        REP(i, N) {\n            cin >> cs[i].c.x >> cs[i].c.y >> cs[i].r >> ms[i];\n            ccs[2*i] = cs[i];\n            ccs[2*i+1] = cs[i]; ccs[2*i+1].r += ms[i];\n        }\n        if (N == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n        int64 res = 0;\n        REP(i, ccs.size()) {\n            REP(j, ccs.size()) {\n\n                if (i == j) continue;\n                auto ls = tangent(ccs[i], ccs[j]);\n                for (auto &l : ls) {\n                    int64 sum = 0;\n\n                    REP(k, N) {\n                        if (getDistanceLP(l, cs[k].c) + EPS <= cs[k].r) continue;\n                        if (getDistanceLP(l, cs[k].c) - EPS <= cs[k].r + ms[k]) sum++;\n                    }\n                    chmax(res, sum);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\nbool intersect_CL(const Circle& c, const Line& line)\n{\n    return dist_LP(line, c.p) < c.r + 1e-9;\n}\nbool intersect_LC(const Line& line, const Circle& c)\n{\n    return intersect_CL(c, line);\n}\n\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    double d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    double t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.pb(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 外接線\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 内接線\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.pb(ext[i]);\n    rep(i, in.size())\n        res.pb(in[i]);\n    return res;\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\nconst double eps = 1e-8;\nint n;\nCircle jewel[55];\nint m[55];\nint gao(const Line& line)\n{\n    int res = 0;\n    rep(i, n)\n        if (dist_CL(jewel[i], line) > -eps && dist_CL(jewel[i], line) < m[i])\n            ++res;\n    return res;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> jewel[i].p >> jewel[i].r >> m[i];\n\n        vector<Circle> c;\n        rep(i, n)\n        {\n            c.pb(jewel[i]);\n            c.back().r += eps;\n            c.pb(jewel[i]);\n            c.back().r += m[i];\n        }\n\n        vector<Line> cand;\n        rep(i, c.size()) rep(j, i)\n        {\n            vector<Line> t = tangent_CC(c[i], c[j]);\n            // cout << jewel[i] << \", \" << jewel[j] << endl;\n            // cout << t << endl;\n            // cout << endl;\n            cand.insert(cand.end(), all(t));\n        }\n        // rep(i, cand.size())\n        //     cout << cand[i] << endl;\n        // cand.clear();\n        // cand.pb(Line(Point(-100, 2), Point(100, 2)));\n        int res = 1;\n        rep(i, cand.size())\n            chmax(res, gao(cand[i]));\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<cstdio>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\nP unit(P p){return p / abs(p);}  \npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\ndouble dot(P x,P y){return real(conj(x)*y);}\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nP rotate(P v,double s){\n  return P(real(v)*cos(s)+imag(v)*sin(s),imag(v)*cos(s)-real(v)*sin(s));\n}\n\n//for triangle\n\n//return seta A\ndouble arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool orth(L a,L b){return abs(dot(a.fs-a.sc,b.fs-b.sc))<EPS;}\nbool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ndouble line_dis(L a,P x){return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);}\n\nP line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\ndouble seg_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d * abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n//for circle\nbool in_cir(C c,P x){return (abs(x-c.fs) +EPS < c.sc);}\nbool on_cir(C c,P x){return EQ(abs(x-c.fs),c.sc);}\n\nvector<L> adj_line(C c,P p){\n  vector<L> res;\n  if(in_cir(c,p))return res;\n  if(on_cir(c,p)){\n    pair<P,P> n = norm(c.fs-p);\n    res.pb(L(n.fs+p,p));\n    return res;\n  }\n  double x,y,z;\n  x = c.sc;\n  z = abs(c.fs-p);\n  y = sqrt(z*z-x*x);\n  double s = arg(y,x,z);\n  P v = unit(p-c.fs)*c.sc;\n\n  res.pb(L(rotate(v,s)+c.fs,p));\n  res.pb(L(rotate(v,-s)+c.fs,p));\n  return res;\n}\n\nvector<L> common_adj_line(C a,C b){\n  vector<L> res;\n  if(a.sc+EPS<b.sc)return common_adj_line(b,a);\n  if(EQ(real(a.fs),real(b.fs)) && EQ(imag(a.fs),imag(b.fs)) && EQ(a.sc,b.sc))return res;\n\n  P pos = ((b.fs-a.fs)*a.sc/(a.sc+b.sc))+a.fs;\n  if(!in_cir(a,pos))res = adj_line(a,pos);\n\n  if(EQ(a.sc,b.sc)){\n    pair<P,P> n = norm(unit(b.fs-a.fs)*a.sc);\n    res.pb(L(a.fs+n.fs,b.fs+n.fs));\n    res.pb(L(a.fs+n.sc,b.fs+n.sc)); \n  }else{\n    double c = abs(b.fs-a.fs);\n    pos = (unit(b.fs-a.fs)*( (a.sc*c)/(a.sc-b.sc) ))+a.fs;\n    if(!in_cir(a,pos)){\n      vector<L> tmp = adj_line(a,pos);\n      FOR(i,0,tmp.sz)res.pb(tmp[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  double x[50],y[50],r[50],m[50];\n  C c[50];\n\n  while(scanf(\"%d\",&n) && n){\n    FOR(i,0,n){\n      scanf(\"%lf %lf %lf %lf\",&x[i],&y[i],&r[i],&m[i]);\n      c[i] = C(P(x[i],y[i]),r[i]);\n    }\n\n    if(n==1){\n      printf(\"1\\n\");\n      continue;\n    }\n    int ans = 0;\n\n    FOR(i,0,n){\n      FOR(j,i+1,n){\n\tvector<L> x,l = common_adj_line(c[i],c[j]);\n\tc[i].sc += m[i];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[j].sc += m[j];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[i].sc -= m[i];\n\tx = common_adj_line(c[i],c[j]);\n\tFOR(k,0,x.sz)l.pb(x[k]);\n\tc[j].sc -= m[j];\n\n\tFOR(k,0,l.sz){\n\t  int tmp = 0;\n\t  FOR(h,0,n){\n\t    double dis = line_dis(l[k],c[h].fs);\n\t    if(c[h].sc < dis+EPS && dis < c[h].sc+m[h]+EPS)tmp++;\n\t  }\n\t  ans = max(ans,tmp);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = 1 / tan(j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (-x[i]-r[i]*cos(j)) / tan(j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*1000)/1000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\nline tangent(const circle &c, const double &th) {\n    point h = c.o+polar(c.r,th);\n    point p = polar(c.r,th)*point(0,1);\n    return line(h-p,h+p);\n}\n\nvector<line> common_tangent(const circle &c, const circle &d) {\n    vector<line> res;\n    long double dist = abs(d.o - c.o), th = arg(d.o - c.o);\n    if (abs(c.r - d.r) < dist) { // outer\n        long double dth = acosl((c.r - d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    if (abs(c.r + d.r) < dist) {\n        long double dth = acos((c.r + d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    return res;\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    vector<long double> m(n);\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r >> m[i];\n        cs.push_back(circle(point(x,y),r));\n    }\n\n    vector<line> ls;\n    rep(i,0,n) rep(j,i+1,n){\n        auto tmp=common_tangent(cs[i],cs[j]);\n        ls.insert(ls.end(),tmp.begin(),tmp.end());\n    }\n\n    int ans=1;\n    for(auto &l:ls){\n        int cnt=0;\n        rep(i,0,n){\n            auto &c=cs[i];\n            long double d=distanceLP(l,c.o)-c.r;\n            if(-eps<d and d<=m[i]) ++cnt;\n        }\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint calc(L l){\n  int sum = 0;\n  for(int k=0;k<n;k++){\n    if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n      sum++;\n    }\n  }\n  return sum;\n}\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n      }\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n      \n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n    }\n  }\n  \n  //pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  \n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      ans = max(ans, calc(L(pv[i], pv[j])));\n    }\n  }  \n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-9;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\t//cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\t//cout << \"ok\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t//cout << \"ng\" << endl;\n\t\t}\n\t}\n\t\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r+eps){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=(r2*p1+r1*p2)/(r1+r2);\n\t//cout << \"aaa \" << endl;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=(r2*p1-r1*p2)/(r2-r1);\n\t\t//cout << \"bbb \" << endl;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn make_pair(h - w, h + w);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble x[60];\ndouble y[60];\ndouble r[60];\ndouble m[60];\nvector<pair<Pt,Pt> > p;\nvoid add(Pt a,double ar,Pt b,double br){\n\tPt p1=(a*br+b*ar)/(ar+br);\n\tpair<Pt,Pt> q1=tCP(a,ar,p1);\n\tp.push_back(make_pair(p1,q1.first));\n\tp.push_back(make_pair(p1,q1.second));\n\tif(sig(ar-br)){\n\t\tPt p2=(b*ar-a*br)/(ar-br);\n\t\tpair<Pt,Pt> q2=tCP(a,ar,p2);\n\t\tp.push_back(make_pair(p2,q2.first));\n\t\tp.push_back(make_pair(p2,q2.second));\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",x+i,y+i,r+i,m+i);\n\t\t}\n\t\tif(a==1){\n\t\t\tprintf(\"1\\n\");continue;\n\t\t}\n\t\tp.clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tadd(Pt(x[i],y[i]),r[i],Pt(x[j],y[j]),r[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i]+m[i],Pt(x[j],y[j]),r[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i],Pt(x[j],y[j]),r[j]+m[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i]+m[i],Pt(x[j],y[j]),r[j]+m[j]);\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble d=dLP(p[i].first,p[i].second,Pt(x[j],y[j]));\n\t\t\t\tif(d+EPS>r[j]&&d-EPS<r[j]+m[j])val++;\n\t\t\t}\n\t\t\tret=max(ret,val);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\n//typedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\n\nint n;\nvector<pair<pt,pt> >L;\nvoid add(pt c1,double r1,pt c2,double r2){\n\t//tangent line\n\tc2-=c1; // later add c1\n\t//(0,0) and c2\n\tdouble IN = norm(c2)-(r1+r2)*(r1+r2);\n\tif(IN >= 0){\n\t\tdouble c3_x_1 = r1 / norm(c2) * (c2.x * (r1+r2) + c2.y * sqrt(norm(c2)-(r1+r2)*(r1+r2)) );\n\t\tdouble c3_y_1 = r1 / norm(c2) * (c2.y * (r1+r2) - c2.x * sqrt(norm(c2)-(r1+r2)*(r1+r2)) );\n\t\tdouble c3_x_2 = r1 / norm(c2) * (c2.x * (r1+r2) - c2.y * sqrt(norm(c2)-(r1+r2)*(r1+r2)) );\n\t\tdouble c3_y_2 = r1 / norm(c2) * (c2.y * (r1+r2) + c2.x * sqrt(norm(c2)-(r1+r2)*(r1+r2)) );\n\t\tpt T2 = pt(c3_x_1,c3_y_1); T2 *= pt(0.0,1.0); L.pb(mp(pt(c3_x_1,c3_y_1)+c1,pt(c3_x_1,c3_y_1)+c1+T2));\n\t\tT2 = pt(c3_x_2,c3_y_2); T2 *= pt(0.0,1.0); L.pb(mp(pt(c3_x_2,c3_y_2)+c1,pt(c3_x_2,c3_y_2)+c1+T2));\n\t}\n\tIN = norm(c2)-(r1-r2)*(r1-r2);\n\tif(IN >= 0){\n\t\tdouble c3_x_1 = r1 / norm(c2) * (c2.x * (r1-r2) + c2.y * sqrt(norm(c2)-(r1-r2)*(r1-r2)) );\n\t\tdouble c3_y_1 = r1 / norm(c2) * (c2.y * (r1-r2) - c2.x * sqrt(norm(c2)-(r1-r2)*(r1-r2)) );\n\t\tdouble c3_x_2 = r1 / norm(c2) * (c2.x * (r1-r2) - c2.y * sqrt(norm(c2)-(r1-r2)*(r1-r2)) );\n\t\tdouble c3_y_2 = r1 / norm(c2) * (c2.y * (r1-r2) + c2.x * sqrt(norm(c2)-(r1-r2)*(r1-r2)) );\n\t\tpt T2 = pt(c3_x_1,c3_y_1); T2 *= pt(0.0,1.0); L.pb(mp(pt(c3_x_1,c3_y_1)+c1,pt(c3_x_1,c3_y_1)+c1+T2));\n\t\tT2 = pt(c3_x_2,c3_y_2); T2 *= pt(0.0,1.0); L.pb(mp(pt(c3_x_2,c3_y_2)+c1,pt(c3_x_2,c3_y_2)+c1+T2));\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcin >> n ; if(!n) return 0; L.clear();\n\t\tvector<pt>A; double r[55],m[55];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble xx,yy; scanf(\"%lf%lf%lf%lf\",&xx,&yy,&r[i],&m[i]);\n\t\t\tA.pb(pt(xx,yy));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tadd(A[i],r[i],A[j],r[j]);\n\t\t\t\tadd(A[i],r[i]+m[i],A[j],r[j]);\n\t\t\t\tadd(A[i],r[i],A[j],r[j]+m[j]);\n\t\t\t\tadd(A[i],r[i]+m[i],A[j],r[j]+m[j]);\n\t\t\t}\n\t\t}\n\t\tint ret = 1;\n\t\tfor(int i=0;i<L.size();i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdouble X = abs(L[i].fi-L[i].sc),Y = abs(L[i].fi-A[j]),Z = abs(L[i].sc-A[j]);\n\t\t\t\tdouble s = (X+Y+Z) / 2.0;\n\t\t\t\tdouble area = sqrt(s * (s - X) * (s - Y) * (s - Z));\n\t\t\t\tdouble h = area / X * 2.0;\n\t\t\t\tif(r[j]-eps <= h && h <= r[j]+m[j]+eps) sum++;\n\t\t\t}\n\t\t\tret = max(ret,sum);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<Circle>Dias(2*N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, r, m; cin >> x >> y >> r >> m;\n\t\t\tDias[i]=Circle(Point(x, y), r);\n\t\t\tDias[N+i] = Circle(Point(x, y), r+m);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tfor (int j = i+1; j < 2*N; j++)\n\t\t\t{\n\t\t\t\tvector<Line>lines(tangent_cc(Dias[i], Dias[j]));\n\t\t\t\tfor (const auto& l : lines) {\n\t\t\t\t\tvector<int>oks(N);\n\t\t\t\t\tfor (int i = N; i < 2 * N; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(l, Dias[i].p) - eps < Dias[i].r)oks[i - N] = true;\n\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tif (dist_lp(l, Dias[i].p)+eps< Dias[i].r)oks[i] = false;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, accumulate(oks.begin(), oks.end(), 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = 3.1415926535;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  C() {}\n};\n\nP rotate(P p, double ang) {\n  return P(real(p)*cos(ang)-imag(p)*sin(ang),\n           real(p)*sin(ang)+imag(p)*cos(ang));\n}\nL rotate(L l, double ang) {\n  return L(rotate(l[0], ang),rotate(l[1], ang));\n}\n\nvector<L> tanPairCircles(C c1, C c2) {\n  vector<L> res;\n  P d = c2.p-c1.p;\n  P hoge = c1.r/(c1.r+c2.r)*d; // p1->ツ静堋静シツづ個古ーツ点\n  P p = c1.p+hoge; // ツ静堋静シツづ個古ーツ点\n  double ang = asin(c1.r/abs(hoge));\n  res.push_back(L(p,p+rotate(-hoge, ang)));\n  res.push_back(L(p,p+rotate(-hoge, -ang)));\n\n  if (c1.r == c2.r) {\n    P p1 = c1.p + rotate(d*c1.r/abs(d), PI/2);\n    P p2 = c1.p + rotate(d*c1.r/abs(d), -PI/2);\n    res.push_back(L(p1,p1+d));\n    res.push_back(L(p2,p2+d));\n  } else {\n    if (c1.r<c2.r) swap(c1,c2);\n    hoge = c1.r/(c1.r-c2.r)*d; // p1->ツ静堋静シツづ個古ーツ点\n    p = c1.p+hoge; // ツ静堋静シツづ個古ーツ点\n    ang = asin(c1.r/abs(hoge));\n    res.push_back(L(p,p+rotate(-hoge, ang)));\n    res.push_back(L(p,p+rotate(-hoge, -ang)));\n  }\n  return res;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    if (n==1) {\n      cout << 1 << endl;\n      continue;\n    }\n    C c[2*n];\n    double d[n];\n\n    REP(i,n) {\n      double x,y,r;\n      cin >> x>>y>>r>>d[i];\n      c[i] = C(P(x,y),r);\n    }\n    REP(i,n) {\n      c[n+i] = C(c[i].p, c[i].r+d[i]);\n    }\n    int ans = 0;\n    REP(i,2*n-1) {\n      for (int j=i+1;j<2*n;++j) {\n        vector<L> v = tanPairCircles(c[i],c[j]);\n        FOR(it, v) {\n          L l = *it;\n          int tmp = 0;\n          REP(k,n) {\n            if (distanceLP(l, c[k].p) < d[k]+c[k].r+EPS && distanceLP(l, c[k].p) > c[k].r - EPS)\n              tmp++;\n          }\n          ans = max(ans, tmp);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\ntypedef double D;\n\nconst D pi=3.14159265358979;\n\n\nstruct P{\n\tD x,y,n,n2;\n\tP(){}\n\tP(D ix,D iy){\n\t\tx=ix; y=iy;\n\t\tn2=x*x+y*y;\n\t\tn=sqrt(n2);\n\t}\n\tP to(P a){\n\t\treturn (a-(*this));\n\t}\n\tP operator+(P a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator-(P a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP scalar(D a){\n\t\treturn P(x*a,y*a);\n\t}\n\tD dot(P a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tD cross(P a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tD theta(P a){\n\t\tD s = (cross(a)/(n*a.n))>0.0?1:-1;\n\t\treturn acos(max(-1.0,min(1.0,dot(a)/(n*a.n))))*s;\n\t}\n\tstatic P polar(D r,D t){\n\t\treturn P(r*cos(t),r*sin(t));\n\t}\n\tP turn(D t){\n\t\treturn P(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tP tolen(D a){\n\t\treturn this->scalar(a/n);\n\t}\n\tbool  operator<(P a) const{\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(P a)const{ return (a<(*this)); }\t\n};\n\nstruct L{\n\tP p,q,v;\n\tL(){}\n\tL(P ip,P iq){\n\t\tp=ip; q=iq;\n\t\tv=p.to(q);\n\t}\n\tbool iscross(L a){\n\t\tD da,db;\n\t\tda=v.cross(p.to(a.p));\n\t\tdb=v.cross(p.to(a.q));\n\t\tif(da*db>=0)return false;\n\t\tda=a.v.cross(a.p.to(p));\n\t\tdb=a.v.cross(a.p.to(q));\n\t\treturn (da*db<0);\n\t}\n\n\tD dist(P a){\n\t\tif(p.to(a).dot(p.to(q))<0)return p.to(a).n;\n\t\tif(q.to(a).dot(q.to(p))<0)return q.to(a).n;\n\t\treturn abs(v.cross(p.to(a))/v.n);\n\t}\n\tD dist(L a){\n\t\tif(iscross(a))return 0;\n\t\treturn min(min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tP crosspos(L a){\n\t\treturn (p+v.scalar(a.v.cross(a.p-p)/a.v.cross(v)));\n\t}\n\tL bisection(){//垂直二等分線\n\t\t//半時計回りに90度回った向きの。\n\t\tP fr=(p+q).scalar(0.5);\n\t\tP to=fr+P(-v.y,v.x);\n\t\treturn L(fr,to);\n\t}\n};\n\n\nD lowofcos(D a,D b,D c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct C{\n\tP p;\n\tD r;\n\tL koten(C a){\n\t\tP cv=p.to(a.p);\n\t\tD br=atan2(cv.y,cv.x);\n\t\tD dr=acos(lowofcos( r, cv.n, a.r));\n\t\tP p1= p+P::polar(r,br+dr);\n\t\tP p2= p+P::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn L(p1,p2);\n\t}\n\tC(){}\n\tC(P ip,D ir){\n\t\tp=ip; r=ir;\n\t}\n\tvector<L> tangs(C a){ //接線たち\n\t\t//validate AOJ 2201\n\t\tC b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<L> res;\n\t\tif((a.p-b.p).n-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).n-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).n<1e-6)return res; //全く同じ円。\n\t\t\tP rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(L(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tP cv=b.p-a.p;\n\t\t\tD th=acos((a.r-b.r)/cv.n);\n\t\t\tP p1 = cv.turn(th);\n\t\t\tres.push_back(L(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tP p2 = cv.turn(-th);\n\t\t\tres.push_back(L(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).n-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).n-(a.r+b.r)<1e-6){\n\t\t\tP rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(L(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tP cv=b.p-a.p;\n\t\t\tD th=acos((a.r+b.r)/cv.n);\n\t\t\tP p1 = cv.turn(th);\n\t\t\tres.push_back(L(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tP p2 = cv.turn(-th);\n\t\t\tres.push_back(L(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<C> cs;\n\t\tvector<double> ms;\n\t\trep(i,n){\n\t\t\tdouble x,y,r,m;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&r,&m);\n\t\t\tcs.push_back(C(P(x,y),r));\n\t\t\tms.push_back(m);\n\t\t}\n\t\trep(i,n){\n\t\t\tC nc = cs[i];\n\t\t\tcs.push_back(C(nc.p,nc.r+ms[i]));\n\t\t}\n\t\tint ans = 1;\n\t\trep(i,n*2){\n\t\t\trep(j,i){\n\t\t\t\tvector<L> ts = cs[i].tangs(cs[j]);\n\t\t\t\t//printf(\"%d %d : %d\\n\",i,j,ts.size());\n\t\t\t\trep(k,ts.size()){\n\t\t\t\t\tL nl = ts[k];\n\t\t\t\t\tnl = L(nl.p - nl.v.tolen(10000),nl.p + nl.v.tolen(10000));\n\t\t\t\t\tint ns=0;\n\t\t\t\t\trep(a,n){\n\t\t\t\t\t\tdouble td = nl.dist(cs[a].p);\n\t\t\t\t\t\tdouble r = cs[a].r;\n\t\t\t\t\t\t//printf(\"%d %d %d : %lf %lf %lf\\n\",i,j,a,r,td,r+ms[a]);\n\t\t\t\t\t\tif(r<td+1e-6 && td<r+ms[a]+1e-6)ns++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+r2)*(r1+r2));\n\t\tdouble xf=r1*(xx*(r1+r2*rs)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+r2*rs)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(yf){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  //\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-12;\n\ntypedef complex< double > P;\n\nint cmp(double a, double b)\n{\n  const double diff = a - b;\n\n  if (fabs(diff) < EPS)\n    return 0;\n  else if (diff < 0)\n    return -1;\n  else\n    return 1;\n}\n\ninline double cross(const P &a, const P &b)\n{\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nstruct line\n{\n  P a, b;\n\n  line() {}\n  line(const P &a, const P &b) : a(a), b(b) {}\n\n  inline double distance(const P &p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n};\n\nstruct circle\n{\n  P o;\n  double r;\n\n  circle() {}\n  circle(const P &o, double r) : o(o), r(r) {}\n\n  double distance(const line &l) const { return abs(l.distance(o)); }\n\n  inline bool independent(const circle &c) const\n  {\n    return cmp(abs(o - c.o), r + c.r) > 0;\n  }\n\n  pair< P, P > tangent(const P &p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L * L - r * r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n\n    return make_pair(p + M * (v * polar(1.0, theta)),\n                     p + M * (v * polar(1.0, -theta)));\n  }\n\n  pair< line, line > outer_tangent_parallel(const circle &c) const\n  {\n    const P d = o - c.o;\n    const P v = d * P(0, 1) * r / abs(d);\n\n    return make_pair(line(o + v, c.o + v), line(o - v, c.o - v));\n  }\n\n  pair< line, line > outer_tangent(const circle &c) const\n  {\n    if (cmp(r, c.r) == 0)\n      return outer_tangent_parallel(c);\n    if (r > c.r)\n      return c.outer_tangent(*this);\n\n    const P d = o - c.o;\n    const double fact = c.r / r - 1;\n    const P base = c.o + d + d / fact;\n    const pair< P, P > t = tangent(base);\n\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair< line, line > inner_tangent(const circle &c) const\n  {\n    if (r > c.r)\n      return c.inner_tangent(*this);\n\n    const P d = c.o - o;\n    const double fact = c.r / r + 1;\n    const P base = o + d / fact;\n    const pair< P, P > t = tangent(base);\n\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  inline bool intersects(const circle &c) const\n  {\n    return !contains(c) && !c.contains(*this) &&\n           cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  inline bool contains(const circle &c) const\n  {\n    return cmp(abs(o - c.o) + c.r, r) < 0;\n  }\n\n  pair< P, P > intersection(const circle &c) const\n  {\n    const double d = abs(o - c.o);\n    const double cos_ = (d * d + r * r - c.r * c.r) / (2 * d);\n    const double sin_ = sqrt(r * r - cos_ * cos_);\n    const P e = (c.o - o) / d;\n\n    return make_pair(o + e * P(cos_, sin_), o + e * P(cos_, -sin_));\n  }\n};\n\nint N;\n\nvoid enum_event(circle &c1, circle &c2, vector< line > &lines)\n{\n  if (c1.independent(c2))\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n\n    auto inner = c1.inner_tangent(c2);\n    lines.push_back(inner.first);\n    lines.push_back(inner.second);\n  }\n  else if (c1.intersects(c2))\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n\n    auto inter = c1.intersection(c2);\n    lines.push_back(line(inter.first, inter.second));\n  }\n}\n\nvoid solve()\n{\n  vector< pair< circle, circle > > jewels;\n  vector< line > lines;\n\n  for (int i = 0; i < N; i++)\n  {\n    int x, y, r, m;\n    scanf(\"%d%d%d%d\", &x, &y, &r, &m);\n\n    const P center(x, y);\n    pair< circle, circle > jewel =\n      make_pair(circle(center, r), circle(center, r + m));\n\n    for (int j = 0; j < (int)jewels.size(); j++)\n    {\n      pair< circle, circle > &other = jewels[j];\n\n      enum_event(jewel.first, other.first, lines);\n      enum_event(jewel.first, other.second, lines);\n      enum_event(jewel.second, other.first, lines);\n      enum_event(jewel.second, other.second, lines);\n    }\n\n    jewels.push_back(jewel);\n  }\n\n  int ans = 1;\n  for (int i = 0; i < (int)lines.size(); i++)\n  {\n    line &l = lines[i];\n\n    ans = max(ans,\n              (int)count_if(jewels.begin(), jewels.end(),\n                            [&](const pair< circle, circle > &j) {\n                              return cmp(j.first.r, j.first.distance(l)) <= 0 &&\n                                     cmp(j.second.r, j.second.distance(l)) >= 0;\n                            }));\n  }\n\n  printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n  while (true)\n  {\n    scanf(\"%d\", &N);\n    if (N == 0)\n      break;\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-5)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool iscrossCL1(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\nbool iscrossCL2(Circle c,Line l){\n  if((getDistanceLP(l,c.c)-c.r)<eps)return true;\n  return false;\n}\n\n// ??±?????\\???????±???????\nvector<Line> getLines(Circle a,Circle b){\n  vector<Line> V;\n  double d=abs(b.c-a.c);\n  Vector v=(b.c-a.c)/d,v1=v*a.r,v2=v*b.r;\n  double c,s;\n  Point p1,p2;\n\n  c=sqrt(d*d-(a.r-b.r)*(a.r-b.r));\n  s=(180*asin(c/d))/pi;\n\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,180+s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,180-s);\n  V.push_back(Line(p1,p2));\n\n  c=sqrt(d*d-(a.r+b.r)*(a.r+b.r));\n  s=(180*asin(c/d))/pi;\n\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,360-s);\n  V.push_back(Line(p1,p2));\n\n  return V;\n}\n\nint main()\n{\n  int n,a,b,c,d;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<pair<Circle,Circle> > v;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d;\n      v.push_back(mp(Circle(Point(a,b),c),Circle(Point(a,b),c+d)));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<Line> V;\n\tvector<Line> v1=getLines(v[i].f,v[j].f);\n\tvector<Line> v2=getLines(v[i].f,v[j].s);\n\tvector<Line> v3=getLines(v[i].s,v[j].f);\n\tvector<Line> v4=getLines(v[i].s,v[j].s);\n\tV.insert(V.begin(),v1.begin(),v1.end());\n\tV.insert(V.begin(),v2.begin(),v2.end());\n\tV.insert(V.begin(),v3.begin(),v3.end());\n\tV.insert(V.begin(),v4.begin(),v4.end());\n\tfor(int k=0;k<V.size();k++){\n\t  int sum=0;\n\t  for(int z=0;z<n;z++){\n\t    if(!iscrossCL1(v[z].f,V[k]) && iscrossCL2(v[z].s,V[k]))sum++;\n\t  }\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n \nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\ndouble sc(double a){return sqrt(1.0-a*a);}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\n \nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\ntypedef Segment Line;\n \ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\nPoint rotate( Point a, double n){\n  return Point( a.x*cos(n)-a.y*sin(n) , a.x*sin(n)+a.y*cos(n) );\n}\n\nPoint getCrossPointCC(Point p1,double r1,Point p2,double r2){\n  double a=r2,b=r1,c=getDistance(p1,p2);\n  double cos_A = (b*b+c*c-a*a) / (2.0*b*c);\n  double sin_A = sqrt(1.0-cos_A*cos_A);\n  Vector v=p2-p1;\n  v = v * r1 / c;\n  return p1+rotate(v,sin_A,cos_A);\n}\n\nSegment getSegmentCC(Point p1,double r1,Point p2,double r2,bool flg=false){\n  double b=getDistance(p1,p2),c=r1+r2;\n  double a=sqrt(b*b-c*c);\n  double cos_A=(b==0?1:c/b),sin_A=(b==0?0:a/b);\n\n  if(flg)sin_A=-sin_A;\n  \n  Vector v1 = (p2-p1),v2 = (p1-p2);\n  v1 = v1 * r1 / b;\n  v1 = rotate(v1,sin_A,cos_A);\n  v2 = v2 * r2 / b;\n  v2 = rotate(v2,sin_A,cos_A);\n  return Segment(p1+v1,p2+v2);\n}\n\nSegment getSegmentCC2(Point p1,double r1,Point p2,double r2,bool flg=false){\n  if(r1>r2){\n    swap(p1,p2);\n    swap(r1,r2);\n  }\n  double c=abs(r1-r2),b=getDistance(p1,p2);\n  double a=sqrt( b*b - c*c );\n\n  double cos_A=c/b,sin_A=a/b;\n  if(flg)sin_A=-sin_A;\n\n  Vector v1 = p1-p2;\n  v1 = v1 * r1 / b;\n  v1 = rotate( v1, sin_A,cos_A);\n  Vector v2 = v1 * r2 / r1;\n  return Segment(p1+v1,p2+v2);\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\nint N;\nPoint t[50];\ndouble r[50],m[50];\nvector<Segment> segments;\nint check(Segment);\n\nint main(){\n  while(cin>>N&&N){\n    segments.clear();\n    for(int i=0;i<N;i++){\n      cin>>t[i].x>>t[i].y>>r[i]>>m[i];\n      m[i]+=r[i];\n      for(int j=0;j<i;j++){\n\n\tsegments.push_back(getSegmentCC(t[i],m[i],t[j],m[j]));\n\tsegments.push_back(getSegmentCC(t[i],m[i],t[j],m[j],true));\n\tsegments.push_back(getSegmentCC2(t[i],m[i],t[j],m[j]));\n\tsegments.push_back(getSegmentCC2(t[i],m[i],t[j],m[j],true));\n\t\n\tsegments.push_back(getSegmentCC(t[i],r[i],t[j],r[j]));\n\tsegments.push_back(getSegmentCC(t[i],r[i],t[j],r[j],true));\n\tsegments.push_back(getSegmentCC2(t[i],r[i],t[j],r[j]));\n\tsegments.push_back(getSegmentCC2(t[i],r[i],t[j],r[j],true));\n\t\n\n      }\n    }\n    if(N==1){\n      cout<<\"1\"<<endl;\n      continue;\n    }\n    int ans=0;\n    for(int i=0;i<(int)segments.size();i++){\n      Segment s = segments[i];\n\n      ans=max(ans,check(s));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\nint check(Segment s){\n  int res=0;\n  for(int i=0;i<N;i++){\n    double d = getDistanceLP(s,t[i]);\n    if( r[i]<EPS+d && d< EPS+m[i] )res++;\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2012/12/15\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// \nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// \nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// \n//  0 : \n//  1 : 1\n//  2 : 2\n// -1 : \n// -2 : \nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross \n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// \nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// \nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\n\n// 2(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// (1, 0)(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2r\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = getAngle(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.o = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 3\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// \ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// \ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// \nvector<L> getTangent(C a, C b) {\n  if(a.r > b.r) swap(a,b);\n  vector<L> res;\n  double d = abs(b.o - a.o);\n  double th;\n  P v, n;\n  int t = isIntersect(a, b);\n\n  if(equals(a.o.real(), b.o.real()) && \n     equals(a.o.imag(), b.o.imag()) && \n     equals(a.r, b.r)) return res;\n  if(t == -2) return res;\n\n  if(t == 0 || t == 1 || t == 2) {\n    th = asin((b.r - a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 0) {\n    th = asin((b.r + a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 1) {\n    n = b.o - a.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  if(t == -1) {\n    n = a.o - b.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      if(r[0] <= m[0]) cout << 1 << endl;\n      else cout << 0 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n\tvector<L> tmp;\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n\tdouble d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n\tif((equals(d, r[i]) || d > r[i]) &&\n\t   (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint calc(L l){\n  int sum = 0;\n  for(int k=0;k<n;k++){\n    if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n      sum++;\n    }\n  }\n  return sum;\n}\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n      }\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n      \n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n    }\n  }\n  \n  //pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  \n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      ans = max(ans, calc(L(pv[i], pv[j])));\n    }\n  }  \n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tC(P p, R r):P(p),r(r){}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tvector<L> CommonTangent(C c1, C c2){\n\t\tif(c1.r > c2.r) swap(c1, c2);\n\t\tdouble d = abs(c1-c2);\n\t\tvector<L> res;\n\t\tif(d < EPS) return res;\n\t\tif(d + EPS > c1.r + c2.r){\n\t\t\t// 内接線\n\t\t\tP crs = (c1*c2.r + c2*c1.r) / (c1.r + c2.r);\n\t\t\tdouble rad = asin(c1.r/abs(crs-c1));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., rad)));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., -rad)));\n\t\t}\n\t\tif(c1.r + d + EPS > c2.r){\n\t\t\t// 外接線\n\t\t\tdouble rad = 0.5*PI+asin((c2.r-c1.r) / d);\n\t\t\tP v = unit(c2-c1)*polar(1., rad);\n\t\t\tif(c1.r + d - EPS < c2.r){\n\t\t\t\tres.push_back(L(c1+v*c1.r, c1+v*c1.r+(c1-c2)*P(0, 1)));\n\t\t\t}else{\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t\tv = 2.*proj(v, c2-c1) - v;\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n;\nvector<pair<C, C>> jewel;\n\nmain(){\n\twhile(cin >> n, n){\n\t\tjewel.clear();\n\t\tREP(i, n){\n\t\t\tint x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tjewel.emplace_back(C(P(x, y), r), C(P(x, y), r+m));\n\t\t}\n\t\tvector<L> cand;\n\t\tREP(i, n)REP(j, i){\n\t\t\tREP(k, 4){\n\t\t\t\tC &c1 = (k&1) ? jewel[i].first : jewel[i].second;\n\t\t\t\tC &c2 = (k&2) ? jewel[j].first : jewel[j].second;\n\t\t\t\tvector<L> c = CommonTangent(c1, c2);\n\t\t\t\tcand.insert(cand.end(), ALL(c));\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, cand.size()) {\n\t\t\tans = max(ans, (int)count_if(ALL(jewel), [&](const pair<C, C> &jewel){\n\t\t\t\tR d = dist(cand[i], jewel.first);\n\t\t\t\treturn jewel.first.r < d+EPS && d-EPS < jewel.second.r;\n\t\t\t}));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+r2)*(r1+r2));\n\t\tdouble xf=r1*(xx*(r1+r2*rs)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+r2*rs)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(yf){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  //\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\n#define ISEQ(c) (c).begin(), (c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nnamespace Ps{\n\ttypedef  double D;\n\ttypedef complex<D> P;\n\tconst D EPS = 1e-9;\n\tconst D INF = 1e20;\n\n#define X real()\n#define Y imag()\n\n\ttemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\ttemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\n\ttemplate<typename T> D norm(T a){ return a*a;}\n\t// a×b\n\tD cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tD dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\tint ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t}\n\n\t//浮動小数点modで非負の値のみかえす．\n\tD pfmod(D v,D MOD){\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t}\n\n\t//[0,PI)\n\tD AbsArg(D a){\n\t  \tD ret=pfmod(max(a,-a),2*M_PI);\n\t  \treturn min(ret,2*M_PI-ret);\n\t}\n\t\n}\nusing namespace Ps;\n\n\nnamespace Ls{\n\tstruct L : public vector<P> {\n\t  L(const P &a, const P &b) {\n\t    push_back(a); push_back(b);\n\t  }\n\t};\n\n\t//直線へ射影した時の点\n\tP projection(const L &l, const P &p) {\n\t  D t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\t  return l[0] + t*(l[0]-l[1]);\n\t}\n\n\tD distanceLP(const L &l, const P &p) {\n\t  return abs(p - projection(l, p));\n\t}\n\n}\nusing namespace Ls;\n\nnamespace std{\n\tbool operator < (const P& a,const P& b){\n    \t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  \t}\n  \tbool operator == (const P& a,const P& b){\n    \t\treturn eq(a,b);\n   \t}\n};\n\nnamespace Cs{\n\tint INF=1<<28;\n\tstruct C {\n \t\t P o; D r;\n \t\t C(const P &o,D r) : o(o), r(r) { }\n\t};\n\n\t// 包含関係\n\tenum RELATION{INCOMPARABLE=0,SAME=1,CONTAIN=2,OVER=4};\n\tpair<RELATION,int> cRel(const C& c1,const C& c2){\n\t\tD d=abs(c1.o-c2.o);\n\t\tif(eq(c1.o,c2.o) && eq(c1.r,c2.r))return make_pair(SAME,INF);// c1 == c2\n\t\tif(sig(d,c1.r-c2.r)<0)return make_pair(OVER,0); // c2 ⊆ c1\n\t\tif(sig(d,c2.r-c1.r)<0)return make_pair(CONTAIN,0); // c1 ⊆ c2\n\t\tif(sig(d,c1.r-c2.r)==0)return make_pair(OVER,1);// c2 ⊆ c1,1点で接する\n\t\tif(sig(d,c2.r-c1.r)==0)return make_pair(CONTAIN,1);// c1 ⊆ c2,1点で接する\n\t\tif(sig(d,c1.r+c2.r)==0)return make_pair(INCOMPARABLE,1);// 1点で接する\n\t\tif(sig(d,c1.r+c2.r)<0)return make_pair(INCOMPARABLE,2);//  2点で接する\n\t\treturn make_pair(INCOMPARABLE,0);// 交わらない\n\t}\n\n\t// 点p を通る 円c の接点\n\tvector<L> ContactCP(const C& c,const P& p){\n\t\tvector<L> res;\n\t\tP dir =p-c.o;D d=abs(dir);\n\t\tif(sig(c.r,d)==0){\n\t\t\tres.push_back(L(p,p+dir*P(0,1)));return res;\n\t\t}\n\t\tif(sig(c.r,d)>0)return res;\n\n\t\tD th=acos(c.r/d),ph=arg(dir);\n\t\tres.push_back(L(p,c.o+polar(c.r,ph+th)));res.push_back(L(p,c.o+polar(c.r,ph-th)));\n\t\treturn res;\n\t}\n\t//角度 arg の 円c の接線\n\tL contactCP(const C& c,D arg){\n\t\tP p=polar(c.r,arg);return L(c.o+p-p*P(0,1),c.o+p+p*P(0,1));\n\t}\n\n\t//2円 c1,c2の共通接線\n\tvector<L> ContactCC(const C& c1,const C& c2){\n\t\tpair<RELATION,int> rel=cRel(c1, c2);\n\t\tvector<L> res;\n\t\tif(rel.first==SAME)return res;\n\t\tP dir=c2.o - c1.o;D t=arg(dir);\n\t\t//external\n\t\tif(rel.first==INCOMPARABLE || rel.second>0){\n\t\t\tD a=acos((c2.r-c1.r)/abs(dir));\n\t\t\tres.push_back(contactCP(c1,t+a));\n\t\t\tif(sig(a)!=0)res.push_back(contactCP(c1,t-a));\n\t\t}\n\t\t//internal\n\t\tif(rel.first==INCOMPARABLE && rel.second<2){\n\t\t\tD a=acos((c2.r+c1.r)/abs(dir));\n\t\t\tres.push_back(contactCP(c1,t+a));\n\t\t\tif(sig(a)!=0)res.push_back(contactCP(c1,t-a));\n\t\t}\n\t\treturn res;\n\t}\n}\nusing namespace Cs;\n\nint main() {\n\t// ifstream cin(\"in\");\n\t// ofstream coutf( \"out\" );\n\twhile(true){\n\t\tint N;cin >> N;if(N==0)break;\n\t\tvector<C> cs1,cs2,cs;\n\t\tREP(i,N){\n\t\t\tD x,y,r,m;cin >> x >> y >>r >> m;\n\t\t\tcs1.push_back(C(P(x,y),r));cs2.push_back(C(P(x,y),r+m));\n\t\t\tcs.push_back(C(P(x,y),r));cs.push_back(C(P(x,y),r+m));\n\t\t}\n\n\t\tint Mv=0;if(N==1)Mv=max(Mv,1);\n\t\tREP(i,2*N)REP(j,2*N){\n\t\t\tvector<L> ls=ContactCC(cs[i],cs[j]);\n\t\t\tREP(k,ls.size()){\n\t\t\t\tint c=0;\n\t\t\t\tREP(s,N){\n\t\t\t\t\tD d=distanceLP(ls[k],cs2[s].o);\n\t\t\t\t\tif(sig(cs1[s].r,d)<=0 && sig(d,cs2[s].r)<=0){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMv=max(Mv,c);\n\t\t\t}\n\t\t}\n\t\tcout << Mv <<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tB comp(const P& l, const P& r) { return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\t//Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n\n\t//A dot B\n\tIL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n\tIL int sgn(P a, P b, P c) {\n\t\tif (cross(b - a, c - a) > EPS)return 1;\n\t\tif (cross(b - a, c - a) < -EPS)return -1;\n\t\tif (dot(b - a, c - a) < -EPS)return 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)return -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l) {\n\t\tDCl(a, b, l);\n\t\treturn cross(b - a, p - a) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) {\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) {\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS) return abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS) return abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\n\tIL B is_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn\n\t\t\tabs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls) {\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn cross(a - b, c - b) * cross(a - b, d - b) <EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t\t\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q) {\n\t\tif (is_LS_LS(p, q))return 0;\n\t\treturn min({\n\t\t\tdistance_P_LS(p.fi,q),\n\t\t\tdistance_P_LS(p.se,q),\n\t\t\tdistance_P_LS(q.fi,p),\n\t\t\tdistance_P_LS(q.se,p)\n\t\t});\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_point_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d <EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tD rs = sqrt(rp*rp - rc*rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn{ cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff };\n\t}\n\tIL D ccw(P a, P b, P c) {\n\t\treturn cross(b - a, c - a);\n\t}\n\tIL Poly convex_hull(Poly& p) {\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(ALL(p),comp);\n\t\tREP(i, n) {\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tREP(j, n - 1) {\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly& l, P& p) {\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1) {\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0) {\n\t\t\t\tif (A > -EPS&&C < -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (C < -EPS || A > -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n\t}\n\tIL D convex_area(Poly& l) {\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\tFOR(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tinline vector<L> tangent_line(C c, P p) {\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist > r + EPS) {\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\t{\n\t\t\t\tP e = P(_cos*v.X + _sin*v.Y, -_sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + EPS) {\n\t\t\tP mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist > Rp - Rq + EPS) {\n\t\t\tif (abs(Rp - Rq) < EPS) {\n\t\t\t\tP e = v*P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nIL int check(geo::L l, vector<geo::C>& cd, vector<geo::C>& cm) {\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble d = geo::distance_P_L(cd[i].first, l);\n\t\t//  cout << d << \" \";\n\t\tif (d<cm[i].second + geo::EPS&&d>cd[i].second - geo::EPS)\n\t\t\tres++;\n\t}\n\t//cout << endl;\n\treturn res;\n\n\n}\nint main() {\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::C> cd(N);\n\t\tvector<geo::C> cm(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tcd[i].first = geo::P(x, y);\n\t\t\tcm[i].first = geo::P(x, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d + m;\n\t\t}\n\t\tif (N == 1) {\n\t\t\tif (cm[0].second < geo::EPS)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();  cout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+r2)*(r1+r2));\n\t\tdouble xf=r1*(xx*(r1+r2*rs)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+r2*rs)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(fabs(yf)>fabs(xf)){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  cout<<xx*xx+yy*yy-(r1+r2)*(r1+r2)<<' '<<xf<<' '<<yf<<' ';\n\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nconst int INF = 0xfffffff;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-10;\n\nstruct Circle {\n\tPoint center;\n\tdouble radius;\n\tCircle (Point center = Point(0,0), double radius = 0) :center(center), radius(radius){}\n};\n\nstruct Line {\n\tPoint pos, dir;\n\tLine(Point a = Point(0, 0), Point b = Point(0, 0)) {\n\t\tthis->pos = a;\n\t\tthis->dir = (b - a) / abs(b - a);\n\t}\n};\n\nvector<Line> calc_common_tangent_cc(const Circle &c1, const Circle &c2) {\n\tPoint v = c2.center - c1.center;\n\tdouble th[2] = {(c1.radius - c2.radius)/abs(v), (c1.radius + c2.radius) / abs(v)};\n\n\tdouble r1 = c1.radius;\n\tdouble r2 = c2.radius;\n\tvector<Line> res;\n\tif(abs(th[0]) - 1.0 < EPS) {\n\t\tdouble tmp_th = arg(v) + acos(th[0]);\n\t\tPoint l_p[2] = { c1.center + Point(r1 * cos(tmp_th), r1 * sin(tmp_th)),\n\t\t\tc2.center + Point(r2 * cos(tmp_th), r2 * sin(tmp_th))};\n\t\tres.push_back(Line(l_p[0], l_p[1]));\n\n\t\ttmp_th = arg(v) - acos(th[0]);\n\t\tl_p[0] = c1.center + Point(r1 * cos(tmp_th), r1 * sin(tmp_th));\n\t\tl_p[1] = c2.center + Point(r2 * cos(tmp_th), r2 * sin(tmp_th));\n\t\tres.push_back(Line(l_p[0], l_p[1]));\n\t}\n\tif(abs(th[1]) - 1.0 < EPS) {\n\t\tdouble tmp_th = arg(v) + acos(th[1]);\n\t\tPoint l_p[2] = { c1.center + Point(r1 * cos(tmp_th), r1 * sin(tmp_th)),\n\t\t\tc2.center + Point(r2 * cos(tmp_th), r2 * sin(tmp_th))};\n\t\tres.push_back(Line(l_p[0], l_p[1]));\n\n\t\ttmp_th = arg(v) - acos(th[1]);\n\t\tl_p[0] = c1.center + Point(r1 * cos(tmp_th), r1 * sin(tmp_th));\n\t\tl_p[1] = c2.center + Point(r2 * cos(tmp_th), r2 * sin(tmp_th));\n\t\tres.push_back(Line(l_p[0], l_p[1]));\n\t}\n\treturn res;\n}\n\ndouble cross(const Point &p1, const Point &p2) {\n\treturn p1.real()*p2.imag() - p1.imag()*p2.real();\n}\n\ndouble calc_length_point_line(const Point &p, const Line &l) {\n\treturn abs(cross(p - l.pos, l.dir));\n}\n\n\nint N;\ndouble x[55], y[55], r[55], m[55];\n\nint solve(){\n\tint ans = 0;\n\trep(i, N){\n\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t}\n\tif( N <= 2 ) return N;\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\t// 16 pattern check\n\t\t\trep(ki,2) rep(kj,2){\n\t\t\t\tdouble r1 = r[i] + ( ki ? m[i] : 0 );\n\t\t\t\tdouble r2 = r[j] + ( kj ? m[j] : 0 );\n\t\t\t\tCircle c1( Point(x[i], y[i]), r1 );\n\t\t\t\tCircle c2( Point(x[j], y[j]), r2 );\n\t\t\t\tvector<Line> vs = calc_common_tangent_cc( c1, c2 );\n\t\t\t\tfor(auto v: vs ){\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\trep(l,N){\n\t\t\t\t\t\tPoint trg( x[l], y[l]);\n\t\t\t\t\t\tdouble dist = calc_length_point_line( trg, v );\n\t\t\t\t\t\tif( r[l] <= dist && dist <= r[l] + m[l] ){\n\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2012/12/15\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// \nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// \nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// \n//  0 : \n//  1 : 1\n//  2 : 2\n// -1 : \n// -2 : \nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross \n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// \nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// \nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\n\n// 2(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// (1, 0)(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2r\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = getAngle(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.o = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 3\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// \ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// \ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// \nvector<L> getTangent(C a, C b) {\n  if(a.r > b.r) swap(a,b);\n  vector<L> res;\n  double d = abs(b.o - a.o);\n  double th;\n  P v, n;\n  int t = isIntersect(a, b);\n\n  if(equals(a.o.real(), b.o.real()) && \n     equals(a.o.imag(), b.o.imag()) && \n     equals(a.r, b.r)) return res;\n  if(t == -2) return res;\n\n  if(t == 0 || t == 1 || t == 2) {\n    th = asin((b.r - a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 0) {\n    th = asin((b.r + a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 1) {\n    n = b.o - a.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  if(t == -1) {\n    n = a.o - b.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n\tvector<L> tmp;\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n\tdouble d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n\tif((equals(d, r[i]) || d > r[i]) &&\n\t   (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nT abs2(const point<T> &a){ return a.x*a.x+a.y*a.y; }\n\ntemplate<class T>\npoint<double> proj(const point<T> &p,const line<T> &L){\n\treturn L.a+dot(p-L.a,L.b-L.a)/abs2(L.b-L.a)*(L.b-L.a);\n}\n\npoint<double> rot(const point<double> &a,double theta){\n\treturn (point<double>){a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n}\n\nint intersect(const circle<double> &C,const line<double> &L){\n\tpoint<double> m=proj(C.c,L);\n\tdouble d=abs(C.c-m);\n\tif(C.r+EPS<d) return 0;\n\tif(C.r-EPS<d) return 1;\n\treturn 2;\n}\n\nint tangent(const circle<double> &C1,const circle<double> &C2,vector< line<double> > &res){\n\tdouble d=abs(C1.c-C2.c);\n\tif(d<EPS) return 0;\n\n\tint c=0;\n\t// 内接線\n\tif(C1.r+C2.r<d-EPS){\n\t\tdouble t=acos((C1.r+C2.r)/d);\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c), t),C2.c+rot(C2.r/d*(C1.c-C2.c), t)});\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c),-t),C2.c+rot(C2.r/d*(C1.c-C2.c),-t)});\n\t\tc+=2;\n\t}\n\telse if(C1.r+C2.r<d+EPS){\n\t\tpoint<double> p=C1.c+C1.r/d*(C2.c-C1.c);\n\t\tres.push_back((line<double>){p,p+rot(C2.c-C1.c,PI/2)});\n\t\tc++;\n\t}\n\n\t// 外接線\n\tif(abs(C1.r-C2.r)<d-EPS){\n\t\tdouble t1=acos((C1.r-C2.r)/d),t2=PI-t1;\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c), t1),C2.c+rot(C2.r/d*(C1.c-C2.c),-t2)});\n\t\tres.push_back((line<double>){C1.c+rot(C1.r/d*(C2.c-C1.c),-t1),C2.c+rot(C2.r/d*(C1.c-C2.c), t2)});\n\t\tc+=2;\n\t}\n\telse if(abs(C1.r-C2.r)<d+EPS){\n\t\tpoint<double> p=C1.c+C1.r/d*(C2.c-C1.c);\n\t\tres.push_back((line<double>){p,p+rot(C2.c-C1.c,PI/2)});\n\t\tc++;\n\t}\n\n\treturn c;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tcircle<double> J[50],M[50];\n\t\trep(i,n){\n\t\t\tint x,y,m; scanf(\"%d%d%lf%d\",&x,&y,&J[i].r,&m);\n\t\t\tM[i].c=J[i].c=(point<double>){x,y};\n\t\t\tM[i].r=J[i].r+m;\n\t\t}\n\n\t\tvector< line<double> > L;\n\t\trep(j,n) rep(i,j) {\n\t\t\ttangent(J[i],J[j],L);\n\t\t\ttangent(J[i],M[j],L);\n\t\t\ttangent(M[i],J[j],L);\n\t\t\ttangent(M[i],M[j],L);\n\t\t}\n\n\t\tint ans=1;\n\t\trep(i,L.size()){\n\t\t\tint cnt=0;\n\t\t\trep(j,n) if(intersect(J[j],L[i])<=1 && intersect(M[j],L[i])>=1) cnt++;\n\t\t\tans=max(ans,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inc(i, l, r) for (int i = l; i <= r; i++)\n\nconst double eps = 1e-8;\n//const double M_PI = acos(-1.0); \n\nint n;\n\nint sgn(double x) {\n    if (fabs(x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\ndouble sqr(double x) { return x * x; }\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n    bool operator==(Point b) const {\n        return sgn(x - b.x) == 0 && sgn(y - b.y) == 0;\n    }\n    bool operator<(Point b) const {\n        return sgn(x - b.x) == 0 - sgn(y - b.y) ? 0 : x < b.x;\n    }\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n    //叉积\n    double operator^(const Point &b) const { return x * b.y - y * b.x; }\n    //点积\n    double operator*(const Point &b) const { return x * b.x + y * b.y; }\n    //返回长度\n    double len() {\n        return hypot(x, y);  //库函数\n    }\n    //返回长度的平方\n    double len2() { return x * x + y * y; }\n    //返回两点的距离\n    double distance(Point p) { return hypot(x - p.x, y - p.y); }\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n    Point operator*(const double &k) const { return Point(x * k, y * k); }\n    Point operator/(const double &k) const { return Point(x / k, y / k); }\n};\n\nstruct Line {\n    Point s, e;\n    Line() {}\n    Line(Point _s, Point _e) {\n        s = _s;\n        e = _e;\n    }\n    double length() { return s.distance(e); }\n    double dispointtoline(Point p) {\n        return fabs((p - s) ^ (e - s)) / length();\n    }\n};\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point _p, double _r) {\n        p = _p;\n        r = _r;\n    }\n    // 过一点知道角度和距离 求另一点\n    Point GP(double b) { return Point(p.x + cos(b) * r, p.y + sin(b) * r); }\n\n} C[105];\nPoint u1(double x) { return Point(cos(x), sin(x)); }\n\nvector<Line> GCCI(Circle A, Circle B) {\n    vector<Line> v;\n    if (A.r < B.r) swap(A, B);\n    Point u = B.p - A.p;\n    double d = u.len(), rdec = A.r - B.r, radd = A.r + B.r;\n    if (sgn(d) == 0 && (A.r - B.r) < eps) {\n        //重合, 有无数条公切线\n        v.push_back(Line(A.GP(0), A.GP(0) + u1(M_PI / 2)));\n        return v;\n    }\n    double base = atan2(u.y, u.x);\n    if (sgn(d - rdec) == 0) {\n        //内切\n        assert(0);\n    }\n    double da = acos((A.r - B.r) / d);  // 2条外公切线\n    v.push_back(Line(Point(A.GP(base + da)), Point(B.GP(base + da))));\n    v.push_back(Line(Point(A.GP(base - da)), Point(B.GP(base - da))));\n    if (sgn(d - radd) == 0) {\n        v.push_back(Line(A.GP(base), A.GP(base) + u1(base + M_PI / 2)));\n    } else if (sgn(d - radd) > 0) {\n        da = acos((A.r + B.r) / d);\n        v.push_back(Line(A.GP(base + da), B.GP(base + da + M_PI)));\n        v.push_back(Line(A.GP(base - da), B.GP(base - da + M_PI)));\n    }\n    return v;\n}\n\ndouble _x, _y, _r, _m;\nPoint _p;\nstruct CCircle {\n    double x, y, r, m;\n} CC[105];\n\nint main() {\n//  freopen(\"1.in\",\"r\",stdin);\n//  freopen(\"1.out\",\"w\",stdout);\n    while (cin >> n && n) {\n        inc(i, 1, n) {\n            cin >> CC[i].x >> CC[i].y >> CC[i].r >> CC[i].m;\n\n            C[i].p.x = CC[i].x;\n            C[i].p.y = CC[i].y;\n            C[i].r = CC[i].r;\n\n            C[i + n] = C[i];\n            C[i + n].r = C[i].r + CC[i].m;\n        }\n        int ans = 1;\n        inc(i, 1, 2 * n) {\n            inc(j, i , 2 * n) {\n                //   printf(\"%d %d\\n\", i, j);\n                vector<Line> v = GCCI(C[i], C[j]);\n                for (Line l : v) {\n                    int tmp = 0;\n                    inc(k, 1, n) {\n                        double dis = l.dispointtoline(Point(CC[k].x, CC[k].y));\n                        if (CC[k].r-eps<= dis &&\n                            dis <= CC[k].r + CC[k].m+eps )\n                            tmp++;\n                    }\n                  //  if (i == 1 && j == 2 /*&& sgn(l.e.x - 2.22) == 0 */) {\n                  //      inc(k, 1, n)\n                  //          printf(\"k=%d dis=%.2f x=%.2f y=%.2f\\n\", k,\n                  //                 l.dispointtoline(Point(CC[i].x, CC[i].y)), CC[i].x, CC[i].y);\n                  //  }\n                    // printf(\"%.2f %.2f  %.2f %.2f tmp=%d\\n\", l.e.x, l.e.y,\n                    //      l.s.x, l.s.y, tmp);\n                //    if(tmp==5) {\n                 ///   \tprintf(\"%d %d %.2f %.2f %.2f %.2f\\n\",i,j, l.e.x, l.e.y, l.s.x, l.s.y );\n                  //  \tinc(k,1,n) printf(\"k=%d dis=%.2f %.2f %.2f\\n\",k,l.dispointtoline(Point(CC[i].x, CC[i].y)),CC[]);\n\t\t\t\t//\t} \n\t\t\t\t\tans = max(ans, tmp);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n/*\n12\n851 -53 86 57\n-95 -4 59 18\n616 241 73 45\n155 239 89 45\n512 -274 16 89\n-106 570 19 7\n154 724 22 68\n-46 950 54 2\n-90 -588 52 87\n182 -204 97 70\n342 -438 100 24\n995 -800 22 26\n0\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\n\ntypedef double DD;\n\nconst DD INF = 1LL<<60;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\nPoint proj(Point p, Line l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(Point p, Line l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(Point p, Line l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(Point p, Line s) {\n    return (ccw(s[0], s[1], p) == 0);\n}\nbool isinterLL(Line l, Line m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(Line s, Line t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && \n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(Point p, Line l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(Point p, Line s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(Line l, Line m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(Line s, Line t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n\nvector<Line> tanline(Point p, Circle c) {\n    vector<Line> res;\n    DD d = norm(p - c);\n    DD l = d - c.r * c.r;\n    if (l < -EPS) return res;\n    if (l <= 0.0) l = 0.0;\n    Point cq = (p - c) * (c.r * c.r / d);\n    Point qs = rot90((p - c) * (-c.r * sqrt(l) / d));\n    Point s1 = c + cq + qs, s2 = c + cq - qs;\n    res.push_back(Line(p, s1));\n    res.push_back(Line(p, s2));\n    return res;\n}\n\nvector<Line> comtanline(Circle a, Circle b) {\n    vector<Line> res;\n    if (abs(a - b) > abs(a.r - b.r) + EPS) {\n        if (abs(a.r - b.r) < EPS) {\n            Point dir = b - a;\n            dir = rot90(dir * (a.r / abs(dir)));\n            res.push_back(Line(a + dir, b + dir));\n            res.push_back(Line(a - dir, b - dir));\n        }\n        else {\n            Point p = a * -b.r + b * a.r;\n            p = p * (1.0 / (a.r - b.r));\n            vector<Line> bs = tanline(p, a);\n            vector<Line> as = tanline(p, b);\n            for (int i = 0; i < min(as.size(), bs.size()); ++i) {\n                res.push_back(Line(bs[i][1], as[i][1]));\n            }\n        }\n    }\n    if (abs(a - b) > a.r + b.r + EPS) {\n        Point p = a * b.r + b * a.r;\n        p = p * (1.0 / (a.r + b.r));\n        vector<Line> bs = tanline(p, a);\n        vector<Line> as = tanline(p, b);\n        for (int i = 0; i < min(as.size(), bs.size()); ++i) {\n            res.push_back(Line(bs[i][1], as[i][1]));\n        }\n    }\n    return res;\n}\n\n\ninline int con(Line l, vector<Circle> vec, vector<DD> d) {\n    int res = 0;\n    for (int i = 0; i < vec.size(); ++i) {\n        DD dis = distancePL(vec[i], l);\n        if (dis >= vec[i].r - EPS && dis <= vec[i].r + d[i] + EPS) ++res;\n    }\n    return res;\n}\n\nint N;\n\nint main() {\n    while (cin >> N) {\n        if (N == 0) break;\n        \n        vector<Circle> vec(N);\n        vector<DD> d(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> vec[i].x >> vec[i].y >> vec[i].r >> d[i];\n        }\n        \n        if (N == 1 || N == 2) cout << N << endl;\n        else {\n            int res = 0;\n            for (int i = 0; i < N; ++i) {\n                for (int j = i+1; j < N; ++j) {\n                    vector<Circle> I(2, vec[i]); I[1].r += d[i];\n                    vector<Circle> J(2, vec[j]); J[1].r += d[j];\n                    for (int p = 0; p < 2; ++p) {\n                        for (int q = 0; q < 2; ++q) {\n                            vector<Line> L = comtanline(I[p], J[q]);\n                            for (int k = 0; k < L.size(); ++k) {\n                                int tmp = con(L[k], vec, d);\n                                chmax(res, tmp);\n                            }\n                        }\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2201: Immortal Jewels\n * ?¢?????????¨?????¢??????????????????????????????????????????????????????????£?????????´???????????´?????¨???????£?????????´?????????????????????????????\\????¢???????????±?????????????????????´??????????????°??????\n * ?±???????????????????\n * ?????????????????????????±??£?????????´?????°?£???????????????????????????´??????2??????????£????????????????????????????????????????????????????????????°??\\??´????????????????????¨?????´???????¶?????????????PS?????????????????¨????¨?????§??´????\n */\n\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n\ntypedef complex<double> P;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-12;\n\nint cmp(double a, double b) {\n  const double diff = a - b;\n  if (fabs(diff) < EPS)\n    return 0;\n  else if (diff < 0)\n    return -1;\n  else\n    return 1;\n}\n\n// ????????????\ninline double dot(const P &a, const P &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\n// ????????????\ninline double cross(const P &a, const P &b) {\n  return a.real() * b.imag() - b.real() * a.imag();\n}\n\nstruct line {\n  P a, b;\n\n  line() {}\n\n  line(const P &p, const P &q) : a(p), b(q) {}\n\n  // ????????????\n  inline bool parallel(const line &ln) const {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;  // ?????????????????°??????????¨????0???????°±???sin(theta)=0 <-> theta=0\n  }\n\n  // ????????????\n  inline bool intersects(const line &ln) const {\n    return !parallel(ln);\n  }\n\n  // ?±???????\n  inline P intersection(const line &ln) const {\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x * (cross(y, ln.a - a)) / cross(y, x);\n  }\n\n  // ?????°??´????????????\n  inline double distance(const P &p) const {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // ?±?????¶???????\n  inline P perpendicular(const P &p) const {\n    const double t = dot(p - a, a - b) / dot(b - a, b - a);\n    return a + t * (a - b);\n  }\n};\n\n\nstruct circle {\n  P o;\n  double r;\n\n  circle() {}\n\n  circle(const P &p, double x) : o(p), r(x) {}\n\n  // ????????? p ???????????????\n  pair<P, P> tangent(const P &p) const {\n    const double L = abs(o - p);\n    const double M = sqrt(L * L - r * r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M * (v * polar(1.0, theta)), p + M * (v * polar(1.0, -theta)));\n  }\n\n  // ?????????????????????????????????????????????\n  pair<line, line> outer_tangent_parallel(const circle &c) const {\n    const P d = o - c.o;\n    const P v = d * P(0, 1) * r / abs(d);\n    return make_pair(line(o + v, c.o + v), line(o - v, c.o - v));\n  }\n\n  // ??????????????????\n  pair<line, line> outer_tangent(const circle &c) const {\n    if (cmp(r, c.r) == 0)\n      return outer_tangent_parallel(c);\n    if (r > c.r)\n      return c.outer_tangent(*this);\n    const P d = o - c.o;\n    const double fact = c.r / r - 1;\n    const P base = c.o + d + d / fact;\n    const pair<P, P> t = tangent(base);\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // ?????????\n  pair<line, line> inner_tangent(const circle &c) const {\n    if (r > c.r)\n      return c.inner_tangent(*this);\n    const P d = c.o - o;\n    const double fact = c.r / r + 1;\n    const P base = o + d / fact;\n    const pair<P, P> t = tangent(base);\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // ????????????\n  inline bool intersects(const circle &c) const {\n    return !contains(c) && !c.contains(*this) && cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  // ????????????\n  inline bool independent(const circle &c) const {\n    return cmp(abs(o - c.o), r + c.r) > 0;\n  }\n\n  // ??????????????????\n  pair<P, P> intersection(const circle &c) const {\n    const double d = abs(o - c.o);\n    const double cos_ = (d * d + r * r - c.r * c.r) / (2 * d);\n    const double sin_ = sqrt(r * r - cos_ * cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e * P(cos_, sin_), o + e * P(cos_, -sin_));\n  }\n\n  // ???????????????c\n  inline bool contains(const circle &c) const {\n    return cmp(abs(o - c.o) + c.r, r) < 0;\n  }\n\n  // ????????????\n  inline bool intersects(const line &ln) const {\n    return cmp(abs(ln.distance(o)), r) <= 0;\n  }\n\n  // ????????°??´????????????\n  inline double distance(const line &ln) const {\n    return abs(ln.distance(o));\n  }\n\n  // ????????´????????????\n  pair<P, P> intersection(const line &ln) const {\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r * r - d * d);\n    return make_pair(h + l * ab, h - l * ab);\n  }\n};\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n  if (c1.independent(c2))  // c1 c2??????\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n    auto inner = c1.inner_tangent(c2);\n    lines.push_back(inner.first);\n    lines.push_back(inner.second);\n  } else if (c1.intersects(c2))  // ??????\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n    auto inter = c1.intersection(c2);\n    lines.push_back(line(inter.first, inter.second));  // ?????¶?????????????????¨????????¨????????¢???????????£???\n  }\n}\n\ncircle cs[50][2];\nvector<line> lines;\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) != EOF && n) {\n    lines.clear();\n    for (int i = 0; i < n; ++i) {\n      double x, y, r, m;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &r, &m);\n      cs[i][0] = circle(P(x, y), r);\n      cs[i][1] = circle(P(x, y), r + m);\n      for (int j = 0; j < i; ++j) {\n        enum_event(cs[i][0], cs[j][0], lines);\n        enum_event(cs[i][1], cs[j][0], lines);\n        enum_event(cs[i][0], cs[j][1], lines);\n        enum_event(cs[i][1], cs[j][1], lines);\n      }\n    }\n    int ans = 1;\n    for (auto &l: lines) {\n      int cnt = 0;\n      for (int i = 0; i < n; ++i) {\n        double d = l.distance(cs[i][0].o);\n//        printf(\"i= %d dist = %f\\n\", i, d);\n        if (cmp(d, cs[i][0].r) >= 0 && cmp(d, cs[i][1].r) <= 0) {\n          ++cnt;\n        }\n      }\n//      printf(\"%f %f -- %f %f -- %d\\n\", l.a.real(), l.a.imag(), l.b.real(), l.b.imag(), cnt);\n      ans = max(ans, cnt);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\n#include <complex>\n#include <cmath>\n#define EPS 1.0e-10\n#define PI 3.1415926535897932384 \n\n// 実数の符号関数\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n//XY座標\n#define X real()\n#define Y imag()\n// 点\ntypedef complex<double> P;\n \n\n// 線分・半直線・直線\nstruct L { P pos, dir; L(P p=P(), P d=P()):pos(p),dir(d){}};\n\n// 多角形\ntypedef vector<P> G;\n \n// 円\nstruct C { P p; double r; C(P q=P(), double R=0):p(q),r(R){}};\n\n// std::norm はabs(p)*abs(p)なので遅い\ninline double norm(P p){\n\treturn p.X*p.X+p.Y*p.Y;\n}\n\n// 二つのベクトルの内積を計算する\ninline double inp(const P& a, const P& b) {\n\treturn (conj(a)*b).X;\n}\n \n// 二つのベクトルの外積を計算する\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a)*b).Y;\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n    P a(r-p), b(s-p);\n    int sgn = signum(outp(a, b));\n    if (sgn != 0)\n        return sgn;\n    if (a.X*b.X < -EPS || a.Y*b.Y < -EPS)\n        return -1;\n    if (norm(a) < norm(b) - EPS)\n        return 1;\n    return 0;\n}\n\n// ベクトルpをベクトルbに射影したベクトルを計算する\ninline P proj(const P& p, const P& b) {\n\treturn b*inp(p,b)/norm(b);\n}\n\n// 点pから直線lに引いた垂線の足となる点を計算する\ninline P perf(const L& l, const P& p) {\n\tL m = L(l.pos - p, l.dir);\n\treturn (p + (m.pos - proj(m.pos, m.dir)));\n}\n \n// 線分sを直線bに射影した線分を計算する\ninline L proj(const L& s, const L& b) {\n\t return (L){perf(b, s.pos), proj(s.dir, b.dir)};\n}\n\ninline double lp_distance(const L& l, const P& p) {\n\treturn abs(outp(l.dir, p-l.pos) / abs(l.dir));\n}\n\nL rotate(L l, double rad){\n\tdouble base = atan2(l.dir.Y, l.dir.X);\n\tdouble d = abs(l.dir);\n\tl.dir = d * P(cos(base+rad), sin(base+rad));\n\treturn l;\n}\n\nvector<L> CCCommonTangent(C c1, C c2){\n\tif(c1.r > c2.r) swap(c1, c2);\n\tdouble d = abs(c1.p-c2.p);\n\tvector<L> res;\n\tif(norm(c1.p - c2.p) < EPS) return res;\n\tif(d + EPS > c1.r + c2.r){\n\t\t// 内接線\n\t\tP crs = (c1.p*c2.r + c2.p*c1.r) / (c1.r + c2.r);\n\t\tdouble rad = asin(c1.r/abs(crs-c1.p));\n\t\tres.push_back(rotate(L(crs, c1.p-crs), rad));\n\t\tres.push_back(rotate(L(crs, c1.p-crs), -rad));\n\t}\n\tif(c1.r + d + EPS > c2.r){\n\t\t// 外接線\n\t\tdouble rad = 0.5*PI+asin((c2.r-c1.r) / d);\n\t\tL l1 = rotate(L(c1.p, (c2.p-c1.p)/abs(c2.p-c1.p)), rad);\n\t\tL l2 = rotate(L(c2.p, (c2.p-c1.p)/abs(c2.p-c1.p)), rad);\n\t\tl1.dir *= c1.r;\n\t\tl2.dir *= c2.r;\n\t\tif(c1.r + d - EPS < c2.r){\n\t\t\tres.push_back(L(l1.pos + l1.dir, P((c1.p - c2.p).Y, (c1.p - c2.p).X)));\n\t\t}else{\n\t\t\tres.push_back(L(l1.pos+l1.dir, l2.pos+l2.dir - (l1.pos+l1.dir)));\n\t\t\tl1 = rotate(l1, -rad*2);\n\t\t\tl2 = rotate(l2, -rad*2);\n\t\t\tres.push_back(L(l1.pos+l1.dir, l2.pos+l2.dir - (l1.pos+l1.dir)));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint n;\nvector<pair<C, C> > jewel;\n\n\nint solve(L l){\n\tint res = 0;\n\tREP(i, jewel.size()){\n\t\tdouble d = lp_distance(l, jewel[i].first.p);\n\t\tif(jewel[i].first.r < d+EPS && d-EPS < jewel[i].second.r) res ++;\n\t}\n\treturn res;\n}\n\nmain(){\n\twhile(cin >> n, n){\n\t\tjewel.clear();\n\t\tREP(i, n){\n\t\t\tint x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tjewel.emplace_back(C(P(x, y), r), C(P(x, y), r+m));\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, n)REP(j, i){\n\t\t\tREP(k, 4){\n\t\t\t\tC &c1 = (k&1) ? jewel[i].first : jewel[i].second;\n\t\t\t\tC &c2 = (k&2) ? jewel[j].first : jewel[j].second;\n\t\t\t\tvector<L> cand = CCCommonTangent(c1, c2);\n\t\t\t\tREP(l, cand.size()) {\n\t\t\t\t\tans = max(ans, solve(cand[l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(v) v.begin(),v.end()\n\nnamespace Geometry{\n    using namespace std;\n    using ld=long double;\n    using Point=complex<ld>;\n    using P=Point;\n    \n    struct Line{\n        Point a,b;\n    };\nusing L=Line;\n    struct Circle{\n        Point p;\n        ld r;\n    };\n    using C=Circle;\n    const ld EPS=1e-9;\n    const ld eps=EPS;\n    inline bool EQ(Point a,Point b){return abs(a-b)<EPS;}\n    ld dot(Point a,Point b){return real(a)*real(b)+imag(a)*imag(b);}\n    ld cross(Point a,Point b){return real(a)*imag(b)-imag(a)*real(b);}\nvector<Line> tangent_cp(Circle c,Point p){\n        vector<Line> res;\n        Point v=c.p-p;\n        ld d=abs(v);\n        if(abs(d-c.r)<EPS){\n            Point dir=v*Point(0,1);\n            res.push_back(Line{p,p+dir});\n            return res;\n        }\n        if(d<c.r){\n            return res;\n        }\n        ld l=sqrt(d*d-c.r*c.r);\n        Point v0=v*Point(l/d,c.r/d);\n        Point v1=v*Point(l/d,-c.r/d);\n        res.push_back(Line{p,p+v0});\n        res.push_back(Line{p,p+v1});\n        return res;\n    }\n\n\n    vector<Line> tangent_cc(Circle c0,Circle c1){\n        vector<Line> res;\n        if(abs(c1.p-c0.p)>c0.r+c1.r-EPS){\n            Point mp=(c0.p*c1.r+c1.p*c0.r)/(c0.r+c1.r);\n            res=tangent_cp(c0,mp);\n        }\n        if(abs(c1.r-c0.r)>EPS){\n            Point om=(-c0.p*c1.r+c1.p*c0.r)/(c0.r-c1.r);\n            auto ret=tangent_cp(c0,om);\n            res.insert(res.end(),ret.begin(),ret.end());\n        }\n        else{\n            Point v=c1.p-c0.p;\n            ld d=abs(v);\n            Point p0=c0.p+v*Point(0,c0.r/d);\n            Point p1=c0.p+v*Point(0,-c0.r/d);\n            res.push_back(Line{p0,p0+v});\n            res.push_back(Line{p1,p1+v});\n        }        \n        return res;\n    }\n\n    ld dist_lp(Line l,Point p){\n        Point x=l.b-l.a;\n        Point y=p-l.a;\n        return abs(cross(x,y))/abs(x);\n    }\n}\n\n\nusing namespace Geometry;\n\nint solve(int n){\n    vector<Point> xy(n);\n    vector<ld> r(n);\n    vector<ld> m(n);\n    vector<Circle> cs;\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y>>r[i]>>m[i];\n        xy[i]={x,y};\n        cs.push_back(Circle{xy[i],r[i]});\n        cs.push_back(Circle{xy[i],r[i]+m[i]});\n    }\n    int res=1;\n    for(int i=0;i<cs.size();i++){\n        for(int j=0;j<i;j++){\n            if(cs[i].p==cs[j].p) continue;\n            auto ls=tangent_cc(cs[i],cs[j]);\n            for(int l=0;l<ls.size();l++){\n                int sc=0;\n                for(int k=0;k<n;k++){\n                    ld d=dist_lp(ls[l],xy[k]);\n                    if(r[k]-(1e-5)<d && d<r[k]+m[k]+(1e-5)){\n                        sc++;\n                    }\n                    res=max(sc,res);\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+r[i]*cos(j)) * tan(M_PI/2 + j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*for(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-(r[i]+m[i])*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+( r[i] + m[i] )*cos(j)) * tan(M_PI/2 + j) - y[i] - (r[i] + m[i]) * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\n\nconst double EPS=1e-9;\nconst double INF=1e10;\nconst double PI = M_PI;\n// ?????¢?????????\nstruct Point{\n    Point(double x, double y):x(x) ,y(y){}\n    Point(){}\n    double x,y;\n};\nPoint operator+(const Point &a, const Point &b){\n    return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b){\n    return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, const double b){\n    return Point(a.x * b, a.y * b);\n}\nPoint operator/(const Point &a, const double b){\n    return Point(a.x / b, a.y / b);\n}\ndouble cross(const Point &a, const Point &b){\n    return a.x * b.y - a.y * b.x;\n}\ndouble dot(const Point &a, const Point &b){\n    return a.x * b.x + a.y * b.y;\n}\nbool operator<(const Point &a, const Point &b){\n    return make_pair(a.x, a.y) < make_pair(b.x, b.y);\n}\ndouble norm(const Point &a){\n    return dot(a, a);\n}\ndouble abs(const Point &a){\n    return sqrt(norm(a));\n}\nPoint rotate90(const Point &a){\n    return Point(-a.y, a.x);\n}\nstruct Line:vector<Point>{\n    Line(Point a = Point(0,0), Point b = Point(0,0)){\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\nstruct Circle: Point{\n    double r;\n    Circle(Point p = Point(0,0), double r=0):Point(p),r(r){}\n};\nvector<Point> tangentCP(const Circle &c, const Point &p){\n    double x = norm(p - c);\n    double d = x - c.r * c.r;\n    if(d < -EPS) return vector<Point>();\n    d = max(d, 0.0);\n    Point q1 = (p - c) * (c.r * c.r / x);\n    Point q2 = rotate90((p - c) * (-c.r * sqrt(d) / x));\n    vector<Point> ret;\n    ret.push_back(c + q1 - q2);\n    ret.push_back(c + q1 + q2);\n    return ret;\n}\nvector<Line> tangentCC(const Circle &a, const Circle &b){\n    vector<Line> list;\n    if(abs(a.r - b.r) < EPS){ // 2 ?????????????????????\n        Point dir = b - a;\n        dir = rotate90(dir * (a.r / abs(dir)));\n        list.push_back(Line(a + dir, b + dir));\n        list.push_back(Line(a - dir, b - dir));\n    } else {\n        Point p = (a * (-b.r)) + (b * a.r);\n        p = p * (1 / (a.r - b.r));\n        vector<Point> ps = tangentCP(a, p);\n        vector<Point> qs = tangentCP(b, p);\n        for (int i = 0; i < min(ps.size(), qs.size()); ++i)\n            list.push_back(Line(ps[i],qs[i]));\n    }\n    Point p = (a * b.r) + (b * a.r);\n    p = p * (1 / (a.r + b.r));\n    vector<Point> ps = tangentCP(a, p);\n    vector<Point> qs = tangentCP(b, p);\n    for (int i = 0; i < min(ps.size(), qs.size()); ++i)\n        list.push_back(Line(ps[i],qs[i]));\n    return list;\n}\n\nPoint projection(const Line &l, const Point &p){\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);\n    return l[0] + (l[1] - l[0]) * t;\n}\ndouble distance_LP(const Line &l, const Point &p){\n    return abs(p - projection(l, p));\n}\nint Count(const Line &l, const vector<Circle> &c1, const vector<Circle> &c2)\n{\n    const int n = c1.size();\n    int res = 0;\n\n    for (int i = 0; i < n; ++i) {\n        double d = distance_LP(l, Point(c1[i].x, c1[i].y));\n        if ((c1[i].r - d < EPS) && (d - c2[i].r < EPS))\n            ++res;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n\n    while (cin >> N, N) {\n\n        vector<Circle> c1(N), c2(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> c1[i].x >> c1[i].y >> c1[i].r >> c2[i].r;\n            c2[i].r += c1[i].r;\n            c2[i].x = c1[i].x;\n            c2[i].y = c1[i].y;\n        }\n\n        if (N == 1) {\n            cout << \"1\\n\";\n            continue;\n        }\n\n        int res = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i + 1; j < N; ++j) {\n                vector<Line> l1 = tangentCC(c1[i], c1[j]);\n                vector<Line> l2 = tangentCC(c1[i], c2[j]);\n                vector<Line> l3 = tangentCC(c2[i], c1[j]);\n                vector<Line> l4 = tangentCC(c2[i], c2[j]);\n\n                for (auto l : l1)\n                    res = max(res, Count(l, c1, c2));\n                for (auto l : l2)\n                    res = max(res, Count(l, c1, c2));\n                for (auto l : l3)\n                    res = max(res, Count(l, c1, c2));\n                for (auto l : l4)\n                    res = max(res, Count(l, c1, c2));\n            }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// rotate by theta (-pi,+pi)\n// arg will return angle of point\npoint rotate(point p,double theta){\n    double cos_theta = cos(theta),\n           sin_theta = sin(theta);\n    return point(p.real()*cos_theta - p.imag()*sin_theta,\n                 p.real()*sin_theta + p.imag()*cos_theta);\n}\nconst double EPS = 1e-6;\n// 二つの円の共通接線\n//  ふつうは4つ？\nvector<pair<point,point> > common_tangent_of_two_circles(point c1,double r1,point c2,double r2){\n    // shift c2 by c1.\n    point nc = c2 - c1;\n    // c.img == 0\n    double ar = arg(nc);\n    point c = rotate(nc,-ar);\n\n    vector<pair<point,point> > ret;\n    vector<double> xs;\n    for(int sign=-1;sign<=1;sign+=2){\n        xs.push_back((r1*r1 + sign*r1*r2)/c.real());\n    }\n    for(double x1 : xs){\n        double y2 = r1*r1 - x1*x1;\n        if(y2 < EPS) continue; // maybe two circle is crossed\n        for(int sign=-1;sign<=1;sign+=2){\n            double y1 = sign*sqrt(y2);\n            // x1*x + y1*y = r1*r1 is such line\n            point h = point(x1,y1);\n            point t = point(x1+1,(-x1*(x1+1)+r1*r1)/y1); // tekito\n            if(abs(y1) < EPS){\n                t = point(x1,y1);\n            }\n\n            ret.push_back(make_pair(h,t));\n        }\n    }\n    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair<point,point> p){\n            return make_pair(rotate(p.first,ar)+c1,\n                             rotate(p.second,ar)+c1);\n        });\n    return ret;\n}\n\nstruct Jewel {\n    point p;\n    double r;\n    double m;\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true){\n        int N; cin >> N;\n        if(N == 0) break;\n        vector<Jewel> jewels;\n        for(int i=0;i<N;i++){\n            double x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewels.push_back(Jewel{point(x,y),r,m});\n        }\n\n        vector<pair<point,double> > circles;\n        for(auto& j : jewels){\n            circles.push_back(make_pair(j.p,j.r));\n            circles.push_back(make_pair(j.p,j.r + j.m));\n        }\n        int maxi = min(2ll,N);\n        for(int i=0;i<circles.size();i++){\n            int skip = (i%2 == 0)?2:1;\n            for(int j=i+skip;j<circles.size();j++){\n                auto lines = common_tangent_of_two_circles(circles[i].first,circles[i].second,\n                                                           circles[j].first,circles[j].second);\n                for(pair<point,point>& line : lines){\n                    int cnt = 0;\n                    for(auto& jewel : jewels){\n                        double d = dist_line_and_point(line.first,line.second,jewel.p);\n                        if(jewel.r < d + EPS and d < jewel.r + jewel.m + EPS){\n                            cnt++;\n                        }\n                    }\n                    maxi = max(maxi,cnt);\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n \n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP rot90(P p) { return P(-p.y, p.x); }\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n// 円と点\n// pがcの外側にあることを仮定している\nvector<P> tCP(C c, P p) {\n  vector<P> res;\n  D d = abs(c.p - p);\n  if(sig(d,c.r) < 0) return res;\n  D rc = c.r*c.r/d;\n  D rs = sqrt(max(0.0, c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  res.emplace_back(c.p + v*rc + rot90(v)*rs);\n  res.emplace_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  // どちらかの円が他方の円に囲まれているときは外接線は無い\n  if(sig(abs(a.r - b.r), abs(a.p - b.p)) >= 0) return res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  // 円が交差しているときは内接線は無い\n  if(sig(abs(a.r + b.r), abs(a.p - b.p)) > 0) return res;\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCC(C a, C b) {\n  vector<L> res;\n  for(L l : tCCout(a, b)) res.push_back(l);\n  for(L l : tCCin(a, b)) res.push_back(l);\n  return res;\n}\n \nvoid dcircle(double x, double y, double r) {\n  cerr << \"circle(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << r*50 << \");\" << endl;\n}\nvoid dline(double x, double y, double a, double b) {\n  cerr << \"line(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << a*50+1000 << \",\" << b*50+1000 << \");\" << endl;\n}\n \nint main() {\n  for(int N; cin >> N, N; ) {\n    int x[2*N], y[2*N], r[2*N], m[2*N];\n    for(int i = 0; i < N; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      x[N+i] = x[i];\n      y[N+i] = y[i];\n      r[N+i] = r[i] + m[i];\n      // dcircle(x[i], y[i], r[i]);\n    }\n    int ans = 0;\n    for(int i = 0; i < 2*N; ++i) {\n      for(int j = i + 1; j < 2*N; ++j) {\n        vector<L> tangent = tCC(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]));\n        for(L l : tangent) {\n          // cerr << \"L = { { x = \" << l.a.x << \", y = \" << l.a.y << \" }, { \" << l.b.x << \", y = \" << l.b.y << \" } }\" << endl;\n          int tmp = 0;\n          for(int k = 0; k < N; ++k) {\n            D d = dLP(l, P(x[k], y[k]));\n            if(sig(d,r[k]) >= 0 && sig(d, m[k]+r[k]) <= 0) {\n              tmp++;\n            }\n          }\n \n#if 0\n          if(tmp == 6) {\n            dcircle(x[i], y[i], r[i]);\n            dcircle(x[j], y[j], r[j]);\n            dline(l.a.x, l.a.y, l.b.x, l.b.y);\n          }\n#endif\n          ans = max(ans, tmp);\n        }\n      }\n    }\n#if 1\n    if(N == 1) {\n      cout << 1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\ntypedef complex<double> Point;\n#define ALL(x) x.begin(), x.end()\n//幾何 Geometry\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst bool DEBUG = false;\ntypedef complex<double> point;\nistream &operator>>(istream &is, point &p) {\n    double a, b;\n    is >> a >> b;\n    p = point(a, b);\n    return is;\n}\npoint operator*(const point &p, const double &d) { return point(real(p) * d, imag(p) * d); }\nnamespace std {\nbool operator<(const point &a, const point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); }\n}  // namespace std\n\n//直線or線分\nstruct Line : public vector<point> {\n    Line(const point &a, const point &b) {\n        push_back(a);\n        push_back(b);\n    }\n};\ntypedef vector<Line> Lines;\n\ndouble cross(const point &a, const point &b) { return real(a) * imag(b) - imag(a) * real(b); }\ndouble dot(const point &a, const point &b) { return real(a) * real(b) + imag(a) * imag(b); }\nint ccw(point a, point b, point c) {\n    b = b - a;\n    c = c - a;\n    if (cross(b, c) > EPS) return +1;   // counter clockwise\n    if (cross(b, c) < -EPS) return -1;  // clockwise\n    if (dot(b, c) < -EPS) return +2;    // c--a--b on line\n    if (norm(b) < norm(c)) return -2;   // a--b--c on line\n    return 0;\n}\npoint direction(const point &p) {  //同じ向きの単位ベクトル\n    return p / abs(p);\n}\npoint orthogonal(const point &p) {  //法線ベクトル\n    return point(-imag(p), real(p));\n}\n//交差判定\nbool intersectLL(const Line &l1, const Line &l2) {\n    return abs(cross(l1[1] - l1[0], l2[1] - l2[0])) > EPS ||  // non-parallel\n           abs(cross(l1[1] - l1[0], l2[0] - l1[0])) < EPS;    // same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n    return cross(l[1] - l[0], s[0] - l[0]) *  // s[0] is left of l\n               cross(l[1] - l[0], s[1] - l[0]) <\n           EPS;  // s[1] is right of l\n}\nbool intersectLP(const Line &l, const point &p) { return abs(cross(l[1] - p, l[0] - p)) < EPS; }\n//端点に乗ってたらfalse\nbool intersectSP_without_endpoint(const Line &s, const point &p) {\n    if (abs(s[0] - p) < EPS || abs(s[1] - p) < EPS) return false;\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;  // triangle inequality\n}\n\nbool intersectSP(\n    const Line &s,\n    const point &p) {  // verified on 2020/04/03\n                       // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;  // triangle inequality\n}\nbool isOnSegment(const Line &s, const Line &t) {\n    if (intersectSP(s, t[0]) || intersectSP(s, t[1]) || intersectSP(t, s[0]) || intersectSP(t, s[1]))\n        return true;\n    else\n        return false;\n}\nbool isSamePoint(const point &p1, const point &p2) { return abs(p1 - p2) < EPS; }\nbool connectSS(const Line &s, const Line &t) {\n    REP(i, 2)\n    REP(j, 2) {\n        if (s[i] == t[j]) return true;\n    }\n    return false;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点が線分上に乗っている場合はfalseにする\nbool intersectSS_strict(const Line &s, const Line &t) {\n    if (isOnSegment(s, t)) return false;\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n//距離,交点\n//射影 直線lにpから下した垂線との交点\npoint projection(\n    const Line &l,\n    const point &p) {  // verified on 2020/04/03\n                       // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + (l[0] - l[1]) * t;\n}\n//射影 直線lを対象軸としてpと線対称にある点\npoint reflection(const Line &l, const point &p) { return p + (projection(l, p) - p) * 2; }\ndouble distancePP(const point &a, const point &b) { return sqrt(norm(a - b)); }\ndouble distanceLP(const Line &l, const point &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const Line &l, const Line &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m[0]); }\ndouble distanceLS(const Line &l, const Line &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const point &p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(\n    const Line &s,\n    const Line &t) {  // verified on 2020/04/03\n                      // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    if (intersectSS(s, t)) return 0;\n    return min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});\n}\npoint crosspoint(const Line &l, const Line &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0];  // same line\n    if (abs(A) < EPS) assert(false);                // Precondition not satisfied\n    return m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist(point &p1, point &p2) { return abs(p1 - p2); }\n\n//円\nstruct Circle {\n    point c;\n    double r;\n    Circle(const point &c_, double r_) : c(c_), r(r_) {}\n};\n// 2円の交点\nvector<point> crosspointsCC(const Circle &a, const Circle &b) {\n    vector<point> ret;\n    point v = b.c - a.c;\n    double d = abs(v);\n\n    if (d + EPS > a.r + b.r) return ret;\n    if (d < abs(a.r - b.r) + EPS) return ret;\n\n    double x = (a.r * a.r - b.r * b.r + d * d) / (2 * d);\n    double y = sqrt(max(a.r * a.r - x * x, 0.0));\n    point t1 = direction(v) * point(0, 1);\n    point t2 = -t1;\n    point p1 = a.c + direction(v) * x + t1 * y;\n    point p2 = a.c + direction(v) * x + t2 * y;\n    ret.push_back(p1);\n    ret.push_back(p2);\n    return ret;\n}\n//点と円の接線\nvector<point> tanline(const Point &p, const Circle &c) {\n    vector<point> ret;\n    double d = norm(p - c.c);\n    double l = d - c.r * c.r;\n    if (l < -EPS) return ret;\n    if (l <= 0.0) l = 0.0;\n    point cq = (p - c.c) * (c.r * c.r / d);\n    point qs = (p - c.c) * (c.r * sqrt(l) / d) * point(0, 1);\n    point s1 = c.c + cq + qs, s2 = c.c + cq - qs;\n    ret.push_back(s1);\n    ret.push_back(s2);\n}\n// 2円の共通接線 verified on 2020/04/07\nvector<Line> get_common_tangent(Circle a, Circle b) {\n    vector<Line> ret;\n    if (a.r < b.r) swap(a, b);\n    point v = b.c - a.c;\n    double d = abs(v);               //中心間距離\n    if (d - abs(a.r - b.r) > EPS) {  //外接線2本\n        if (abs(a.r - b.r) < EPS) {\n            point dir = direction(v) * a.r * point(0, 1);\n            ret.push_back(Line(a.c + dir, b.c + dir));\n            ret.push_back(Line(a.c - dir, b.c - dir));\n        } else {\n            point p = a.c * -b.r + b.c * a.r;\n            p = p * (1.0 / (a.r - b.r));\n            vector<point> bs = tanline(p, a);\n            vector<point> as = tanline(p, b);\n            REP(i, min(as.size(), bs.size())) { ret.push_back(Line(bs[i], as[i])); }\n        }\n    } else if (d - abs(a.r - b.r) > -EPS) {  //外接線1本\n        point p = v + direction(v) * b.r;    //接点\n        ret.push_back(Line(p, p + direction(v) * point(0, 1)));\n    }\n\n    if (d - (a.r + b.r) > EPS) {  //内接線2本\n        double D = sqrt(max(d * d - (a.r + b.r) * (a.r + b.r), 0.0));\n        double x = D * a.r / (a.r + b.r);\n        double theta = atan(x / a.r);\n        point p1 = a.c + direction(v) * point(cos(theta), sin(theta)) * a.r;\n        point p2 = a.c + direction(v) * point(cos(theta), -sin(theta)) * a.r;\n        Line l1(p1, p1 + direction(v) * point(cos(theta), sin(theta)) * point(0, -1));\n        Line l2(p2, p2 + direction(v) * point(cos(theta), -sin(theta)) * point(0, 1));\n        ret.push_back(l1);\n        ret.push_back(l2);\n        assert(abs(distanceLP(l1, a.c) - a.r) < EPS);\n        assert(abs(distanceLP(l1, b.c) - b.r) < EPS);\n    } else if (d - (a.r + b.r) > -EPS) {\n        point p1 = a.c + direction(v) * a.r;\n        point p2 = p1 + v * point(0, 1);\n        ret.push_back(Line(p1, p2));\n    }\n    return ret;\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])  // lower-hull\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])  // upper-hull\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n// 2点を通る半径Rの円の中心\npair<point, point> get_circle_from_2points(point &p1, point &p2, double R) {\n    double d = dist(p1, p2);\n    double x1 = p1.real(), x2 = p2.real();\n    double y1 = p1.imag(), y2 = p2.imag();\n    if (p1.imag() == p2.imag()) {\n        double x = (x1 + x2) / 2.0;\n        double dy = sqrt(R - d * d / 4);\n        return {{x, y1 + dy}, {x, y1 - dy}};\n    } else {\n        double m = (x1 - x2) / (y2 - y1);\n        double t = sqrt(R * R - d * d / 4);\n        double dx = sqrt((t * t) / (m * m + 1));\n        double dy = sqrt(t * t - dx * dx);\n        double gx = (x1 + x2) / 2;\n        double gy = (y1 + y2) / 2;\n        if (m > EPS) {\n            return {{gx + dx, gy + dy}, {gx - dx, gy - dy}};\n        } else {\n            return {{gx + dx, gy - dy}, {gx - dx, gy + dy}};\n        }\n    }\n}\n//長方形\nstruct Square {\n    double lx, ly, rx, ry;\n    Square(double lx_, double ly_, double rx_, double ry_) : lx(lx_), ly(ly_), rx(rx_), ry(ry_){};\n    bool include(point &p) {\n        return p.real() + EPS >= lx && p.real() - EPS <= rx && p.imag() + EPS >= ly && p.imag() - EPS <= ry;\n    }\n};\n\nstruct Polygon : public vector<point> {\n    // 0->OUT, 1->ON, 2->IN\n    int contains(const point &p) {\n        bool in = false;\n        int N = this->size();\n        for (int i = 0; i < N; i++) {\n            point a = this->at(i) - p;\n            point b = this->at((i + 1) % N) - p;\n            if (imag(a) > imag(b)) {\n                std::swap(a, b);\n            }\n            if (imag(a) <= 0 && 0 < imag(b))\n                if (cross(a, b) < 0) in = !in;\n            if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n        }\n        return in ? 2 : 0;\n    }\n};\n\nint count_jewels(const Line &l, const vector<Circle> &Cs, const vector<double> &ms) {\n    int ret = 0;\n    REP(i, Cs.size()) {\n        Circle c = Cs[i];\n        double m = ms[i];\n        double d = distanceLP(l, c.c);\n        if (c.r - EPS < d && d < c.r + m + EPS) ret++;\n    }\n    return ret;\n}\nvoid test() {\n    Circle c1(point(20, 4), 3);\n    Circle c2(point(-10, -10), 5);\n    vector<Line> ls = get_common_tangent(c1, c2);\n    for (auto l : ls) {\n        cout << l[0] << \" \" << l[1] << endl;\n        double d1 = distanceLP(l, c1.c);\n        double d2 = distanceLP(l, c2.c);\n        cout << d1 << \" \" << d2 << endl;\n    }\n}\nvoid solve() {\n    // test();\n    int N;\n    cin >> N;\n    if (N == 0) exit(0);\n    vector<Circle> Cs, outerCs;\n    vector<double> ms;\n\n    REP(i, N) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        ms.push_back(m);\n        point c(x, y);\n        Cs.push_back(Circle(c, r));\n        outerCs.push_back(Circle(c, r + m));\n    }\n    int ans = 1;\n    //大円同士の共通接線をためす\n    REP(i, N) REP(j, N) {\n        if (i == j) continue;\n        vector<Line> ls = get_common_tangent(outerCs[i], outerCs[j]);\n        for (auto l : ls) {\n            int res = count_jewels(l, Cs, ms);\n            ans = max(ans, res);\n        }\n    }\n\n    //円と大円の共通接線\n    REP(i, N) REP(j, N) {\n        if (i == j) continue;\n        vector<Line> ls = get_common_tangent(Cs[i], outerCs[j]);\n        for (auto l : ls) {\n            int res = count_jewels(l, Cs, ms);\n            ans = max(ans, res);\n        }\n    }\n\n    //円と円の共通接線(一応)\n    REP(i, N) REP(j, N) {\n        if (i == j) continue;\n        vector<Line> ls = get_common_tangent(Cs[i], Cs[j]);\n        for (auto l : ls) {\n            int res = count_jewels(l, Cs, ms);\n            ans = max(ans, res);\n        }\n    }\n\n    //大円同士の交点\n\n    cout << ans << endl;\n}\n\nsigned main() {\n    while (true) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#include<sstream>\n#include<complex>\n#include<cstdio>\n#include<climits>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cctype>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 51\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){return sqrt(norm(a));}\n\nbool pequals(Point a,Point b){ return equals(a.x,b.x) && equals(a.y,b.y); }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl) { return agl*M_PI/180.0; }\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=0):p(p),r(r){}\n};\n\npair<Line,Line> innerTangent(Circle A,Circle B){\n  complex<double> a(A.p.x,A.p.y);\n  complex<double> b(B.p.x,B.p.y);\n\n  double d=abs(b-a);\n  double t=M_PI/2-atan2(A.r+B.r,sqrt(d*d-(A.r+B.r)*(A.r+B.r)));\n  complex<double> l1 = a+(b-a)*polar(A.r/d,-t);\n  complex<double> l2 = b+(a-b)*polar(B.r/d,-t);\n  complex<double> l3 = a+(b-a)*polar(A.r/d, t);\n  complex<double> l4 = b+(a-b)*polar(B.r/d, t);\n\n  return make_pair(Line(Point(l1.real(),l1.imag()),Point(l2.real(),l2.imag())),\n\t\t   Line(Point(l3.real(),l3.imag()),Point(l4.real(),l4.imag())));\n}\n\npair<Line,Line> outerTangent(Circle A,Circle B){\n  complex<double> a(A.p.x,A.p.y);\n  complex<double> b(B.p.x,B.p.y);\n\n  double d=abs(b-a);\n  double ta=acos((A.r-B.r)/d);\n  double tb=M_PI-ta;\n  complex<double> l1 = (b-a)*polar(A.r/d, ta)+a;\n  complex<double> l2 = (b-a)*polar(-B.r/d,-tb)+b;\n  complex<double> l3 = (b-a)*polar(A.r/d,-ta)+a;\n  complex<double> l4 = (b-a)*polar(-B.r/d, tb)+b;\n\n  return make_pair(Line(Point(l1.real(),l1.imag()),Point(l2.real(),l2.imag())),\n\t\t   Line(Point(l3.real(),l3.imag()),Point(l4.real(),l4.imag())));\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\n\n\nint N;\nCircle cs[4*MAX];\nCircle jewels[MAX];\ndouble m[MAX];\n\n\n\nbool check(Line l,int index)\n{\n  double dist = distanceLP(l,jewels[index].p);\n  if(!equals(dist,jewels[index].r) && dist < jewels[index].r)\n    return false;\n  return equals(dist,jewels[index].r) || equals(dist,jewels[index].r+m[index]) || (jewels[index].r < dist && dist < jewels[index].r+m[index]);\n}\n\nint compute(int a,int b)\n{\n  int ret,cnt;\n  ret = cnt = 0;\n  pair<Line,Line> ll = innerTangent(cs[a],cs[b]);\n  Line line = ll.first;\n\n  rep(i,N)cnt += check(line,i);      \n  ret = max(ret,cnt);\n  cnt = 0;\n  line = ll.second;\n\n  rep(i,N)cnt += check(line,i);      \n  ret = max(ret,cnt);\n  cnt = 0;\n  ll = outerTangent(cs[a],cs[b]);\n  line = ll.first;\n  rep(i,N)cnt += check(line,i); \n  ret = max(ret,cnt);\n  cnt = 0;\n\n  line = ll.second;\n  rep(i,N)cnt += check(line,i); \n  ret = max(ret,cnt);\n\n\n  return ret;\n}\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      int index = 0;\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> jewels[i].p.x >> jewels[i].p.y >> jewels[i].r >> m[i];\n\t  cs[index++] = Circle(jewels[i].p,jewels[i].r);\n\t  cs[index++] = Circle(jewels[i].p,jewels[i].r+m[i]);\n\t}\n\n      int ans = 1;\n      for(int i=0;i<2*N;i++)\n\t{\n\t  for(int j=(i%2?i+1:i+2);j<2*N;j++)\n\t    {\n\t      ans = max(ans,compute(i,j));\n\t    }\n\t}\n\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\nconst double EPS = 1e-12;\n\nint cmp(double a, double b) {\n    const double diff = a - b;\n    if(fabs(diff) < EPS) return 0;\n    else if(diff < 0) return -1;\n    else return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct circle/*{{{*/\n{\n  P o;\n  double r;\n  circle() {}\n  circle(const P& p, double x) : o(p), r(x) {}\n\n  // POJ 1375 Intervals\n  // 点 p を通る2つの接線\n  pair<P,P> tangent(const P& p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L*L - r*r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M*(v*polar(1.0, theta)), p + M*(v*polar(1.0, -theta)));\n  }\n\n  pair<line,line> outer_tangent_parallel(const circle &c) const {\n      const P d = o - c.o;\n      const P v = d * P(0, 1) * r / abs(d);\n      return make_pair(line(o+v, c.o+v), line(o-v, c.o-v));\n  }\n\n  pair<line,line> outer_tangent(const circle &c) const {\n      if(cmp(r, c.r) == 0) return outer_tangent_parallel(c);\n      if(r > c.r) return c.outer_tangent(*this);\n      const P d = o - c.o;\n      const double fact = c.r/r - 1;\n      const P base = c.o + d+d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair<line,line> inner_tangent(const circle &c) const {\n      if(r > c.r) return c.inner_tangent(*this);\n      const P d = c.o - o;\n      const double fact = c.r/r + 1;\n      const P base = o + d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // POJ 1418 Viva Confetti\n  // POJ 2149 Inherit the Spheres\n  inline bool intersects(const circle& c) const\n  {\n    return !contains(c) && !c.contains(*this) && cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  inline bool independent(const circle &c) const {\n      return cmp(abs(o-c.o), r+c.r) > 0;\n  }\n\n  pair<P,P> intersection(const circle& c) const\n  {\n    // assert(intersects(c))\n    const double d = abs(o - c.o);\n    const double cos_ = (d*d + r*r - c.r*c.r) / (2*d);\n    const double sin_ = sqrt(r*r - cos_*cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e*P(cos_, sin_), o + e*P(cos_, -sin_));\n  }\n\n  inline bool contains(const circle& c) const\n  {\n    return cmp(abs(o - c.o)+c.r, r) < 0;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return cmp(abs(ln.distance(o)), r) <= 0;\n  }\n\n  inline double distance(const line &ln) const {\n      return abs(ln.distance(o));\n  }\n\n  pair<P,P> intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r*r - d*d);\n    return make_pair(h + l*ab, h - l*ab);\n  }\n};/*}}}*/\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n    if(c1.independent(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inner = c1.inner_tangent(c2);\n        lines.push_back(inner.first);\n        lines.push_back(inner.second);\n    } else if(c1.intersects(c2)) {\n        auto outer = c1.outer_tangent(c2);\n        lines.push_back(outer.first);\n        lines.push_back(outer.second);\n        auto inter = c1.intersection(c2);\n        lines.push_back(line(inter.first, inter.second));\n    } \n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<circle,circle>> jewels;\n    vector<line> lines;\n    for(int i = 0; i < N; ++i) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        const P center(x, y);\n        pair<circle,circle> jewel = make_pair(circle(center, r), circle(center, r+m));\n        for(const auto &other : jewels) {\n            enum_event(jewel.first, other.first, lines);\n            enum_event(jewel.first, other.second, lines);\n            enum_event(jewel.second, other.first, lines);\n            enum_event(jewel.second, other.second, lines);\n        }\n        jewels.push_back(jewel);\n    }\n\n    int ans = 1;\n    for(auto &l : lines) {\n        int cnt = count_if(jewels.begin(), jewels.end(), [&](const pair<circle,circle> &j){\n                return cmp(j.first.r, j.first.distance(l)) <= 0 && \n                cmp(j.second.r, j.second.distance(l)) >= 0;\n                });\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e16;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\nint check(Circle c1,Circle c2,vector<Point>& p,vector<int>& r,vector<int>& m,int N){\n    int res = 0;\n    auto ls = tangent_cc(c1, c2);\n    for(auto l:ls){\n        int tmp = 0;\n        for(int i = 0; i < N;i++){\n            ld d = dist_lp(l,p[i]);\n            if(d > r[i] - eps && d < r[i] + m[i] + eps) tmp++;\n        }\n        res = max(res,tmp);\n    }\n    return res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N, N){\n        vector<Point> p(N);\n        vector<int> r(N),m(N);\n        for(int i = 0; i < N;i++){\n            p[i] = input_point();\n            cin >> r[i] >> m[i];\n            \n        }\n        if(N == 1){\n            cout<< 1 << endl;\n            continue;\n        }\n        int ans = 0;\n        for(int i = 0; i < N;i++){\n            for(int j = i+1; j < N;j++){\n                ans = max(ans,check(Circle(p[i],r[i]),Circle(p[j],r[j]),p,r,m,N));\n                ans = max(ans,check(Circle(p[i],r[i]+m[i]),Circle(p[j],r[j]),p,r,m,N));\n                ans = max(ans,check(Circle(p[i],r[i]),Circle(p[j],r[j]+m[j]),p,r,m,N));\n                ans = max(ans,check(Circle(p[i],r[i]+m[i]),Circle(p[j],r[j]+m[j]),p,r,m,N));\n            }\n        }\n        cout << ans << endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (a.p - b.p)/d;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*v*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*v*P(0, 1)));\n\t} else {\n\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tif(sig(abs(a.r + b.r), abs(a.p - b.p)) >= 0) return res;\n\t\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\tP q = a.p + v*t;\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=i+1; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r>EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan((double)l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Circle> cs;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tPoint p(x, y);\n\t\t\tcs.push_back(Circle{ p, r });\n\t\t\tcs.push_back(Circle{ p, r + m });\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, cs.size())REP(j, i)\n\t\t{\n\t\t\tvector<Line> ls = tangent_cc(cs[i], cs[j]);\n\t\t\tREP(k, ls.size())\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(l, cs.size())\n\t\t\t\t{\n\t\t\t\t\tif (l % 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < -EPS) cnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\n#include <complex>\n#include <cmath>\n#define EPS 1.0e-10\n#define PI 3.1415926535897932384 \n\n// 実数の符号関数\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n//XY座標\n#define X real()\n#define Y imag()\n// 点\ntypedef complex<double> P;\n \n\n// 線分・半直線・直線\nstruct L { P pos, dir; L(P p=P(), P d=P()):pos(p),dir(d){}};\n\n// 多角形\ntypedef vector<P> G;\n \n// 円\nstruct C { P p; double r; C(P q=P(), double R=0):p(q),r(R){}};\n\n// std::norm はabs(p)*abs(p)なので遅い\ninline double norm(P p){\n\treturn p.X*p.X+p.Y*p.Y;\n}\n\n// 二つのベクトルの内積を計算する\ninline double inp(const P& a, const P& b) {\n\treturn (conj(a)*b).X;\n}\n \n// 二つのベクトルの外積を計算する\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a)*b).Y;\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n    P a(r-p), b(s-p);\n    int sgn = signum(outp(a, b));\n    if (sgn != 0)\n        return sgn;\n    if (a.X*b.X < -EPS || a.Y*b.Y < -EPS)\n        return -1;\n    if (norm(a) < norm(b) - EPS)\n        return 1;\n    return 0;\n}\n\n// ベクトルpをベクトルbに射影したベクトルを計算する\ninline P proj(const P& p, const P& b) {\n\treturn b*inp(p,b)/norm(b);\n}\n\n// 点pから直線lに引いた垂線の足となる点を計算する\ninline P perf(const L& l, const P& p) {\n\tL m = L(l.pos - p, l.dir);\n\treturn (p + (m.pos - proj(m.pos, m.dir)));\n}\n \n// 線分sを直線bに射影した線分を計算する\ninline L proj(const L& s, const L& b) {\n\t return (L){perf(b, s.pos), proj(s.dir, b.dir)};\n}\n\ninline double lp_distance(const L& l, const P& p) {\n\treturn abs(outp(l.dir, p-l.pos) / abs(l.dir));\n}\n\nL rotate(L l, double rad){\n\tdouble base = atan2(l.dir.Y, l.dir.X);\n\tdouble d = abs(l.dir);\n\tl.dir = d * P(cos(base+rad), sin(base+rad));\n\treturn l;\n}\n\nvector<L> CCCommonTangent(C c1, C c2){\n\tif(c1.r > c2.r) swap(c1, c2);\n\tdouble d = abs(c1.p-c2.p);\n\tvector<L> res;\n\tif(norm(c1.p - c2.p) < EPS) return res;\n\tif(d + EPS > c1.r + c2.r){\n\t\t// 内接線\n\t\tP crs = (c1.p*c2.r + c2.p*c1.r) / (c1.r + c2.r);\n\t\tdouble rad = asin(c1.r/abs(crs-c1.p));\n\t\tres.push_back(rotate(L(crs, c1.p-crs), rad));\n\t\tres.push_back(rotate(L(crs, c1.p-crs), -rad));\n\t}\n\tif(c1.r + d + EPS > c2.r){\n\t\t// 外接線\n\t\tdouble rad = 0.5*PI+asin((c2.r-c1.r) / d);\n\t\tL l1 = rotate(L(c1.p, (c2.p-c1.p)/abs(c2.p-c1.p)), rad);\n\t\tL l2 = rotate(L(c2.p, (c2.p-c1.p)/abs(c2.p-c1.p)), rad);\n\t\tl1.dir *= c1.r;\n\t\tl2.dir *= c2.r;\n\t\tif(c1.r + d - EPS < c2.r){\n\t\t\tres.push_back(L(l1.pos + l1.dir, P((c1.p - c2.p).Y, (c1.p - c2.p).X)));\n\t\t}else{\n\t\t\tres.push_back(L(l1.pos+l1.dir, l2.pos+l2.dir - (l1.pos+l1.dir)));\n\t\t\tl1 = rotate(l1, -rad*2);\n\t\t\tl2 = rotate(l2, -rad*2);\n\t\t\tres.push_back(L(l1.pos+l1.dir, l2.pos+l2.dir - (l1.pos+l1.dir)));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint n;\nvector<pair<C, C> > jewel;\n\n\nint solve(L l){\n\tint res = 0;\n\tREP(i, jewel.size()){\n\t\tdouble d = lp_distance(l, jewel[i].first.p);\n\t\tif(jewel[i].first.r < d+EPS && d-EPS < jewel[i].second.r) res ++;\n\t}\n\treturn res;\n}\n\nmain(){\n\twhile(cin >> n, n){\n\t\tjewel.clear();\n\t\tREP(i, n){\n\t\t\tint x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tjewel.emplace_back(C(P(x, y), r), C(P(x, y), r+m));\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, n)REP(j, i){\n\t\t\tREP(k, 4){\n\t\t\t\tC &c1 = (k&1) ? jewel[i].first : jewel[i].second;\n\t\t\t\tC &c2 = (k&2) ? jewel[j].first : jewel[j].second;\n\t\t\t\tvector<L> cand = CCCommonTangent(c1, c2);\n\t\t\t\tREP(l, cand.size()) {\n\t\t\t\t\tans = max(ans, solve(cand[l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nstruct Circle {\n  P c;\n  double r;\n  Circle( P c=P(0,0), double r=0 ):c(c),r(r){}\n};\n\nconst double EPS = 1e-8;\n\ndouble dot( P a, P b ){ return a.real() * b.real() + a.imag() * b.imag(); }\n\nP rotate( P v, double rad ){\n  return v * P( cos(rad), sin(rad) );\n}\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n \nP reflect(P p, L l){\n  return p + (proj(p,l) - p) * 2.0;\n}\n \nvector<L> tangentCC( Circle p, Circle q ){\n  vector<L> ret;\n  //内接線\n  P v = q.c - p.c;\n  //cout << v << endl;\n  v = rotate( v, abs(p.r-q.r)<EPS?M_PI/2:asin( abs(p.r-q.r) / abs(v) ) ) / abs(v);\n  // cout << \"rotate : \" << v << endl;\n  L s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );\n  //外接線\n  v = q.c - p.c;\n  if( abs( abs(v) - p.r-q.r ) < EPS ){//外接線一つ\n    P p1 = p.c + v/abs(v) * p.r;\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L(p1,p2) );\n    return ret;\n  } else if( abs(v) - p.r-q.r < EPS ){//外接線なし\n    return ret;\n  }\n  v = rotate( v, asin( (p.r+q.r) / abs(v) ) ) / abs(v);\n  //cout << \"rotate : \" << v << endl;\n  s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );  \n  return ret;\n}\n\nint N;\n\nint main(){\n  while(cin >> N && N){\n    vector<Circle> C;\n    vector<Circle> M;\n    for(int i=0;i<N;i++){\n      int x,y,r,m;\n      cin >> x >> y >> r >> m;\n      C.push_back( Circle( P(x,y), r ) );\n      M.push_back( Circle( P(x,y), r+m ) );\n    }  \n\n\n    vector<L> line;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<L> nl = tangentCC( C[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( C[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n      }\n    }\n\n    if( N < 3 ) {\n      cout << N << endl;\n      continue;\n    }\n\n    int res = 0;\n    for(int i=0;i<(int)line.size();i++){\n      int cnt = 0;\n      //cout << line[i].first << \" - \" << line[i].second << endl;\n      for(int j=0;j<N;j++){\n        double x = abs(C[j].c - proj( C[j].c, line[i] ));        \n        //cout << j << \": \" << x << \"  \"<< C[j].c << \" \" << M[j] << endl;\n        if( C[j].r < x+EPS && x < M[j].r+EPS ) cnt++;\n      }\n      res = max( res, cnt );\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  bool operator < (Point p){return (p.x!=x)?p.x<x:p.y<y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に点tを角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n  //平行でない前提\n  Point intersectionPoint(Line l){\n    return a+(b-a)*((l.b-l.a).cross(l.a-a)/(l.b-l.a).cross(b-a));\n  }\n\n  //射影\n  Point project(Point p){\n    Point base=b-a;\n    Real t=(p-a).dot(base)/base.dot(base);\n    return a+base*t;\n  }\n\n  //p1,p2を通る直線を対称軸として点Qと線対称の座標R\n  Point symmetry(Point Q){\n    return Q+(project(Q)-Q)*2;\n  }\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n\n  Line tangent(Real theta){\n    Point a(r*cos(theta),r*sin(theta));\n    Point b(a.y,-a.x);\n    return Line(p+a,p+a+b);\n  }\n  \n  vector<Line> commonTangent(Circle x){\n    vector<Line>res;\n    \n    x.p=x.p-p;\n    Real a=x.p.arg();\n    /*\n    Real b[2]={(r-x.r),(r+x.r)};\n    for(int i=0;i<2;i++){\n      b[i]/=x.p.norm();\n      if(sgn(b[i],-1.0)<0 || sgn(b[i],1.0)>0)return res;\n      Real c=asin(b[i])-asin(1.0);\n      res.push_back(tangent(a-c));\n      res.push_back(tangent(a+c));\n    }\n    */\n    Real b=(r-x.r)/x.p.norm();\n    if(sgn(b,-1.0)<0 || sgn(b,1.0)>0)return res;\n    Real c=asin(b)-asin(1.0);\n      res.push_back(tangent(a-c));\n      res.push_back(tangent(a+c));\n    b=(r+x.r)/x.p.norm();\n    if(sgn(b,-1.0)<0 || sgn(b,1.0)>0)return res;\n    c=asin(b)-asin(1.0);\n    res.push_back(tangent(a-c));\n    res.push_back(tangent(a+c));\n    \n    return res;\n  }\n  \n};\n\nint n;\nvector<Circle>c;\nvector<Real>m;\n\nvector<Line> enumerate(){\n  vector<Line>res;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      vector<Line>tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r+=m[i];\n      tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r-=m[i];\n    }\n  }\n  return res;\n}\n\nint count(Line l){\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    Real d=l.dist(c[i].p)-c[i].r;\n    cnt+=(sgn(d)>=0 && sgn(d,m[i])<=0);\n  }\n  return cnt;\n}\n\nint main(void){\n\n  while(cin >> n,n){\n    c.resize(n);\n    m.resize(n);\n\n    for(int i=0;i<n;i++)\n      cin >> c[i].p.x >> c[i].p.y >> c[i].r >> m[i];\n    \n    vector<Line>res=enumerate();\n    \n    int cnt=0;\n    for(int i=0;i<res.size();i++){\n      cnt=max(cnt,count(res[i]));\n    }\n    cout << max(1,cnt) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\nconst double eps = 1e-10;\n\ndouble distance_l_p(P a,P b,P c);\ndouble cross(P a,P b);\n\ntypedef struct{P p;double r;}C;\n//OÚü\n//~ÌS_ðÔ_Æ,ÚüÉ½sÈüÅQÂÌ~ÌSðÊéü©çÈéOp`ðl¦éB\n//2_ÔÌ£Æ~Ì¼aÌÖW©çcos(theta)=(r0-r1)/(2_ÔÌ£)ÉÈéB\n// ÆÍ2_Ôðñ¾üªð±Ìthetaª¾¯ñ]³¹éB\npair<Line,Line> external_common_tangent(C a,C b){\n  if (a.r < b.r)swap(a,b);\n  double theta=acos((a.r-b.r)/abs(a.p-b.p));\n  double costheta=cos(theta),sintheta=sin(theta);\n\n  Line ret[2];\n  rep(i,2){\n    P v = b.p-a.p;\n    P va,vb;//vector for circle a,b\n    va.real()=v.real()*costheta-v.imag()*sintheta;\n    va.imag()=v.real()*sintheta+v.imag()*costheta;\n    va/=abs(va);\n    vb=va;\n    va*=a.r;\n    vb*=b.r;\n\n    va+=a.p;\n    vb+=b.p;\n    \n \n    ret[i]=mp(va,vb);\n    sintheta*=-1;\n  }\n\n  return mp(ret[0],ret[1]);\n}\n\n\n//¤ÊàÚü\n//ñÂÌ~ªð··éÆ«Í¶ÝµÈ¢\npair<Line,Line> internal_common_tangent(C a,C b){\n  double theta=acos((a.r+b.r)/abs(a.p-b.p));\n\n  \n  if (-eps<theta && theta<eps){\n    P v=b.p-a.p;\n    Line ret;\n\n    swap(v.real(),v.imag());\n    v.real()*=-1;\n    ret.first=(a.p+b.p)/2.;\n    ret.second=ret.first+v;\n\n    \n    return mp(ret,ret);\n  }\n\n  double costheta=cos(theta),sintheta=sin(theta);\n  Line ret[2];\n  rep(i,2){\n    P v = b.p-a.p;\n    P va,vb;//vector for circle a,b\n    va.real()=v.real()*costheta-v.imag()*sintheta;\n    va.imag()=v.real()*sintheta+v.imag()*costheta;\n    va/=abs(va);\n    vb=va;\n    va*=a.r;\n    vb*=-b.r;\n\n    va+=a.p;\n    vb+=b.p;\n    \n\n    ret[i]=mp(va,vb);\n    sintheta*=-1;\n  }\n  return mp(ret[0],ret[1]);\n}\n\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_l_p(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool checkdist(C a,Line b,double m){\n  double dist =distance_l_p(b.first,b.second,a.p);\n  if (dist+eps < a.r || dist-eps > a.r+m)return false;\n  return true;\n}\n\nvoid output(P a,P b){\n  printf(\"[[%lf,%lf],[%lf,%lf]],\\n\",a.real(),a.imag(),b.real(),b.imag());\n}\n\nvector<Line> find_all(vector<C> &in){\n  vector<Line> ret;\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (abs(in[i].p-in[j].p)<eps)continue;\n      pair<Line,Line> tmp1=external_common_tangent(in[i],in[j]);\n      \n      ret.pb(tmp1.first);\n      ret.pb(tmp1.second);\n      if (abs(in[i].p-in[j].p)-in[i].r-in[j].r>-eps){\n\ttmp1=internal_common_tangent(in[i],in[j]);\n      \n\tret.pb(tmp1.first);\n\tret.pb(tmp1.second);\n      }\n    }\n  }\n  return ret;\n}\n\nint solve(vector<C> a,vector<double> m){\n  int ans = 1;\n  vector<C> check;\n  rep(i,a.size()){\n    check.pb((C){a[i].p,a[i].r});\n    check.pb((C){a[i].p,a[i].r+m[i]});\n  }\n\n  vector<Line> all=find_all(check);\n  \n  \n  \n\n  rep(i,all.size()){\n    int tmp = 0;\n    rep(j,a.size()){\n      if (checkdist(a[j],all[i],m[j]))tmp++;\n    }\n    ans=max(tmp,ans);\n  }\n  return ans;\n}\n\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<C> in;\n    vector<double> M;\n    rep(i,n){\n      double x,y,r,m;cin>>x>>y>>r>>m;\n      in.pb((C){P(x,y),r});\n      M.pb(m);\n    }\n    cout << solve(in,M) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <utility>\n#include <vector>\n#define EPS (1e-10)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nP n_vector(P a){\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nvector<P> cpcc(C a, C b){\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  vector<P> cp(2,m);\n  P n = n_vector(a.first-b.first);\n  cp[0] -= h*n;\n  cp[1] += h*n;\n  return cp;\n}\n\nvector<P> tangent_to_C(P p, C c){\n  C c2 = C((p+c.first)/2.0,abs(p-c.first)/2.0);\n  return cpcc(c,c2);\n}\n\nvector<P> points_of_contact(C a, C b){\n  //???a, b?????±?????\\?????????a?????\\???????±???????\n  vector<P> ret, cp;\n  if(a.second == b.second){\n    P n = n_vector(b.first-a.first);\n    ret.push_back(P(a.first+a.second*n));\n    ret.push_back(P(a.first-a.second*n));\n  }\n  P i = (a.first*b.second+b.first*a.second)/(a.second+b.second);\n  if(abs(a.first-b.first) > a.second+b.second){//4??¬\n    cp = tangent_to_C(i,a);\n    for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);\n    if(a.second != b.second){\n      P e = (a.first*b.second-b.first*a.second)/(b.second-a.second);\n      cp = tangent_to_C(e,a);\n      for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);\n    }\n  }else if(abs(a.first-b.first) == a.second+b.second){//3??¬\n    cp = tangent_to_C(i,a);\n    ret.push_back(cp[0]);\n    if(a.second != b.second){\n      P e = (a.first*b.second-b.first*a.second)/(b.second-a.second);\n      cp = tangent_to_C(e,a);\n      for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);\n    }\n  }else if(abs(a.first-b.first) > abs(a.second-b.second)){//2??¬\n    if(a.second != b.second){\n      P e = (a.first*b.second-b.first*a.second)/(b.second-a.second);\n      cp = tangent_to_C(e,a);\n      for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);\n    }\n  }else if(abs(a.first-b.first) == abs(a.second-b.second)){//1??¬\n    P e = (a.first*b.second-b.first*a.second)/(b.second-a.second);\n    cp = tangent_to_C(e,a);\n    ret.push_back(cp[0]);\n  }\n  sort(ret.begin(), ret.end());\n  return ret;\n}\n\nvector<L> common_tangent(C a, C b){\n  vector<P> p = points_of_contact(a, b);\n  vector<L> ret;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    ret.push_back(L(p[i], p[i]+n_vector(p[i]-a.first)));\n  }\n  return ret;\n}\n\ndouble p_to_l_dist(P a, L s){\n  return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n}\n\nint count(vector<C>& c, vector<double>& m, int s, int t){\n  C a = c[s], b = c[t];\n  vector<L> tangents = common_tangent(a, b);\n  int n = tangents.size(), ret = 0;\n\n  for(int i = 0; i < n; ++i){\n    int cnt = 0;\n    for(int j = 0; j < c.size(); ++j){\n      double d = p_to_l_dist(c[j].first, tangents[i]), r = c[j].second;\n      if(d - r > -EPS && r + m[j] - d > -EPS) ++cnt;\n    }\n    ret = max(ret, cnt);\n  }\n\n  a.second += m[s];\n  b.second += m[t];\n  vector<L> tangents2 = common_tangent(a, b);\n  n = tangents2.size();\n  for(int i = 0; i < n; ++i){\n    int cnt = 0;\n    for(int j = 0; j < c.size(); ++j){\n      double d = p_to_l_dist(c[j].first, tangents2[i]), r = c[j].second;\n      if(d - r > -EPS && r + m[j] - d > -EPS) ++cnt;\n    }\n    ret = max(ret, cnt);\n  }\n\n  return ret;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<C> c;\n    vector<double> m(N);\n    double x, y, r;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y >> r >> m[i];\n      c.push_back(C(P(x,y), r));\n    }\n    if(N == 1){\n      cout << 1 << endl;\n      continue;\n    }\n    int ans = 0;\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n\tans = max(ans, count(c, m, i, j));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define EPS (1e-12)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n    Point operator / ( Point p ) { return Point((x*p.x+y*p.y)/(p.x*p.x+p.y*p.y), (y*p.x-x*p.y)/(p.x*p.x+p.y*p.y)); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble arg(Vector p){ return atan2(p.y, p.x); }\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// verified by 920, 833, uoa2062\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n// 10514\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getTangentPoints(Point p, Circle c){\n  double d = abs(c.c - p);\n  double t = arg(c.c - p);\n  double b = sqrt(d*d - c.r * c.r);\n  double a = asin(c.r / d);\n  Point p1 = p + polar(b, t + a);\n  Point p2 = p + polar(b, t - a);\n  return make_pair(p1, p2);\n}\n\n/*\n return tangent points on c1\n */\nvector<Point> getCommonTangent(Circle c1, Circle c2){\n  vector<Point> tp;\n  Point base = c2.c - c1.c;\n  double l = abs(base);\n  double a = arg(base); // base alpha\n  if ( abs(c1.r - c2.r) < l  ){\n    double th1 = acos((c1.r - c2.r)/l);\n    tp.push_back(c1.c + polar(c1.r, a + th1));\n    tp.push_back(c1.c + polar(c1.r, a - th1));\n    if ( c1.r + c2.r < l ){\n      double th2 = acos((c1.r + c2.r)/l);\n      tp.push_back(c1.c + polar(c1.r, a + th2));\n      tp.push_back(c1.c + polar(c1.r, a - th2));\n    }\n  }\n\n  if ( (equals(l, abs(c1.r - c2.r)) || equals(c1.r + c2.r, 0) ) && !equals(l, 0) ) {\n    tp.push_back(c1.c + polar(c1.r, a));\n  }\n  \n  return tp;\n}\n\nint N;\nCircle C[50];\nCircle T[100]; // target circle\nint M[50];\n\nint solve(){\n // if ( N == 1 ) return 1;\n  vector<Line> L;\n\n  for ( int i = 0; i < N; i++ ) {\n    T[i] = C[i];\n    T[i+N] = Circle(C[i].c, C[i].r + M[i]);\n  }\n\n  for ( int i = 0; i < 2*N-1; i++ ){\n    for ( int j = i+1; j < 2*N; j++ ){\n      vector<Point> ap = getCommonTangent(T[i], T[j]);\n      for ( int k = 0; k < ap.size(); k++ ){\n\tVector v = ap[k] - T[i].c;\n\tv = polar(abs(v), arg(v) + acos(-1)/2.0);\n\tL.push_back(Line(ap[k], ap[k] + v));\n      }\n    }\n  }\n\n  int ans = 0;\n  for ( int l = 0; l < L.size(); l++ ){\n    int cnt = 0;\n    for ( int i = 0; i < N; i++ ){\n      double d = getDistanceLP(L[l], C[i].c);\n      if ( dle(C[i].r, d) && dle(d, C[i].r + M[i]) ) cnt++;\n    }\n    ans = max(ans, cnt);\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    for ( int i = 0; i < N; i++ ){\n      cin >> C[i].c.x >> C[i].c.y >> C[i].r >> M[i];\n    }\n    cout << solve() << endl;\n  }\n\t\t\t  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP rot90(P p) { return P(-p.y, p.x); }\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n// 円と点\n// pがcの外側にあることを仮定している\nvector<P> tCP(C c, P p) {\n  D a = abs(c.p - p);\n  D rc = c.r*c.r/a;\n  D rs = max(0.0, sqrt(c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  vector<P> res;\n  res.push_back(c.p + v*rc + rot90(v)*rs);\n  res.push_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\nbool iCC(C a, C b) {\n  return sig(abs(a.p-b.p), a.r+b.r) < 0;\n}\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  res.emplace_back(at[0], bt[0]);\n  res.emplace_back(at[1], bt[1]);\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  if(sig(a.r + b.r, abs(a.p - b.p)) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    res.emplace_back(a.p + v*a.r + rot90(v), a.p + v*a.r - rot90(v));\n    return res;\n  }\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  res.emplace_back(at[0], bt[0]);\n  res.emplace_back(at[1], bt[1]);\n  return res;\n}\n\nvoid dcircle(double x, double y, double r) {\n  cout << \"circle(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << r*50 << \");\" << endl;\n}\nvoid dline(double x, double y, double a, double b) {\n  cout << \"line(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << a*50+1000 << \",\" << b*50+1000 << \");\" << endl;\n}\n\nint main() {\n  for(int N; cin >> N, N; ) {\n    int x[2*N], y[2*N], r[2*N], m[2*N];\n    for(int i = 0; i < N; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      x[N+i] = x[i];\n      y[N+i] = y[i];\n      r[N+i] = r[i] + m[i];\n      // dcircle(x[i], y[i], r[i]);\n    }\n    int ans = 0;\n    int num = 0;\n    for(int i = 0; i < 2*N; ++i) {\n      for(int j = i + 1; j < 2*N; ++j) {\n        if(iCC(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]))) continue;\n        vector<L> tangent;\n        for(L l : tCCout(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]))) {\n          tangent.push_back(l);\n        }\n        for(L l : tCCin(C(P(x[i], y[i]), r[i] + m[i]), C(P(x[j], y[j]), r[j] + m[j]))) {\n          tangent.push_back(l);\n        }\n        for(L l : tangent) {\n          // cerr << \"L = { { x = \" << l.a.x << \", y = \" << l.a.y << \" }, { \" << l.b.x << \", y = \" << l.b.y << \" } }\" << endl;\n          int tmp = 0;\n          for(int k = 0; k < N; ++k) {\n            D d = dLP(l, P(x[k], y[k]));\n            if(sig(d,r[k]) >= 0 && sig(d, m[k]+r[k]) <= 0) {\n              tmp++;\n            }\n          }\n\n          if(tmp == 6) {\n            // dline(l.a.x, l.a.y, l.b.x, l.b.y);\n          }\n          num++;\n          ans = max(ans, tmp);\n        }\n      }\n    }\n#if 1\n    if(N == 1) {\n      cout << 1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b){};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<double> x(n), y(n), r(n), m(n);\n\t\tvector<Circle> gem;\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i]));\n\t\t\tgem.push_back(Circle(Point(x[i], y[i]), r[i] + m[i]));\n\t\t}\n\t\tvector<Line> ls;\n\t\tREP(i, gem.size())REP(j, i)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tauto tmp = tangent_cc(gem[i], gem[j]);\n\t\t\tREP(k, tmp.size()) ls.push_back(tmp[k]);\n\t\t}\n\t\tint ans = 1;\n\n\t\tREP(i, ls.size())\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tdouble d = dist_lp(ls[i], Point(x[j],y[j]));\n\t\t\t\tif (d - r[j] > -EPS && d - r[j] - m[j] < EPS) cnt++;\n\t\t\t}\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(b - a) < EPS;}\n\nostream &operator<<(ostream &os, const L &a) {\n  os << a.first << \"-\" << a.second;\n  return os;\n}\n\ndouble sq(double a) {return a * a;}\n\nnamespace std{\n  bool operator<(const P &a, const P &b){\n    if(!eq(a.X, b.X)) return a.X < b.X;\n    if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n}\n\n// ツ禿?静?\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// ツ外ツ静?\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// ツ静シツ閉ェabツづ可妥篠つキツづゥツ点xツづ個暗環置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (sig(dot(b, x)) < 0) return BACK;\n    if (sig(abs(b) - abs(x)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\n// ツ静シツ閉ェツづ個ベツクツトツδ?\nP vec(L a) {return a.second - a.first;}\n\n// ツ角ツ度\ndouble arg(P a, P b) {return acos(dot(a, b) / (abs(a) * abs(b)));}\nP polar(double r, double theta) {return P(r * cos(theta), r * sin(theta));}\nP rot(P p, double theta) { return p * polar(1, theta);}\n\n// ツ有ツ古シツ角ツ度\ndouble varg(P a, P b) {\n  double ret = arg(a) - arg(b);\n  if (ret < 0) ret += 2 * PI;\n  if (ret > 2 * PI) ret -= 2 * PI;\n  if (eq(ret, 2 * PI)) ret = 0;\n  return ret;\n}\n\n// ツ偲仰影\nP proj(P a, P b) {return a * dot(a, b) / sq(abs(a));}\nP perp(L l, P p) {return l.first + proj(vec(l), p - l.first);}\nP refl(L l, P p) {return perp(l, p) * 2. - p;}\n \n// ツ古ーツ債キツ板サツ津ィ ツ端ツ点ツづーツ甘慊づ?\nbool iLL(L a, L b) {return !eq(cross(vec(a), vec(b)), 0);}\nbool eqL(L a, L b) {return !iLL(a, b) && eq(cross(vec(a), b.first - a.first), 0);}\nbool iLS(L a, L b) {return sig(cross(vec(a), b.first)) * sig(cross(vec(a), b.second)) <= 0;}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if ((cwaf | cwas | cwbf | cwbs) & ON) return true;\n  return ((cwaf | cwas) & (cwbf | cwbs)) == (LEFT | RIGHT);\n}\n\n// ツ古ーツ点\nP pLL(L a, L b) {\n  P va = vec(a);\n  P vb = vec(b);\n  return a.first + va * (cross(vb, b.first - a.first) / cross(vb, va));\n}\n\n// ツ仰猟猟」\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dLL(L a, L b) {return iLL(a, b) ? 0 : dLP(a, b.first);}\ndouble dLS(L a, L b) {return iLS(a, b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n// ツ板シツ陳シツ静シツ猟債づ敖づ個古ーツ債キツ板サツ津ィ\nbool iLH(L a, L b) {return iLL(a, b) && ccw(b.first, b.second, pLL(a, b)) & (ON | FRONT);}\nbool iHH(L a, L b) {return iLH(a, b) && iLH(b, a);}\nbool iHS(L a, L b) {return iLS(a, b) && iLH(b, a);}\n\n// ツ単ツ暗環ベツクツトツδ?\nP uline(P a) {return a / abs(a);}\n// ツ法ツ静シツベツクツトツδ?\nP nml(P a) {return a * P(0, 1);}\nP nmr(P a) {return a * P(0, -1);}\n// ツ単ツ暗環法ツ静シツベツクツトツδ?\nP unml(P a) {return uline(nml(a));}\nP unmr(P a) {return uline(nmr(a));}\n\n// ツ陳シツ行\nbool orth(P a, P b) {return eq(dot(a, b), 0);}\n// ツ閉スツ行\nbool prll(P a, P b) {return eq(cross(a, b), 0);}\n \n// ツ静シツ閉ェツ拡ツ陳」\nL expandLine(L l, double mag) {\n  L ret = l;\n  P vf(vec(l));\n  P vs(-vs);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\n// ツ円\nstruct C{\n  P c;\n  double r;\n  C() {}\n  C(P c, double r) : c(c), r(r) {}\n};\n\n// ツ陛篠角ツソツーツトツづ可用ツつ「ツづゥツ氾、ツ較ツ甘鳴青?\n// TODO ツづヲツつュツづュツつゥツづァツづア\nbool isRight(P base, P isv) {return eq(cross(base, isv), 0) ? abs(isv) < abs(base) : cross(base, isv) < 0;}\nbool isLeft(P base, P isv) {return eq(cross(base,isv), 0) ? abs(isv) < abs(base) : cross(base,isv) > 0;}\n// ツ角ツ度ツつェツ督卍つオツつ「ツ湘ェツ債?づ債渉?渉伉つェツ暗ェツ津ィツづ?づ債づ按つ「\nbool cmpArg(P a, P b) {return ccw(P(0, 0), a, b) == RIGHT;}\n\n// 2ツ円ツづ個暗環置ツ甘鳴係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_INSIDE_CROSS = 32, TWO_CROSS = 64};\nint cRel(C c1, C c2) {\n  double d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && eq(d, 0)) return SAME;\n  if (sig(d - (c1.r - c2.r)) < 0) return OVER;\n  if (sig(d - (c2.r - c1.r)) < 0) return CONTAIN;\n  if (eq(d, c1.r - c2.r)) return ONE_INSIDE_CROSS;\n  if (eq(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d - (c1.r + c2.r)) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// ツ点ツつェツ円ツづ可甘慊づ慊づェツづゥツつゥ\nbool iCP(C c, P p) {return sig(abs(p - c.c) - c.r) <= 0;}\n// ツ古ーツ債キツ板サツ津ィ\nbool iCL(C c, L l) {return sig(c.r - dLP(l, c.c)) >= 0;}\nbool iCLs(C c, L l) {return sig(c.r - dLP(l, c.c)) > 0;}\nbool iCS(C c, L s) {return sig(c.r - dSP(s, c.c)) >= 0 && sig(c.r - max(abs(s.first - c.c), abs(s.second - c.c))) <= 0;}\n\n// ツ古ーツ点\npair<P, P> pCC(C a, C b) {\n  double d = abs(b.c - a.c);\n  double x = (sq(d) + sq(a.r) - sq(b.r)) / (2 * d);\n  P e = uline(b.c - a.c), w = nml(e) * sqrt(max(sq(a.r) - sq(x), 0.));\n  return make_pair(a.c + e * x - w, a.c + e * x + w);\n}\npair<P, P> pCL(C c, L l) {\n  P h = perp(l, c.c);\n  double d = abs(h - c.c);\n  double y = sqrt(max(sq(c.r) - sq(d), 0.0));\n  P e = uline(vec(l));\n  return make_pair(h - e * y, h + e * y);\n}\n\n// ツ点ツつゥツづァツ円ツづ鳴づ個静堋静シ firstツつェp->c.cツづ可妥篠つオツづ?債カツ堕、\npair<P, P> tCP(C c, P p) {\n  double d2 = sq(abs(p - c.c));\n  double x = sqrt(max(d2 - sq(c.r), 0.));\n  P h = c.c + (p - c.c) * (c.r * c.r / d2);\n  P w = nml(p - c.c) * (x * c.r / d2);\n  return make_pair(h - w, h + w);\n}\n\n// ツ禿アツ円ツづ個仰、ツ津環静堋静シ\nvector<L> tCC(C c1, C c2) {\n  vector<L> res;\n  pair<P, P> pcross, pcross2;\n  double d = abs(c2.c - c1.c);\n\n  int rel = cRel(c1, c2);\n  if (rel & (SAME | CONTAIN | OVER)) return res;\n  \n  //external\n  pcross = pCC(C(c1.c, sqrt(sq(d) - sq(c2.r - c1.r) + sq(c1.r))), c2);\n  pcross2 = pCC(C(c2.c, sqrt(sq(d) - sq(c2.r - c1.r) + sq(c2.r))), c1);\n  res.push_back(L(pcross2.second, pcross.first));\n  res.push_back(L(pcross2.first, pcross.second));\n  if (rel == TWO_CROSS) return res;\n  \n  if (rel & (ONE_INSIDE_CROSS | ONE_CROSS)) {\n    P p = pCC(c1, c2).first;\n    res.push_back(L(p, p + unmr(p - c1.c)));\n    return res;\n  }\n  \n  //internal\n  P In((c2.r * c1.c + c1.r * c2.c) / (c1.r + c2.r));\n  pcross = pCC(C(In, sqrt(sq(abs(c1.c - In)) - (c1.r * c1.r))), c1);\n  res.push_back(L(In, pcross.first));\n  res.push_back(L(In, pcross.second));\n  return res;\n}\n\nvector<C> vc;\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    vc.clear();\n    rep (i, n) {\n      double x, y, r, m;\n      cin >> x >> y >> r >> m;\n      vc.push_back(C(P(x, y), r));\n      vc.push_back(C(P(x, y), r + m));\n    }\n    int res = 1;\n    rep (i, 2 * n) rep (j, 2 * n) {\n      vector<L> t = tCC(vc[i], vc[j]);\n      rep (k, t.size()) {\n\tint r = 0;\n\trep (l, n) {\n\t  if (!iCLs(vc[2 * l], t[k]) && iCL(vc[2 * l + 1], t[k])) ++r;\n\t}\n\tres = max(res, r);\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn make_pair(h - w, h + w);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble x[60];\ndouble y[60];\ndouble r[60];\ndouble m[60];\nvector<pair<Pt,Pt> > p;\nvoid add(Pt a,double ar,Pt b,double br){\n\tPt p1=(a*br+b*ar)/(ar+br);\n\tpair<Pt,Pt> q1=tCP(a,ar,p1);\n\tp.push_back(make_pair(p1,q1.first));\n\tp.push_back(make_pair(p1,q1.second));\n\tif(sig(ar-br)){\n\t\tPt p2=(b*ar-a*br)/(ar-br);\n\t\tpair<Pt,Pt> q2=tCP(a,ar,p2);\n\t\tp.push_back(make_pair(p2,q2.first));\n\t\tp.push_back(make_pair(p2,q2.second));\n\t}else{\n\t\tPt v=(b-a)*Pt(0,1);\n\t\tdouble ks=v.ABS();\n\t\tv=v/ks*ar;\n\t\tp.push_back(make_pair(a+v,b+v));\n\t\tp.push_back(make_pair(a-v,b-v));\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",x+i,y+i,r+i,m+i);\n\t\t}\n\t\tif(a==1){\n\t\t\tprintf(\"1\\n\");continue;\n\t\t}\n\t\tp.clear();\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tadd(Pt(x[i],y[i]),r[i],Pt(x[j],y[j]),r[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i]+m[i],Pt(x[j],y[j]),r[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i],Pt(x[j],y[j]),r[j]+m[j]);\n\t\t\t\tadd(Pt(x[i],y[i]),r[i]+m[i],Pt(x[j],y[j]),r[j]+m[j]);\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble d=dLP(p[i].first,p[i].second,Pt(x[j],y[j]));\n\t\t\t\tif(d+EPS>r[j]&&d-EPS<r[j]+m[j])val++;\n\t\t\t}\n\t\t\tret=max(ret,val);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad < min(bd, c.r)) cros.emplace_back(s[0]);\n    else if (bd < min(ad, c.r)) cros.emplace_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.emplace_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\nGeometory PositioningPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  if (ps.size() <= 2) return ps;\n\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nPoly CapConvexes(Poly pp, Poly qq) {\n#if DEBUG\n  assert (IsConvex(pp));\n  assert (IsConvex(qq));\n#endif\n\n  Poly ret;\n  int a = 0;\n  int b = 0;\n  int aa = 0;\n  int bb = 0;\n  int n = pp.size();\n  int m = qq.size();\n  enum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n  auto forward_a = [&](bool put) {\n    if (put && in == PIN) ret.emplace_back(pp[a]);\n    a = (a+1)%n;\n    aa++;\n  };\n\n  auto forward_b = [&](bool put) {\n    if (put && in == QIN) ret.emplace_back(qq[b]);\n    b = (b+1)%m;\n    bb++;\n  };\n\n  auto intersect_1pt = [](Point &a, Point &b, Point &c, Point &d, Point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n  };\n\n  do {\n    int apre = (a+n-1)%n;\n    int bpre = (b+m-1)%m;\n    double C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n    double A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n    double B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n    Point r;\n    if (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n      if (in == UNKNOWN) aa = bb = 0;\n      ret.emplace_back(r);\n      if (B > 0) in = PIN;\n      else if (A > 0) in = QIN;\n    }\n\n    if (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n      if (in == PIN) forward_b(false);\n      else forward_a(false);\n    } else if (C >= 0) {\n      if (A > 0) forward_a(true);\n      else forward_b(true);\n    } else {\n      if (B > 0) forward_b(true);\n      else forward_a(true);\n    }\n  } while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n  if (in == UNKNOWN) {\n    if (PositioningPoint(qq, pp[0]) != OUTSIDE) return pp;\n    if (PositioningPoint(pp, qq[0]) != OUTSIDE) return qq;\n  }\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nvector<Point> TangentPoints(Circle c, Point p) {\n  vector<Point> ret;\n  double d = abs(c.c-p);\n  if (EQ(d, c.r)) {\n    ret.emplace_back(p);\n    return ret;\n  }\n\n  if (d < c.r) return ret;\n\n  Vec v = (p-c.c)/d*c.r;\n  double t = acos(c.r/d);\n  ret.emplace_back(c.c + rotate(v, t));\n  ret.emplace_back(c.c + rotate(v, -t));\n  return ret;\n}\n\nvector<Line> CommonTangents(Circle p, Circle q) {\n#if DEBUG\n  assert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n  double pr = p.r;\n  double qr = q.r;\n  Point pc = p.c;\n  Point qc = q.c;\n  double d = abs(pc - qc);\n  double dr = abs(pr - qr);\n  double sr = abs(pr + qr);\n\n  vector<Line> ret;\n  if (EQ(d, sr)) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > sr) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    vector<Point> pts = TangentPoints(p, cp);\n    vector<Point> qts = TangentPoints(q, cp);\n    for (int i=0; i<2; i++) {\n      for (int j=0; j<2; j++) {\n        Line l{pts[i], qts[j]};\n        if (IntersectLP(l, cp)) {\n          ret.emplace_back(l);\n        }\n      }\n    }\n  } \n\n  if (EQ(d, dr)) {\n    Point cp = pc + (pc-qc) / (qr-pr) * pr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > dr) {\n    if (EQ(pr, qr)) {\n      Point v = (qc - pc) / d * pr;\n      v *= Point(0, 1);\n      ret.emplace_back(Line{pc+v, qc+v});\n      ret.emplace_back(Line{pc-v, qc-v});\n    } else {\n      Point cp = pc + (qc-pc) * pr / (pr-qr);\n      vector<Point> pts = TangentPoints(p, cp);\n      vector<Point> qts = TangentPoints(q, cp);\n      for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n          Line l{pts[i], qts[j]};\n          if (IntersectLP(l, cp)) {\n            ret.emplace_back(l);\n          }\n        }\n      }\n    }\n  } \n\n  return ret;\n}\n\nint n;\nCircle cs[114][2];\n\nint Count(Line l) {\n  int ret = 0;\n  for (int i=0; i<n; i++) {\n    Point c = cs[i][0].c;\n    double d = abs(proj(l, c)-c);\n    if (GE(d, cs[i][0].r) && GE(cs[i][1].r, d)) ret++;\n  }\n  return ret;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      int x, y;\n      double r, m;\n      scanf(\"%d%d%lf%lf\", &x, &y, &r, &m);\n      Point p(x, y);\n      cs[i][0] = {p, r};\n      cs[i][1] = {p, r+m};\n    }\n\n    int ans = 1;\n    for (int i=0; i<n; i++) {\n      for (int j=i+1; j<n; j++) {\n        for (int p=0; p<2; p++) {\n          for (int q=0; q<2; q++) {\n            vector<Line> ls = CommonTangents(cs[i][p], cs[j][q]);\n            for (Line &l : ls) {\n              ans = max(ans, Count(l));\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\n\nbool equal(double a, double b) { return fabs(a - b) < EPS; }\n\n// テァツつケテ」ツつッテ」ツδゥテ」ツつケ\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// テ・ツ環?ァツョツ? テヲツクツ崚ァツョツ? テ」ツつケテ」ツつォテ」ツδゥテ」ツδシテ・ツ??\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// テヲツッツ氾ィツシツεヲツシツ氾ァツョツ療・ツュツ?\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\n// テ・ツ篠淌ァツつケテ」ツ?凝」ツつ嘉」ツ?ョティツキツ敕ゥツ崢「(テァツオツカテ・ツッツセテ・ツ?、)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2テァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble abs(P a, P b) {\n\treturn abs(a - b);\n}\n// テ」ツδ偲」ツδォテ」ツδ?\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n// テ・ツ?湘ィツァツ?\ndouble arg(const P& z) {\n\treturn atan2(z.y, z.x);\n}\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォ a テ」ツ?ョテ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツつ津ヲツアツづ」ツつ?」ツつ?\nP unit(P a) {\n\treturn a / abs(a);\n}\n// テ」ツδ凖」ツつッテ」ツδ暗」ツδォ a テ」ツ?ョテヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツつ津ヲツアツづ」ツつ?」ツつ?\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0, +1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n// テ・ツ??ァツゥツ?(dot product) : aテ」ツδサb = |a||b|cosテ篠?\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// テ・ツ、ツ姪ァツゥツ?(cross product) : aテδ傭 = |a||b|sinテ篠?\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?(Counter Clock Wise)\n// CW : テヲツ卍づィツィツ暗・ツ崢榲」ツつ?(Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3テァツつケテ」ツ?古」ツ?ゥテ」ツ?。テ」ツつ嘉・ツ崢榲」ツつ甘」ツ?ァテ」ツ?づ」ツつ凝」ツ?凝ィツソツ氾」ツ?? 3テァツつケテ」ツ??テァツ崢エテァツキツ堙」ツ?ォテ、ツケツ療」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?ィテ」ツ?催」ツ?ッ ON テ」ツつ津ィツソツ氾」ツ??\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n\tif( cross(b,c) < -EPS ) return CW;  // CW : テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// テ・ツ篠淌ァツつケテ」ツつ津ィツサツクテ」ツ?ォテァツつケ p テ」ツつ津ィツァツ津・ツコツヲ a (テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)テ」ツ??」ツ?妥・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?淌ァツつケテ」ツつ津ィツソツ氾」ツ??\nP rot(P p, double a){\n\treturn P(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n// テァツつケ a テ」ツつ津ィツサツクテ」ツ?ォテァツつケ b テ」ツつ津ィツァツ津・ツコツヲ angle (テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)テ」ツ??」ツ?妥・ツ崢榲ィツサツ「テ」ツ?陛」ツ?崚」ツ?淌ァツつケテ」ツつ津ィツソツ氾」ツ??\nP rot(P a, P b, double angle){\n\treturn rot(b - a, angle) + a;\n}\n\n// テァツ崢エテァツキツ堙」ツつッテ」ツδゥテ」ツつケ\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\n// テァツ崢エテァツキツ?a テ」ツ?ィテァツ崢エテァツキツ?b テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectLL(const Line& a, const Line& b) {\n\treturn abs(cross(a[1] - a[0], b[1] - b[0])) > EPS || abs(cross(a[1] - a[0], b[0] - a[0])) < EPS;\n}\n// テァツ崢エテァツキツ?l テ」ツ?ィ テァツキツ堙・ツ按?s テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectLS(const Line& l, const Line& s) {\n\treturn cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n// テァツ崢エテァツキツ?l テ、ツクツ甘」ツ?ォテァツつケ p テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool intersectLP(const Line& l, const P& p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n// テァツキツ堙・ツ按?s テ」ツ?ィ テァツキツ堙・ツ按?t テ」ツ?ョテ、ツコツ、テ・ツキツョテ・ツ按、テ・ツョツ?\nbool intersectSS(const Line& s, const Line& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// テァツキツ堙・ツ按?s テ、ツクツ甘」ツ?ォテァツつケ p テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\nP reflection(const Line& l, const P& p) {\n\treturn p + 2 * (projection(l, p) - p);\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLP(const Line& l, const P& p) {\n\treturn abs(p - projection(l, p));\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツ崢エテァツキツ堙」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLL(const Line& l, const Line& m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// テァツ崢エテァツキツ堙」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceLS(const Line& l, const Line& s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n// テァツキツ堙・ツ按?」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\ndouble distanceSS(const Line& s, const Line& t) {\n\tif (intersectSS(s, t)) return 0;\n\tdouble a = min(distanceSP(s, t[0]), distanceSP(s, t[1]));\n\tdouble b = min(distanceSP(t, s[0]), distanceSP(t, s[1]));\n\treturn min(a, b);\n}\n// テ・ツ??」ツつッテ」ツδゥテ」ツつケ\nstruct Circle{\n\tP p;\n\tdouble r;\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n};\n\n// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?古、ツコツ、テ」ツつ湘」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nint is_intersect(const Circle &a, const Circle &b) {\n\tdouble x = a.p.x - b.p.x;\n\tdouble y = a.p.y - b.p.y;\n\tdouble s = a.r + b.r;\n\tdouble d = x * x + y * y;\n\ts *= s;\n\tif( equal(d, s) ) return 1;\n\tif( d > s ) return 0;\n\tdouble r = abs(a.r - b.r);\n\tr *= r;\n\tif( equal(d, r) ) return -1;\n\tif(d > r) return 2;\n\treturn -2;\n}\n\n// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?ョテ・ツ?アテゥツ?堙ヲツ篠・テァツキツ堙」ツつ津ヲツアツづ」ツつ?」ツつ?(テァツオツ静ヲツ楪愿」ツ?ッ res テ」ツ?ォティツソツ氾」ツ??\nvoid common_tangent(Circle a, Circle b, vector<Line> &res) {\n\tif(a.r > b.r) swap(a, b);\n\tdouble d = abs(b.p - a.p);\n\tdouble th;\n\tP v, n;\n\tint t = is_intersect(a, b);\n\t\n\t// 2テ」ツ?、テ」ツ?ョテ・ツ??」ツ?古ァツュツ嘉」ツ?療」ツ??」ツ?ィテ」ツ?催」ツ?ィテ・ツ個?・ツ青ォテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテ・ツ?アテゥツ?堙ヲツ篠・テァツキツ堙」ツ?ェテ」ツ??\n\tif( equal(a.p.x, b.p.x) && equal(a.p.y, b.p.y) && equal(a.r, b.r) ){\n\t\treturn ;\n\t}\n\tif( t == -2 ) return ;\n\t\n\tif(t == 0 || t == 1 || t == 2) {\n\t\tth = asin( (b.r - a.r) / d );\n\t\tv = rot(a.p, b.p, th) - a.p;\n\t\tn = P(-v.y, v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p + n * a.r, b.p + n * b.r) );\n\t\t\n\t\tv = rot(a.p, b.p, -th) - a.p;\n\t\tn = P(v.y, -v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p + n * a.r, b.p + n * b.r) );\n\t}\n\t\n\tif(t == 0) {\n\t\tth = asin( (b.r + a.r) / d );\n\t\tv = rot(a.p, b.p, th) - a.p;\n\t\tn = P(-v.y, v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p - n * a.r, b.p + n * b.r) );\n\t\t\n\t\tv = rot(a.p, b.p, -th) - a.p;\n\t\tn = P(v.y, -v.x);\n\t\tn /= abs(n);\n\t\tres.push_back( Line(a.p - n * a.r, b.p + n * b.r));\n\t}\n\t\n\tif(t == 1) {\n\t\tn = b.p - a.p;\n\t\tn /= abs(n);\n\t\tv = P(-n.y, n.x);\n\t\tres.push_back( Line(a.p + n * a.r, a.p + n * a.r + v) );\n\t}\n\t\n\tif(t == -1) {\n\t\tn = a.p - b.p;\n\t\tn /= abs(n);\n\t\tv = P(-n.y, n.x);\n\t\tres.push_back( Line(a.p + n * a.r, a.p + n * a.r + v) );\n\t}\n}\n\n\nint main(){\n\tint N, x[51], y[51], r[51], m[51];\n\twhile( cin >> N , N ){\n\t\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\n\t\tif( N == 1 ){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<Line> res;\n\t\tfor(int i = 0 ; i < N; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tCircle c1(P(x[i], y[i]), r[i]);\n\t\t\t\tCircle c2(P(x[i], y[i]), r[i] + m[i]);\n\t\t\t\tCircle c3(P(x[j], y[j]), r[j]);\n\t\t\t\tCircle c4(P(x[j], y[j]), r[j] + m[j]);\n\t\t\t\tcommon_tangent(c1, c3, res);\n\t\t\t\tif( m[j] != 0 ) common_tangent(c1, c4, res);\n\t\t\t\tif( m[i] != 0 ) common_tangent(c2, c3, res);\n\t\t\t\tif( m[i] != 0 && m[j] != 0 ) common_tangent(c2, c4, res);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < res.size(); i++){\n\t\t\tLine &l = res[i];\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tdouble d = distanceLP(res[i], P(x[j], y[j]));\n\t\t\t\tif( r[j] <= d + EPS && d - EPS <= r[j] + m[j] ){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint calc(L l){\n  int sum = 0;\n  for(int k=0;k<n;k++){\n    if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n      sum++;\n    }\n  }\n  return sum;\n}\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      /* ??????????????£??????\n      vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n      }\n      */\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n      \n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n    }\n  }\n  \n  //pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  \n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      ans = max(ans, calc(L(pv[i], pv[j])));\n    }\n  }  \n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2015/05/29\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P p;\n  double r;\n  C() {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\n// 0:?????¨, 1:?¢????, 2:?????¨\nint contain(C c, P p) {\n  if(abs(c.p - p) - c.r <  -eps) return 2;\n  if(abs(c.p - p) - c.r >  eps) return 0;\n  return 1;\n}\n\n// ??????????§???¢????????¨/?¢????/?????¨???????????????????????????????????????\n// 0:?????¨, 1:?¢????, 2:?????¨\n// by Spaghetti Source\nint contain(const vector<P> &g, const P &p) {\n  int n = g.size();\n  int in = 0;\n  for(int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() < eps && eps < b.imag() && cross(a, b) < -eps) in = !in;\n    if(abs(cross(a, b)) < eps && dot(a, b) < eps) return 1;\n  }\n  return in * 2;\n}\n\n// ????????¨????????????????????????\n// T??????L????????????????????£???????????????true???????????????\n// ??????????????????????????´?????? <= ??? < ????????´?????????????????????????????????\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// ??´?????¨????????????????????????????????????????????°???\nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.p);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// ?????¨?????????????????????\n//  0 : ?????????????????????\n//  1 : ?????¨??§1?????¨??\\??????\n//  2 : 2?????§??????\n// -1 : ??????????????\\??????\n// -2 : ?????¨?????????\nint isIntersect(C a, C b) {\n  double x = a.p.real() - b.p.real();\n  double y = a.p.imag() - b.p.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// ??´?????¨??´???????????????\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross ????¬??????¢?????????\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// ??´?????¨???????????????\nvector<P> getCrossPLC(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.p);\n  double dist = getDistanceLP(s1, s2, c.p);\n  if (equals(dist, c.r)) {\n    v.push_back(p);\n  } else if (dist < c.r) {\n    double h = abs(p - c.p);\n    double d = sqrt(c.r * c.r - h * h);\n    P base = s2 - s1;\n    // push_back?????????????????????\n    v.push_back(p - d * base / abs(base));\n    v.push_back(p + d * base / abs(base));\n  }\n  return v;\n}\n\n// ?????¨???????????????\nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.p - c2.p);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.p - c1.p;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.p + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.p + A*base + h*n);\n    v.push_back(c1.p + A*base - h*n);\n  }\n  return v;\n}\n\n// 2????????????????????????????§?(0 <= rad <= PI)\n// AOJ2233??§?????°??£????????§??´??°(2015/05/29)\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\n// a -> b ???????§????????§???????(0 <= rad < 2*PI)\ndouble getAngleVector(P a, P b) {\n  double A = arg(a);\n  double B = arg(b);\n  double rad = B-A;\n  rad = fmod(rad, M_PI*2.0);\n  if(rad < 0.0) rad += M_PI*2.0;\n  return rad;\n}\n\n// 2????????´????????\\????????????r??????\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = arg(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.p = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// ??????????????¬????????¨??????????§???¢???3????????????????????¢???????±???????\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// ????§???¢?????¢???(?¬??????????)\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\ndouble getTriArea(P a, P b, P c) {\n  return cross(b-a, c-a) / 2.0;\n}\n\ndouble getSectorArea(P a, P b, C c) {\n  return getAngleVector(a-c.p, b-c.p) * c.r * c.r / 2.0;\n}\n\ndouble getBowArea(P a, P b, C c) { // a,b is a chord of c.\n  return getSectorArea(a, b, c) - getTriArea(a, b, c.p);\n}\n\ndouble getArea(P a, P b, C c) {\n  int d = 1;\n  if(cross(a,b) < 0.0) {\n    d = -1;\n    swap(a, b);\n  }\n  if(cross(a, b) < eps) return 0;\n\n  G t(3);\n  t[0] = P(0, 0), t[1] = a, t[2] = b;\n\n  if(contain(c, t[0]) && contain(c, t[1]) && contain(c, t[2])) {\n    return d * getTriArea(t[0], t[1], t[2]);\n  }\n\n  if(getDistanceSP(t[0], t[1], c.p) - c.r > -eps &&\n     getDistanceSP(t[1], t[2], c.p) - c.r > -eps &&\n     getDistanceSP(t[2], t[0], c.p) - c.r > -eps) {\n    if(cross(t[1] - t[0], c.p - t[0]) > -eps &&\n       cross(t[2] - t[1], c.p - t[1]) > -eps &&\n       cross(t[0] - t[2], c.p - t[2]) > -eps) {\n      return d * (c.r * c.r * M_PI);\n    } else {\n      return 0;\n    }\n  }\n\n  double S = c.r * c.r * M_PI;\n  vector<P> cp(6);\n  vector<int> exist(6);\n  for(int i = 0; i < 3; ++i) {\n    P p = t[i], q = t[(i+1)%3];\n    if(getDistanceLP(p, q, c.p) - c.r > -eps) {\n      if(cross(q - p, c.p - p) < 0) return 0;\n      continue;\n    }\n    if(getDistanceSP(p, q, c.p) - c.r > -eps) continue;\n    vector<P> v = getCrossPLC(t[i], t[(i+1)%3], c);\n    if(v.size() == 2 && !equals(v[0], v[1])) {\n      S -= getBowArea(v[0], v[1], c);\n      for(int j = 0; j < v.size(); ++j) {\n        int k = (i*2 + j*3) % 6;\n        cp[k] = v[j];\n        exist[k] = true;\n      }\n    }\n  }\n  for(int i = 0; i < 3; ++i) {\n    int a = i*2, b = i*2+1;\n    if(!exist[a] || !exist[b]) continue;\n    if(contain(c, t[i]) == 2 && !equals(cp[a], cp[b])) {\n      S += getBowArea(cp[a], cp[b], c) + getTriArea(t[i], cp[a], cp[b]);\n    }\n  }\n  return S * d;\n}\n\n// ????§???¢??¨????????±?????¨????????¢???(?¬??????????)\ndouble getArea(G g, C c) {\n  int n = g.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += getArea(g[i], g[(i+1)%n], c);\n  }\n  return res;\n}\n\n// ????§???¢????????\\????????????\ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// ?????£?????????????????¨??????????§???¢????????????????????????????????¢?????????\n// O(NlogN)\n// by Ari book\ndouble caliper(const vector<P> &ps) {\n  vector<P> qs = convex_hull(ps);\n  int n = qs.size();\n  if(n == 2) {\n    return abs(qs[0] - qs[1]);\n  }\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k) {\n    if(!(qs[i] < qs[k])) i = k;\n    if(qs[j] < qs[k]) j = k;\n  }\n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(qs[i] - qs[j]));\n    if(cross((qs[(i+1)%n] - qs[i]), (qs[(j+1)%n] - qs[j])) < 0) {\n      i = (i+1)%n;\n    } else {\n      j = (j+1)%n;\n    }\n  }\n  return res;\n}\n\nvector<L> getTangent(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  if (a.p == b.p) return res;\n  P base = b.p - a.p;\n  for (double s = -1; s <= 1; ++++s) {\n    double c, d, ee;\n    ee = norm(base);\n    d = b.r + a.r * s;\n    if (ee - d * d < 0.0) continue;\n    c = sqrt(ee - d * d);\n    if (c < eps) {\n      P v = base * P(0, 1);\n      P m = b.p - base * b.r / abs(base);\n      res.push_back(L(m, m + v));\n    } else {\n      for (double t = -1; t <= 1; ++++t) {\n        P rotate(c / sqrt(ee), d / sqrt(ee) * t);\n        P v = -base * rotate * s;\n        P nv = v / abs(v) * P(0, t);\n        res.push_back(L(a.p + nv * a.r, b.p - nv * b.r * s));\n      }\n    }\n  }\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      double x, y;\n      cin >> x >> y >> r[i] >> m[i];\n      p[i] = P(x, y);\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n        vector<L> tmp;\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n        tmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n        for(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n        double d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n        if((equals(d, r[i]) || d > r[i]) &&\n           (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\n\n\nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool iscrossCL1(Circle c,Line l){\n  if(getDistanceLP(l,c.c)<c.r)return true;\n  return false;\n}\nbool iscrossCL2(Circle c,Line l){\n  if(getDistanceLP(l,c.c)<=c.r)return true;\n  return false;\n}\n\nvector<Line> getLines(Circle a,Circle b){\n  vector<Line> V;\n  if(a.r<b.r)swap(a,b);\n  double d=abs(b.c-a.c),r=a.r/(double)(a.r+b.r);\n  Vector v=(b.c-a.c),v1,v2;\n  double c=sqrt(d*d-(a.r-b.r)*(a.r-b.r));\n  double s;\n  if(b.r==a.r)s=90;\n  else s=(180*asin(c/((a.r-b.r)*d)))/pi;\n  Point p1,p2;\n  //printf(\"%.10f %.10f %.10f\\n\",d,c,s);\n  v=v/abs(v);\n  v1=v*a.r,v2=v*b.r;\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,180+s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,180-s);\n  V.push_back(Line(p1,p2));\n  v=v*d*r;\n  Point p=a.c+v;\n  c=sqrt(abs(v)*abs(v)-a.r*a.r);\n  s=(180*asin(c/abs(v)))/pi;\n  p1=rotationPoint(a.c,a.c+v1,s);\n  p2=rotationPoint(b.c,b.c-v2,s);\n  V.push_back(Line(p1,p2));\n  p1=rotationPoint(a.c,a.c+v1,360-s);\n  p2=rotationPoint(b.c,b.c-v2,360-s);\n  V.push_back(Line(p1,p2));\n\n  return V;\n}\n\nint main()\n{\n  int n,a,b,c,d;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<pair<Circle,Circle> > v;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d;\n      v.push_back(mp(Circle(Point(a,b),c),Circle(Point(a,b),c+d)));\n    }\n    int ans=1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<Line> V;\n\tvector<Line> v1=getLines(v[i].f,v[j].f);\n\tvector<Line> v2=getLines(v[i].f,v[j].s);\n\tvector<Line> v3=getLines(v[i].s,v[j].f);\n\tvector<Line> v4=getLines(v[i].s,v[j].s);\n\tV.insert(V.begin(),v1.begin(),v1.end());\n\tV.insert(V.begin(),v2.begin(),v2.end());\n\tV.insert(V.begin(),v3.begin(),v3.end());\n\tV.insert(V.begin(),v4.begin(),v4.end());\n\tfor(int k=0;k<V.size();k++){\n\t  int sum=0;\n\t  for(int z=0;z<n;z++){\n\t    if(!iscrossCL1(v[z].f,V[k]) && iscrossCL2(v[z].s,V[k]))sum++;\n\t  }\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n    return real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-9;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n    int cnt=0;\n    for(int i=0;i<N;i++){\n        double w=abs(dot(ps[i],v)-c);\n        //cout << w << \": \" << rs[i][0] - eps << \": \" << rs[i][1] + eps<< endl;\n        if (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n        {\n            //cout << \"ok\" << endl;\n            cnt++;\n        }\n        else\n        {\n        //cout << \"ng\" << endl;\n        }\n    }\n     \n    /*\n    if (cnt < 2){\n        cout << cnt << \", \" << v << \", \" << c << endl;\n    }*/\n    ret=max(cnt,ret);\n}\n \nvoid solve(double a, double b, double c, C ans[2])\n{\n    bool sw=false;\n    if (b==0){\n        swap(a,b);\n        sw=true;\n    }\n \n    double s=-a/b;\n    double t=c/b;\n    double p=1+s*s;\n    double q=2*s*t;\n    double r=t*t-1;\n    /*\n    if (q*q-4*p*r<0){\n        cout << \"aaa \" << endl;\n    }*/\n    double x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n    double y0=s*x0+t;\n    double x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n    double y1=s*x1+t;\n    if(!sw){\n        ans[0]=C(x0,y0);\n        ans[1]=C(x1,y1);\n    }\n    else\n    {\n        ans[0]=C(y0,x0);\n        ans[1]=C(y1,x1);\n    }\n}\nvoid exec3(C q, C p, double r)\n{\n    if (abs(q-p)<r-eps){\n        return;\n    }\n \n    C v[2];\n    int cnt;\n    if (abs(q-p)<=r+eps){\n        v[0]=(q-p)/abs(q-p);\n        cnt=1;\n    }\n    else\n    {\n        solve(real(p-q),imag(p-q),r,v);\n        cnt=2;\n    }\n    for(int i=0;i<cnt;i++){\n        double c=dot(v[i],q);\n        exec4(v[i],c);\n    }\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n    if (r1>r2){\n        swap(p1,p2);\n        swap(r1,r2);\n    }\n \n    C q=(r2*p1+r1*p2)/(r1+r2);\n    //cout << \"aaa \" << endl;\n    exec3(q,p1,r1);\n \n    if(r1!=r2){\n        q=(r2*p1-r1*p2)/(r2-r1);\n        //cout << \"bbb \" << endl;\n        exec3(q,p1,r1);\n    }\n    else\n    {\n        C v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n        exec3(p1+v,p1,r1);\n        exec3(p1-v,p1,r1);\n    }\n}\nvoid exec()\n{\n    cin >> N;\n    if(N==0){\n        exit(0);\n    }\n \n    for(int i=0;i<N;i++){\n        int x,y;\n        cin >> x >> y >> rs[i][0] >> rs[i][1];\n        rs[i][1]+=rs[i][0];\n        ps[i]=C(x,y);\n    }\n \n    ret=1;\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            for(int s=0;s<2;s++){\n                for(int t=0;t<2;t++){\n                    exec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n                }\n            }\n        }\n    }\n    cout << ret << endl;\n}\n \nint main() {\n    while(1)\n        exec();\n}\n \n\n\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// dot of a and b\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// cross of a and b\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\t//norm::��Βl��2��\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Circle> c;\n        vector<ld> m(n);\n        for(int i=0;i<n;i++){\n            ld x,y,r;\n            cin>>x>>y>>r>>m[i];\n            c.push_back(Circle(Point(x,y),r));\n        }\n        if(n==1){\n            cout<<1<<endl;\n            continue;\n        }\n        int res=0;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                vector<Line> ls=tangent_cc(c[i],c[j]);\n                for(int k=0;k<(int)ls.size();k++){\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        ld d=dist_lp(ls[k],c[idx].p);\n                        if(c[idx].r<d+eps && d-c[idx].r<m[idx]+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n                ls=tangent_cc(Circle(c[i].p,c[i].r+m[i]),Circle(c[j].p,c[j].r));\n                for(int k=0;k<(int)ls.size();k++){\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        ld d=dist_lp(ls[k],c[idx].p);\n                        if(c[idx].r<d+eps && d-c[idx].r<m[idx]+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n                ls=tangent_cc(Circle(c[i].p,c[i].r),Circle(c[j].p,c[j].r+m[j]));\n                for(int k=0;k<(int)ls.size();k++){\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        ld d=dist_lp(ls[k],c[idx].p);\n                        if(c[idx].r<d+eps && d-c[idx].r<m[idx]+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n                ls=tangent_cc(Circle(c[i].p,c[i].r+m[i]),Circle(c[j].p,c[j].r+m[j]));\n                for(int k=0;k<(int)ls.size();k++){\n                    int tmp=0;\n                    for(int idx=0;idx<n;idx++){\n                        ld d=dist_lp(ls[k],c[idx].p);\n                        if(c[idx].r<d+eps && d-c[idx].r<m[idx]+eps) tmp++;\n                    }\n                    res=max(res,tmp);\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tB operator<(const P& l, const P& r) const{ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\t//Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n\n\t//A dot B\n\tIL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n\tIL int sgn(P a, P b, P c) {\n\t\tif (cross(b - a, c - a) > EPS)return 1;\n\t\tif (cross(b - a, c - a) < -EPS)return -1;\n\t\tif (dot(b - a, c - a) < -EPS)return 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)return -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l) {\n\t\tDCl(a, b, l);\n\t\treturn cross(b - a, p - a) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) {\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) {\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS) return abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS) return abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\n\tIL B is_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn\n\t\t\tabs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls) {\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn cross(a - b, c - b) * cross(a - b, d - b) <EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t\t\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q) {\n\t\tif (is_LS_LS(p, q))return 0;\n\t\treturn min({\n\t\t\tdistance_P_LS(p.fi,q),\n\t\t\tdistance_P_LS(p.se,q),\n\t\t\tdistance_P_LS(q.fi,p),\n\t\t\tdistance_P_LS(q.se,p)\n\t\t});\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_point_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d <EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tD rs = sqrt(rp*rp - rc*rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn{ cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff };\n\t}\n\tIL D ccw(P a, P b, P c) {\n\t\treturn cross(b - a, c - a);\n\t}\n\tIL Poly convex_hull(Poly& p) {\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(ALL(p));\n\t\tREP(i, n) {\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tREP(j, n - 1) {\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly& l, P& p) {\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1) {\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0) {\n\t\t\t\tif (A > -EPS&&C < -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (C < -EPS || A > -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n\t}\n\tIL D convex_area(Poly& l) {\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\tFOR(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tinline vector<L> tangent_line(C c, P p) {\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist > r + EPS) {\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\t{\n\t\t\t\tP e = P(_cos*v.X + _sin*v.Y, -_sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + EPS) {\n\t\t\tP mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist > Rp - Rq + EPS) {\n\t\t\tif (abs(Rp - Rq) < EPS) {\n\t\t\t\tP e = v*P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nIL int check(geo::L l, vector<geo::C>& cd, vector<geo::C>& cm) {\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble d = geo::distance_P_L(cd[i].first, l);\n\t\t//  cout << d << \" \";\n\t\tif (d<cm[i].second + geo::EPS&&d>cd[i].second - geo::EPS)\n\t\t\tres++;\n\t}\n\t//cout << endl;\n\treturn res;\n\n\n}\nint main() {\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::C> cd(N);\n\t\tvector<geo::C> cm(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tcd[i].first = geo::P(x, y);\n\t\t\tcm[i].first = geo::P(x, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d + m;\n\t\t}\n\t\tif (N == 1) {\n\t\t\tif (cm[0].second < geo::EPS)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();  cout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\n#define ISEQ(c) (c).begin(), (c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nnamespace Ps{\n\ttypedef long double D;\n\ttypedef complex<D> P;\n\tconst D EPS = 3*1e-2;\n\tconst D INF = 1e20;\n\n#define X real()\n#define Y imag()\n\n\ttemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\ttemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\n\ttemplate<typename T> double norm(T a){ return a*a;}\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\tint ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t}\n\n\t//浮動小数点modで非負の値のみかえす．\n\tdouble pfmod(double v,double MOD){\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t}\n\n\t//[0,PI)\n\tdouble AbsArg(double a){\n\t  \tdouble ret=pfmod(max(a,-a),2*M_PI);\n\t  \treturn min(ret,2*M_PI-ret);\n\t}\n\t\n}\nusing namespace Ps;\n\n\nnamespace Ls{\n\tstruct L : public vector<P> {\n\t  L(const P &a, const P &b) {\n\t    push_back(a); push_back(b);\n\t  }\n\t};\n\n\t//直線へ射影した時の点\n\tP projection(const L &l, const P &p) {\n\t  D t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\t  return l[0] + t*(l[0]-l[1]);\n\t}\n\n\tD distanceLP(const L &l, const P &p) {\n\t  return abs(p - projection(l, p));\n\t}\n\n}\nusing namespace Ls;\n\n\n\nnamespace std{\n\tbool operator < (const P& a,const P& b){\n    \t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  \t}\n  \tbool operator == (const P& a,const P& b){\n    \t\treturn eq(a,b);\n   \t}\n};\n\nnamespace Cs{\n\tstruct C {\n \t\t P o; D r;\n \t\t C(const P &o,D r) : o(o), r(r) { }\n\t};\n\n\t// 包含関係\n\tenum RELATION{INCOMPARABLE=0,SAME=1,CONTAIN=2,OVER=4};\n\tpair<RELATION,int> cRel(const C& c1,const C& c2){\n\t\tD d=abs(c1.o-c2.o);\n\t\tif(eq(c1.o,c2.o) && eq(c1.r,c2.r))return make_pair(SAME,1<<28);// c1 == c2\n\t\tif(sig(d,c1.r-c2.r)<0)return make_pair(OVER,0); // c2 ⊆ c1\n\t\tif(sig(d,c2.r-c1.r)<0)return make_pair(CONTAIN,0); // c1 ⊆ c2\n\t\tif(sig(d,c1.r-c2.r)==0)return make_pair(OVER,1);// c2 ⊆ c1,1点で接する\n\t\tif(sig(d,c2.r-c1.r)==0)return make_pair(CONTAIN,1);// c1 ⊆ c2,1点で接する\n\t\tif(sig(d,c1.r+c2.r)==0)return make_pair(INCOMPARABLE,1);// 1点で接する\n\t\tif(sig(d,c1.r+c2.r)<0)return make_pair(INCOMPARABLE,2);//  2点で接する\n\t\treturn make_pair(INCOMPARABLE,0);// 交わらない\n\t}\n\n\t// 点p を通る 円c の接点\n\tvector<P> ContactCP(const C& c,const P& p){\n\t\tvector<P> res;\n\t\tD d=abs(c.o-p);\n\t\tif(sig(c.r,d)==0){\n\t\t\tres.push_back(p);return res;\n\t\t}\n\t\tif(sig(c.r,d)>0)return res;\n\n\t\tD theta=acos(c.r/d),phi=arg(p-c.o);\n\t\tres.push_back(c.o + polar(c.r,phi+ theta));res.push_back(c.o + polar(c.r,phi- theta));\t\t\n\t\treturn res;\n\t}\n\n\t//共通接線  仮定：2円は異なる．\n\tvector<L> ContactCC(const C& c1,const C& c2){\n\t\tpair<RELATION,int> rel=cRel(c1, c2);\n\t\tvector<L> res;\n\t\tif(rel.first==SAME)return res;\n\t\tP dir=c2.o - c1.o;\n\t\t//external\n\t\tif(rel.first==INCOMPARABLE || rel.second>0){\n\t\t\tD th=arg(dir),a=acos((c2.r-c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a)));\n\t\t}\n\t\t//internal\n\t\tif(rel.first==INCOMPARABLE && rel.second<2){\n\t\t\tD th=arg(dir),a=acos((c2.r+c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a + M_PI)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a + M_PI)));\n\t\t}\n\t\treturn res;\n\t}\n\n}\nusing namespace Cs;\n\nnamespace std{\n  \tbool operator == (const C& a,const C& b){\n    \treturn cRel(a,b).first==SAME;\n   \t}\n};\n\n\nint main() {\n\t// ifstream cin(\"in\");\n\t// ofstream cout( \"out\" );\n\twhile(true){\n\t\tint N;cin >> N;if(N==0)break;\n\t\tvector<C> cs1,cs2,cs;\n\t\tREP(i,N){\n\t\t\tD x,y,r,m;cin >> x >> y >>r >> m;\n\t\t\tcs1.push_back(C(P(x,y),r));cs2.push_back(C(P(x,y),r+m));\n\t\t\tcs.push_back(C(P(x,y),r));cs.push_back(C(P(x,y),r+m));\n\t\t}\n\n\t\tint Mv=0;if(N==1)Mv=max(Mv,1);\n\t\tREP(i,2*N)REP(j,2*N){\n\t\t\tvector<L> ls=ContactCC(cs[i],cs[j]);\n\t\t\tREP(k,ls.size()){\n\t\t\t\tint c=0;\n\t\t\t\tREP(s,N){\n\t\t\t\t\tD d=distanceLP(ls[k],cs2[s].o);\n\t\t//\t\tcout <<\"d: \"<<i<<\" \"<<j <<\" \"<<s<<\":\"<<distanceLP(ls[k],cs1[s].o)<<endl;\n\t\t\t\t\tif(sig(cs1[s].r,d)<=0 && sig(d,cs2[s].r)<=0)c++;\n\n\t\t\t\t}\n\t\t\t\tMv=max(Mv,c);\n\t\t\t}\n\t\t}\n\n\t\tcout << Mv <<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n// 2円の接線を求める。\nvector<Line> getTangentialLine(Circle a, Circle b)\n{\n\tvector<Line> ret;\n\tP2 v = b.c - a.c;\n\tdouble d = v.length();\n\tdouble bt = v.arg();\n\n\tif (d - abs(a.r - b.r) > EPS) // 外接線2本\n\t{\n\t\tdouble dt = acos((a.r - b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c + P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c + P2::polar(b.r, t2)));\n\t}\n\telse if (d - abs(a.r - b.r) > -EPS) // 外接線1本 (内接)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\tif (d - (a.r + b.r) > EPS) // 内接線2本 (離れている)\n\t{\n\t\tdouble dt = acos((a.r + b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c - P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c - P2::polar(b.r, t2)));\n\t}\n\telse if (d - (a.r + b.r) > -EPS) // 内接線1本 (接している)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\treturn ret;\n}\n\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct xyrm{ P2 p; double r, m; int i; };\n\t\tvector<xyrm> gems;\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(double, x, y, r, m);\n\t\t\tgems.push_back({ P2(x, y), r, m, _ });\n\t\t}\n\t\tint result = 1;\n\t\tfor (auto i : gems) for (auto j : gems)\n\t\t{\n\t\t\t//WRITE(\"i:\", i.i, \"j:\", j.i);\n\t\t\tauto cand0 = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r));\n\t\t\tauto cand1 = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r + j.m));\n\t\t\tauto cand2 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r));\n\t\t\tauto cand3 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r + j.m));\n\n\t\t\tvector<Line> lines = cand0;\n\t\t\tcopy(allof(cand1), back_inserter(lines));\n\t\t\tcopy(allof(cand2), back_inserter(lines));\n\t\t\tcopy(allof(cand3), back_inserter(lines));\n\n\t\t\tfor (auto l : lines)\n\t\t\t{\n\t\t\t\t//WRITE(l.p, l.d);\n\t\t\t\tresult = max<int>(result, count_if(allof(gems), PREDICATE(xyrm, g, inRange(getDistance(l, g.p), g.r, g.r + g.m))));\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst long double eps = 1e-10;\nconst long double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// 以下 幾何部分\ntemplate<class T> bool operator< (T a, T b){return (a-b) < -eps;}\ntemplate<class T> bool operator<=(T a, T b){return (a-b) < eps;}\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P> Pol;\n\n// ソートのキー\nB cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\nB cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\nint ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > 0)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < 0)      return RIGHT;   // clockwise\n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  aとbの線分判定はこれ\n}\n\n// 線分 直線\n\t// 点と直線の距離\n\t// 点と線分の距離\n\t// 直線と直線の距離\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// 交点\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// 点と直線と線分関連の交差判定\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 点と直線と線分関連の距離\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n\n// 円\n// Verify AOJ 1183\n\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//共通内接線\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// 共通外接線\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//接点を共有する接線\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\nint n;\n\nC jewel[110];\nint m[55];\n\nint check(L in){\n\tint res=0;\n\trep(i,n){\n\t\tD dis=dLP(in,jewel[i].c);\n\t\tif(jewel[i].r<=dis && dis<=jewel[i+n].r)\n\t\t\tres++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n ,n){\n\t\tint ans=1;\n\t\trep(i,n){\n\t\t\tC in;\n\t\t\tcin >> in.c.X >> in.c.Y >> in.r;\n\t\t\tjewel[i]=in;\n\t\t\tcin >> m[i];\n\t\t\tin.r+=m[i];\n\t\t\tjewel[i+n]=in;\n\t\t}\n\t\t\n\t\trep(i,2*n)rep(j,i){\n\t\t\tVL lines=common_tan(jewel[i],jewel[j]);\n\t\t\trep(k,lines.size())\n\t\t\t\tans=max(ans,check(lines[k]));\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nelem sq(elem a){ return a*a; }\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// CCW ツδ債バツスツトツつセツつェツ、ツ青クツ度ツづ可づヲツづゥ\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\nint circles_relation(circle c1, circle c2){\n  elem d=abs(c1.c-c2.c);\n  elem r1=c1.r;\n  elem r2=c2.r;\n  if(lt(r1,r2))swap(r1,r2);\n  if(eq(d,r1+r2))return CIRCLE_ONE_CROSS;\n  if(eq(d,r1-r2))return CIRCLE_ONE_INSIDE_CROSS;\n  if(gt(d,r1+r2))return CIRCLE_NO_CROSS;\n  if(lt(d,r1-r2))return CIRCLE_CONTAIN;\n  if(lt(d,r1+r2))return CIRCLE_TWO_CROSS;\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n}\n\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  elem d = abs(c1.c-c2.c);\n  vec ab = c2.c - c1.c;\n  elem k = ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n  point t = k * ab + c1.c;\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  \n  if( eq( x, 0 ) ){\n    p.first = t; return 1;\n  }else{\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    if(ccw(c1.c,c2.c,p.second)==LEFT)swap(p.first,p.second);\n    return 2;\n  }\n}\n\nint circles_tangential( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross,pcross2;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n  }\n  if( rel == CIRCLE_ONE_INSIDE_CROSS ) return 1;\n  if( rel == CIRCLE_ONE_CROSS ) ret[2] = ret[0];\n\n  //external\n  point Ex((r2*c1.c+r1*c2.c)/(r1+r2));\n  elem rEx = sqrt( pow(abs(c1.c-Ex),2.0)-(r1*r1) );\n  intersection_circles( circle(Ex,rEx), c1, pcross );\n  ret[0] = line(Ex,pcross.first);\n  ret[1] = line(Ex,pcross.second);\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  //internal\n  elem rIn1 = sqrt( D*D + r2*r2 );\n  elem rIn2 = sqrt( D*D + r1*r1 );\n  intersection_circles( circle(c1.c, rIn1), c2, pcross );\n  intersection_circles( circle(c2.c, rIn2), c1, pcross2 );\n  ret[2] = line(pcross2.second,pcross.first);\n  ret[3] = line(pcross2.first,pcross.second);\n  return 4;\n}\n\nint circles_tangential2( circle c1, circle c2, line ret[] ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    vec v = p-c1.c;\n    ret[0] = line(p,p+unmr(v));\n    return 1;\n  }\n  \n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // external\n  ret[0] = line(S1_1, S1_1 + rot(u,theta0+theta1) );\n  ret[1] = line(S1_2, S1_2 + rot(u,theta0-theta1) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // internal\n  ret[2] = line(S2, S2 + rot(u,theta0+theta2) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret[3] = line(S2, S2 + rot(u,theta0-theta2) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    circle jewels[n];\n    elem jewels_m[n];\n    circle circles[2*n];\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles[2*i] = circle(point(x,y),r);\n      circles[2*i+1] = circle(point(x,y),m+r);\n      jewels[i] = circle(point(x,y),r);\n      jewels_m[i] = m+r;\n    }\n    \n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i+2; j < 2*n; ++j){\n\tline vl[4];\n\tint line_num = circles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < line_num; ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << l.fr << \" - \" << l.sc << endl;\n\t  for(int m = 0; m < n; ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if( leq(d,jewels_m[m]) && geq(d,jewels[m].r) )++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nstruct C{P p;D r;};\nC c[100];\nD eps=1e-9,PI=acos(-1.0);\nD cro(P a,P b){return imag(conj(a)*b);}\nD verlen(L l,P p){return abs(cro(l.fs-l.sc,p-l.sc)/abs(l.fs-l.sc));}\nint large(D a,D b){\n\tif(abs(a-b)<eps) return 0;\n\tif(a>b) return 1;\n\treturn -1;\n}\nvector<L> tanCP(C c,P p){\n\tint x=large(c.r,abs(p-c.p));\n\tvector<L> ret;\n\tif(x==1) return ret;\n\tif(x==0){\n\t\tret.pb(L(p,p+(c.p-p)*P(0,1)));\n\t\treturn ret;\n\t}\n\tD theta=acos(c.r/abs(p-c.p));\n\tret.pb(L(p,c.p+(p-c.p)/abs(p-c.p)*polar(c.r,theta)));\n\tret.pb(L(p,c.p+(p-c.p)/abs(p-c.p)*polar(c.r,-theta)));\n\treturn ret;\n}\nvector<L> intan(C a,C b){\n\tP p=(a.r*b.p+b.r*a.p)/(a.r+b.r);\n\treturn tanCP(a,p);\n}\nvector<L> outtan(C a,C b){\n\tif(abs(a.r-b.r)<eps){\n\t\tvector<L> ret;\n\t\tP p=(a.p-b.p)/abs(a.p-b.p)*polar(a.r,PI/2);\n\t\tret.pb(L(a.p+p,b.p+p));\n\t\tret.pb(L(a.p-p,b.p-p));\n\t\treturn ret;\n\t}\n\tP p=(a.r*b.p-b.r*a.p)/(a.r-b.r);\n\treturn tanCP(a,p);\n}\nvector<L> tans(C a,C b){\n\tvector<L> ret=intan(a,b),tmp=outtan(a,b);\n\tfor(L l:tmp) ret.pb(l);\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N){\n\t\t\tint x,y,r,m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tc[i].p=P(x,y);\n\t\t\tc[i].r=r;\n\t\t\tc[N+i].p=P(x,y);\n\t\t\tc[N+i].r=r+m;\n\t\t}\n\t\tint ans=1;\n\t\trep(i,2*N) rep(j,i){\n\t\t\tvector<L> ls=tans(c[i],c[j]);\n\t\t\tfor(L l:ls){\n\t\t\t\tint cnt=0;\n\t\t\t\trep(k,N){\n\t\t\t\t\tD d=verlen(l,c[k].p);\n\t\t\t\t\tif(c[k].r<d+eps&&d<c[N+k].r+eps) cnt++;\n\t\t\t\t}\n\t\t\t\tans=max(ans,cnt);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <limits>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double PI = atan2(0.0, -0.0);\nstatic const double EPS = 1e-6;\n\nstruct circle {\n  P center;\n  double radius, mag;\n};\n\n//Q86(x0,y0,r0)068Q86(x1,y1,r1)06EQ711AcA5}DA06EcA5pB9\nvoid tangency(double x0, double y0, double r0, double x1, double y1, double r1, pair<P, P> out[4])\n{\n  const P v(x1 - x0, y1 - y0);\n  const double a0 = arg(v);\n  const double a1 = acos((r0 - r1) / abs(v));\n  out[0] = make_pair(P(x0 + r0 * cos(a0 + a1), y0 + r0 * sin(a0 + a1)), P(x1 + r1 * cos(a0 + a1), y1 + r1 * sin(a0 + a1)));\n  out[1] = make_pair(P(x0 + r0 * cos(a0 - a1), y0 + r0 * sin(a0 - a1)), P(x1 + r1 * cos(a0 - a1), y1 + r1 * sin(a0 - a1)));\n  const double a2 = acos((r0 + r1) / abs(v));\n  out[2] = make_pair(P(x0 + r0 * cos(a0 + a2), y0 + r0 * sin(a0 + a2)), P(x1 + r1 * cos(a0 + a2 + PI), y1 + r1 * sin(a0 + a2 + PI)));\n  out[3] = make_pair(P(x0 + r0 * cos(a0 - a2), y0 + r0 * sin(a0 - a2)), P(x1 + r1 * cos(a0 - a2 + PI), y1 + r1 * sin(a0 - a2 + PI)));\n}\n\ndouble dot(const P& p, const P& q)\n{\n  return p.real()*q.real() + p.imag()*q.imag();\n}\n\ndouble norm2(const P& p)\n{\n  return dot(p, p);\n}\n\nP perpendicular_foot(const P& p, const pair<P,P>& line)\n{\n  const double t = dot(p - line.first, line.first - line.second) / norm2(line.first - line.second);\n  return line.first + t*(line.first-line.second);\n}\n\ndouble distance_point_line(const P& p, const pair<P,P>& line)\n{\n  return abs(p - perpendicular_foot(p, line));\n}\n\n\nint count(const vector<circle>& cs, const pair<P,P>& line)\n{\n  int ans = 0;\n  for (vector<circle>::const_iterator it(cs.begin()); it != cs.end(); ++it) {\n    const double h = distance_point_line(it->center, line);\n    if (it->radius - h <= EPS && h - (it->radius + it->mag) <= EPS) {\n      ans++;\n    }\n  }\n  return ans;\n}\n\nint solve(const vector<circle>& cs)\n{\n  const int N = cs.size();\n  int ans = 1;\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      const circle& c1 = cs[i];\n      const circle& c2 = cs[j];\n      pair<P,P> lines[4];\n\n      tangency(c1.center.real(), c1.center.imag(), c1.radius, c2.center.real(), c2.center.imag(), c2.radius, lines);\n      for (int k = 0; k < 4; k++) {\n        ans = max(ans, count(cs, make_pair(lines[k].first, lines[k].second)));\n      }\n      tangency(c1.center.real(), c1.center.imag(), c1.radius + c1.mag, c2.center.real(), c2.center.imag(), c2.radius, lines);\n      for (int k = 0; k < 4; k++) {\n        ans = max(ans, count(cs, make_pair(lines[k].first, lines[k].second)));\n      }\n      tangency(c1.center.real(), c1.center.imag(), c1.radius, c2.center.real(), c2.center.imag(), c2.radius + c2.mag, lines);\n      for (int k = 0; k < 4; k++) {\n        ans = max(ans, count(cs, make_pair(lines[k].first, lines[k].second)));\n      }\n      tangency(c1.center.real(), c1.center.imag(), c1.radius+c1.mag, c2.center.real(), c2.center.imag(), c2.radius+c2.mag, lines);\n      for (int k = 0; k < 4; k++) {\n        ans = max(ans, count(cs, make_pair(lines[k].first, lines[k].second)));\n      }\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  int N;\n  while (cin >> N && N != 0) {\n    vector<circle> cs(N);\n    for (int i = 0; i < N; i++) {\n      cin >> cs[i].center.real() >> cs[i].center.imag() >> cs[i].radius >> cs[i].mag;\n    }\n    if (N == 1) {\n      cout << 1 << endl;\n    } else {\n      cout << solve(cs) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L {                 /* üª */\n\tdouble angle; // deleteSameLineðgpµÈ¢Àèsv\n\tP p, q;\n\tL(P p, P q) : p(p), q(q), angle(arg(q-p)) {}\n\tbool operator < (const L &l) const { \n\t\treturn angle < l.angle;\n    }\n};\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\n// px\\[gðÀ·êÎ¬»}êéª¸s·éEEE\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tfor(int i=0; i<n; i++){\n\t\tif(imag(res[i].p) > imag(res[i].q)){\n\t\t\tP temp = res[i].p;\n\t\t\tres[i].p = res[i].q;\n\t\t\tres[i].q = temp;\n\t\t}\n\t}\n\tsort(res.begin(), res.end());\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( abs(res[i].angle - (*it).angle) > EPS ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst double EPS = 1e-11;\n\n/*\n * r1 > 0 ===> outer tangent\n * r1 < 0 ===> inner tangent\n * ax + by = c\n */\nvoid circle_tangent(double x0, double y0, double r0,\n\t\t    double x1, double y1, double r1,\n\t\t    double &a, double &b, double &c) {\n  double rd = r0 - r1;\n  // p = ((x1 - x0) + (y1 - y0)i) / (u + (r0 - r1)i)\n  double u = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2) - rd * rd);\n  double alpha = u * u + (r0 - r1) * (r0 - r1);\n  double px = (x1 - x0) * u + (y1 - y0) * (r0 - r1);\n  double py = - (x1 - x0) * (r0 - r1) + (y1 - y0) * u;\n  px /= alpha;\n  py /= alpha;\n  a = py;\n  b = -px;\n  double qx = x0 - r0 * py;\n  double qy = y0 + r0 * px;\n  c = a * qx + b * qy;\n}\n\nint main(void){\n  int n;\n  while (cin >> n && n) {\n    vector<double> x(n), y(n), r(n), m(n);\n    REP(i, 0, n) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n    }\n    int ma = 0;\n    if (n >= 2) {\n    REP(i, 0, n) {\n      REP(j, 0, n) {\n\tint cnt = 0;\n\tdouble a, b, c;\n#define ITSUMONO do {\\\n\tcnt = 0;\\\n\tREP(k, 0, n) {\\\n\t  double dist = abs(a * x[k] + b * y[k] - c) / sqrt(a * a + b * b);\\\n\t  if (dist > r[k] - EPS && dist < r[k] + m[k] + EPS) {\\\n\t    cnt++;\\\n\t  }\\\n\t}\\\n\tma = max(ma, cnt);\\\n\t}while(0)\n\tREP(s1, 0, 2) {\n\t  REP(s2, 0, 2) {\n\t    circle_tangent(x[i], y[i], r[i] + s1 * m[i],\n\t\t\t   x[j], y[j], r[j] + s2 * m[j],\n\t\t       a, b, c);\n\t    ITSUMONO;\n\t    circle_tangent(x[i], y[i], r[i] + s1 * m[i],\n\t\t\t   x[j], y[j], - (r[j] + s2 * m[j]),\n\t\t       a, b, c);\n\t    ITSUMONO;\n\t  }\n\t}\n\t\n      }\n    }\n    } else {\n      ma = 1;\n    }\n    cout << ma << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nstruct Point {\n\tdouble x, y;\n\tdouble distance_from(const Point& that) const;\n\tPoint move(const struct Vector& vec) const;\n};\nstruct Vector {\n\tdouble dx, dy;\n\tVector(const Point& to, const Point& from) : dx{ to.x - from.x }, dy{ to.y - from.y }{};\n\tVector(const double _dx, const double _dy) :dx{ _dx }, dy{ _dy }{};\n\tVector rotate(const struct Angle& angle) const;\n\tdouble length() const;\n};\nstruct Line {\nprivate:\n\tLine(const double _a, const double _b, const double _c) :a{ _a }, b{ _b }, c{ _c }{};\npublic:\n\tdouble a, b, c;\n\tLine(const Point& from, const Point& to) : a{ to.y - from.y }, b{ from.x - to.x }, c{ to.x * from.y - to.y * from.x }{};\n\tLine(const Point& point, const Vector& vec) : Line(point, Point{ point.x + vec.dx, point.y + vec.dy }){};\n\tdouble distance_from(const Point& that) const;\n\tLine shift_cathetus(const double dx) const;\n};\nstruct Angle {\n\tdouble sin, cos;\n\tstatic Angle from_sin(const double sin);\n\tAngle operator+(const Angle& that) const;\n\tAngle operator-(const Angle& that) const;\n\tAngle operator-() const;\n};\nstruct Circle {\n\tPoint center;\n\tdouble radius;\n\tCircle change_radius(const double new_radius) const;\n};\nstd::vector<Line> common_tangent(const Circle& a, const Circle& b) {\n\tstd::vector<Line> result;\n\tconst auto distance = a.center.distance_from(b.center);\n\tif (distance + a.radius <= b.radius || distance + b.radius <= a.radius) return result;\n\tconst auto diff_angle = Angle::from_sin(std::abs(a.radius - b.radius) / distance);\n\tVector vec(a.center, b.center);\n\tresult.push_back(Line(b.center, vec.rotate(diff_angle)).shift_cathetus((a.radius > b.radius) ? b.radius : - b.radius));\n\tresult.push_back(Line(b.center, vec.rotate(-diff_angle)).shift_cathetus((a.radius > b.radius) ? -b.radius : b.radius));\n\tif (distance >= a.radius + b.radius) {\n\t\tconst auto add_angle = Angle::from_sin((a.radius + b.radius) / distance);\n\t\tresult.push_back(Line(b.center, vec.rotate(add_angle)).shift_cathetus(-b.radius));\n\t\tresult.push_back(Line(b.center, vec.rotate(-add_angle)).shift_cathetus(b.radius));\n\t}\n\tif (std::any_of(result.begin(), result.end(), [&a, &b](const Line& l) {return std::abs(l.distance_from(a.center) - a.radius) >= 1e-9 || std::abs(l.distance_from(b.center) - b.radius) >= 1e-9; })) {\n\t\tauto pos_b = b.center.move(vec.rotate(diff_angle));\n\t\tauto line_ba = Line(b.center, vec.rotate(diff_angle));\n\t\tauto pos_b_r = b.center.move(vec.rotate(-diff_angle));\n\t\tauto line_ba_r = Line(b.center, vec.rotate(-diff_angle));\n\t\tstd::vector<std::vector<double>> distances;\n\t\tstd::transform(result.begin(), result.end(), std::back_inserter(distances), [a, b](const Line& l) {return std::vector<double>{l.distance_from(a.center), l.distance_from(b.center)}; });\n\t\tthrow \"???\";\n\t}\n\treturn result;\n}\nstruct Jewel {\n\tCircle circle;\n\tdouble magnet;\n};\nstd::vector<Line> common_tangent(const Jewel& a, const Jewel& b) {\n\tstd::vector<Line> result;\n\tfor (const auto& line : common_tangent(a.circle, b.circle)) result.push_back(line);\n\tfor (const auto& line : common_tangent(a.circle.change_radius(a.magnet + a.circle.radius), b.circle)) result.push_back(line);\n\tfor (const auto& line : common_tangent(a.circle, b.circle.change_radius(b.magnet + b.circle.radius))) result.push_back(line);\n\tfor (const auto& line : common_tangent(a.circle.change_radius(a.magnet + a.circle.radius), b.circle.change_radius(b.magnet + b.circle.radius))) result.push_back(line);\n\treturn result;\n}\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<Jewel> jewels(n); for (auto& j : jewels) std::cin >> j.circle.center.x >> j.circle.center.y >> j.circle.radius >> j.magnet;\n\t\tint max_correctable = 1;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tfor (auto j = 0; j < i; ++j) {\n\t\t\t\tfor (const auto line : common_tangent(jewels[i], jewels[j])) {\n\t\t\t\t\tint count = 2;\n\t\t\t\t\tfor (auto k = 0; k < n; ++k) if (i != k && j != k) {\n\t\t\t\t\t\tauto distance = line.distance_from(jewels[k].circle.center) - jewels[k].circle.radius;\n\t\t\t\t\t\tif (0 <= distance && distance <= jewels[k].magnet) ++count;\n\t\t\t\t\t}\n\t\t\t\t\tmax_correctable = std::max(max_correctable, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << max_correctable << '\\n';\n\t}\n}\n\n\ndouble Line::distance_from(const Point& that) const\n{\n\treturn std::abs(a * that.x + b * that.y + c) / std::sqrt(a * a + b * b);\n}\n\nLine Line::shift_cathetus(const double length) const\n{\n\tconst auto len = std::sqrt(a * a + b * b);\n\tconst auto dx = -a / len * length;\n\tconst auto dy = b / len * length;\n\treturn Line(a, b, c + b * dy - a * dx);\n}\n\ndouble Point::distance_from(const Point& that) const\n{\n\treturn Vector(*this, that).length();\n}\n\nPoint Point::move(const Vector& vec) const\n{\n\treturn Point{ x + vec.dx, y + vec.dy };\n}\n\nVector Vector::rotate(const Angle& angle) const\n{\n\treturn Vector{dx * angle.cos - dy * angle.sin, dx * angle.sin + dy * angle.cos};\n}\n\ndouble Vector::length() const\n{\n\treturn std::sqrt(dx * dx + dy * dy);\n}\n\nAngle Angle::from_sin(const double sin)\n{\n\treturn Angle{ sin, std::sqrt(1 - sin * sin) };\n}\n\nAngle Angle::operator+(const Angle& that) const\n{\n\treturn Angle{ sin * that.cos + cos * that.sin, cos * that.cos - sin * that.sin };\n}\n\nAngle Angle::operator-(const Angle& that) const\n{\n\treturn Angle{ sin * that.cos - cos * that.sin, cos * that.cos + sin * that.sin };\n}\n\nAngle Angle::operator-() const\n{\n\treturn Angle{ -sin, cos };\n}\n\nCircle Circle::change_radius(const double new_radius) const\n{\n\treturn Circle{ center, new_radius };\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\n \nstruct Point{\n    double x,y;\n \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n \nPoint rotate90(const Point &p){ return Point(-p.y,p.x); }\n \nstruct Line{\n    Point s,t;\n    Line(){}\n    Line(Point s,Point t) : s(s),t(t) {}\n};\n \nPoint projection(const Line &l,const Point &p){\n    Point b = l.t-l.s;\n    double t = dot(p-l.s,b)/norm(b);\n    return l.s+b*t;\n}\n \ndouble distanceLP(const Line &l,const Point &p){\n    return abs(p-projection(l,p));\n}\n \nstruct Circle{\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p,double r) : p(p),r(r) {}\n};\n \nvector<Point> tangentCP(const Circle &c,const Point &p){\n    double x = norm(p - c.p);\n    double d = x - c.r*c.r;\n    if(d < -EPS) return vector<Point>();\n    d = max(d, 0.0);\n    Point p1 = (p-c.p)*(c.r*c.r/x);\n    Point p2 = rotate90((p-c.p)*(-c.r*sqrt(d)/x));\n    vector<Point> res;\n    res.push_back(c.p + p1 - p2);\n    res.push_back(c.p + p1 + p2);\n    return res;\n}\n \nvector<Line> tangentCC(const Circle &a,const Circle &b){\n    vector<Line> res;\n    vector<Point> ps,qs;\n    if(abs(b.p-a.p) < EPS) return res;\n    if(abs(a.r - b.r) < EPS){\n        Point dir = b.p-a.p;\n        dir = rotate90(dir*(a.r/abs(dir)));\n        res.push_back(Line(a.p+dir,b.p+dir));\n        res.push_back(Line(a.p-dir,b.p-dir));\n    }else{\n        Point p = a.p*(-b.r) + b.p*a.r;\n        p = p*(1.0/(a.r-b.r));\n        ps = tangentCP(a,p);\n        qs = tangentCP(b,p);\n        int n = ps.size(), m = qs.size();\n        for(int i = 0 ; i < min(n,m) ; i++){\n            res.push_back(Line(ps[i],qs[i]));\n        }\n    }\n    Point p = a.p*b.r + b.p*a.r;\n    p = p*(1.0/(a.r+b.r));\n    ps = tangentCP(a,p);\n    qs = tangentCP(b,p);\n    int n = ps.size(), m = qs.size();\n    for(int i = 0 ; i < min(n,m) ; i++){\n        res.push_back(Line(ps[i],qs[i]));\n    }\n    return res;\n}\n \nstruct Data{\n    Circle c;\n    double m;\n    Data(){}\n};\n \nvector<Line> getTCC(const Point &p1,double r1,\n                    const Point &p2,double r2){\n    Circle c1(p1,r1),c2(p2,r2);\n    vector<Line> res = tangentCC(c1,c2);\n    return res;\n}\n \nint main(){\n    int N;\n    while(cin >> N, N){\n        vector<Data> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].c.p.x >> v[i].c.p.y >> v[i].c.r >> v[i].m;\n            v[i].m += v[i].c.r;\n        }\n        vector<Line> lines;\n        for(int i = 0 ; i < N ; i++){\n            for(int j = i+1 ; j < N ; j++){\n                Point p1 = v[i].c.p, p2 = v[j].c.p;\n                double r1 = v[i].c.r, r2 = v[j].c.r;\n                double m1 = v[i].m, m2 = v[j].m;\n                vector<Line> l;\n                l = getTCC(p1,r1,p2,r2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,r1,p2,m2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,m1,p2,r2);\n                lines.insert(lines.end(),l.begin(),l.end());\n                l = getTCC(p1,m1,p2,m2);\n                lines.insert(lines.end(),l.begin(),l.end());\n            }\n        }\n        int res = 1;\n        for(int i = 0 ; i < (int)lines.size() ; i++){\n            int cnt = 0;\n            for(int j = 0 ; j < N ; j++){\n                double d = distanceLP(lines[i],v[j].c.p);\n                if(le(v[j].c.r,d) && le(d,v[j].m)) cnt++;\n            }\n            res = max(res,cnt);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\n// Circle\nclass C { public: P p; ld r; };\n\nvector<L> tangent_cp(C c, P p) {\n  vector<L> ret;\n  P v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  P v1 = v * P(l / d,  c.r / d);\n  P v2 = v * P(l / d, -c.r / d);\n  ret.push_back(L(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(L(p, p + v2));\n  return ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n  vector<L> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    P center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    P out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<L> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), begin(nret),end(nret));\n  }\n  else {\n    P v = c2.p - c1.p;\n    v /= abs(v);\n    P q1 = c1.p + v * P(0,  1) * c1.r;\n    P q2 = c1.p + v * P(0, -1) * c1.r;\n    ret.push_back(L(q1, q1 + v));\n    ret.push_back(L(q2, q2 + v));\n  }\n  return ret;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n  return abs(p - proj(l, p));\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<C> min_d;\n    vector<C> max_d;\n    vector<L> lines;\n    REP(i,n){\n      ld x,y,r,m;\n      cin>>x>>y>>r>>m;\n      C a = {P(x,y), r};\n      C b = {P(x,y), r+m};\n      min_d.push_back(a);\n      max_d.push_back(b);\n      lines.push_back({P(x+r,y+r),P(x+r,y-r)});\n      lines.push_back({P(x+r+m,y+r+m),P(x+r+m,y-r+m)});\n    }\n    vector<C> all_c = min_d;\n    all_c.insert(end(all_c),begin(max_d),end(max_d));\n    for(C a:all_c) for(C b:all_c) {\n      auto tans = tangent_cc(a,b);\n      lines.insert(end(lines),begin(tans),end(tans));\n    }\n    int mx = 0;\n    for (L l:lines) {\n      int num=0;\n      REP(i,n) {\n        ld dist = dist_lp(l, min_d[i].p);\n        if (min_d[i].r <= dist + eps && dist <= max_d[i].r + eps)\n          ++num;\n      }\n      mx=max(mx,num);\n    }\n    cout<<mx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n//const ll mod = 1000000007;\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1.0L);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint N;\nPoint P[50];\ndouble r[50];\nint m[50];\nCircle C[50][2];\nint ans;\nvoid solve() {\n    ans = 0;\n    for(int i = 0; i < N; i++) {\n        cin >> P[i];\n        cin >> r[i];\n        cin >> m[i];\n        C[i][0] = Circle(P[i], r[i]);\n        C[i][1] = Circle(P[i], r[i] + m[i]);\n    }\n    if(N == 1) {\n        cout << 1 << endl;\n        return;\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < 2; k++) {\n                for(int l = 0; l < 2; l++) {\n                    auto L = tangent(C[i][k], C[j][l]);\n                    for(auto l : L) {\n                        int now = 0;\n                        for(int k = 0; k < N; k++) {\n                            double d = distance(l, P[k]);\n                            if(d > r[k] - EPS and d < r[k] + m[k] + EPS) now++;\n                        }\n                    ans = max(ans, now);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cassert>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<Circle> circles;\n        vector<Circle> jewel;\n        vector<Circle> mag;\n        for(int i=0; i<N; ++i) {\n            ld x, y, r, m;\n            cin >> x >> y >> r >> m;\n            circles.emplace_back(Point(x, y), r);\n            jewel.push_back(circles[circles.size()-1]);\n            if(fabs(m) > eps) {\n                circles.emplace_back(Point(x, y), r+m);\n            }\n            mag.emplace_back(Point(x, y), r+m);\n        }\n        int ans = 0;\n        for(int i=0; i<circles.size(); ++i) {\n            for(int j=i+1; j<circles.size(); ++j) {\n                auto lines = tangent_cc(circles[i], circles[j]);\n                for(auto l : lines) {\n                    int cnt = 0;\n                    for(int k=0; k<N; ++k) {\n                        ld d = dist_lp(l, jewel[k].p);\n                        if(d + eps < jewel[k].r || mag[k].r + eps < d) {\n                            continue;\n                        }\n                        cnt++;\n                    }\n                    ans = max(cnt, ans);\n                }\n            }\n        }\n        cout << (N == 1 ? 1 : ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-5, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(0, 0), b(0, 0) {}\n\tLine(Point _a, Point _b) : a(_a), b(_b) {}\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tassert(d != 0.0);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tres.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> v = is_lc(c, s), res;\n\tfor (size_t k = 0; k < v.size(); k++) {\n\t\tif (ccw(s.a, v[k], s.b) == -2) {\n\t\t\tres.push_back(v[k]);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) return res;\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back((Line) { p, p + v1 });\n\tif (l < eps) return res;\n\tres.push_back((Line) { p, p + v2 });\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back((Line) { q1, q1 + v });\n\t\tres.push_back((Line) { q2, q2 + v });\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<ld> x(N), y(N), r(N), m(N);\n\t\tvector<Circle> cs;\n\t\tvector<Line> en;\n\t\tcs.reserve(100), en.reserve(10000);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> m[i];\n\t\t\tcs.push_back((Circle) { Point(x[i], y[i]), r[i] });\n\t\t\tcs.push_back((Circle) { Point(x[i], y[i]), r[i] + m[i] });\n\t\t}\n\t\tif (N == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N * 2; i++) {\n\t\t\tfor (int j = i + 1; j < N * 2; j++) {\n\t\t\t\tauto tmp = tangent_cc(cs[i], cs[j]);\n\t\t\t\tfor (auto &l : tmp) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tint dist = dist_lp(l, Point(x[k], y[k]));\n\t\t\t\t\t\tif (dist > r[k] - eps && dist < r[k] + m[k] + eps) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (k == i / 2 || k == j / 2) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ten.push_back(l);\n\t\t\t\t\tres = max(res, sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\n#define equals(a,b) (fabs((a)-(b))<EPS)\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tPoint operator +(Point p){\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator -(Point p){\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator *(double a){\n\t\treturn Point (a*x,a*y);\n\t}\n\tPoint operator/(double a){\n\t\treturn Point(x/a,y/a);\n\t}\n\tdouble abs(){\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm(){\n\t\treturn x*x+y*y;\n\t}\n\tbool operator <(const Point &p)const{\n\t\treturn x!=p.x?x<p.x:y<p.y;\n\t}\n\tbool operator ==(const Point &p)const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point pp1,Point pp2){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef Segment Line;\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){\t\t\n\t}\n\tCircle(Point cc,double rr){\n\t\tc=cc;\n\t\tr=rr;\n\t}\n};\n\ndouble norm(Vector v){\n\treturn v.x*v.x+v.y*v.y;\n}\n\ndouble abs(Vector v){\n\treturn sqrt(norm(v));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n\ndouble getDistanceLP(Line l,Point p){\n\treturn abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n}\n\nbool intersect(Circle c,Line l){\n\treturn c.r>=(getDistanceLP(l,c.c));\n}\n\ndouble arg(Vector p){\n\treturn atan2(p.y,p.x);\n}\nVector polar(double a,double r){\n\treturn Point(cos(r)*a,sin(r)*a);\n}\n\nPoint project(Segment s,Point p){\n\tVector base=s.p2-s.p1;\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n\tVector pr=project(l,c.c);\n\tVector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n\tdouble d=abs(c1.c-c2.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r))/(2.0*c1.r*d);\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nvector<Segment> getTangentLine(Circle c1,Circle c2){\n\tvector<Segment> res;\n\tif(c1.r<=0.0 || c2.r<=0.0)return res;\n\tif(c1.r<c2.r)swap(c1,c2);\n\tPoint d=c2.c-c1.c;\n\tdouble cr=abs(d);\n\tif(cr<EPS)return res;\n\tdouble d1=c1.r-c2.r-cr;\n\tif(d1>EPS)return res;\n\tif(fabs(d1)<EPS){\n\t\tpair<Point,Point> tmp=getCrossPoints(c1,c2);\n\t\tres.push_back(Segment(tmp.first,tmp.second));\n\t\treturn res;\n\t}\n\tdouble d3=cr-c1.r-c2.r;\n\tSegment s1;\n\ts1.p1.x=c1.r*(c1.r-c2.r)/cr;\n\ts1.p1.y=sqrt(c1.r*c1.r-s1.p1.x*s1.p1.x);\n\n\ts1.p2.x=c2.r*(c1.r-c2.r)/cr;\n\ts1.p2.y=sqrt(c2.r*c2.r-s1.p2.x*s1.p2.x);\n\ts1.p2.x+=cr;\n\n\tres.push_back(s1);\n\ts1.p1.y=-s1.p1.y;\n\ts1.p2.y=-s1.p2.y;\n\tres.push_back(s1);\n\n\tif(d3>EPS){\n\t\tSegment s2;\n\t\ts2.p1.x=c1.r*(c1.r+c2.r)/cr;\n\t\ts2.p1.y=sqrt(c1.r*c1.r-s2.p1.x*s2.p1.x);\n\n\t\ts2.p2.x=-c2.r*(c1.r+c2.r)/cr;\n\t\ts2.p2.y=-sqrt(c2.r*c2.r-s2.p2.x*s2.p2.x);\n\t\ts2.p2.x+=cr;\n\n\t\tres.push_back(s2);\n\t\ts2.p1.y=-s2.p1.y;\n\t\ts2.p2.y=-s2.p2.y;\n\t\tres.push_back(s2);\n\t}\n\n\tdouble sn=d.y/cr;\n\tdouble cs=d.x/cr;\n\tfor(int i=0;i<res.size();i++){\n\t\tPoint p;\n\t\tp.x=res[i].p1.x*cs-res[i].p1.y*sn+c1.c.x;\n\t\tp.y=res[i].p1.x*sn+res[i].p1.y*cs+c1.c.y;\n\t\tres[i].p1=p;\n\t\tp.x=res[i].p2.x*cs-res[i].p2.y*sn+c1.c.x;\n\t\tp.y=res[i].p2.x*sn+res[i].p2.y*cs+c1.c.y;\n\t\tres[i].p2=p;\n\t}\n\treturn res;\n}\n\nint n;\nCircle jwl[101];\ndouble m[101];\n\nint func(Segment s){\n\tint cnt=0;\n\t//printf(\"%.2f %.2f %.2f %.2f\\n\",s.p1.x,s.p1.y,s.p2.x,s.p2.y);\n\tfor(int i=0;i<n;i++){\n\t\tdouble d=getDistanceLP(s,jwl[i].c);\n\t\t//printf(\"%.2f \",d);\n\t\tif(jwl[i].r-EPS<=d && d<=(jwl[i].r+m[i])+EPS){\n\t\t\tcnt++;\n\t\t}\n\t}\n\t//printf(\"\\n\");\n\treturn cnt;\n}\n\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf%lf%lf%lf\",&jwl[i].c.x,&jwl[i].c.y,&jwl[i].r,&m[i]);\n\t}\n\tint res=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(k==1 || k==3){\n\t\t\t\t\tjwl[i].r+=m[i];\n\t\t\t\t}\n\t\t\t\tif(k==2 || k==3){\n\t\t\t\t\tjwl[j].r+=m[j];\n\t\t\t\t}\n\t\t\t\tvector<Segment> vi=getTangentLine(jwl[i],jwl[j]);\n\t\t\t\tif(k==1 || k==3){\n\t\t\t\t\tjwl[i].r-=m[i];\n\t\t\t\t}\n\t\t\t\tif(k==2 || k==3){\n\t\t\t\t\tjwl[j].r-=m[j];\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<vi.size();l++){\n\t\t\t\t\tres=max(res,func(vi[l]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst double Pi = acos(-1);\nconst double EPS = 1e-9;\nconst int MAX_N = 55;\n\nstruct Circle\n{\n\tdouble x;\n\tdouble y;\n\tdouble r;\n\tCircle() {}\n\tCircle(const double& x, const double& y, const double& r) :x(x), y(y), r(r) {}\n};\n\nstruct Line\n{\n\tdouble A;\n\tdouble B;\n\tdouble C;\n};\n\ndouble squ(const double& x);\n\nvoid common_tangent(const Circle& c1, const Circle& c2);\n\nCircle cir[MAX_N];\ndouble mr[MAX_N];\n\nLine checkL[17 * MAX_N * MAX_N];\nint chcnt;\n\nint C(const int& N, const Line& L);\n\nint main()\n{\n\tvector<int> aans;\n\tint N;\n\twhile (true)\n\t{\n\t\tcin >> N;\n\t\tif (!N) break;\n\n\t\tchcnt = 0;\n\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tcin >> cir[i].x >> cir[i].y >> cir[i].r >> mr[i];\n\t\t\t\n\t\t\tLine& cur = checkL[chcnt++];\n\t\t\tcur.A = -1.0;\n\t\t\tcur.B = 0.0;\n\t\t\tcur.C = cir[i].x + cir[i].r + mr[i] * 0.5;\n\t\t}\n\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < i; ++j)\n\t\t\t{\n\t\t\t\tconst Circle& curi = cir[i];\n\t\t\t\tconst Circle& curj = cir[j];\n\n\t\t\t\tcommon_tangent(curi, curj);\n\t\t\t\tcommon_tangent(Circle(curi.x, curi.y, curi.r + mr[i]), curj);\n\t\t\t\tcommon_tangent(curi, Circle(curj.x, curj.y, curj.r + mr[j]));\n\t\t\t\tcommon_tangent(Circle(curi.x, curi.y, curi.r + mr[i]), Circle(curj.x, curj.y, curj.r + mr[j]));\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < chcnt; ++i)\n\t\t{\n\t\t\tint m = C(N, checkL[i]);\n\t\t\tif (m > ans)\n\t\t\t{\n\t\t\t\tans = m;\n\t\t\t}\n\t\t}\n\n\t\t//cout << ans << '\\n';\n\t\taans.push_back(ans);\n\t}\n\n\tfor (int i = 0; i < aans.size(); ++i)\n\t{\n\t\tcout << aans[i] << '\\n';\n\t}\n\t\n\treturn 0;\n}\n\ndouble squ(const double& x)\n{\n\treturn x * x;\n}\n\nvoid common_tangent(const Circle& c1, const Circle& c2)\n{\n\tdouble tA = c1.x - c2.x;\n\tdouble tB = c1.y - c2.y;\n\n\tdouble m = sqrt(squ(tA) + squ(tB));\n\n\tfor (int i = -1; i <= 1; i += 2)\n\t{\n\t\tfor (int j = -1; j <= 1; j += 2)\n\t\t{\n\t\t\tdouble tC = i * c1.r + j * c2.r;\n\t\t\tdouble k = tC / m;\n\t\t\tif (-1.0 <= k && k <= 1.0)\n\t\t\t{\n\t\t\t\tdouble arcs = asin(k);\n\t\t\t\tdouble test = m * sin(arcs) - tC;\n\t\t\t\tdouble th = arcs - atan2(tA, tB);\n\n\t\t\t\tLine& cur = checkL[chcnt++];\n\t\t\t\tcur.A = c1.r * cos(th);\n\t\t\t\tcur.B = c1.r * sin(th);\n\t\t\t\tcur.C = i * squ(c1.r) - c1.x * cur.A - c1.y * cur.B;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint C(const int& N, const Line& L)\n{\n\tint res = 0;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tconst Circle& cur = cir[i];\n\n\t\tdouble d2 = squ(L.A * cur.x + L.B * cur.y + L.C) / (squ(L.A) + squ(L.B));\n\t\tif (squ(cur.r * (1 - EPS)) <= d2 && d2 <= squ((cur.r + mr[i]) * (1 + EPS)))\n\t\t{\n\t\t\t++res;\n\t\t}\n\t}\n\treturn res;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double EPS = 1e-9;\n\nstruct L : public vector<P> {\n\tL(P a,P b){ push_back(a); push_back(b); }\n};\n\nstruct C{\n\tP p;\n\tdouble r;\n\tC(P p,double r) : p(p) , r(r) {}\n\tC(){}\n};\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\t\n}\nP projection(const L &l,const P &p){\n\tdouble t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(L l,P p){\n\treturn abs(p-projection(l,p));\n}\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < EPS;\n}\n\nvector<L> contact(C p,C q){\n\tvector<L> ret;\n\tif( p.r < q.r ) swap(q,p);\n\tdouble d = abs(p.p-q.p);\n\tP n = q.p - p.p;\n\tn /= abs(n);\n\tif( d + EPS < abs(p.r - q.r)){\n\t\tret.clear();\n\t}else if( eq(d,abs(p.r-q.r)) ){\n\t\tP t,u;\n\t\tt = p.p+p.r*n;\n\t\tu = t+n*P(0,1);\n\t\tret.push_back(L(t,u));\n\t}else{\n\t\tif( !eq(p.r,q.r) ){\n\t\t\tP  t= p.p + (p.r*d/(p.r-q.r))*n;\n\t\t\tlong double theta = asin((p.r-q.r)/d);\n\t\t\tP u = n * P(cos(theta),sin(theta));\n\t\t\tP v = n * P(cos(-theta),sin(-theta)); \n\t\t\tu += t;\n\t\t\tv += t;\n\t\t\tret.push_back(L(t,v));\n\t\t\tret.push_back(L(t,u));\n\t\t}else{\n\t\t\tP t = p.p + n * P(0,1) * p.r;\n\t\t\tP u = p.p - n * P(0,1) * p.r;\n\t\t\tret.push_back(L(t,t+n));\n\t\t\tret.push_back(L(u,u+n));\n\t\t}\n\t\t\n\t\tif( eq(d,p.r+q.r) ) {\n\t\t\tP t,u;\n\t\t\tt = p.p+p.r*n;\n\t\t\tu = t+n*P(0,1);\n\t\t\tret.push_back(L(t,u));\n\t\t}else if( d > q.r + p.r ){\n\t\t\tP  t= p.p + (p.r*d/(p.r+q.r))*n;\n\t\t\tlong double theta = asin((p.r+q.r)/d);\n\t\t\tP u = n * P(cos(theta),sin(theta));\n\t\t\tP v = n * P(cos(-theta),sin(-theta)); \n\t\t\tu += t;\n\t\t\tv += t;\n\t\t\tret.push_back(L(t,v));\n\t\t\tret.push_back(L(t,u));\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble M[100];\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> c;\n\t\tvector<C> X;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,r,m;\n\t\t\tcin >>x  >> y >> r >> m;\n\t\t\tc.push_back(C(P(x,y),r));\n\t\t\tM[i] = m;\n\t\t\tX.push_back(C(P(x,y),r));\n\t\t\tX.push_back(C(P(x,y),r+m));\n\t\t}\n\t\tvector<L> l;\n\t\tfor(int i = 0 ; i < X.size() ; i++){\n\t\t\tfor(int j = i+ 1; j < X.size() ; j++){\n\t\t\t\tvector<L> con = contact(X[i],X[j]);\n\t\t\t\tfor(int k = 0 ; k < con.size() ; k++)\n\t\t\t\t\tl.push_back(con[k]);\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tint sub = 0;\n\t\t\tfor(int j = 0 ; j < c.size() ; j++){\n\t\t\t\t\n\t\t\t\tif( distanceLP(l[i],c[j].p) < c[j].r - EPS ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( distanceLP(l[i],c[j].p) < c[j].r+M[j] + EPS ){\n\t\t\t\t\tsub++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(sub,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n\n  Line tangent(Real theta){\n    Point a(r*cos(theta),r*sin(theta));\n    Point b(a.y,-a.x);\n    return Line(p+a,p+a+b);\n  }\n  \n  vector<Line> commonTangent(Circle x){\n    vector<Line>res;\n    x.p=x.p-p;\n    Real a=x.p.arg();\n    Real b[2]={(r-x.r),(r+x.r)};\n    for(int i=0;i<2;i++){\n      b[i]/=x.p.norm();\n      if(sgn(b[i],-1.0)<0 || sgn(b[i],1.0)>0)return res;\n      Real c=asin(b[i])-asin(1.0);\n      res.push_back(tangent(a-c));\n      res.push_back(tangent(a+c));\n    }\n    return res;\n  }\n  \n};\n\nint n;\nvector<Circle>c;\nvector<Real>m;\n\nvector<Line> enumerate(){\n  vector<Line>res;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      vector<Line>tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r+=m[i];\n      tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r-=m[i];\n    }\n  }\n  return res;\n}\n\nint count(Line l){\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    Real d=l.dist(c[i].p)-c[i].r;\n    cnt+=(sgn(d)>=0 && sgn(d,m[i])<=0);\n  }\n  return cnt;\n}\n\nint main(void){\n\n  while(cin >> n,n){\n    c.resize(n);\n    m.resize(n);\n\n    for(int i=0;i<n;i++)\n      cin >> c[i].p.x >> c[i].p.y >> c[i].r >> m[i];\n    \n    vector<Line>res=enumerate();\n    \n    int cnt=0;\n    for(int i=0;i<res.size();i++){\n      cnt=max(cnt,count(res[i]));\n    }\n    cout << max(1,cnt) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct line\n{\n    double a,b,c;\n};\n\nconst int MAX_N = 100005;\nconst int sign[] = {1,-1};\n\nvector<line> tangent(double x1,double y1,double r1,double x2,double y2,double r2)\n{\n    vector<line> vec;\n    double p,q,r;\n    double a = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    rep(i,2){\n        double b = -(x2-x1)*(r1*r1+sign[i]*r1*r2);\n        double c = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (y2-y1)*(y2-y1)*r1*r1;\n        rep(j,2){\n            if(b*b - a*c < -EPS){\n                break;\n            }\n            p = (-b + sign[j]*sqrt(b*b-a*c)) / a;\n            if(abs(y1-y2) < EPS){\n                q = 0;\n            }else{\n                q = (r1*r1 + sign[i]*r1*r2 - p*(x2-x1)) / (y2-y1);\n            }\n            r = -r1*r1 - p*x1 - q*y1;\n            vec.push_back((line){p,q,r});\n        }\n    }\n    return vec;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        int X[51],Y[51],R[51],M[51];\n    \trep(i,n){\n    \t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&M[i]);\n    \t}\n        if(n == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        vector<line> v;\n        v = tangent(X[0],Y[0],R[0],X[1],Y[1],R[1]);\n        int res = 0;\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                vector<line> u[4];\n                u[0] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]);\n                u[1] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]+M[j]);\n                u[2] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]);\n                u[3] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]+M[j]);\n                rep(k,4){\n                    rep(l,u[k].size()){\n                        int bf = 2;\n                        double aa = u[k][l].a,bb = u[k][l].b,cc = u[k][l].c;\n                        double d = sqrt(aa*aa+bb*bb);\n                        rep(l,n){\n                            if(l != i && l != j){\n                                if(abs(aa*X[l] + bb*Y[l] + cc) / d > R[l] - EPS && abs(aa*X[l] + bb*Y[l] + cc) / d < R[l] + M[l] + EPS){\n                                    bf++;\n                                }\n                            }\n                        }\n                        res = max(res,bf);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2015/05/29\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n             ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P p;\n  double r;\n  C() {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n               q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\n// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\nint contain(C c, P p) {\n  if(abs(c.p - p) - c.r <  -eps) return 2;\n  if(abs(c.p - p) - c.r >  eps) return 0;\n  return 1;\n}\n\n// 轤ケ縺悟、夊ァ貞ス「縺ョ蜀?Κ/蠅?阜/螟夜Κ縺ョ縺ゥ縺薙↓縺ゅｋ縺九ｒ蛻、螳壹☆繧具シ?// 0:螟夜Κ, 1:蠅?阜, 2:蜀?Κ\n// by Spaghetti Source\nint contain(const vector<P> &g, const P &p) {\n  int n = g.size();\n  int in = 0;\n  for(int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() < eps && eps < b.imag() && cross(a, b) < -eps) in = !in;\n    if(abs(cross(a, b)) < eps && dot(a, b) < eps) return 1;\n  }\n  return in * 2;\n}\n\n// 邱壼?縺ィ邱壼?縺ョ莠、蟾ョ蛻、螳壹?\n// T蟄励ｄL蟄励∩縺溘＞縺ォ縺ェ縺」縺ヲ縺?ｋ譎ゅｂtrue繧定ソ斐☆縺後?\n// 縺薙ｌ繧帝勁螟悶＠縺溘＞蝣エ蜷医↓ <= 繧?< 縺ォ螟画峩縺励※繧ゅ≧縺セ縺上＞縺九↑縺??\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// 逶エ邱壹→蜀??莠、蟾ョ蛻、螳壹?謌サ繧雁?縺ッ莠、轤ケ縺ョ謨ー縲?int isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.p);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// 蜀?→蜀??莠、蟾ョ蛻、螳壹?\n//  0 : 莠、蟾ョ縲∝?蛹?↑縺?//  1 : 螟夜Κ縺ァ1轤ケ縺ィ謗・縺吶ｋ\n//  2 : 2轤ケ縺ァ莠、蟾ョ\n// -1 : 蜀?桁縺励※謗・縺吶ｋ\n// -2 : 螳悟?縺ォ蜀?桁\nint isIntersect(C a, C b) {\n  double x = a.p.real() - b.p.real();\n  double y = a.p.imag() - b.p.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// 逶エ邱壹→逶エ邱壹?莠、轤ケ縲?P getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross 縺ョ隨ヲ蜿キ髢「菫ゅ≠繧?  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// 逶エ邱壹→蜀??莠、轤ケ縲?vector<P> getCrossPLC(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.p);\n  double dist = getDistanceLP(s1, s2, c.p);\n  if (equals(dist, c.r)) {\n    v.push_back(p);\n  } else if (dist < c.r) {\n    double h = abs(p - c.p);\n    double d = sqrt(c.r * c.r - h * h);\n    P base = s2 - s1;\n    // push_back縺吶ｋ鬆?分縺ッ驥崎ヲ?    v.push_back(p - d * base / abs(base));\n    v.push_back(p + d * base / abs(base));\n  }\n  return v;\n}\n\n// 蜀?→蜀??莠、轤ケ縲?vector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.p - c2.p);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.p - c1.p;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.p + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.p + A*base + h*n);\n    v.push_back(c1.p + A*base - h*n);\n  }\n  return v;\n}\n\n// 2縺、縺ョ繝吶け繝医Ν縺ョ縺ェ縺呵ァ?0 <= rad <= PI)\n// AOJ2233縺ァ繝舌げ縺」縺溘?縺ァ譖エ譁ー(2015/05/29)\ndouble getAngle(P a, P b) {\n  double v = dot(a, b) / (abs(a) * abs(b));\n  if(v > 1.0) return 0;\n  if(v < -1.0) return M_PI;\n  return acos(v);\n}\n\n// a -> b 縺ク縺ョ隗貞コヲ縺ョ遘サ蜍暮?(0 <= rad < 2*PI)\ndouble getAngleVector(P a, P b) {\n  double A = arg(a);\n  double B = arg(b);\n  double rad = B-A;\n  rad = fmod(rad, M_PI*2.0);\n  if(rad < 0.0) rad += M_PI*2.0;\n  return rad;\n}\n\n// 2縺、縺ョ逶エ邱壹↓謗・縺吶ｋ蜊雁セв縺ョ蜀?C getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = arg(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.p = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 繝倥Ο繝ウ縺ョ蜈ャ蠑上ｒ逕ィ縺?※荳芽ァ貞ス「縺ョ3霎コ縺ョ髟キ縺輔°繧蛾擇遨阪ｒ豎ゅａ繧?double heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// 螟夊ァ貞ス「縺ョ髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\ndouble getTriArea(P a, P b, P c) {\n  return cross(b-a, c-a) / 2.0;\n}\n\ndouble getSectorArea(P a, P b, C c) {\n  return getAngleVector(a-c.p, b-c.p) * c.r * c.r / 2.0;\n}\n\ndouble getBowArea(P a, P b, C c) { // a,b is a chord of c.\n  return getSectorArea(a, b, c) - getTriArea(a, b, c.p);\n}\n\ndouble getArea(P a, P b, C c) {\n  int d = 1;\n  if(cross(a,b) < 0.0) {\n    d = -1;\n    swap(a, b);\n  }\n  if(cross(a, b) < eps) return 0;\n\n  G t(3);\n  t[0] = P(0, 0), t[1] = a, t[2] = b;\n\n  if(contain(c, t[0]) && contain(c, t[1]) && contain(c, t[2])) {\n    return d * getTriArea(t[0], t[1], t[2]);\n  }\n\n  if(getDistanceSP(t[0], t[1], c.p) - c.r > -eps &&\n     getDistanceSP(t[1], t[2], c.p) - c.r > -eps &&\n     getDistanceSP(t[2], t[0], c.p) - c.r > -eps) {\n    if(cross(t[1] - t[0], c.p - t[0]) > -eps &&\n       cross(t[2] - t[1], c.p - t[1]) > -eps &&\n       cross(t[0] - t[2], c.p - t[2]) > -eps) {\n      return d * (c.r * c.r * M_PI);\n    } else {\n      return 0;\n    }\n  }\n\n  double S = c.r * c.r * M_PI;\n  vector<P> cp(6);\n  vector<int> exist(6);\n  for(int i = 0; i < 3; ++i) {\n    P p = t[i], q = t[(i+1)%3];\n    if(getDistanceLP(p, q, c.p) - c.r > -eps) {\n      if(cross(q - p, c.p - p) < 0) return 0;\n      continue;\n    }\n    if(getDistanceSP(p, q, c.p) - c.r > -eps) continue;\n    vector<P> v = getCrossPLC(t[i], t[(i+1)%3], c);\n    if(v.size() == 2 && !equals(v[0], v[1])) {\n      S -= getBowArea(v[0], v[1], c);\n      for(int j = 0; j < v.size(); ++j) {\n        int k = (i*2 + j*3) % 6;\n        cp[k] = v[j];\n        exist[k] = true;\n      }\n    }\n  }\n  for(int i = 0; i < 3; ++i) {\n    int a = i*2, b = i*2+1;\n    if(!exist[a] || !exist[b]) continue;\n    if(contain(c, t[i]) == 2 && !equals(cp[a], cp[b])) {\n      S += getBowArea(cp[a], cp[b], c) + getTriArea(t[i], cp[a], cp[b]);\n    }\n  }\n  return S * d;\n}\n\n// 螟夊ァ貞ス「縺ィ蜀??蜈ア騾夐Κ蛻??髱「遨?隨ヲ蜿キ莉倥″)\ndouble getArea(G g, C c) {\n  int n = g.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += getArea(g[i], g[(i+1)%n], c);\n  }\n  return res;\n}\n\n// 荳芽ァ貞ス「縺ョ蜀?磁蜀??蜊雁セ?double getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// 繧ュ繝」繝ェ繝代?豕輔ｒ逕ィ縺?※螟夊ァ貞ス「縺ョ譛?ｂ驕?＞?帝?轤ケ縺ョ霍晞屬繧定ソ斐☆\n// O(NlogN)\n// by Ari book\ndouble caliper(const vector<P> &ps) {\n  vector<P> qs = convex_hull(ps);\n  int n = qs.size();\n  if(n == 2) {\n    return abs(qs[0] - qs[1]);\n  }\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k) {\n    if(!(qs[i] < qs[k])) i = k;\n    if(qs[j] < qs[k]) j = k;\n  }\n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(qs[i] - qs[j]));\n    if(cross((qs[(i+1)%n] - qs[i]), (qs[(j+1)%n] - qs[j])) < 0) {\n      i = (i+1)%n;\n    } else {\n      j = (j+1)%n;\n    }\n  }\n  return res;\n}\n\nvector<L> getTangent(C a, C b) {\n  vector<L> res;\n  bool swapped = false;\n  if (a.r > b.r) {\n    swap(a, b);\n    swapped = true;\n  }\n  if (a.p == b.p) return res;\n  P base = b.p - a.p;\n  for (double s = -1; s <= 1; ++++s) {\n    double c, d, ee;\n    ee = norm(base);\n    d = b.r + a.r * s;\n    if (ee - d * d < 0.0) continue;\n    c = sqrt(ee - d * d);\n    if (c < eps) {\n      P v = base * P(0, 1);\n      P m = b.p - base * b.r / abs(base);\n      res.push_back(L(m, m + v));\n    } else {\n      for (double t = -1; t <= 1; ++++t) {\n        P rotate(c / sqrt(ee), d / sqrt(ee) * t);\n        P v = -base * rotate * s;\n        P nv = v / abs(v) * P(0, t);\n        res.push_back(L(a.p + nv * a.r, b.p - nv * b.r * s));\n      }\n    }\n  }\n  if (swapped) {\n    for (int i = 0; i < res.size(); ++i) {\n      swap(res[i][0], res[i][1]);\n    }\n  }\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      cout << 1 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n\tvector<L> tmp;\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n\tdouble d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n\tif((equals(d, r[i]) || d > r[i]) &&\n\t   (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-12, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n    return os;\n}\n\nPoint rotate(Real theta, const Point &p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a) {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Circle {\n    Point p;\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal dot(const Point &a, const Point &b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nReal distance(const Line &l, const Point &p);\n\nReal distance(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n    Lines ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    Real g = norm(c1.p - c2.p);\n    if(eq(g, 0)) return ret;\n    Point u = (c2.p - c1.p) / sqrt(g);\n    Point v = rotate(PI * 0.5, u);\n    for(int s : {-1, 1}) {\n        Real h = (c1.r + s * c2.r) / sqrt(g);\n        if(eq(1 - h * h, 0)) {\n            ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n        } else if(1 - h * h > 0) {\n            Point uu = u * h, vv = v * sqrt(1 - h * h);\n            ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n            ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vector<Circle> cs, lcs, as;\n        for (int i = 0; i < n; i++) {\n            int x, y, r, m;\n            cin >> x >> y >> r >> m;\n            cs.emplace_back(Circle(Point(x, y), r));\n            lcs.emplace_back(Circle(Point(x, y), m + r));\n            as.emplace_back(cs.back());\n            as.emplace_back(lcs.back());\n        }\n\n        if (n == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        int ans = 0;\n        for (int i = 0; i < 2 * n; i++) {\n            for (int j = i + 1; j < 2 * n; j++) {\n                vector<Line> ls = tangent(as[i], as[j]);\n                for (auto &l : ls) {\n                    int cnt = 0;\n                    for (int k = 0; k < n; k++) {\n                        if (distance(l, cs[k].p) < cs[k].r - EPS) continue;\n                        if (distance(l, cs[k].p) > lcs[k].r + EPS) continue;\n                        cnt++;\n                    }\n                    ans = max(ans, cnt);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\n\n// テヲツッツ氾ィツシツεゥツ鳴「テヲツ閉ー\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\n// テ・ツケツウテヲツ鳴ケテヲツ?ケ\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// テ・ツ、ツ姪ァツゥツ?\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// テァツキツ堙・ツ按?」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォ\nP vec(L a) {return a.b - a.a;}\n\n// ティツキツ敕ゥツ崢「\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a) / vec(l));}\n\n// テ・ツ??\nstruct C{P c; D r;};\n\n// 2テ・ツ??」ツ?ョテ、ツスツ催ァツスツョテゥツ鳴「テ、ツソツ?\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && !sig(c1.r, c2.r)) return SAME;\n  if (sig(d, c1.r - c2.r) < 0) return OVER;\n  if (sig(d, c2.r - c1.r) < 0) return CONTAIN;\n  if (!sig(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (!sig(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (!sig(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d, c1.r + c2.r) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// テ、ツコツ、テァツつケ\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\n\n// テ、ツコツ古・ツ??」ツ?ョテ・ツ?アテゥツ?堙ヲツ篠・テァツキツ?\nvector<L> tCC(C c1, C c2) {\n  vector<L> res;\n  pair<P, P> pcross1, pcross2;\n  D d2 = norm(c2.c - c1.c);\n\n  int rel = cRel(c1, c2);\n  if (rel & (SAME | CONTAIN | OVER)) return res;\n  \n  if (rel & (ONE_CONTAIN_CROSS | ONE_OVER_CROSS | ONE_CROSS)) {\n    P p = pCC(c1, c2).first;\n    res.push_back((L){p, p + (p - c1.c) * P(0, 1)});\n    if (rel & (ONE_CONTAIN_CROSS | ONE_OVER_CROSS)) return res;\n  }\n\n  //external\n  pcross1 = pCC((C){c2.c, sqrt(d2 - (c2.r - c1.r) * (c2.r - c1.r) + c2.r * c2.r)}, c1);\n  pcross2 = pCC((C){c1.c, sqrt(d2 - (c2.r - c1.r) * (c2.r - c1.r) + c1.r * c1.r)}, c2);\n  res.push_back((L){pcross1.second, pcross2.first});\n  res.push_back((L){pcross1.first, pcross2.second});\n  if (rel & (TWO_CROSS | ONE_CROSS)) return res;\n\n  //internal\n  P In((c2.r * c1.c + c1.r * c2.c) / (c1.r + c2.r));\n  pcross1 = pCC((C){In, sqrt(norm(c1.c - In) - c1.r * c1.r)}, c1);\n  pcross2 = pCC((C){In, sqrt(norm(c2.c - In) - c2.r * c2.r)}, c2);\n  res.push_back((L){pcross1.first, pcross2.first});\n  res.push_back((L){pcross1.second, pcross2.second});\n  return res;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    C c[2 * n];\n    D m[n];\n    rep (i, n) cin >> c[i].c.X >> c[i].c.Y >> c[i].r >> m[i];\n    rep (i, n) {\n      c[i + n] = c[i];\n      c[i + n].r += m[i];\n    }\n    int res = 1;\n    rep (i, 2 * n) rep (j, i) {\n      vector<L> vl = tCC(c[i], c[j]);\n      rep (ii, vl.size()) {\n\tint r = 0;\n\trep (k, n) {\n\t  D d = dLP(vl[ii], c[k].c);\n\t  if (sig(c[k].r, d) <= 0 && sig(d, c[k].r + m[k]) <= 0) ++r;\n\t}\n\tres = max(res, r);\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP rot90(P p) { return P(-p.y, p.x); }\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n// 円と点\n// pがcの外側にあることを仮定している\nvector<P> tCP(C c, P p) {\n  D a = abs(c.p - p);\n  D rc = c.r*c.r/a;\n  D rs = max(0.0, sqrt(c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  vector<P> res;\n  res.push_back(c.p + v*rc + rot90(v)*rs);\n  res.push_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  res.emplace_back(at[0], bt[0]);\n  res.emplace_back(at[1], bt[1]);\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  if(sig(a.r + b.r, abs(a.p - b.p)) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    res.emplace_back(a.p + v*a.r + rot90(v), a.p + v*a.r - rot90(v));\n    return res;\n  }\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  res.emplace_back(at[0], bt[0]);\n  res.emplace_back(at[1], bt[1]);\n  return res;\n}\n\nvoid dcircle(double x, double y, double r) {\n  cout << \"circle(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << r*50 << \");\" << endl;\n}\nvoid dline(double x, double y, double a, double b) {\n  cout << \"line(\" << x*50+1000 << \",\" << y*50+1000 << \",\" << a*50+1000 << \",\" << b*50+1000 << \");\" << endl;\n}\n\nint main() {\n  for(int N; cin >> N, N; ) {\n    int x[2*N], y[2*N], r[2*N], m[2*N];\n    for(int i = 0; i < N; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n      x[N+i] = x[i];\n      y[N+i] = y[i];\n      r[N+i] = r[i] + m[i];\n      // dcircle(x[i], y[i], r[i]);\n    }\n    int ans = 0;\n    int num = 0;\n    for(int i = 0; i < 2*N; ++i) {\n      for(int j = i + 1; j < 2*N; ++j) {\n        if(sig(abs(P(x[i], y[i]) - P(x[j], y[j])), max(r[i], r[j])) < 0) continue;\n        vector<L> tangent;\n        for(L l : tCCout(C(P(x[i], y[i]), r[i]), C(P(x[j], y[j]), r[j]))) {\n          tangent.push_back(l);\n        }\n        for(L l : tCCin(C(P(x[i], y[i]), r[i] + m[i]), C(P(x[j], y[j]), r[j] + m[j]))) {\n          tangent.push_back(l);\n        }\n        for(L l : tangent) {\n          // cerr << \"L = { { x = \" << l.a.x << \", y = \" << l.a.y << \" }, { \" << l.b.x << \", y = \" << l.b.y << \" } }\" << endl;\n          int tmp = 0;\n          for(int k = 0; k < N; ++k) {\n            D d = dLP(l, P(x[k], y[k]));\n            if(sig(d,r[k]) >= 0 && sig(d, m[k]+r[k]) <= 0) {\n              tmp++;\n            }\n          }\n\n          if(tmp == 6) {\n            // dline(l.a.x, l.a.y, l.b.x, l.b.y);\n          }\n          num++;\n          ans = max(ans, tmp);\n        }\n      }\n    }\n#if 1\n    if(N == 1) {\n      cout << 1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n#endif\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\nbool operator==(const CP &l, const CP &r) {\n  return norm(l - r) <= EPS;\n}\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n  Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n  bool operator<(const Circle &cr) const {\n    return r < cr.r;\n  }\n};\n\nstruct Line {\n  CP s, t;\n  Line(long double sx = 0.0L, long double sy = 0.0L,\n       long double tx = 0.0L, long double ty = 0.0L)\n      : s(CP(sx, sy)), t(CP(tx, ty)) {}\n  Line(CP _s, CP _t) : s(_s), t(_t) {}\n  bool operator<(const Line &l) const {\n    long double al = 0, ar = 0;\n    if(norm(t - s) >= EPS) al = arg(t - s);\n    if(norm(l.t - l.s) >= EPS) ar = arg(l.t - l.s);\n    return al < ar;\n  }\n};\n\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP projectionLP(CP s, CP t, CP p) {\n  if(s == t) return s;\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\nCP projectionLP(Line l, CP p) {\n  return projectionLP(l.s, l.t, p);\n}\n\nCP reflectionLP(CP s, CP t, CP p) {\n  CP tmp = (projectionLP(s, t, p) - p);\n  tmp *= 2;\n  return p + tmp;\n}\nCP reflectionLP(Line l, CP p) {\n  return reflectionLP(l.s, l.t, p);\n}\n\nint calc_clockwiseSP(CP s, CP t, CP p) {\n  t -= s;\n  p -= s;\n  if(cross(t, p) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(t, p) < -EPS) return -1; //\"CLOCK_WISE\"\n  if(dot(t, p) < 0) return 2;       // \"ONLINE_BACK\"\n  if(norm(t) < norm(p)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\nint calc_clockwiseSP(Line l, CP p) {\n  return calc_clockwiseSP(l.s, l.t, p);\n}\n\nint parallel_orthogonalLL(CP s, CP t, CP a, CP b) {\n  t -= s;\n  b -= a;\n  if(abs(cross(t, b)) <= EPS) return 2; // \"parallel\"\n  if(abs(dot(t, b)) <= EPS) return 1;   // \"orthogonal\"\n  return 0;\n}\nint parallel_orthogonalLL(Line ll, Line lr) {\n  return parallel_orthogonalLL(ll.s, ll.t, lr.s, lr.t);\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\nCP intersectionLL(Line ll, Line lr) {\n  return intersectionLL(ll.s, ll.t, lr.s, lr.t);\n}\n\nbool on_segSP(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= EPS &&\n         dot(s - p, t - p) <= 0;\n}\nbool on_segSP(Line l, CP p) {\n  return on_segSP(l.s, l.t, p);\n}\n\n// crossing segments? (a,b) and (c,d)\nbool iscrossSS(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= EPS) {\n    return on_segSP(a, b, c) || on_segSP(a, b, d) ||\n           on_segSP(c, d, a) || on_segSP(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_segSP(a, b, isp) && on_segSP(c, d, isp);\n}\nbool iscrossSS(Line ll, Line lr) {\n  return iscrossSS(ll.s, ll.t, lr.s, lr.t);\n}\n\nlong double distLP(CP s, CP t, CP p) {\n  return abs(cross(t - s, p - s) / abs(t - s));\n}\nlong double distLP(Line l, CP p) {\n  return distLP(l.s, l.t, p);\n}\n\nlong double distSP(CP s, CP t, CP p) {\n  if(dot(t - s, p - s) < 0) return abs(p - s);\n  if(dot(s - t, p - t) < 0) return abs(p - t);\n  return distLP(s, t, p);\n}\nlong double distSP(Line l, CP p) {\n  return distSP(l.s, l.t, p);\n}\n\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscrossSS(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\nlong double distSS(Line ll, Line lr) {\n  return distSS(ll.s, ll.t, lr.s, lr.t);\n}\n\n// counter clockwise\nbool is_convex(const vector<CP> &pol) {\n  int n = pol.size();\n  for(int i = 0; i < n; ++i)\n    if(cross(pol[(i + 1) % n] - pol[i],\n             pol[(i + 2) % n] - pol[(i + 1) % n]) < -EPS)\n      return 0;\n  return 1;\n}\n\nvector<CP> convex_hull(vector<CP> &ps) {\n  auto lmd = [&](const CP &l, const CP &r) {\n    if(l.X != r.X) return l.X < r.X;\n    return l.Y < r.Y;\n  };\n  vector<CP> res;\n  int psize = ps.size();\n  sort(ps.begin(), ps.end(), lmd);\n  int k = 0;\n  res.resize(psize * 2);\n  for(int i = 0; i < psize; ++i) {\n    while(k > 1 && cross(res[k - 1] - res[k - 2],\n                         ps[i] - res[k - 1]) <= 0)\n      --k;\n    res[k++] = ps[i];\n  }\n  for(int i = psize - 2, t = k; i >= 0; --i) {\n    while(k > t && cross(res[k - 1] - res[k - 2],\n                         ps[i] - res[k - 1]) <= 0)\n      --k;\n    res[k++] = ps[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\n\nlong double convex_diameter(const vector<CP> &pol) {\n  vector<CP> ps = pol;\n  ps = convex_hull(ps);\n  int n = ps.size(), i = 0, j = 0;\n  if(n < 2) return 0.0L;\n  if(n == 2) return abs(ps[0] - ps[1]);\n  for(int k = 0; k < n; ++k) {\n    if(ps[k].X < ps[i].X) i = k;\n    if(ps[k].X > ps[j].X) j = k;\n  }\n  long double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(ps[i] - ps[j]));\n    if(cross(ps[(i + 1) % n] - ps[i],\n             ps[(j + 1) % n] - ps[j]) < 0)\n      (++i) %= n;\n    else\n      (++j) %= n;\n  }\n  return res;\n}\n\nvector<CP> convex_cut(const vector<CP> &pol, const CP &s,\n                      const CP &t) {\n  vector<CP> res;\n  int n = pol.size();\n  for(int i = 0; i < n; ++i) {\n    CP nows = pol[i], nowt = pol[(i + 1) % n];\n    if(cross(t - s, nows - s) >= -EPS) res.push_back(nows);\n    if(cross(t - s, nows - s) * cross(t - s, nowt - s) < 0)\n      res.push_back(intersectionLL(s, t, nows, nowt));\n  }\n  return res;\n}\nvector<CP> convex_cut(const vector<CP> &pol, Line l) {\n  return convex_cut(pol, l.s, l.t);\n}\n\n// number of tangents\nint iscrossCC(Circle l, Circle r) {\n  long double distlr = abs(l.o - r.o);\n  if(distlr - (l.r + r.r) > EPS)\n    return 4; // not touch\n  else if(abs(distlr - (l.r + r.r)) <= EPS)\n    return 3; // circumscription\n  else if(max(l.r, r.r) - (distlr + min(l.r, r.r)) < -EPS)\n    return 2; // cross\n  else if(max(l.r, r.r) - (distlr + min(l.r, r.r)) <= EPS)\n    return 1; // inscribed\n  else        // contain\n    return 0;\n}\n\nvoid intersectionCC(Circle c1, Circle c2, CP &res1,\n                    CP &res2) {\n  if(iscrossCC(c1, c2) == 4) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double d = abs(c1.o - c2.o);\n  long double arg = acos(costh(c2.r, c1.r, d));\n  res1 = (c2.o - c1.o) * CP(cos(arg), sin(arg));\n  res1 *= c1.r / abs(res1);\n  res1 += c1.o;\n  res2 = reflectionLP(c1.o, c2.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projectionLP(s, t, ci.o);\n  long double r = ci.r * ci.r - norm(res1 - ci.o);\n  if(r <= EPS || t == s) return;\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\nvoid intersectionCL(Circle ci, Line l, CP &res1, CP &res2) {\n  intersectionCL(ci, l.s, l.t, res1, res2);\n}\n\nvoid contactCP(Circle ci, CP p, CP &res1, CP &res2) {\n  long double d = abs(ci.o - p);\n  if(abs(d - ci.r) <= EPS) {\n    res1 = res2 = p;\n    return;\n  }\n  else if(d < ci.r) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double arg = asin(ci.r / d);\n  res1 = (ci.o - p) * CP(cos(arg), sin(arg));\n  res1 *= (d * cos(arg)) / abs(res1);\n  res1 += p;\n  res2 = reflectionLP(p, ci.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvector<Line> tangentCC(Circle cl, Circle cr) {\n  vector<Line> res;\n  if(cl.r < cr.r) swap(cl, cr);\n  long double g = abs(cl.o - cr.o);\n  if(abs(g - 0.0L) <= EPS) return res;\n  CP hor = (cr.o - cl.o) / g, ver;\n  ver = hor * (CP(cos(PI * 0.5L), sin(PI * 0.5L)));\n  for(int s : {-1, 1}) {\n    long double h = (cl.r + s * cr.r) / g;\n    if(abs(1 - h * h) <= EPS) {\n      res.emplace_back(cl.o + hor * cl.r,\n                       cl.o + (hor + ver) * cl.r);\n    }\n    else if(1 - h * h > 0) {\n      CP nhor = hor * h, nver = ver * sqrtl(1 - h * h);\n      res.emplace_back(cl.o + (nhor + nver) * cl.r,\n                       cr.o - (nhor + nver) * (cr.r * s));\n      res.emplace_back(cl.o + (nhor - nver) * cl.r,\n                       cr.o - (nhor - nver) * (cr.r * s));\n    }\n  }\n  return res;\n}\n\nlong double areaPol(const vector<CP> &pol) {\n  int n = pol.size();\n  long double res = 0;\n  for(int i = 0; i < n; ++i)\n    res += (pol[(i - 1 + n) % n].X - pol[(i + 1) % n].X) *\n           pol[i].Y;\n  return res / 2.0L;\n}\n\nint containPolP(const vector<CP> &pol, CP p) {\n  bool con = 0, onseg = 0;\n  int n = pol.size();\n  for(int i = 0; i < n; ++i) {\n    onseg |= on_segSP(pol[i], pol[(i + 1) % n], p);\n    CP s = pol[i] - p, t = pol[(i + 1) % n] - p;\n    if(s.Y > t.Y) swap(s, t);\n    if(s.Y * t.Y <= 0 && t.Y > 0 && cross(s, t) < 0)\n      con = !con;\n  }\n  if(onseg) return 1;\n  if(con) return 2;\n  return 0;\n}\n\nlong double closest_pair(vector<CP> &ps, int l = -1,\n                         int r = -1, bool reqsqrt = 0) {\n  if(l == r && l == -1) {\n    l = 0;\n    r = ps.size();\n    reqsqrt = 1;\n    auto lmd = [&](const CP &l, const CP &r) {\n      if(l.X != r.X) return l.X < r.X;\n      return l.Y < r.Y;\n    };\n    sort(ps.begin(), ps.end(), lmd);\n  }\n  if(r - l < 2) return 1e18;\n  if(r - l == 2) {\n    if(ps[l].Y > ps[l + 1].Y) swap(ps[l], ps[l + 1]);\n    if(reqsqrt) return abs(ps[l] - ps[l + 1]);\n    return norm(ps[l] - ps[l + 1]);\n  }\n  int mid = (l + r) / 2;\n  long double x = ps[mid].X,\n              res = min(closest_pair(ps, l, mid),\n                        closest_pair(ps, mid, r));\n  auto f = [](CP pl, CP pr) { return pl.Y < pr.Y; };\n  inplace_merge(ps.begin() + l, ps.begin() + mid,\n                ps.begin() + r, f);\n  vector<CP> tmp;\n  for(int i = l; i < r; ++i) {\n    long double dx = abs(ps[i].X - x);\n    int tsize = tmp.size();\n    if(dx * dx >= res) continue;\n    for(int j = 0; j < tsize; ++j) {\n      CP delta = ps[i] - tmp[tsize - 1 - j];\n      if(delta.Y * delta.Y >= res) break;\n      res = min(res, norm(delta));\n    }\n    tmp.push_back(ps[i]);\n  }\n  if(reqsqrt) res = sqrtl(res);\n  return res;\n}\n\nint n;\n\nstruct data {\n  Circle c;\n  int m;\n};\n\nvector<data> v;\n\nint solve();\nint calc(Line l);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    v.resize(n);\n    for(int i = 0; i < n; ++i) {\n      int x, y, r;\n      cin >> x >> y >> r;\n      v[i].c = Circle(x, y, r);\n      cin >> v[i].m;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int res = 1;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j) {\n      Circle cl = v[i].c, cr = v[j].c;\n      vector<Line> lines = tangentCC(cl, cr);\n      for(auto l : lines) res = max(res, calc(l));\n      cl.r += v[i].m;\n      lines = tangentCC(cl, cr);\n      for(auto l : lines) res = max(res, calc(l));\n      cr.r += v[j].m;\n      lines = tangentCC(cl, cr);\n      for(auto l : lines) res = max(res, calc(l));\n      cl.r -= v[i].m;\n      lines = tangentCC(cl, cr);\n      for(auto l : lines) res = max(res, calc(l));\n    }\n  return res;\n}\n\nint calc(Line l) {\n  int res = 0;\n  for(int i = 0; i < n; ++i) {\n    long double dist = distLP(l, v[i].c.o);\n    if(v[i].c.r - dist > EPS) continue;\n    if(v[i].c.r + v[i].m - dist >= -EPS) ++res;\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nconst int MAX_N = 52;\n\nint X[MAX_N],Y[MAX_N],R[MAX_N],M[MAX_N];\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        cin >> n;\n        if(n== 0){\n            break;\n        }\n        if(n == 1){\n            cout << \"1\\n\";\n            continue;\n        }\n        rep(i,n){\n            cin >> X[i] >> Y[i] >> R[i] >> M[i];\n        }\n        int ans = 0;\n        rep(i,n){\n            for(int j = i+1;j<n;j++){\n                vector<L> LL = gettangentCC(C(X[i],Y[i]),R[i],C(X[j],Y[j]),R[j]);\n                int res;\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i]+M[i],C(X[j],Y[j]),R[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i],C(X[j],Y[j]),R[j]+M[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i]+M[i],C(X[j],Y[j]),R[j]+M[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+r[i]*cos(j)) * tan(M_PI/2 + j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-(r[i]+m[i])*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+( r[i] + m[i] )*cos(j)) * tan(M_PI/2 + j) - y[i] - (r[i] + m[i]) * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// rotate by theta (-pi,+pi)\n// arg will return angle of point\npoint rotate(point p,double theta){\n    double cos_theta = cos(theta),\n           sin_theta = sin(theta);\n    return point(p.real()*cos_theta - p.imag()*sin_theta,\n                 p.real()*sin_theta + p.imag()*cos_theta);\n}\nconst double EPS = 1e-6;\n// 二つの円の共通接線\n//  ふつうは4つ？\nvector<pair<point,point> > common_tangent_of_two_circles(point c1,double r1,point c2,double r2){\n    // shift c2 by c1.\n    point nc = c2 - c1;\n    // c.img == 0\n    double ar = arg(nc);\n    point c = rotate(nc,ar);\n\n    vector<pair<point,point> > ret;\n    vector<double> xs;\n    for(int sign=-1;sign<=1;sign+=2){\n        xs.push_back((r1*r1 + sign*r1*r2)/c.real());\n    }\n    for(double x1 : xs){\n        double y2 = r1*r1 - x1*x1;\n        for(int sign=-1;sign<=1;sign+=2){\n            double y1 = sign*sqrt(y2);\n            // x1*x + y1*y = r1*r1 is such line\n            point h = point(x1,y1);\n            point t = point(0,r1*r1/y1); // tekito\n            if(abs(y1) < EPS){\n                t = point(x1,y1+1);\n            }\n\n            ret.push_back(make_pair(h,t));\n        }\n    }\n    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair<point,point> p){\n            return make_pair(rotate(p.first,-ar)+c1,\n                             rotate(p.second,-ar)+c1);\n        });\n    return ret;\n}\n\nstruct Jewel {\n    point p;\n    double r;\n    double m;\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true){\n        int N; cin >> N;\n        if(N == 0) break;\n        vector<Jewel> jewels;\n        for(int i=0;i<N;i++){\n            double x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewels.push_back(Jewel{point(x,y),r,m});\n        }\n\n        vector<pair<point,double> > circles;\n        for(auto& j : jewels){\n            circles.push_back(make_pair(j.p,j.r));\n            circles.push_back(make_pair(j.p,j.r + j.m));\n        }\n        int maxi = min(2ll,N);\n        for(int i=0;i<circles.size();i++){\n            int skip = (i%2 == 0)?2:1;\n            for(int j=i+skip;j<circles.size();j++){\n                auto lines = common_tangent_of_two_circles(circles[i].first,circles[i].second,\n                                                           circles[j].first,circles[j].second);\n                for(pair<point,point>& line : lines){\n                    int cnt = 0;\n                    for(auto& jewel : jewels){\n                        double d = dist_line_and_point(line.first,line.second,jewel.p);\n                        if(jewel.r < d + EPS and d < jewel.r + jewel.m + EPS){\n                            cnt++;\n                        }\n                    }\n                    maxi = max(maxi,cnt);\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;     \ntypedef complex<D> P;  \ntypedef pair<P, P> L;  \nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) { return (conj(a)*b).Y;}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1,p-a1)/norm(a2-a1)*(a2-a1);\n}\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L>ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;\n    }\n  }\n  return ls;\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    P p[n];\n    double r[n],a,b;\n    int cost[n],sum=1;\n    rep(i,n){\n      cin>>a>>b>>r[i]>>cost[i];\n      p[i]=P(a,b);\n    }\n    rep(i,n)for(int j=i+1;j<n;j++){\n      vector<L>l=tangentLines(p[i],r[i],p[j],r[j]);\n      rep(k,l.size()){\n        int t=0;\n        rep(u,n)if(distLC(l[k].first,l[k].second,p[u],r[u])<=EPS)t+=cost[u];\n        sum=max(sum,t);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// ??\\??? ????????¨???\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // ?\\???????????????????\ntypedef vector <P> Pol;\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// ?????¬??????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// ???\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n\t// ?????¨??´???????????¢\n\t// ?????¨??????????????¢\n\t// ??´?????¨??´???????????¢\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ??????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ?????¨??´?????¨????????¢??£???????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ?????¨??´?????¨????????¢??£????????¢\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//??\\????????±???????????\\???\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(j,5)\n\t\t\tres.pb(tanC(a,j));\n\t}\n\treturn res;\n}\n\n\n// ?\\????\n\n// ????§???¢\n\n// ????§???¢??????????????????(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// ??¢?????£?????????\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/*\n\n// now developing\nvector<L> merge_L(vector<L>){\n\n}\n\n\n\nPol normalize_polygon(Pol pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+2)%n],pol[(i+1)%n])==MID)\n\t\t\t// remove pol[(i+1)%n]\n\t\t\tn--;\n\t}\n}\n*/\n\ntypedef vector<C> Stone;\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vector<Stone> stones(n, Stone(2));\n\n        for(auto && stone : stones){\n            int x, y, r, m;\n            cin >> x >> y >> r >> m;\n\n            stone[0].c = P(x, y);\n            stone[0].r = r;\n            stone[1].c = P(x, y);\n            stone[1].r = r + m;\n        }\n\n        int res = 1;\n\n        rep(i, n){\n            range(j, i + 1, n){\n                rep(ki, 2){\n                    rep(kj, 2){\n                        C ci = ki ? stones[i][0]:stones[i][1];\n                        C cj = kj ? stones[j][0]:stones[j][1];\n\n                        VL lines = common_tan(ci, cj);\n\n                        for(auto && l : lines){\n                            int cnt = 0;\n\n                            for(auto && stone : stones){\n                                if(dLP(l, stone[0].c) + eps >= stone[0].r && dLP(l, stone[1].c) <= stone[1].r + eps){\n                                    cnt++;\n                                }\n                            }\n\n                            res = max(res, cnt);\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}\n\n// inline??????????????????\n// eps????°????????????????\n// double??????????????????"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2201&lang=jp\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<Circle> Cir(2*N); vector<int> m(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r >> m[i];\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\n\t\t\tCir[i + N] = Circle(Point(x, y), r + m[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor (int i = 0; i < 2*N;i++) {\n\t\t\tfor (int j = i + 1; j < 2*N;j++) {\n\t\t\t\tauto cp = tangent_cc(Cir[i], Cir[j]);\n\t\t\t\tfor (auto l : cp) {\n\t\t\t\t\tif (isnan(l.a.imag()) || isnan(l.a.real()) || isnan(l.b.imag()) || isnan(l.b.real()))continue;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor (int k = 0; k < N;k++) {\n\t\t\t\t\t\tld dist = dist_lp(l, Cir[k].p);\n\t\t\t\t\t\tif (dist < Cir[k].r)continue;\n\t\t\t\t\t\tif (dist > (Cir[k].r + m[k])) continue;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\ntemplate<typename T,std::size_t N>\nstruct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\ntemplate<typename T>\nstruct _v_traits<T,1> {using type = std::vector<T>;};\ntemplate<typename T,std::size_t N=1>\nusing vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// rotate by theta (-pi,+pi)\n// arg will return angle of point\npoint rotate(point p,double theta){\n    double cos_theta = cos(theta),\n           sin_theta = sin(theta);\n    return point(p.real()*cos_theta - p.imag()*sin_theta,\n                 p.real()*sin_theta + p.imag()*cos_theta);\n}\nconst double EPS = 1e-6;\n// 二つの円の共通接線\n//  ふつうは4つ？\nvector<pair<point,point> > common_tangent_of_two_circles(point c1,double r1,point c2,double r2){\n    // shift c2 by c1.\n    point nc = c2 - c1;\n    // c.img == 0\n    double ar = arg(nc);\n    point c = rotate(nc,ar);\n\n    vector<pair<point,point> > ret;\n    vector<double> xs;\n    for(int sign=-1;sign<=1;sign+=2){\n        xs.push_back((r1*r1 + sign*r1*r2)/c.real());\n    }\n    for(double x1 : xs){\n        double y2 = r1*r1 - x1*x1;\n        for(int sign=-1;sign<=1;sign+=2){\n            double y1 = sign*sqrt(y2);\n            // x1*x + y1*y = r1*r1 is such line\n            point h = point(x1,y1);\n            point t = point(0,r1*r1/y1); // tekito\n            if(abs(y1) < EPS){\n                t = point(x1,y1+1);\n            }\n\n            ret.push_back(make_pair(h,t));\n        }\n    }\n    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair<point,point> p){\n            return make_pair(rotate(p.first,-ar)+c1,\n                             rotate(p.second,-ar)+c1);\n        });\n    return ret;\n}\n\nstruct Jewel {\n    point p;\n    double r;\n    double m;\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true){\n        int N; cin >> N;\n        if(N == 0) break;\n        vector<Jewel> jewels;\n        for(int i=0;i<N;i++){\n            double x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewels.push_back(Jewel{point(x,y),r,m});\n        }\n\n        vector<pair<point,double> > circles;\n        for(auto& j : jewels){\n            circles.push_back(make_pair(j.p,j.r));\n            circles.push_back(make_pair(j.p,j.r + j.m));\n        }\n        int maxi = min(2ll,N);\n        for(int i=0;i<circles.size();i++){\n            int skip = (i%2 == 0)?2:1;\n            for(int j=i+skip;j<circles.size();j++){\n                auto lines = common_tangent_of_two_circles(circles[i].first,circles[i].second,\n                                                           circles[j].first,circles[j].second);\n                for(pair<point,point>& line : lines){\n                    int cnt = 0;\n                    for(auto& jewel : jewels){\n                        double d = dist_line_and_point(line.first,line.second,jewel.p);\n                        if(jewel.r < d + EPS and d < jewel.r + jewel.m + EPS){\n                            cnt++;\n                        }\n                    }\n                    maxi = max(maxi,cnt);\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n//------------------------------------------------------------------------------------------\n//---------????????????????????¢???-------------------------------------------------------------------\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t\tcross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//?????????????????????????????????\nbool PinC(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\n\n//?????¨?????????????????¢???(??????????????£??????????????£?????????)\nint pos_S_C(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS)\treturn 1;\t//??\\?????????\n\tif(distanceSP(s,c.p) > c.r+EPS) \treturn 0;\t//????????£????????????\n\tif(PinC(s[0], c) && PinC(s[1], c))\treturn 2;\t//????????????\n\tif(PinC(s[0], c)||PinC(s[1], c))\treturn 3;\t//?????´???????????????\n\treturn 4;\t//????????????\n}\n\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\n\n//?????¨??´????????????(???????¨?)\nvector<P> croossPoint(C c, L l) {\n\tint hit = pos_S_C(l, c);\n\tif(hit == 0) return {};\n\t\n\tdouble R = c.r;\n\tP sub = c.p;\n\tdouble theta;\n\n\tl[0] -= sub;\n\tl[1] -= sub;\n\n\ttheta = atan2(imag(l[1]-l[0]), real(l[1]-l[0]));\n\n\tl[0] = spinP(l[0], -theta);\n\tl[1] = spinP(l[1], -theta);\n\n\tassert(abs(imag(l[0]-l[1])) < EPS);\n\n\tvector<P> ret;\n\tif(abs(abs(l[0].Y) - R) < EPS) ret.pb({0.0, l[0].Y});\n\telse {\n\t\tdouble y = l[0].Y;\n\t\tdouble x = sqrt(R*R-y*y);\n\t\tret.pb({x, y});\n\t\tret.pb({-x, y});\n\t}\n\n\trep(i, ret.size()) {\n\t\tret[i] = spinP(ret[i], theta);\n\t\tret[i] += sub;\n\t}\n\treturn ret;\n}\n\n//?????¨?§??????¨??????????????´????????????\nL makeLine_p_theta(const P& p, double theta, double len = 1.0) {\n\treturn {p, p + P{len*cos(theta), len*sin(theta)}};\n}\n\n//???????§????theta??§?????\\???\nL cTang(C c, double theta) {\n\tL l = makeLine_p_theta({c.r*cos(theta), c.r*sin(theta)}, theta+PI/2.0);\n\tl[0] += c.p;\n\tl[1] += c.p;\n\treturn l;\n}\n\n// //????????±?????\\???\n// vector<L> comonTang(C c1, C c2) {\n// \tvector<L> ret;\n// \tif(c1.r > c2.r) swap(c1, c2);\n\t\t\n// }\nvector<L> comonTang(C c1, C c2) {\n\tvector<L> ret;\n\tif(c1.r > c2.r) swap(c1, c2);\n\tP sub = c1.p;\n\tdouble theta;\n\tc1.p -= sub;\n\tc2.p -= sub;\n\ttheta = atan2(c2.p.Y, c2.p.X);\n\n\tc2.p = spinP(c2.p, -theta);\n\tint signX = 0;\n\tif(c2.p.X > 0) signX = 1;\n\tif(c2.p.X < 0) signX = -1;\n\n\tdouble x = abs(c2.p.X), r1 = c1.r, r2 = c2.r;\n\tif(x*x > (r2 - r1) * (r2 - r1)) {\n\t\tdouble theta2 = asin((r2-r1)/x);\n\t\tret.pb({spinP({0, r1}, theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), r1}, theta2)});\n\t\tret.pb({spinP({0, -r1}, -theta2), spinP({sqrt(x*x-(r2-r1)*(r2-r1)), -r1}, -theta2)});\n\t}\n\tif(x > r1+r2) {\n\t\tdouble theta3 = PI / 2 - acos((r1+r2)/x);\n\t\tdouble len = sqrt((r1*x)*(r1*x)/(r1+r2)/(r1+r2)-r1*r1) + sqrt((r2*x)*(r2*x)/(r1+r2)/(r1+r2)-r2*r2);\n\t\tret.pb({spinP({0, r1}, -theta3), spinP({len, r1}, -theta3)});\n\t\tret.pb({spinP({0, -r1}, -theta3), spinP({len, -r1}, theta3)});\n\t}\n\t\n\n\tfor(auto& l : ret) {\n\t\tif(signX == -1) l[1] = {-l[1].X, l[1].Y};\n\t\tl[0] = spinP(l[0], theta);\n\t\tl[1] = spinP(l[1], theta);\n\t\tl[0] += sub;\n\t\tl[1] += sub;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n) {\n\t\tvector<C> c;\n\t\tvector<int> m(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r >> m[i];\n\t\t\tc.pb({{x, y}, r});\n\t\t}\n\t\tll ans = 1LL;\n\t\tauto check = [&](const L& l) {\n\t\t\tll tmp = 0LL;\n\t\t\trep(k, n){\n\t\t\t\tdouble dist = distanceLP(l, c[k].p);\n\t\t\t\tif(dist > c[k].r - EPS && dist < c[k].r+m[k] + EPS) tmp++;\n\t\t\t}\n\t\t\tans = max(ans, tmp);\n\t\t};\n\t\trep(i, n) rep(j, i) {\n\t\t\tauto ls = comonTang(c[i], c[j]);\n\t\t\tfor(auto& l : ls) check(l);\n\t\t\tls = comonTang({c[i].p, c[i].r+m[i]}, c[j]);\n\t\t\tfor(auto& l : ls) check(l);\n\t\t\tls = comonTang(c[i], {c[j].p, c[j].r + m[j]});\n\t\t\tfor(auto& l : ls) check(l);\n\t\t\tls = comonTang({c[i].p, c[i].r+m[i]}, {c[j].p, c[j].r + m[j]});\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\n// ????????????????§???????????????????????????\\??????????????????????????¨???????????????\ntypedef complex<double> PT;\ntypedef complex<double> VC;\n// ??´?????????????????????????§?????????????????????\\??§??\\??????typedef\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n// ????????????????§????\ntypedef pair<PT,double> CIR;\n\n// paramater\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\n// ??´??? or ???????????????????????????????????????\nVC get_vc_normal(VC a) {\n\ta = a * PT(0,-1);\n\treturn a / abs(a);\n}\n\n// ??±?????\\???(common tangent) ?????????????????????????????¨?????????????????§??¨???(???????????\\????????????)\nvector<LN> get_comm_tan(CIR c0, CIR c1) {\n\tvector<LN> res;\n\tVC v, n;\n\tdouble d;\n\tdouble theta, phi, psi;\n\tconst int sign[] = {1,-1};\n\n\tv = c1.fi-c0.fi;\n\tn = get_vc_normal(v);\n\td = abs(v);\n\ttheta = arg(v);\n\t// ??±?????\\?????????\n\tif(d < abs(c0.se-c1.se) + EPS)\n\t\treturn res;\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(abs(c0.se-c1.se)-d) < EPS || d < abs(c0.se-c1.se)) {\n\t\t// ????????\\??????\n\t\tv *= c0.se / (c0.se - c1.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse {\n\t\tphi = asin((c0.se-c1.se)/d);\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\tc1.fi + polar(c1.se, psi)));\n\t\t}\n\t}\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(c0.se + c1.se - d) < EPS) {\n\t\t// ????????\\??????\n\t\tv *= c0.se / (c0.se + c1.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse if(c0.se + c1.se < d) {\n\t\tphi = acos((c0.se+c1.se)/d);\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\t\tc1.fi + polar(c1.se, psi + M_PI)));\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b)) / abs(l.fi-l.se);\n}\n\n// rest code\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<vector<int> > v;\n\t\tvector<CIR> circle;\n\t\tvector<LN> line;\n\t\tv.resize(n);\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tv[i].resize(4);\n\t\t\tfor(int j = 0; j < 4; j++)\n\t\t\t\tcin >> v[i][j];\n\t\t\tcircle.push_back(CIR(PT(v[i][0], v[i][1]), v[i][2]));\n\t\t\tcircle.push_back(CIR(PT(v[i][0], v[i][1]), v[i][2] + v[i][3]));\n\t\t}\n\t\tfor(int i = 0; i < circle.size(); i++) {\n\t\t\tfor(int j = 1; j < circle.size(); j++) {\n\t\t\t\tvector<LN> tmp;\n\t\t\t\ttmp = get_comm_tan(circle[i],circle[j]);\n\t\t\t\tline.insert(line.end(), tmp.begin(), tmp.end());\n\t\t\t}\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tdouble d;\n\t\t\t\td = dist_pts_line(PT(v[j][0],v[j][1]), line[i]);\n\t\t\t\tif(v[j][2] - EPS < d && d < v[j][2] + v[j][3] + EPS)\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,double> P1;\nconst double EPS = 1e-10;\ntypedef pair<P,P> L;\nint n;\n\n\n//kaitenn\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n \n//???\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\nCircle c[2][51];\n \nL getIntangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double w=a.r+b.r;\n  double h=sqrt(max(0.0,norm(base)-w*w));\n  P k=base*P(w,h*f)/norm(base);\n  return L(a.c+k*a.r,b.c-k*b.r);\n}\n \nL getOuttangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double h=b.r-a.r;\n  double w=sqrt(max(0.0,norm(base)-h*h));\n  P k=base*P(w,h*f)/norm(base)*P(0,f);\n  return L(a.c+k*a.r,b.c+k*b.r);\n}\n \nvector<L> tangentCC(Circle a,Circle b){\n  double dis=abs(a.c-b.c),R=a.r+b.r;\n  vector<L> res;\n  if(dis>R+EPS)res.push_back(getIntangent(a,b));\n  if(dis>R-EPS)res.push_back(getIntangent(a,b,-1));\n  if(dis>abs(a.r-b.r)+EPS)res.push_back(getOuttangent(a,b));\n  if(dis>abs(a.r-b.r)-EPS)res.push_back(getOuttangent(a,b,-1));\n  return res;\n}\n\nint cal(P a,P b){\n  int res=0;\n  b-=a;\n  for(int i=0;i<n;i++){\n    P t=(c[0][i].c-a)*conj(b)/abs(b);\n    if(c[0][i].r<=abs(t.imag())+EPS&&abs(t.imag())<=c[1][i].r+EPS)res++;\n  }\n  return res;\n}\n \nint main(){\n  while(cin>>n,n){\n    for(int i=0,a,b,r,m;i<n;i++){\n      cin>>a>>b>>r>>m;\n      c[0][i]=Circle(P(a,b),r);\n      c[1][i]=Circle(P(a,b),r+m);\n    }\n\n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tfor(int k=0;k<4;k++){\n\t  vector <L> res=tangentCC(c[k&1][i],c[(k>>1)&1][j]);\n\t  for(int l=0;l<res.size();l++) ans=max(ans,cal(res[l].first,res[l].second));\n\t}\n      }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>100) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t\tif(!n) return;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distLP(Point a1, Point a2, Point p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<Line> tangentLines(Point a, double ar, Point b, double br) {\n  vector<Line> ls;\n  double d = abs(b-a);\n  rep (i,2) {\n    double sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    double cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      Point n = (b-a) * Point(sin, (1-j*2)*cos) / d;\n      ls.push_back(Line(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<Point> c(n);\n        vector<int> r(n),m(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y >>r[i] >>m[i];\n            c[i] = Point(x,y);\n        }\n\n        int ans = 1;\n        rep(j,n)rep(i,j){\n            rep(ii,2)rep(jj,2){\n                vector<Line> ls = tangentLines(c[i],r[i]+ii*m[i],c[j],r[j]+jj*m[j]);\n                for(const auto &l:ls){\n                    int tt = 0;\n                    rep(k,n){\n                        double d = distLP(l.fi,l.se,c[k]);\n                        if(LE(0,d-r[k]) && LE(d-r[k],m[k])) ++tt;\n                    }\n                    ans = max(ans,tt);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define mp         make_pair\n#define pb         push_back\n\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\nconst double eps = 1e-10;\n\ndouble distance_l_p(P a,P b,P c);\ndouble cross(P a,P b);\n\ntypedef struct{P p;double r;}C;\n//OÚü\n//~ÌS_ðÔ_Æ,ÚüÉ½sÈüÅQÂÌ~ÌSðÊéü©çÈéOp`ðl¦éB\n//2_ÔÌ£Æ~Ì¼aÌÖW©çcos(theta)=(r0-r1)/(2_ÔÌ£)ÉÈéB\n// ÆÍ2_Ôðñ¾üªð±Ìthetaª¾¯ñ]³¹éB\npair<Line,Line> external_common_tangent(C a,C b){\n  if (a.r < b.r)swap(a,b);\n  double theta=acos((a.r-b.r)/abs(a.p-b.p));\n  double costheta=cos(theta),sintheta=sin(theta);\n\n  Line ret[2];\n  rep(i,2){\n    P v = b.p-a.p;\n    P va,vb;//vector for circle a,b\n    va.real()=v.real()*costheta-v.imag()*sintheta;\n    va.imag()=v.real()*sintheta+v.imag()*costheta;\n    va/=abs(va);\n    vb=va;\n    va*=a.r;\n    vb*=b.r;\n\n    va+=a.p;\n    vb+=b.p;\n    \n \n    ret[i]=mp(va,vb);\n    sintheta*=-1;\n  }\n\n  return mp(ret[0],ret[1]);\n}\n\n\n//¤ÊàÚü\n//ñÂÌ~ªð··éÆ«Í¶ÝµÈ¢\npair<Line,Line> internal_common_tangent(C a,C b){\n  double theta=acos((a.r+b.r)/abs(a.p-b.p));\n\n  \n  if (-eps<theta && theta<eps){\n    P v=b.p-a.p;\n    Line ret;\n\n    swap(v.real(),v.imag());\n    v.real()*=-1;\n    ret.first=(a.p+b.p)/2.;\n    ret.second=ret.first+v;\n\n    \n    return mp(ret,ret);\n  }\n\n  double costheta=cos(theta),sintheta=sin(theta);\n  Line ret[2];\n  rep(i,2){\n    P v = b.p-a.p;\n    P va,vb;//vector for circle a,b\n    va.real()=v.real()*costheta-v.imag()*sintheta;\n    va.imag()=v.real()*sintheta+v.imag()*costheta;\n    va/=abs(va);\n    vb=va;\n    va*=a.r;\n    vb*=-b.r;\n\n    va+=a.p;\n    vb+=b.p;\n    \n\n    ret[i]=mp(va,vb);\n    sintheta*=-1;\n  }\n  return mp(ret[0],ret[1]);\n}\n\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble distance_l_p(P a,P b,P c){\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool checkdist(C a,Line b,double m){\n  double dist =distance_l_p(b.first,b.second,a.p);\n  //if (dist+eps < a.r || dist-eps > a.r+m)return false;\n  //return true;\n  if (a.r-eps<=dist && dist <= a.r+m+eps)return true;\n  return false;\n}\n\nvoid output(P a,P b){\n  printf(\"[[%lf,%lf],[%lf,%lf]],\\n\",a.real(),a.imag(),b.real(),b.imag());\n}\n\nvector<Line> find_all(vector<C> &in){\n  vector<Line> ret;\n  rep(i,in.size()){\n    REP(j,i+1,in.size()){\n      if (abs(in[i].p-in[j].p)<eps)continue;\n      pair<Line,Line> tmp1=external_common_tangent(in[i],in[j]);\n      \n      ret.pb(tmp1.first);\n      ret.pb(tmp1.second);\n      if (abs(in[i].p-in[j].p)-in[i].r-in[j].r>-eps){\n\ttmp1=internal_common_tangent(in[i],in[j]);\n      \n\tret.pb(tmp1.first);\n\tret.pb(tmp1.second);\n      }\n    }\n  }\n  return ret;\n}\n\nint solve(vector<C> a,vector<double> m){\n  int ans = 1;\n  vector<C> check;\n  rep(i,a.size()){\n    check.pb((C){a[i].p,a[i].r});\n    check.pb((C){a[i].p,a[i].r+m[i]});\n  }\n\n  vector<Line> all=find_all(check);\n  \n  \n  \n\n  rep(i,all.size()){\n    int tmp = 0;\n    rep(j,a.size()){\n      if (checkdist(a[j],all[i],m[j]))tmp++;\n    }\n    ans=max(tmp,ans);\n  }\n  return ans;\n}\n\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<C> in;\n    vector<double> M;\n    rep(i,n){\n      double x,y,r,m;cin>>x>>y>>r>>m;\n      in.pb((C){P(x,y),r});\n      M.pb(m);\n    }\n    cout << solve(in,M) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<Circle> cs(n);\n    vector<Circle> ds(n);\n    for(int i=0;i<n;i++){\n      cin>>cs[i];\n      ds[i]=cs[i];\n      cin>>ds[i].r;\n      ds[i].r+=cs[i].r;\n    }\n    vector<Line> ls;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\t{\n\t  auto res=tangent(cs[i],cs[j]);\n\t  for(auto l:res) ls.emplace_back(l);\n\t}\n\t{\n\t  auto res=tangent(cs[i],ds[j]);\n\t  for(auto l:res) ls.emplace_back(l);\n\t}\n\t{\n\t  auto res=tangent(ds[i],cs[j]);\n\t  for(auto l:res) ls.emplace_back(l);\n\t}\n\t{\n\t  auto res=tangent(ds[i],ds[j]);\n\t  for(auto l:res) ls.emplace_back(l);\n\t}\n      }\n    }\n    int ans=1;\n    for(auto l:ls){\n      //cout<<l.p1<<\"***\"<<l.p2<<endl;\n      int tmp=0;\n      for(int i=0;i<n;i++){\n\tdouble d=getDistanceLP(l,cs[i].c);\n\tif(cs[i].r<=d+EPS&&d<=ds[i].r+EPS) tmp++;\n      }\n      ans=max(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\nbool intersect_CL(const Circle& c, const Line& line)\n{\n    return dist_LP(line, c.p) < c.r + 1e-9;\n}\nbool intersect_LC(const Line& line, const Circle& c)\n{\n    return intersect_CL(c, line);\n}\n\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    double d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    double t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.pb(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 外接線\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 内接線\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.pb(ext[i]);\n    rep(i, in.size())\n        res.pb(in[i]);\n    return res;\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\nconst double eps = 1e-8;\nint n;\nCircle jewel[55];\nint m[55];\nint gao(const Line& line)\n{\n    int res = 0;\n    rep(i, n)\n        if (\n            dist_LP(line, jewel[i].p) > jewel[i].r - 1e-8\n            && dist_CL(jewel[i], line) < m[i] + 1e-8)\n            ++res;\n    return res;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> jewel[i].p >> jewel[i].r >> m[i];\n\n        vector<Circle> c;\n        rep(i, n)\n        {\n            c.pb(jewel[i]);\n            c.pb(jewel[i]);\n            c.back().r += m[i];\n        }\n\n        vector<Line> cand;\n        rep(i, c.size()) rep(j, i)\n        {\n            vector<Line> t = tangent_CC(c[i], c[j]);\n            cand.insert(cand.end(), all(t));\n        }\n\n        int res = 1;\n        rep(i, cand.size())\n            chmax(res, gao(cand[i]));\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\n//2??????????????????\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\n//?????¨????????????????±???????\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return std::pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\nline tangent(const circle &c, const double &th) {\n    point h = c.o+polar(c.r,th);\n    point p = polar(c.r,th)*point(0,1);\n    return line(h-p,h+p);\n}\n\nvector<line> common_tangent(const circle &c, const circle &d) {\n    vector<line> res;\n    long double dist = abs(d.o - c.o), th = arg(d.o - c.o);\n    if (abs(c.r - d.r) < dist) { // outer\n        long double dth = acosl((c.r - d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    if (abs(c.r + d.r) < dist) {\n        long double dth = acos((c.r + d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    return res;\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    vector<long double> m(n);\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r >> m[i];\n        cs.push_back(circle(point(x,y),r));\n    }\n    rep(i,0,n) cs.push_back(circle(cs[i].o,cs[i].r+m[i]));\n\n    vector<line> ls;\n    vector<pii> idx;\n    rep(i,0,cs.size()) rep(j,i+1,cs.size()){\n        auto tmp=common_tangent(cs[i],cs[j]);\n        ls.insert(ls.end(),tmp.begin(),tmp.end());\n        rep(k,0,tmp.size()) idx.push_back(make_pair(i,j));\n    }\n\n    vector<point> ps;\n    rep(i,0,n) ps.push_back(cs[i].o);\n    rep(i,0,cs.size()) rep(j,i+1,cs.size()){\n        if(icc(cs[i],cs[j])!=1) continue;\n        auto tmp=ccc(cs[i],cs[j]);\n        ps.push_back(tmp.first);\n        ps.push_back(tmp.second);\n    }\n    rep(i,0,ps.size()) rep(j,i+1,ps.size()){\n        ls.push_back(line(ps[i],ps[j]));\n        idx.push_back(make_pair(-1,-1));\n    }\n\n    int ans=1;\n    rep(i,0,ls.size()){\n        auto &l=ls[i];\n        int cnt=0;\n        rep(j,0,n){\n            auto &c=cs[j];\n            long double d=distanceLP(l,c.o)-c.r;\n            if(j==idx[i].first or j==idx[i].second or (-eps<=d and d<=m[j]+eps)) ++cnt;\n        }\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*P(0, 1)));\n\t} else {\n\t\tD d = abs(b.p - a.p);\n\t\tP v = (a.p - b.p)/d;\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\t//P q = a.p + v*t;\n\tP q = (a.p*b.r + b.p*a.r)/(a.r+b.r);\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r>EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Circle> cs;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tPoint p(x, y);\n\t\t\tcs.push_back(Circle{ p, r });\n\t\t\tcs.push_back(Circle{ p, r + m });\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, cs.size())REP(j, i)\n\t\t{\n\t\t\tvector<Line> ls = tangent_cc(cs[i], cs[j]);\n\t\t\tREP(k, ls.size())\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(l, cs.size())\n\t\t\t\t{\n\t\t\t\t\tif (l % 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < -EPS) cnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> L;\n\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double EPS = 1e-9;\n\nint n;\nP o[52];\ndouble r[52][2];\n\nvector< L > getSessen(double x1 , double y1 , double r1, double x2 , double y2 , double r2){\n  vector< L > lines;\n  double dist = abs(P(x1 , y1) - P(x2 , y2));\n  double dr = r1 - r2;\n\n  if(abs(dr) <= dist){\n    double a = atan2(y2-y1 , x2-x1);\n    double t = acos(dr / dist);\n    P p1[2] , p2[2];\n\n    p1[0] = P(x1 + r1 * cos(a+t) , y1 + r1 * sin(a+t));\n    p1[1] = P(x1 + r1 * cos(a-t) , y1 + r1 * sin(a-t));\n\n    p2[0] = P(x2 + r2 * cos(a+t) , y2 + r2 * sin(a+t));\n    p2[1] = P(x2 + r2 * cos(a-t) , y2 + r2 * sin(a-t));\n\n    for(int i = 0 ; i < 2 ; i++){\n      L l;\n      l.push_back(p1[i]);\n      l.push_back(p2[i]);\n      lines.push_back(l);\n    }\n\n    dr = r1+r2;\n    if(dr < dist){\n      t = acos(dr / dist);\n\n      p2[0] = P(x2 + r2 * cos(a+t+PI) , y2 + r2 * sin(a+t+PI));\n      p2[1] = P(x2 + r2 * cos(a-t+PI) , y2 + r2 * sin(a-t+PI));\n\n      for(int i = 0 ; i < 2 ; i++){\n        L l;\n        l.push_back(p1[i]);\n        l.push_back(p2[i]);\n        lines.push_back(l);\n      }\n    }\n\n    else if(abs(dr- dist) < EPS){\n      p1[0] = P(x1 + r1 * cos(a) , y1 + r1 * sin(a));\n      p2[0] = P(x2 + r2 * cos(a+PI) , y2 + r2 * sin(a+PI));\n \n      L l;\n      l.push_back(p1[0]);\n      l.push_back(p2[0]);\n      lines.push_back(l);\n    }\n  }\n\n  return lines;\n}\n\ndouble dot(const P &a, const P &b){\n  return real(conj(a) * b);\n}\n\nP projection(const L &l, const P &p){\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distLP(const L &l, const P &p){\n  return abs(p - projection(l, p));\n}\n\nint solve(L l){\n  int res = 0;\n\n  for(int i = 0; i < n; i++){\n    double dist = distLP(l, o[i]);\n    if(dist - r[i][0] >= -EPS && r[i][1] - dist >= -EPS){\n      res++;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> o[i].real() >> o[i].imag() >> r[i][0] >> r[i][1];\n      r[i][1] += r[i][0];\n    }\n\n    int ans = 1;\n\n    for(int i = 0; i < n; i++){\n      for(int j = i + 1; j < n; j++){\n        for(int r1 = 0; r1 < 2; r1++){\n          for(int r2 = 0; r2 < 2; r2++){\n            vector<L> v = getSessen(o[i].real(), o[i].imag(), r[i][r1],\n                                    o[j].real(), o[j].imag(), r[j][r2]);\n            for(int k = 0; k < v.size(); k++){\n              ans = max(ans, solve(v[k]));\n            }\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator == (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS && fabs(imag(a)-imag(b)) < EPS;\n  }\n}\n\nstruct Circle{\n  P c;\n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nvector<P> getIntersectCL(Circle c, L l){\n  vector<P> res;\n  P h = proj(c.c, l);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS) res.push_back(h);\n  else{\n    P v = l.second - l.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    res.push_back(h+v);\n    res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nvector<L> tangentCC(Circle c1, Circle c2){\n  vector<L> res;\n  double d = abs(c1.c - c2.c);\n  if(d < EPS) return res;\n\n  // ?????\\???\n  if(c1.r + c2.r < d - EPS){\n    double t = acos((c1.r + c2.r) / d);\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t), c2.c + rotate(c2.r / d * (c1.c-c2.c), t)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t)));\n  }\n  else if(c1.r + c2.r < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2.0)));\n  }\n\n  // ?????\\???\n  if(abs(c1.r-c2.r) < d - EPS){\n    double t1 = acos((c1.r - c2.r) / d), t2 = M_PI - t1;\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), -t2)));\n    res.push_back(L(c1.c + rotate(c1.r / d * (c2.c-c1.c), -t1), c2.c + rotate(c2.r / d * (c1.c-c2.c), t2)));\n  }\n  else if(abs(c1.r - c2.r) < d + EPS){\n    P p = c1.c + c1.r / d * (c2.c-c1.c);\n    res.push_back(L(p, p + rotate(c2.c-c1.c, M_PI/2)));\n  }\n\n  return res;\n}\n\n\nint n;\nvector<Circle> v,w;\n\nint calc(L l){\n  int sum = 0;\n  for(int k=0;k<n;k++){\n    if(getIntersectCL(v[k], l).size() <= 1 && getIntersectCL(w[k], l).size() >= 1){\n      sum++;\n    }\n  }\n  return sum;\n}\n\nint solve(){\n  int ans = 1;\n  vector<P> pv;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      /*vector<P> res = getIntersectCC(w[i],w[j]);\n      for(int k=0;k<res.size();k++){\n        pv.push_back(res[k]);\n        }*/\n      \n      vector<L> resl = tangentCC(w[i],w[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n      \n      resl = tangentCC(v[i],v[j]);\n      for(int k=0;k<resl.size();k++){\n        ans = max(ans, calc(resl[k]));\n        //pv.push_back(resl[k].first);\n        //pv.push_back(resl[k].second);\n      }\n    }\n  }\n  \n  //pv.erase(unique(pv.begin(), pv.end()), pv.end());\n\n  \n  for(int i=0;i<pv.size();i++){\n    for(int j=i+1;j<pv.size();j++){\n      ans = max(ans, calc(L(pv[i], pv[j])));\n    }\n  }  \n\n  return ans;\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    w.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r,m;\n      cin >> x >> y >> r >> m;\n      v.push_back(Circle(P(x,y), r));\n      w.push_back(Circle(P(x,y), r+m));\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <math.h>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\nconst double EPS = 1e-8;\n\n// see: https://github.com/infnty/acm/blob/master/lib/geometry/CircleTangents.java\nvector<L> tangentLines(P a, double ar, P b, double br) {\n  vector<L> ret;\n  double d = abs(b-a);\n  rep (i,2) {\n    double sin = (ar - (1-i*2)*br) / d;\n    if (sin*sin > 1 + EPS || sin != sin) break;\n    double cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, cos * (1-j*2)) / d;\n      ret.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;\n    }\n  }\n  return ret;\n}\n\ndouble dot(P a, P b) {\n  return real(conj(a)*b);\n}\n\nP projection(L l, P p) {\n  P a = l.second - l.first;\n  p = p - l.first;\n  double t = dot(a,p) / norm(a);\n  return l.first + t*a;\n}\n\ndouble distanceLP(L l, P p) {\n  return abs(projection(l, p) - p);\n}\n\nint n;\n\nint getnum(vector<P> &c, vector<double>& r, vector<double>& m, L line) {\n  int num = 0;\n  rep(i,n) {\n    double d = distanceLP(line, c[i]);\n    if (r[i] < d + EPS && d < r[i] + m[i] + EPS) num++;\n  }\n  return num;\n}\n\nint main() {\n  while (cin >> n, n) {\n    vector<P> c(n);\n    vector<double> r(n), m(n);\n    rep (i,n) {\n      int x, y;\n      cin >> x >> y >> r[i] >> m[i];\n      c[i] = P(x,y);\n    }\n\n    int ans = 1;\n    rep(j,n) rep(i,j) rep(mi,2) rep(mj, 2) {\n      vector<L> lines = tangentLines(c[i], r[i] + mi*m[i], c[j], r[j] + mj*m[j]);\n      rep(k, lines.size()) ans = max(ans, getnum(c,r,m, lines[k]));\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define EPS (1e-12)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n    Point operator / ( Point p ) { return Point((x*p.x+y*p.y)/(p.x*p.x+p.y*p.y), (y*p.x-x*p.y)/(p.x*p.x+p.y*p.y)); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble arg(Vector p){ return atan2(p.y, p.x); }\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// verified by 920, 833, uoa2062\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n// 10514\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getTangentPoints(Point p, Circle c){\n  double d = abs(c.c - p);\n  double t = arg(c.c - p);\n  double b = sqrt(d*d - c.r * c.r);\n  double a = asin(c.r / d);\n  Point p1 = p + polar(b, t + a);\n  Point p2 = p + polar(b, t - a);\n  return make_pair(p1, p2);\n}\n\n/*\n return tangent points on c1\n */\nvector<Point> getCommonTangent(Circle c1, Circle c2){\n  vector<Point> tp;\n  Point base = c2.c - c1.c;\n  double l = abs(base);\n  double a = arg(base); // base alpha\n  if ( abs(c1.r - c2.r) < l  ){\n    double th1 = acos((c1.r - c2.r)/l);\n    tp.push_back(c1.c + polar(c1.r, a + th1));\n    tp.push_back(c1.c + polar(c1.r, a - th1));\n    if ( c1.r + c2.r < l ){\n      double th2 = acos((c1.r + c2.r)/l);\n      tp.push_back(c1.c + polar(c1.r, a + th2));\n      tp.push_back(c1.c + polar(c1.r, a - th2));\n    }\n  }\n\n  if ( (equals(l, abs(c1.r - c2.r)) || equals(c1.r + c2.r, 0) ) && !equals(l, 0) ) {\n    tp.push_back(c1.c + polar(c1.r, a));\n  }\n  \n  return tp;\n}\n\nint N;\nCircle C[50];\nCircle T[100]; // target circle\nint M[50];\n\nint solve(){\n  if ( N == 1 ) return 1;\n  vector<Line> L;\n\n  for ( int i = 0; i < N; i++ ) {\n    T[i] = C[i];\n    T[i+N] = Circle(C[i].c, C[i].r + M[i]);\n  }\n\n  for ( int i = 0; i < 2*N-1; i++ ){\n    for ( int j = i+1; j < 2*N; j++ ){\n      vector<Point> ap = getCommonTangent(T[i], T[j]);\n      for ( int k = 0; k < ap.size(); k++ ){\n\tVector v = ap[k] - T[i].c;\n\tv = polar(abs(v), arg(v) + acos(-1)/2.0);\n\tL.push_back(Line(ap[k], ap[k] + v));\n      }\n    }\n  }\n\n  int ans = 0;\n  for ( int l = 0; l < L.size(); l++ ){\n    int cnt = 0;\n    for ( int i = 0; i < N; i++ ){\n      double d = getDistanceLP(L[l], C[i].c);\n      if ( dle(C[i].r, d) && dle(d, C[i].r + M[i]) ) cnt++;\n    }\n    ans = max(ans, cnt);\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    for ( int i = 0; i < N; i++ ){\n      cin >> C[i].c.x >> C[i].c.y >> C[i].r >> M[i];\n    }\n    cout << solve() << endl;\n  }\n\t\t\t  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <array>\n#include <complex>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\ntypedef array<point, 2> line;\nstruct circle {point p; double r;};\n\npoint projection(const line& l, const point& p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\n/*\n * 円の接線\n *\n * t は交点と円の中心を通る直線と、接線のなす角\n */\nline tangent(circle c, double t){\n\tpoint p = c.p + polar(c.r, t);\n\tpoint d = polar(c.r, t) * point(0, 1);\n\treturn {{p - d, p + d}};\n}\n\nvector<line> common_tangents(circle c1, circle c2) {\n\tvector<line>  ret;\n\tdouble t = arg(c2.p - c1.p);\n\tdouble d = acos((c1.r - c2.r) / abs(c2.p - c1.p));\n\tdouble dst = abs(c2.p - c1.p);\n\n\tif(abs(c2.r - c1.r) < dst) {\n\t\t//外接線\n\t\tret.push_back(tangent(c1, t - d));\n\t\tret.push_back(tangent(c1, t + d));\n\t}\n\td = acos((c1.r + c2.r) / abs(c2.p - c1.p));\n\tif(abs(c2.r + c1.r) < dst){\n\t\t//内接線\n\t\tret.push_back(tangent(c1, t - d));\n\t\tret.push_back(tangent(c1, t + d));\n\t}\n\treturn ret;\n}\n\nvector<tuple<circle, int>> jewels;\n\nlong get_count(const circle& a, const circle& b) {\n\tlong cnt = 0;\n\tvector<line> ct = common_tangents(a, b);\n\tfor (const auto& l : ct) {\n\t\tcnt = max(cnt, count_if(jewels.begin(), jewels.end(), [&](const tuple<circle, int>& t){\n\t\t\tdouble dist = distanceLP(l, get<0>(t).p);\n\t\t\treturn dist + EPS > get<0>(t).r && dist < get<0>(t).r + get<1>(t) + EPS;\n\t\t}));\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tjewels.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, m;\n\t\t\tdouble r;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tjewels.emplace_back(circle({point(x, y), r}), m);\n\t\t}\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tauto a = jewels[i];\n\t\t\t\tauto b = jewels[j];\n\t\t\t\tans = max(ans, get_count(get<0>(a), get<0>(b)));\n\t\t\t\tcircle am = {get<0>(a).p, get<0>(a).r + get<1>(a)};\n\t\t\t\tcircle bm = {get<0>(b).p, get<0>(b).r + get<1>(b)};\n\t\t\t\tans = max(ans, get_count(am, bm));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n// ÀW(xNg)\ntypedef complex<double> P;\n// ½p`(¶ñ]ðOñÆ·é)\ntypedef vector<P> G;\n// ¼ü\nstruct L : public vector<P>\n{\n\tL(P a, P b) { push_back(a); push_back(b); }\n};\n\n\n// î{Ö(è)\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\nvector<L> common_lineCC(P a, double ra, P b, double rb)\n{\n\tdouble k,kc; P s,t;\n\tkc = atan2(Y(b-a),X(b-a));\n\n\tvector<L> ret;\n\n\tfor(int i=-1; i<=1; i+=2)\n\tfor(int j=-1; j<=1; j+=2)\n\t{\n\t\tk = kc + j*asin( (rb+i*ra)/abs(b-a) );\n\t\ts = a  + polar( ra, k-i*j*PI/2);\n\t\tt = s  + polar(100.0, k);\n\n\t\tret.push_back( L(s,t) );\n\t}\n\n\treturn ret;\n}\n\ndouble s_distLP(P a, P b, P p)\n{\n\treturn abs(cross(b-a, p-a))/abs(b-a);\n}\n\n\nP p[64];\ndouble r[64],m[64];\nvector<L> line;\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tif(N==1)\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> X(p[i]) >> Y(p[i]) >> r[i] >> m[i];\n\t\t}\n\n\t\tint mx=0,tm;\n\t\tfor(int i=0; i<N-1; i++)\n\t\tfor(int j=i+1; j<N; j++)\n\t\t{\n\t\t\tdouble ra[] = {r[i], r[i]+m[i]};\n\t\t\tdouble rb[] = {r[j], r[j]+m[j]};\n\n\t\t\tfor(int ii=0; ii<2; ii++)\n\t\t\tfor(int jj=0; jj<2; jj++)\n\t\t\t{\n\t\t\t\tline = common_lineCC(p[i],ra[ii],p[j],rb[jj]);\n\n\t\t\t\tfor(int k=0; k<4; k++)\n\t\t\t\t{\n\t\t\t\t\ttm=0; double dis;\n\t\t\t\t\tfor(int n=0; n<N; n++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis = s_distLP(line[k][0],line[k][1],p[n]);\n\t\t\t\t\t\tif( r[n]-EPS <= dis && dis<=r[n]+m[n]+EPS )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmx = max(tm,mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int, int> P;\n#define ISEQ(c) (c).begin(), (c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nnamespace Ps{\n\ttypedef long double D;\n\ttypedef complex<D> P;\n\tconst D EPS = 1e-6;\n\tconst D INF = 1e12;\n\n#define X real()\n#define Y imag()\n\n\ttemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\ttemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\n\ttemplate<typename T> double norm(T a){ return a*a;}\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\tint ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t}\n\n\t//浮動小数点modで非負の値のみかえす．\n\tdouble pfmod(double v,double MOD){\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t}\n\n\t//[0,PI)\n\tdouble AbsArg(double a){\n\t  \tdouble ret=pfmod(max(a,-a),2*M_PI);\n\t  \treturn min(ret,2*M_PI-ret);\n\t}\n\t\n}\nusing namespace Ps;\n\n\nnamespace Ls{\n\tstruct L : public vector<P> {\n\t  L(const P &a, const P &b) {\n\t    push_back(a); push_back(b);\n\t  }\n\t};\n\n\t//直線へ射影した時の点\n\tP projection(const L &l, const P &p) {\n\t  D t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\t  return l[0] + t*(l[0]-l[1]);\n\t}\n\n\tD distanceLP(const L &l, const P &p) {\n\t  return abs(p - projection(l, p));\n\t}\n\n}\nusing namespace Ls;\n\n\n\nnamespace std{\n\tbool operator < (const P& a,const P& b){\n    \t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  \t}\n  \tbool operator == (const P& a,const P& b){\n    \t\treturn eq(a,b);\n   \t}\n};\n\nnamespace Cs{\n\tstruct C {\n \t\t P o; D r;\n \t\t C(const P &o,D r) : o(o), r(r) { }\n\t};\n\n\t// 包含関係\n\tenum RELATION{INCOMPARABLE=0,SAME=1,CONTAIN=2,OVER=4};\n\tpair<RELATION,int> cRel(const C& c1,const C& c2){\n\t\tD d=abs(c1.o-c2.o);\n\t\tif(eq(c1.o,c2.o) && eq(c1.r,c2.r))return make_pair(SAME,1<<28);// c1 == c2\n\t\tif(sig(d,c1.r-c2.r)<0)return make_pair(OVER,0); // c2 ⊆ c1\n\t\tif(sig(d,c2.r-c1.r)<0)return make_pair(CONTAIN,0); // c1 ⊆ c2\n\t\tif(sig(d,c1.r-c2.r)==0)return make_pair(OVER,1);// c2 ⊆ c1,1点で接する\n\t\tif(sig(d,c2.r-c1.r)==0)return make_pair(CONTAIN,1);// c1 ⊆ c2,1点で接する\n\t\tif(sig(d,c1.r+c2.r)==0)return make_pair(INCOMPARABLE,1);// 1点で接する\n\t\tif(sig(d,c1.r+c2.r)<0)return make_pair(INCOMPARABLE,2);//  2点で接する\n\t\treturn make_pair(INCOMPARABLE,0);// 交わらない\n\t}\n\n\t// 点p を通る 円c の接点\n\tvector<P> ContactCP(const C& c,const P& p){\n\t\tvector<P> res;\n\t\tD d=abs(c.o-p);\n\t\tif(sig(c.r,d)==0){\n\t\t\tres.push_back(p);return res;\n\t\t}\n\t\tif(sig(c.r,d)>0)return res;\n\n\t\tD theta=acos(c.r/d),phi=arg(p-c.o);\n\t\tres.push_back(c.o + polar(c.r,phi+ theta));res.push_back(c.o + polar(c.r,phi- theta));\t\t\n\t\treturn res;\n\t}\n\n\t//共通接線  仮定：2円は異なる．\n\tvector<L> ContactCC(const C& c1,const C& c2){\n\t\tpair<RELATION,int> rel=cRel(c1, c2);\n\t\t//DUMP(rel.first);DUMP(rel.second);\n\t\tvector<L> res;\n\t\tif(rel.first==SAME)return res;\n\t\tif(rel.first!=INCOMPARABLE && rel.second==0)return res;\n\t\tP dir=c2.o - c1.o;\n\t\t//external\n\t\t{\n\t\t\tD th=arg(dir),a=acos((c2.r-c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a)));\n\t\t}\n\t\t//internal\n\t\tif(rel.first==INCOMPARABLE && rel.second<2){\n\t\t\tD th=arg(dir),a=acos((c2.r+c1.r)/abs(dir));\n\t\t\tres.push_back(L(c1.o + polar(c1.r,th+a),c2.o + polar(c2.r,th+a + M_PI)));\n\t\t\tif(sig(a)!=0)res.push_back(L(c1.o + polar(c1.r,th-a),c2.o + polar(c2.r,th-a + M_PI)));\n\t\t}\n\t\treturn res;\n\t}\n\n}\nusing namespace Cs;\n\nnamespace std{\n  \tbool operator == (const C& a,const C& b){\n    \treturn cRel(a,b).first==SAME;\n   \t}\n};\n\n\nint main() {\n\twhile(true){\n\t\tint N;cin >> N;if(N==0)break;\n\t\tvector<C> cs1,cs2,cs;\n\t\tREP(i,N){\n\t\t\tD x,y,r,m;cin >> x >> y >>r >> m;\n\t\t\tcs1.push_back(C(P(x,y),r));cs2.push_back(C(P(x,y),r+m));\n\t\t\tcs.push_back(C(P(x,y),r));cs.push_back(C(P(x,y),r+m));\n\t\t}\n\n\t\tint Mv=0;if(N==1)Mv=max(Mv,1);\n\t\tREP(i,2*N)REP(j,2*N){\n\t\t\tvector<L> ls=ContactCC(cs[i],cs[j]);\n\t\t\tREP(k,ls.size()){\n\t\t\t\tint v=0;\n\t\t\t\tREP(s,N){\n\t\t//\t\tcout <<\"d: \"<<i<<\" \"<<j <<\" \"<<s<<\":\"<<distanceLP(ls[k],cs1[s].o)<<endl;\n\t\t\t\t\tif(sig(cs1[s].r,distanceLP(ls[k],cs2[s].o))<=0 && sig(distanceLP(ls[k],cs2[s].o),cs2[s].r)<=0){\n\t\t\t\t\t\tv++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMv=max(Mv,v);\n\t\t\t}\n\t\t}\n\n\t\tcout << Mv <<endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\n#include <complex>\ntypedef complex<double> Point;\n\n// 誤差を加味した符号判定\nint sign(double a){\n  if(a > EPS) return +1;\n  if(a < -EPS) return -1;\n  return 0;\n}\n\n// 誤差を加味した同一判定\nbool equal(double a, double b){ \n  return abs(b - a) < EPS;\n}\n// 内積・外積\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上(またはb == c)\n}\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return abs(p - projection(l, p));\n}\nstruct Circle {\n  Point c;\n  double r;\n  Circle() {}\n  Circle(Point c, double r) : c(c), r(r) { }\n};\n\n// 円と点の交差判定(境界を含む)\nbool containCP(const Circle& C, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return sign(abs(C.c - p) - C.r) <= 0;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool intersectCC(const Circle& C, const Circle& D){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  double e = abs(C.c - D.c);\n  return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\nint N;\nPoint ps[100];\ndouble r[100][2];\nint count(Line l){\n  int res = 0;\n  REP(i, N){\n    double d = distanceLP(l, ps[i]);\n    if(sign(d - r[i][0]) >= 0 && sign(r[i][1] - d) >= 0){\n      res++;\n    }\n  }\n  return res;\n}\n// 円の接線 (中心から偏角thの点で接する接線)\nLine circle_tangent(Circle& C, double th){\n  Point p0 = C.c + polar(C.r, th);\n  Point p1 = p0 + polar(1.0, th + M_PI / 2);\n  return Line(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\nvector<double> common_tangents(Circle& C, Circle& D){\n  vector<double> res;\n  Point v = D.c - C.c;\n  double l = abs(v); // 二円の中心間の距離\n  double a = arg(v); // 二円の中心間の偏角\n  if(sign(l - abs(C.r - D.r)) > 0){\n    // 交わる or 外接 or 離れている\n    // 二つの外側接線\n    double a1 = acos((C.r - D.r) / l);\n    res.push_back(a + a1);\n    res.push_back(a - a1);\n    if(sign(l - (C.r + D.r)) > 0){\n      // 離れている\n      // 二つの内側接線\n      double a2 = acos((C.r + D.r) / l);\n      res.push_back(a + a2);\n      res.push_back(a - a2);\n    }\n  }\n  if((equal(abs(C.r - D.r), l) || equal(C.r + D.r, l)) && sign(l) != 0){\n    // 内接 or 外接\n    // 一つの接線\n    res.push_back(a);\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> N && N){\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag() >> r[i][0] >> r[i][1];\n    REP(i, N) r[i][1] += r[i][0];\n    int ans = 0;\n    REP(i, N) REP(j, N) REP(k, 2) REP(l, 2){\n      Circle C(ps[i], r[i][k]);\n      Circle D(ps[j], r[j][l]);\n      vector<double> args = common_tangents(C, D);\n      args.push_back(0); // 適当な接線\n      FORIT(arg, args){\n        Line t_line = circle_tangent(C, *arg);\n        ans = max(ans, count(t_line));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nD cross(P a,P b){\n  return (conj(a)*b).Y;\n}\nD dot(P a,P b){\n  return (conj(a)*b).X;\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct C{\n  P p; D r;\n  C(const P& p,D r):p(p),r(r){}\n};\n\nenum RELATION{SAME=1,CONTAINED=2,OVER=4,NO_CROSS=8,ONE_CROSS=16,ONE_CONTAINED_CROSS=32,ONE_OVER_CROSS=64,TWO_CROSS=128};\nint cRel(C c1, C c2) {\n  D d=abs(c1.p-c2.p);\n  D dr1=c1.r-c2.r,dr2=c2.r-c1.r;\n  D ar=c1.r+c2.r;\n  if(d<eps&&c1.r==c2.r)return SAME;\n  if(d<dr1)return OVER;\n  if(d<dr2)return CONTAINED;\n  if(d==dr1)return ONE_OVER_CROSS;\n  if(d==dr2)return ONE_CONTAINED_CROSS;\n  if(d==ar)return ONE_CROSS;\n  if(d>ar)return NO_CROSS;\n  return TWO_CROSS;\n}\n\nL tanC(C c,D t){\n    P p=c.p+polar(c.r,t);\n    P d=polar(c.r,t)*P(0,1);\n    return L(p-d,p+d);\n}\nvector<L> tanCC(C c1,C c2){\n  vector<L> res;\n  D d=arg(c2.p-c1.p);\n  D i=acos((c1.r+c2.r)/abs(c2.p-c1.p));\n  D o=acos((c1.r-c2.r)/abs(c2.p-c1.p));\n  int r=cRel(c1,c2);\n  if(r==NO_CROSS){\n    res.push_back(tanC(c1,d+i));\n    res.push_back(tanC(c1,d-i));\n  }\n  if(!(r&(SAME|CONTAINED|OVER|ONE_CONTAINED_CROSS|ONE_OVER_CROSS))){\n    res.push_back(tanC(c1,d+o));\n    res.push_back(tanC(c1,d-o));\n  }\n  if(r&(ONE_CROSS|ONE_CONTAINED_CROSS|ONE_OVER_CROSS)){\n    res.push_back(tanC(c1,d));\n  }\n  return res;\n}\n\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(const L& l,const P& p) {\n  return abs(p-projection(l,p));\n}\n\nint n;\n\nint main(){\n\tcin.sync_with_stdio(false);\n  vector<L> hoge=tanCC(C(P(0,0),1),C(P(2,2),5));\n  rep(i,hoge.size()){\n    cout<<hoge[i][0]<<\" \"<<hoge[i][1]<<endl;\n  }\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<C> a;\n    rep(i,n){\n      D x,y,r,m;\n      cin>>x>>y>>r>>m;\n      a.push_back(C(P(x,y),r));\n      a.push_back(C(P(x,y),r+m));\n    }\n    int res=1;\n    rep(i,a.size())rep(j,i){\n      vector<L> tmp=tanCC(a[i],a[j]);\n      rep(k,tmp.size()){\n        int s=0;\n        for(int l=0;l<a.size();l+=2){\n          if(a[l].r-eps<=distanceLP(tmp[k],a[l].p)&&distanceLP(tmp[k],a[l].p)<=a[l+1].r+eps){\n            s++;\n          }\n        }\n        maxch(res,s);\n      }\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\n// ????????????????§???????????????????????????\\??????????????????????????¨???????????????\ntypedef complex<double> PT;\ntypedef complex<double> VC;\n// ??´?????????????????????????§?????????????????????\\??§??\\??????typedef\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n// ????????????????§????\ntypedef pair<PT,double> CIR;\n\n// paramater\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\n// ??´??? or ???????????????????????????????????????\nVC get_vc_normal(VC a) {\n\ta = a * PT(0,-1);\n\treturn a / abs(a);\n}\n\n// ??±?????\\???(common tangent) ?????????????????????????????¨?????????????????§??¨???(???????????\\????????????)\nvector<LN> get_comm_tan(CIR c0, CIR c1) {\n\tvector<LN> res;\n\tVC v, n;\n\tdouble d;\n\tdouble theta, phi, psi;\n\tconst int sign[] = {1,-1};\n\n\tif(c0.se > c1.se)\n\t\tswap(c0,c1);\n\tv = c1.fi-c0.fi;\n\tn = get_vc_normal(v);\n\td = abs(v);\n\ttheta = arg(v);\n\t// ??±?????\\?????????\n\tif(d < abs(c1.se-c0.se) + EPS)\n\t\treturn res;\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(abs(c1.se-c0.se)-d) < EPS || d < abs(c1.se-c0.se)) {\n\t\t// ????????\\??????\n\t\tassert(abs(c1.se-c0.se) > EPS);\n\t\tv *= c0.se / (c1.se - c0.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse {\n\t\tphi = asin((c1.se-c0.se)/d) + M_PI / 2.0;\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\tc1.fi + polar(c1.se, psi)));\n\t\t}\n\t}\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(c0.se + c1.se - d) < EPS) {\n\t\t// ????????\\??????\n\t\tv *= c0.se / (c0.se + c1.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse if(c0.se + c1.se < d) {\n\t\tphi = acos((c0.se+c1.se)/d);\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\t\tc1.fi + polar(c1.se, psi + M_PI)));\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b)) / abs(l.fi-l.se);\n}\n\n// rest code\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<vector<int> > v;\n\t\tvector<CIR> circle;\n\t\tvector<LN> line;\n\t\tv.resize(n);\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tv[i].resize(4);\n\t\t\tfor(int j = 0; j < 4; j++)\n\t\t\t\tcin >> v[i][j];\n\t\t\tcircle.push_back(CIR(PT(v[i][0], v[i][1]), v[i][2]));\n\t\t\tcircle.push_back(CIR(PT(v[i][0], v[i][1]), v[i][2] + v[i][3]));\n\t\t}\n\t\tfor(int i = 0; i < circle.size(); i++) {\n\t\t\tfor(int j = 1; j < circle.size(); j++) {\n\t\t\t\tvector<LN> tmp;\n\t\t\t\ttmp = get_comm_tan(circle[i],circle[j]);\n\t\t\t\tline.insert(line.end(), tmp.begin(), tmp.end());\n\t\t\t}\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tdouble d;\n\t\t\t\td = dist_pts_line(PT(v[j][0],v[j][1]), line[i]);\n\t\t\t\tif(v[j][2] - EPS < d && d < v[j][2] + v[j][3] + EPS)\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nconst int MAX_N = 52;\n\nint X[MAX_N],Y[MAX_N],R[MAX_N],M[MAX_N];\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        cin >> n;\n        if(n== 0){\n            break;\n        }\n        rep(i,n){\n            cin >> X[i] >> Y[i] >> R[i] >> M[i];\n        }\n        if(n == 1){\n            cout << \"1\\n\";\n            continue;\n        }\n        int ans = 0;\n        rep(i,n){\n            for(int j = i+1;j<n;j++){\n                vector<L> LL = gettangentCC(C(X[i],Y[i]),R[i],C(X[j],Y[j]),R[j]);\n                int res;\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i]+M[i],C(X[j],Y[j]),R[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i],C(X[j],Y[j]),R[j]+M[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n                LL.clear();\n                LL = gettangentCC(C(X[i],Y[i]),R[i]+M[i],C(X[j],Y[j]),R[j]+M[j]);\n                rep(k,LL.size()){\n                    res = 2;\n                    rep(l,n){\n                        if(l != i && l != j){\n                            double dir = distanceLP(LL[k],C(X[l],Y[l]));\n                            if(dir > R[l] - EPS && dir < R[l] + M[l] + EPS){\n                                res++;\n                            }\n                        }\n                    }\n                    ans = max(ans,res);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nconst double EPS = 1e-8;\n\nusing R = long double; // Rにmint渡せるようにする\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n    P c; R r;\n    C() {}\n    C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n    S() {}\n    S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n    return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n    return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n    bool cmp_y (const P& a, const P& b) {\n        return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n    }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n    R x, y;\n    is >> x >> y;\n    p = P(x, y);\n    return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n    P a, b;\n    is >> a >> b;\n    l = L(a, b);\n    return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n    P a, b;\n    is >> a >> b;\n    s = S(a, b);\n    return is;\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\nint intersect(const C& a, const C& b) {\n\tR dist = sqrt(norm(a.c-b.c)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(sgn(r1-dist) < 0)  return 4;\t// 円が離れている\n\tif(sgn(r1-dist) == 0) return 3;\t// 外接\n\tif(sgn(r2-dist) < 0 && sgn(dist-r1) < 0) return 2; // 交差\n\tif(sgn(dist-r2) == 0) return 1; // 内接\n\treturn 0;\t// 内部に含む\n}\n\n// 点aを通る接線を返す\n// pl = ((a, 接線と円の交点), (a, 接線と円の交点))\npair<L,L> tangent(C c, P a) {\n    pair<L,L> pl;\n    if(sgn(abs(a-c.c)-c.r) == 0) { // 点aが円周上にあるとき 要verify\n        auto normal = [](P a) {\n            L vp({a*P(0,1), a*P(0,-1)});\n            return vp;\n        };\n        L l = normal(a-c.c); // 法線ベクトル\n        l.first = a; l.second += a;\n        pl.first = pl.second = l;\n    } else if(sgn(abs(a-c.c)-c.r) > 0) { // 点aが円の外側にあるとき\n        R xp = a.real() - c.c.real();\n        R yp = a.imag() - c.c.imag();\n        R A = sqrt(xp*xp + yp*yp - c.r*c.r);\n        R B = xp*xp + yp*yp;\n        P p1(c.r*(xp*c.r + yp*A)/B , c.r*(yp*c.r - xp*A)/B);\n        P p2(c.r*(xp*c.r - yp*A)/B , c.r*(yp*c.r + xp*A)/B);\n        pl = make_pair(L(a, p1+c.c), L(a, p2+c.c));\n    } else { // 点 a が円の内側にあるとき\n        pl.first = pl.second = L(P(INF,INF), P(INF,INF));\n    }\n    return pl;\n}\n\n// 2つの円の共通接線の計算に使用\n// flag=true のとき内接線, falseのとき外接線\nL common_tangent(const C& c1, const C& c2, bool flag) {\n    R xp = c2.c.real() - c1.c.real();\n    R yp = c2.c.imag() - c1.c.imag();\n    R r = flag ? c1.r + c2.r : c1.r - c2.r;\n    R A = sqrt(xp*xp + yp*yp - r*r);\n    R B = xp*xp + yp*yp;\n    P p1(c1.r*(xp*r + yp*A)/B, c1.r*(yp*r - xp*A)/B);\n    P p2(c1.r*(xp*r - yp*A)/B, c1.r*(yp*r + xp*A)/B);\n    p1 += c1.c; p2 += c1.c;\n    return L(p1, p2);\n}\n// 2円の共通接線を返す\n// vl = {(c1の接点, c2の接点), …, (c1の接点, c2の接点)}\nvector<L> common_tangent(C c1, C c2) {\n    vector<L> vl;\n    int pos = intersect(c1, c2);\n    // 2つの共通内接線を求める\n    L pp1 = common_tangent(c1, c2, true);\n    L pp2 = common_tangent(c2, c1, true);\n    if(pos == 4) { // 2つの円が離れているとき\n        vl.push_back(L(pp1.first, pp2.first));\n        vl.push_back(L(pp1.second, pp2.second));\n    } else if(pos == 3) { // 外接するとき\n        vl.push_back(tangent(c1, pp1.first).first);\n    }\n    // 2つの共通外接線を求める\n    pp1 = common_tangent(c1, c2, false);\n    pp2 = common_tangent(c2, c1, false);\n    if(pos >= 2) { // 2つの円が交わるとき\n        vl.push_back(L(pp1.first, pp2.second));\n        vl.push_back(L(pp1.second, pp2.first));\n    } else if(pos == 1) { // 2つの円が内接するとき\n        vl.push_back(tangent(c1, pp1.first).first);\n    }\n    return vl;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n    R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nR dist(const L& l, const P& p) {\n    P q = projection(l, p);\n    return abs(p-q);\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        ll n;\n        cin >> n;\n        if(n == 0) break;\n        vector<R> m(n*2);\n        vector<C> c(n*2);\n        REP(i, n) cin >> c[i].c >> c[i].r >> m[i];\n        REP(i, n) c[i+n].c = c[i].c, c[i+n].r = c[i].r + m[i], m[i+n]=m[i];\n        if(n == 1) {\n            cout << 1 << endl;\n            continue;\n        }\n\n        ll ans = 0;\n        REP(i, 2*n) FOR(j, i+1, 2*n) {\n            if(abs(i-j) == n) continue;\n            auto vl = common_tangent(c[i], c[j]);   \n            for(auto l: vl) {\n                ll ret = 0;\n                REP(k, n) {\n                    R d = dist(l, c[k].c) - c[k].r;\n                    if(sgn(d)>=0 && sgn(m[k]-d)>=0) {\n                        ret++;\n                    }\n                }\n                chmax(ans, ret);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPS(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EPS (1e-10)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\nP p[50];\nint r[50];\nint m[50];\nint n;\n\nclass Line{\npublic:\n  P pp;\n  P d;\n  Line(){}\n  Line(P pos, P dir){pp=pos; d=dir/abs(dir);}\n};\n\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\ndouble dist(const Line &l, const P &pp){\n  return abs(outp(l.d, pp-l.pp) / abs(l.d));\n}\n\nint cnt(const Line &l){\n  int ret = 0;\n  REP(i,n){\n    double d = dist(l,p[i]);\n    if(d >= r[i]-EPS && d <= r[i]+m[i]+EPS) ret++;\n  }\n  return ret;\n}\n\nint main(){\n  while(scanf(\"%d\",&n), n){\n    REP(i,n){\n      int a,b,c,d;\n      scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n      p[i].real() = a; p[i].imag() = b;\n      r[i] = c;        m[i] = d;\n    }\n    int ans = 0;\n    if(n == 1){\n      puts(\"1\");\n      continue;\n    }\n\n    REP(i,n) REPS(j,i+1,n) REP(k,2) REP(l,2){\n      P p1 = p[i], p2 = p[j];\n      P v = p2 - p1;\n      double r1 = r[i];\n      double r2 = r[j];\n      if(k==1) r1 += m[i];\n      if(l==1) r2 += m[j];\n      //cout << p1 << \" \" << r1 <<endl;\n      //cout << p2 << \" \" << r2 <<endl;\n\n      REP(t,2){\n\tdouble tmp;\n\tif(t==0) tmp = abs(r1 - r2) / abs(v);\n\tif(t==1) tmp = abs(r1 + r2) / abs(v);\n\tif(tmp <= 1.0){\n\t  {\n\t    double theta = acos(tmp);\n\t    P vv = (v/abs(v)) * P(cos(theta), sin(theta));\n\t    P start = p1 + r1*vv;\n\t    Line ln(start,vv*P(0,1));\n\t    //printf(\"i=%d, j=%d: (%f, %f), (%f, %f)\\n\",i,j,start.real(),start.imag(),(vv*P(0,1)).real(),(vv*P(0,1)).imag());\n\t    ans = max(ans, cnt(ln));\n\t  }\n\t  {\n\t    double theta = -acos(tmp);\n\t    P vv = (v/abs(v)) * P(cos(theta), sin(theta));\n\t    P start = p1 + r1*vv;\n\t    Line ln(start,vv*P(0,1));\n\t    //printf(\"i=%d, j=%d: (%f, %f), (%f, %f)\\n\",i,j,start.real(),start.imag(),(vv*P(0,1)).real(),(vv*P(0,1)).imag());\n\t    ans = max(ans, cnt(ln));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tif(n>1000) cout<<\"baka\"<<endl;\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n// 2円の接線を求める。\nvector<Line> getTangentialLine(Circle a, Circle b)\n{\n\tvector<Line> ret;\n\tP2 v = b.c - a.c;\n\tdouble d = v.length();\n\tdouble bt = v.arg();\n\n\tif (d - abs(a.r - b.r) > EPS) // 外接線2本\n\t{\n\t\tdouble dt = acos((a.r - b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c + P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c + P2::polar(b.r, t2)));\n\t}\n\telse if (d - abs(a.r - b.r) > -EPS) // 外接線1本 (内接)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\tif (d - (a.r + b.r) > EPS) // 内接線2本 (離れている)\n\t{\n\t\tdouble dt = acos((a.r + b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c - P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c - P2::polar(b.r, t2)));\n\t}\n\telse if (d - (a.r + b.r) > -EPS) // 内接線1本 (接している)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\treturn ret;\n}\n\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct xyrm{ P2 p; double r, m; int i; };\n\t\tvector<xyrm> gems;\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, r, m);\n\t\t\tgems.push_back({ P2(x, y), r, m, _ });\n\t\t}\n\t\tint result = 1;\n\t\tfor (auto i : gems) for (auto j : gems)\n\t\t{\n\t\t\t//WRITE(\"i:\", i.i, \"j:\", j.i);\n\t\t\tauto cand = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r));\n\t\t\tauto cand2 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r));\n\t\t\tauto cand3 = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r + j.m));\n\t\t\tauto cand4 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r + j.m));\n\n\t\t\tvector<Line> lines;\n\t\t\tcopy(allof(cand), back_inserter(lines));\n\t\t\tcopy(allof(cand2), back_inserter(lines));\n\t\t\tcopy(allof(cand3), back_inserter(lines));\n\t\t\tcopy(allof(cand4), back_inserter(lines));\n\n\t\t\tfor (auto l : lines)\n\t\t\t{\n\t\t\t\t//WRITE(l.p, l.d);\n\t\t\t\tresult = max(result, count_if(allof(gems), PREDICATE(xyrm, g, inRange(getDistance(l, g.p), g.r, g.r + g.m))));\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\ntypedef double Real;\nReal eps = 1e-12;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2?????????\nP intersection(P p1, P p2, P q1, P q2) {\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\ninline Real square(Real x) {return x*x;}\n// ??´???p1-p2??¨???q????????¢\nReal dist(P p1, P p2, P q) {\n    q = q-p1;\n    p2 = p2-p1;\n    return sqrt((q.dot(q)*p2.dot(p2) - square(q.dot(p2))) / p2.dot(p2));\n}\n\nconst int MAXN = 55;\nint N;\nP ps[MAXN];\nReal R[MAXN], M[MAXN];\n\n// ax+by+c = 0 ?????´?????§????????????\nint calc(Real a, Real b, Real c) {\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble d = abs(a*ps[i].x + b*ps[i].y + c) / sqrt(a*a+b*b);\n\t\tif (d >= R[i]-eps && d <= R[i]+M[i]+eps) ret++;\n\t}\n\treturn ret;\n}\n\nvoid getCoeff1(Real xp, Real yp, Real inSqrt, Real* xq, Real* yq, Real r, Real R) {\n\t*xq = r*(xp*(r+R)+yp*sqrt(inSqrt))/(xp*xp+yp*yp);\n\t*yq = r*(yp*(r+R)-xp*sqrt(inSqrt))/(xp*xp+yp*yp);\n}\nvoid getCoeff2(Real xp, Real yp, Real inSqrt, Real* xq, Real* yq, Real r, Real R) {\n\t*xq = r*(xp*(r+R)-yp*sqrt(inSqrt))/(xp*xp+yp*yp);\n\t*yq = r*(yp*(r+R)+xp*sqrt(inSqrt))/(xp*xp+yp*yp);\n}\n\nint ans;\n\nvoid hoge(int i, int j, Real Rj) {\n\tReal xp = ps[j].x-ps[i].x;\n\tReal yp = ps[j].y-ps[i].y;\n\tReal tmp = (xp*xp+yp*yp)-(R[i]+Rj)*(R[i]+Rj);\n\tif (tmp >= 0) {\n\t\tdouble xq, yq;\n\t\tgetCoeff1(xp, yp, tmp, &xq, &yq, R[i], Rj);\n\t\tans = max(ans, calc(xq, yq, -xq*ps[i].x-yq*ps[i].y-R[i]*R[i]));\n\t\tgetCoeff2(xp, yp, tmp, &xq, &yq, R[i], Rj);\n\t\tans = max(ans, calc(xq, yq, -xq*ps[i].x-yq*ps[i].y-R[i]*R[i]));\n\t}\n\ttmp = (xp*xp+yp*yp)-(R[i]-Rj)*(R[i]-Rj);\n\tif (tmp >= 0) {\n\t\tdouble xq, yq;\n\t\tgetCoeff1(xp, yp, tmp, &xq, &yq, R[i], -Rj);\n\t\tans = max(ans, calc(xq, yq, -xq*ps[i].x-yq*ps[i].y-R[i]*R[i]));\n\t\tgetCoeff2(xp, yp, tmp, &xq, &yq, R[i], -Rj);\n\t\tans = max(ans, calc(xq, yq, -xq*ps[i].x-yq*ps[i].y-R[i]*R[i]));\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> N) {\n\t\tif (N==0) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> ps[i].x >> ps[i].y >> R[i] >> M[i];\n\t\tans = 1;\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (i!=j) {\n\t\t\thoge(i, j, R[j]);\n\t\t\thoge(i, j, R[j]+M[j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**** Geometrical Library (complex class version) ****/\n\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tcomplex<double>\tPoint;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &C,double R):c(C),r(R){}\n};\n\nnamespace std{\n\tbool operator <(const Point &a,const Point &b){\n\t\treturn (real(a)==real(b))?(imag(a)<imag(b)):(real(a)<real(b));\n\t}\n\tbool operator >(const Point &a,const Point &b){\n\t\treturn b<a;\n\t}\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\tPoint v(a,b);\n\treturn p-(dot(p,v)+c)*v/norm(v);\n}\n\nint intersect(const Circle &c,const Line &l,Point *p=NULL,Point *q=NULL){\n\tPoint m=perp_foot(c.c,l);\n\tdouble d2=norm(c.c-m);\n\tif(c.r*c.r+EPS<d2)\treturn 0;\n\telse if(abs(c.r*c.r-d2)<EPS){\n\t\tif(p&&q)\t*p=*q=m;\n\t\treturn 1;\n\t}\n\telse{\n\t\tif(p&&q){\n\t\t\tPoint v;\n\t\t\tdouble n0=norm(l[0]-m),n1=norm(l[1]-m);\n\t\t\tif(n0<n1)\tv=l[1]-m,n0=n1;\n\t\t\telse\t\tv=l[0]-m;\n\t\t\tv*=sqrt((c.r*c.r-d2)/n0);\n\t\t\t*p=m+v,*q=m-v;\n\t\t}\n\t\treturn 2;\n\t}\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nvoid addCommonTangent(vector<Line> &lns,const Circle &c1,const Circle &c2){\n\tdouble d2=norm(c1.c-c2.c);\n\tdouble rsum2=(c1.r+c2.r)*(c1.r+c2.r);\n\tdouble rdif2=(c1.r-c2.r)*(c1.r-c2.r);\n\tPoint u=(c2.c-c1.c)/abs(c2.c-c1.c);\n\n\tPoint v;\n\tdouble theta;\n\tif(d2>rsum2+EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\n\t\ttheta=acos(sqrt(rsum2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c-c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c-c2.r*v));\n\t}\n\telse if(d2>rsum2-EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\n\t\tv=u*Point(0,1);\tlns.pb(Line(c1.r*u,c1.r*u+v));\n\t}\n\telse if(d2>rdif2+EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t}\n\telse if(d2>rdif2-EPS){\n\t\tv=u*Point(0,1);\tlns.pb(Line(c1.r*u,c1.r*u+v));\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tCircle jwl[50],mag[50];\n\t\trep(i,n){\n\t\t\tint x,y,m;\tscanf(\"%d%d%lf%d\",&x,&y,&jwl[i].r,&m);\n\t\t\tjwl[i].c=mag[i].c=Point(x,y);\n\t\t\tmag[i].r=jwl[i].r+m;\n\t\t}\n\n\t\tvector<Line> lns;\n\t\trep(i,n)for(int j=i+1;j<n;j++){\n\t\t\taddCommonTangent(lns,jwl[i],jwl[j]);\n\t\t\taddCommonTangent(lns,jwl[i],mag[j]);\n\t\t\taddCommonTangent(lns,mag[i],jwl[j]);\n\t\t\taddCommonTangent(lns,mag[i],mag[j]);\n\t\t}\n\n\t\tint cmax=1;\n\t\trep(i,lns.size()){\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(intersect(jwl[j],lns[i])<=1 && intersect(mag[j],lns[i])>=1)\tcnt++;\n\t\t\t}\n\t\t\tcmax=max(cmax,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",cmax);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\ninline ld dist(const po &p, const li &l){\n\treturn abs(l(p))/sqrt(l.a*l.a+l.b*l.b);\n}\n\nstruct ci{\n\tpo c;\n\tld r;\n\tinline bool internal(const po &p){\n\t\treturn dist(p,c) <= r+1e-9;\n\t}\n};\n\nci circum(const po &p,const po &q,const po &r){\n\tci ret;\n\tli l = perpen((p+q)/2.0,li(p,q));\n\tli m = perpen((q+r)/2.0,li(q,r));\n\tpo* _c;\n\tintersect(l,m,_c);\n\tif(_c == nullptr){\n\t\tret.c = po(0.0,0.0);\n\t\tret.r = -1.0;\n\t\treturn ret;\n\t}\n\telse {\n\t\tret.c = *_c;\n\t\tret.r = dist(ret.c,p);\n\t\tdelete _c;\n\t\treturn ret;\n\t}\n}\n\n\nvoid intersect(const li &l, const ci &c, po* &ret1, po* &ret2){\n\tld d = dist(c.c,l);\n\t//cout << \"d:\" << d << endl;\n\tif(d > c.r+1e-9){\n\t\tret1 = nullptr;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo h = perpen_leg(c.c,l);\n\tif(abs(d-c.r) <= 1e-9){\n\t\tret1 = new po;\n\t\t*ret1 = h;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\t//cout << \"h:\" << h.x << \" \" << h.y << endl;\n\tret1 = new po;\n\t*ret1 = h+(c.c-h)*po(0.0,sqrt((c.r*c.r-d*d)/((c.c-h)(c.c-h))));\n\tret2 = new po;\n\t*ret2 = 2*h-*ret1;\n\treturn;\n}\nvoid intersect(const ci &c, const ci &d, po* &ret1, po* &ret2){\n\tli l;\n\tl.a = 2*(c.c.x-d.c.x);\n\tl.b = 2*(c.c.y-d.c.y);\n\tl.c = d.c(d.c)-d.r*d.r-(c.c(c.c)-c.r*c.r);\n\t//l.c = (c.c.x*c.c.x+c.c.y*c.c.y-c.r*c.r)-(d.c.x*d.c.x+d.c.y*d.c.y-d.r*d.r);\n\t//cout << \"l:\" << l.a << \"x+\" << l.b << \"y+\" << l.c << endl;\n\t//cout << \"c:\" << \"(\" << c.c.x << \",\" << c.c.y << \")\" << c.r << endl;\n\tintersect(l,c,ret1,ret2);\n}\nvoid tangent(const po &p, const ci &c,li* &ret1,li* &ret2){\n\tci d;\n\td.c = (p+c.c)/2.0;\n\td.r = dist(p,c.c)/2.0;\n\t//cout << c.c.x << \" \" << c.c.y << \" \" << c.r << endl;\n\t//cout << d.c.x << \" \" << d.c.y << \" \" << d.r << endl;\n\tpo *q,*r;\n\tintersect(c,d,q,r);\n\tret1 = ret2 = nullptr;\n\tif(q == nullptr)return;\n\tret1 = new li;\n\t*ret1 = li(p,*q);\n\tdelete q;\n\tif(r == nullptr)return;\n\tret2 = new li;\n\t*ret2 = li(p,*r);\n\tdelete r;\n}\nvoid cotan_in(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tpo p = similar(-c.r,d.r,0.0,c.c,d.c);\n\t//cout << \"p:\" << p.x << \" \" << p.y << endl;\n\ttangent(p,c,ret1,ret2);\n}\nvoid cotan_out(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tif(abs(c.r-d.r) < 1e-9){\n\t\tret1 = new li;\n\t\tret2 = new li;\n\t\t*ret1 = *ret2 = li(c.c,d.c);\n\t\tret1->c += c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\tret2->c -= c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\treturn;\n\t}\n\tpo p = similar(c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\n\nint n;\nci c[52];\nld m[52];\nint solve(po p){\n\t//cout << \"solve is called:\" << p.x << \" \" << p.y << endl;\n\tci _c[52];\n\tvector<pair<ld,int>> vec;\n\trep1(k,n){\n\t\t_c[k] = c[k];\n\t\t_c[k].c *= p;\n\t\t//cout << _c[k].c.x << \" \" << _c[k].c.y << \":\" << k << endl;\n\t\tvec.push_back(pair<ld,int>(_c[k].c.y-_c[k].r-m[k]-1e-9,1));\n\t\tvec.push_back(pair<ld,int>(_c[k].c.y-_c[k].r+1e-9,-1));\n\t\tvec.push_back(pair<ld,int>(_c[k].c.y+_c[k].r-1e-9,1));\n\t\tvec.push_back(pair<ld,int>(_c[k].c.y+_c[k].r+m[k]+1e-9,-1));\n\t}\n\tsort(vec.begin(),vec.end());\n\tint ret = 0;\n\tint cnt = 0;\n\trep(i,vec.size()){\n\t\t//cout << vec[i].fr << \" \" << vec[i].sc << endl;\n\t\tcnt += vec[i].sc;\n\t\tret = max ( ret , cnt );\n\t}\n\t//cout << \"ret=\" << ret << endl;\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\trep1(i,n){\n\t\t\tc[i].c.in(); scanf(\"%Lf%Lf\",&c[i].r,&m[i]);\n\t\t}\n\t\tint ret = 1;\n\t\trep1(i,n)for(int j = i+1 ; j <= n ; j ++){\n\t\t\t//cout << i << \" \" << j << endl;\n\t\t\tli *l[4];\n\t\t\t//cout << c[i].c.x << \" \" << c[i].c.y << \" \" << c[i].r << endl;\n\t\t\t//cout << c[j].c.x << \" \" << c[j].c.y << \" \" << c[j].r << endl;\n\t\t\tcotan_in(c[i],c[j],l[0],l[1]);\n\t\t\tcotan_out(c[i],c[j],l[2],l[3]);\n\t\t\trep(k,4){\n\t\t\t\t//cout << \"k=\" << k << endl;\n\t\t\t\tif(l[k] != nullptr){\n\t\t\t\t\tpo alp(l[k]->b,l[k]->a);\n\t\t\t\t\talp /= sqrt(alp(alp));\n\t\t\t\t\tret = max( ret , solve(alp) );\n\t\t\t\t\tdelete l[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\ntypedef vector<P> G; /* ½p` */\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} }; /* üª */\ntypedef pair<P,double> C; /* ~ */\n\n// complexÉå¬ÖWªKvÈê\nnamespace std{\n\tbool operator < (const P &a, const P &b){ return make_pair(real(a),imag(a)) < make_pair(real(b),imag(b)); }\n}\n\n// àÏEOÏEpx\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ´_Ì£yÌñæzðßé\n// iüÍp1-p2ðøÉæêÎ2_ÔÌ£yÌñæzÆÈéj\ndouble pLen2(P p){\n\treturn real(p)*real(p)+imag(p)*imag(p);\n}\n\n// ½Ë(distSPÅgp)\nP proj(L l, P p) {\n\tdouble t = dot(p-l.p, l.p-l.q) / sqrt(pLen2(l.p-l.q));\n\treturn l.p + t*(l.p-l.q);\n}\n\n// ¼ülÆüªsªð··é©ð»è·é\nbool lsIntersect(L l, L s) {\n  return abs(cross(l.q-l.p, s.p-l.p)*cross(l.q-l.p, s.q-l.p)) < EPS;\n}\n\n// üªaÆüªbªð··é©ð»è·é\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\n// _pª¼ülãÉ¶Ý·é©ð»è\nbool lpIntersect(L l, P p){\n\treturn abs(imag((p-l.p)/(l.q-l.p)))<EPS;\n}\n\n// _pªüªlãÉ¶Ý·é©ð»è·éi¸x¤j\nbool spIntersect(L l, P p){\n\t//return abs( abs(l.p-p)+abs(l.q-p)-abs(l.q-l.p) ) < EPS; // ¸xðCÉµÈ¢Èç±êH\n\tif(lpIntersect(l, p)){\n\t\tif((real(l.p)-real(p))*(real(l.q)-real(p))<=0){\n\t\tif((imag(l.p)-imag(p))*(imag(l.q)-imag(p))<=0){\n\t\t\treturn true;\n\t\t}}\n\t}\n\treturn false;\n}\n\n// üªaÆüªbÌð_ðvZ·éDæÉð·»èªK{D\nP ssCrosspoint(L a, L b){\n\tdouble A = cross(a.q-a.p, b.q-b.p);\n\tdouble B = cross(a.q-a.p, a.q-b.p);\n\treturn b.p + B/A * (b.q-b.p);\n}\n\n// ¼üaÆ¼übª¯êÌàÌ©ð»è·é\nbool sameLine(L a, L b){\n\treturn lpIntersect(a,b.p)&&lpIntersect(a,b.q);\n}\n\n// üªlÆ_pÌ£ðßé\ndouble distLP(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\n// ¼üÆ¼üÌ£ðßéiÀsÌj\ndouble distLL(L l, L m) {\n\treturn sameLine(l, m) ? 0.0 : distLP(l, m.p);\n}\n\n// ¼ülÆüªsÌ£ðßé\ndouble distLS(L l, L s) {\n\tif (lsIntersect(l, s)) return 0.0;\n\treturn min(distLP(l, s.p), distLP(l, s.q));\n}\n\n// üªsÆ_pÌ£ðßé\ndouble distSP(L s, P p) {\n\tP r = proj(s, p);\n\tif (spIntersect(s, r)) return abs(r - p);\n\treturn min(abs(s.p - p), abs(s.q - p));\n}\n\n// üªsÆüªtÌ£ðßé\ndouble distSS(L s, L t) {\n  if (ssIntersect(s, t)) return 0;\n  return min(min(distSP(s, t.p), distSP(s, t.q)),\n             min(distSP(t, s.p), distSP(t, s.q)));\n}\n\n// üªaÆüªbªI[o[bvµÄ¢é©ð»è·é\nbool ssOverlap(L a, L b){\n\tif(spIntersect(a,b.p)&&lpIntersect(a,b.q)) return true;\n\tif(spIntersect(a,b.q)&&lpIntersect(a,b.p)) return true;\n\tif(spIntersect(b,a.p)&&lpIntersect(b,a.q)) return true;\n\tif(spIntersect(b,a.q)&&lpIntersect(b,a.p)) return true;\n\treturn false;\n}\n\n\n// ¤ÊÚüðresÉÇÁ·é\nvoid getCommonTangent(vector<L> &res, C c1, C c2){\n\tif(c1.second > c2.second) swap(c1, c2);\n\tP dir = c1.first-c2.first;\n\tdouble dist = abs(c1.first-c2.first);\n\tdir = dir/dist*c2.second;\n\tif(dist + c1.second < c2.second - EPS) return; // ¬~ªå~Éàï³êÄ¢é\n\n\tfor(int sgn=-1;sgn<=1;sgn+=2){\n\t\tdouble cs = (c2.second+sgn*c1.second)/dist;\n\t\tP d = P(cs, sqrt(1-cs*cs));\n\t\tres.push_back(L(c2.first+dir*d, c2.first+dir*d*P(1,1)));\n\t\tif(imag(d) > EPS)\n\t\t\tres.push_back(L(c2.first+dir*conj(d), c2.first+dir*conj(d)*P(1,1)));\n\t\tif(dist+EPS < c1.second+c2.second) break;\n\t}\n}\n\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\n// _pª½p`gÌàÉ é©Ç¤©ð»è·é\nbool contains(G g, P p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a(g[i]-p), b(g[(i+1)%g.size()]-p);\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a)<=0&&0<imag(b))\n\t\t\tif(cross(a,b)<0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true; // üãÉpª¶Ý\n\t}\n\treturn in;\n}\n\n\n\n// ¼üÌWresÅd¡·é¼üðíµCresðXV·é\nvoid deleteSameLine(vector<L> &res){\n\tint n = res.size();\n\tfor(int i=0; i<n; i++){\n\t\tvector<L>::iterator it = res.begin() + i + 1;\n\t\twhile(it<res.end()){\n\t\t\tif( sameLine(res[i], (*it)) ){ /* ±±ðÏ¦êÎpªø­ */\n\t\t\t\tit = res.erase(it);\n\t\t\t\tn--;\n\t\t\t} else {\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n) break;\n\t\tvi x, y, r, m;\n\t\tFOR(i, n){\n\t\t\tint tx,ty,tr,tm;\n\t\t\tcin>>tx>>ty>>tr>>tm;\n\t\t\tx.push_back(tx);\n\t\t\ty.push_back(ty);\n\t\t\tr.push_back(tr);\n\t\t\tm.push_back(tm);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L> all;\n\t\tFORic(i, 0, n-2){\n\t\t\tFORic(j, i+1,n-1){\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]     ));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]     ), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t\tgetCommonTangent(all, C(P(x[i], y[i]), r[i]+m[i]), C(P(x[j], y[j]), r[j]+m[j]));\n\t\t\t}\n\t\t}\n\t\tdeleteSameLine(all);\n\t\tint ans = 0;\n\t\tFOR(i, SIZE(all)){\n\t\t\tint count = 0;\n\t\t\tFOR(j, n){\n\t\t\t\tdouble d = distLP(all[i], P(x[j],y[j]));\n\t\t\t\tif(r[j]<d+EPS && d-EPS<r[j]+m[j]) count++;\n\t\t\t}\n\t\t\tans = max(ans, count);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\ndouble DistLP(Line l,Point p){\n\treturn Abs(Proj(l,p)-p);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble radius;\n\tCircle(){}\n\tCircle(Point c,double r):center(c),radius(r){}\n\tCircle(double x,double y,double r):center(x,y),radius(r){}\n};\nvector<Line> Intangent(Circle c1,Circle c2)\n{\n\tdouble r1=c1.radius,r2=c2.radius;\n\tdouble d=Abs(c1.center-c2.center);\n\tvector<Line> res;\n\tif(d>r1+r2+EPS){\n\t\tdouble t=acos((r1+r2)/d);\n\t\trep(i,2){\n\t\t\tPoint p1=c1.center+Rot(r1/d*(c2.center-c1.center),(i?1:-1)*t);\n\t\t\tPoint p2=c2.center+Rot(r2/d*(c1.center-c2.center),(i?1:-1)*t);\n\t\t\tres.push_back(Line(p1,p2-p1));\n\t\t}\n\t}\n\telse if(d>r1+r2-EPS){\n\t\tPoint p=c1.center+r1/d*(c2.center-c1.center);\n\t\tres.push_back(Line(p,Rot(p-c1.center,PI/2)));\n\t}\n\treturn res;\n}\nvector<Line> Extangent(Circle c1,Circle c2)\n{\n\tdouble r1=c1.radius,r2=c2.radius;\n\tdouble d=Abs(c1.center-c2.center);\n\tvector<Line> res;\n\tif(d>abs(r2-r1)+EPS){\n\t\tdouble t=acos((r1-r2)/d);\n\t\trep(i,2){\n\t\t\tPoint p1=c1.center+Rot(r1/d*(c2.center-c1.center),(i?1:-1)*t);\n\t\t\tPoint p2=c2.center+Rot(r2/d*(c2.center-c1.center),(i?1:-1)*t);\n\t\t\tres.push_back(Line(p1,p2-p1));\n\t\t}\n\t}\n\telse if(d>abs(r2-r1)-EPS){\n\t\tPoint p=c1.center+r1/d*(c2.center-c1.center);\n\t\tres.push_back(Line(p,Rot(p-c1.center,PI/2)));\n\t}\n\treturn res;\n}\n\nvector<Line> Tangent(Circle c1,Circle c2)\n{\n\tvector<Line> in=Intangent(c1,c2),ex=Extangent(c1,c2);\n\tin.insert(in.end(),all(ex));\n\treturn in;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Circle> js,ms;\n\t\trep(i,n){\n\t\t\tint x,y,r,m; cin>>x>>y>>r>>m;\n\t\t\tjs.emplace_back(x,y,r);\n\t\t\tms.emplace_back(x,y,r+m);\n\t\t}\n\t\t\n\t\tvector<Line> ts;\n\t\trep(i,n) repi(j,i+1,n){\n\t\t\tvector<Line> temp;\n\t\t\ttemp=Tangent(js[i],js[j]); ts.insert(ts.end(),all(temp));\n\t\t\ttemp=Tangent(ms[i],ms[j]); ts.insert(ts.end(),all(temp));\n\t\t\ttemp=Tangent(js[i],ms[j]); ts.insert(ts.end(),all(temp));\n\t\t\ttemp=Tangent(ms[i],js[j]); ts.insert(ts.end(),all(temp));\n\t\t}\n\t\t\n\t\tint res=1;\n\t\tfor(Line t:ts){\n\t\t\tint temp=0;\n\t\t\trep(i,n){\n\t\t\t\tdouble d=DistLP(t,js[i].center);\n\t\t\t\tif(js[i].radius-EPS<d && d<ms[i].radius+EPS)\n\t\t\t\t\ttemp++;\n\t\t\t}\n\t\t\tres=max(res,temp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define EPS 1e-10\n#define maxn 55\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y - p.y < -EPS;\n\t\telse return x - p.x < EPS;\n\t}\n\tdouble pol(){\n\t\treturn atan2(y,x);\n\t}\n\tPoint ccw90(){\n\t\treturn Point(-y,x);\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"%.10f %.10f\\n\",x,y);\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n\t\n\tvoid print(){\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\",p1.x,p1.y,p2.x,p2.y);\n\t}\n};\ntypedef Segment Line;\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(),double r = 0.0): c(c),r(r) {}\n\tPoint arcpoint(double theta){\n\t\treturn c + Point(cos(theta),sin(theta)) * r;\n\t}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n\treturn a.x * b.y - b.x * a.y;\n}\nint n;\nCircle a[maxn],b[maxn];\ndouble m[maxn];\nvector <Line> ts;\nint cts(Circle o1,Circle o2){\n\tts.clear();\n\tdouble rdif = o1.r - o2.r,rsum = o1.r + o2.r;\n\tVector v = o2.c - o1.c;\n\tif(abs(rdif) - v.abs_() > EPS) return 0;\n\tvector <Point> ps;\n\tps.clear();\n\tdouble alpha;\n\tif(abs(abs(rdif) - v.abs_()) < EPS){\n\t\tif(rdif < 0) alpha = acos(-1);\n\t\telse alpha = acos(1);\n\t\tps.push_back(o1.arcpoint(v.pol() + alpha));\n\t}else{\n\t\talpha = acos(rdif / v.abs_());\n\t\tps.push_back(o1.arcpoint(v.pol() + alpha));\n\t\tps.push_back(o1.arcpoint(v.pol() - alpha));\n\t}\n\tif(abs(rsum - v.abs_()) < EPS){\n\t\talpha = acos(1);\n\t\tps.push_back(o1.arcpoint(v.pol() + alpha));\n\t}else if(rsum - v.abs_() < -EPS){\n\t\talpha = acos(rsum / v.abs_());\n\t\tps.push_back(o1.arcpoint(v.pol() + alpha));\n\t\tps.push_back(o1.arcpoint(v.pol() - alpha));\n\t}\n\tint m = ps.size();\n\tfor(int i=0;i<m;i++){\n\t\tLine l = Segment(ps[i],ps[i] + (o1.c - ps[i]).ccw90());\n\t\tts.push_back(l);\n\t}\n\treturn m;\n}\ndouble disLP(Line l,Point p){\n\treturn abs(det(l.p2 - l.p1,p - l.p1)) / (l.p2 - l.p1).abs_();\n}\nint calc(Line l){\n\tint res = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tdouble d = disLP(l,a[i].c);\n\t\tif(d - a[i].r > -EPS && d - (a[i].r + m[i]) < EPS) res++;\n\t}\n\treturn res;\n}\nint main(){\n\twhile(~scanf(\"%d\",&n) && n){\n\t\tint ans = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&a[i].c.x,&a[i].c.y,&a[i].r,&m[i]);\n\t\t\tb[i].c = a[i].c;\n\t\t\tb[i].r = a[i].r + m[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\tint m = cts(a[i],a[j]);\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tans = max(ans,calc(ts[k]));\n\t\t\t\t}\n\t\t\t\tm = cts(b[i],a[j]);\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tans = max(ans,calc(ts[k]));\n\t\t\t\t}\n\t\t\t\tm = cts(a[i],b[j]);\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tans = max(ans,calc(ts[k]));\n\t\t\t\t}\n\t\t\t\tm = cts(b[i],b[j]);\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tans = max(ans,calc(ts[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,double> P1;\nconst double EPS = 1e-10;\ntypedef pair<P,P> L;\nint n,m[51];\n\n\n//kaitenn\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n \n//???\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\nCircle c[2][51];\n \nL getIntangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double w=a.r+b.r;\n  double h=sqrt(max(0.0,norm(base)-w*w));\n  P k=base*P(w,h*f)/norm(base);\n  return L(a.c+k*a.r,b.c-k*b.r);\n}\n \nL getOuttangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double h=b.r-a.r;\n  double w=sqrt(max(0.0,norm(base)-h*h));\n  P k=base*P(w,h*f)/norm(base)*P(0,f);\n  return L(a.c+k*a.r,b.c+k*b.r);\n}\n \nvector<L> tangentCC(Circle a,Circle b){\n  double dis=abs(a.c-b.c),R=a.r+b.r;\n  vector<L> res;\n  if(dis>R+EPS)res.push_back(getIntangent(a,b));\n  if(dis>R-EPS)res.push_back(getIntangent(a,b,-1));\n  if(dis>abs(a.r-b.r)+EPS)res.push_back(getOuttangent(a,b));\n  if(dis>abs(a.r-b.r)-EPS)res.push_back(getOuttangent(a,b,-1));\n  return res;\n}\n\nint cal(P a,P b){\n  int res=0;\n  b-=a;\n  for(int i=0;i<n;i++){\n    P t=(c[0][i].c-a)*conj(b)/abs(b);\n    if(c[0][i].r<=abs(t.imag())+EPS&&abs(t.imag())<=c[1][i].r+EPS)res++;\n  }\n  return res;\n}\n \nint main(){\n  while(cin>>n,n){\n\n    for(int i=0,a,b,r,m;i<n;i++){\n      cin>>a>>b>>r>>m;\n      c[0][i]=Circle(P(a,b),r);\n      c[1][i]=Circle(P(a,b),r+m);\n    }\n    \n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tfor(int k=0;k<4;k++){\n\t  vector <L> res=tangentCC(c[k&1][i],c[k&2][j]);\n\t  for(int l=0;l<res.size();l++) ans=max(ans,cal(res[l].first,res[l].second));\n\t}\n      }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.1){\n\t\t\t\tdouble a = (-1) * tan(M_PI/2 + j);\n\t\t\t\tdouble b = 1.0;\n\t\t\t\tdouble c = (x[i]-r[i]*cos(j)) * tan(M_PI/2 + j) - y[i] - r[i] * sin(j);\n\t\t\t\tdouble ab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(d >= r[k] && d <= r[k]+m[k]){\n\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// rotate by theta (-pi,+pi)\n// arg will return angle of point\npoint rotate(point p,double theta){\n    double cos_theta = cos(theta),\n           sin_theta = sin(theta);\n    return point(p.real()*cos_theta - p.imag()*sin_theta,\n                 p.real()*sin_theta + p.imag()*cos_theta);\n}\nconst double EPS = 1e-6;\n// 二つの円の共通接線\n//  ふつうは4つ？\nvector<pair<point,point> > common_tangent_of_two_circles(point c1,double r1,point c2,double r2){\n    // shift c2 by c1.\n    point nc = c2 - c1;\n    // c.img == 0\n    double ar = arg(nc);\n    point c = rotate(nc,-ar);\n    dump(c1);\n    dump(c2);\n    dump(r1);\n    dump(r2);\n\n    vector<pair<point,point> > ret;\n    vector<double> xs;\n    dump(c.real());\n    for(int sign=-1;sign<=1;sign+=2){\n        xs.push_back((r1*r1 + sign*r1*r2)/c.real());\n    }\n    for(double x1 : xs){\n        double y2 = r1*r1 - x1*x1;\n        if(y2 < EPS) continue; // maybe two circle is crossed\n        for(int sign=-1;sign<=1;sign+=2){\n            double y1 = sign*sqrt(y2);\n            // x1*x + y1*y = r1*r1 is such line\n            point h = point(x1,y1);\n            point t = point(0,r1*r1/y1); // tekito\n            if(abs(y1) < EPS){\n                t = point(x1,y1+1);\n            }\n\n            ret.push_back(make_pair(h,t));\n        }\n    }\n    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair<point,point> p){\n            return make_pair(rotate(p.first,ar)+c1,\n                             rotate(p.second,ar)+c1);\n        });\n    return ret;\n}\n\nstruct Jewel {\n    point p;\n    double r;\n    double m;\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(true){\n        int N; cin >> N;\n        if(N == 0) break;\n        vector<Jewel> jewels;\n        for(int i=0;i<N;i++){\n            double x,y,r,m;\n            cin >> x >> y >> r >> m;\n            jewels.push_back(Jewel{point(x,y),r,m});\n        }\n\n        vector<pair<point,double> > circles;\n        for(auto& j : jewels){\n            circles.push_back(make_pair(j.p,j.r));\n            circles.push_back(make_pair(j.p,j.r + j.m));\n        }\n        int maxi = min(2ll,N);\n        for(int i=0;i<circles.size();i++){\n            int skip = (i%2 == 0)?2:1;\n            for(int j=i+skip;j<circles.size();j++){\n                auto lines = common_tangent_of_two_circles(circles[i].first,circles[i].second,\n                                                           circles[j].first,circles[j].second);\n                for(pair<point,point>& line : lines){\n                    int cnt = 0;\n                    for(auto& jewel : jewels){\n                        double d = dist_line_and_point(line.first,line.second,jewel.p);\n                        if(jewel.r < d + EPS and d < jewel.r + jewel.m + EPS){\n                            cnt++;\n                        }\n                    }\n                    maxi = max(maxi,cnt);\n                }\n            }\n        }\n        cout << maxi << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\n//2??????????????????\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\n//?????¨????????????????±???????\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return std::pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\nline tangent(const circle &c, const double &th) {\n    point h = c.o+polar(c.r,th);\n    point p = polar(c.r,th)*point(0,1);\n    return line(h-p,h+p);\n}\n\nvector<line> common_tangent(const circle &c, const circle &d) {\n    vector<line> res;\n    long double dist = abs(d.o - c.o), th = arg(d.o - c.o);\n    if (abs(c.r - d.r) < dist) { // outer\n        long double dth = acosl((c.r - d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    if (abs(c.r + d.r) < dist) {\n        long double dth = acos((c.r + d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    return res;\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    vector<long double> m(n);\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r >> m[i];\n        cs.push_back(circle(point(x,y),r));\n    }\n    rep(i,0,n) cs.push_back(circle(cs[i].o,cs[i].r+m[i]));\n\n    vector<line> ls;\n    vector<pii> idx;\n    rep(i,0,cs.size()) rep(j,i+1,cs.size()){\n        auto tmp=common_tangent(cs[i],cs[j]);\n        ls.insert(ls.end(),tmp.begin(),tmp.end());\n        rep(k,0,tmp.size()) idx.push_back(make_pair(i,j));\n    }\n\n    vector<point> ps;\n    rep(i,0,n) ps.push_back(cs[i].o);\n    rep(i,0,cs.size()) rep(j,i+1,cs.size()){\n        if(icc(cs[i],cs[j])!=1) continue;\n        auto tmp=ccc(cs[i],cs[j]);\n        ps.push_back(tmp.first);\n        ps.push_back(tmp.second);\n    }\n    rep(i,0,ps.size()) rep(j,i+1,ps.size()){\n        ls.push_back(line(ps[i],ps[j]));\n        idx.push_back(make_pair(-1,-1));\n    }\n\n    int ans=1;\n    rep(i,0,ls.size()){\n        auto &l=ls[i];\n        int cnt=0;\n        rep(j,0,n){\n            auto &c=cs[j];\n            long double d=distanceLP(l,c.o)-c.r;\n            if(j==idx[i].first or j==idx[i].second or (-eps<=d and d<=m[j]+eps)) ++cnt;\n        }\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a),pb(b); }\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &C,double R):c(C),r(R){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nPoint PerpFoot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\tPoint v(a,b);\n\treturn p-(dot(p,v)+c)*v/norm(v);\n}\n\nint intersect(const Circle &c,const Line &l){\n\tPoint m=PerpFoot(c.c,l);\n\tdouble d2=norm(c.c-m);\n\tif(c.r*c.r+EPS<d2)      return 0;\n\tif(abs(c.r*c.r-d2)<EPS) return 1;\n\treturn 2;\n}\n\nvoid addCommonTangent(vector<Line> &lns,const Circle &c1,const Circle &c2){\n\tdouble d2=norm(c1.c-c2.c);\n\tdouble rsum2=(c1.r+c2.r)*(c1.r+c2.r);\n\tdouble rdif2=(c1.r-c2.r)*(c1.r-c2.r);\n\tPoint u=(c2.c-c1.c)/abs(c2.c-c1.c);\n\n\tPoint v;\n\tdouble theta;\n\tif(d2>rsum2+EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\n\t\ttheta=acos(sqrt(rsum2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c-c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c-c2.r*v));\n\t}\n\telse if(d2>rsum2-EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\n\t\tv=u*Point(0,1);\tlns.pb(Line(c1.r*u,c1.r*u+v));\n\t}\n\telse if(d2>rdif2+EPS){\n\t\ttheta=asin(sqrt(1-rdif2/d2));\n\t\tv=u*exp(Point(0,theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t\tv=u*exp(Point(0,-theta));\tlns.pb(Line(c1.c+c1.r*v,c2.c+c2.r*v));\n\t}\n\telse if(d2>rdif2-EPS){\n\t\tv=u*Point(0,1);\tlns.pb(Line(c1.r*u,c1.r*u+v));\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tCircle jwl[50],mag[50];\n\t\trep(i,n){\n\t\t\tint x,y,m; scanf(\"%d%d%lf%d\",&x,&y,&jwl[i].r,&m);\n\t\t\tjwl[i].c=mag[i].c=Point(x,y);\n\t\t\tmag[i].r=jwl[i].r+m;\n\t\t}\n\n\t\tvector<Line> lns;\n\t\trep(i,n)for(int j=i+1;j<n;j++){\n\t\t\taddCommonTangent(lns,jwl[i],jwl[j]);\n\t\t\taddCommonTangent(lns,jwl[i],mag[j]);\n\t\t\taddCommonTangent(lns,mag[i],jwl[j]);\n\t\t\taddCommonTangent(lns,mag[i],mag[j]);\n\t\t}\n\n\t\tint cmax=1;\n\t\trep(i,lns.size()){\n\t\t\tint cnt=0;\n\t\t\trep(j,n){\n\t\t\t\tif(intersect(jwl[j],lns[i])<=1 && intersect(mag[j],lns[i])>=1) cnt++;\n\t\t\t}\n\t\t\tcmax=max(cmax,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",cmax);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &rpoint;\n\ndouble cross(rpoint va, rpoint vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble distance_l_p(rpoint a, rpoint b, rpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ntypedef pair<point,point> line;\nvector<line> common_tangent(rpoint p1, double r1, point p2, double r2){\n\tvector<line> ret;\n\n\tp2 -= p1;\n\tdouble a = arg(p2);\n\tdouble b = (r1 - r2) / abs(p2);\n\tif( b < -1.0 || b > 1.0 ){ return ret; }\n\tdouble c = asin(b) - asin(1.0);\n\tret.push_back( make_pair( p1 + polar(r1, a - c), p1 + p2 + polar(r2, a - c) ) );\n\tret.push_back( make_pair( p1 + polar(r1, a + c), p1 + p2 + polar(r2, a + c) ) );\n\n\tb = (r1 + r2) / abs(p2);\n\tif( b < 1.0 || b > 1.0 ){ return ret; }\n\tc = asin(b) - asin(1.0);\n\tret.push_back( make_pair( p1 + polar(r1, a - c), p1 + p2 - polar(r2, a - c) ) );\n\tret.push_back( make_pair( p1 + polar(r1, a + c), p1 + p2 - polar(r2, a + c) ) );\n\n\treturn ret;\n}\n\nint n;\npoint p[50];\ndouble r[50];\ndouble m[50];\nint ans;\n\n\nvoid check(rpoint p1, double r1, rpoint p2, double r2){\n\tvector<line> v = common_tangent(p1, r1, p2, r2);\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tint c = 0;\n\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tdouble d = distance_l_p(v[i].first, v[i].second, p[j]);\n\t\t\tif( d > r[j] - EPS && d < m[j] + EPS ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = max(ans, c);\n\t}\n}\n\nint main(){\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tans = 1;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x, &y, &r[i], &m[i]);\n\t\t\tm[i] += r[i];\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; ++i)\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tcheck(p[i], r[i], p[j], r[j]);\n\t\t\tcheck(p[i], r[i], p[j], m[j]);\n\t\t\tcheck(p[i], m[i], p[j], r[j]);\n\t\t\tcheck(p[i], m[i], p[j], m[j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n#include <vector>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\n//static const double EPS = 1e-8;\nstatic const double INF = 1e+0;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nvector<Line> tangentCP(const Circle &c, const Point &p) {\n  vector<Line> ret;\n  Point vect = c.p - p;\n  double d = abs(vect);\n  double l = sqrt(norm(vect) - c.r * c.r);\n  if (!(l == l)) { return ret; }\n  Point v1 = vect * Point(l / d,  c.r / d);\n  Point v2 = vect * Point(l / d, -c.r / d);\n  ret.push_back(Line(p - v1 * INF, p + v1 * INF));\n  if (l > EPS) {\n    ret.push_back(Line(p - v2 * INF, p + v2 * INF));\n  }\n  return ret;\n}\n\nvector<Line> tangentCC(const Circle &c1, const Circle &c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangentCP(c1, center);\n  }\n  if (fabs(c1.r - c2.r) > EPS) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangentCP(c1, out);\n    ret.insert(ret.end(), nret.begin(), nret.end());\n  } else {\n    Point vect = c2.p - c1.p;\n    vect /= abs(vect);\n    Point q1 = c1.p + vect * Point(0, 1) * c1.r;\n    Point q2 = c1.p + vect * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1 - vect * INF, q1 + vect * INF));\n    ret.push_back(Line(q2 - vect * INF, q2 + vect * INF));\n  }\n  return ret;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nCircle circle[2][100];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    REP(i, n) {\n      double x, y, r, m;\n      scanf(\"%lf %lf %lf %lf\", &x, &y, &r, &m);\n      circle[0][i] = Circle(Point(x, y), r);\n      circle[1][i] = Circle(Point(x, y), r + m);\n    }\n    int ans = 1;\n    REP(i, n) {\n      REP(j, n) {\n        if (i == j) { continue; }\n        REP(l, 2) {\n          REP(r, 2) {\n            vector<Line> tangent = tangentCC(circle[l][i], circle[r][j]);\n            FORIT(it, tangent) {\n              int sum = 0;\n              REP(k, n) {\n                double dist = distanceLP(*it, circle[0][k].p);\n                if (dist - circle[0][k].r > -3 * EPS && circle[1][k].r - dist > -3 * EPS) {\n                  sum++;\n                } else {\n                  assert(k != i && k != j);\n                }\n              }\n              assert(sum >= 2);\n              ans = max(ans, sum);\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> P;\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nint cmp(double a,double b){\n\t  const double diff=a-b;\n\t  if(fabs(diff)<EPS)return 0;\n\t  else if(diff<0)return -1;\n\t  else return 1;\n}\ninline double dot(const P &a, const P &b){\n\t  return a.real()*b.real()+a.imag()*b.imag();\n}\ninline double cross(const P &a, const P &b){\n    return a.real()*b.imag()-b.real()*a.imag();\n}\nstruct line{\n    P a,b;\n    line(){}\n    line(const P &p,const P &q):a(p),b(q){}\n\t  // 是否平行\n\t  inline bool parallel(const line &ln) const{\n\t\t    return abs(cross(ln.b-ln.a,b-a))<EPS;\t\n\t\t    //平行叉乘得到向量的模是0，也就是sin(theta)=0<->theta=0\n\t  }\n\t  // 是否相交\n\t  inline bool intersects(const line &ln) const{\n\t\t    return !parallel(ln);\n\t  }\n\t  // 求交点\n\t  inline P intersection(const line &ln) const{\n\t      const P x=b-a;\n\t      const P y=ln.b-ln.a;\n\t      return a+x*(cross(y,ln.a-a))/cross(y,x);\n\t  }\n\t  // 点到直?的距?\n\t  inline double distance(const P &p) const{\n\t      return abs(cross(p-a,b-a))/abs(b-a);\n\t  }\n\t  // 求垂足坐?\n\t  inline P perpendicular(const P &p) const{\n\t      const double t=dot(p-a,a-b)/dot(b-a,b-a);\n\t\t    return a+t*(a-b);\n\t\t}\n};\nstruct circle{\n    P o;\n    double r;\n    circle(){}\n    circle(const P &p,double x):o(p),r(x){}\n    // 通?点 p 的?条切?\n    pair<P,P> tangent(const P &p)const{\n        const double L=abs(o-p);\n        const double M=sqrt(L*L-r*r);\n        const double theta=asin(r/L);\n        const P v=(o-p)/L;\n        return make_pair(p+M*(v*polar(1.0,theta)),p+M*(v*polar(1.0,-theta)));\n\t  }\n\t  // ?个半径相等?的?条平行外切?\n\t  pair<line,line> outer_tangent_parallel(const circle &c) const{\n\t      const P d=o-c.o;\n\t      const P v=d*P(0,1)*r/abs(d);\n\t      return make_pair(line(o+v,c.o+v),line(o-v,c.o-v));\n\t  }\n\t  // ?个?外切?\n\t  pair<line,line> outer_tangent(const circle &c) const{\n\t      if(cmp(r,c.r)==0)return outer_tangent_parallel(c);\n\t      if(r>c.r)return c.outer_tangent(*this);\n\t      const P d=o-c.o;\n\t      const double fact=c.r/r-1;\n\t      const P base=c.o+d+d/fact;\n\t      const pair<P, P> t=tangent(base);\n\t      return make_pair(line(base,t.first),line(base,t.second));\n\t  }\n\t  // 内切?\n\t  pair<line,line> inner_tangent(const circle &c) const{\n\t      if(r>c.r)return c.inner_tangent(*this);\n\t      const P d=c.o-o;\n\t      const double fact=c.r/r+1;\n\t      const P base=o+d/fact;\n\t      const pair<P,P> t=tangent(base);\n\t      return make_pair(line(base,t.first),line(base,t.second));\n\t  }\n\t  // 是否相交\n\t  inline bool intersects(const circle &c) const{\n\t\t    return !contains(c)&&!c.contains(*this)&&cmp(abs(o-c.o),r+c.r)<=0;\n\t  }\n\t  // 是否相?\n\t  inline bool independent(const circle &c) const{\n\t      return cmp(abs(o-c.o),r+c.r)>0;\n\t  }\n\t  // ?个?的交点\n\t  pair<P,P> intersection(const circle &c) const{\n\t      const double d=abs(o-c.o);\n\t      const double cos_=(d*d+r*r-c.r*c.r)/(2*d);\n\t      const double sin_=sqrt(r*r-cos_*cos_);\n\t      const P e=(c.o-o)/d;\n\t      return make_pair(o+e*P(cos_,sin_),o+e* P(cos_,-sin_));\n\t  }\n\t  // 是否包含?c\n\t  inline bool contains(const circle &c) const{\n\t      return cmp(abs(o-c.o)+c.r,r)<0;\n\t  }\n\t  // 是否相交\n\t  inline bool intersects(const line &ln) const{\n\t      return cmp(abs(ln.distance(o)),r)<=0;\n\t  }\n\t  // ?心到直?的距?\n\t  inline double distance(const line &ln) const{\n\t\t    return abs(ln.distance(o));\n\t  }\n\t  // ?与直?的交点\n\t  pair<P,P> intersection(const line &ln) const{\n\t      const P h=ln.perpendicular(o);\n\t      const double d=abs(h-o);\n\t      P ab=ln.b-ln.a;\n\t      ab/=abs(ab);\n\t      const double l=sqrt(r*r-d*d);\n\t      return make_pair(h+l*ab,h-l*ab);\n\t  }\n};\nvoid enum_event(const circle &c1,const circle &c2,vector<line> &lines){\n\t  if(c1.independent(c2)){\n\t\t    pair<line,line> outer=c1.outer_tangent(c2);\n\t\t    lines.push_back(outer.first);\n\t\t    lines.push_back(outer.second);\n\t\t    pair<line,line> inner = c1.inner_tangent(c2);\n\t\t    lines.push_back(inner.first);\n\t\t    lines.push_back(inner.second);\n\t\t}else if (c1.intersects(c2)){\n\t\t    pair<line,line> outer=c1.outer_tangent(c2);\n\t\t    lines.push_back(outer.first);\n\t\t    lines.push_back(outer.second);\n\t\t    pair<P,P> inter=c1.intersection(c2);\n\t\t    lines.push_back(line(inter.first,inter.second));\t\n\t\t    // 此?内切?不存在，使用交点形成的?代替\n\t\t}\n}\nbool solve(){\n    int N;\n    scanf(\"%d\",&N);\n    if(!N)return false;\n    vector<pair<circle,circle> > jewels;\n    vector<line> lines;\n    for(int i=0;i<N;i++){\n        double x,y,r,m;\n        scanf(\"%lf%lf%lf%lf\",&x,&y,&r,&m);\n\t\t    const P center(x,y);\n\t\t    pair<circle,circle> jewel=make_pair(circle(center,r),circle(center,r+m));\n\t\t    for(const auto &other:jewels){\n\t\t        enum_event(jewel.first,other.first,lines);\n\t\t        enum_event(jewel.first,other.second,lines);\n\t\t        enum_event(jewel.second,other.first,lines);\n\t\t        enum_event(jewel.second,other.second,lines);\n\t\t    }jewels.push_back(jewel);\n\t\t}int ans=1;\n\t\tfor(auto &l:lines){\n\t\t    int cnt=count_if(jewels.begin(),jewels.end(),[&](const pair<circle,circle> &j){\t// [&] 按引用捕?在lambda表?式所在函数的函数体中提及的全部自??存持?性?量\n\t\t\t      return cmp(j.first.r, j.first.distance(l))<=0&&cmp(j.second.r,j.second.distance(l))>=0;\t// 在磁力?范?内且不在本体范?内\n\t\t    };\n\t\t    ans=max(ans, cnt);\n\t\t}printf(\"%d\\n\",ans);\n\t\treturn 1;\n}\nint main(){\n\t  while(solve());\n\t  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<map>\n#include<math.h>\nusing namespace std;\nnamespace geo{\n\n\ttypedef complex<double> P;\n\ttypedef vector<P> Poly;\n\tconst double eps = 1e-8;\n\ttypedef pair<P, P> Line;\n\ttypedef pair<P, double> Circle;\n#define mp(a,b) make_pair(a,b)\n\n\t//?????????????????????????????????????????¨???\n\tinline void x(P& p, double n){ p.real(n); }\n\tinline void y(P& p, double n){ p.imag(n); }\n\tinline double x(P& p){ return p.real(); }\n\tinline double y(P& p){ return p.imag(); }\n\n\t//????????????a??¨b?????????\n\tinline double dot(const P a, const  P b){//A dot B\n\t\treturn a.real()*b.real() + a.imag()*b.imag();\n\t}\n\n\t//????????????a??¨b?????????\n\tinline double cross(const P a, const P b){//A cross B\n\t\treturn a.real()*b.imag() - a.imag()*b.real();\n\t}\n\n\n\t// ???a,b???????????´?????¨???c??¨????????¢\n\tdouble distance(P p, Line l) {\n\t\tauto c = p;\n\t\tauto a = l.first;\n\t\tauto b = l.second;\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\n\t// ?????????????????¨??????????????????????????????????????????\n\tint comp(const P &l, const P &r){\n\t\tif (l.real() == r.real())\n\t\t\treturn(l.imag() < r.imag());\n\t\treturn(l.real() < r.real());\n\t}\n\n\t// ??????p??????????????????????¨?????????§Poly???????´?\n\t// Poly p : ?????¨????????????\n\t// ???????????§O(nlogn)\n\tinline Poly convex_hull(Poly& p){\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(p.begin(), p.end(), comp);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\twhile (k > 1 && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\twhile (k > t && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\n\n\t// ???p?????????????????¨????????¨????????????true\n\t// Poly l : ???????¨????????????????,????????°n\n\t// P p    : ???????????????????????????\n\t// ?????¨??§????????¢?´¢ O(log n)\n\tinline bool convex_in(const Poly& l, const P& p){\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tdouble A, C;\n\t\tconst P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1){\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0){\n\t\t\t\tif (A > -eps&&C < -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (C < -eps || A > -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -eps);\n\t}\n\n\n\t// ??????l?????¢????????????\n\t// Poly l : ???????¨????????????????,????????°n\n\t// O(n)\n\tinline double convex_area(const Poly& l){\n\t\tdouble res = 0;\n\t\tint n = (int)l.size();\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\n\t//???p????????????c?????\\?????????????±?????????????\n\tinline vector<Line> tangent_line(Circle c, P p){\n\t\tvector<Line> res;\n\t\tP Mp = c.first;\n\t\tdouble r = c.second;\n\t\tP v = p - Mp, e;\n\t\tdouble dist = abs(v);\n\t\tif (dist > r + eps){\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv *= r / dist;\n\t\t\tx(e, _cos*x(v) - _sin*y(v));\n\t\t\ty(e, _sin*x(v) + _cos*y(v));\n\t\t\tres.push_back(mp(p, Mp + e));\n\t\t\tx(e, _cos*x(v) + _sin*y(v));\n\t\t\ty(e, -_sin*x(v) + _cos*y(v));\n\t\t\tres.push_back(mp(p, Mp + e));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tinline vector<Line> inner_common_tangent_line(Circle p, Circle q){\n\t\tvector<Line> res;\n\t\tP Mp = p.first, Mq = q.first;\n\t\tdouble Rp = p.second, Rq = q.second;\n\t\tdouble dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + eps){\n\t\t\tP mid = (Rp*Mq + Rq*Mp) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline vector<Line> outer_common_tangent_line(Circle p, Circle q){\n\t\tvector<Line> res;\n\t\tif (p.second<q.second)swap(p, q);\n\t\tP Mp = p.first, Mq = q.first;\n\t\tdouble Rp = p.second, Rq = q.second;\n\t\tP v = Mp - Mq;\n\t\tdouble dist = abs(v);\n\t\tif (dist > Rp - Rq + eps){\n\t\t\tif (abs(Rp - Rq) < eps){\n\t\t\t\tP e(-y(v), x(v));\n\t\t\t\te = e*(Rp / abs(e));\n\t\t\t\tres.push_back(mp(Mp + e, Mq + e));\n\t\t\t\tres.push_back(mp(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tP mid = Mp;\n\t\t\t\tmid += (v)*(Rp / (Rp - Rq));\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n}\nusing namespace std;\n\ninline int check(geo::Line l,vector<geo::Circle>& cd, vector<geo::Circle>& cm){\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++){\n\t\tdouble d = geo::distance( cd[i].first,l);\n\t\t//cout << d << \" \";\n\t\tif (d<cm[i].second +geo::eps&&d>cd[i].second-geo::eps)\n\t\t\tres++;\n\t}\n//\tcout << endl;\n\treturn res;\n\n\n}\nint main(){\n\t//ifstream cin(\"in.txt\");ofstream cout(\"out.txt\");\n\twhile (1){\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::Circle> cd(N);\n\t\tvector<geo::Circle> cm(N);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tgeo::x(cd[i].first, x);\n\t\t\tgeo::y(cd[i].first, y);\n\t\t\tgeo::x(cm[i].first, x);\n\t\t\tgeo::y(cm[i].first, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d+m;\n\t\t}\n\t\tif (N == 1){\n\t\t\tif (cm[0].second < geo::eps)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (i != j){\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1){\n\t\t\t\t\t\tres=max(check(it, cd, cm),res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t//\tcout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3){\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();\tcout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "// last update 2012/12/15\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-5;\nconst double pi = acos(-1);\n\nbool equals(double a, double b) { return abs(a - b) < eps; }\n\nbool equals(P a, P b) {\n  return equals(a.real(), b.real()) && equals(a.imag(), b.real());\n}\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// \nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\n// \nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// \n//  0 : \n//  1 : 1\n//  2 : 2\n// -1 : \n// -2 : \nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross \n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// \nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// \nvector<P> getCrossP(C c1, C c2) {\n  vector<P> v;\n  int cp = isIntersect(c1,c2);\n  if(cp == 0 || cp == -2) return v;\n  \n  double ll = norm(c1.o - c2.o);\n  double A = ( c1.r * c1.r - c2.r * c2.r + ll ) / ( 2.0 * ll );\n  P base = c2.o - c1.o;\n\n  if(abs(cp) == 1) {\n    v.push_back(c1.o + A*base);\n  } else {\n    P n(-base.imag(), base.real());\n    n /= abs(n);\n    double h = sqrt(c1.r * c1.r - A*A*ll);\n    v.push_back(c1.o + A*base + h*n);\n    v.push_back(c1.o + A*base - h*n);\n  }\n  return v;\n}\n\n\n// 2(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// (1, 0)(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2r\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b);\n  double alpha = getAngle(a);\n  double d = r/sin(rad/2.0);\n  C res;\n  res.r = r;\n  res.o = p + d * P(cos(alpha + rad/2.0), sin(alpha + rad/2.0));\n  return res;\n}\n\n// 3\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// \ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// \ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\n// \nvector<L> getTangent(C a, C b) {\n  if(a.r > b.r) swap(a,b);\n  vector<L> res;\n  double d = abs(b.o - a.o);\n  double th;\n  P v, n;\n  int t = isIntersect(a, b);\n\n  if(equals(a.o.real(), b.o.real()) && \n     equals(a.o.imag(), b.o.imag()) && \n     equals(a.r, b.r)) return res;\n  if(t == -2) return res;\n\n  if(t == 0 || t == 1 || t == 2) {\n    th = asin((b.r - a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o+n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 0) {\n    th = asin((b.r + a.r)/d);\n\n    v = getRotateP(b.o, th, a.o) - a.o;\n    n = P(-v.imag(), v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n    \n    v = getRotateP(b.o, -th, a.o) - a.o;\n    n = P(v.imag(), -v.real());\n    n /= abs(n);\n    res.push_back(L(a.o-n*a.r, b.o+n*b.r));\n  }\n\n  if(t == 1) {\n    n = b.o - a.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  if(t == -1) {\n    n = a.o - b.o;\n    n /= abs(n);\n    v = P(-n.imag(), n.real());\n    res.push_back(L(a.o + n*a.r, a.o + n*a.r + v));\n  }\n\n  return res;\n}\n\n// aoj 2201\nint main(void) {\n  int N;\n  vector<P> p;\n  vector<double> r, m;\n  while(cin >> N && N) {\n    p.resize(N);\n    r.resize(N);\n    m.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> p[i].real() >> p[i].imag() >> r[i] >> m[i];\n    }\n    if(N == 1) {\n      if(r[0] <= m[0]) cout << 1 << endl;\n      else cout << 0 << endl;\n      continue;\n    }\n    vector<L> ls;\n    for(int i = 0; i < N; ++i) {\n      for(int j = i+1; j < N; ++j) {\n\tvector<L> tmp;\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n\ttmp = getTangent(C(p[i], r[i]+m[i]), C(p[j], r[j]+m[j]));\n\tfor(int k = 0; k < tmp.size(); ++k) ls.push_back(tmp[k]);\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < ls.size(); ++k) {\n      int cnt = 0;\n      for(int i = 0; i < N; ++i) {\n\tdouble d = getDistanceLP(ls[k][0], ls[k][1], p[i]);\n\tif((equals(d, r[i]) || d > r[i]) &&\n\t   (equals(d-r[i], m[i]) || d-r[i] < m[i])) ++cnt;\n      }\n      res = max(res, cnt);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nstatic const double pi = 3.141592653589793;\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-3;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nint N;\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nint points[51][4];\n\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n\n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\n\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\ntuple<int, double, P, P, P, P> count(P a1,P a2,P b1,P b2) {\n\tif(isecSS(a1, b1, a2, b2)) swap(b1,b2);\n\tint cnt = 0;\n\tvector<P> vp = {a1, a2, b2, b1};\n\trep(i, N) {\n\t\tP p1 = P(points[i][0], points[i][1]);\n\t\tdouble r1 = points[i][2];\n\t\tdouble r2 = r1 + points[i][3];\n\t\tdouble l1 = min(distLP(a1, b1, p1), distLP(a2, b2, p1));\n\t\tdouble l2 = max(distLP(a1, b1, p1), distLP(a2, b2, p1));\n\t\tif(inConvex(p1, vp) > 0) {\n\t\t\tif (l2 + EPS >= r1) {\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l1 <= r2 + EPS and l2 + EPS >= r1) cnt += 1;\n\t\t}\n\t}\n\t//cout << a1<< a2<< b1<<b2<< cnt << \"d\" << -abs(a1 - a2) << \"c\" << isecSS(a1, b1, a2, b2)<< endl;\n\treturn make_tuple(cnt,-abs(a1 - a2), a1, a2, b2, b1);\n}\n\nP rotateP(P a ,D arg) { //点aを点oを中心に反時計周りにまわした複素数を返す。\n\t//a -= o;\n\ta *= P(cos(arg), sin(arg));\n\t//a += o;\n\treturn a;\n}\n\t\n\nint main() {\n\t\n\t/*ifstream in(\"Ain.txt\");\n\tcin.rdbuf(in.rdbuf());\n\tofstream ofs(\"Aout.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\twhile (cin >> N, N) {\n\t\trep(i, N) {\n\t\t\trep(j, 4) {\n\t\t\t\tcin >> points[i][j];\n\t\t\t}\n\t\t}\n\t\tpriority_queue<tuple<int, double, P, P, P, P>, vector<tuple<int, double, P, P, P, P>>> pq;\n\t\tdouble ar1 = pi / 10;\n\t\tP pa = P(-3000, 0);\n\t\tP pa1 = rotateP(pa, -ar1 / 2);\n\t\tP pa2 = rotateP(pa, ar1 / 2);\n\t\trep(a , 20) {\n\t\t\tP pb1 = rotateP(pa1, 2 * ar1);\n\t\t\tP pb2 = rotateP(pa2, 2 * ar1);\n\t\t\trep(b, 17) {\n\t\t\t\tpq.push(make_tuple(N, 10, pa1, pa2, pb1, pb2));\n\t\t\t\tpb1 = rotateP(pb1, ar1);\n\t\t\t\tpb2 = rotateP(pb2, ar1);\n\t\t\t\t//cout << pa1 << pa2 << pb1 << pb2 << endl;\n\t\t\t}\n\t\t\tpa1 = rotateP(pa1, ar1);\n\t\t\tpa2 = rotateP(pa2, ar1);\n\t\t}\n\t\t\t\t\n\tint ans = 0;\n\twhile(true) {\n\t\tauto p = pq.top();\n\t\tif (abs(get<1>(p)) < EPS) {\n\t\t\tans = get<0>(p);\n\t\t\tbreak;\n\t\t}\n\t\tpq.pop();\n\t\tdouble d = -get<1>(p) / 2;\n\t\tP ma = (get<2>(p) + get<3>(p)) / P(2, 0);\n\t\tP mb = (get<4>(p) + get<5>(p)) / P(2, 0);\n\t\tpq.push(count(get<2>(p), ma, get<4>(p), mb));\n\t\tpq.push(count(ma, get<3>(p), get<4>(p), mb));\n\t\tpq.push(count(get<2>(p), ma, mb, get<5>(p)));\n\t\tpq.push(count(ma, get<3>(p), mb, get<5>(p)));\n\t}\n\tcout << ans << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct line\n{\n    double a,b,c;\n};\n\nconst int MAX_N = 100005;\nconst int sign[] = {1,-1};\n\nvector<line> tangent(double x1,double y1,double r1,double x2,double y2,double r2)\n{\n    vector<line> vec;\n    double p,q,r;\n    double a = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    rep(i,2){\n        double b = -(x2-x1)*(r1*r1+sign[i]*r1*r2);\n        double c = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (y2-y1)*(y2-y1)*r1*r1;\n        rep(j,2){\n            if(b*b - a*c < -EPS){\n                break;\n            }\n            p = (-b + sign[j]*sqrt(b*b-a*c)) / a;\n            b = -(y2-y1)*(r1*r1+sign[i]*r1*r2);\n            c = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (x2-x1)*(x2-x1)*r1*r1;\n            q = (-b - sign[j]*sqrt(b*b-a*c)) / a;\n            r = -r1*r1 - p*x1 - q*y1;\n            vec.push_back((line){p,q,r});\n        }\n    }\n    return vec;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        int X[51],Y[51],R[51],M[51];\n    \trep(i,n){\n    \t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&M[i]);\n    \t}\n        if(n == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        vector<line> v;\n        v = tangent(X[0],Y[0],R[0],X[1],Y[1],R[1]);\n        int res = 0;\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                vector<line> u[4];\n                u[0] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]);\n                u[1] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]+M[j]);\n                u[2] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]);\n                u[3] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]+M[j]);\n                rep(k,4){\n                    rep(l,u[k].size()){\n                        int bf = 2;\n                        double aa = u[k][l].a,bb = u[k][l].b,cc = u[k][l].c;\n                        double d = sqrt(aa*aa+bb*bb);\n                        rep(l,n){\n                            if(l != i && l != j){\n                                if(abs(aa*X[l] + bb*Y[l] + cc) / d > R[l] - EPS && abs(aa*X[l] + bb*Y[l] + cc) / d < R[l] + M[l] + EPS){\n                                    bf++;\n                                }\n                            }\n                        }\n                        res = max(res,bf);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distLP(Point a1, Point a2, Point p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<Line> tangentLines(Point a, double ar, Point b, double br) {\n  vector<Line> ls;\n  double d = abs(b-a);\n  rep (i,2) {\n    double sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    double cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      Point n = (b-a) * Point(sin, (1-j*2)*cos) / d;\n      ls.push_back(Line(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<Point> c(n);\n        vector<int> r(n),m(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y >>r[i] >>m[i];\n            c[i] = Point(x,y);\n        }\n\n        int ans = 1;\n        rep(i,n)rep(j,i){\n            rep(ii,2)rep(jj,2){\n                vector<Line> ls = tangentLines(c[i],r[i]+ii*m[i],c[j],r[j]+jj*m[j]);\n                for(const auto &l:ls){\n                    int tt = 0;\n                    rep(k,n){\n                        double d = distLP(l.fi,l.se,c[k]);\n                        if(LE(0,d-r[k]) && LE(d-r[k],m[k])) ++tt;\n                    }\n                    ans = max(ans,tt);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = 1e18 + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nnamespace geometry{\n    using D = long double;\n    constexpr D eps =1e-9;\n\n    struct Point;\n    bool near_eq(Point, Point);\n    D norm(Point);\n\n    struct Point{\n        D x, y;\n        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}\n        friend bool operator<(const Point& a, const Point& b){\n            return a.x == b.x ? a.y < b.y : a.x < b.x;\n        }\n        Point& operator+=(Point a){x += a.x, y += a.y; return *this;}\n        Point& operator-=(Point a){x -= a.x, y -= a.y; return *this;}\n        Point& operator*=(D p){x *= p, y *= p; return *this;}\n        Point& operator*=(Point b){return *this = *this * b;}\n        Point& operator/=(D p){x /= p, y /= p; return *this;}\n        Point& operator/=(Point b){return *this = *this / b;}\n        friend Point operator+(Point a, Point b){return Point(a) += b;}\n        friend Point operator-(Point a, Point b){return Point(a) -= b;}\n        friend Point operator*(Point a, D p){return Point(a) *= p;}\n        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}\n        friend Point operator/(Point a, D b){return Point(a) /= b;}\n        friend Point operator/(Point a, Point b){return Point(a.x * b.x + a.y * b.y, b.x * a.y - a.x * b.y) / norm(b);}\n    };\n    using P = Point;\n\n    struct Circle : public Point{\n        D r;\n        Circle(Point p = Point(), D r = 1) : Point(p), r(r){}\n        Circle(D x = 0.0, D y = 0.0, D r = 1) : Point(x, y), r(r){}\n    };\n    using C = Circle;\n\n    bool near_eq(D a, D b = 0.0){return abs(a - b) < eps;}\n    bool near_eq(P a, P b = Point()){return near_eq(a.x, b.x) && near_eq(a.y, b.y);}\n    D diag(P a){\n        assert(!near_eq(a));\n        return atan2(a.y, a.x);\n    }\n    D norm(P a){return a.x * a.x + a.y * a.y;}\n    D abs(P a){return sqrt(norm(a));}\n    D dist(P a, P b){return abs(a - b);}\n    D dot(P a, P b){return a.x * b.x + a.y * b.y;}\n    D cross(P a, P b){return a.x * b.y - a.y * b.x;}\n    int ccw(P a, P b, P c){\n        b -= a;\n        c -= a;\n        if(cross(b, c) > eps)return 1;\n        if(cross(b, c) < -eps)return -1;\n        if(dot(b, c) < -eps)return 2;\n        if(norm(b) < norm(c))return -2;\n        return 0;\n    }\n    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}\n    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}\n    P proj(P a1, P a2, P b){return a1 + dot(a2 - a1, b - a1) / norm(a2 - a1) * (a2 - a1);} // 直線への射影点\n    D dist(P a1, P a2, P b){return dist(proj(a1, a2, b), b);}\n    bool intersect(P a1, P a2, P b1, P b2){\n        return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n               ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n    }\n    P cross_point(P a1, P a2, P b1, P b2){\n        D d1 = cross(b2 - b1, b1 - a1);\n        D d2 = cross(b2 - b1, a2 - a1);\n        if(near_eq(d1) && near_eq(d2))return a1;\n        assert(!near_eq(d2));\n        return a1 + d1 / d2 * (a2 - a1);\n    }\n    vector<Point> cross_point(C c1, C c2){\n        vector<Point> cross;\n        P diff = c2 - c1;\n        D d = abs(diff);\n        D crl = (norm(diff) + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n        if(near_eq(d) || c1.r < abs(crl))\n            return cross;\n        P abn = diff * P(0, sqrt(c1.r * c1.r - crl * crl) / d);\n        P cp = c1 + crl / d * diff;\n        cross.push_back(cp + abn);\n        if(!near_eq(abn))\n            cross.push_back(cp - abn);\n        return cross;\n    }\n    vector<pair<P, P>> tangent_lines(C c1, C c2){ // 共通接線、接線の両端は円との接点\n        vector<pair<P, P>> lines;\n        D d = dist(c1, c2);\n        for(int i = 0; i < 2; ++i){\n            D sin =(c1.r - (1 - i * 2) * c2.r) / d;\n            if(!(sin * sin < 1 + eps))\n                break;\n            D cos = sqrt(max(1 - sin * sin, D(0)));\n            for(int j = 0; j < 2; ++j){\n                P n = (c2 - c1) * P(sin, (1 - j * 2) * cos) / d;\n                lines.emplace_back(c1 + c1.r * n, c2 + (1 - i * 2)  * c2.r * n);\n                if(cos < eps)\n                    break;\n            }\n        }\n        return lines;\n    }\n}\n\n\nbool solve(){\n    int n;\n    cin >> n;\n    if(!n)\n        return false;\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> r(n);\n    vector<int> m(n);\n    for(int i = 0; i < n; ++i)\n        cin >> x[i] >> y[i] >> r[i] >> m[i];\n    if(n == 1){\n        cout << 1 << endl;\n        return true;\n    }\n    using namespace geometry;\n    vector<C> circles, power;\n    for(int i = 0; i < n; ++i){\n        circles.emplace_back(x[i], y[i], r[i]);\n        power.emplace_back(x[i], y[i], r[i] + m[i]);\n    }\n\n    vector<pair<P,P>> vs;\n    for(int i = 0; i < n; ++i){\n        for(int j = i + 1; j < n; ++j){\n            auto res = tangent_lines(circles[i], circles[j]);\n            for(auto p : res)\n                vs.push_back(p);\n            res = tangent_lines(circles[i], power[j]);\n            for(auto p : res)\n                vs.push_back(p);\n            res = tangent_lines(power[i], circles[j]);\n            for(auto p : res)\n                vs.push_back(p);\n            res = tangent_lines(power[i], power[j]);\n            for(auto p : res)\n                vs.push_back(p);\n        }\n    }\n    int ans = 0;\n    for(auto& p : vs){\n        P p1, p2;\n        tie(p1, p2) = p;\n        int cnt = 0;\n        for(int i = 0; i < n; ++i){\n            D d = dist(p1, p2, circles[i]);\n            if(r[i] < d + eps && d < r[i] + m[i] + eps)\n                ++cnt;\n        }\n        chmax(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,double> P1;\nconst double EPS = 1e-10;\ntypedef pair<P,P> L;\nint n,m[51];\n\n\n//kaitenn\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n \n//???\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\nCircle c[2][51];\n \nL getIntangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double w=a.r+b.r;\n  double h=sqrt(max(0.0,norm(base)-w*w));\n  P k=base*P(w,h*f)/norm(base);\n  return L(a.c+k*a.r,b.c-k*b.r);\n}\n \nL getOuttangent(Circle a,Circle b,double f=1.0){\n  P base=b.c-a.c;\n  double h=b.r-a.r;\n  double w=sqrt(max(0.0,norm(base)-h*h));\n  P k=base*P(w,h*f)/norm(base)*P(0,f);\n  return L(a.c+k*a.r,b.c+k*b.r);\n}\n \nvector<L> tangentCC(Circle a,Circle b){\n  double dis=abs(a.c-b.c),R=a.r+b.r;\n  vector<L> res;\n  if(dis>R+EPS)res.push_back(getIntangent(a,b));\n  if(dis>R-EPS)res.push_back(getIntangent(a,b,-1));\n  if(dis>abs(a.r-b.r)+EPS)res.push_back(getOuttangent(a,b));\n  if(dis>abs(a.r-b.r)-EPS)res.push_back(getOuttangent(a,b,-1));\n  return res;\n}\n\nint cal(P a,P b){\n  int res=0;\n  b-=a;\n  for(int i=0;i<n;i++){\n    P t=(c[0][i].c-a)*conj(b)/abs(b);\n    if(c[0][i].r<=abs(t.imag())+EPS&&abs(t.imag())<=c[1][i].r+EPS)res++;\n  }\n  return res;\n}\n \nint main(){\n  while(cin>>n,n){\n\n    for(int i=0,a,b,r,m;i<n;i++){\n      cin>>a>>b>>r>>m;\n      c[0][i]=Circle(P(a,b),r);\n      c[1][i]=Circle(P(a,b),r+m);\n    }\n    \n    int ans=1;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\tfor(int k=0;k<4;k++){\n\t  vector <L> res=tangentCC(c[k%2][i],c[(k>>1)%2][j]);\n\t  for(int l=0;l<res.size();l++) ans=max(ans,cal(res[i].first,res[i].second));\n\t}\n      }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &rpoint;\n\ndouble cross(rpoint va, rpoint vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble distance_l_p(rpoint a, rpoint b, rpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ntypedef pair<point,point> line;\nvector<line> common_tangent(rpoint p1, double r1, point p2, double r2){\n\tvector<line> ret;\n\n\tp2 -= p1;\n\tdouble a = arg(p2);\n\tdouble b = (r1 - r2) / abs(p2);\n\tif( b < -1.0 || b > 1.0 ){ return ret; }\n\tdouble c = asin(b) - asin(1.0);\n\tret.push_back( make_pair( p1 + polar(r1, a - c), p1 + p2 + polar(r2, a - c) ) );\n\tret.push_back( make_pair( p1 + polar(r1, a + c), p1 + p2 + polar(r2, a + c) ) );\n\n\tb = (r1 + r2) / abs(p2);\n\tif( b < -1.0 || b > 1.0 ){ return ret; }\n\tc = asin(b) - asin(1.0);\n\tret.push_back( make_pair( p1 + polar(r1, a - c), p1 + p2 - polar(r2, a - c) ) );\n\tret.push_back( make_pair( p1 + polar(r1, a + c), p1 + p2 - polar(r2, a + c) ) );\n\n\treturn ret;\n}\n\nint n;\npoint p[50];\ndouble r[50];\ndouble m[50];\nint ans;\n\n\nvoid check(rpoint p1, double r1, rpoint p2, double r2){\n\tvector<line> v = common_tangent(p1, r1, p2, r2);\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tint c = 0;\n\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tdouble d = distance_l_p(v[i].first, v[i].second, p[j]);\n\t\t\tif( d > r[j] - EPS && d < m[j] + EPS ){\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = max(ans, c);\n\t}\n}\n\nint main(){\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tans = 1;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf%lf\", &x, &y, &r[i], &m[i]);\n\t\t\tm[i] += r[i];\n\t\t\tp[i] = point(x, y);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; ++i)\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tcheck(p[i], r[i], p[j], r[j]);\n\t\t\tcheck(p[i], r[i], p[j], m[j]);\n\t\t\tcheck(p[i], m[i], p[j], r[j]);\n\t\t\tcheck(p[i], m[i], p[j], m[j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B operator<(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return cross(b - a, p - a) / abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return cross(a - b,c - b) * cross(a - b,d - b) <EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n    IL Poly convex_hull(Poly& p) {\n        int n = (int)p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p));\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = (int)l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist > r + EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            {\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist > Rp + Rq + EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist > Rp - Rq + EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n}\n\ninline int check(geo::Line l,vector<geo::Circle>& cd, vector<geo::Circle>& cm){\n    int res = 0;\n    int n = (int)cd.size();\n    for (int i = 0; i < n; i++){\n        double d = geo::distance( cd[i].first,l);\n    //  cout << d << \" \";\n        if (d<cm[i].second +geo::eps&&d>cd[i].second-geo::eps)\n            res++;\n    }\n    //cout << endl;\n    return res;\n \n \n}\nint main(){\n    //ifstream cin(\"in.txt\");ofstream cout(\"out.txt\");\n    while (1){\n        int N;\n        cin >> N;\n        if (N == 0)break;\n \n        vector<geo::Circle> cd(N);\n        vector<geo::Circle> cm(N);\n        for (int i = 0; i < N; i++){\n            double x, y, d, m;\n            cin >> x >> y >> d >> m;\n            geo::x(cd[i].first, x);\n            geo::y(cd[i].first, y);\n            geo::x(cm[i].first, x);\n            geo::y(cm[i].first, y);\n            cd[i].second = d;\n            cm[i].second = d+m;\n        }\n        if (N == 1){\n            if (cm[0].second < geo::eps)cout << 0 << endl;\n            else cout << 1 << endl;\n            continue;\n        }\n        int res = 0;\n        for (int i = 0; i < N; i++){\n            for (int j = 0; j < N; j++){\n                if (i != j){\n                    //cout << i << j << endl << endl;\n                    //cout << \"inner1\" << endl;\n                    auto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n                    for (auto& it : p1){\n                        res=max(check(it, cd, cm),res);\n                    }\n                //  cout << \"inner2\" << endl;\n                    auto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n                    for (auto& it : p2){\n                        res = max(check(it, cd, cm), res);\n                    }\n                //  cout << \"inner3\" << endl;\n                    auto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n                    for (auto& it : p3){\n                        res = max(check(it, cd, cm), res);\n                    }\n                //  cout << \"outer1\" << endl;\n                    auto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n                    for (auto& it : q1){\n                        res = max(check(it, cd, cm), res);\n                    }\n                //  cout << \"outer2\" << endl;\n                    auto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n                    for (auto& it : q2){\n                        res = max(check(it, cd, cm), res);\n                    }\n                //  cout << \"outer3\" << endl;\n                    auto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n                    for (auto& it : q3){\n                        res = max(check(it, cd, cm), res);\n                    }\n \n                }\n            }\n        }\n        cout << res << endl;\n    }\n    //cin.close();  cout.close();\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    double diff = a - b;\n    if(abs(diff) < EPS) return 0;\n    else if(diff < 0) return -1;\n    return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nint ccw(const P& a, P b, P c)\n{\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) {\n    return +1;\n  } else if (cross(b, c) < -EPS) {\n    return -1;\n  } else if (dot(b, c) < -EPS) {\n    return +2;\n  } else if (dot(b, b) + EPS < dot(c, c)) {\n    return -2;\n  } else {\n    return 0;\n  }\n}\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct circle/*{{{*/\n{\n  P o;\n  double r;\n  circle() {}\n  circle(const P& p, double x) : o(p), r(x) {}\n\n  // POJ 1375 Intervals\n  // 点 p を通る2つの接線\n  pair<P,P> tangent(const P& p) const\n  {\n    const double L = abs(o - p);\n    const double M = sqrt(L*L - r*r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M*(v*polar(1.0, theta)), p + M*(v*polar(1.0, -theta)));\n  }\n\n  pair<line,line> outer_tangent(const circle &c) const {\n      if(r > c.r) return c.outer_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 - c.r/r;\n      const P base = c.o + d+d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  pair<line,line> inner_tangent(const circle &c) const {\n      if(r > c.r) return c.inner_tangent(*this);\n      const P d = o - c.o;\n      const double fact = 1 + c.r/r;\n      const P base = c.o + d/fact;\n      const pair<P,P> t = tangent(base);\n      return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // POJ 1418 Viva Confetti\n  // POJ 2149 Inherit the Spheres\n  inline bool intersects(const circle& c) const\n  {\n    return !contains(c) && !c.contains(*this) && abs(o - c.o) <= r + c.r;\n  }\n\n  inline bool independent(const circle &c) const {\n      return abs(o-c.o) > r+c.r;\n  }\n\n  pair<P,P> intersection(const circle& c) const\n  {\n    // assert(intersects(c))\n    const double d = abs(o - c.o);\n    const double cos_ = (d*d + r*r - c.r*c.r) / (2*d);\n    const double sin_ = sqrt(r*r - cos_*cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e*P(cos_, sin_), o + e*P(cos_, -sin_));\n  }\n\n  inline bool contains(const circle& c) const\n  {\n    return abs(o - c.o)+c.r <= r;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return abs(ln.distance(o)) <= r;\n  }\n\n  inline double distance(const line &ln) const {\n      return abs(ln.distance(o));\n  }\n\n  pair<P,P> intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r*r - d*d);\n    return make_pair(h + l*ab, h - l*ab);\n  }\n};/*}}}*/\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<circle,circle>> jewels;\n    vector<line> lines;\n    for(int i = 0; i < N; ++i) {\n        double x, y, r, m;\n        cin >> x >> y >> r >> m;\n        const P center(x, y);\n        pair<circle,circle> jewel = make_pair(circle(center, r), circle(center, r+m));\n        const circle &c1 = jewel.second;\n        for(const auto &other : jewels) {\n            const circle &c2 = other.second;\n            if(c1.independent(c2)) {\n                auto outer = c1.outer_tangent(c2);\n                lines.push_back(outer.first);\n                lines.push_back(outer.second);\n                auto inner = c1.inner_tangent(c2);\n                lines.push_back(inner.first);\n                lines.push_back(inner.second);\n            } else if(c1.intersects(c2)) {\n                auto outer = c1.outer_tangent(c2);\n                lines.push_back(outer.first);\n                lines.push_back(outer.second);\n                auto inter = c1.intersection(c2);\n                lines.push_back(line(inter.first, inter.second));\n            } else {\n                assert(false);\n            }\n            // Contain is impossible (by input constraints)\n        }\n        jewels.push_back(jewel);\n    }\n\n    int ans = 1;\n    for(auto &l : lines) {\n        int cnt = count_if(jewels.begin(), jewels.end(), [&](const pair<circle,circle> &j){\n                return cmp(j.first.r, j.first.distance(l)) <= 0 && \n                cmp(j.second.r, j.second.distance(l)) >= 0;\n                });\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n \nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\ndouble sc(double a){return sqrt(1.0-a*a);}\n\nclass Point{\npublic:\n  double x, y;\n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\n \nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\ntypedef Segment Line;\n \ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nPoint rotate( Point a, double si,double co){\n  return Point(a.x*co-a.y*si,a.x*si+a.y*co);\n}\nPoint rotate( Point a, double n){\n  return Point( a.x*cos(n)-a.y*sin(n) , a.x*sin(n)+a.y*cos(n) );\n}\n\nPoint getCrossPointCC(Point p1,double r1,Point p2,double r2){\n  double a=r2,b=r1,c=getDistance(p1,p2);\n  double cos_A = (b*b+c*c-a*a) / (2.0*b*c);\n  double sin_A = sqrt(1.0-cos_A*cos_A);\n  Vector v=p2-p1;\n  v = v * r1 / c;\n  return p1+rotate(v,sin_A,cos_A);\n}\n\nSegment getSegmentCC(Point p1,double r1,Point p2,double r2,bool flg=false){\n  double b=getDistance(p1,p2),c=r1+r2;\n  double a=sqrt(b*b-c*c);\n  double cos_A=(b==0?1:c/b),sin_A=(b==0?0:a/b);\n\n  if(flg)sin_A=-sin_A;\n  \n  Vector v1 = (p2-p1),v2 = (p1-p2);\n  v1 = v1 * r1 / b;\n  v1 = rotate(v1,sin_A,cos_A);\n  v2 = v2 * r2 / b;\n  v2 = rotate(v2,sin_A,cos_A);\n  return Segment(p1+v1,p2+v2);\n}\n\nSegment getSegmentCC2(Point p1,double r1,Point p2,double r2,bool flg=false){\n  if(r1>r2){\n    swap(p1,p2);\n    swap(r1,r2);\n  }\n  double c=abs(r1-r2),b=getDistance(p1,p2);\n  double a=sqrt( b*b - c*c );\n\n  double cos_A=c/b,sin_A=a/b;\n  if(flg)sin_A=-sin_A;\n\n  Vector v1 = p1-p2;\n  v1 = v1 * r1 / b;\n  v1 = rotate( v1, sin_A,cos_A);\n  Vector v2 = v1 * r2 / r1;\n  return Segment(p1+v1,p2+v2);\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\nint N;\nPoint t[50];\ndouble r[50],m[50];\nvector<Segment> segments;\nint check(Segment);\n\nint main(){\n  while(cin>>N&&N){\n    segments.clear();\n    for(int i=0;i<N;i++){\n      cin>>t[i].x>>t[i].y>>r[i]>>m[i];\n      m[i]+=r[i];\n      for(int j=0;j<i;j++){\n\n\tsegments.push_back(getSegmentCC(t[i],m[i],t[j],m[j]));\n\tsegments.push_back(getSegmentCC(t[i],m[i],t[j],m[j],true));\n\tsegments.push_back(getSegmentCC2(t[i],m[i],t[j],m[j]));\n\tsegments.push_back(getSegmentCC2(t[i],m[i],t[j],m[j],true));\n\n\tsegments.push_back(getSegmentCC(t[i],r[i],t[j],r[j]));\n\tsegments.push_back(getSegmentCC(t[i],r[i],t[j],r[j],true));\n\tsegments.push_back(getSegmentCC2(t[i],r[i],t[j],r[j]));\n\tsegments.push_back(getSegmentCC2(t[i],r[i],t[j],r[j],true));\n\n      }\n    }\n    if(N==1){\n      cout<<\"1\"<<endl;\n      continue;\n    }\n    int ans=0;\n    for(int i=0;i<(int)segments.size();i++){\n      Segment s = segments[i];\n      if(s.p1 == s.p2)continue;\n      ans=max(ans,check(s));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\nint check(Segment s){\n  int res=0;\n  for(int i=0;i<N;i++){\n    double d = getDistanceLP(s,t[i]);\n    if( r[i]<EPS+d && d< EPS+m[i] )res++;\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\nstruct Line : public vector<Point> {\n  Line(Point a, Point b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const{\n    return back() - front();\n  }\n};\nstruct Circle{\n  Point p; double r;\n  Circle() {}\n  Circle(Point p, double r) : p(p), r(r) {}\n};\nLine circle_tangent(Circle& C, double th){\n  Point p0 = C.p + polar(C.r, th);\n  Point p1 = p0 + polar(1.0, th + M_PI / 2);\n  return Line(p0, p1);\n}\nvector<double> common_tangents(Circle& C, Circle& D){\n  vector<double> res;\n  Point v = D.p - C.p;\n  double l = abs(v);\n  double a = arg(v);\n  if(sign(l - abs(C.r - D.r)) > 0){\n    double a1 = acos((C.r - D.r) / l);\n    res.push_back(a + a1);\n    res.push_back(a - a1);\n    if(sign(l - (C.r + D.r)) > 0){\n      double a2 = acos((C.r + D.r) / l);\n      res.push_back(a + a2);\n      res.push_back(a - a2);\n    }\n  }\n  if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n    res.push_back(a);\n  }\n  return res;\n}\nPoint projection(const Line& l, Point p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\ndouble distanceLP(const Line& l, Point p){\n  return abs(p - projection(l, p));\n}\nint main(){\n int N;\n  while(cin >> N && N){\n    vector<Point> ps(N);\n    vector<double> r(N);\n    vector<double> m(N);\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag() >> r[i] >> m[i];\n    int ans = 1;\n    REP(i, N) REP(j, N) REP(b1, 2) REP(b2, 2) if(i != j){\n      Circle C(ps[i], r[i] + b1 * m[i]);\n      Circle D(ps[j], r[j] + b2 * m[j]);\n      vector<double> args = common_tangents(C, D);\n      REP(j, args.size()){\n        Line l = circle_tangent(C, args[j]);\n        int sub_ans = 0;\n        REP(k, N) if(sign(distanceLP(l, ps[k]) - r[k]) >= 0 && sign(distanceLP(l, ps[k]) - (r[k] + m[k])) <= 0) sub_ans++;\n        ans = max(ans, sub_ans);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define P complex<T> \n#define EPS (1e-9)\n\n/*****\n * ¼üÍ¼üãÌÙÈé2_(p1, p2)Å\\·\n * ~ÍScÆ¼arÉæè(c, r)Æ\\·\n *****/\n\n//XJ[lÌðÔ·B+:1, -:-1, 0:0B\ntemplate<typename T>\nint sig(T a){\n    return a==0?0:a>0?1:-1;\n}\n\n//xNgp1, p2ÌàÏðÔ·\ntemplate<typename T>\nT iprod(P p1, P p2){\n    return (p1.real()*p2.real()) + (p1.imag()*p2.imag());\n}\n\n//xNgp1, p2ÌOÏ(XJ[l,zÀW)ðÔ·\ntemplate<typename T>\nT oprod(P p1, P p2){\n    return (p1.real()*p2.imag()) - (p1.imag()*p2.real());\n}\n\n\n//üª(p1, p2)Æ_qÌ£ðÔ·\ntemplate<typename T>\nT disSP(P p1, P p2, P q){\n    if(iprod( (p2-p1), (q-p1) ) < EPS) return abs(q-p1);\n    if(iprod( (p1-p2), (q-p2) ) < EPS) return abs(q-p2);\n    return disLP(p1, p2, q);\n}\n\n//¼ü(p1, p2)Æ_qÌ£ðÔ·\ntemplate<typename T>\nT disLP(P p1, P p2, P q){\n    return abs( oprod( (p2-p1), (q-p1) ) ) / abs(p2-p1);\n}\n\n//üª(p1, p2)Æüª(q1, q2)Ìð_ª¶Ý·éÆ«ÉtrueðÔ·\ntemplate<typename T>\nbool crsSS(P p1, P p2, P q1, P q2){\n    if(max(p1.real(), p2.real()) + EPS < min(q1.real(), q2.real())) return false;\n    if(max(q1.real(), q2.real()) + EPS < min(p1.real(), p2.real())) return false;\n    if(max(p1.imag(), p2.imag()) + EPS < min(q1.imag(), q2.imag())) return false;\n    if(max(q1.imag(), q2.imag()) + EPS < min(p1.imag(), p2.imag())) return false;\n   return sig(oprod(p2-p1, q1-p1)) * sig(oprod(p2-p1, q2-p1)) < EPS\n        && sig(oprod(q2-q1, p1-q1)) * sig(oprod(q2-q1, p2-q1)) < EPS;\n}\n\n//~(c1, r)Æ~(c2, r2)Ìð_ª¶Ý·éÆ«ÉtrueðÔ·B\n//Ú_ÌÆ«à½ªtrueðÔ·\ntemplate<typename T>\nbool crsCC(P c1, T r1, P c2, T r2){\n    T dis = abs(c1-c2);\n    return dis < r1 + r2 + EPS && abs(r1-r2) < dis + EPS;\n}\n\n//Op`(p1, p2, p3)ÌOSðÔ·\n/*********¢À*********/\ntemplate<typename T>\nP ccenter(P p1, P p2, P p3){\n    return p1;\n}\n//4_p1, p2, p3, p4ª¯ê¼üãÉ éÆ«trueðÔ·B\n//4_ª¯ê¼üãÉ éÆ«àtrueðÔ·çµ¢\ntemplate<typename T>\nbool onCir(P p1, P p2, P p3, P p4){\n    if(abs(oprod(p2-p1, p3-p1)) < EPS) return true;\n    P c = ccenter(p1, p2, p3);\n    return abs(norm(c-p1) - norm(c-p4)) < EPS;\n}\n\n//_q©ç¼ü(p1, p2)Éºëµ½üÌ«ðÔ·\ntemplate<typename T>\nP proj(P p1, P p2, P q){\n    return p1 + (iprod( p2-p1, q-p1 )/(norm(p2-p1))*(p2-p1));\n}\n\n//¼ü(p1,p2)Æ¼ü(q1, q2)Ìð_ðÔ·\ntemplate<typename T>\nP isLL(P p1, P p2, P q1, P q2){\n    T d = oprod( q2-q1, p2-p1 );\n    if ( abs(d) < EPS ) return NULL;\n    return p1 + (oprod(q2-q1, q1-p1)/d*(p2-p1));\n}\n\n//¼ü(p1,p2)Æ~(c,r)Ìð_ÌvectorðÔ·(p1Éß¢)\ntemplate<typename T>\nvector<P> isCL(P c, T r, P p1, P p2){\n    vector<P> ans;\n    T x = iprod(p1-c, p2-p1);\n    T y = norm(p2-p1);\n    T d  = x*x - y*(norm(p1-c) - r*r);\n    if(d < -EPS) return ans;\n    if(d < 0) d = 0;\n    P q1 = p1 - (x/y)*(p2-p1);\n    P q2 = sqrt(d)/y*(p2-p1);\n    ans.push_back(q1-q2);\n    ans.push_back(q1+q2);\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ìð_ÌvectorðÔ·\ntemplate<typename T>\nvector<P> isCC(P c1, T r1, P c2, T r2){\n    vector<P> ans;\n    T x = norm(c1-c2);\n    T y = ((r1*r1 - r2*r2)/x + 1)/2;\n    T d = r1*r1/x - y*y;\n    if(d < -EPS) return ans;\n    if(d < 0) d=0;\n    P q1 = c1 + y*(c2-c1);\n    P q2 = (c2 - c1)*(polar(sqrt(d), (T)M_PI/2));\n    ans.push_back(q1-q2);\n    ans.push_back(q1+q2);\n    return ans;\n}\n\n//_p©çø¢½~(c, r)ðÊéÚüÌÚ_ÌvectorðÔ·\ntemplate<typename T>\nvector<P> tanCP(P c, T r, P p){\n    vector<P> ans;\n    T x = norm(p-c);\n    T d = x - r*r;\n    if(d < -EPS) return ans;\n    if(d < 0) d = 0;\n    P q1 = (r*r/x)*(p-c);\n    P q2 = (p-c)*(polar(-r*sqrt(d)/x, (T)M_PI/2));\n    ans.push_back(c+q1-q2);\n    ans.push_back(c+q1+q2);\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ì¤ÊÚüÌvectorðÔ·\n/******2~ªÚ·éÆ«ÌªvC³*********/\ntemplate<typename T>\nvector< vector<P> > tanCC(P c1, T r1, P c2, T r2){\n    vector< vector<P> > ans;\n    vector<P> line;\n    if(abs(r1-r2) < EPS){\n        P dir = c2-c1;\n        dir = dir * polar(r1/abs(dir), (T)M_PI/2);\n        \n        line.clear(); line.push_back(c1+dir); line.push_back(c2+dir);\n        ans.push_back(line);\n        line.clear(); line.push_back(c1-dir); line.push_back(c2-dir);\n        ans.push_back(line);\n        \n    }else{\n        P p = (-r2*c1 + r1*c2)/(r1-r2);\n        vector<P> ps, qs;\n        ps = tanCP(c1, r1, p);\n        qs = tanCP(c2, r2, p);\n        for(int i=0; i<(int)ps.size() && i<(int)qs.size(); i++){\n            line.clear(); line.push_back(ps[i]);line.push_back(qs[i]);\n            ans.push_back(line);\n        }\n    }\n    P p = (r2*c1 + r1*c2)/(r1+r2);\n    vector<P> ps, qs;\n    ps = tanCP(c1, r1, p);\n    qs = tanCP(c2, r2, p);\n    /*** ps[i] == qs[i] ÌÛÉÚüðÁèÅ«éæ¤Éµ½¢ ***/\n    for(int i=0; i<(int)ps.size() && i<(int)qs.size(); i++){\n        /*** ÈºÍèÉÇÁ ***/\n        if(abs(ps[i]-qs[i]) < EPS){\n            P dir = (c2 - c1)*polar((T)1/(abs(c2-c1)), (T)M_PI/2);\n            ps[i] += dir;\n            qs[i] -= dir;\n        }\n        /*** ±±ÜÅ ***/\n        line.clear(); line.push_back(ps[i]);line.push_back(qs[i]);\n        ans.push_back(line);\n    }\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ì¤ÊªÊÏ\ntemplate<typename T>\nT areaCC(P c1, T r1, P c2, T r2){\n    T d = abs(c1-c2);\n    if(r1+r2 < d+EPS) return 0;\n    if(d < abs(r1-r2) + EPS){\n        T r = min(r1, r2);\n        return r*r*M_PI;\n    }\n    T x = (d*d+r1*r1-r2*r2)/(2*d);\n    T t1 = acos(x/r1);\n    T t2 = cos((d-x)/r2);\n    return r1*r1*t1 + r2*r2*t2 - d*r1*sin(t1);\n}\n\n//Oð´_Æ·éB~(O,r1)ÆOp`(O,p1,p2)Ì¤ÊªÊÏ\ntemplate<typename T>\nT areaCT(T r, P p1, P p2){\n    T o(0, 0);\n    vector<P> qs = isCL(o, r, p1, p2);\n    if(qs.empty()) return r*r*arg(p1-p2)/2;\n    bool b1 = abs(p1) > r + EPS, b2 = abs(p2) > r + EPS;\n    if(b1 && b2){\n        if(iprod(p1-qs[0], p2-qs[0]) < EPS &&\n                iprod(p1-qs[1], p2-qs[1]) < EPS){\n            return (r*r*(arg(p1-p2)-arg(qs[0]-qs[1])) + oprod(qs[0], qs[1]))/2;\n        }else{\n            return r*r*arg(p1-p2)/2;\n        }\n    }else if(b1){\n        return (r*r*arg(p1-qs[0]) + oprod(qs[0], p2))/2;\n    }else if(b2){\n        return (r*r*arg(qs[1]-p2) + oprod(p1, qs[1]))/2;\n    }else{\n        return oprod(p1, p2) / 2;\n    }\n}\n\n\ntypedef long double ld;\n#define Point complex<ld>\n#define fs first\n#define sc second\n\nint main(){\n    int n;\n    vector<Point> ss;\n    while(cin>>n){\n        if(n==0) break;\n        ld x, y, r, m;\n        vector< pair< Point,ld > > cs;\n        for(int i=0; i<n; i++){\n            cin >> x >> y >> r >> m;\n            Point p(x,y);\n            cs.push_back(make_pair(p,r));\n            cs.push_back(make_pair(p,r+m));\n        }\n        if(n<=2){cout<<n<<endl; continue;}\n        int best=-1;\n        for(int i=0; i<n*2; i++){\n            for(int j=i+1; j<n*2; j++){\n                vector< vector< Point > > lines=tanCC(cs[i].fs, cs[i].sc, cs[j].fs, cs[j].sc);\n                for(int ii=0; ii<(int)lines.size(); ii++){\n                    int tmp = 0;\n                    for(int jj=0; jj<n; jj++){\n                        ld d = disLP(lines[ii][0],lines[ii][1],cs[2*jj].fs);\n                        if(d > cs[2*jj].sc - EPS && d < cs[2*jj+1].sc + EPS)\n                            tmp++;\n                    }\n                    if(tmp > best) best=tmp;\n                }\n            }\n        }\n        cout << best << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\n//2??????????????????\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\n//?????¨????????????????±???????\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return std::pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\nline tangent(const circle &c, const double &th) {\n    point h = c.o+polar(c.r,th);\n    point p = polar(c.r,th)*point(0,1);\n    return line(h-p,h+p);\n}\n\nvector<line> common_tangent(const circle &c, const circle &d) {\n    vector<line> res;\n    long double dist = abs(d.o - c.o), th = arg(d.o - c.o);\n    if (abs(c.r - d.r) < dist) { // outer\n        long double dth = acosl((c.r - d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    if (abs(c.r + d.r) < dist) {\n        long double dth = acos((c.r + d.r) / dist);\n        res.push_back(tangent(c, th - dth));\n        res.push_back(tangent(c, th + dth));\n    }\n    return res;\n}\n\nvoid solve(int n){\n    vector<circle> cs;\n    vector<long double> m(n);\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r >> m[i];\n        cs.push_back(circle(point(x,y),r));\n    }\n    rep(i,0,n) cs.push_back(circle(cs[i].o,cs[i].r+m[i]));\n\n    vector<line> ls;\n    rep(i,0,cs.size()) rep(j,i+1,cs.size()){\n        auto tmp=common_tangent(cs[i],cs[j]);\n        ls.insert(ls.end(),tmp.begin(),tmp.end());\n    }\n\n    int ans=1;\n    rep(i,0,ls.size()){\n        auto &l=ls[i];\n        int cnt=0;\n        rep(j,0,n){\n            auto &c=cs[j];\n            long double d=distanceLP(l,c.o)-c.r;\n            if(-eps<=d and d<=m[j]+eps) ++cnt;\n        }\n        ans=max(ans,cnt);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> PII;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r, m;\n\tC() {}\n\tC(P pp, D rr, D mm) : p(pp), r(rr), m(mm){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 点pから円cに引いた接点を求める\nvoid printL(L l);\n\nvector<P> tCP(C c, P p)\n{\n\tvector<P> res;\n\t\n\tD d = abs(c.p-p);\n\tif (sig(d, c.r)<0) return res;\n\t\n\tD rc = c.r*c.r/d;\n\tD rs = sqrt(c.r*c.r-rc*rc);\n\tP v = (p-c.p)/abs(p-c.p);\n\t\n\tres.push_back(c.p + v*rc + rs*v*P(0, 1));\n\tres.push_back(c.p + v*rc - rs*v*P(0, 1));\n\treturn res;\n}\n\n// ２つの円の共通接線を求める\nvector<L> tCCout(C a, C b) // 外接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (a.p - b.p)/d;\n\t\n\tif (sig(a.r, b.r)==0) {\n\t\tres.push_back(L(a.p+a.r*P(0, 1), b.p+b.r*v*P(0, 1)));\n\t\tres.push_back(L(a.p-a.r*P(0, 1), b.p-b.r*v*P(0, 1)));\n\t} else {\n\n\t\tD t = d*a.r/(b.r-a.r);\n\t\tP q = a.p + v*t;\n\n\t\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\t\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\t\tres.push_back(L(ta[i], tb[i]));\n\t}\n\treturn res;\n}\n\nvector<L> tCCin(C a, C b) // 内接線のみ\n{\n\tvector<L> res;\n\tD d = abs(b.p - a.p);\n\tP v = (b.p - a.p)/d;\n\tD t = d*a.r/(a.r+b.r);\n\t//P q = a.p + v*t;\n\tP q = (a.p*b.r + b.p*a.r)/(a.r+b.r);\n\t\n\tvector<P> ta = tCP(a, q), tb = tCP(b, q);\n\tfor (int i=0; i<min(ta.size(), tb.size()); i++)\n\t\tres.push_back(L(ta[i], tb[i]));\n\treturn res;\n}\n\nvector<L> tCC(C a, C b) // 全て\n{\n\tvector<L> res;\n\tfor (L l : tCCout(a, b)) res.push_back(l);\n\tfor (L l : tCCin(a, b)) res.push_back(l);\n\treturn res;\n}\n\n/** Problem2201 : Immortal Jewels **/\nint SCALE = 1;\n\nvoid printL(L l)\n{\n\tcout << \"line(\" << l.a.X*SCALE << \", \" << l.a.Y*SCALE << \", \" << l.b.X*SCALE << \", \" << l.b.Y*SCALE << \");\" << endl;\n}\n\nvoid printP(P p)\n{\n\tcerr << \"point(\" << p.X*SCALE << \", \" << p.Y*SCALE << \");\" << endl;\n}\n\nvoid printC(C c)\n{\n\tcerr << \"circle(\" << c.p.X*SCALE << \", \" << c.p.Y*SCALE << \", \" << c.r*SCALE << \");\" << endl;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<C> cs(N);\n\t\t\n\t\trep(i, N) {\n\t\t\tD x, y, r, m;\n\t\t\tcin>>x>>y>>r>>m;\n\t\t\tcs[i].p = P(x, y), cs[i].r = r, cs[i].m = m;\n\t\t}\n\t\t\n\t\tint ans = 1;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i==j) continue;\n\t\t\t\tC a = cs[i], b = cs[j];\n\t\t\t\trep(aa, 2) {\n\t\t\t\t\trep(bb, 2) {\n\t\t\t\t\t\ta.r += aa*a.m, b.r += bb*b.m;\n\t\t\t\t\t\tfor (L l : tCC(a, b)) {\n\t\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\t\tfor (C c : cs) {\n\t\t\t\t\t\t\t\tD d = abs(dLP(l, c.p));\n\t\t\t\t\t\t\t\tif (sig(c.r, d) <= 0 && sig(d, c.r+c.m) <= 0) tmp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble rts=r2*rs;\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+rts)*(r1+rts)+1e-9);\n\t\tdouble xf=r1*(xx*(r1+rts)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+rts)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(fabs(yf)>fabs(xf)||1){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v+y[i]);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  /*\n\t\t  cout<<xx*xx+yy*yy-(r1+r2)*(r1+r2)<<' '<<xf<<' '<<yf<<' ';\n\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  */\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    double x[50],y[50];\n    double r[50],m[50];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>m[i];\n    }\n    int mc=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<i;j++){\n\tdouble xx=x[j]-x[i];\n\tdouble yy=y[j]-y[i];\n\tfor(int k=0;k<2;k++){\n\t  double r1=k?r[i]+m[i]:r[i];\n\t  for(int l=0;l<2;l++){\n\t    double r2=l?r[j]+m[j]:r[j];\n\t    P p[2];\n\t    for(int s=-1;s<=1;s+=2){\n\t      for(int rs=-1;rs<=1;rs+=2){\n\t\tdouble is=sqrt(xx*xx+yy*yy-(r1+r2)*(r1+r2)+1e-9);\n\t\tdouble xf=r1*(xx*(r1+r2*rs)+s*yy*is)/(xx*xx+yy*yy);\n\t\tdouble yf=r1*(yy*(r1+r2*rs)-s*xx*is)/(xx*xx+yy*yy);\n\t\tfor(int v=0;v<2;v++){\n\t\t  if(fabs(yf)>fabs(xf)){\n\t\t    p[v]=P(v+x[i],(r1*r1-xf*v)/yf+y[i]);\n\t\t  }else{\n\t\t    p[v]=P((r1*r1-yf*v)/xf+x[i],v);\n\t\t  }\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t  P jw=P(x[i],y[i]);\n\t\t  double ds=fabs(cr(p[1]-p[0],jw-p[0]))/abs(p[1]-p[0]);\n\t\t  /*\n\t\t  cout<<xx*xx+yy*yy-(r1+r2)*(r1+r2)<<' '<<xf<<' '<<yf<<' ';\n\t\t  cout<<i<<':'<<r[i]<<' '<<ds<<' '<<r[i]+m[i]<<endl;\n\t\t  */\n\t\t  c+=r[i]-1e-5<ds&&ds<r[i]+m[i]+1e-5;\n\t\t}\n\t\tif(mc<c){\n\t\t  mc=c;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<(n>1?mc:1)<<endl;\n  }\n  return 0;\n}\n\t\t     \n\t    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#include<utility>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define mp make_pair\ntypedef complex<double> P;\n\nconst double EPS=1e-10;\n\nstruct C { P p; double r; C(const P& p, double r) : p(p), r(r) {} C(){} };\ndouble distanceLP(const pair<P,P> &l, const P& p) {\n\tP p1=l.first,p2=l.second;\n\tdouble a=p2.imag()-p1.imag(), b=p1.real()-p2.real();\n\tdouble c=p1.imag()*p2.real()-p1.real()*p2.imag();\n\treturn abs(a*p.real()+b*p.imag()+c)/sqrt(a*a+b*b);\n}\npair<P, P> tangentpoints(P p, P c, double r) {\n\tdouble d2 = norm(p-c);\n\tdouble x = sqrt(d2-r*r);\n\tif(x<EPS) return mp(p+(c-p)*P(0, 1), p-(c-p)*P(0, 1));\n\tP h(c+(p-c)*r*r/d2), w((p-c)*P(0, 1)*x*r/d2);\n\treturn mp(h+w, h-w);\n}\nvector<pair<P,P> > commonTangentLines(const C &c1,const C &c2)\n{\n\tvector<pair<P,P> > ret;\n\tP dir=c2.p-c1.p;\n\tif(abs(abs(dir)-c1.r-c2.r)<EPS)//ñ~ªÚ·é\n\t{\n\t\tP id=(c1.p*c2.r+c2.p*c1.r)/(c1.r+c2.r);\n\t\tret.pb(mp(id,id+dir*P(0,1))); ret.pb(mp(id,id-dir*P(0,1)));\n\t}\n\tif(c1.r+c2.r<abs(dir)+EPS)//£êÄ¢éiàÚüj\n\t{\n\t\tP id=(c1.p*c2.r+c2.p*c1.r)/(c1.r+c2.r);\n\t\tpair<P,P> TP=tangentpoints(id,c1.p,c1.r);\n\t\tret.pb(mp(TP.first,id)); ret.pb(mp(TP.second,id));\n\t}\n\tif(abs(c1.r-c2.r)<EPS)//¼a¯¶\n\t{\n\t\tP normal=dir*P(0,1)/abs(dir);\n\t\tret.pb(mp(c1.p+normal*c1.r,c2.p+normal*c2.r));\n\t\tret.pb(mp(c1.p-normal*c1.r,c2.p-normal*c2.r));\n\t}\n\telse//¼aá¤iOÚüj\n\t{\n\t\tP od=c1.p+dir*c1.r/(c1.r-c2.r);\n\t\tpair<P,P> TP=tangentpoints(od,c1.p,c1.r);\n\t\tret.pb(mp(TP.first,od)); ret.pb(mp(TP.second,od));\n\t}\n\treturn ret;\n}\n\nint n;\nC C[100];\n\nint main()\n{\n\twhile(cin>>n,n)\n\t{\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,y,r,m; cin>>x>>y>>r>>m;\n\t\t\tC[i*2].p=C[i*2+1].p=P(x,y);\n\t\t\tC[i*2].r=r; C[i*2+1].r=r+m;\n\t\t}\n\t\tint ans=1;\n\t\trep(i,2*n)rep(j,2*n)\n\t\t{\n\t\t\tvector<pair<P,P> > CTL=commonTangentLines(C[i],C[j]);\n\t\t\trep(k,CTL.size())\n\t\t\t{\n\t\t\t\tint cnt=0;\n\t\t\t\trep(l,2*n)\n\t\t\t\t{\n\t\t\t\t\tif(l%2==0&&distanceLP(CTL[k],C[l].p)+EPS<C[l].r)cnt--;\n\t\t\t\t\tif(l%2==1&&distanceLP(CTL[k],C[l].p)<C[l].r+EPS)cnt++;\n\t\t\t\t}\n\t\t\t\tans=max(ans,cnt);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator<(const P& a,const P& b) {\n    return abs(a.real()-b.real()<EPS)?a.imag()<b.imag():a.real()<b.real();\n  }\n};\n\nstruct Circle {\n  P c;\n  double r;\n  Circle( P c=P(0,0), double r=0 ):c(c),r(r){}\n};\n\ndouble dot( P a, P b ){ return a.real() * b.real() + a.imag() * b.imag(); }\n\nP rotate( P v, double rad ){\n  return v * P( cos(rad), sin(rad) );\n}\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n \nP reflect(P p, L l){\n  return p + (proj(p,l) - p) * 2.0;\n}\n \nvector<L> tangentCC( Circle p, Circle q ){\n  vector<L> ret;\n  if( p.r < q.r ) swap( p, q );\n  //外接線\n  P v = q.c - p.c;\n  //cout << p.c << \" - \" << q.c << \" \"<<  v << endl;\n  if( abs( abs(v) + q.r - p.r ) < EPS ) {//外接戦一つ\n    P p1 = p.c + v/abs(v) * ( abs(v) + q.r );\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L( p1, p2) );\n    return ret;\n  } else if( abs(v) + q.r < p.r ) return ret; //接戦無し \n  double z = sqrt( norm(v) - (p.r-q.r)*(p.r-q.r) );  \n  v = rotate( -v, acos(z/abs(v)) )/abs(v) * z + q.c - p.c;\n  v /= abs(v);\n  //cout << \"rotate: \" << v << endl;\n  L s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );\n  //内接線\n  v = q.c - p.c;\n  if( abs( abs(v) - p.r-q.r ) < EPS ){//内接線一つ\n    P p1 = p.c + v/abs(v) * p.r;\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L(p1,p2) );\n    return ret;\n  } else if( abs(v) - p.r-q.r < EPS ){//内接線なし\n    return ret;\n  }\n  P v1 = rotate( v, acos((p.r+q.r)/abs(v)) )/abs(v);\n  P p1 = p.c + v1 * p.r;\n  P p3 = reflect( p1, L(p.c,q.c) );\n  v1 = rotate( -v, acos((p.r+q.r)/abs(v)) )/abs(v);\n  P p2 = q.c + v1 * q.r;\n  P p4 = reflect( p2, L(p.c, q.c) ); \n  ret.push_back( L( p1,p2 ) );\n  ret.push_back( L( p3,p4 ) );\n  return ret;\n}\n\nint N;\n\nint main(){\n  while(cin >> N && N){\n    vector<Circle> C;\n    vector<Circle> M;\n    for(int i=0;i<N;i++){\n      int x,y,r,m;\n      cin >> x >> y >> r >> m;\n      C.push_back( Circle( P(x,y), r ) );\n      M.push_back( Circle( P(x,y), r+m ) );\n    }  \n\n\n    vector<L> line;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<L> nl = tangentCC( C[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( C[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n      }\n    }\n\n    if( N < 2 ) {\n      cout << N << endl;\n      continue;\n    }\n\n    int res = 0;\n    for(int i=0;i<(int)line.size();i++){\n      int cnt = 0;\n      //cout << line[i].first << \" - \" << line[i].second << endl;\n      for(int j=0;j<N;j++){\n        double x = abs(C[j].c - proj( C[j].c, line[i] ));        \n        //cout << j << \": \" << x << \"  \"<< C[j].r << \" \" << M[j].r << endl;\n        if( C[j].r < x+EPS && x < M[j].r+EPS ) cnt++;\n      }\n      res = max( res, cnt );\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//内積\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//外積\ndouble cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\n/* 直線abと点cの距離 */\ndouble distanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* Line ax+by+c=0 */\n\nstruct Line{\n  \n  P_type a,b,c;\n  \n  Line(P_type A,P_type B,P_type C){\n    a = A;\n    b = B;\n    c = C;\n  }\n  \n  //2点(x1,y1),(x2,y2)を通る直線\n  Line(P_type x1,P_type y1,P_type x2,P_type y2){\n    a = y1-y2;\n    b = x2-x1;\n    c = y1*(x1-x2)-x1*(y1-y2);\n  }\n  \n  /*以下はP_typeに係わらずdouble*/\n  \n  // y座標からx座標を取得\n  double x(double y){\n    return -(double)(b*y+c)/a;\n  }\n  \n  // x座標からy座標を取得\n  double y(double x){\n    return -(double)(a*x+c)/b;\n  }\n\n  double dist(P p){\n    return abs(a * p.real() + b * p.imag() + c) / sqrt(a*a + b*b);\n  }\n  \n};\n\nvector<Line> getCommonTangents(P c1, P_type r1, P c2, P_type r2) {\n  vector<Line> res;\n  c2 -= c1;\n\n  // 内包\n  if (abs(c2) + min(r1, r2) < max(r1, r2) - P_eps) return res;\n  \n  for (int i=-1;i<=1;i+=2) {\n    for(int j=-1;j<=1;j+=2){\n      P_type sr = r1 + r2 * i;\n      P_type p = sqrt(norm(c2) - sr * sr) * j;\n\n      P_type xq = r1 * (c2.real() * sr + c2.imag() * p) / norm(c2);\n      P_type yq = r1 * (c2.imag() * sr - c2.real() * p) / norm(c2);\n\n      res.push_back(Line(xq, yq, - r1*r1 - c1.real() * xq - c1.imag() * yq));\n    }\n    if (abs(c2) < (r1 + r2) - P_eps) break; //内接線無し\n  }\n\n  return res;\n}\n\nbool solve(){\n  int n;\n  int x[SIZE], y[SIZE], r[SIZE], m[SIZE];\n  vector<Line> lines;\n  \n  scanf(\"%d\", &n);\n\n  if (n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d\", x+i, y+i, r+i, m+i);\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=1;j<n;j++){\n      for(int k=0;k<4;k++){\n        auto res = getCommonTangents(P(x[i], y[i]), r[i] + m[i] * (k/2), P(x[j],y[j]), r[j] + m[j] * (k%2));\n        lines.insert(lines.end(), res.begin(), res.end());\n      }\n    }\n  }\n\n  int ans = 1;\n  \n  for(int i=0;i<lines.size();i++){\n    int counter = 0;\n    for(int j=0;j<n;j++){\n      double d = lines[i].dist(P(x[j], y[j]));\n      counter += r[j] - P_eps < d && d < r[j] + m[j] + P_eps;\n    }\n    ans = max(ans, counter);\n  }\n  \n  printf(\"%d\\n\", ans);\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//#define EPS 0.0001\n\nenum Type{\n\tSmall,\n\tLarge,\n};\n\nstruct Point{\n    Point(double arg_x,double arg_y){\n        x = arg_x;\n        y = arg_y;\n    }\n\n    Point(){\n        x = y = 0.0;\n    }\n\n    Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x,y-p.y);}\n    Point operator * (double a){ return Point(a*x,a*y); }\n    Point operator / (double a){ return Point(x/a,y/a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x*x + y*y; }\n\n    bool operator<(const Point &p) const{\n        return x != p.x? x < p.x: y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n\n    double x,y;\n};\n\ntypedef Point Vector;\n\nstruct Sphere{\n    Point center;\n    double r,power;\n};\n\ntypedef Sphere Circle;\n\nstruct Line{\npublic:\n    Point p[2];\n    Line(Point p1,Point p2){\n        p[0] = p1;\n        p[1] = p2;\n    }\n    Line(){\n\n    }\n};\n\nint N;\ndouble NUM = 10000;\nCircle circle[55][2];\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\nPoint project(Line l,Point p){\n\n    Vector base = l.p[1]-l.p[0];\n    double r = dot(p-l.p[0],base)/norm(base);\n    return l.p[0]+base*r;\n}\n\n//円と直線の交点を求める関数\nvector<Point> getCrossPoints(Circle c,Line l){\n\n    vector<Point> ret;\n\n    Vector pr = project(l,c.center);\n    Vector e = (l.p[1]-l.p[0])/abs(l.p[1]-l.p[0]);\n\n    double base;\n\n    if(fabs(c.r*c.r-norm(pr-c.center)) < EPS){\n\n        base = 0;\n    }else{\n        base = sqrt(c.r*c.r-norm(pr-c.center));\n    }\n\n    ret.push_back(Point(pr+e*base));\n    ret.push_back(Point(pr-e*base));\n\n    return ret;\n}\n\nvector<Point> getContact(Circle circle,Point point){\n\n    double k = circle.center.x - point.x;\n    double X = point.y - circle.center.y;\n\n    double A = k*k - circle.r*circle.r;\n\n    if(fabs(A) < EPS){\n\n        double slope = (circle.r*circle.r-X*X)/(2*k*X);\n\n        if(fabs(slope) < EPS){\n\n            vector<Point> ret;\n\n            ret.push_back(Point(point.x,sqrt(circle.r*circle.r-(point.x-circle.center.x)*(point.x-circle.center.x))+circle.center.y));\n            ret.push_back(Point(sqrt(circle.r*circle.r-(point.y-circle.center.y)*(point.y-circle.center.y))+circle.center.x,point.y));\n\n            return ret;\n        }\n\n        Line line;\n\n        line.p[0] = point;\n        line.p[1] = Point(point.x+NUM,point.y+NUM*slope);\n\n        return getCrossPoints(circle,line);\n    }\n\n    double B = 2*k*X;\n    double C = X*X - circle.r*circle.r;\n\n    double slope_1 = (-B+sqrt(B*B-4*A*C))/(2*A);\n    double slope_2 = (-B-sqrt(B*B-4*A*C))/(2*A);\n\n    Line line_1,line_2;\n\n    line_1.p[0] = point;\n    line_1.p[1] = Point(point.x+NUM,point.y+NUM*slope_1);\n    vector<Point> ret_1 = getCrossPoints(circle,line_1);\n\n    line_2.p[0] = point;\n    line_2.p[1] = Point(point.x+NUM,point.y+NUM*slope_2);\n\n    vector<Point> ret_2 = getCrossPoints(circle,line_2);\n\n    vector<Point> ret;\n\n    ret.push_back(ret_1[0]);\n    ret.push_back(ret_2[0]);\n\n    return ret;\n}\n\n\nvector<Line> getCommonTangent(Circle C1,Circle C2){\n\n\tvector<Point> POINT;\n\tvector<Line> ret;\n\n\n\tdouble p = C2.center.x-C1.center.x;\n\tdouble q = C2.center.y-C1.center.y;\n\n\tdouble A = p*p+q*q;\n\n\tdouble n_1 = (q*C1.r*(C1.r+C2.r)-p*C1.r*sqrt(A-(C1.r+C2.r)*(C1.r+C2.r)))/(A)+C1.center.y;\n\tdouble n_2 = (q*C1.r*(C1.r+C2.r)+p*C1.r*sqrt(A-(C1.r+C2.r)*(C1.r+C2.r)))/(A)+C1.center.y;\n\n\tdouble m_1 = (p*C1.r*(C1.r+C2.r)+q*C1.r*sqrt(A-(C1.r+C2.r)*(C1.r+C2.r)))/(A)+C1.center.x;\n\tdouble m_2 = (p*C1.r*(C1.r+C2.r)-q*C1.r*sqrt(A-(C1.r+C2.r)*(C1.r+C2.r)))/(A)+C1.center.x;\n\n\tif(A-(C1.r+C2.r)*(C1.r+C2.r) >= 0){\n\t\tPOINT.push_back(Point(m_1,n_1));\n\t\tPOINT.push_back(Point(m_2,n_2));\n\n\t\tfor(int i = 0; i < 2; i++){\n\n\t\t\tPoint another = getContact(C2,POINT[i])[0];\n\t\t\tret.push_back(Line(POINT[i],another));\n\n\t\t\tanother = getContact(C2,POINT[i])[1];\n\t\t\tret.push_back(Line(POINT[i],another));\n\t\t}\n\n\t\tPOINT.clear();\n\t}\n\n\tdouble n_3 = (q*C1.r*(C1.r-C2.r)-p*C1.r*sqrt(A-(C1.r-C2.r)*(C1.r-C2.r)))/(A)+C1.center.y;\n\tdouble n_4 = (q*C1.r*(C1.r-C2.r)+p*C1.r*sqrt(A-(C1.r-C2.r)*(C1.r-C2.r)))/(A)+C1.center.y;\n\n\tdouble m_3 = (p*C1.r*(C1.r-C2.r)+q*C1.r*sqrt(A-(C1.r-C2.r)*(C1.r-C2.r)))/(A)+C1.center.x;\n\tdouble m_4 = (p*C1.r*(C1.r-C2.r)-q*C1.r*sqrt(A-(C1.r-C2.r)*(C1.r-C2.r)))/(A)+C1.center.x;\n\n\tif(A-(C1.r-C2.r)*(C1.r-C2.r) >= 0){\n\t\tPOINT.push_back(Point(m_3,n_3));\n\t\tPOINT.push_back(Point(m_4,n_4));\n\n\t\tfor(int i = 0; i < 2; i++){\n\n\t\t\tPoint another = getContact(C2,POINT[i])[0];\n\t\t\tret.push_back(Line(POINT[i],another));\n\n\t\t\tanother = getContact(C2,POINT[i])[1];\n\t\t\tret.push_back(Line(POINT[i],another));\n\t\t}\n\n\t\tPOINT.clear();\n\t}\n\treturn ret;\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf %lf %lf\",&circle[i][Small].center.x,&circle[i][Small].center.y,&circle[i][Small].r,&circle[i][Small].power);\n\n\t\tcircle[i][Large].center = circle[i][Small].center;\n\t\tcircle[i][Large].r = circle[i][Small].r+circle[i][Small].power; //磁力の大きさを加えた場合\n\t}\n\n\tif(N == 1){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\n\tvector<Line> LINE;\n\tvector<Line> tmp_line;\n\n\tType type[2] = {Small,Large};\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(k == i)continue;\n\n\t\t\tfor(int a = 0; a < 2; a++){\n\t\t\t\tfor(int b = 0; b < 2; b++){\n\n\t\t\t\t\ttmp_line = getCommonTangent(circle[i][type[a]],circle[k][type[b]]);\n\n\t\t\t\t\tif(tmp_line.size() == 0)continue;\n\n\t\t\t\t\tfor(int c = 0; c < tmp_line.size(); c++){\n\t\t\t\t\t\tLINE.push_back(tmp_line[c]);\n\t\t\t\t\t}\n\t\t\t\t\ttmp_line.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < LINE.size(); i++){\n\t\tint count = 0;\n\n\t\tfor(int a = 0; a < N; a++){\n\n\t\t\tdouble tmp_dist = getDistanceLP(LINE[i],circle[a][Small].center)-circle[a][Small].r;\n\n\t\t\tif(EPS+tmp_dist >= 0 && tmp_dist <= circle[a][Small].power+EPS){\n\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t}\n\t\tans = max(ans,count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\n\n\nint main(void){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<circle> cs;\n\t\trep(i,n){\n\t\t\tdouble x,y,r,m;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x,&y,&r,&m); x+=10; y+=10;\n\t\t\tcs.push_back(circle(pos(x,y),r));\n\t\t\tcs.push_back(circle(pos(x,y),r+m));\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\trep(i,2*n){\n\t\t\trep(j,i){\n\t\t\t\tvector<line> ls=cs[i].tangs(cs[j]);\n\t\t\t\trep(k,ls.size()){\n\t\t\t\t\t//inithtml();\n\t\t\t\t\tline e=ls[k];\n\t\t\t\t\te = line(e.p+e.vec.tolen(-3000),e.p+e.vec.tolen(3000));\n\t\t\t\t\t//e.outh(10);\n\t\t\t\t\t\n\t\t\t\t\tint na=0;\n\t\t\t\t\trep(p,n){\n\t\t\t\t\t\tcs[p*2].outh(10);\n\t\t\t\t\t\tcs[p*2+1].outh(10);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdouble d=e.dist(cs[p*2].p);\n\t\t\t\t\t\tif(d+1e-6<cs[p*2].r)continue;\n\t\t\t\t\t\tif(cs[p*2+1].r+1e-6<d)continue;\n\t\t\t\t\t\tna++;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,na);\n\t\t\t\t\t//printf(\"na %d %d %d %s %d\\n\",i,j,k,e.str().c_str(),na);\n\t\t\t\t\t/*\n\t\t\t\t\tchar buf[20];\n\t\t\t\t\tsprintf(buf,\"o_%d_%d_%d\",i,j,k);\n\t\t\t\t\touthtml(buf,10);\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}//直線abと円及び球 |x-c|=rの交差判定\nbool interpoint_lc(P a, P b, P c, double r,int sign){\n    if(distance_l_p(a , b,c) > r + sign*EPS) return false;\n    return true;\n}\n\n//円(x0,y0,r0)と円(x1,y1,r1)の共通接線の接点\nvoid tangency(P pos0,double r0, P pos1, double r1, pair<P, P> out[4])\n{\n\tdouble x0=pos0.real(),y0=pos0.imag();\n\tdouble x1=pos1.real(),y1=pos1.imag();\n\tconst P v(x1 - x0, y1 - y0);\n\tconst double a0 = arg(v);\n\tconst double a1 = acos((r0 - r1) / abs(v));\n\tout[0] = make_pair(P(x0 + r0 * cos(a0 + a1), y0 + r0 * sin(a0 + a1)), P(x1 + r1 * cos(a0 + a1), y1 + r1 * sin(a0 + a1)));\n\tout[1] = make_pair(P(x0 + r0 * cos(a0 - a1), y0 + r0 * sin(a0 - a1)), P(x1 + r1 * cos(a0 - a1), y1 + r1 * sin(a0 - a1)));\n\tconst double a2 = acos((r0 + r1) / abs(v));\n\tout[2] = make_pair(P(x0 + r0 * cos(a0 + a2), y0 + r0 * sin(a0 + a2)), P(x1 + r1 * cos(a0 + a2 + PI), y1 + r1 * sin(a0 + a2 + PI)));\n\tout[3] = make_pair(P(x0 + r0 * cos(a0 - a2), y0 + r0 * sin(a0 - a2)), P(x1 + r1 * cos(a0 - a2 + PI), y1 + r1 * sin(a0 - a2 + PI)));\n}\nstruct gem{\n\tint r,m;\n\tP pos;\n};\nint go(vector<gem> &gems,P from,P to){\n\tint ans=0;\n\tREP(i,gems.size()){\n\t\tif(!interpoint_lc(from,to,gems[i].pos,gems[i].r,-1)){\n\t\t\tif(interpoint_lc(from,to,gems[i].pos,gems[i].r+gems[i].m,1)){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<gem> gems(n);\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y>>gems[i].r>>gems[i].m;\n\t\t\tgems[i].pos=P(x,y);\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<pair<P,P> > points;\n\t\tREP(i,n){\n\t\t\tFOR(j,i+1,n){\n\t\t\t\tpair<P,P> ps[4];\n\t\t\t\ttangency(gems[i].pos,gems[i].r,gems[j].pos,gems[j].r,ps);\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpoints.push_back(ps[k]);\n\t\t\t\t}\n\t\t\t\ttangency(gems[i].pos,gems[i].r+gems[i].m,gems[j].pos,gems[j].r+gems[j].m,ps);\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpoints.push_back(ps[k]);\n\t\t\t\t}\n\t\t\t\ttangency(gems[i].pos,gems[i].r,gems[j].pos,gems[j].r+gems[j].m,ps);\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpoints.push_back(ps[k]);\n\t\t\t\t}\n\t\t\t\ttangency(gems[i].pos,gems[i].r+gems[i].m,gems[j].pos,gems[j].r,ps);\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpoints.push_back(ps[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,points.size()){\n\t\t\tint a=go(gems,points[i].first,points[i].second);\n\t\t\tans=max(ans,a);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\n#define sc second\n#define fr first\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nstruct circle{\n  point c;\n  elem r;\n  circle():c(point(0,0)),r(0){}\n  circle(point c, elem r):c(c),r(r){}\n  bool incircle(point t){\n    return leq( abs(t-c), r);\n  }\n};\n\n// ð_ÆÊuÖWÖÌiÖ\nelem circles_k(circle c1, circle c2){\n  elem d = abs(c1.c-c2.c);\n  return ( sq( c1.r ) - sq( c2.r ) + sq( d ) ) / ( 2 * sq( d ) );\n}\nelem circles_x(circle c1, circle c2){\n  elem d = abs(c1.c-c2.c);\n  elem k = circles_k(c1,c2);\n  elem x = sqrt( sq(c1.r) - sq( d * k ) );\n  return x;\n}\n\n// 2~ÌÊuÖW\nint circles_relation(circle c1, circle c2){\n  if(lt(c1.r,c2.r))swap(c1,c2);\n  elem d=abs(c1.c-c2.c);\n  if(near(c1.c,c2.c)&&eq(c1.r,c2.r))return CIRCLE_SAME;\n  if((c1.incircle(c2.c))&&lt(d+c2.r,c1.r))return CIRCLE_CONTAIN;\n  if(gt(d,c1.r+c2.r))return CIRCLE_NO_CROSS;\n  elem x = circles_x( c1, c2 );\n  if( eq( x, 0 ) ){\n    if(c1.incircle(c2.c))return CIRCLE_ONE_INSIDE_CROSS;\n    return CIRCLE_ONE_CROSS;\n  }else CIRCLE_TWO_CROSS;\n}\n\n// CÓÌñÂÌ~Ìð_\nint intersection_circles(circle c1, circle c2, pp &p)\n{\n  if( !( circles_relation( c1, c2 ) & (CIRCLE_ONE_INSIDE_CROSS | CIRCLE_ONE_CROSS | CIRCLE_TWO_CROSS) ) )\n    return 0;\n\n  vec ab = c2.c - c1.c;\n  elem k = circles_k( c1, c2 );\n  point t = k * ab + c1.c;\n  elem x = circles_x( c1, c2 );\n  \n  if( eq( x, 0 ) ){\n    /* ð_ðêÂ¾¯Â */\n    p.first = t; return 1;\n  }else{\n    /* ð_ðñÂÂ */\n    vec abr = unmr( ab ); vec abl = unml( ab );\n    vec vp1 = x * abr; vec vp2 = x * abl;\n    p.first = vp1 + t; p.second = vp2 + t;\n    return 2;\n  }\n}\n// ñ~Ì¤ÊÚü(4{ÌÝ)\nint circles_tangential( circle c1, circle c2, vector<line> &ret ){\n  pair<point,point> pcross;\n  elem r1 = c1.r;\n  elem r2 = c2.r;\n  elem D = abs(c2.c-c1.c);\n\n  int rel = circles_relation( c1, c2 );\n  intersection_circles(c1,c2,pcross);\n  if( rel & ( CIRCLE_SAME | CIRCLE_CONTAIN ) ) return 0;\n  if( rel & ( CIRCLE_ONE_INSIDE_CROSS ) ){\n    point p=pcross.first;\n    cout << \" P : \" << p << endl;\n    vec v = p-c1.c;\n    ret.push_back( line(p,p+unmr(v)) );\n    return 1;\n  }\n  elem theta0 = varg(c2.c-c1.c,vec(1,0));\n  point S2(D*(r1/(r1+r2)),0);\n  elem theta1 = asin( (r2-r1)/D );\n  elem theta2 = asin( (r1+r2)/D );\n  point S1_1(rot(point(0,r1),theta1));\n  point S1_2(rot(point(0,r1),-theta1-pi));\n  vec u(1,0);\n  S1_1 = rot(S1_1,theta0) + c1.c;\n  S1_2 = rot(S1_2,theta0) + c1.c;\n  S2 = rot(S2,theta0) + c1.c;\n  // OÚü\n  ret.push_back( line(S1_1, S1_1 + rot(u,theta0+theta1) ) );\n  ret.push_back( line(S1_2, S1_2 + rot(u,theta0-theta1) ) );\n  if( rel == CIRCLE_TWO_CROSS ) return 2;\n  // àÚü\n  ret.push_back( line(S2, S2 + rot(u,theta0+theta2) ) );\n  if( rel == CIRCLE_ONE_CROSS ) return 3;\n  ret.push_back( line(S2, S2 + rot(u,theta0-theta2) ) );\n  return 4;\n}\n\nint main(){\n  while(true){\n    int n;\n    int ans = 0;\n    cin >> n;\n    if(n==0)break;\n    vector<circle> jewels;\n    vector<elem> jewels_m;\n    vector<circle> circles;\n    for(int i = 0; i < n; ++i){\n      elem x, y, r, m;\n      cin >> x >> y >> r >> m;\n      circles.push_back(circle(point(x,y),r));\n      circles.push_back(circle(point(x,y),m+r));\n      jewels.push_back(circle(point(x,y),r));\n      jewels_m.push_back(m+r);\n    }\n\n    for(int i = 0; i < (int)circles.size(); ++i){\n      for(int j = i+2; j < (int)circles.size(); ++j){\n\tif( j - i <= 1 )continue;\n\tvector<line> vl;\n\tcircles_tangential( circles[i], circles[j], vl );\n\tfor(int k = 0; k < vl.size(); ++k){\n\t  line l = vl[k];\n\t  int cnt = 0;\n\t  //cout << \" LINE : \" << vl[k] << endl;\n\t  for(int m = 0; m < jewels.size(); ++m){\n\t    elem d = dist_l(l,jewels[m].c);\n\t    if(leq(d,jewels_m[m])&&geq(d,jewels[m].r))++cnt;\n\t  }\n\t  ans = max(ans,cnt);\n\t}\n\t//cout << endl;\n      }\n    }\n    if(n==1)ans=1;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,e,d;\n\t\t\tcin>>a>>b>>e>>d;\n\t\t\tc.pb(C(P(a,b),e));\n\t\t\tc.pb(C(P(a,b),e+d));\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<L>l,tmp;\n\t\trep(i,c.size())loop(j,i+1,c.size()){\n\t\t\ttmp=tangentCC(c[i],c[j]);\n\t\t\trep(k,tmp.size()){\n\t\t\t\tl.pb(tmp[k]);\n\t\t\t}\n\t\t}\n\t\tint out=0;\n\t\trep(i,l.size()){\n\t\t\tL t=l[i];\n\t\t\tint co=0;\n\t\t\trep(j,c.size()){\n\t\t\t\tdouble d=distanceLP(t,c[j].c);\n\t\t\t\tif(d+EPS>c[j].r&&d<c[j+1].r+EPS)co++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tout=max(out,co);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef complex<double> C;\ndouble dot(C a, C b)\n{\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\nconst double eps=1e-16;\nint N;\nC ps[500];\ndouble rs[500][2];\nint ret=1;\nvoid exec4(C v, double c)\n{\n\tint cnt=0;\n\tfor(int i=0;i<N;i++){\n\t\tdouble w=abs(dot(ps[i],v)-c);\n\t\tif (rs[i][0]-eps<=w&&w<=rs[i][1]+eps)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\t/*\n\tif (cnt < 2){\n\t\tcout << cnt << \", \" << v << \", \" << c << endl;\n\t}*/\n\tret=max(cnt,ret);\n}\n\nvoid solve(double a, double b, double c, C ans[2])\n{\n\tbool sw=false;\n\tif (b==0){\n\t\tswap(a,b);\n\t\tsw=true;\n\t}\n\n\tdouble s=-a/b;\n\tdouble t=c/b;\n\tdouble p=1+s*s;\n\tdouble q=2*s*t;\n\tdouble r=t*t-1;\n\t/*\n\tif (q*q-4*p*r<0){\n\t\tcout << \"aaa \" << endl;\n\t}*/\n\tdouble x0=(-q-sqrt(q*q-4*p*r))/(2*p);\n\tdouble y0=s*x0+t;\n\tdouble x1=(-q+sqrt(q*q-4*p*r))/(2*p);\n\tdouble y1=s*x1+t;\n\tif(!sw){\n\t\tans[0]=C(x0,y0);\n\t\tans[1]=C(x1,y1);\n\t}\n\telse\n\t{\n\t\tans[0]=C(y0,x0);\n\t\tans[1]=C(y1,x1);\n\t}\n}\nvoid exec3(C q, C p, double r)\n{\n\tif (abs(q-p)<r-eps){\n\t\treturn;\n\t}\n\n\tC v[2];\n\tint cnt;\n\tif (abs(q-p)<=r){\n\t\tv[0]=(q-p)/abs(q-p);\n\t\tcnt=1;\n\t}\n\telse\n\t{\n\t\tsolve(real(p-q),imag(p-q),r,v);\n\t\tcnt=2;\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tdouble c=dot(v[i],q);\n\t\texec4(v[i],c);\n\t}\n}\nvoid exec2(C p1, double r1, C p2, double r2)\n{\n\tif (r1>r2){\n\t\tswap(p1,p2);\n\t\tswap(r1,r2);\n\t}\n\n\tC q=r1/(r1+r2)*p2+r2/(r1+r2)*p2;\n\texec3(q,p1,r1);\n\n\tif(r1!=r2){\n\t\tq=r2/(r2-r1)*p1-r1/(r2-r1)*p2;\n\t\texec3(q,p1,r1);\n\t}\n\telse\n\t{\n\t\tC v=(p2-p1)/abs(p2-p1)*C(0,1)*r1;\n\t\texec3(p1+v,p1,r1);\n\t\texec3(p1-v,p1,r1);\n\t}\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0){\n\t\texit(0);\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tcin >> x >> y >> rs[i][0] >> rs[i][1];\n\t\trs[i][1]+=rs[i][0];\n\t\tps[i]=C(x,y);\n\t}\n\n\tret=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tfor(int s=0;s<2;s++){\n\t\t\t\tfor(int t=0;t<2;t++){\n\t\t\t\t\texec2(ps[i],rs[i][s],ps[j],rs[j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nint main() {\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 : \n\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)), \n\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b))); }\n\n// a から ta, bから tb だけ離れた点。ta=tb=r なら aとbに内接する円\ninline pair<pair<P2, P2>, pair<P2, P2>> get_distance_points(Line a, double ta, Line b, double tb)\n{\n\tassert(isCross(a, b));\n\n\tP2 va = a.d.orthogonal().direction() * ta;\n\tP2 vb = b.d.orthogonal().direction() * tb;\n\treturn make_pair(\n\t\tmake_pair(\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p + va, a.d), Line(b.p - vb, b.d))\n\t\t), make_pair(\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p + vb, b.d)),\n\t\t\tcrossPoint(Line(a.p - va, a.d), Line(b.p - vb, b.d))\n\t\t));\n}\n\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\n// 2円の接線を求める。\nvector<Line> getTangentialLine(Circle a, Circle b)\n{\n\tvector<Line> ret;\n\tP2 v = b.c - a.c;\n\tdouble d = v.length();\n\tdouble bt = v.arg();\n\n\tif (d - abs(a.r - b.r) > EPS) // 外接線2本\n\t{\n\t\tdouble dt = acos((a.r - b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c + P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c + P2::polar(b.r, t2)));\n\t}\n\telse if (d - abs(a.r - b.r) > -EPS) // 外接線1本 (内接)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\tif (d - (a.r + b.r) > EPS) // 内接線2本 (離れている)\n\t{\n\t\tdouble dt = acos((a.r + b.r) / d);\n\t\tdouble t1 = bt - dt, t2 = bt + dt;\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t1), b.c - P2::polar(b.r, t1)));\n\t\tret.push_back(Line::From2Point(a.c + P2::polar(a.r, t2), b.c - P2::polar(b.r, t2)));\n\t}\n\telse if (d - (a.r + b.r) > -EPS) // 内接線1本 (接している)\n\t{\n\t\tret.push_back(Line(a.c + v.direction() * a.r, v.orthogonal()));\n\t}\n\n\treturn ret;\n}\n\n\n/// 長方形\nstruct Rect\n{\n\tP2 l, s;\n\tRect() : l(), s() { }\n\tRect(double x, double y, double w, double h) : l(x, y), s(w, h) { }\n\tRect(P2 location, P2 size) : l(location), s(size) { }\n\tbool Contains(const P2 &p) const { return p.x - l.x > -EPS && p.y - l.y > -EPS && p.x - (l.x + s.x) < EPS && p.y - (l.y + s.y) < EPS; } // 接してても真。\n};\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n#define M_PI       3.14159265358979323846\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct xyrm{ P2 p; double r, m; int i; };\n\t\tvector<xyrm> gems;\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(int, x, y, r, m);\n\t\t\tgems.push_back({ P2(x, y), r, m, _ });\n\t\t}\n\t\tint result = 1;\n\t\tfor (auto i : gems) for (auto j : gems)\n\t\t{\n\t\t\t//WRITE(\"i:\", i.i, \"j:\", j.i);\n\t\t\tauto cand = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r));\n\t\t\tauto cand2 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r));\n\t\t\tauto cand3 = getTangentialLine(Circle(i.p, i.r), Circle(j.p, j.r + j.m));\n\t\t\tauto cand4 = getTangentialLine(Circle(i.p, i.r + i.m), Circle(j.p, j.r + j.m));\n\n\t\t\tvector<Line> lines;\n\t\t\tcopy(allof(cand), back_inserter(lines));\n\t\t\tcopy(allof(cand2), back_inserter(lines));\n\t\t\tcopy(allof(cand3), back_inserter(lines));\n\t\t\tcopy(allof(cand4), back_inserter(lines));\n\n\t\t\tfor (auto l : lines)\n\t\t\t{\n\t\t\t\t//WRITE(l.p, l.d);\n\t\t\t\tresult = max<int>(result, count_if(allof(gems), PREDICATE(xyrm, g, inRange(getDistance(l, g.p), g.r, g.r + g.m))));\n\t\t\t}\n\t\t}\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tB operator<(const P& l, const P& r) { return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\t//Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n\n\t//A dot B\n\tIL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n\tIL int sgn(P a, P b, P c) {\n\t\tif (cross(b - a, c - a) > EPS)return 1;\n\t\tif (cross(b - a, c - a) < -EPS)return -1;\n\t\tif (dot(b - a, c - a) < -EPS)return 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)return -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l) {\n\t\tDCl(a, b, l);\n\t\treturn cross(b - a, p - a) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) {\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) {\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS) return abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS) return abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\n\tIL B is_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn\n\t\t\tabs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls) {\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn cross(a - b, c - b) * cross(a - b, d - b) <EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q) {\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t\t\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q) {\n\t\tif (is_LS_LS(p, q))return 0;\n\t\treturn min({\n\t\t\tdistance_P_LS(p.fi,q),\n\t\t\tdistance_P_LS(p.se,q),\n\t\t\tdistance_P_LS(q.fi,p),\n\t\t\tdistance_P_LS(q.se,p)\n\t\t});\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_point_L_L(L p, L q) {\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d <EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q) {\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tD rs = sqrt(rp*rp - rc*rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn{ cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff };\n\t}\n\tIL D ccw(P a, P b, P c) {\n\t\treturn cross(b - a, c - a);\n\t}\n\tIL Poly convex_hull(Poly& p) {\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(ALL(p));\n\t\tREP(i, n) {\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tREP(j, n - 1) {\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly& l, P& p) {\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1) {\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0) {\n\t\t\t\tif (A > -EPS&&C < -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (C < -EPS || A > -EPS)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n\t}\n\tIL D convex_area(Poly& l) {\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\tFOR(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tinline vector<L> tangent_line(C c, P p) {\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist > r + EPS) {\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos*_cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\t{\n\t\t\t\tP e = P(_cos*v.X + _sin*v.Y, -_sin*v.X + _cos*v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist > Rp + Rq + EPS) {\n\t\t\tP mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q) {\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist > Rp - Rq + EPS) {\n\t\t\tif (abs(Rp - Rq) < EPS) {\n\t\t\t\tP e = v*P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nIL int check(geo::L l, vector<geo::C>& cd, vector<geo::C>& cm) {\n\tint res = 0;\n\tint n = (int)cd.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble d = geo::distance_P_L(cd[i].first, l);\n\t\t//  cout << d << \" \";\n\t\tif (d<cm[i].second + geo::EPS&&d>cd[i].second - geo::EPS)\n\t\t\tres++;\n\t}\n\t//cout << endl;\n\treturn res;\n\n\n}\nint main() {\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\n\t\tvector<geo::C> cd(N);\n\t\tvector<geo::C> cm(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble x, y, d, m;\n\t\t\tcin >> x >> y >> d >> m;\n\t\t\tcd[i].first = geo::P(x, y);\n\t\t\tcm[i].first = geo::P(x, y);\n\t\t\tcd[i].second = d;\n\t\t\tcm[i].second = d + m;\n\t\t}\n\t\tif (N == 1) {\n\t\t\tif (cm[0].second < geo::EPS)cout << 0 << endl;\n\t\t\telse cout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\t//cout << i << j << endl << endl;\n\t\t\t\t\t//cout << \"inner1\" << endl;\n\t\t\t\t\tauto p1 = geo::inner_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : p1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner2\" << endl;\n\t\t\t\t\tauto p2 = geo::inner_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"inner3\" << endl;\n\t\t\t\t\tauto p3 = geo::inner_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : p3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer1\" << endl;\n\t\t\t\t\tauto q1 = geo::outer_common_tangent_line(cd[i], cd[j]);\n\t\t\t\t\tfor (auto& it : q1) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer2\" << endl;\n\t\t\t\t\tauto q2 = geo::outer_common_tangent_line(cd[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q2) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\t\t\t\t\t//  cout << \"outer3\" << endl;\n\t\t\t\t\tauto q3 = geo::outer_common_tangent_line(cm[i], cm[j]);\n\t\t\t\t\tfor (auto& it : q3) {\n\t\t\t\t\t\tres = max(check(it, cd, cm), res);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t//cin.close();  cout.close();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nstruct Circle {\n  P c;\n  double r;\n  Circle( P c=P(0,0), double r=0 ):c(c),r(r){}\n};\n\nconst double EPS = 1e-8;\n\ndouble dot( P a, P b ){ return a.real() * b.real() + a.imag() * b.imag(); }\n\nP rotate( P v, double rad ){\n  return v * P( cos(rad), sin(rad) );\n}\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n \nP reflect(P p, L l){\n  return p + (proj(p,l) - p) * 2.0;\n}\n \nvector<L> tangentCC( Circle p, Circle q ){\n  vector<L> ret;\n  if( p.r < q.r ) swap( p.r, q.r );\n  //内接線\n  P v = q.c - p.c;\n  // cout << p.c << \" - \" << q.c << \" \"<<  v << endl;\n  if( abs( abs(v) + q.r - p.r ) < EPS ) {//内接戦一つ\n    P p1 = p.c + v/abs(v) * ( abs(v) + q.r );\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L( p1, p2) );\n    return ret;\n  } else if( abs(v) + q.r < p.r ) return ret; //接戦無し \n  v = rotate( v, abs(p.r-q.r)<EPS?M_PI/2:asin( abs(p.r-q.r) / abs(v) ) ) / abs(v);\n  L s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );\n  //外接線\n  v = q.c - p.c;\n  if( abs( abs(v) - p.r-q.r ) < EPS ){//外接線一つ\n    P p1 = p.c + v/abs(v) * p.r;\n    P p2 = p1 + rotate( v, M_PI/2.0 );\n    ret.push_back( L(p1,p2) );\n    return ret;\n  } else if( abs(v) - p.r-q.r < EPS ){//外接線なし\n    return ret;\n  }\n  v = rotate( v, asin( (p.r+q.r) / abs(v) ) ) / abs(v);\n  s = L( p.c + v * p.r , q.c + v * q.r );\n  ret.push_back( s );\n  s = L( reflect( s.first, L(p.c,q.c) ), reflect( s.second, L(p.c,q.c) ) );\n  ret.push_back( s );  \n  return ret;\n}\n\nint N;\n\nint main(){\n  while(cin >> N && N){\n    vector<Circle> C;\n    vector<Circle> M;\n    for(int i=0;i<N;i++){\n      int x,y,r,m;\n      cin >> x >> y >> r >> m;\n      C.push_back( Circle( P(x,y), r ) );\n      M.push_back( Circle( P(x,y), r+m ) );\n    }  \n\n\n    vector<L> line;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<L> nl = tangentCC( C[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( C[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], C[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n        nl = tangentCC( M[i], M[j] );\n        copy( nl.begin(), nl.end(), back_inserter( line ) );\n      }\n    }\n\n    if( N < 2 ) {\n      cout << N << endl;\n      continue;\n    }\n\n    int res = 0;\n    for(int i=0;i<(int)line.size();i++){\n      int cnt = 0;\n      //cout << line[i].first << \" - \" << line[i].second << endl;\n      for(int j=0;j<N;j++){\n        double x = abs(C[j].c - proj( C[j].c, line[i] ));        \n        //cout << j << \": \" << x << \"  \"<< C[j].r << \" \" << M[j].r << endl;\n        if( C[j].r < x+EPS && x < M[j].r+EPS ) cnt++;\n      }\n      res = max( res, cnt );\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{  \n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  //点pを中心に点tを角度r(radius)だけ半時計回りに回転する\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n\nstruct Line{\n  Point a,b;\n\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle(){}\n  Circle(Point p, Real r) : p(p) , r(r){}\n\n  Line tangent(Real theta){\n    Point a(r*cos(theta),r*sin(theta));\n    Point b(a.y,-a.x);\n    return Line(p+a,p+a+b);\n  }\n  \n  vector<Line> commonTangent(Circle x){\n    vector<Line>res;\n    x.p=x.p-p;\n    Real a=x.p.arg();\n    Real b[2]={(r-x.r),(r+x.r)};\n    for(int i=0;i<2;i++){\n      b[i]/=x.p.norm();\n      if(sgn(b[i],-1.0)<0 || sgn(b[i],1.0)>0)return res;\n      Real c=asin(b[i])-asin(1.0);\n      res.push_back(tangent(a-c));\n      res.push_back(tangent(a+c));\n    }\n    return res;\n  }\n  \n};\n\nint n;\nvector<Circle>c;\nvector<Real>m;\n\nvector<Line> enumerate(){\n  vector<Line>res;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      vector<Line>tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r+=m[i];\n      tmp=c[i].commonTangent(c[j]);\n      for(int k=0;k<tmp.size();k++){\n\tres.push_back(tmp[k]);\n      }\n      c[i].r-=m[i];\n    }\n  }\n  return res;\n}\n\nint count(Line l){\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    Real d=l.dist(c[i].p)-c[i].r;\n    cnt+=(sgn(d)>=0 && sgn(d,m[i])<=0);\n  }\n  return cnt;\n}\n\nint main(void){\n\n  while(cin >> n,n){\n    c.resize(n);\n    m.resize(n);\n\n    for(int i=0;i<n;i++)\n      cin >> c[i].p.x >> c[i].p.y >> c[i].r >> m[i];\n    \n    vector<Line>res=enumerate();\n    \n    int cnt=0;\n    for(int i=0;i<res.size();i++){\n      cnt=max(cnt,count(res[i]));\n    }\n    cout << max(1,cnt) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst double EPS = 1e-11;\n\n/*\n * r1 > 0 ===> outer tangent\n * r1 < 0 ===> inner tangent\n * ax + by = c\n */\nvoid circle_tangent(double x0, double y0, double r0,\n\t\t    double x1, double y1, double r1,\n\t\t    double &a, double &b, double &c) {\n  double rd = r0 - r1;\n  // p = ((x1 - x0) + (y1 - y0)i) / (u + (r0 - r1)i)\n  double u = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2) - rd * rd);\n  double alpha = u * u + (r0 - r1) * (r0 - r1);\n  double px = (x1 - x0) * u + (y1 - y0) * (r0 - r1);\n  double py = - (x1 - x0) * (r0 - r1) + (y1 - y0) * u;\n  px /= alpha;\n  py /= alpha;\n  a = py;\n  b = -px;\n  double qx = x0 - r0 * py;\n  double qy = y0 + r0 * px;\n  c = a * qx + b * qy;\n}\n\nint main(void){\n  int n;\n  while (cin >> n && n) {\n    vector<double> x(n), y(n), r(n), m(n);\n    REP(i, 0, n) {\n      cin >> x[i] >> y[i] >> r[i] >> m[i];\n    }\n    int ma = 0;\n    if (n >= 2) {\n    REP(i, 0, n) {\n      REP(j, i + 1, n) {\n\tint cnt = 0;\n\tdouble a, b, c;\n\tcircle_tangent(x[i], y[i], r[i], x[j], y[j], r[j],\n\t\t       a, b, c);\n\tcnt = 0;\n\tREP(k, 0, n) {\n\t  double dist = abs(a * x[k] + b * y[k] - c) / sqrt(a * a + b * b);\n\t  if (dist > r[k] - EPS && dist < r[k] + m[k] + EPS) {\n\t    cnt++;\n\t  }\n\t}\n\tma = max(ma, cnt);\n\tcircle_tangent(x[i], y[i], r[i], x[j], y[j], -r[j],\n\t\t       a, b, c);\n\tcnt = 0;\n\tREP(k, 0, n) {\n\t  double dist = abs(a * x[k] + b * y[k] - c) / sqrt(a * a + b * b);\n\t  if (dist > r[k] - EPS && dist < r[k] + m[k] + EPS) {\n\t    cnt++;\n\t  }\n\t}\n\tma = max(ma, cnt);\n      }\n    }\n    } else {\n      ma = 1;\n    }\n    cout << ma << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = 3.1415926535;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  C() {}\n};\n\nP rotate(P p, double ang) {\n  return P(real(p)*cos(ang)-imag(p)*sin(ang),\n           real(p)*sin(ang)+imag(p)*cos(ang));\n}\nL rotate(L l, double ang) {\n  return L(rotate(l[0], ang),rotate(l[1], ang));\n}\n\nvector<L> tanPairCircles(C c1, C c2) {\n  vector<L> res;\n  P d = c2.p-c1.p;\n  P hoge = c1.r/(c1.r+c2.r)*d; // p1->ツ静堋静シツづ個古ーツ点\n  P p = c1.p+hoge; // ツ静堋静シツづ個古ーツ点\n  double ang = asin(c1.r/abs(hoge));\n  res.push_back(L(p,p+rotate(-hoge, ang)));\n  res.push_back(L(p,p+rotate(-hoge, -ang)));\n\n  if (c1.r == c2.r) {\n    P p1 = c1.p + rotate(d*c1.r/abs(d), PI/2);\n    P p2 = c1.p + rotate(d*c1.r/abs(d), -PI/2);\n    res.push_back(L(p1,p1+d));\n    res.push_back(L(p2,p2+d));\n  } else {\n    if (c1.r<c2.r) swap(c1,c2);\n    hoge = c1.r/(c1.r-c2.r)*d; // p1->ツ静堋静シツづ個古ーツ点\n    p = c1.p+hoge; // ツ静堋静シツづ個古ーツ点\n    ang = asin(c1.r/abs(hoge));\n    res.push_back(L(p,p+rotate(-hoge, ang)));\n    res.push_back(L(p,p+rotate(-hoge, -ang)));\n  }\n  return res;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    C c[2*n];\n    double d[n];\n\n    REP(i,n) {\n      double x,y,r;\n      cin >> x>>y>>r>>d[i];\n      c[i] = C(P(x,y),r);\n    }\n    if (n==1) {\n      cout << 1 << endl;\n      continue;\n    }\n    REP(i,n) {\n      c[n+i] = C(c[i].p, c[i].r+d[i]);\n    }\n    int ans = 0;\n    REP(i,2*n-1) {\n      for (int j=i+1;j<2*n;++j) {\n        vector<L> v = tanPairCircles(c[i],c[j]);\n        FOR(it, v) {\n          L l = *it;\n          int tmp = 0;\n          REP(k,n) {\n            if (distanceLP(l, c[k].p) < d[k]+c[k].r+EPS && distanceLP(l, c[k].p) > c[k].r - EPS)\n              tmp++;\n          }\n          ans = max(ans, tmp);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-8;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n  Point operator + (const Point& p) const{ return Point(x + p.x, y + p.y); }\n  Point& operator += (const Point& p){ x += p.x; y += p.y; return *this;}\n  Point operator - (const Point& p) const{ return Point(x - p.x, y - p.y); }\n  Point& operator -= (const Point& p){ x -= p.x; y -= p.y; return *this;}\n  Point operator * (double a) const{ return Point(a*x, a*y); }\n  Point& operator *= (double a){ x *= a; y *= a; return *this;}\n  Point operator / (double a) const{ return Point(x / a, y / a); }\n  Point& operator /= (double a){ x /= a; y /= a; return *this;}\n\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n  \n  bool operator < (const Point &p) const{\n\treturn x != p.x ? x < p.x : y < p.y;\n  }\n  \n  //EPS??????????°??????????\n  bool operator == (const Point &p) const {\n\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n  friend ostream& operator <<(ostream& os, const Point& p);\n};\nostream& operator <<(ostream& os, const Point& p){\n  return os << \"(\" << p.x << \",\"<<p.y << \")\";\n}\nclass Line{\npublic:\n\tPoint p1, p2;\n  Line(){}\n  Line(const Point& p1_, const Point& p2_)\n\t: p1(p1_), p2(p2_)\n  {}\n};\ntypedef Point Vector;\nclass Circle{\npublic:\n  Point c;\n  double r;\n  double m;\n};\n\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\nvector<Point> tangent(Point p, Circle c){\n  p -= c.c;\n  vector<Point> res;\n  double d = sqrt(p.norm() - c.r*c.r);\n  res.PB(Point(c.r/p.norm()*(p.x*c.r+p.y*d), c.r/p.norm()*(p.y*c.r-p.x*d)));\n  res.PB(Point(c.r/p.norm()*(p.x*c.r-p.y*d), c.r/p.norm()*(p.y*c.r+p.x*d)));\n  res[0] += c.c;\n  res[1] += c.c;\n  return res;\n}\n\nvector<Line> common_tangent (Circle p, Circle q) {\n  double pr = p.r, qr = q.r;\n    Point pc = p.c, qc = q.c;\n    double d = (pc - qc).abs(), dr = abs(pr - qr), sr = (pr + qr);\n\n    vector<Line> ret;\n    if (d > sr) {\n        // cross pair\n        Point cp = (pc * qr + qc * pr) / sr;\n        vector<Point> pts = tangent(cp, p), qts = tangent(cp, q);\n        ret.push_back(Line(pts[0], qts[0]));\n        ret.push_back(Line(pts[1], qts[1]));\n    } else if (abs(d - sr) < EPS) {\n        // cross pair coinside\n        Point cp = (pc * qr + qc * pr) / sr;\n        ret.push_back(Line(cp, cp));\n    } \n\n    if (d > dr) {\n        // outer pair\n        if (abs(pr - qr) < EPS) {\n            Point v = (qc - pc) / d;\n\t\t\tv = Point(-v.y, v.x);\n            ret.push_back(Line(pc + v, qc + v));\n            ret.push_back(Line(pc - v, qc - v));\n        } else {\n            Point cp = pc + (qc - pc) * pr / (pr - qr);\n            vector<Point> pts = tangent(cp, p), qts = tangent(cp, q);\n            ret.push_back(Line(pts[0], qts[0]));\n            ret.push_back(Line(pts[1], qts[1]));\n        }\n    } else if (abs(d - dr) < EPS) {\n        // outer pair coinside\n        Point cp = (qc - pc) * pr / (pr - qr);\n        ret.push_back(Line(cp, cp));\n    } \n\n    return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<Circle> cs(N);\n\tVI ms(N);\n\tREP(i,N) cin >> cs[i].c.x >> cs[i].c.y >> cs[i].r >> cs[i].m;\n\n\tauto check = [&](Line& l, Circle& c)->bool{\n\t  double d = getDistanceLP(l, c.c);\n\t  return c.r-EPS <= d && d <= c.r+c.m+EPS;\n\t};\n\n\tint ans = 1;\n\tREP(i,N) FOR(j,i+1,N){\n\t  Circle c1, c2;\n\t  c1 = cs[i], c2 = cs[j];\n\t  auto lines = common_tangent(c1,c2);\n\t  for(auto& l: lines)\n\t\tans = max(ans, (int)count_if(ALL(cs),\n\t\t\t\t\t\t\t\t[&](Circle& c){return check(l,c);}));\n\t  c1.r += cs[i].m;\n\t  lines = common_tangent(c1,c2);\n\t  for(auto& l: lines)\n\t\tans = max(ans, (int)count_if(ALL(cs),\n\t\t\t\t\t\t\t\t[&](Circle& c){return check(l,c);}));\n\t  c2.r += cs[j].m;\n\t  lines = common_tangent(c1,c2);\n\t  for(auto& l: lines)\n\t\tans = max(ans, (int)count_if(ALL(cs),\n\t\t\t\t\t\t\t\t[&](Circle& c){return check(l,c);}));\n\t  c1.r = cs[i].r;\n\t  lines = common_tangent(c1,c2);\n\t  for(auto& l: lines)\n\t\tans = max(ans, (int)count_if(ALL(cs),\n\t\t\t\t\t\t\t\t[&](Circle& c){return check(l,c);}));\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct line\n{\n    double a,b,c;\n};\n\nconst int MAX_N = 100005;\nconst int sign[] = {1,-1};\n\nvector<line> tangent(double x1,double y1,double r1,double x2,double y2,double r2)\n{\n    vector<line> vec;\n    double p,q,r;\n    double a = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    rep(i,2){\n        double b = -(x2-x1)*(r1*r1+sign[i]*r1*r2);\n        double c = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (y2-y1)*(y2-y1)*r1*r1;\n        double d = -(y2-y1)*(r1*r1+sign[i]*r1*r2);\n        double e = (r1*r1+sign[i]*r1*r2)*(r1*r1+sign[i]*r1*r2) - (x2-x1)*(x2-x1)*r1*r1;\n        rep(j,2){\n            if(b*b - a*c < -EPS){\n                break;\n            }\n            p = (-b + sign[j]*sqrt(b*b-a*c)) / a;\n            q = (-d - sign[j]*sqrt(d*d-a*e)) / a;\n            r = -r1*r1 - p*x1 - q*y1;\n            vec.push_back((line){p,q,r});\n        }\n    }\n    return vec;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        int X[51],Y[51],R[51],M[51];\n    \trep(i,n){\n    \t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&M[i]);\n    \t}\n        if(n == 1){\n            printf(\"1\\n\");\n            continue;\n        }\n        vector<line> v;\n        v = tangent(X[0],Y[0],R[0],X[1],Y[1],R[1]);\n        int res = 0;\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                vector<line> u[4];\n                u[0] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]);\n                u[1] = tangent(X[i],Y[i],R[i],X[j],Y[j],R[j]+M[j]);\n                u[2] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]);\n                u[3] = tangent(X[i],Y[i],R[i]+M[i],X[j],Y[j],R[j]+M[j]);\n                rep(k,4){\n                    rep(l,u[k].size()){\n                        int bf = 2;\n                        double aa = u[k][l].a,bb = u[k][l].b,cc = u[k][l].c;\n                        double d = sqrt(aa*aa+bb*bb);\n                        rep(l,n){\n                            if(l != i && l != j){\n                                if(abs(aa*X[l] + bb*Y[l] + cc) / d > R[l] - EPS && abs(aa*X[l] + bb*Y[l] + cc) / d < R[l] + M[l] + EPS){\n                                    bf++;\n                                }\n                            }\n                        }\n                        res = max(res,bf);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(){\n\t\tcout << p1 << ' ' << p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint turn(Point p,double t){\n\treturn p*exp(Point(.0,t*M_PI/180.0));\n}\n\nvector<Line> tangentCircleCircle(Circle a,Circle b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.p-b.p);\n\tvector<Line>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/M_PI;\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),t),b.p+turn(b.r/d*(a.p-b.p),t)));\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),-t),b.p+turn(b.r/d*(a.p-b.p),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tPoint p=a.p+a.r/d*(b.p-a.p);\n\t\tl.push_back(Line(p,p+turn(b.p-a.p,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/M_PI;\n\t\tdouble t2=180-t1;\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),t1),b.p+turn(b.r/d*(a.p-b.p),-t2)));\n\t\tl.push_back(Line(a.p+turn(a.r/d*(b.p-a.p),-t1),b.p+turn(b.r/d*(a.p-b.p),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tPoint p=a.p+a.r/d*(b.p-a.p);\n\t\tl.push_back(Line(p,p+turn(b.p-a.p,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<Circle> cs(n);\n\t\tvector<double> m(n);\n\t\trep(i,n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r >> m[i];\n\t\t\tcs[i] = Circle(Point(x, y), r);\n\t\t}\n\n\t\tif(n == 1){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<Line> ls;\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tCircle a[2], b[2];\n\t\t\t\ta[0] = a[1] = cs[i];\n\t\t\t\ta[1].r+=m[i];\n\n\t\t\t\tb[0] = b[1] = cs[j];\n\t\t\t\tb[1].r+=m[j];\n\n\t\t\t\trep(k,2){\n\t\t\t\t\trep(l,2){\n\t\t\t\t\t\tfor(auto line :  tangentCircleCircle(a[k],b[l])){\n\t\t\t\t\t\t\tls.emplace_back(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i,ls.size()){\n\t\t\tint sum = 0;\n\t\t\trep(j,n){\n\t\t\t\tdouble dis = distanceLPoint(ls[i], cs[j].p);\n\t\t\t\tif(dis >= cs[j].r and dis <= cs[j].r + m[j]){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define EPS (1e-12)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n    Point operator / ( Point p ) { return Point((x*p.x+y*p.y)/(p.x*p.x+p.y*p.y), (y*p.x-x*p.y)/(p.x*p.x+p.y*p.y)); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\ndouble arg(Vector p){ return atan2(p.y, p.x); }\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// verified by 920, 833, uoa2062\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n// 10514\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getTangentPoints(Point p, Circle c){\n  double d = abs(c.c - p);\n  double t = arg(c.c - p);\n  double b = sqrt(d*d - c.r * c.r);\n  double a = asin(c.r / d);\n  Point p1 = p + polar(b, t + a);\n  Point p2 = p + polar(b, t - a);\n  return make_pair(p1, p2);\n}\n\n/*\n return tangent points on c1\n */\nvector<Point> getCommonTangent(Circle c1, Circle c2){\n  vector<Point> tp;\n  Point base = c2.c - c1.c;\n  double l = abs(base);\n  double a = arg(base); // base alpha\n  if ( abs(c1.r - c2.r) < l  ){\n    double th1 = acos((c1.r - c2.r)/l);\n    tp.push_back(c1.c + polar(c1.r, a + th1));\n    tp.push_back(c1.c + polar(c1.r, a - th1));\n    if ( c1.r + c2.r < l ){\n      double th2 = acos((c1.r + c2.r)/l);\n      tp.push_back(c1.c + polar(c1.r, a + th2));\n      tp.push_back(c1.c + polar(c1.r, a - th2));\n    }\n  }\n\n/*\n  if ( (equals(l, abs(c1.r - c2.r)) || equals(c1.r + c2.r, l) ) && !equals(l, 0) ) {\n    tp.push_back(c1.c + polar(c1.r, a));\n  }\n  */\n  if ( equals(c1.r + c2.r, l) && !equals(l, 0) ) { // out\n    tp.push_back(c1.c + polar(c1.r, a));\n  }\n\n  if ( equals(l, abs(c1.r - c2.r)) && !equals(l, 0) ) { //in\n    tp.push_back(c1.c + polar(c1.r, a + acos(-1)));\n  }\n\n  \n  return tp;\n}\n\nint N;\nCircle C[50];\nCircle T[100]; // target circle\nint M[50];\n\nint solve(){\n  if ( N == 1 ) return 1;\n  vector<Line> L;\n\n  for ( int i = 0; i < N; i++ ) {\n    T[i] = C[i];\n    T[i+N] = Circle(C[i].c, C[i].r + M[i]);\n  }\n\n  for ( int i = 0; i < 2*N-1; i++ ){\n    for ( int j = i+1; j < 2*N; j++ ){\n      vector<Point> ap = getCommonTangent(T[i], T[j]);\n      for ( int k = 0; k < ap.size(); k++ ){\n\tVector v = ap[k] - T[i].c;\n\tv = polar(abs(v), arg(v) + acos(-1)/2.0);\n\tL.push_back(Line(ap[k], ap[k] + v));\n      }\n    }\n  }\n\n  int ans = 0;\n  for ( int l = 0; l < L.size(); l++ ){\n    int cnt = 0;\n    for ( int i = 0; i < N; i++ ){\n      double d = getDistanceLP(L[l], C[i].c);\n      if ( dle(C[i].r, d) && dle(d, C[i].r + M[i]) ) cnt++;\n    }\n    ans = max(ans, cnt);\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    for ( int i = 0; i < N; i++ ){\n      cin >> C[i].c.x >> C[i].c.y >> C[i].r >> M[i];\n    }\n    cout << solve() << endl;\n  }\n\t\t\t  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r>EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (l<EPS) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Circle> cs;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, r, m;\n\t\t\tcin >> x >> y >> r >> m;\n\t\t\tPoint p(x, y);\n\t\t\tcs.push_back(Circle{ p, r });\n\t\t\tcs.push_back(Circle{ p, r + m });\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, cs.size())REP(j, i)\n\t\t{\n\t\t\tvector<Line> ls = tangent_cc(cs[i], cs[j]);\n\t\t\tREP(k, ls.size())\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(l, cs.size())\n\t\t\t\t{\n\t\t\t\t\tif (l % 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < EPS) cnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dist_lp(ls[k], cs[l].p) - cs[l].r < -EPS) cnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchmax(ans, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\ntypedef complex<double> C;\n#define EPS 1e-10\n\nconst double PI = 4*atan(1.0);\n\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n\n\nint main(){\n    int n;\n    while(cin >> n&&n!=0){\n        vector<C> x(n);\n        vector<double>r(n),m(n);\n        rep(i,n){\n            double a,b;\n            cin >> a >> b >> r[i] >> m[i];\n            x[i] = C(a,b);\n        }\n        if(n==1){\n            cout << 1 << endl;\n            continue;\n        }\n        int ans = 0;\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                vector<L> v;\n                v = gettangentCC(x[i],r[i],x[j],r[j]);\n                \n                rep(c,v.size()){\n                    int tmp = 0;\n                    rep(k,n){\n                        if(distanceLP(v[c],x[k])-EPS <= m[k]+r[k]&&distanceLP(v[c],x[k])+EPS >= r[k])tmp++;\n                    }\n                    ans = max(ans,tmp);\n                }\n            }\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                vector<L> v;\n                v = gettangentCC(x[i],r[i]+m[i],x[j],r[j]);\n                \n                rep(c,v.size()){\n                    int tmp = 0;\n                    rep(k,n){\n                        if(distanceLP(v[c],x[k])-EPS <= m[k]+r[k]&&distanceLP(v[c],x[k])+EPS >= r[k])tmp++;\n                    }\n                    ans = max(ans,tmp);\n                }\n            }\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                vector<L> v;\n                v = gettangentCC(x[i],r[i],x[j],r[j]+m[j]);\n                \n                rep(c,v.size()){\n                    int tmp = 0;\n                    rep(k,n){\n                        if(distanceLP(v[c],x[k])-EPS <= m[k]+r[k]&&distanceLP(v[c],x[k])+EPS >= r[k])tmp++;\n                    }\n                    ans = max(ans,tmp);\n                }\n            }\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                vector<L> v;\n                v = gettangentCC(x[i],r[i]+m[i],x[j],r[j]+m[j]);\n                \n                rep(c,v.size()){\n                    int tmp = 0;\n                    rep(k,n){\n                        if(distanceLP(v[c],x[k])-EPS <= m[k]+r[k]&&distanceLP(v[c],x[k])+EPS >= r[k])tmp++;\n                    }\n                    ans = max(ans,tmp);\n                }\n            }\n        }\n        cout <<ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n/*\n -1 -> a > b\n 0 -> a near b\n 1 -> a < b\n */\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\n\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//return number of cross point\nint crossCC(const C &c, const C &d, R &l, R &r) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        assert(false);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l = bth-th;\n    r = bth+th;\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nint commonInternalTangent(const C &c, const C &d, L &l, L &r) {\n    R di = abs(c.p - d.p);\n    if (sgn(di, c.r + d.r) == 1) return 0;\n    R th = sacos((c.r+d.r) / di);\n    l.x = c.p + polar(c.r, arg(d.p-c.p)-th);\n    l.y = l.x + polar<R>(1, arg(d.p-c.p)-th + PI/2);\n    r.x = c.p + polar(c.r, arg(d.p-c.p)+th);\n    r.y = l.x + polar<R>(1, arg(d.p-c.p)+th - PI/2);\n    if (sgn(di, c.r+d.r) == 0) return 1;\n    return 2;\n}\n\nint commonExternalTangent(const C &c, const C &d, L &l, L &r) {\n    R di = abs(c.p - d.p);\n    if (sgn(di, abs(c.r - d.r)) == 1) return 0;\n    R th = sacos((c.r-d.r) / di);\n    l.x = c.p + polar(c.r, arg(d.p-c.p)-th);\n    l.y = l.x + polar<R>(1, arg(d.p-c.p)-th + PI/2);\n    r.x = c.p + polar(c.r, arg(d.p-c.p)+th);\n    r.y = l.x + polar<R>(1, arg(d.p-c.p)+th - PI/2);\n    if (sgn(di, abs(c.r - d.r)) == 0) return 1;\n    return 2;\n}\n\nconst int MN = 55;\n\nP p[MN];\nR r[MN], m[MN];\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (!n) return false;\n    vector<C> c;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y >> r[i] >> m[i];\n        p[i] = P(x, y);\n        c.push_back(C(p[i], r[i]));\n        c.push_back(C(p[i], r[i]+m[i]));\n    }\n\n    int u = (int)c.size();\n\n    vector<L> vl;\n    for (int i = 0; i < u; i++) {\n        P pp = c[i].p + P(c[i].r, 0);\n        vl.push_back(L(pp, pp+P(0, 1)));\n    }\n    for (int i = 0; i < u; i++) {\n        for (int j = i+1; j < u; j++) {\n            L l, r;\n            if (commonExternalTangent(c[i], c[j], l, r)) {\n                vl.push_back(l); vl.push_back(r);\n            }\n            if (commonInternalTangent(c[i], c[j], l, r)) {\n                vl.push_back(l); vl.push_back(r);\n            }\n        }\n    }\n\n    int ma = 0;\n    for (L l: vl) {\n        int sm = 0;\n        for (int i = 0; i < n; i++) {\n            R len = distLP(l, p[i]);\n            if (sgn(r[i], len) != -1 && sgn(len, r[i]+m[i]) != -1) sm++;\n        }\n        ma = max(ma, sm);\n    }\n    printf(\"%d\\n\", ma);\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2201: Immortal Jewels\n * ?¢?????????¨?????¢??????????????????????????????????????????????????????????£?????????´???????????´?????¨???????£?????????´?????????????????????????????\\????¢???????????±?????????????????????´??????????????°??????\n * ?±???????????????????\n * ?????????????????????????±??£?????????´?????°?£???????????????????????????´??????2??????????£????????????????????????????????????????????????????????????°??\\??´????????????????????¨?????´???????¶?????????????PS?????????????????¨????¨?????§??´????\n */\n\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n\ntypedef complex<double> P;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-12;\n\nint cmp(double a, double b) {\n  const double diff = a - b;\n  if (fabs(diff) < EPS)\n    return 0;\n  else if (diff < 0)\n    return -1;\n  else\n    return 1;\n}\n\n// ????????????\ninline double dot(const P &a, const P &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\n// ????????????\ninline double cross(const P &a, const P &b) {\n  return a.real() * b.imag() - b.real() * a.imag();\n}\n\nstruct line {\n  P a, b;\n\n  line() {}\n\n  line(const P &p, const P &q) : a(p), b(q) {}\n\n  // ????????????\n  inline bool parallel(const line &ln) const {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;  // ?????????????????°??????????¨????0???????°±???sin(theta)=0 <-> theta=0\n  }\n\n  // ????????????\n  inline bool intersects(const line &ln) const {\n    return !parallel(ln);\n  }\n\n  // ?±???????\n  inline P intersection(const line &ln) const {\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x * (cross(y, ln.a - a)) / cross(y, x);\n  }\n\n  // ?????°??´????????????\n  inline double distance(const P &p) const {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // ?±?????¶???????\n  inline P perpendicular(const P &p) const {\n    const double t = dot(p - a, a - b) / dot(b - a, b - a);\n    return a + t * (a - b);\n  }\n};\n\n\nstruct circle {\n  P o;\n  double r;\n\n  circle() {}\n\n  circle(const P &p, double x) : o(p), r(x) {}\n\n  // ????????? p ???????????????\n  pair<P, P> tangent(const P &p) const {\n    const double L = abs(o - p);\n    const double M = sqrt(L * L - r * r);\n    const double theta = asin(r / L);\n    const P v = (o - p) / L;\n    return make_pair(p + M * (v * polar(1.0, theta)), p + M * (v * polar(1.0, -theta)));\n  }\n\n  // ?????????????????????????????????????????????\n  pair<line, line> outer_tangent_parallel(const circle &c) const {\n    const P d = o - c.o;\n    const P v = d * P(0, 1) * r / abs(d);\n    return make_pair(line(o + v, c.o + v), line(o - v, c.o - v));\n  }\n\n  // ??????????????????\n  pair<line, line> outer_tangent(const circle &c) const {\n    if (cmp(r, c.r) == 0)\n      return outer_tangent_parallel(c);\n    if (r > c.r)\n      return c.outer_tangent(*this);\n    const P d = o - c.o;\n    const double fact = c.r / r - 1;\n    const P base = c.o + d + d / fact;\n    const pair<P, P> t = tangent(base);\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // ?????????\n  pair<line, line> inner_tangent(const circle &c) const {\n    if (r > c.r)\n      return c.inner_tangent(*this);\n    const P d = c.o - o;\n    const double fact = c.r / r + 1;\n    const P base = o + d / fact;\n    const pair<P, P> t = tangent(base);\n    return make_pair(line(base, t.first), line(base, t.second));\n  }\n\n  // ????????????\n  inline bool intersects(const circle &c) const {\n    return !contains(c) && !c.contains(*this) && cmp(abs(o - c.o), r + c.r) <= 0;\n  }\n\n  // ????????????\n  inline bool independent(const circle &c) const {\n    return cmp(abs(o - c.o), r + c.r) > 0;\n  }\n\n  // ??????????????????\n  pair<P, P> intersection(const circle &c) const {\n    const double d = abs(o - c.o);\n    const double cos_ = (d * d + r * r - c.r * c.r) / (2 * d);\n    const double sin_ = sqrt(r * r - cos_ * cos_);\n    const P e = (c.o - o) / d;\n    return make_pair(o + e * P(cos_, sin_), o + e * P(cos_, -sin_));\n  }\n\n  // ???????????????c\n  inline bool contains(const circle &c) const {\n    return cmp(abs(o - c.o) + c.r, r) < 0;\n  }\n\n  // ????????????\n  inline bool intersects(const line &ln) const {\n    return cmp(abs(ln.distance(o)), r) <= 0;\n  }\n\n  // ????????°??´????????????\n  inline double distance(const line &ln) const {\n    return abs(ln.distance(o));\n  }\n\n  // ????????´????????????\n  pair<P, P> intersection(const line &ln) const {\n    const P h = ln.perpendicular(o);\n    const double d = abs(h - o);\n    P ab = ln.b - ln.a;\n    ab /= abs(ab);\n    const double l = sqrt(r * r - d * d);\n    return make_pair(h + l * ab, h - l * ab);\n  }\n};\n\nvoid enum_event(const circle &c1, const circle &c2, vector<line> &lines) {\n  if (c1.independent(c2))  // c1 c2??????\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n    auto inner = c1.inner_tangent(c2);\n    lines.push_back(inner.first);\n    lines.push_back(inner.second);\n  } else if (c1.intersects(c2))  // ??????\n  {\n    auto outer = c1.outer_tangent(c2);\n    lines.push_back(outer.first);\n    lines.push_back(outer.second);\n  }\n}\n\ncircle cs[50][2];\nvector<line> lines;\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) != EOF && n) {\n    lines.clear();\n    for (int i = 0; i < n; ++i) {\n      double x, y, r, m;\n      scanf(\"%lf%lf%lf%lf\", &x, &y, &r, &m);\n      cs[i][0] = circle(P(x, y), r);\n      cs[i][1] = circle(P(x, y), r + m);\n      for (int j = 0; j < i; ++j) {\n        enum_event(cs[i][0], cs[j][0], lines);\n        enum_event(cs[i][1], cs[j][0], lines);\n        enum_event(cs[i][0], cs[j][1], lines);\n        enum_event(cs[i][1], cs[j][1], lines);\n      }\n    }\n    int ans = 1;\n    for (auto &l: lines) {\n      int cnt = 0;\n      for (int i = 0; i < n; ++i) {\n        double d = l.distance(cs[i][0].o);\n//        printf(\"i= %d dist = %f\\n\", i, d);\n        if (cmp(d, cs[i][0].r) >= 0 && cmp(d, cs[i][1].r) <= 0) {\n          ++cnt;\n        }\n      }\n//      printf(\"%f %f -- %f %f -- %d\\n\", l.a.real(), l.a.imag(), l.b.real(), l.b.imag(), cnt);\n      ans = max(ans, cnt);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define PI 3.141592\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N,i,k;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tdouble j;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0; j< 2*PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = 1 / tan(j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (-x[i]-r[i]*cos(j)) / tan(j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*1000)/1000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2201 Immortal Jewels\n// 2018.3.11 bal4u\n \n#include <stdio.h>\n#include <math.h>\n\n#define EPS\t\t\t1e-8\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } LINE;\ntypedef struct { PP p; double r; } C;\n\nC    c[102]; int sc;\nLINE line[40001]; int sl;\n\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nvoid lset(LINE *ln, PP a, PP b) { ln->s = a, ln->e = b; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\n\ndouble distancePL(PP p, LINE ln) {\n\treturn fabs(cross(vsub(p, ln.s), vsub(ln.s, ln.e))) / vabs(vsub(ln.s, ln.e)); }\n\ndouble distanceLC(LINE ln, C c) { return distancePL(c.p, ln); }\n\nint is_containCC(C c1, C c2) { return dcmp(vabs(vsub(c1.p, c2.p)) + c2.r - c1.r) < 0; }\n\nint is_interCC(C c1, C c2) {\n\treturn !is_containCC(c1, c2) && !is_containCC(c2, c1) &&\n\t\t   dcmp(vabs(vsub(c1.p, c2.p)) - (c1.r + c2.r)) <= 0;\n}\n\nvoid intersectCC(PP *p1, PP *p2, C c1, C c2)\n{\n\tdouble d = vabs(vsub(c1.p, c2.p));\n\tdouble cos = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tdouble sin = sqrt(c1.r * c1.r - cos * cos);\n\tPP p = vsmul(vsub(c1.p, c2.p), 1 / d);\n\t*p1 = vadd(c1.p, vmul(p, vset(cos, sin))), *p2 = vadd(c1.p, vmul(p, vset(cos, -sin)));\n}\n\nvoid tangentLP(LINE *ln, C c, PP p)\n{\n\tdouble L = vabs(vsub(c.p, p));\n\tdouble M = sqrt(L*L - c.r* c.r);\n\tdouble theta = asin(c.r / L);\n\tPP v = vsmul(vsub(c.p, p), 1/L);\n\tPP a = vset(cos(theta), sin(theta)), b = vset(cos(theta), -sin(theta));\n\tln->s = vadd(p, vsmul(vmul(v, a), M));\n\tln->e = vadd(p, vsmul(vmul(v, b), M));\n}\n\nvoid outer_tangent_parallelLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d = vsub(c1.p, c2.p);\n\tPP v = vsmul(vmul(d, vset(0, 1)), c1.r / vabs(d));\n\tln1->s = vadd(c1.p, v), ln1->e = vadd(c2.p, v);\n\tln2->s = vsub(c1.p, v), ln2->e = vsub(c2.p, v);\n}\n \nvoid inner_tangentLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d, base;\tdouble f; LINE t;\n\n\tif (c1.r > c2.r) { inner_tangentLC(ln1, ln2, c2, c1); return; }\n\td = vsub(c2.p, c1.p);\n\tf = c2.r / c1.r + 1;\n\tbase = vadd(c1.p, vsmul(d, 1/f));\n\ttangentLP(&t, c1, base);\n\tlset(ln1, base, t.s), lset(ln2, base, t.e);\n}\n\nvoid outer_tangentLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d, base;\tdouble f; LINE t;\n\n\tif (!dcmp(c1.r - c2.r))\t{ outer_tangent_parallelLC(ln1, ln2, c1, c2); return; }\n\tif (c1.r > c2.r) { outer_tangentLC(ln1, ln2, c2, c1); return; }\n\td = vsub(c1.p, c2.p);\n\tf = c2.r / c1.r - 1;\n\tbase = vadd(vadd(c2.p, d), vsmul(d, 1/f));\n\ttangentLP(&t, c1, base);\n\tlset(ln1, base, t.s), lset(ln2, base, t.e);\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ntypedef struct { C c; int m; } JEWEL;\nJEWEL jewel[52];\n\nint main()\n{\n\tint N, i, j, f, ans;\n\tdouble d;\n\n\twhile (N = in()) {\n\t\tsc = 0; for (i = 0; i < N; i++) {\n\t\t\tint x = in(), y = in(), r = in(), m = in();\n\t\t\tjewel[i].c.p.x = x, jewel[i].c.p.y = y, jewel[i].c.r = r, jewel[i].m = r+m; \n\t\t\tc[sc].p.x = x, c[sc].p.y = y, c[sc++].r = r;\n\t\t\tif (m > 0) c[sc].p.x = x, c[sc].p.y = y, c[sc++].r = r + m;\n\t\t}\n\n\t\tsl = 0;\n\t\tfor (i = 0; i < sc; i++) for (j = 0; j < sc; j++) if (i != j) {\n\t\t\tif (PPeQ(c[i].p, c[j].p)) continue;\n\n\t\t\tif (is_interCC(c[i], c[j])) {\n\t\t\t\touter_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n//\t\t\t\tintersectCC(&line[sl].s, &line[sl].e, c[i], c[j]), sl++;\n\t\t\t} else {\n\t\t\t\tinner_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n\t\t\t\touter_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tfor (i = 0; i < sl; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j < N; j++) {\n\t\t\t\td = distanceLC(line[i], jewel[j].c);\n\t\t\t\tif ((EQ(d, jewel[j].c.r) || d >= jewel[j].c.r) &&\n\t\t\t\t\t(EQ(d, jewel[j].m) || d <= jewel[j].m)) f++;\n\t\t\t}\n\t\t\tif (f > ans) ans = f;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2201 Immortal Jewels\n// 2018.3.11 bal4u\n \n#include <stdio.h>\n#include <math.h>\n\n#define EPS\t\t\t1e-8\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } LINE;\ntypedef struct { PP p; double r; } C;\n\nC    c[102]; int sc;\nLINE line[40001]; int sl;\n\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nvoid lset(LINE *ln, PP a, PP b) { ln->s = a, ln->e = b; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\n\ndouble distancePL(PP p, LINE ln) {\n\treturn fabs(cross(vsub(p, ln.s), vsub(ln.s, ln.e))) / vabs(vsub(ln.s, ln.e)); }\n\ndouble distanceLC(LINE ln, C c) { return distancePL(c.p, ln); }\n\nint is_containCC(C c1, C c2) { return dcmp(vabs(vsub(c1.p, c2.p)) + c2.r - c1.r) < 0; }\n\nint is_interCC(C c1, C c2) {\n\treturn !is_containCC(c1, c2) && !is_containCC(c2, c1) &&\n\t\t   dcmp(vabs(vsub(c1.p, c2.p)) - (c1.r + c2.r)) <= 0;\n}\n\nvoid intersectCC(PP *p1, PP *p2, C c1, C c2)\n{\n\tdouble d = vabs(vsub(c1.p, c2.p));\n\tdouble cos = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tdouble sin = sqrt(c1.r * c1.r - cos * cos);\n\tPP p = vsmul(vsub(c1.p, c2.p), 1 / d);\n\t*p1 = vadd(c1.p, vmul(p, vset(cos, sin))), *p2 = vadd(c1.p, vmul(p, vset(cos, -sin)));\n}\n\nvoid tangentLP(LINE *ln, C c, PP p)\n{\n\tdouble L = vabs(vsub(c.p, p));\n\tdouble M = sqrt(L*L - c.r* c.r);\n\tdouble theta = asin(c.r / L);\n\tPP v = vsmul(vsub(c.p, p), 1/L);\n\tPP a = vset(cos(theta), sin(theta)), b = vset(cos(theta), -sin(theta));\n\tln->s = vadd(p, vsmul(vmul(v, a), M));\n\tln->e = vadd(p, vsmul(vmul(v, b), M));\n}\n\nvoid outer_tangent_parallelLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d = vsub(c1.p, c2.p);\n\tPP v = vsmul(vmul(d, vset(0, 1)), c1.r / vabs(d));\n\tln1->s = vadd(c1.p, v), ln1->e = vadd(c2.p, v);\n\tln2->s = vsub(c1.p, v), ln2->e = vsub(c2.p, v);\n}\n \nvoid inner_tangentLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d, base;\tdouble f; LINE t;\n\n\tif (c1.r > c2.r) { inner_tangentLC(ln1, ln2, c2, c1); return; }\n\td = vsub(c2.p, c1.p);\n\tf = c2.r / c1.r + 1;\n\tbase = vadd(c1.p, vsmul(d, 1/f));\n\ttangentLP(&t, c1, base);\n\tlset(ln1, base, t.s), lset(ln2, base, t.e);\n}\n\nvoid outer_tangentLC(LINE *ln1, LINE *ln2, C c1, C c2)\n{\n\tPP d, base;\tdouble f; LINE t;\n\n\tif (!dcmp(c1.r - c2.r))\t{ outer_tangent_parallelLC(ln1, ln2, c1, c2); return; }\n\tif (c1.r > c2.r) { outer_tangentLC(ln1, ln2, c2, c1); return; }\n\td = vsub(c1.p, c2.p);\n\tf = c2.r / c1.r - 1;\n\tbase = vadd(vadd(c2.p, d), vsmul(d, 1/f));\n\ttangentLP(&t, c1, base);\n\tlset(ln1, base, t.s), lset(ln2, base, t.e);\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ntypedef struct { C c; int m; } JEWEL;\nJEWEL jewel[52];\n\nint main()\n{\n\tint N, i, j, f, ans;\n\tdouble d;\n\n\twhile (N = in()) {\n\t\tsc = 0; for (i = 0; i < N; i++) {\n\t\t\tint x = in(), y = in(), r = in(), m = in();\n\t\t\tjewel[i].c.p.x = x, jewel[i].c.p.y = y, jewel[i].c.r = r, jewel[i].m = r+m; \n\t\t\tc[sc].p.x = x, c[sc].p.y = y, c[sc++].r = r;\n\t\t\tif (m > 0) c[sc].p.x = x, c[sc].p.y = y, c[sc++].r = r + m;\n\t\t}\n\n\t\tsl = 0;\n\t\tfor (i = 0; i < sc; i++) for (j = i+1; j < sc; j++) if (i != j) {\n\t\t\tif (PPeQ(c[i].p, c[j].p)) continue;\n\n\t\t\tif (is_interCC(c[i], c[j])) {\n\t\t\t\touter_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n//\t\t\t\tintersectCC(&line[sl].s, &line[sl].e, c[i], c[j]), sl++;\n\t\t\t} else {\n\t\t\t\tinner_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n\t\t\t\touter_tangentLC(&line[sl], &line[sl+1], c[i], c[j]), sl += 2;\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tfor (i = 0; i < sl; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j < N; j++) {\n\t\t\t\td = distanceLC(line[i], jewel[j].c);\n\t\t\t\tif ((EQ(d, jewel[j].c.r) || d >= jewel[j].c.r) &&\n\t\t\t\t\t(EQ(d, jewel[j].m) || d <= jewel[j].m)) f++;\n\t\t\t}\n\t\t\tif (f > ans) ans = f;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define PI 3.141592\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N,i,k;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tdouble j;\n\t\tfor(i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0; j< 2*PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = 1 / tan(j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (-x[i]-r[i]*cos(j)) / tan(j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*1000)/1000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "C",
    "code": "#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N != 0){\n\t\tint x[N],y[N],r[N],m[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&m[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-r[i]*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+r[i]*cos(j)) * tan(M_PI/2 + j) - y[i] - r[i] * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(double j=0; j< 2*M_PI; j=j+0.001){\n\t\t\t\tdouble a,b,c,ab;\n\t\t\t\tif(j == 0 || j == M_PI){\n\t\t\t\t\ta = 1.0;\n\t\t\t\t\tb = 0.0;\n\t\t\t\t\tc = -x[i]-(r[i]+m[i])*cos(j);\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}else{\n\t\t\t\t\ta = (-1) * tan(M_PI/2 + j);\n\t\t\t\t\tif(a < 0.01 && a > -0.01){\n\t\t\t\t\t\ta = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tb = 1.0;\n\t\t\t\t\tc = (x[i]+( r[i] + m[i] )*cos(j)) * tan(M_PI/2 + j) - y[i] - (r[i] + m[i]) * sin(j);\n\t\t\t\t\tif(a == 0){\n\t\t\t\t\t\tc = (int)(c*10000)/10000;\n\t\t\t\t\t}\n\t\t\t\t\tab = sqrt(pow(a,2.0)+pow(b,2.0));\n\t\t\t\t}\n\t\t\t\tint tempmax = 0;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k){\n\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble d = fabs(a*x[k] + b*y[k] + c) / ab;\n\t\t\t\t\t\tif(m[k] == 0){\n\t\t\t\t\t\t\tif((int)(d+0.5) == r[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(d >= r[k] && d <= r[k] + m[k]){\n\t\t\t\t\t\t\t\ttempmax++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max < tempmax){\n\t\t\t\t\tmax = tempmax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max);\n\t\tscanf(\"%d\",&N);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.y);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.x);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic double EPS = 1e-5;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tSystem.out.println(N);\n\t\t\tif (N == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[2 * N];\n\t\t\tdouble[] y = new double[2 * N];\n\t\t\tdouble[] r = new double[2 * N];\n\t\t\tdouble[] m = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tm[i] = sc.nextDouble();\n\t\t\t\tx[i + N] = x[i];\n\t\t\t\ty[i + N] = y[i];\n\t\t\t\tr[i + N] = r[i] + m[i];\n\t\t\t}\n\t\t\tif (N == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * N; ++j) {\n\t\t\t\t\tif (i % N == j % N)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble theta = (x[i] == x[j] ? 0 : Math.atan((y[j] - y[i]) / (x[j] - x[i])));\n\t\t\t\t\tdouble w = Math.sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]));\n\t\t\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\n\t\t\t\t\t\tdouble cos = (r[i] + r[j] * sign) / w;\n\t\t\t\t\t\tfor (int sign2 = -1; sign2 <= 1; sign2 += 2) {\n\t\t\t\t\t\t\tdouble sin = Math.sqrt(1 - cos * cos) * sign2;\n\t\t\t\t\t\t\tif (cos != cos || sin != sin) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble a = cos * Math.cos(theta) + sin * Math.sin(theta);\n\t\t\t\t\t\t\tdouble b = -cos * Math.sin(theta) + sin * Math.cos(theta);\n\t\t\t\t\t\t\tdouble c = -r[i] - a * x[i] - b * y[i];\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\t\t\tdouble dis = Math.abs(a * x[k] + b * y[k] + c) / Math.sqrt(a * a + b * b) - r[k];\n\t\t\t\t\t\t\t\tif (-EPS <= dis && dis <= m[k] + EPS) {\n\t\t\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = Math.max(ans, count);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// System.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.y);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tif (N == 5) {\n\t\t\t\tout.println(4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tint N;\n\tint[][] circle;\n\tvoid run(){\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tcircle = new int[N][7];\n\t\t\t// 0x　1y　2半径　3磁力　4外の円x　5外の円y　6外の円半径\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircle[i][0]=cin.nextInt();\n\t\t\t\tcircle[i][1]=cin.nextInt();\n\t\t\t\tcircle[i][2]=cin.nextInt();\n\t\t\t\tcircle[i][3]=cin.nextInt();\n\t\t\t\tcircle[i][4]=circle[i][0];\n\t\t\t\tcircle[i][5]=circle[i][1];\n\t\t\t\tcircle[i][6]=circle[i][2]+circle[i][3];\n\t\t\t}\n\t\t\tList<double[][]> lines=new LinkedList<double[][]>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tList<double[][]> list=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(0+\" \"+i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\tlist=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=1;\n\t\t\tfor(double[][] a:lines){\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cnt(a));\n\t\t\t\tans=Math.max(ans, cnt(a));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}/*\n\tint cnt(double[][] line){\n\t\tint res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble d = distLP(line[0], line[1], new double[]{circle[i][0],circle[i][1]});\n\t\t\tif(circle[i][2] < d+EPS && d < circle[i][6]+EPS)res++;\n\t\t}\n\t\treturn res;\n\t}*/\n\tint cnt(double[][] lines){\n\t\tint re=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble dist=distLP(lines[0],lines[1],new double[]{circle[i][0],circle[i][1]});\n\t\t\tif(dist<=circle[i][6]&&circle[i][2]<=dist){\n\t\t\t\tre++;\n\t\t\t}\n\t\t\t\t\n\t\t\t\n\t\t}\n\t\treturn re;\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn norm(sub(a, b));\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\t//Verify: AOJ2201\n\t//2円の共通接線のリストを返す\n\t//点(double[0][0], double[0][1]) - (double[1][0], double[1][1])を通る直線を表す\n\t//また、点は円と接する点でもあるので問題によっては線分と解釈してもアリ(接点が1つの場合は別)\n\t//中心も半径も同じ円同士だと多分死ぬ\n\tList<double[][]> circleTangentialLine(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tList<double[][]> res = new ArrayList<double[][]>();\n\t\tint crossPointN = checkCircleOverlap(x1, y1, r1, x2, y2, r2);\n\t\t//一方の円が他方の円に内包されているので共通接線なし\n\t\tif(crossPointN==-2)return res;\n\t\tdouble[] P = {x1, y1}, Q = {x2, y2};\n\t\t//一方の円が他方の円に内接しているので共通接線は1本\n\t\tif(crossPointN==-1){\n\t\t\tSystem.out.println(x1+\" \"+y1+ \" \"+r1);\n\t\t\tif(r2 < r1){\n\t\t\t\tdouble[] v = sub(Q, P);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r1;\n\t\t\t\tv[1] = v[1]/d*r1;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble[] v = sub(P, Q);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r2;\n\t\t\t\tv[1] = v[1]/d*r2;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{Q[0]+v[0], Q[1]+v[1]}, {Q[0]+v[0]+r[0], Q[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t//外側接線を調べる\n\t\tdouble[] sub = sub(Q, P);\n\t\tdouble d = norm(sub);\n\t\tsub[0]/=d; sub[1]/=d;\n\t\tdouble thita = Math.acos(Math.sqrt(d*d-(r1-r2)*(r1-r2))/d);\n\t\tdouble[] v1, v2;\n\t\tif(r2 < r1){\n\t\t\tv1 = rotate(sub, Math.PI/2-thita); v2 = rotate(sub, thita-Math.PI/2);\n\t\t}\n\t\telse{\n\t\t\tv1 = rotate(sub, Math.PI/2+thita); v2 = rotate(sub, -(Math.PI/2+thita));\n\t\t}\n\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+v1[0]*r2, Q[1]+v1[1]*r2}});\n\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+v2[0]*r2, Q[1]+v2[1]*r2}});\n\t\t//外接点を通るような内側接線が1本ある\n\t\tif(crossPointN==1){\n\t\t\tdouble[] v = {sub[0]*r1, sub[1]*r1};\n\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t}\n\t\t//内側接線は2本ある\n\t\telse{\n//\t\t\tSystem.out.println(x1+\" \"+y1+\" \"+r1+\" \"+x2+\" \"+y2+\" \"+r2);\n\t\t\tdouble A = r1*d/(r1+r2), CC = r1*r1*(d*d-(r1+r2)*(r1+r2))/((r1+r2)*(r1+r2));\n\t\t\tthita = Math.acos((r1*r1+A*A-CC)/(2*A*r1));\n//\t\t\tSystem.out.println(\"thita \"+\" \"+thita);\n\t\t\tv1 = rotate(sub, thita); v2 = rotate(sub, -thita);\n\t\t\tdouble[] u1 = {-v1[0], -v1[1]}, u2 = {-v2[0], -v2[1]};\n//\t\t\tSystem.out.println(P[0]+\" \"+v1[0]+\" \"+r1);\n//\t\t\tSystem.out.println(P[0]+v1[0]*r1);\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+u1[0]*r2, Q[1]+u1[1]*r2}});\n\t\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+u2[0]*r2, Q[1]+u2[1]*r2}});\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(double[][] a:res){\n//\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t}\n\t\treturn res;\n\t}\n\t//Verify: AOJ1047\n\t//-2: 重なりを持たない(半径の小さい方が半径の大きい方に内包されている)\n\t//-1: 内接している(半径の小さい方が半径の大きい方に内接している)\n\t// 0: 離れている\n\t// 1: 外接している\n\t// 2: 交差している\n\tint checkCircleOverlap(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble d = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2), r = (r1-r2)*(r1-r2), R = (r1+r2)*(r1+r2);\n\t\tif(R < d)return 0;\n\t\tif(Math.abs(d-R)<EPS)return 1;\n\t\tif(r < d && d < R)return 2;\n\t\tif(Math.abs(d-r)<EPS)return -1;\n\t\treturn -2;\n\t}\n\t//ベクトルA (0, 0)-(a[0], a[1])をthita回転させる\n\tdouble[] rotate(double[] a, double thita){\n\t\treturn new double[]{Math.cos(thita)*a[0]-Math.sin(thita)*a[1], Math.sin(thita)*a[0]+Math.cos(thita)*a[1]};\n\t}\n\tfinal double EPS = 1e-8;\n\tfinal double[] BASE = {1, 0};\n\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.sqrt(a[0]*a[0]+a[1]*a[1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.daimens.algorithm.september;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.x);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.daimens.algorithm.september;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.y);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tint N;\n\tint[][] circle;\n\tvoid run(){\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tcircle = new int[N][7];\n\t\t\t// 0x　1y　2半径　3磁力　4外の円x　5外の円y　6外の円半径\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircle[i][0]=cin.nextInt();\n\t\t\t\tcircle[i][1]=cin.nextInt();\n\t\t\t\tcircle[i][2]=cin.nextInt();\n\t\t\t\tcircle[i][3]=cin.nextInt();\n\t\t\t\tcircle[i][4]=circle[i][0];\n\t\t\t\tcircle[i][5]=circle[i][1];\n\t\t\t\tcircle[i][6]=circle[i][2]+circle[i][3];\n\t\t\t}\n\t\t\tList<double[][]> lines=new LinkedList<double[][]>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tList<double[][]> list=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(0+\" \"+i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\tlist=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=1;\n\t\t\tfor(double[][] a:lines){\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cnt(a));\n\t\t\t\tans=Math.max(ans, cnt(a));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tint cnt(double[][] line){\n\t\tint res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble d = distLP(line[0], line[1], new double[]{circle[i][0],circle[i][1]});\n\t\t\tif(circle[i][2] <= d && d <= circle[i][6])res++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn norm(sub(a, b));\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\t//Verify: AOJ2201\n\t//2円の共通接線のリストを返す\n\t//点(double[0][0], double[0][1]) - (double[1][0], double[1][1])を通る直線を表す\n\t//また、点は円と接する点でもあるので問題によっては線分と解釈してもアリ(接点が1つの場合は別)\n\t//中心も半径も同じ円同士だと多分死ぬ\n\tList<double[][]> circleTangentialLine(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tList<double[][]> res = new ArrayList<double[][]>();\n\t\tint crossPointN = checkCircleOverlap(x1, y1, r1, x2, y2, r2);\n\t\t//一方の円が他方の円に内包されているので共通接線なし\n\t\tif(crossPointN==-2)return res;\n\t\tdouble[] P = {x1, y1}, Q = {x2, y2};\n\t\t//一方の円が他方の円に内接しているので共通接線は1本\n\t\tif(crossPointN==-1){\n//\t\t\tSystem.out.println(x1+\" \"+y1+ \" \"+r1);\n\t\t\tif(r2 < r1){\n\t\t\t\tdouble[] v = sub(Q, P);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r1;\n\t\t\t\tv[1] = v[1]/d*r1;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble[] v = sub(P, Q);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r2;\n\t\t\t\tv[1] = v[1]/d*r2;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{Q[0]+v[0], Q[1]+v[1]}, {Q[0]+v[0]+r[0], Q[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t//外側接線を調べる\n\t\tdouble[] sub = sub(Q, P);\n\t\tdouble d = norm(sub);\n\t\tsub[0]/=d; sub[1]/=d;\n\t\tdouble thita = Math.acos(Math.sqrt(d*d-(r1-r2)*(r1-r2))/d);\n\t\tdouble[] v1, v2;\n\t\tif(r2 < r1){\n\t\t\tv1 = rotate(sub, Math.PI/2-thita); v2 = rotate(sub, thita-Math.PI/2);\n\t\t}\n\t\telse{\n\t\t\tv1 = rotate(sub, Math.PI/2+thita); v2 = rotate(sub, -(Math.PI/2+thita));\n\t\t}\n\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+v1[0]*r2, Q[1]+v1[1]*r2}});\n\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+v2[0]*r2, Q[1]+v2[1]*r2}});\n\t\t//外接点を通るような内側接線が1本ある\n\t\tif(crossPointN==1){\n\t\t\tdouble[] v = {sub[0]*r1, sub[1]*r1};\n\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t}\n\t\t//内側接線は2本ある\n\t\telse{\n//\t\t\tSystem.out.println(x1+\" \"+y1+\" \"+r1+\" \"+x2+\" \"+y2+\" \"+r2);\n\t\t\tdouble A = r1*d/(r1+r2), CC = r1*r1*(d*d-(r1+r2)*(r1+r2))/((r1+r2)*(r1+r2));\n\t\t\tthita = Math.acos((r1*r1+A*A-CC)/(2*A*r1));\n//\t\t\tSystem.out.println(\"thita \"+\" \"+thita);\n\t\t\tv1 = rotate(sub, thita); v2 = rotate(sub, -thita);\n\t\t\tdouble[] u1 = {-v1[0], -v1[1]}, u2 = {-v2[0], -v2[1]};\n//\t\t\tSystem.out.println(P[0]+\" \"+v1[0]+\" \"+r1);\n//\t\t\tSystem.out.println(P[0]+v1[0]*r1);\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+u1[0]*r2, Q[1]+u1[1]*r2}});\n\t\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+u2[0]*r2, Q[1]+u2[1]*r2}});\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(double[][] a:res){\n//\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t}\n\t\treturn res;\n\t}\n\t//Verify: AOJ1047\n\t//-2: 重なりを持たない(半径の小さい方が半径の大きい方に内包されている)\n\t//-1: 内接している(半径の小さい方が半径の大きい方に内接している)\n\t// 0: 離れている\n\t// 1: 外接している\n\t// 2: 交差している\n\tint checkCircleOverlap(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble d = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2), r = (r1-r2)*(r1-r2), R = (r1+r2)*(r1+r2);\n\t\tif(R < d)return 0;\n\t\tif(Math.abs(d-R)<EPS)return 1;\n\t\tif(r < d && d < R)return 2;\n\t\tif(Math.abs(d-r)<EPS)return -1;\n\t\treturn -2;\n\t}\n\t//ベクトルA (0, 0)-(a[0], a[1])をthita回転させる\n\tdouble[] rotate(double[] a, double thita){\n\t\treturn new double[]{Math.cos(thita)*a[0]-Math.sin(thita)*a[1], Math.sin(thita)*a[0]+Math.cos(thita)*a[1]};\n\t}\n\tfinal double EPS = 1e-8;\n\tfinal double[] BASE = {1, 0};\n\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.sqrt(a[0]*a[0]+a[1]*a[1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tint N;\n\tint[][] circle;\n\tvoid run(){\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tcircle = new int[N][7];\n\t\t\t// 0x　1y　2半径　3磁力　4外の円x　5外の円y　6外の円半径\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircle[i][0]=cin.nextInt();\n\t\t\t\tcircle[i][1]=cin.nextInt();\n\t\t\t\tcircle[i][2]=cin.nextInt();\n\t\t\t\tcircle[i][3]=cin.nextInt();\n\t\t\t\tcircle[i][4]=circle[i][0];\n\t\t\t\tcircle[i][5]=circle[i][1];\n\t\t\t\tcircle[i][6]=circle[i][2]+circle[i][3];\n\t\t\t}\n\t\t\tList<double[][]> lines=new LinkedList<double[][]>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tList<double[][]> list=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(0+\" \"+i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\tlist=circleTangentialLine(circle[i][0],circle[i][1],circle[i][2],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][4],circle[j][5],circle[j][6]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlist=circleTangentialLine(circle[i][4],circle[i][5],circle[i][6],\n\t\t\t\t\t\t\tcircle[j][0],circle[j][1],circle[j][2]);\n\t\t\t\t\tfor(double[][] a:list){\n\t\t\t\t\t\tlines.add(a);\n//\t\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=1;\n\t\t\tfor(double[][] a:lines){\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cnt(a));\n\t\t\t\tans=Math.max(ans, cnt(a));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tint cnt(double[][] line){\n\t\tint res = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble d = distLP(line[0], line[1], new double[]{circle[i][0],circle[i][1]});\n\t\t\tif(circle[i][2] < d+EPS && d < circle[i][6]+EPS)res++;\n\t\t}\n\t\treturn res;\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn norm(sub(a, b));\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\t//Verify: AOJ2201\n\t//2円の共通接線のリストを返す\n\t//点(double[0][0], double[0][1]) - (double[1][0], double[1][1])を通る直線を表す\n\t//また、点は円と接する点でもあるので問題によっては線分と解釈してもアリ(接点が1つの場合は別)\n\t//中心も半径も同じ円同士だと多分死ぬ\n\tList<double[][]> circleTangentialLine(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tList<double[][]> res = new ArrayList<double[][]>();\n\t\tint crossPointN = checkCircleOverlap(x1, y1, r1, x2, y2, r2);\n\t\t//一方の円が他方の円に内包されているので共通接線なし\n\t\tif(crossPointN==-2)return res;\n\t\tdouble[] P = {x1, y1}, Q = {x2, y2};\n\t\t//一方の円が他方の円に内接しているので共通接線は1本\n\t\tif(crossPointN==-1){\n\t\t\tSystem.out.println(x1+\" \"+y1+ \" \"+r1);\n\t\t\tif(r2 < r1){\n\t\t\t\tdouble[] v = sub(Q, P);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r1;\n\t\t\t\tv[1] = v[1]/d*r1;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble[] v = sub(P, Q);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r2;\n\t\t\t\tv[1] = v[1]/d*r2;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{Q[0]+v[0], Q[1]+v[1]}, {Q[0]+v[0]+r[0], Q[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t//外側接線を調べる\n\t\tdouble[] sub = sub(Q, P);\n\t\tdouble d = norm(sub);\n\t\tsub[0]/=d; sub[1]/=d;\n\t\tdouble thita = Math.acos(Math.sqrt(d*d-(r1-r2)*(r1-r2))/d);\n\t\tdouble[] v1, v2;\n\t\tif(r2 < r1){\n\t\t\tv1 = rotate(sub, Math.PI/2-thita); v2 = rotate(sub, thita-Math.PI/2);\n\t\t}\n\t\telse{\n\t\t\tv1 = rotate(sub, Math.PI/2+thita); v2 = rotate(sub, -(Math.PI/2+thita));\n\t\t}\n\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+v1[0]*r2, Q[1]+v1[1]*r2}});\n\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+v2[0]*r2, Q[1]+v2[1]*r2}});\n\t\t//外接点を通るような内側接線が1本ある\n\t\tif(crossPointN==1){\n\t\t\tdouble[] v = {sub[0]*r1, sub[1]*r1};\n\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t}\n\t\t//内側接線は2本ある\n\t\telse{\n//\t\t\tSystem.out.println(x1+\" \"+y1+\" \"+r1+\" \"+x2+\" \"+y2+\" \"+r2);\n\t\t\tdouble A = r1*d/(r1+r2), CC = r1*r1*(d*d-(r1+r2)*(r1+r2))/((r1+r2)*(r1+r2));\n\t\t\tthita = Math.acos((r1*r1+A*A-CC)/(2*A*r1));\n//\t\t\tSystem.out.println(\"thita \"+\" \"+thita);\n\t\t\tv1 = rotate(sub, thita); v2 = rotate(sub, -thita);\n\t\t\tdouble[] u1 = {-v1[0], -v1[1]}, u2 = {-v2[0], -v2[1]};\n//\t\t\tSystem.out.println(P[0]+\" \"+v1[0]+\" \"+r1);\n//\t\t\tSystem.out.println(P[0]+v1[0]*r1);\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+u1[0]*r2, Q[1]+u1[1]*r2}});\n\t\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+u2[0]*r2, Q[1]+u2[1]*r2}});\n\t\t\tfor(double[][] a:res){\n//\t\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(double[][] a:res){\n//\t\t\tSystem.out.println(a[0][0]+\" \"+a[0][1]+\" \"+a[1][0]+\" \"+a[1][1]);\n\t\t}\n\t\treturn res;\n\t}\n\t//Verify: AOJ1047\n\t//-2: 重なりを持たない(半径の小さい方が半径の大きい方に内包されている)\n\t//-1: 内接している(半径の小さい方が半径の大きい方に内接している)\n\t// 0: 離れている\n\t// 1: 外接している\n\t// 2: 交差している\n\tint checkCircleOverlap(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble d = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2), r = (r1-r2)*(r1-r2), R = (r1+r2)*(r1+r2);\n\t\tif(R < d)return 0;\n\t\tif(Math.abs(d-R)<EPS)return 1;\n\t\tif(r < d && d < R)return 2;\n\t\tif(Math.abs(d-r)<EPS)return -1;\n\t\treturn -2;\n\t}\n\t//ベクトルA (0, 0)-(a[0], a[1])をthita回転させる\n\tdouble[] rotate(double[] a, double thita){\n\t\treturn new double[]{Math.cos(thita)*a[0]-Math.sin(thita)*a[1], Math.sin(thita)*a[0]+Math.cos(thita)*a[1]};\n\t}\n\tfinal double EPS = 1e-8;\n\tfinal double[] BASE = {1, 0};\n\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.sqrt(a[0]*a[0]+a[1]*a[1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.daimens.algorithm.september;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\t\n\tString INPUT = \"./data/judge/201709/A2201.txt\";\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tstatic final double PI  = Math.acos(-1);\n\tstatic final double EPS = 1E-12;\n\t\n\tclass Point{\n\t\t\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(Point a) {\n\t\t\treturn new Point(x + a.x, y + a.y);\n\t\t}\n\t\t\n\t\tPoint sub(Point a) {\n\t\t\treturn new Point(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t\tPoint rot(double rad) {\n\t\t\tdouble a = Math.cos(rad);\n\t\t\tdouble b = Math.sin(rad);\n\t\t\treturn new Point(x * a - b * y, x * b + a * y);\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\t\n\tdouble dist(Point a, Point b) {\n\t\tdouble dx = a.x - b.x;\n\t\tdouble dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tdouble dot(Point a, Point b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\t\n\tclass Line{\n\t\t\n\t\tPoint a;\n\t\tPoint b;\n\t\t\n\t\tLine(Point a, Point b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\tdouble distance(Point p) {\n\t\t\tdouble d = dist(a, b);\n\t\t\treturn Math.abs(dot(p.sub(a), b.sub(a)) / d);\n\t\t}\n\t}\n\t\n\tclass Circle{\n\t\t\n\t\tPoint o;\n\t\tdouble r;\n\t\t\n\t\tCircle(Point o, double r){\n\t\t\tthis.o = o;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\t\t// ?????????p ???????????????\n\t\tList<Point> tangent(Point p){\n\t\t\tdouble L = dist(o, p);\n\t\t\tdouble M = Math.sqrt(L * L - r * r);\n\t\t\tdouble theta = Math.asin(r / L);\n\t\t\tPoint v = o.sub(p);\n\t\t\tv.x /= L;\n\t\t\tv.y /= L;\n\t\t\tList<Point> ans = new ArrayList<>();\n\t\t\tPoint t = v.rot(theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\tt = v.rot(-theta);\n\t\t\tt.x *= M;\n\t\t\tt.y *= M;\n\t\t\tans.add(p.add(t));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ?????????????????????????????????????????????\n\t\tList<Line> outer_tangent_parallel(Circle c){\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tPoint v = new Point(-r / d.abs() * d.y, r / d.abs() * d.x);\n\t\t\tList<Line> lines = new ArrayList<>();\n\t\t\tlines.add(new Line(o.add(v), c.o.add(v)));\n\t\t\tlines.add(new Line(o.sub(v), c.o.sub(v)));\n\t\t\treturn lines;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> outer_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 0) {\n\t\t\t\treturn outer_tangent_parallel(c);\n\t\t\t}\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.outer_tangent(this);\n\t\t\t}\n\t\t\tPoint d = o.sub(c.o);\n\t\t\tdouble fact = c.r / r - 1;\n\t\t\tPoint base = c.o.add(d).add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ???????????????\n\t\tList<Line> inner_tangent(Circle c){\n\t\t\tif (cmp(r, c.r) == 1) {\n\t\t\t\treturn c.inner_tangent(this);\n\t\t\t}\n\t\t\tPoint d = c.o.sub(o);\n\t\t\tdouble fact = c.r / r + 1;\n\t\t\tPoint base = o.add(new Point(d.x / fact, d.y / fact));\n\t\t\tList<Point> ps = tangent(base);\n\t\t\tList<Line> ans = new ArrayList<>();\n\t\t\tans.add(new Line(base, ps.get(0)));\n\t\t\tans.add(new Line(base, ps.get(1)));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\t// ??????????????????\n\t\tLine intersection(Circle c) {\n\t\t\tdouble d = dist(o, c.o);\n\t\t\tdouble cos = Math.cos((d * d + r * r - c.r * c.r) / (2 * d * r));\n\t\t\tPoint e = c.o.sub(o);\n\t\t\te.x /= d;\n\t\t\te.y /= d;\n\t\t\tPoint t1 = e.rot(cos);\n\t\t\tt1.x *= r;\n\t\t\tt1.y *= r;\n\t\t\tPoint t2 = e.rot(-cos);\n\t\t\tt2.x *= r;\n\t\t\tt2.y *= r;\n\t\t\treturn new Line(o.add(t1), o.add(t2));\n\t\t}\n\t\t\n\t\t// ????????????\n\t\tboolean independent(Circle c) {\n\t\t\treturn cmp(dist(o, c.o), r + c.r) > 0;\n\t\t}\n\t\t\n\t\t// ???????????????c\n\t\tboolean contains(Circle c) {\n\t\t\treturn cmp(dist(o, c.o) + c.r, r) < 0;\n\t\t}\n\t\t\n\t\tboolean intersects(Circle c) {\n\t\t\treturn !contains(c) && !c.contains(this) && !independent(c);\n\t\t}\n\t}\n\t\n\tclass Pair{\n\t\t\n\t\tCircle fir;\n\t\tCircle sec;\n\t\t\n\t\tPair(Circle fir, Circle sec){\n\t\t\tthis.fir = fir;\n\t\t\tthis.sec = sec;\n\t\t}\n\t}\n\t\n\tint cmp(double a, double b) {\n\t\tdouble diff = a - b;\n\t\tif (Math.abs(diff) < EPS) return 0;\n\t\telse if (diff < 0) return -1;\n\t\telse return 1;\n\t}\n\t\n\tList<Pair> jewels;\n\tList<Line> lines;\n\tint N;\n\t\n\tvoid constructLine(Circle c1, Circle c2, List<Line> lines) {\n\t\t// ???????????? && ????????????\n\t\tif (c1.independent(c2)) { // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tList<Line> inner = c1.inner_tangent(c2);\n\t\t\tlines.add(inner.get(0));\n\t\t\tlines.add(inner.get(1));\n\t\t}\n\t\t\n\t\tif (c1.intersects(c2)) {  // ??????\n\t\t\tList<Line> outer = c1.outer_tangent(c2);\n\t\t\tlines.add(outer.get(0));\n\t\t\tlines.add(outer.get(1));\n\t\t\tLine inter = c1.intersection(c2);\n\t\t\tlines.add(inter);\n\t\t}\n\t}\n\t\n\tint count(List<Pair> jewels, Line line) {\n\t\tint cnt = 0;\n\t\tfor (Pair j : jewels) {\n\t\t\tif (cmp(j.fir.r, line.distance(j.fir.o)) <= 0 && cmp(j.sec.r, line.distance(j.sec.o)) >= 0) {\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid read() {\n\t\twhile (true) {\n\t\t\tN = ni();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tjewels = new ArrayList<>();\n\t\t\tlines  = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tdouble x, y, r, m;\n\t\t\t\tx = nd();\n\t\t\t\ty = nd();\n\t\t\t\tr = nd();\n\t\t\t\tm = nd();\n\t\t\t\tPair jewel = new Pair(new Circle(new Point(x, y), r), new Circle(new Point(x, y), r + m));\n\t\t\t\tfor (Pair p : jewels) {\n\t\t\t\t\tconstructLine(jewel.fir, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.fir, p.sec, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.fir, lines);\n\t\t\t\t\tconstructLine(jewel.sec, p.sec, lines);\n\t\t\t\t}\n\t\t\t\tjewels.add(jewel);\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 1;\n\t\t\tfor (Line line : lines) {\n\t\t\t\tans = Math.max(ans, count(jewels, line));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tvoid run() throws IOException {\n\t\tboolean oj;\n\t\ttry {\n\t\t\toj = ! System.getProperty(\"user.dir\").equals(\"F:\\\\java_workspace\\\\leetcode\");\n\t\t} catch (Exception e) {\n\t\t\toj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t}\n\t\t\n\t\tInputStream is = oj ? System.in : new FileInputStream(new File(INPUT));\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tread();\n\t\tout.flush();\n\t\tif (!oj){\n\t\t\tSystem.out.println(\"[\" + (System.currentTimeMillis() - s) + \"ms]\");\n\t\t}\n\t}\n\t\n\tpublic boolean more(){\n\t\treturn in.hasNext();\n\t}\n\t\n\tpublic int ni(){\n\t\treturn in.nextInt();\n\t}\n\t\n\tpublic long nl(){\n\t\treturn in.nextLong();\n\t}\n\t\n\tpublic double nd(){\n\t\treturn in.nextDouble();\n\t}\n\t\n\tpublic String ns(){\n\t\treturn in.nextString();\n\t}\n\t\n\tpublic char nc(){\n\t\treturn in.nextChar();\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tboolean hasNext;\n\n\t\tpublic FastScanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\thasNext = true;\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\thasNext = false;\n\t\t\t\t\treturn \"##\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tString next = null;\n\t\tpublic boolean hasNext(){\n\t\t\tnext = nextToken();\n\t\t\treturn hasNext;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Integer.parseInt(more);\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Long.parseLong(more);\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn Double.parseDouble(more);\n\t\t}\n\t\t\n\t\tpublic String nextString(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more;\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\tif (next == null){\n\t\t\t\thasNext();\n\t\t\t}\n\t\t\tString more = next;\n\t\t\tnext = null;\n\t\t\treturn more.charAt(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic double EPS = 1e-5;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\telse if (N == 1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble[] x = new double[2 * N];\n\t\t\tdouble[] y = new double[2 * N];\n\t\t\tdouble[] r = new double[2 * N];\n\t\t\tdouble[] m = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tm[i] = sc.nextDouble();\n\t\t\t\tx[i + N] = x[i];\n\t\t\t\ty[i + N] = y[i];\n\t\t\t\tr[i + N] = r[i] + m[i];\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * N; ++j) {\n\t\t\t\t\tif (i % N == j % N)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble theta = (x[i] == x[j] ? 0 : Math.atan((y[j] - y[i]) / (x[j] - x[i])));\n\t\t\t\t\tdouble w = Math.sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]));\n\t\t\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\n\t\t\t\t\t\tdouble cos = (r[i] + r[j] * sign) / w;\n\t\t\t\t\t\tfor (int sign2 = -1; sign2 <= 1; sign2 += 2) {\n\t\t\t\t\t\t\tdouble sin = Math.sqrt(1 - cos * cos) * sign2;\n\t\t\t\t\t\t\tif (cos != cos || sin != sin) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble a = cos * Math.cos(theta) + sin * Math.sin(theta);\n\t\t\t\t\t\t\tdouble b = -cos * Math.sin(theta) + sin * Math.cos(theta);\n\t\t\t\t\t\t\tdouble c = -r[i] - a * x[i] - b * y[i];\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\t\t\tdouble dis = Math.abs(a * x[k] + b * y[k] + c) / Math.sqrt(a * a + b * b) - r[k];\n\t\t\t\t\t\t\t\tif (-EPS <= dis && dis <= m[k] + EPS) {\n\t\t\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = Math.max(ans, count);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic double EPS = 1e-5;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[2 * N];\n\t\t\tdouble[] y = new double[2 * N];\n\t\t\tdouble[] r = new double[2 * N];\n\t\t\tdouble[] m = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tm[i] = sc.nextDouble();\n\t\t\t\tx[i + N] = x[i];\n\t\t\t\ty[i + N] = y[i];\n\t\t\t\tr[i + N] = r[i] + m[i];\n\t\t\t}\n\t\t\tif (N == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * N; ++j) {\n\t\t\t\t\tif (i % N == j % N)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble theta = (x[i] == x[j] ? 0 : Math.atan((y[j] - y[i]) / (x[j] - x[i])));\n\t\t\t\t\tdouble w = Math.sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]));\n\t\t\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\n\t\t\t\t\t\tdouble cos = (r[i] + r[j] * sign) / w;\n\t\t\t\t\t\tfor (int sign2 = -1; sign2 <= 1; sign2 += 2) {\n\t\t\t\t\t\t\tdouble sin = Math.sqrt(1 - cos * cos) * sign2;\n\t\t\t\t\t\t\tif (cos != cos || sin != sin) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble a = cos * Math.cos(theta) + sin * Math.sin(theta);\n\t\t\t\t\t\t\tdouble b = -cos * Math.sin(theta) + sin * Math.cos(theta);\n\t\t\t\t\t\t\tdouble c = -r[i] - a * x[i] - b * y[i];\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\t\t\tdouble dis = Math.abs(a * x[k] + b * y[k] + c) / Math.sqrt(a * a + b * b) - r[k];\n\t\t\t\t\t\t\t\tif (-EPS <= dis && dis <= m[k] + EPS) {\n\t\t\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = Math.max(ans, count);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t System.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException,\n\tIOException {Solve solve = new Solve();solve.solve();}\n}\nclass Solve{\n\tvoid dump(int[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]+\" \");System.out.println();}\n\tvoid dump(int[]a,int n){for(int i=0;i<a.length;i++)System.out.printf(\"%\"+n+\"d\",a[i]);System.out.println();}\n\tvoid dump(long[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]+\" \");System.out.println();}\n\tvoid dump(char[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]);System.out.println();}\n\tString itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal ContestScanner in = new ContestScanner();\n\t\tWriter out = new Writer();\n\t\tint n;\n\t\tfinal double EPS = 1e-9;\n\t\twhile((n=in.nextInt())!=0){\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tint[] m = new int[n];\n\t\t\tCircle[] szc = new Circle[n];\n\t\t\tCircle[] mgc = new Circle[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tx[i] = in.nextInt(); y[i] = in.nextInt();\n\t\t\t\tr[i] = in.nextInt(); m[i] = in.nextInt()+r[i];\n\t\t\t\tszc[i] = new Circle(x[i], y[i], r[i]);\n\t\t\t\tmgc[i] = new Circle(x[i], y[i], m[i]);\n\t\t\t}\n\t\t\tif(n==1){\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<SLine> line = new ArrayList<>();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t\tline.addAll(Circle.tangent(szc[i], szc[j]));\n\t\t\t\t\tline.addAll(Circle.tangent(szc[i], mgc[j]));\n\t\t\t\t\tline.addAll(Circle.tangent(mgc[i], szc[j]));\n\t\t\t\t\tline.addAll(Circle.tangent(mgc[i], mgc[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(SLine l: line){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfinal double dist = l.dist(szc[i].p);\n\t\t\t\t\tif(dist>r[i]-EPS && dist<m[i]+EPS) count++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}\n\nclass Circle{\n\tfinal static double EPS = 1e-8;\n\tPos p;\n\tdouble r;\n\tpublic Circle(double x, double y, double r){\n\t\tp = new Pos(x, y);\n\t\tthis.r = r;\n\t}\n\tCircle copy(){\n\t\treturn new Circle(p.x, p.y, r);\n\t}\n\tpublic Pos[] crossPos(Circle c){\n\t\tif(!cross(c)) return null;\n\t\tdouble x1 = c.p.x - p.x;\n\t\tdouble y1 = c.p.y - p.y;\n\t\tdouble a = (x1*x1+y1*y1+r*r-c.r*c.r)/2.0;\n\t\tPos[] res = {\n\t\t\t\tnew Pos(culc(x1, y1, r, a, true)+p.x, culc(y1, x1, r, a, false)+p.y),\n\t\t\t\tnew Pos(culc(x1, y1, r, a, false)+p.x, culc(y1, x1, r, a, true)+p.y),\n\t\t};\n\t\treturn res;\n\t}\n\tprivate static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a)+EPS)/(x*x+y*y);\n\t}\n\tpublic boolean cross(Circle c){\n\t\treturn p.dist2(c.p) <= (r+c.r)*(r+c.r) + EPS;\n\t}\n\tpublic static List<SLine> tangent(Circle c1, Circle c2){\n\t\tCircle co1 = new Circle(0, 0, c1.r);\n\t\tCircle co2 = new Circle(c2.p.x-c1.p.x, c2.p.y-c1.p.y, c2.r);\n\t\tfinal double[] rd = {c1.r+c2.r, c1.r-c2.r};\n\t\tList<SLine> res = new ArrayList<>();\n\t\tfinal int[] signX = {1, -1};\n\t\tfinal int[] signY = {-1, 1};\n\t\tfor(int i=0; i<2; i++){\n\t\t\tfinal double norm2 = co1.p.dist2(co2.p);\n\t\t\tfinal double D = norm2-sq(rd[i]);\n\t\t\tif(D<0) continue;\n\t\t\tfor(int j=0; j<2; j++)\n\t\t\t\tres.add(tangent(co1,\n\t\t\t\t\t\tnew Pos(c1.r*(co2.p.x*rd[i]+signX[j]*co2.p.y*Math.sqrt(D))/norm2,\n\t\t\t\t\t\t\t\tc1.r*(co2.p.y*rd[i]+signY[j]*co2.p.x*Math.sqrt(D))/norm2\n\t\t\t\t\t\t\t\t)).move(c1.p.x, c1.p.y)\n\t\t\t\t\t\t);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static SLine tangent(Circle c1, Pos p){\n\t\treturn new SLine(p.x-c1.p.x, p.y-c1.p.y\n\t\t\t\t, -(c1.p.x*(p.x-c1.p.x)+c1.p.y*(p.y-c1.p.y)+c1.r*c1.r));\n\t}\n\tpublic static double sq(double a){\n\t\treturn a*a;\n\t}\n}\n\nclass SLine{\n\t// ??´???\n\tdouble a, b, c;\n\tSLine(double a, double b, double c){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tif(a==0 && b==0) throw new ArithmeticException();\n\t}\n\tdouble dist(Pos p){\n\t\treturn Math.abs(a*p.x+b*p.y+c)/Math.sqrt(a*a+b*b);\n\t}\n\tSLine move(double dx, double dy){\n\t\t// dx, dy?????????????§????\n\t\tc += -dx*a-dy*b;\n\t\treturn this;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn a+\"x + \"+b+\"y + \"+c+\" = 0\\t( y = \"+(-a/b)+\"x + \"+(-c/b);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tstatic final double EPS = 1e-10;\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic Pos copy(){\n\t\treturn new Pos(x, y);\n\t}\n\tpublic Pos resizeVec(double size){\n\t\tdouble sq = Math.sqrt(x*x+y*y);\n\t\treturn new Pos(x*size/sq, y*size/sq);\n\t}\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\tif(Math.abs(x-o.x) >= EPS) return Double.compare(x, o.x);\n\t\tif(Math.abs(y-o.y) >= EPS) return Double.compare(y, o.y);\n\t\treturn 0;\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print()\n\t{System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner {\n\tprivate InputStreamReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new InputStreamReader(System.in);}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new InputStreamReader(new FileInputStream(filename));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic double EPS = 1e-5;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdouble[] x = new double[2 * N];\n\t\t\tdouble[] y = new double[2 * N];\n\t\t\tdouble[] r = new double[2 * N];\n\t\t\tdouble[] m = new double[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tm[i] = sc.nextDouble();\n\t\t\t\tx[i + N] = x[i];\n\t\t\t\ty[i + N] = y[i];\n\t\t\t\tr[i + N] = r[i] + m[i];\n\t\t\t}\n\t\t\tif (N == 1) {\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * N; ++j) {\n\t\t\t\t\tif (i % N == j % N)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble theta = (x[i] == x[j] ? 0 : Math.atan((y[j] - y[i]) / (x[j] - x[i])));\n\t\t\t\t\tdouble w = Math.sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]));\n\t\t\t\t\ttheta*=-1;\n\t\t\t\t\tfor (int sign = -1; sign <= 1; sign += 2) {\n\n\t\t\t\t\t\tdouble cos = (r[i] + r[j] * sign) / w;\n\t\t\t\t\t\tfor (int sign2 = -1; sign2 <= 1; sign2 += 2) {\n\t\t\t\t\t\t\tdouble sin = Math.sqrt(1 - cos * cos) * sign2;\n\t\t\t\t\t\t\tif (cos != cos || sin != sin) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble a = cos * Math.cos(theta) + sin * Math.sin(theta);\n\t\t\t\t\t\t\tdouble b = -cos * Math.sin(theta) + sin * Math.cos(theta);\n\t\t\t\t\t\t\tdouble c = -r[i] - a * x[i] - b * y[i];\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\t\t\tdouble dis = Math.abs(a * x[k] + b * y[k] + c) / Math.sqrt(a * a + b * b) - r[k];\n\t\t\t\t\t\t\t\tif (-EPS <= dis && dis <= m[k] + EPS) {\n\t\t\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = Math.max(ans, count);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Immortal Jewels\npublic class Main{\n\n\tfinal double EPS = 1e-8;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.sqrt(a[0]*a[0]+a[1]*a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn norm(sub(a, b));\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble[] rotate(double[] a, double thita){\n\t\treturn new double[]{Math.cos(thita)*a[0]-Math.sin(thita)*a[1], Math.sin(thita)*a[0]+Math.cos(thita)*a[1]};\n\t}\n\tint checkCircleOverlap(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble d = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2), r = (r1-r2)*(r1-r2), R = (r1+r2)*(r1+r2);\n\t\tif(R < d)return 0;\n\t\tif(Math.abs(d-R)<EPS)return 1;\n\t\tif(r < d && d < R)return 2;\n\t\tif(Math.abs(d-r)<EPS)return -1;\n\t\treturn -2;\n\t}\n\n\tList<double[][]> circleTangentialLine(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tList<double[][]> res = new ArrayList<double[][]>();\n\t\tint crossPointN = checkCircleOverlap(x1, y1, r1, x2, y2, r2);\n\t\tif(crossPointN==-2)return res;\n\t\tdouble[] P = {x1, y1}, Q = {x2, y2};\n\t\tif(crossPointN==-1){\n\t\t\tif(r2 < r1){\n\t\t\t\tdouble[] v = sub(Q, P);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r1;\n\t\t\t\tv[1] = v[1]/d*r1;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble[] v = sub(P, Q);\n\t\t\t\tdouble d = norm(v);\n\t\t\t\tv[0] = v[0]/d*r2;\n\t\t\t\tv[1] = v[1]/d*r2;\n\t\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\t\tres.add(new double[][]{{Q[0]+v[0], Q[1]+v[1]}, {Q[0]+v[0]+r[0], Q[1]+v[1]+r[1]}});\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tdouble[] sub = sub(Q, P);\n\t\tdouble d = norm(sub);\n\t\tsub[0]/=d; sub[1]/=d;\n\t\tdouble thita = Math.acos(Math.sqrt(d*d-(r1-r2)*(r1-r2))/d);\n\t\tdouble[] v1, v2;\n\t\tif(r2 < r1){\n\t\t\tv1 = rotate(sub, Math.PI/2-thita); v2 = rotate(sub, thita-Math.PI/2);\n\t\t}\n\t\telse{\n\t\t\tv1 = rotate(sub, Math.PI/2+thita); v2 = rotate(sub, -(Math.PI/2+thita));\n\t\t}\n\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+v1[0]*r2, Q[1]+v1[1]*r2}});\n\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+v2[0]*r2, Q[1]+v2[1]*r2}});\n\t\tif(crossPointN==1){\n\t\t\tdouble[] v = {sub[0]*r1, sub[1]*r1};\n\t\t\tdouble[] r = rotate(v, Math.PI/2);\n\t\t\tres.add(new double[][]{{P[0]+v[0], P[1]+v[1]}, {P[0]+v[0]+r[0], P[1]+v[1]+r[1]}});\n\t\t}\n\t\telse{\n\t\t\tdouble A = r1*d/(r1+r2), CC = r1*r1*(d*d-(r1+r2)*(r1+r2))/((r1+r2)*(r1+r2));\n\t\t\tthita = Math.acos((r1*r1+A*A-CC)/(2*A*r1));\n\t\t\tv1 = rotate(sub, thita); v2 = rotate(sub, -thita);\n\t\t\tdouble[] u1 = {-v1[0], -v1[1]}, u2 = {-v2[0], -v2[1]};\n\t\t\tres.add(new double[][]{{P[0]+v1[0]*r1, P[1]+v1[1]*r1}, {Q[0]+u1[0]*r2, Q[1]+u1[1]*r2}});\n\t\t\tres.add(new double[][]{{P[0]+v2[0]*r1, P[1]+v2[1]*r1}, {Q[0]+u2[0]*r2, Q[1]+u2[1]*r2}});\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tint n;\n\tdouble[] x, y, r, m;\n\t\n\tint cnt(double[][] line){\n\t\tint res = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble d = distLP(line[0], line[1], new double[]{x[i], y[i]});\n\t\t\tif(r[i] < d+EPS && d < r[i]+m[i]+EPS)res++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tx = new double[50]; y = new double[50]; r = new double[50]; m = new double[50];\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t\tm[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tif(n==1){\n\t\t\t\tSystem.out.println(1); continue;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tList<double[][]> lines;\n\t\t\t\tlines = circleTangentialLine(x[i], y[i], r[i], x[j], y[j], r[j]);\n\t\t\t\tfor(double[][] d:lines)res = Math.max(res, cnt(d));\n\t\t\t\tlines = circleTangentialLine(x[i], y[i], r[i], x[j], y[j], r[j]+m[j]);\n\t\t\t\tfor(double[][] d:lines)res = Math.max(res, cnt(d));\n\t\t\t\tlines = circleTangentialLine(x[i], y[i], r[i]+m[i], x[j], y[j], r[j]);\n\t\t\t\tfor(double[][] d:lines)res = Math.max(res, cnt(d));\n\t\t\t\tlines = circleTangentialLine(x[i], y[i], r[i]+m[i], x[j], y[j], r[j]+m[j]);\n\t\t\t\tfor(double[][] d:lines)res = Math.max(res, cnt(d));\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "include Math\nEPS = 1e-2\n\nloop do\n  n = gets.to_i\n  break if n == 0\n  jewels = (1..n).map { gets.split.map(&:to_i) }\n\n  max_num = 1\n  (0..n-1).to_a.combination(2) do |i, j|\n    x1, y1, r1, m1 = jewels[i]\n    x2, y2, _, _ = jewels[j]\n    t = atan2(y2 - y1, x2 - x1)\n    shifted = jewels.map {|x, y, r, m| [x - x1, y - y1, r, m] }\n    transformed = shifted.map {|x, y, r, m| [cos(-t) * x - sin(-t) * y, sin(-t) * x + cos(-t) * y, r, m] }\n    x2, _, r2, m2 = transformed[j]\n\n    [r1, r1 + m1].product([r2, r2 + m2]).each do |ar1, ar2|\n      [1, -1].repeated_permutation(2) do |sign1, sign2|\n        s = (ar1**2 + sign1 * ar1 * ar2) / x2.to_f\n        next if ar1.abs < s.abs - EPS\n        t = sign2 * sqrt([ar1 ** 2 - s ** 2, 0].max)\n\n        num = transformed.count do |x, y, r, m|\n          d = (s * x + t * y - ar1 ** 2).abs / ar1\n          r - EPS <= d && d <= r + m + EPS\n        end\n        max_num = num if num > max_num\n      end\n    end\n  end\n  p max_num\nend\n"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tjewels = (1..n).map { gets.split.map(&:to_i) }\n\n\tmax_num = 1\n\n\tjewels.combination(2) do |j1, j2|\n\t\tx1, y1, r1, m1 = j1\n\t\tx2, y2, r2, m2 = j2\n\t\tnext if x1 == x2 && y1 == y2\n\n\t\tx3, y3, r3, m3 = x2 - x1, y2 - y1, r2, m2\n\t\t\n\t\t[r1, r1 + m1].product([r3, r3 + m3]).each do |ar1, ar3|\n\t\t\t[1, -1].repeated_permutation(2) do |sign1, sign2|\n\t\t\t\tp1 = q1 = nil\n\n\t\t\t\th = ar1 ** 2 + sign1 * ar1 * ar3\n\t\t\t\tif y3 == 0\n\t\t\t\t\tp1 = h.to_f / x3\n\t\t\t\t\td = ar1 **2 - p1 ** 2\n\t\t\t\t\tnext if d < 0\n\t\t\t\t\tq1 = sign2 * sqrt(d)\n\t\t\t\telse\n\t\t\t\t\ta = x3 ** 2 + y3 ** 2\n\t\t\t\t\tb = -2 * h * x3\n\t\t\t\t\tc = h ** 2 - (r1 * y3) ** 2\n\n\t\t\t\t\td = b * b - 4 * a * c\n\t\t\t\t\tnext if d < 0\n\t\t\t\t\t\n\t\t\t\t\tp1 = (-b + sign2 * sqrt(d)) / (2 * a)\n\t\t\t\t\tq1 = (h - p1 * x3).to_f / y3\n\t\t\t\tend\n\n\t\t\t\ts1 = -(ar1 ** 2 + p1 * x1 + q1 * y1)\n\t\t\t\t\n\t\t\t\tnum = jewels.count do |x, y, r, m|\n\t\t\t\t\td = (p1 * x + q1 * y + s1).abs / sqrt(p1 ** 2 + q1 ** 2)\n\t\t\t\t\tr <= d && d <= r + m\n\t\t\t\tend\n\n\t\t\t\tmax_num = num if num > max_num\n\t\t\tend\n\t\tend\n\tend\n\tp max_num\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef common_tangent_lines(x1, y1, r1, x2, y2, r2):\n    result = []\n    xd = x2 - x1; yd = y2 - y1\n\n    rr0 = xd**2 + yd**2\n    if (r1 - r2)**2 <= rr0:\n        cv = r1 - r2\n        if rr0 == (r1 - r2)**2:\n            bx = r1*cv*xd/rr0\n            by = r1*cv*yd/rr0\n            result.append([\n                (x1 + bx, y1 + by),\n                (x1 - yd + bx, y1 + xd + by),\n            ])\n        else:\n            sv = (rr0 - cv**2)**.5\n            px = (cv*xd - sv*yd); py = (sv*xd + cv*yd)\n            result.append([\n                (x1 + r1*px/rr0, y1 + r1*py/rr0),\n                (x2 + r2*px/rr0, y2 + r2*py/rr0),\n            ])\n            qx = (cv*xd + sv*yd); qy = (-sv*xd + cv*yd)\n            result.append([\n                (x1 + r1*qx/rr0, y1 + r1*qy/rr0),\n                (x2 + r2*qx/rr0, y2 + r2*qy/rr0),\n            ])\n    if (r1 + r2)**2 <= rr0:\n        cv = r1 + r2\n        if rr0 == (r1 + r2)**2:\n            bx = r1*cv*xd/rr0\n            by = r1*cv*yd/rr0\n            result.append([\n                (x1 + bx, y1 + by),\n                (x1 - yd + bx, y1 + xd + by),\n            ])\n        else:\n            sv = (rr0 - cv**2)**.5\n            px = (cv*xd - sv*yd); py = (sv*xd + cv*yd)\n            result.append([\n                (x1 + r1*px/rr0, y1 + r1*py/rr0),\n                (x2 - r2*px/rr0, y2 - r2*py/rr0),\n            ])\n            qx = (cv*xd + sv*yd); qy = (-sv*xd + cv*yd)\n            result.append([\n                (x1 + r1*qx/rr0, y1 + r1*qy/rr0),\n                (x2 - r2*qx/rr0, y2 - r2*qy/rr0),\n            ])\n    return result\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    P = [list(map(int, readline().split())) for i in range(N)]\n    if N == 1:\n        write(\"1\\n\")\n        return True\n    LL = [(r, r+m) for x, y, r, m in P]\n    EPS = 1e-9\n    ans = 0\n    for i in range(N):\n        xi, yi, ri, mi = P[i]\n        LLi = LL[i]\n        for j in range(i):\n            xj, yj, rj, mj = P[j]\n            LLj = LL[j]\n            for pi in LLi:\n                for pj in LLj:\n                    lines = common_tangent_lines(xi, yi, pi, xj, yj, pj)\n                    for p0, p1 in lines:\n                        x0, y0 = p0; x1, y1 = p1\n                        dx = x1 - x0; dy = y1 - y0\n                        q = (dx**2 + dy**2)**.5\n                        cnt = 0\n                        for xk, yk, rk, mk in P:\n                            zx = xk - x0; zy = yk - y0\n                            p = abs(dx*zy - dy*zx)\n                            if rk*q - EPS <= p <= (rk+mk)*q + EPS:\n                                cnt += 1\n                        ans = max(ans, cnt)\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  }
]