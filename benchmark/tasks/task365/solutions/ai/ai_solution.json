[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y, r, s;\n} Gem;\n\nint compare(const void *a, const void *b) {\n    Gem *gemA = (Gem *)a;\n    Gem *gemB = (Gem *)b;\n    double endA = gemA->r + gemA->s;\n    double endB = gemB->r + gemB->s;\n    if (endA < endB) return -1;\n    if (endA > endB) return 1;\n    return 0;\n}\n\nint maxGems(Gem gems[], int n) {\n    if (n == 0) return 0;\n    qsort(gems, n, sizeof(Gem), compare);\n    int count = 1;\n    double lastEnd = gems[0].r + gems[0].s;\n    for (int i = 1; i < n; i++) {\n        if (gems[i].r - gems[i].s >= lastEnd) {\n            count++;\n            lastEnd = gems[i].r + gems[i].s;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Gem *gems = malloc(n * sizeof(Gem));\n    for (int i = 0; i < n; i++) {\n        double x, y, r, s;\n        scanf(\"%lf %lf %lf %lf\", &x, &y, &r, &s);\n        gems[i].x = x;\n        gems[i].y = y;\n        gems[i].r = sqrt(x * x + y * y);\n        gems[i].s = s;\n    }\n    printf(\"%d\\n\", maxGems(gems, n));\n    free(gems);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Event {\n    double angle;\n    bool isStart;\n    bool operator<(const Event& other) const {\n        if (angle != other.angle) return angle < other.angle;\n        return isStart > other.isStart;\n    }\n};\n\nint maxGems(vector<vector<int>>& gems) {\n    int maxCount = 0;\n    for (int i = 0; i < gems.size(); ++i) {\n        vector<Event> events;\n        int x0 = gems[i][0], y0 = gems[i][1], r0 = gems[i][2];\n        int sameCenter = 0;\n        for (int j = 0; j < gems.size(); ++j) {\n            if (i == j) continue;\n            int x = gems[j][0], y = gems[j][1], r = gems[j][2];\n            int dx = x - x0, dy = y - y0;\n            int dSq = dx * dx + dy * dy;\n            int sumR = r0 + r;\n            int diffR = abs(r0 - r);\n            if (dSq == 0 && r == r0) {\n                sameCenter++;\n                continue;\n            }\n            if (dSq > sumR * sumR || dSq < diffR * diffR) continue;\n            double d = sqrt(dSq);\n            double phi = atan2(dy, dx);\n            double theta = acos((r0 * r0 + dSq - r * r) / (2 * r0 * d));\n            double start = phi - theta;\n            double end = phi + theta;\n            if (start < -M_PI) {\n                events.push_back({start + 2 * M_PI, true});\n                events.push_back({M_PI, false});\n                events.push_back({-M_PI, true});\n                events.push_back({end, false});\n            } else if (end > M_PI) {\n                events.push_back({start, true});\n                events.push_back({M_PI, false});\n                events.push_back({-M_PI, true});\n                events.push_back({end - 2 * M_PI, false});\n            } else {\n                events.push_back({start, true});\n                events.push_back({end, false});\n            }\n        }\n        sort(events.begin(), events.end());\n        int count = 1 + sameCenter;\n        maxCount = max(maxCount, count);\n        for (const auto& event : events) {\n            if (event.isStart) {\n                count++;\n                maxCount = max(maxCount, count);\n            } else {\n                count--;\n            }\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> gems(N, vector<int>(3));\n    for (int i = 0; i < N; ++i) {\n        cin >> gems[i][0] >> gems[i][1] >> gems[i][2];\n    }\n    cout << maxGems(gems) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Gem {\n    int x, y, r, s;\n\n    public Gem(int x, int y, int r, int s) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n        this.s = s;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Gem[] gems = new Gem[n];\n\n        for (int i = 0; i < n; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int r = scanner.nextInt();\n            int s = scanner.nextInt();\n            gems[i] = new Gem(x, y, r, s);\n        }\n\n        int maxGems = 0;\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                double distance = Math.sqrt(Math.pow(gems[i].x - gems[j].x, 2) + Math.pow(gems[i].y - gems[j].y, 2));\n                if (distance <= gems[j].r + gems[j].s) {\n                    count++;\n                }\n            }\n            if (count > maxGems) {\n                maxGems = count;\n            }\n        }\n\n        System.out.println(maxGems);\n    }\n}",
    "timestamp": "2025-08-05 21:14:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ImmortalJewelsCollection {\n    public static int maxJewelsCollected(List<Circle> circles, double rodLength) {\n        int n = circles.size();\n        int maxJewels = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                maxJewels = Math.max(maxJewels, countJewelsFromLine(circles, circles.get(i).center, circles.get(j).center, rodLength));\n            }\n        }\n\n        return maxJewels;\n    }\n\n    private static int countJewelsFromLine(List<Circle> circles, Point p1, Point p2, double rodLength) {\n        int count = 0;\n        for (Circle circle : circles) {\n            if (distanceBetweenPointAndLine(circle.center, p1, p2) <= circle.magneticStrength + rodLength) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static double distanceBetweenPointAndLine(Point point, Point lineStart, Point lineEnd) {\n        double lineLength = Math.sqrt(Math.pow(lineEnd.x - lineStart.x, 2) + Math.pow(lineEnd.y - lineStart.y, 2));\n        double crossProduct = Math.abs((point.x - lineStart.x) * (lineEnd.y - lineStart.y) - \n                                       (point.y - lineStart.y) * (lineEnd.x - lineStart.x));\n        return crossProduct / lineLength;\n    }\n\n    static class Circle {\n        Point center;\n        double magneticStrength;\n\n        Circle(Point center, double magneticStrength) {\n            this.center = center;\n            this.magneticStrength = magneticStrength;\n        }\n    }\n\n    static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Circle> circles = new ArrayList<>();\n        circles.add(new Circle(new Point(1, 2), 0.5));\n        circles.add(new Circle(new Point(3, 4), 0.7));\n        circles.add(new Circle(new Point(5, 6), 0.3));\n\n        double rodLength = 1.0;\n        System.out.println(maxJewelsCollected(circles, rodLength));\n    }\n}",
    "timestamp": "2025-08-05 21:15:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y, strength;\n} Gem;\n\nint compare(const void* a, const void* b) {\n    Gem* gemA = (Gem*)a;\n    Gem* gemB = (Gem*)b;\n    return gemA->strength < gemB->strength ? 1 : -1;\n}\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\n\nint maxGemsCollected(Gem* gems, int n, double rodLength) {\n    qsort(gems, n, sizeof(Gem), compare);\n    \n    int maxGems = 0;\n    for (int i = 0; i < n; i++) {\n        int currentGems = 0;\n        for (int j = 0; j < n; j++) {\n            if (distance(gems[i].x, gems[i].y, gems[j].x, gems[j].y) <= gems[j].strength + rodLength) {\n                currentGems++;\n            }\n        }\n        maxGems = fmax(maxGems, currentGems);\n    }\n    \n    return maxGems;\n}\n\nint main() {\n    int n;\n    double rodLength;\n    \n    scanf(\"%d %lf\", &n, &rodLength);\n    \n    Gem* gems = malloc(n * sizeof(Gem));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &gems[i].x, &gems[i].y, &gems[i].strength);\n    }\n    \n    int result = maxGemsCollected(gems, n, rodLength);\n    printf(\"%d\\n\", result);\n    \n    free(gems);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Gem {\n    double x, y, r;\n};\n\ndouble distance(const Gem& a, const Gem& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint maxGemsCollected(vector<Gem>& gems, double rodLength) {\n    int n = gems.size();\n    int maxGems = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<bool> collected(n, false);\n            int currentGems = 0;\n\n            for (int k = 0; k < n; k++) {\n                double dist = min(\n                    distance(gems[i], gems[k]),\n                    distance(gems[j], gems[k])\n                );\n\n                if (dist <= rodLength + gems[k].r && !collected[k]) {\n                    collected[k] = true;\n                    currentGems++;\n                }\n            }\n\n            maxGems = max(maxGems, currentGems);\n        }\n    }\n\n    return maxGems;\n}\n\nint main() {\n    int n;\n    double rodLength;\n    cin >> n >> rodLength;\n\n    vector<Gem> gems(n);\n    for (int i = 0; i < n; i++) {\n        cin >> gems[i].x >> gems[i].y >> gems[i].r;\n    }\n\n    cout << maxGemsCollected(gems, rodLength) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_gems_collected(gems):\n    def count_gems_within_distance(x, y, rod_d):\n        count = 0\n        for gx, gy, m in gems:\n            if math.sqrt((gx - x) ** 2 + (gy - y) ** 2) <= rod_d + m:\n                count += 1\n        return count\n\n    max_gems = 0\n    for x1, y1, m1 in gems:\n        for x2, y2, m2 in gems:\n            if (x1, y1) == (x2, y2):\n                max_gems = max(max_gems, count_gems_within_distance(x1, y1, m1))\n            else:\n                d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n                m_total = m1 + m2\n                if d <= m_total:\n                    # Calculate intersection midpoint of the two circle edges\n                    mx = (x1 + x2) / 2\n                    my = (y1 + y2) / 2\n                    max_gems = max(max_gems, count_gems_within_distance(mx, my, m1))\n    return max_gems\n\n# Example to test the function\ngems = [(0, 0, 1), (2, 0, 1), (0, 2, 1), (2, 2, 1), (1, 1, 2)]\nprint(max_gems_collected(gems))  # Output should be the maximum number of gems that can be attracted",
    "timestamp": "2025-08-13 05:38:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class ImmortalJewelsCollector {\n    static class Gem {\n        double x, y, radius;\n        \n        Gem(double x, double y, double radius) {\n            this.x = x;\n            this.y = y;\n            this.radius = radius;\n        }\n        \n        double distanceTo(Gem other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        ArrayList<Gem> gems = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            double r = scanner.nextDouble();\n            gems.add(new Gem(x, y, r));\n        }\n        \n        int maxCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                ArrayList<Double> distances = new ArrayList<>();\n                \n                for (int k = 0; k < n; k++) {\n                    double d1 = gems.get(k).distanceTo(gems.get(i)) - gems.get(k).radius;\n                    double d2 = gems.get(k).distanceTo(gems.get(j)) - gems.get(k).radius;\n                    \n                    distances.add(d1 - d2);\n                }\n                \n                Collections.sort(distances);\n                \n                int count1 = 0, count2 = 0;\n                double radius1 = gems.get(i).radius + gems.get(j).radius, radius2 = radius1;\n                \n                for (double dist : distances) {\n                    if (dist <= radius1) {\n                        count1++;\n                    }\n                    if (-dist <= radius2) {\n                        count2++;\n                    }\n                }\n                \n                maxCount = Math.max(maxCount, Math.max(count1, count2));\n            }\n        }\n        \n        System.out.println(maxCount);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 05:38:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_GEMS 100\n\ntypedef struct {\n    double x;\n    double y;\n    double magneticStrength;\n} Gem;\n\nint n;\nGem gems[MAX_GEMS];\n\nint countAttractedGems(double rodX, double rodY) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        double distance = sqrt(pow(gems[i].x - rodX, 2) + pow(gems[i].y - rodY, 2));\n        if (distance <= gems[i].magneticStrength) {\n            count++;\n        }\n    }\n    return count;\n}\n\ndouble evaluatePosition(double *bestX, double *bestY) {\n    double best = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double midX = (gems[i].x + gems[j].x) / 2.0;\n            double midY = (gems[i].y + gems[j].y) / 2.0;\n            double count = countAttractedGems(midX, midY);\n            if (count > best) {\n                best = count;\n                *bestX = midX;\n                *bestY = midY;\n            }\n        }\n    }\n    return best;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &gems[i].x, &gems[i].y, &gems[i].magneticStrength);\n    }\n\n    double bestX = 0, bestY = 0;\n    double maxGems = evaluatePosition(&bestX, &bestY);\n\n    printf(\"%d\\n\", (int)maxGems);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:38:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_gems_collected(gems):\n    n = len(gems)\n    max_gems = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            # Try placing rod between two extreme points\n            collected = count_gems_in_range(gems, gems[i][0], gems[j][0])\n            max_gems = max(max_gems, collected)\n    \n    return max_gems\n\ndef count_gems_in_range(gems, start, end):\n    count = 0\n    for x, r in gems:\n        # Check if gem can be attracted by rod placed between start and end\n        if abs(x - start) <= r or abs(x - end) <= r or (start <= x <= end):\n            count += 1\n    return count\n\ndef main():\n    # Input gem locations and magnetic strengths\n    # Format: (x-coordinate, magnetic strength/radius)\n    gems = [(1, 2), (3, 1), (5, 3), (7, 2)]\n    print(max_gems_collected(gems))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:38:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef max_gems(gems):\n    events = []\n    for x, y, r, s in gems:\n        d = math.sqrt(x**2 + y**2)\n        start = d - r - s\n        end = d - r\n        events.append((start, 1))\n        events.append((end, -1))\n    \n    events.sort()\n    max_count = 0\n    current = 0\n    for event in events:\n        current += event[1]\n        if current > max_count:\n            max_count = current\n    return max_count\n\n# Example usage:\n# gems = [(x1, y1, r1, s1), (x2, y2, r2, s2), ...]\n# print(max_gems(gems))",
    "timestamp": "2025-08-13 05:38:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstruct Gem {\n    double x, y, strength;\n};\n\nbool canAttract(double rod_x, double rod_y, const Gem& gem) {\n    double distance = std::sqrt((rod_x - gem.x) * (rod_x - gem.x) + (rod_y - gem.y) * (rod_y - gem.y));\n    return distance <= gem.strength;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Gem> gems(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> gems[i].x >> gems[i].y >> gems[i].strength;\n    }\n    \n    int max_count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                double x1 = (gems[i].x + gems[j].x + gems[k].x) / 3.0;\n                double y1 = (gems[i].y + gems[j].y + gems[k].y) / 3.0;\n\n                int count1 = std::count_if(gems.begin(), gems.end(),\n                    [=](const Gem& gem) { return canAttract(x1, y1, gem); });\n\n                max_count = std::max(max_count, count1);\n            }\n        }\n    }\n    \n    std::cout << max_count << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:14"
  }
]