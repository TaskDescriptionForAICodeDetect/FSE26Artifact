[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n\n  val n = readInt\n  val movies = Array.tabulate(n){_ ⇒\n    val Array(from, to) = readLine.trim.split(' ').map(_.toInt)\n    Movie(from, to)\n  }\n  val (source, drain, nodes) = makeGraph(movies)\n  println(3100 - calMinCost(nodes, source, drain, 31))\n  def makeGraph(movies: Array[Movie]): (Int, Int, Array[Array[Edge]]) = {\n    val result = Array.tabulate(31 + movies.length * 2 + 2){_ ⇒ ArrayBuffer[Edge]()}\n    val days = 0 until 31\n    val movieFirstTime = movies.zipWithIndex.map(m ⇒ (m._1, m._2 + 31))\n    val movieSecondTime = movies.zipWithIndex.map(m ⇒ (m._1, m._2 + 31 + movies.length))\n    val source = 31 + movies.length * 2\n    val drain = source + 1\n    for (day ← days){\n      result(day).append(Edge(source, result(source).length, 0, 0))\n      result(day).append(Edge(drain, result(drain).length, 100, 1))\n      result(source).append(Edge(day, 0, 0, 1))\n      result(drain).append(Edge(day, 1, -100, 0))\n    }\n    for ((m, movie) ← movieFirstTime){\n      result(movie).append(Edge(drain, result(drain).length, 0, 1))\n      result(drain).append(Edge(movie, 0, 0, 0))\n      for (day ← m.range.map(_ - 1)){\n        result(movie).append(Edge(day, result(day).length, 0, 0))\n        result(day).append(Edge(movie, result(movie).length - 1, 0, 1))\n      }\n    }\n    for ((m, movie) ← movieSecondTime){\n      result(movie).append(Edge(drain, result(drain).length, 0, 100))\n      result(drain).append(Edge(movie, 0, 0, 0))\n      for (day ← m.range.map(_ - 1)){\n        result(movie).append(Edge(day, result(day).length, -50, 0))\n        result(day).append(Edge(movie, result(movie).length - 1, 50, 1))\n      }\n    }\n    (source, drain, result.map(_.toArray))\n  }\n  case class Movie(from: Int, to: Int) {\n    def range = from to to\n  }\n  def calMinCost(nodes: Array[Array[Edge]], source: Int, drain: Int, flow: Int): Int = {\n    val minCost = Array.tabulate(nodes.length){_ ⇒ Int.MaxValue}\n    val potential = Array.tabulate(nodes.length){_ ⇒ 0}\n    val queue = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse)\n    val revEdge = Array.tabulate(nodes.length){_ ⇒ Edge(0, 0, 0, 0)}\n    var result = 0\n    for (_ ← 0 until flow){\n      minCost.indices.foreach(i ⇒ minCost(i) = Int.MaxValue)\n      minCost(source) = 0\n      queue.enqueue((source, 0))\n      while(queue.nonEmpty){\n        val (top, cost) = queue.dequeue()\n        if (minCost(top) == cost && top != drain){\n          for (Edge(to, pair, c, flow) ← nodes(top) if flow > 0){\n            if (minCost(to) > potential(to) + c - potential(top) + cost) {\n              minCost(to) = potential(to) + c - potential(top) + cost\n              revEdge(to) = nodes(to)(pair)\n              queue.enqueue((to, minCost(to)))\n            }\n          }\n        }\n      }\n      result += minCost(drain)\n      var last = drain\n      while(last != source){\n        val Edge(from, pair, _, _) = revEdge(last)\n        nodes(from)(pair).flow -= 1\n        revEdge(last).flow += 1\n        last = from\n      }\n      for (i ← potential.indices if i != source && i != drain) potential(i) += minCost(i)\n    }\n    result\n  }\n  case class Edge(to: Int, pair: Int, cost: Int, var flow: Int)\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 200\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint main(){\n  int n,m;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      add_edge(1+j,i+110,1);\n    }\n  }\n  r(i,100)add_edge(0,i+1,1);\n  r(i,36)add_edge(i+110,99,1);\n  int p=max_flow(0,99);\n  cout<<p*50+30*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n  int n;\n  cin >> n;\n  priority_queue<P, vector<P>, greater<P>> ls, rs;\n  vector<int> cnt(32, 0);\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    for (int j = a; j <= b; j++) cnt[j] = 1;\n    ls.push({a, b});\n  }\n\n  int y = 0, z = 0;\n  for (int i = 1; i <= 31; i++) {\n    while (!ls.empty()) {\n      auto p = ls.top();\n      int l = p.first;\n      int r = p.second;\n      if (i < l || r < i) break;\n      ls.pop();\n      rs.push({r, l});\n    }\n    int ytmp = 0;\n    while (!rs.empty()) {\n      auto p = rs.top(); rs.pop();\n      int r = p.first;\n      int l = p.second;\n      if (i < l || r < i) continue;\n      ytmp++;\n      break;\n    }\n    y += ytmp;\n  }\n  z = accumulate(begin(cnt), end(cnt), 0);\n  cout << 100 * y + 50 * (z - y) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * e.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int M = 31;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\ntemplate <typename T, const int MAX_N>\nstruct BIT {\n  int n;\n  T bits[MAX_N + 1];\n  \n  BIT() {}\n  BIT(int _n) { init(n); }\n\n  void init(int _n) {\n    n = _n;\n    memset(bits, 0, sizeof(bits));\n  }\n\n  T sum(int x) {\n    T s = 0;\n    while (x > 0) {\n      s += bits[x];\n      x -= (x & -x);\n    }\n    return s;\n  }\n\n  void add(int x, T v) {\n    while (x <= n) {\n      bits[x] += v;\n      x += (x & -x);\n    }\n  }\n};\n\n/* global variables */\n\nBIT<int,M + 2> bit;\npii rs[MAX_N];\nbool fs[M + 1], used[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  bit.init(M + 1);\n\n  for (int i = 0; i < n; i++) {\n    cin >> rs[i].first >> rs[i].second;\n    bit.add(rs[i].first, 1);\n    bit.add(rs[i].second + 1, -1);\n  }\n  sort(rs, rs + n);\n\n  //for (int i = 1; i <= M; i++) printf(\"%d \", bit.sum(i)); putchar('\\n');\n  //for (int i = 1; i <= M; i++) printf(\"%d \", fs[i]); putchar('\\n');\n\n  for (bool changed = true; changed;) {\n    changed = false;\n\n    for (int i = 0; i < n; i++)\n      if (! used[i])\n\tfor (int j = rs[i].first; j <= rs[i].second; j++)\n\t  if (bit.sum(j) == 1) {\n\t    fs[j] = true;\n\t    used[i] = true;\n\t    bit.add(rs[i].first, -1);\n\t    bit.add(rs[i].second + 1, 1);\n\t    changed = true;\n\t    break;\n\t  }\n  }\n\n  //for (int i = 1; i <= M; i++) printf(\"%d \", bit.sum(i)); putchar('\\n');\n  //for (int i = 1; i <= M; i++) printf(\"%d \", fs[i]); putchar('\\n');\n  \n  for (int i = 0; i < n; i++)\n    if (! used[i])\n      for (int j = rs[i].first; j <= rs[i].second; j++)\n\tif (! fs[j]) {\n\t  fs[j] = true;\n\t  used[i] = true;\n\t  bit.add(rs[i].first, -1);\n\t  bit.add(rs[i].second + 1, 1);\n\t  break;\n\t}\n  \n  //for (int i = 1; i <= M; i++) printf(\"%d \", bit.sum(i)); putchar('\\n');\n  //for (int i = 1; i <= M; i++) printf(\"%d \", fs[i]); putchar('\\n');\n\n  int sum = 0;\n  for (int i = 1; i <= M; i++) sum += (fs[i] ? 2 : 1);\n\n  printf(\"%d\\n\", sum * 50);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    int n; cin >> n;\n\n    int res = 0;\n\n    vector<int> d[33];\n    vector<bool> s(33,false);\n    for (int i = 0; i < n; i++) {\n        int x, y; cin >> x >> y;\n        d[x].push_back(y);\n        for (int  j = x; j <= y; j++) s[j] = true;\n    }\n\n    for (int i = 1; i < 32; i++) {\n        if (d[i].size() > 0) {\n            res += 100;\n            sort(d[i].begin(), d[i].end());\n            for (int j = 1; j < d[i].size(); j++) {\n                if (d[i][j] > i) {\n                    d[i+1].push_back(d[i][j]);\n                }\n            }\n        } else if (s[i] > 0) res += 50;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * e.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\n/* global variables */\n\npii rs[MAX_N];\nint cvs[31];\nbool fs[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> rs[i].first >> rs[i].second;\n    rs[i].first--;\n    for (int j = rs[i].first; j < rs[i].second; j++) cvs[j]++;\n  }\n  sort(rs, rs + n);\n\n  for (int i = 0; i < n; i++) {\n    bool done = false;\n    for (int j = rs[i].first; j < rs[i].second; j++)\n      if (cvs[j] == 1) {\n\tfs[j] = true;\n\tdone = true;\n\tbreak;\n      }\n    if (done) continue;\n\n    for (int j = rs[i].first; j < rs[i].second; j++)\n      if (! fs[j]) {\n\tfs[j] = true;\n\tbreak;\n      }\n  }\n\n  int sum = 0;\n  for (int i = 0; i < 31; i++) sum += (fs[i] ? 2 : 1);\n\n  printf(\"%d\\n\", sum * 50);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//最大流\nstruct MaxFlow {\n    struct Edge {\n        int to, cap, rev;\n        Edge() {};\n        Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {};\n    };\n    int V;\n    vector<vector<Edge>> G;\n    vector<int> used;\n\n    MaxFlow(int V) : V(V), G(V, vector<Edge>()), used(V){}\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back({to, cap, (int)G[to].size()});\n        G[to].push_back({from, 0, (int)G[from].size() - 1});\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge& e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            // memset(used, 0, sizeof(used));\n            used = vector<int>(V, 0);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\n\nint main(){\n    int n;\n    cin >> n;\n    MaxFlow flow(31+n+2);\n    int source = 0, sink = 31+n+2-1;\n    REP(i, 1, n+1) {\n        int cur = 31+i;\n        int a, b;\n        cin >> a >> b;\n        REP(j, a, b+1) {\n            flow.add_edge(cur, j, 1);\n        }\n        flow.add_edge(source, cur, 1);\n    }\n    REP(i, 1, 31 + 1) {\n        flow.add_edge(i, sink, 1);\n    }\n    int f = flow.max_flow(source, sink);\n    cout << f*100+(31-f)*50 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=1;i<n;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) REP(i,v.size())cout<<#v<<\"[\"<<i<<\"]: \"<<v[i]<<endl\n#define ALL(a) (a).begin(),(a).end()\n\nint main(){\n  int n;\n  cin >> n;\n  int result = 0;\n  int lastorder[31];\n  REP(i,31)lastorder[i]=-1;\n  vector<pii> schedule(n);\n  REP(i,n){\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    schedule[i] = make_pair(b-a,a);\n  }\n  sort(ALL(schedule));\n  REP(i,n){\n    int span = schedule[i].first;\n    int start = schedule[i].second;\n    for(int d=start;d<=start+span;++d){\n      if(lastorder[d]==-1){\n        lastorder[d]=i;\n        result += 100;\n        break;\n      }\n    }\n  }\n  REP(i,31){\n    if(lastorder[i]==-1){\n      result += 50;\n    }\n  }\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main (int argc, char *argv[]) {\n    int n;\n    int ans = 0;\n    cin>>n;\n    vector<pair<int, int> > p;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        int tmp1, tmp2;\n        cin>>tmp1>>tmp2;\n        p.push_back(make_pair(tmp1, tmp2));\n    }\n    sort(p.begin(), p.end(), [](auto lp, auto rp){\n        return lp.second < rp.second;\n    });\n    // for (auto e : p) {\n    //     cout<<e.first<<\" \"<<e.second<<endl;\n    // }\n    for (int day = 1; day < 32; ++day) {\n        int target = 0;\n        bool flag1 = false;\n        bool flag2 = false;\n        for (int i = 0; i < p.size(); ++i) {\n            if (p[i].first <= day && day <= p[i].second) {\n                flag1 = true;\n                if (!visited[i] && target == 0) {\n                    target = i;\n                    flag2 = true;\n                    // cout <<i<<endl;\n                }\n            }\n        }\n        visited[target] = true;\n        if (flag1 && flag2) ans += 100;\n        if (flag1 && !flag2) ans += 50;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<pair<int,int>> movie;\n  int num[100] = {0};\n  \n  for(int i = 0;i < n;++i){\n    int a,b;\n    cin>>a;\n    cin>>b;\n\n    movie.push_back(make_pair(a,b));\n  }\n  sort(movie.begin(),movie.end());\n\n  int sum = 0;\n  for(int i = 1;i <= 31;++i){\n    int begin = 0;\n    int end = 0;\n    int place = 0;\n    int times = 0;\n    int check = 0;\n\n    for(pair<int,int> e : movie){\n      if(i >= e.first && i <= e.second){\n        if(check == 0){\n          begin = e.first;\n          end = e.second;\n          place = times;\n          check = 1;\n        }\n        else{\n          if(num[place] == 1 && num[times] == 0){\n            begin = e.first;\n            end = e.second;\n            place = times;\n          }\n          else if(num[place] == 0 && num[times] == 0){\n            if(end > e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n          }\n        }\n      }\n      ++times;\n    }\n\n    if(num[place] == 0){\n      sum += 100;\n      num[place] = 1;\n    }\n    else{\n      sum += 50;\n    }\n  }\n\n  cout<<sum<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\nint N, A[128], B[128];\n\n\nint main() {\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tbool check[128] = {0};\n\tint ans = 0;\n\tFFOR(d,1,31){\n\t\tint after = 32, wsee = 128;\n\t\tbool ok = false;\n\t\tREP(j,N){\n\t\t\tif(A[j] <= d && d <= B[j])\n\t\t\t\tok = true;\n\t\t\tif(check[j])\n\t\t\t\tcontinue;\n\t\t\tif(A[j] <= d && d <= B[j]){\n\t\t\t\tif(after > B[j]){\n\t\t\t\t\tafter = B[j];\n\t\t\t\t\twsee = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(wsee != 128){\n\t\t\tcheck[wsee] = true;\n\t\t\tans += 100;\n\t\t}\n\t\telse{\n\t\t\tif(ok)\n\t\t\t\tans += 50;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool cheak(ll x, ll y, ll xMax, ll yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline ll toInt(string s) { ll v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e9 + 9;\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nint main(){\n\n\tint n;\n\tcin >> n;\n\n\tvector<P> v(n);\n\n\trep(i, n){\n\t\tcin >> v[i].second >> v[i].first;\n\t}\n\n\tsort(all(v));\n\tbool f[200];\n\tclr(f);\n\t\n\tint ans = 0;\n\tFor(i, 1, 32){\n\n\t\tans += 50;\n\t\trep(j, n){\n\t\t\tif (v[j].second <= i && v[j].first >= i){\n\t\t\t\tif (f[j] == false){\n\t\t\t\t\tf[j] = true;\n\t\t\t\t\tans += 50; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nclass bipartite_matching{\nprivate:\n  int V;\n  vector< vector< int > > info;\n  vector< int > match;\n  vector< bool > used;\npublic:\n  bipartite_matching(int V_size):V(V_size){\n    info.resize(V_size);\n    used.resize(V_size);\n    match.resize(V_size);\n  };\n  void add_edge( int u, int v){\n    info[u].push_back(v);\n    info[v].push_back(u);\n  }\n  bool dfs( int v){\n    used[v] = true;\n    for(int i = 0; i < info[v].size(); i++){\n      int u = info[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)){\n        match[v] = u, match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int run(){\n    match.assign(V,-1);\n    int ret = 0;\n    for(int i = 0; i < V; i++){\n      if(match[i] < 0){\n        used.assign(V,false);\n        if(dfs(i)) ret++;\n      }\n    }\n    return ret;\n  }\n};\n\nint main()\n{\n  int n;\n  vector< int > data[31];\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    for(int j = x; j <= y; j++) {\n      data[j].push_back(i);\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 31; i++) {\n    ret += !data[i].empty();\n  }\n\n  bipartite_matching bp(n + 31);\n  for(int i = 0; i < 31; i++) {\n    for(int j = 0; j < data[i].size(); j++) {\n      bp.add_edge(i + n, data[i][j]);\n    }\n  }\n  cout << ret * 50 + bp.run() * 50 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<pair<int,int>> movie;\n  int num[100] = {0};\n  \n  for(int i = 0;i < n;++i){\n    int a,b;\n    cin>>a;\n    cin>>b;\n\n    movie.push_back(make_pair(a,b));\n  }\n  sort(movie.begin(),movie.end());\n\n  int sum = 0;\n  for(int i = 1;i <= 31;++i){\n    int begin = 0;\n    int end = 0;\n    int place = 0;\n    int times = 0;\n    int check = 0;\n\n    for(pair<int,int> e : movie){\n      if(i >= e.first && i <= e.second){\n        if(check == 0){\n          begin = e.first;\n          end = e.second;\n          place = times;\n          check = 1;\n        }\n        else{\n          if(num[place] == 0 && num[times] == 1){\n            continue;\n          }\n          else{\n            if(end > e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n            else if(end == e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n          }\n        }\n      }\n      ++times;\n    }\n\n    if(num[place] == 0){\n      sum += 100;\n      num[place] = 1;\n    }\n    else{\n      sum += 50;\n    }\n  }\n  cout<<sum<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 2000000000\n#define N 100\nusing namespace std;\nint main(){\n  int n,a[N],b[N],c[N],cnt,minv,r,i,j;\n  cin >> n;\n  for(i=0;i<n;i++) cin >> a[i] >> b[i],c[i]=0;\n  for(i=1;i<=31;i++){\n    minv=INF;\n    for(j=0;j<n;j++){\n      if(a[j]<=i&&i<=b[j]&&c[j]==0){\n\tif(minv>b[j]-i){\n\t  minv=b[j]-i;\n\t  r=j;\n\t}\n      }\n    }\n    if(minv!=INF) c[r]=1;\n  }\n  cnt=0;\n  for(i=0;i<n;i++){\n    if(c[i]==1) cnt++;\n  }\n  cout << 50*31+50*cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nvector<int> days[31];\nbool watched[200];\n\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tint b[n];\n\trep(i,n){\n\t\tcin>>a[i]>>b[i];\n\t\tfor(int d = 0; d < 31; d++)\n\t\t\tif(a[i] <= d + 1 && b[i] >= d + 1)\n\t\t\t\tdays[d].push_back(i);\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < 31; i++)\n\t{\n\t\tint target = -1;\n\t\tfor(int j = 0; j < days[i].size(); j++)\n\t\t{\n\t\t\tif(watched[days[i][j]])\n\t\t\t\tcontinue;\n\t\t\tif(target == -1 || b[target] > b[days[i][j]])\n\t\t\t\ttarget = days[i][j];\n\t\t}\n\t\tans += (target == -1 || watched[target]) ? 50 : 100;\n\t\twatched[target] = true;\n\t}\n\tcout << ans << endl;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=n-1;j>i;j--){\n\t\t\tif(b[j-1] > b[j]){\n\t\t\t\tint alt=b[j-1];\n\t\t\t\tb[j-1]=b[j];\n\t\t\t\tb[j]=alt;\n\t\t\t\talt=a[j-1];\n\t\t\t\ta[j-1]=a[j];\n\t\t\t\ta[j]=alt;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*bool dt[n][32];\n\tint movie[32];\n\trep(i,32)movie[i]=-1;\n\trep(i,n)rep(j,32)dt[i][j]=false;\n\tint a,b;\n\tint ans=0;\n\trep(i,n){\n\t\tcin>>a>>b;\n\t\tloop(j,a,b+1)dt[i][j]=true;\n\t}\n\tloop(i,1,32){\n\t\tint cnt=0;\n\t\tint mv=-1;\n\t\trep(j,n){\n\t\t\tif(dt[j][i]){\n\t\t\t\tcnt++;\n\t\t\t\tmv=j;\n\t\t\t}\n\t\t}\n\t\tif(cnt==1){\n\t\t\tmovie[i]=mv;\n\t\t}\n\t}\n\tloop(i,1,32){\n\t\trep(j,n){\n\t\t\tif(dt[j][i] && movie[i]==-1){\n\t\t\t\tmovie[i]=j;\n\t\t\t}\n\t\t}\n\t}\n\tloop(i,1,32)cout<<movie[i]<<\" \";\n\tcout<<endl;\n\tbool used[n];\n\trep(i,n)used[i]=true;\n\tloop(i,1,32){\n\t\tif(movie[i]!=-1){\n\t\t\tif(used[movie[i]])ans+=100;\n\t\t\telse ans+=50;\n\t\t\tused[movie[i]]=false;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> happy;\nvector< pair<int, int> > date;\n\nint func(int day){\n  if(day == 32) return 0;\n  int res = 0;\n  for(int i=0; i < n; i++){\n    if(date[i].first <= day && day <= date[i].second){\n      int h = happy[i];\n      happy[i] = 50;\n      res = max(res, func(day+1)+h);\n      happy[i] = h;\n    }\n  }\n  return res;\n}\n\nint main(void){\n  cin >> n;\n  for(int i=0; i < n; i++){\n    int a, b; cin >> a >> b;\n    happy.push_back(100);\n    date.push_back(make_pair(a, b));\n  }\n  cout << func(1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[50][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  best = 0;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 50; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] > b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    // cout << a[i] << \"-\" << b[i] << endl;\n  }\n  return rec(0, 0);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 200\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint main(){\n  int n,m;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      add_edge(1+j,i+110,1);\n    }\n  }\n  r(i,36)add_edge(0,i+1,1);\n  r(i,36)add_edge(i+110,99,1);\n  int p=max_flow(0,99);\n  cout<<p*50+31*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define hi cout<<\"hi\"<<endl;\ntypedef long long ll;\nconst int N = 105;\n#define LL long long\n\nint a[N], b[N];\nint main()\n{\n    ios::sync_with_stdio(0);\n    int n;\n\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n    priority_queue<int, vector<int>, greater<int> > q;\n    int k = 0;\n    for (int i = 1; i <= 31; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[j] == i)\n            {\n                q.push(b[j]);\n            }\n        }\n        if (!q.empty())\n        {\n            k++;\n            q.pop();\n        }\n        while (!q.empty() && q.top() == i) q.pop();\n    }\n    cout << k * 100 + (31 - k) *50 << endl;\n    return 0;\n}\n/*\n4\n9999992 9999992 9999998 9999998\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint ku[40];\nint main(){\n  int n,m;\n  set<int>s;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      s.insert(i);\n      add_edge(1+j,i+40,1);\n    }\n  }\n  r(i,32)add_edge(0,i+1,1);\n  r(i,32)add_edge(i+40,99,1);\n  int p=max_flow(0,99);\n  cout<<p*100+(s.size()-p)*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Movie\n{\n\tint num, a, b;\n\tbool isUsed;\n\tMovie()\n\t{\n\t\ta = 0;\n\t\tb = 1e9;\n\t\tisUsed = false;\n\t}\n\n\tbool operator < (const Movie &a) const\n\t{\n\t\tif (isUsed != a.isUsed)\n\t\t{\n\t\t\treturn isUsed;\n\t\t}\n\t\treturn b > a.b;\n\t}\n};\n\nint main(){\n\tint N;\n\tMovie movie[100];\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> movie[i].a >> movie[i].b;\n\t\tmovie[i].num = i;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= 31; i++)\n\t{\n\t\tMovie ma = Movie();\n\t\tma.isUsed = true;\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(i < movie[j].a || movie[j].b < i) continue;\n\t\t\tma = max(ma, movie[j]);\n\t\t}\n\t\tmovie[ma.num].isUsed = true;\n\t\tif (ma.isUsed) ans += 50;\n\t\telse ans += 100;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 101\n#define INF (1e9)\nusing namespace std;\nint n,a[N],b[N],ans,c;\nbool used[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&a[j]<=i&&i<=b[j]&&b[j]<=c){\n\tif(c!=INF&&a[j]<a[c]) c=j;\n\telse c=j;\n      }\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint start,end;\n};\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tInfo info[N];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].start,&info[i].end);\n\t}\n\n\tbool watched[N];\n\tfor(int i = 0; i < N; i++)watched[i] = false;\n\n\tint count = 0;\n\tint  min_end,min_index;\n\n\tfor(int day = 1; day <= 31; day++){\n\n\t\tmin_end = BIG_NUM;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(watched[i])continue;\n\t\t\tif(info[i].end < day || info[i].start > day)continue;\n\n\t\t\tif(min_end > info[i].end){\n\t\t\t\tmin_end = info[i].end;\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\n\t\tif(min_end != BIG_NUM){\n\t\t\tcount++;\n\t\t\twatched[min_index] = true;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",100*count+50*(31-count));\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nsigned main(){\n   \n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; ++i){\n        cin >> a[i] >> b[i];\n    }\n\n    int ans = 0;\n    bool watched[100] = {};\n    for(int t = 1; t <= 31; ++t){\n        int idx = -1, mx = INF;\n        for(int i = 0; i < n; ++i){\n            if(!watched[i] && t >= a[i] && t <= b[i]){\n                if(mx > b[i] - t){\n                    mx = b[i] - t;\n                    idx = i;\n                }\n            }\n        }\n        //cout << idx << endl;\n        if(idx != -1){\n            watched[idx] = true;\n            ans += 100;\n        }else{\n            for(int i = 0; i < n; ++i){\n                if(t >= a[i] && t <= b[i]){\n                    ans += 50;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    cin >>n;\n\n    vector<int> q[33];\n    rep(i,n){\n        int a,b;\n        cin >>a >>b;\n        q[a].pb(b);\n    }\n\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int ans = 0;\n    for(int i=1; i<=31; ++i){\n        for(int e:q[i]) pq.push(e);\n\n        while(!pq.empty() && pq.top()<i) pq.pop();\n\n        if(!pq.empty()){\n\n            ans += 2;\n            pq.pop();\n        }\n        else ++ans;\n    }\n\n    cout << ans*50 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nint main(){\n  int n;\n  cin>>n;\n  vector<int>f(n);\n  vector<vector<bool> >in(n,vector<bool>(31));\n  vector<int>sa(n);\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    loop(j,a-1,b)in[i][j]=true;\n    sa[i]=b-a;\n  }\n\n  int out=0;\n  rep(i,31){\n    bool h=false;\n    int tmp=1e8;\n    rep(j,n)if(in[j][i]){\n      if(!h){\n\tif(f[j]){\n\t  tmp=j;\n\t}\n\telse {\n\t  h=true;\n\t  tmp=j;\n\t}\n      }else{\n\tif(!f[j]&&sa[tmp]>sa[j])tmp=j;\n      }\n    }\n    if(h)out+=100;\n    else out+=50;\n    f[tmp]=true;\n  \n  }\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MN = 110;\nint n;\nint l[MN], r[MN];\n\nbool is[MN];\n\nint main() {\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--;\n\t\tl[i] = a; r[i] = b;\n\t}\n\tint ba = 31;\n\tint co = 0;\n\tfor (int i = 0; i < 31; i++) {\n\t\tint mi = 1000000;\n\t\tint mij = -1;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (is[j]) continue;\n\t\t\tif (!(l[j] <= i && i < r[j])) continue;\n\t\t\tif (r[j] < mi) {\n\t\t\t\tmi = r[j];\n\t\t\t\tmij = j;\n\t\t\t}\n\t\t}\n\t\tif (mij == -1) continue;\n\t\tba++;\n\t\tis[mij] = true;\n\t}\n\tprintf(\"%d\\n\", ba*50);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i] >> b[i];\n\n    vector<bool> check(n, false);\n    int ans = 0;\n    for(int d=1; d<=31; ++d){\n        int k = -1;\n        for(int i=0; i<n; ++i){\n            if(!(a[i] <= d && d <= b[i]))\n                continue;\n            if(k == -1 || (!check[i] && check[k]) || (check[i] == check[k] && b[i] < b[k]))\n                k = i;\n        }\n        if(!check[k]){\n            ans += 100;\n            check[k] = true;\n        }\n        else{\n            ans += 50;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <type_traits>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <limits>\n#include <iostream>\nnamespace lc {\ntemplate <class CapacityType>\nstruct EdgeWithCapacity {\n\tint to;\n\tCapacityType capacity;\n\tEdgeWithCapacity() : to(0), capacity() { }\n\tEdgeWithCapacity(int to, const CapacityType &capacity)\n\t\t: to(to), capacity(capacity)\n\t{ }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n\tListType &operator[](int u){ return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <class EdgeType>\nstruct HasWeight {\nprivate:\n\tstatic std::false_type check(...);\npublic:\n\tstatic const bool value = decltype(check(EdgeType()))::value;\n};\n}\nnamespace lc {\ntemplate <class EdgeType>\nstruct ResidualEdge : public EdgeType {\n\tint rev;\n\ttemplate <class... Args>\n\tResidualEdge(int rev, Args&&... args)\n\t\t: EdgeType(args...)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <class EdgeType>\nclass ResidualAdjacencyList\n\t: public AdjacencyList<ResidualEdge<EdgeType>>\n{\npublic:\n\texplicit ResidualAdjacencyList(int n = 0)\n\t\t: AdjacencyList<ResidualEdge<EdgeType>>(n)\n\t{ }\n};\ntemplate <class EdgeType>\nauto make_residual(const AdjacencyList<EdgeType> &graph)\n\t-> typename std::enable_if<\n\t\t!HasWeight<EdgeType>::value, ResidualAdjacencyList<EdgeType>>::type\n{\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst int n = graph.size();\n\tResidualAdjacencyList<EdgeType> result(n);\n\tfor(int u = 0; u < n; ++u){\n\t\tfor(const auto &e : graph[u]){\n\t\t\tconst int v = e.to;\n\t\t\tconst int rev_u = result[v].size();\n\t\t\tconst int rev_v = result[u].size();\n\t\t\tresult[u].emplace_back(rev_u, e);\n\t\t\tresult[v].emplace_back(rev_v, e);\n\t\t\tresult[v].back().to = u;\n\t\t\tresult[v].back().capacity = capacity_type();\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace lc {\ntemplate <class EdgeType>\nauto maxflow_dinic(\n\tint source, int sink, ResidualAdjacencyList<EdgeType> &graph)\n\t-> decltype(EdgeType().capacity)\n{\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst capacity_type inf = std::numeric_limits<capacity_type>::max();\n\tconst int n = graph.size();\n\tcapacity_type flow = 0;\n\twhile(true){\n\t\tstd::vector<int> level(n, -1);\n\t\tstd::queue<int> q;\n\t\tlevel[source] = 0;\n\t\tq.push(source);\n\t\twhile(!q.empty()){\n\t\t\tconst int u = q.front();\n\t\t\tq.pop();\n\t\t\tfor(const auto &e : graph[u]){\n\t\t\t\tconst int v = e.to;\n\t\t\t\tif(e.capacity <= 0 || level[v] >= 0){ continue; }\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tif(level[sink] < 0){ break; }\n\t\tstd::vector<size_t> iteration(n, 0);\n\t\twhile(true){\n\t\t\tstd::function<capacity_type(int, capacity_type)> dfs =\n\t\t\t\t[&](int u, capacity_type limit) -> capacity_type {\n\t\t\t\t\tif(u == sink){ return limit; }\n\t\t\t\t\tfor(; iteration[u] < graph[u].size(); ++iteration[u]){\n\t\t\t\t\t\tauto &e = graph[u][iteration[u]];\n\t\t\t\t\t\tconst int v = e.to;\n\t\t\t\t\t\tif(e.capacity <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\tconst capacity_type diff =\n\t\t\t\t\t\t\tdfs(v, std::min(e.capacity, limit));\n\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\te.capacity -= diff;\n\t\t\t\t\t\t\tgraph[v][e.rev].capacity += diff;\n\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\tconst auto f = dfs(source, inf);\n\t\t\tif(f <= 0){ break; }\n\t\t\tflow += f;\n\t\t}\n\t}\n\treturn flow;\n}\n}\nusing namespace std;\ntypedef lc::EdgeWithCapacity<int> Edge;\ntypedef pair<int, int> pii;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> ir(32);\n\tvector<pii> ranges(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tranges[i] = pii(a, b);\n\t\t++ir[a];\n\t\t--ir[b + 1];\n\t}\n\tfor(int i = 1; i <= 31; ++i){\n\t\tir[i] += ir[i - 1];\n\t}\n\tlc::AdjacencyList<Edge> graph(n + 31 + 2);\n\tconst int source = n + 31, sink = source + 1;\n\tfor(int i = 0; i < n; ++i){\n\t\tgraph.add_edge(source, i, 1);\n\t\tfor(int j = ranges[i].first; j <= ranges[i].second; ++j){\n\t\t\tgraph.add_edge(i, n + j, 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < 31; ++i){\n\t\tgraph.add_edge(n + i, sink, 1);\n\t}\n\tauto residual = lc::make_residual(graph);\n\tconst int f = lc::maxflow_dinic(source, sink, residual);\n\tint answer = f * 50;\n\tfor(int i = 0; i < 31; ++i){\n\t\tif(ir[i] > 0){ answer += 50; }\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 105\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\nint n,st[M],ed[M],ans;\nbool vis[M];\npriority_queue<int,vector<int>,greater<int>> q;\nint main()\n{\n\tRI(n);\n\tans = 0;\n\tREP(i,1,n)\n\t{\n\t\tRI(st[i], ed[i]);\n\t\tREP(j,st[i],ed[i]) if(!vis[j])\n\t\t{\n\t\t\tvis[j] = true;\n\t\t\tans += 50;\n\t\t}\n\t}\n\n\tREP(i,1,31)\n\t{\n\t\tREP(j,1,n) if(st[j]==i) q.push(ed[j]);\n\t\twhile(!q.empty() && q.top()<i) q.pop();\n\t\tif(!q.empty())\n\t\t{\n\t\t\tq.pop();\n\t\t\tans += 50;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<pair<int,int>> ab(n);\n    for(int i=0;i<n;i++) cin>>ab[i].first>>ab[i].second; \n\n    int cnt=0;\n    for(int day=1;day<=31;day++){\n        int bestId=-1;\n        for(int j=0;j<ab.size();j++){\n            if(ab[j].first<=day && day<=ab[j].second){\n                if(bestId==-1 || ab[j].second<ab[bestId].second){\n                    bestId=j;\n                }\n            }\n        }\n        if(bestId!=-1){\n            ab.erase(ab.begin()+bestId);\n            cnt++;\n        }\n    }\n\n    cout<<(31-cnt)*50+cnt*100<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\n#define SIZE 100000\n\nint main(){\n    int n,a,b;\n    int ans = 0;\n    vector<int> day[31];\n    \n    scanf(\"%d\",&n);\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        a--;\n        b--;\n        \n        day[a].push_back(b);\n    }\n    \n    priority_queue<int> pq;\n    \n    \n    for(int i=0;i<31;i++){\n        while(pq.size() && pq.top() > -i) pq.pop();\n\n        for(int j=0;j<day[i].size();j++){\n            pq.push(-day[i][j]);\n        }\n        \n        if(pq.size()){\n            ans += 100;\n            pq.pop();\n        }else{\n            ans += 50;\n        }\n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100 + 11;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[50][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  best = 0;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 50; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] < b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    // cout << a[i] << \"-\" << b[i] << endl;\n  }\n  return rec(0, 0);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n#define INF 1e9\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<vector<edge> > g;\nvoid add_edge(int from,int to,int cap){\n    edge f,t;\n    f = (edge){ to,cap,(int)g[to].size() };\n    g[from].push_back(f);\n    t = (edge){ from,0,(int)g[from].size()-1} ;\n    g[to].push_back(t);\n}\n\nint dfs( int v,int t,int f,vector<bool> &used){\n    if( v== t ) return f;\n    used[v] = true;\n    for(int i=0;i<g[v].size();i++){\n\tedge &e = g[v][i];\n\tif(!used[e.to] && e.cap > 0 ){\n\t    int d = dfs(e.to , t, min(f,e.cap),used);\n\t    if( d> 0){\n\t\te.cap -=d;\n\t\tg[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\nint max_flow(int s,int t){\n    int flow = 0;\n    while(1){\n\tvector<bool> used(g.size(),false);\n\tint f = dfs(s,t,INF,used);\n\tif(f==0) return flow;\n\tflow += f;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    int m = 30,M = 1;\n    g = vector<vector<edge> > ( n + 33);\n    int S = 0,T =n+32;\n    for(int i=1;i<=31;i++) add_edge(S,i,1);\n    for(int i=0;i<n;i++) add_edge( 32 + i , T , 1 );\n    for(int i=0;i<n;i++){\n\tint a,b;\n\tcin>>a>>b;\n\t//a--,b--;\n\tm= min(m,a);\n\tM = max(M,b);\n\tfor(int j=a;j<=b;j++) add_edge( j , 32 + i , 1);\n    }\n    int f = max_flow(S,T);\n    cout<< (M-m+1)*50 + f*50 << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int D = 32;\n#define REP(i, j) for(int i = 0; i < j; i++)\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    if(a.second != b.second) return a.second < b.second;\n    return a.first < b.first;\n  }\n}\n\nint N;\n\nint solve(int d, vector<P> &v, vector<bool> &used){\n  for(int i = 0; i < N; ++i){\n    if(used[i]) continue;\n    if(v[i].first <= d && v[i].second >= d) {\n      used[i] = true;\n      return 100;\n    }\n  }\n  return 50;\n}\n\nint main(){\n  cin >>N;\n  vector<P> v(N);\n  REP(i, N){\n    int a, b; cin >>a >>b;\n    v[i] = P(a, b);\n  }\n  sort(v.begin(), v.end());\n  vector<bool> used(N, false);\n  int ans = 0;\n  for(int d = 1; d <= 31; d++) ans += solve(d, v, used);\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int MAX_V=1000;\nconst int INF=1e9;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int to=0,int cap=0,int rev=0)\n        :to(to),cap(cap),rev(rev){}\n};\n\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap==0||used[e.to])continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d){\n            e.cap-=d;\n            G[e.to][e.rev].cap+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        fill_n(used,MAX_V,false);\n        int f=dfs(s,t,INF);\n        if(f)flow+=f;\n        else return flow;\n    }\n}\n\nint main(){\n    int S=998,T=999;\n\n    int n;cin>>n;\n\n\n    for(int i=0;i<n;i++){\n        add_edge(S,i*2,1);\n        add_edge(i*2,i*2+1,1);\n    }\n\n    for(int i=n;i<n+31;i++){\n        add_edge(i*2,i*2+1,1);\n        add_edge(i*2+1,T,1);\n    }\n\n    for(int i=0;i<n;i++){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        for(int j=n+a;j<=n+b;j++)add_edge(i*2+1,j*2,1);\n    }\n\n    int f=max_flow(S,T);\n    cout<<f*100+(31-f)*50<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N 101\n#define INF (1e9)\nusing namespace std;\nint n,ans,c;\nbool used[N];\npair<int,int> d[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>d[i].first>>d[i].second;\n  sort(d,d+n);\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&d[j].first<=i&&i<=d[j].second&&d[j].second<c) c=j;\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\nint main () {\n\n    ll n; cin >> n;\n    vector<pair<ll, ll>> ab(n);\n    for (ll i = 0; i < n; i++) {\n        cin >> ab[i].first >> ab[i].second;\n    }\n\n    sort(ab.begin(), ab.end(), [](auto x, auto y) -> bool {\n        return x.second == y.second\n            ? x.first < y.first\n            : x.second < y.second;\n    });\n\n    ll ans = 0;\n    vector<bool> watched(32, false);\n    for (ll i = 0; i < n; i++) {\n        for (ll day = ab[i].first; day <= ab[i].second; day++) {\n            if (!watched[day]) {\n                watched[day] = true;\n                ans++;\n                break;\n            }\n        }\n    }    \n\n    cout << (ans + 31) * 50 << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100 + 11;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[50][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  best = 0;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 50; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] > b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    // cout << a[i] << \"-\" << b[i] << endl;\n  }\n  return rec(0, 0);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<pair<int,int>> movie;\n  int num[100] = {0};\n  \n  for(int i = 0;i < n;++i){\n    int a,b;\n    cin>>a;\n    cin>>b;\n\n    movie.push_back(make_pair(a,b));\n  }\n  sort(movie.begin(),movie.end());\n\n  int sum = 0;\n  for(int i = 1;i <= 31;++i){\n    int begin = 0;\n    int end = 0;\n    int place = 0;\n    int times = 0;\n    int check = 0;\n\n    for(pair<int,int> e : movie){\n      if(i >= e.first && i <= e.second){\n        if(check == 0){\n          begin = e.first;\n          end = e.second;\n          place = times;\n          check = 1;\n        }\n        else{\n          if(num[place] == 0 && num[times] == 1){\n            continue;\n          }\n          else{\n            if(end > e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n            else if(end == e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n          }\n        }\n      }\n      ++times;\n    }\n\n    if(num[place] == 0){\n      sum += 100;\n      num[place] = 1;\n    }\n    else{\n      sum += 50;\n    }\n  }\n  cout<<sum<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint ku[40];\nint main(){\n  int n,m;\n  set<int>s;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      s.insert(i);\n      add_edge(1+j,i+40,1);\n    }\n  }\n  r(i,31)add_edge(0,i+1,1);\n  r(i,31)add_edge(i+40,99,1);\n  int p=max_flow(0,99);\n  cout<<p*100+(s.size()-p)*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n;\n  cin >> n;\n  priority_queue<int> q;\n  vector<P> vec;\n  for(int i = 0; i < n; ++i){\n    int a, b;\n    cin >> a >> b;\n    vec.push_back(make_pair(a, b));\n  }\n  sort(vec.begin(), vec.end());\n  vec.push_back(make_pair(100, 100));\n  int i = 0;\n  int ans = 0;\n  for(int d = 1; d <= 31; ++d){\n    while(d == vec[i].first){\n      q.push(-vec[i].second);\n      ++i;\n    }\n    bool f = false;\n    while(!q.empty()){\n      int p = -q.top();\n      q.pop();\n      if(d <= p){\n\tf = true;\n      }\n    }\n    if(f){\n      ans += 100;\n    }else{\n      ans += 50;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * e.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\npii rs[MAX_N];\nbool fs[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> rs[i].first >> rs[i].second;\n    rs[i].first--, rs[i].second--;\n  }\n  sort(rs, rs + n);\n\n  for (int i = 0; i < n; i++)\n    for (int j = rs[i].first; j <= rs[i].second; j++)\n      if (! fs[j]) {\n\tfs[j] = true;\n\tbreak;\n      }\n\n  int sum = 0;\n  for (int i = 0; i < 31; i++) sum += (fs[i] ? 2 : 1);\n\n  printf(\"%d\\n\", sum * 50);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define P pair<int, int>\n#define hi cout<<\"hi\"<<endl;\n#define INF 0x3f3f3f3f\n#define LL long long\ntypedef long long ll;\n\nconst int maxn = 1005;\n\nstruct Edge {\n    int v, next, cap, flow;\n}e[maxn*maxn]; //注意边数\nint head[maxn];\nint cur[maxn], d[maxn];//当前弧下标 结点到汇点距离下界\nint p[maxn], gap[maxn]; //可增广路上的一条弧 gap优化 比dinic多的两个数组\nint tot;\nvoid init()\n{\n    tot = 0;\n    memset(head, -1, sizeof head);\n}\nvoid addedge(int u, int v, int w, int rw = 0)\n{\n    e[tot].v = v; e[tot].cap = w; e[tot].flow = 0;\n    e[tot].next = head[u]; head[u] = tot++;\n    e[tot].v = u; e[tot].cap = rw; e[tot].flow = 0;\n    e[tot].next = head[v]; head[v] = tot++;\n}\n\nint sap(int s, int t, int N) //N 结点总数(包括源点汇点)\n{\n    memset(gap, 0, sizeof(gap));\n    memset(d, 0, sizeof(d));\n    memcpy(cur, head, sizeof(head));\n    int u = s;\n    p[u] = -1;\n    gap[0] = N;\n    int ans = 0;\n    while (d[s] < N)\n    {\n        if (u == t)\n        {\n            int Min = INF;\n            for (int i = p[u]; ~i; i = p[e[i^1].v])\n                if (Min > e[i].cap - e[i].flow)\n                    Min = e[i].cap - e[i].flow;\n            for (int i = p[u]; ~i; i = p[e[i^1].v])\n            {\n                e[i].flow += Min;\n                e[i^1].flow -= Min;\n            }\n            u = s;\n            ans += Min;\n            continue;\n        }\n        int v;\n        bool ok = false;\n        for (int i = cur[u]; ~i; i = e[i].next)\n        {\n\n            v = e[i].v;\n            if (e[i].cap - e[i].flow && d[v] + 1 == d[u])\n            {\n                ok = true;\n                cur[u] = p[v] = i;\n                break;\n            }\n        }\n        if (ok)\n        {\n            u = v;\n            continue;\n        }\n        int Min = N;\n        for (int i = head[u]; ~i; i = e[i].next)\n        {\n\n            if (e[i].cap - e[i].flow && d[e[i].v] < Min)\n            {\n                Min = d[e[i].v];\n                cur[u] = i;\n            }\n        }\n        gap[d[u]]--;\n        if (!gap[d[u]]) return ans;\n        d[u] = Min + 1;\n        gap[d[u]]++;\n        if (u != s) u = e[p[u]^1].v;\n    }\n\n    return ans;\n}\nint l[maxn], r[maxn];\nint main()\n{\n    int n = 31, m;\n    ios::sync_with_stdio(0);\n    cin  >> m;\n\n    init();\n    int s = 0, t = m + n + 1;\n\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> l[i] >> r[i];\n        //r[i] = l[i] + r[i] - 1;\n\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        addedge(s, i, 1);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        for (int j = l[i]; j <= r[i]; j++)\n        {\n            addedge(i, j + m, 1);\n        }\n    }\n    for (int i = m + 1; i <= m + n; i++)\n    {\n        addedge(i, t, 1);\n    }\n    int k = sap(s, t, t + 1);\n\n    cout << 50 * 31 + k * 50 << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n, a, b;\n    multiset<int> m;\n    vector<int> v[32];\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> a >> b;\n        v[a].push_back(b);\n    }\n    int ans = 0;\n    for(int i = 1; i <= 31; i++){\n        for(int x : v[i])   m.insert(x);\n        while(!m.empty() && *(m.begin()) < i)  m.erase(m.begin());\n        if(m.empty())   ans++;\n        else            ans += 2, m.erase(m.begin());\n    }\n    cout << ans*50 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 101\n#define INF (1e9)\nusing namespace std;\nint n,a[N],b[N],ans,c;\nbool used[N];\n \nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&a[j]<=i&&i<=b[j]){\n\tif(c==INF) c=j;\n\telse if(b[j]<b[c]) c=j;\n      }\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n\n  cin>>n;\n  \n  vector<int> movie(n+1,0);\n  vector<int> a(n+1);\n  vector<int> b(n+1);\n  int total=0;\n  \n  for(int i=1;i<=n;++i)\n\tcin>>a[i]>>b[i];\n\n  for(int i=1;i<=31;++i){\n\tfor(int j=1;j<=n;++j){\n\t  if(i >= a[j] && i <= b[j] && movie[j] == 0){\n\t\ttotal+=100;\n\t\tmovie[j]=1;\n\t\tbreak;\n\t  }\n\t  if(j==n)\n\t\ttotal+=50;\n\t}\n  }\n\n  cout<<total<<endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  vector<PII> xs(N);\n  cin >> xs;\n\n  VVI ends(32);\n  for(auto p: xs)\n\tends[p.FF].PB(p.SS);\n\n  int ans = 0;\n  priority_queue<int,VI,greater<int>> pq;\n  FOR(t,1,32){\n\tfor(int e: ends[t])\n\t  pq.push(e);\n\twhile(!pq.empty() && pq.top() < t)\n\t  pq.pop();\n\n\tif(!pq.empty()){\n\t  ans += 100;\n\t  pq.pop();\n\t}\n\telse{\n\t  ans += 50;\n\t}\n  }\n  \n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<tuple<int,int,int> > day;\n    day.resize(n);\n    for(int i=0;i<n;i++){\n        int st,en;\n        cin >> st >> en;\n        day[i] = make_tuple(en-st+1, st-1, en-1);\n    }\n    sort(day.begin(),day.end());\n    int hpdy[31]={};\n    for(tuple<int,int,int>p:day){\n        for(int i=get<1>(p);i<=get<2>(p);i++){\n            if(hpdy[i]==0){\n                hpdy[i]=1;\n                break;\n            }\n        }\n    }\n    int sum=0;\n    for(int i=0;i<31;i++){\n        sum+=hpdy[i]+1;\n    }\n    cout << sum*50 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define INF (1<<29)\nusing namespace std;\ntypedef long long ll;\nint main(){\n      vector<int> dy[32];\n      int a[100],b[100];\n      int n;\n      cin>>n;\n      REP(i,n){\n            cin>>a[i]>>b[i];\n            for(int j=a[i];j<=b[i];j++)dy[j].PB(i);\n      }\n      bool f[100];\n      memset(f,true,sizeof(f));\n      int ans=0;\n      for(int i=1;i<=31;i++){\n            vector<int> tdy;\n            REP(j,dy[i].size()){\n                  if(f[dy[i][j]])tdy.PB(dy[i][j]);\n            }\n            int d=1000000,k=-1;\n            REP(j,tdy.size()){\n                  if(d>(b[tdy[j]]-i)){\n                        d=b[tdy[j]]-i;\n                        k=tdy[j];\n                  }\n            }\n            if(k==-1)ans+=50;\n            else{\n                  ans+=100;\n                  f[k]=false;\n            }\n      }\n      cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 100\n#define INF (1e9)\nusing namespace std;\nint n,a[N],b[N],ans,c;\nbool used[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&a[j]<=i&&i<=b[j]&&b[j]<c) c=j;\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tint N, a[100], b[100];\n\tbool isUsed[100] = {};\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> a[i] >> b[i];\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= 31; i++)\n\t{\n\t\tint mi = 1e9;\n\t\tbool isNew = false;\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i < a[j] || b[j] < i) continue;\n\t\t\tif (isNew && isUsed[j]) continue;\n\t\t\tif (!isNew && !isUsed[j])\n\t\t\t{\n\t\t\t\tisNew = true;\n\t\t\t\tmi = b[j];\n\t\t\t\tisUsed[j] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(mi > b[j])\n\t\t\t\t{\n\t\t\t\t\tmi = b[j];\n\t\t\t\t\tisUsed[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isNew) ans += 100;\n\t\telse ans += 50;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <type_traits>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <limits>\n#include <iostream>\nnamespace lc {\ntemplate <class CapacityType>\nstruct EdgeWithCapacity {\n\tint to;\n\tCapacityType capacity;\n\tEdgeWithCapacity() : to(0), capacity() { }\n\tEdgeWithCapacity(int to, const CapacityType &capacity)\n\t\t: to(to), capacity(capacity)\n\t{ }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n\tListType &operator[](int u){ return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <class EdgeType>\nstruct ResidualEdge : public EdgeType {\n\tint rev;\n\ttemplate <class... Args>\n\tResidualEdge(int rev, Args&&... args)\n\t\t: EdgeType(args...)\n\t\t, rev(rev)\n\t{ }\n};\ntemplate <class EdgeType>\nclass ResidualAdjacencyList\n\t: public AdjacencyList<ResidualEdge<EdgeType>>\n{\npublic:\n\texplicit ResidualAdjacencyList(int n = 0)\n\t\t: AdjacencyList<ResidualEdge<EdgeType>>(n)\n\t{ }\n};\ntemplate <class EdgeType>\nResidualAdjacencyList<EdgeType> make_residual(const AdjacencyList<EdgeType> &graph){\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst int n = graph.size();\n\tResidualAdjacencyList<EdgeType> result(n);\n\tfor(int u = 0; u < n; ++u){\n\t\tfor(const auto &e : graph[u]){\n\t\t\tconst int v = e.to;\n\t\t\tconst int rev_u = result[v].size();\n\t\t\tconst int rev_v = result[u].size();\n\t\t\tresult[u].emplace_back(rev_u, e);\n\t\t\tresult[v].emplace_back(rev_v, e);\n\t\t\tresult[v].back().to = u;\n\t\t\tresult[v].back().capacity = capacity_type();\n\t\t}\n\t}\n\treturn result;\n}\n}\nnamespace lc {\ntemplate <class EdgeType>\nauto maxflow_dinic(\n\tint source, int sink, ResidualAdjacencyList<EdgeType> &graph)\n\t-> decltype(EdgeType().capacity)\n{\n\ttypedef decltype(EdgeType().capacity) capacity_type;\n\tconst capacity_type inf = std::numeric_limits<capacity_type>::max();\n\tconst int n = graph.size();\n\tcapacity_type flow = 0;\n\twhile(true){\n\t\tstd::vector<int> level(n, -1);\n\t\tstd::queue<int> q;\n\t\tlevel[source] = 0;\n\t\tq.push(source);\n\t\twhile(!q.empty()){\n\t\t\tconst int u = q.front();\n\t\t\tq.pop();\n\t\t\tfor(const auto &e : graph[u]){\n\t\t\t\tconst int v = e.to;\n\t\t\t\tif(e.capacity <= 0 || level[v] >= 0){ continue; }\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tif(level[sink] < 0){ break; }\n\t\tstd::vector<size_t> iteration(n, 0);\n\t\twhile(true){\n\t\t\tstd::function<capacity_type(int, capacity_type)> dfs =\n\t\t\t\t[&](int u, capacity_type limit) -> capacity_type {\n\t\t\t\t\tif(u == sink){ return limit; }\n\t\t\t\t\tfor(; iteration[u] < graph[u].size(); ++iteration[u]){\n\t\t\t\t\t\tauto &e = graph[u][iteration[u]];\n\t\t\t\t\t\tconst int v = e.to;\n\t\t\t\t\t\tif(e.capacity <= 0 || level[u] >= level[v]){ continue; }\n\t\t\t\t\t\tconst capacity_type diff =\n\t\t\t\t\t\t\tdfs(v, std::min(e.capacity, limit));\n\t\t\t\t\t\tif(diff > 0){\n\t\t\t\t\t\t\te.capacity -= diff;\n\t\t\t\t\t\t\tgraph[v][e.rev].capacity += diff;\n\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\tconst auto f = dfs(source, inf);\n\t\t\tif(f <= 0){ break; }\n\t\t\tflow += f;\n\t\t}\n\t}\n\treturn flow;\n}\n}\nusing namespace std;\ntypedef lc::EdgeWithCapacity<int> Edge;\ntypedef pair<int, int> pii;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> ir(32);\n\tvector<pii> ranges(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tranges[i] = pii(a, b);\n\t\t++ir[a];\n\t\t--ir[b + 1];\n\t}\n\tfor(int i = 1; i <= 31; ++i){\n\t\tir[i] += ir[i - 1];\n\t}\n\tlc::AdjacencyList<Edge> graph(n + 31 + 2);\n\tconst int source = n + 31, sink = source + 1;\n\tfor(int i = 0; i < n; ++i){\n\t\tgraph.add_edge(source, i, 1);\n\t\tfor(int j = ranges[i].first; j <= ranges[i].second; ++j){\n\t\t\tgraph.add_edge(i, n + j, 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < 31; ++i){\n\t\tgraph.add_edge(n + i, sink, 1);\n\t}\n\tauto residual = lc::make_residual(graph);\n\tconst int f = lc::maxflow_dinic(source, sink, residual);\n\tint answer = f * 50;\n\tfor(int i = 0; i < 31; ++i){\n\t\tif(ir[i] > 0){ answer += 50; }\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\nusing namespace std;\n\nint main(void){\n  int day[31];\n  rep(i,31)day[i]=50;\n  pair<int,int> q[50];\n  int n;\n  cin>>n;\n  int begin = 40;\n  \n \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    --a,--b;\n    q[i] = make_pair(b,a);\n    begin = min(begin,a);\n  }\n  sort(q,q+n);\n  //rep(i,n)cout<<q[i].second<<\" \"<<q[i].first<<endl;\n  rep(i,n){\n    for(int j = q[i].second ; j <= q[i].first ; j ++)\n      if(day[j] == 50){\n\tday[j] = 100;\n\tbreak;\n      }\n  }\n  int res = 0;\n  for(int i = begin ; i < 31 ; i ++)\n    res += day[i];\n  //rep(i,31)cout<<i<<\" \" <<day[i]<<endl;;\n  cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int,P> P3;\ntypedef pair<double, P3> P4;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(3e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    int n, ans=0;\n    vector<P> ls[35];\n    bool used[105]{};\n    cin >> n;\n    REP(i,n){\n        int a, b;\n        cin >> a >> b;\n        ls[a].push_back({b,i});\n    }\n    priority_queue<P, vector<P>, greater<P> > que;\n    for(int i=1;i<=31;i++){\n        for(auto p : ls[i]) que.push(p);\n        while(!que.empty() && que.top().first < i)que.pop();\n        if(!que.empty()){\n            ans += 100;\n            que.pop();\n        }\n        else ans += 50;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<pair<int,int>> movie;\n  int num[100] = {0};\n  \n  for(int i = 0;i < n;++i){\n    int a,b;\n    cin>>a;\n    cin>>b;\n\n    movie.push_back(make_pair(a,b));\n  }\n  sort(movie.begin(),movie.end());\n\n  int sum = 0;\n  for(int i = 1;i <= 31;++i){\n    int begin = 0;\n    int end = 0;\n    int place = 0;\n    int times = 0;\n    int check = 0;\n\n    for(pair<int,int> e : movie){\n      if(i >= e.first && i <= e.second){\n        if(check == 0){\n          begin = e.first;\n          end = e.second;\n          place = times;\n          check = 1;\n        }\n        else{\n          if(num[place] == 1 && num[times] == 0){\n            begin = e.first;\n            end = e.second;\n            place = times;\n          }\n          else if(num[place] == 0 && num[times] == 0){\n            if(end > e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n          }\n          else{\n            continue;\n          }\n        }\n      }\n      ++times;\n    }\n\n    if(num[place] == 0){\n      sum += 100;\n      num[place] = 1;\n    }\n    else{\n      sum += 50;\n    }\n  }\n  cout<<sum<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n \ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n \nstruct BiMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n   \n  BiMatch(){}\n  BiMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n   \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n    match[v]=u;\n    match[u]=v;\n    return true;\n      }\n    }\n    return false;\n  }\n \n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n    fill(used.begin(),used.end(),0);\n    if(dfs(v)){\n      res++;\n    }\n      }\n    }\n    return res;\n  }\n};\n \nsigned main() {\n  int n;\n  cin >> n;\n \n  BiMatch BM(n+32);\n  Rep(i, n) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    for ( int j = a; j <= b; j++ ) {\n      BM.add_edge(i, n+j);\n    }\n  }\n \n  cout << 50*31 + 50*BM.build() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\n#define MAX_V 200\n#define INF 1e9\n \nint V,match[MAX_V];\nvector<int> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int u = G[v][i],w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v = 0 ; v < V ; v++){\n    if(match[v] < 0){\n      memset(used,false,sizeof(used));\n      if(dfs(v)){ res++; }\n    }\n  }\n  return res;\n}\n \nint main(){\n    int N,a,b;\n    cin >> N;\n    for(int i = 0 ; i < N ; i++){\n        cin >> a >> b; a--; b--;\n        for(int j = a ; j <= b ; j++){\n            add_edge(j,i+31);\n        }\n    }\n    V = N + 31;\n    int K = bipartite_matching();\n    cout << 50*(31-K)+100*K << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100 + 11;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[50][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  best = 0;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 50; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] < b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  int res1 = rec(0, 0);\n\n  for (int i = 0; i < 50; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] > b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  int res2 = rec(0, 0);\n\n  return max(res1, res2);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  vector<PII> xs(N);\n  cin >> xs;\n\n  VVI ends(32);\n  for(auto p: xs)\n\tends[p.FF].PB(p.SS);\n\n  int ans = 0;\n  priority_queue<int,VI,greater<int>> pq;\n  FOR(t,1,32){\n\tfor(int e: ends[t])\n\t  pq.push(e);\n\twhile(!pq.empty() && pq.top() < t)\n\t  pq.pop();\n\n\tif(!pq.empty()){\n\t  ans += 100;\n\t  pq.pop();\n\t}\n\telse{\n\t  ans += 50;\n\t}\n  }\n  \n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a;i<(int)(b);i++)\n#define rep(i,b) loop(i,0,b)\ntypedef long long ll;\n\n// 1 indexed\n\nint main(){\n    ll n;\n    while(cin >> n && n){\n        vector<int> a(n), b(n);\n        rep(i,n) cin >> a[i] >> b[i], a[i]--, b[i]--;\n        vector<int> seen(n,false);\n        rep(i,31){\n            int min_fine = 100;\n            int idx = -1;\n            rep(j,n){\n                if(!seen[j] && min_fine > b[j] && a[j] <= i && i <= b[j]){\n                    min_fine = b[j];\n                    idx = j;\n                }\n            }\n            if(idx != -1){\n                seen[idx] = true;\n            }\n        }\n        int s = 0;\n        rep(i,n) if(seen[i]) s++;\n        // rep(i,n){\n        //     cout << seen[i] << \" \";\n        // }\n        // cout << endl;\n        int ans = s*100 + (31-s)*50;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\nint main()\n{\n  int n, happy = 0;\n  int x, y;\n  vector<int> first;\n  vector<int> fin;\n  int watch[35];\n\n  for(int i = 0; i < 35; i++) watch[i] = 0;\n\n  cin >> n;\n\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    first.push_back(x);\n    fin.push_back(y);\n     \n    if(first[i] == fin[i] ){\n      happy += 100;\n      watch[first[i]] = 1;\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int day = 1; day <= 31; day++){\n      if(watch[day] == 0){\n        if(first[i] <= day && day <= fin[i]){\n          happy += 100;\n          watch[day] = 1;\n          break;\n        }\n      }\n    }\n  }\n  \n  for(int i = 1; i <= 31; i++){\n    if(watch[i] == 0) happy += 50;\n  }\n  \n  cout << happy << endl;\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int D = 32;\n#define REP(i, j) for(int i = 0; i < j; i++)\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    if(a.second != b.second) return a.second < b.second;\n    return a.first < b.first;\n  }\n}\n\nint N;\n\nint solve(int d, vector<P> &v, vector<bool> &used){\n  for(int i = 0; i < N; ++i){\n    if(used[i]) continue;\n    if(v[i].first <= d && v[i].second >= d) {\n      used[i] = true;\n      return 100;\n    }\n  }\n  return 50;\n}\n\nint main(){\n  cin >>N;\n  vector<P> v(N);\n  REP(i, N){\n    int a, b; cin >>a >>b;\n    v[i] = P(a, b);\n  }\n  sort(v.begin(), v.end());\n  vector<bool> used(N, false);\n  int ans = 0;\n  for(int d = 1; d <= 31; d++) ans += solve(d, v, used);\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main (int argc, char *argv[]) {\n    int n;\n    int ans = 0;\n    cin>>n;\n    vector<pair<int, int> > p;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        int tmp1, tmp2;\n        cin>>tmp1>>tmp2;\n        p.push_back(make_pair(tmp1, tmp2));\n    }\n    sort(p.begin(), p.end(), [](auto lp, auto rp){\n        return lp.second < rp.second;\n    });\n    // for (auto e : p) {\n    //     cout<<e.first<<\" \"<<e.second<<endl;\n    // }\n    for (int day = 1; day < 32; ++day) {\n        int target = 0;\n        bool flag1 = false;\n        bool flag2 = false;\n        for (int i = 0; i < p.size(); ++i) {\n            if (p[i].first <= day && day <= p[i].second) {\n                flag1 = true;\n                if (!visited[i] && target == 0) {\n                    target = i;\n                    flag2 = true;\n                    visited[target] = true;\n                    // cout <<i<<endl;\n                }\n            }\n        }\n        if (flag1 && flag2) ans += 100;\n        if (flag1 && !flag2) ans += 50;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n;\n  cin >> n;\n  priority_queue<int> q;\n  vector<P> vec;\n  for(int i = 0; i < n; ++i){\n    int a, b;\n    cin >> a >> b;\n    vec.push_back(make_pair(a, b));\n  }\n  sort(vec.begin(), vec.end());\n  vec.push_back(make_pair(100, 100));\n  int i = 0;\n  int ans = 0;\n  for(int d = 1; d <= 31; ++d){\n    while(d == vec[i].first){\n      q.push(-vec[i].second);\n      ++i;\n    }\n    bool f = false;\n    while(!q.empty()){\n      int p = -q.top();\n      q.pop();\n      if(d <= p){\n\tf = true;\n\tbreak;\n      }\n    }\n    if(f){\n      ans += 100;\n    }else{\n      ans += 50;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n\nstruct E {\n\tint to, rev, cap;\n\tE(int to, int rev, int cap) : to(to), rev(rev), cap(cap) {}\n};\n\nconst int MAX_V = 1000;\nint level[MAX_V], iter[MAX_V];\nvector<E> e[MAX_V];\n\nvoid add_undirected_edge(int f, int t, int c) {\n\te[f].push_back(E(t, sz(e[t]), c));\n\te[t].push_back(E(f, sz(e[f]) - 1, c));\n}\n\nvoid add_directed_edge(int f, int t, int c) {\n\te[f].push_back(E(t, sz(e[t]), c));\n\te[t].push_back(E(f, sz(e[f]) - 1, 0));\n}\n\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> q;\n\tlevel[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint v = q.front(); q.pop();\n\t\tfor (auto t : e[v]) {\n\t\t\tif (t.cap > 0 && level[t.to] < 0) {\n\t\t\t\tlevel[t.to] = level[v] + 1;\n\t\t\t\tq.push(t.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < sz(e[v]); i++) {\n\t\tE& _e = e[v][i];\n\t\tif (_e.cap > 0 && level[v] < level[_e.to]) {\n\t\t\tint d = dfs(_e.to, t, min(f, _e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\t_e.cap -= d;\n\t\t\t\te[_e.to][_e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nconst int INF = ten(8);\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint x[31];\n\nint main() {\n\tint n; reader(n);\n\tFOR(i, n) {\n\t\tint a, b; reader(a, b);\n\t\ta--;\n\t\tfor (int j = a; j < b; j++) {\n\t\t\tx[j]++;\n\t\t\tadd_directed_edge(j, 31 + i, 1);\n\t\t}\n\t}\n\tconst int S = 31 + n, T = 31 + n + 1;\n\tFOR(i, 31) add_directed_edge(S, i, 1);\n\tFOR(i, n) add_directed_edge(31 + i, T, 1);\n\n\tint flow = max_flow(S, T);\n\tint cnt = 0;\n\tFOR(i, 31) if (x[i]) cnt++;\n\tint ans = flow * 100 + (cnt - flow) * 50;\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct BiMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n  \n  BiMatch(){}\n  BiMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\n\nsigned main() {\n  int n;\n  cin >> n;\n\n  BiMatch BM(n+32);\n  Rep(i, n) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    for ( int j = a; j <= b; j++ ) {\n      BM.add_edge(i, n+j);\n    }\n  }\n\n  cout << 50*31 + 50*BM.build() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n\n  cin>>n;\n  \n  vector<int> movie(n+1,0);\n  vector<int> a(n+1);\n  vector<int> b(n+1);\n  int total=0;\n  \n  for(int i=1;i<=n;++i)\n\tcin>>a[i]>>b[i];\n\n  for(int i=1;i<=31;++i){\n\tint index=0;\n\tfor(int j=1;j<=n;++j){\n\t  if(i >= a[j] && i <= b[j] && movie[j] == 0){\n\t\tif(index==0 || b[index]>b[j])\n\t\t  index=j;\n\t  }\n\t}\n\tif(index!=0){\n\t  total+=100;\n\t  movie[index]=1;\n\t}\n\telse if(index==0)\n\t  total+=50;\n\t}\n\n  cout<<total<<endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\nint N, A[128], B[128];\n\n\nint main() {\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> A[i] >> B[i];\n\t}\n\tbool check[128] = {0};\n\tint ans = 0;\n\tREP(d,31){\n\t\tint after = 32, wsee = 128;\n\t\tREP(j,N){\n\t\t\tif(check[j])\n\t\t\t\tcontinue;\n\t\t\tif(A[j] <= d && d <= B[j]){\n\t\t\t\tif(after > B[j]){\n\t\t\t\t\tafter = B[j];\n\t\t\t\t\twsee = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(wsee != 128){\n\t\t\tcheck[wsee] = true;\n\t\t\tans += 100;\n\t\t}\n\t\telse{\n\t\t\tans += 50;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int DAY_COUNT = 31;\n\nstruct BipartiteMatching {\n    std::vector<std::vector<int>> G;\n    std::vector<int> match;\n    std::vector<bool> used;\n\n    BipartiteMatching(int V) : G(V), match(V, -1), used(V, false) {}\n    \n    void add_edge(int u, int v)\n    {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    bool dfs(int v)\n    {\n        used[v] = true;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i], w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int matching()\n    {\n        int res = 0;\n        for (int v = 0; v < (int)G.size(); v++) {\n            if (match[v] < 0) {\n                used.assign(used.size(), false);\n                if (dfs(v)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    int N, a, b;\n    std::cin >> N;\n    BipartiteMatching bm(N + DAY_COUNT);\n    for (int i = 0; i < N; i++) {\n\tstd::cin >> a >> b; a--; b--;\n\tfor (int j = a; j <= b; j++) {\n\t    bm.add_edge(j, i + DAY_COUNT);\n\t}\n    }\n    \n    int K = bm.matching();\n    std::cout << 50 * (DAY_COUNT - K) + 100 * K << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<vector<bool>> vv;\n    vector<bool> fv(32,false);\n    vector<int> size;\n    int a,b;\n    int cnt = 0;\n    \n    for(int i=0; i<n; ++i){\n      cin >> a >> b ;\n      vv.push_back(fv);\n      size.push_back(b-a+1);\n      for(int j=a; j<=b; ++j){\n\tvv[i][j] = true;\n      }\n    }\n\n    for(int i=31; i>0; --i){\n      int min = 32;\n      int ans;\n      for(int j=0; j<n; ++j){\n\tif(vv[j][i]==true && size[j]<min){\n\t  min = size[j];\n\t  ans = j;\n\t}\n      }\n      if(min<32){++cnt;}\n      vv[ans] = fv;\n    }\n    cout << cnt << endl;\n    int ans = 1550 + (cnt*50);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\t  \n\t\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\nint main()\n{\n  int n, happy = 0;\n  int x, y;\n  vector<int> first;\n  vector<int> fin;\n  int watch[35];\n\n  for(int i = 0; i < 35; i++) watch[i] = 0;\n\n  cin >> n;\n\n  for(int i = 0; i < n; i++){\n    cin >> x >> y;\n    first.push_back(x);\n    fin.push_back(y);\n     \n    if((first[i] == fin[i]) && watch[first[i]] == 0){\n      happy += 100;\n      watch[first[i]] = 1;\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    for(int day = 1; day <= 31; day++){\n      if(watch[day] == 0){\n        if(first[i] <= day && day <= fin[i]){\n          watch[day] = 1;\n          break;\n        }\n      }\n    }\n  }\n  \n  for(int i = 1; i <= 31; i++){\n    if(watch[i] == 0) happy += 50;\n    else happy += 100;\n  }\n  \n  cout << happy << endl;\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int> > v(n);\n  for(int i=0; i<n; i++) {\n    vector<int> a(2);\n    cin >> a[1] >> a[0];\n    v[i]=a;\n  }\n  sort(v.begin(),v.end());\n  for(int i=0; i<n; i++) swap(v[i][0],v[i][1]);\n  bool u[n];\n  memset(u,0,sizeof(u));\n  int ans=0;\n  for(int i=1; i<=31; i++) {\n    int x=50;\n    for(int j=0; j<n; j++) {\n      if(v[j][0]<=i&&i<=v[j][1]&&!u[j]) {\n        u[j]=1;\n        x=100;\n        break;\n      }\n    }\n    ans+=x;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> A(N), B(N);\n  REP(i, 0, N) cin >> A[i] >> B[i], A[i]--;\n\n  ll s = N + 31, t = N + 31 + 1;\n  vector<ll> movie(N), date(31);\n  REP(i, 0, N) movie[i] = i;\n  REP(i, 0, 31) date[i] = N + i;\n\n  MaxFlow mf(N * 2 + 31 + 2);\n  REP(i, 0, N) {\n    mf.add_directed_edge(s, movie[i], 1);\n    REP(j, A[i], B[i]) mf.add_directed_edge(movie[i], date[j], 1);\n  }\n  REP(i, 0, 31) mf.add_directed_edge(date[i], t, 1);\n\n  ll f = mf.max_flow(s, t);\n  cout << f * 100 + (31 - f) * 50 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1566>\n問題文============================================================\n 太郎君は夏休みの間、毎日１つの映画を近所の映画館で見ることにしました。\n （太郎君の夏休みは8月1日から8月31日までの31日間あります。）\n \n その映画館では、夏休みの間にn つの映画が上映されることになっています。\n それぞれの映画には 1 から n までの番号が割り当てられており、\n i 番目の映画は8月 ai 日から8月 bi 日の間だけ上映されます。\n \n 太郎君は映画を見た時、それが初めて見る映画だった場合は 100 の幸福度を得ることができます。\n しかし、過去に 1 度でも見たことのある映画だった場合は 50 の幸福度を得ます。\n \n 太郎君は上映される映画の予定表をもとに、夏休みの計画を立てることにしました。\n 太郎君が得られる幸福度の合計値が最大になるように映画を見たときの合計値を求めてください。\n \n どの日も必ず1つ以上の映画が上映されていることが保証されます。\n=================================================================\n\n解説=============================================================\n\nできるだけ多く初視聴となる映画をみるには\n 1日から31日まで順番に見て行き、i日目のとき、その区間を覆う期間のうち\n 最も早く期間が終了するもの（bが最も近いもの）を優先して視聴していけば最適となる。\n \n また、その選び方として、sortの他にpriority_queue、フローなどで実装できる\n \n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int n; cin >> n;\n    vector<int> a(n),b(n);\n    for(int i = 0; i < n;i++) {\n        cin >> a[i] >> b[i]; a[i]--; b[i]--;\n    }\n    vector<vector<pii>> G(31);\n    vector<int> flag(n,0);\n    for(int i = 0; i < n;i++){\n        for(int j = a[i]; j <= b[i];j++){\n            G[j].push_back(pii(b[i],i));\n        }\n    }\n    for(int i = 0; i < 31;i++) sort(G[i].begin(),G[i].end());\n    for(int i = 0; i < 31;i++){\n        for(auto e:G[i]){\n            if(flag[e.second] == 0){\n                flag[e.second] = 1;\n                break;\n            }\n        }\n    }\n    ll ans = 50*31;\n    for(int i = 0; i < n;i++){\n        if(flag[i]){\n            ans += 50;\n        }\n    }\n    cout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[31][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 31; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] < b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    // cout << a[i] << \"-\" << b[i] << endl;\n  }\n  return rec(0, 0);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define INF (1<<29)\nusing namespace std;\ntypedef long long ll;\nint main(){\n      vector<int> dy[32];\n      int a[100],b[100];\n      int n;\n      cin>>n;\n      REP(i,n){\n            cin>>a[i]>>b[i];\n            for(int j=a[i];j<=b[i];j++)dy[j].PB(i);\n      }\n      bool f[100];\n      memset(f,true,sizeof(f));\n      int ans=0;\n      for(int i=1;i<=31;i++){\n            vector<int> tdy;\n            REP(j,dy[i].size()){\n                  if(f[dy[i][j]])tdy.PB(dy[i][j]);\n            }\n            int d=1000000,k=-1;\n            REP(j,tdy.size()){\n                  if(d>(b[tdy[j]]-i)){\n                        d=b[tdy[j]];\n                        k=tdy[j];\n                  }\n            }\n            if(k==-1)ans+=50;\n            else{\n                  ans+=100;\n                  f[k]=false;\n            }\n      }\n      cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int INF = 1 << 29;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\n\nstruct Flow {\n  vector< vector< Edge > > G;\n  const int MAXC = 1 << 29;\n  int n;\n  vector<int> used;\n  Flow(int n_) : G(n_), n(n_), used(n_, false) {}\n\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back(Edge(to, cap, G[to].size()));\n    G[to  ].push_back(Edge(from, 0, G[from].size() - 1));\n  }\n\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++) {\n      Edge &e = G[v][i];\n      if(!used[e.to] and e.cap > 0) {\n\tint d = dfs(e.to, t, min(f, e.cap));\n\tif(d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(1) {\n      fill(used.begin(), used.end(), false);\n      int f = dfs(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nint main() {\n  int N; cin >> N;\n  vector<int> a(N), b(N);\n  for(int i=0; i<N; i++) {\n    cin >> a[i] >> b[i];\n  }\n\n  const int D = 32;\n  Flow fl(N + D + 2);\n  int source = N + D, sink = source + 1;\n  for(int i=0; i<N; i++) fl.add_edge(source, i, 1);\n  for(int i=0; i<D; i++) fl.add_edge(N+i, sink, 1);\n  for(int i=0; i<N; i++) {\n    for(int j=a[i]; j<=b[i]; j++) {\n      fl.add_edge(i, N+j, 1);\n    }\n  }\n  int one = fl.max_flow(source, sink);\n  int two = 31 - one;\n  cout << one * 100 + two * 50 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\nusing namespace std;\n\nint main(void){\n  int day[31];\n  rep(i,31)day[i]=50;\n  int n;\n  cin>>n;\n  int begin = 40;\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    begin = min(begin,--a);\n\n    for(int j = a ; j < b ; j ++)\n      if(day[j] == 50){\n\tday[j] = 100;\n\tbreak;\n      }\n  }\n  int res = 0;\n  for(int i = begin ; i < 31 ; i ++)\n    res += day[i];\n  //rep(i,31)cout<<i+1<<\" \" <<day[i]<<endl;;\n  cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<pair<int,int> > day;\n    day.resize(n);\n    for(int i=0;i<n;i++){\n        cin >> day[i].first >> day[i].second;\n    }\n    sort(day.begin(),day.end());\n    int hpdy[31]={};\n    for(pair<int,int>p:day){\n        for(int i=p.first-1;i<p.second;i++){\n            if(hpdy[i]==0){\n                hpdy[i]=1;\n                break;\n            }\n        }\n    }\n    int sum=0;\n    for(int i=0;i<31;i++){\n        sum+=hpdy[i]+1;\n    }\n    cout << sum*50 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a;i<(int)(b);i++)\n#define rep(i,b) loop(i,0,b)\ntypedef long long ll;\n\n// 1 indexed\n\nint main(){\n    ll n;\n    while(cin >> n && n){\n        vector<int> a(n), b(n);\n        rep(i,n) cin >> a[i] >> b[i], a[i]--, b[i]--;\n        vector<int> seen(n,false);\n        rep(i,n){\n            int min_fine = 100;\n            int idx = -1;\n            rep(j,n){\n                if(!seen[j] && min_fine > b[j]){\n                    min_fine = b[j];\n                    idx = j;\n                }\n            }\n            if(idx != -1){\n                seen[idx] = true;\n            }\n        }\n        int s = 0;\n        rep(i,n) if(seen[i]) s++;\n        int ans = s*100 + (31-s)*50;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 200\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint main(){\n  int n,m;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      add_edge(1+j,i+110,1);\n    }\n  }\n  r(i,100)add_edge(0,i+1,1);\n  r(i,36)add_edge(i+110,99,1);\n  int p=max_flow(0,99);\n  cout<<p*50+31*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\nusing namespace std;\n\nint main(void){\n  int day[31];\n  rep(i,50)day[i]=50;\n  int q[50][50];\n  int n;\n  cin>>n;\n  int begin = 40;\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    begin = min(begin,--a);\n\n    for(int j = a ; j < b ; j ++)\n      if(day[j] == 50){\n\tday[j] = 100;\n\tbreak;\n      }\n  }\n  int res = 0;\n  for(int i = begin ; i < 31 ; i ++)\n    res += day[i];\n  //rep(i,31)cout<<i+1<<\" \" <<day[i]<<endl;;\n  cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE = 100;\nint n;\nint a[SIZE];\nint b[SIZE];\n\nbool input() {\n  if (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> a[i] >> b[i];\n      --a[i];\n      --b[i];\n    }\n    return true;\n  }\n  return false;\n}\n\nint dp[31][SIZE];\nint rec(int d, int k) {\n  if (d >= 31) {\n    return 0;\n  }\n  auto& best = dp[d][k];\n  if (best != -1) return best;\n  for (int i = k; i < n; ++i) {\n    if (a[i] <= d && d <= b[i]) {\n      best = max(best, rec(d + 1, i + 1) + 100);\n    }\n  }\n  return best = max(best, rec(d + 1, k) + 50);\n}\n\nint solve() {\n  for (int i = 0; i < 31; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      dp[i][j] = -1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i; j < n; ++j) {\n      if (a[i] > a[j]) {\n        swap(a[i], a[j]);\n        swap(b[i], b[j]);\n      } else if (a[i] == a[j]) {\n        if (b[i] > b[j]) {\n          swap(a[i], a[j]);\n          swap(b[i], b[j]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    // cout << a[i] << \"-\" << b[i] << endl;\n  }\n  return rec(0, 0);\n}\n\nint main() {\n  while (input()) cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main (int argc, char *argv[]) {\n    int n;\n    int ans = 0;\n    cin>>n;\n    vector<pair<int, int> > p;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        int tmp1, tmp2;\n        cin>>tmp1>>tmp2;\n        p.push_back(make_pair(tmp1, tmp2));\n    }\n    sort(p.begin(), p.end(), [](auto lp, auto rp){\n        return lp.second < rp.second;\n    });\n    // for (auto e : p) {\n    //     cout<<e.first<<\" \"<<e.second<<endl;\n    // }\n    for (int day = 1; day < 32; ++day) {\n        int target = 0;\n        bool flag1 = false;\n        bool flag2 = false;\n        for (int i = 0; i < p.size(); ++i) {\n            if (p[i].first <= day && day <= p[i].second) {\n                flag1 = true;\n                if (!visited[i] && target == 0) {\n                    target = i;\n                    flag2 = true;\n                    // cout <<i<<endl;\n                }\n            }\n        }\n        visited[target] = true;\n        if (flag1 && flag2) ans += 100;\n        if (flag1 && !flag2) ans += 50;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint main(){\n  int n,m;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      add_edge(1+j,i+40,1);\n    }\n  }\n  r(i,32)add_edge(0,i+1,1);\n  r(i,32)add_edge(i+40,99,1);\n  int p=max_flow(0,99);\n  cout<<p*50+31*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MN = 110;\nint n;\nint l[MN], r[MN];\n\nbool buf[31];\nbool is[31];\n\nint main() {\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--;\n\t\tl[i] = a; r[i] = b;\n\t\tfor (int j = a; j < b; j++) {\n\t\t\tbuf[j] = true;\n\t\t}\n\t}\n\tint ba = 0;\n\tfor (int i = 0; i < 31; i++) {\n\t\tif (buf[i]) ba++;\n\t}\n\n\n\tint co = 0;\n\tfor (int i = 0; i < 31; i++) {\n\t\tint mi = 1000000;\n\t\tint mij = -1;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (is[j]) continue;\n\t\t\tif (!(l[j] <= i && i < r[j])) continue;\n\t\t\tif (r[j] < mi) {\n\t\t\t\tmi = r[j];\n\t\t\t\tmij = j;\n\t\t\t}\n\t\t}\n\t\tif (mij == -1) continue;\n\t\tba++;\n\t\tis[mij] = true;\n\t}\n\tprintf(\"%d\\n\", ba*50);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 101\n#define INF (1e9)\nusing namespace std;\nint n,a[N],b[N],ans,c;\nbool used[N];\n \nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&a[j]<=i&&i<=b[j]&&b[j]<=b[c]) c=j;\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n  int n;\n\n  cin>>n;\n  \n  vector<int> movie(n+1,0);\n  vector<int> a(n+1);\n  vector<int> b(n+1);\n  int total=0;\n  \n  for(int i=1;i<=n;++i)\n\tcin>>a[i]>>b[i];\n\n  for(int i=1;i<=31;++i){\n\tfor(int j=1;j<=n;++j){\n\t  if(i >= a[j] && i <= b[j] && movie[j] == 0){\n\t\ttotal+=100;\n\t\tmovie[j]=1;\n\t\tbreak;\n\t  }\n\t  if(j==n)\n\t\ttotal+=50;\n\t}\n  }\n\n  cout<<total<<endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n  int n; cin >> n;\n  vector< pair<int,int> > date;\n  vector<int> happy(n, 100);\n  int ans = 0;\n  for(int i=0; i < n; i++){\n    int a, b; cin >> a >> b;\n    date.push_back(make_pair(a,b));\n  }\n  for(int day = 1; day <= 31; day++){\n    int watching = INT_MAX;\n    int w = -1;\n    for(int i=0; i < n; i++){\n      if(date[i].first <= day && day <= date[i].second){\n        if(watching > date[i].second && happy[i] == 100){\n          w = i;\n          watching = date[i].second;\n        }\n      }\n    }\n    if(w == -1){\n      for(int i=0; i < n; i++){\n        if(date[i].first <= day && day <= date[i].second){\n          ans += 50;\n          break;\n        }\n      }\n    }else{\n      ans += happy[w];\n      happy[w] = 50;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 200\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n#define r(i,n) for(int i=0;i<n;i++)\nint main(){\n  int n,m;\n  cin>>n;\n  r(j,n){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    for(int i=a;i<=b;i++){\n      add_edge(1+j,i+110,1);\n    }\n  }\n  r(i,100)add_edge(0,i+1,1);\n  r(i,36)add_edge(i+110,199,1);\n  int p=max_flow(0,199);\n  cout<<p*50+31*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n  Edge(int src, int dst) :\n    src(src), dst(dst) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tGraph g(n+31);\n\tfor(int i = 0 ; i < n ; i++){\n\t\t\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tfor(int j = a ; j <= b ; j++){\t\n\t\t\tg[i].push_back(Edge(i,n+j-1));\n\t\t\tg[n+j-1].push_back(Edge(n+j-1,i));\n\t\t}\n\t}\n\t\n\tEdges dummy;\n\tlong long ans = 31 * 50 + bipartiteMatching(g,n,dummy) * 50;\n\tcout << ans << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tint n,a[102],b[102];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d%d\",&a[i],&b[i]);\n\t\n\tint ret = 0;\n\tpriority_queue<int,vector<int>,greater<int>> que;\n\trep1(i,31){\n\t\trep(j,n)if(a[j] == i)que.push(b[j]);\n\t\twhile(que.size() > 0 && que.top() < i)que.pop();\n\t\tif(que.size() > 0){\n\t\t\tret ++;\n\t\t\tque.pop();\n\t\t}\n\t}\n\tcout << (31+ret)*50 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <tuple>\n\n\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <tuple<int, int>> ranges;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tranges.emplace_back(b, a);\n\t}\n\tstable_sort(ranges.begin(), ranges.end());\n\tvector<bool> looked(31, false);\n\tfor (int i = 0; i < n; i++) {\n\t\tint l, r;\n\t\ttie(r, l) = ranges[i];\n\t\tfor (int j = l - 1; j <= r - 1; j++) {\n\t\t\tif (!looked[j]) {\n\t\t\t\tlooked[j] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < 31; i++)if (looked[i])cnt++;\n\n\tcout << cnt * 100 + (31 - cnt) * 50 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint start,end;\n};\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tInfo info[N];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].start,&info[i].end);\n\t}\n\n\tvector<int> V;\n\tint count = 0;\n\tint  min_end,min_index;\n\n\tfor(int day = 1; day <= 31; day++){\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].start == day){\n\t\t\t\tV.push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tmin_end = BIG_NUM;\n\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\tif(info[V[i]].end < min_end){\n\t\t\t\tmin_end = info[V[i]].end;\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\n\t\tif(min_end != BIG_NUM){\n\t\t\tV.erase(V.begin()+min_index);\n\t\t\tcount++;\n\t\t}\n\n\n\t\tfor(int i = 0; i < V.size(); i++){\n\t\t\tif(info[V[i]].end == day){\n\t\t\t\tV.erase(V.begin()+i);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",100*count+50*(31-count));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin>>n;\n\n  vector<pair<int,int>> movie;\n  int num[100] = {0};\n  \n  for(int i = 0;i < n;++i){\n    int a,b;\n    cin>>a;\n    cin>>b;\n\n    movie.push_back(make_pair(a,b));\n  }\n  sort(movie.begin(),movie.end());\n\n  int sum = 0;\n  for(int i = 1;i <= 31;++i){\n    int begin = 0;\n    int end = 0;\n    int place = 0;\n    int times = 0;\n    int check = 0;\n\n    for(pair<int,int> e : movie){\n      if(i >= e.first && i <= e.second){\n        if(check == 0){\n          begin = e.first;\n          end = e.second;\n          place = times;\n          check = 1;\n        }\n        else{\n          if(num[place] == 1 && num[times] == 0){\n            begin = e.first;\n            end = e.second;\n            place = times;\n          }\n          else if(num[place] == 0 && num[times] == 0){\n            if(end > e.second){\n              begin = e.first;\n              end = e.second;\n              place = times;\n            }\n          }\n          else{\n            continue;\n          }\n        }\n      }\n      ++times;\n    }\n\n    if(num[place] == 0){\n      sum += 100;\n      num[place] = 1;\n    }\n    else{\n      sum += 50;\n    }\n  }\n  \n  cout<<sum<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint ans;\nint N;\nint A[100];\nint B[100];\nbool X[100];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d%d\",&A[i],&B[i]);\n\tfor(int i=0;i<N;i++)X[i]=1;\n\tfor(int i=1;i<=31;i++){\n\t\tint mid=32;\n\t\tint midi=-1;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(A[j]<=i&&i<=B[j]&&X[j]){\n\t\t\t\tmid=min(mid,B[j]);\n\t\t\t\tif(mid==B[j])midi=j;\n\t\t\t}\n\t\t}\n\t\tif(midi==-1){\n\t\t\tans+=50;\n\t\t}\n\t\telse{\n\t\t\tans+=100;\n\t\t\tX[midi]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main (int argc, char *argv[]) {\n    int n;\n    int ans = 0;\n    cin>>n;\n    vector<pair<int, int> > p;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        int tmp1, tmp2;\n        cin>>tmp1>>tmp2;\n        p.push_back(make_pair(tmp1, tmp2));\n    }\n    sort(p.begin(), p.end(), [](auto lp, auto rp){\n        return lp.second < rp.second;\n    });\n    // for (auto e : p) {\n    //     cout<<e.first<<\" \"<<e.second<<endl;\n    // }\n    for (int day = 1; day < 32; ++day) {\n        int target = 0;\n        bool flag1 = false;\n        bool flag2 = false;\n        for (int i = 0; i < p.size(); ++i) {\n            if (p[i].first <= day && day <= p[i].second) {\n                flag1 = true;\n                if (!visited[i] && target == 0) {\n                    target = i;\n                    flag2 = true;\n                    visited[target] = true;\n                    // cout <<i<<endl;\n                }\n            }\n        }\n        if (flag1 && flag2) ans += 100;\n        if (flag1 && !flag2) ans += 50;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  int a[123],b[123];\n  for(int i=0;i<n;i++){\n    cin>>a[i]>>b[i];\n  }\n  multiset<int> m;\n  int nnew=0;\n  for(int i=1;i<=31;i++){\n    for(int j=0;j<n;j++){\n      if(a[j]==i){\n\tm.insert(b[j]);\n      }\n    }\n    if(!m.empty()){\n      nnew++;\n      m.erase(m.begin());\n    }\n    m.erase(i);\n  }\n  cout<<nnew*100+(31-nnew)*50<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n\n\tconst bool operator<(const aa&a)const  {\n\t\treturn time>a.time;\n\t}\n};\n\nint main() {\n\tint N;cin>>N;\n\tvector<pair<int,int>>ps;\n\n\tvector<int>valid(31);\n\n\t\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\tps.emplace_back(a-1,b-1);\n\t\tfor (int k = a - 1; k <= b - 1; ++k) {\n\t\t\tvalid[k]=true;\n\t\t}\n\t}\n\n\tint ans=accumulate(valid.begin(),valid.end(),0);\n\n\tsort(ps.begin(),ps.end());\n\n\tpriority_queue<int,vector<int>,greater<int>>que;\n\n\tfor (int i = 0; i < 31; ++i) {\n\t\tfor (auto p : ps) {\n\t\t\tif (p.first == i) {\n\t\t\t\tque.push(p.second);\n\t\t\t}\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\tint now=que.top();\n\t\t\tque.pop();\n\t\t\tif(now==i-1)continue;\n\t\t\telse {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans*50<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define INF (1<<29)\nusing namespace std;\ntypedef long long ll;\nint main(){\n      vector<int> dy[32];\n      int a[100],b[100];\n      int n;\n      cin>>n;\n      REP(i,n){\n            cin>>a[i]>>b[i];\n            for(int j=a[i];j<=b[i];j++)dy[j].PB(i);\n      }\n      bool f[100];\n      memset(f,true,sizeof(f));\n      int ans=0;\n      for(int i=1;i<=31;i++){\n            vector<int> tdy;\n            REP(j,dy[i].size()){\n                  if(f[dy[i][j]])tdy.PB(dy[i][j]);\n            }\n            if(tdy.size()>0){\n                  int d=b[tdy[0]]-i,k=tdy[0];\n                  for(int j=1;j<tdy.size();j++){\n                        if(d>(b[tdy[j]]-i)){\n                              d=b[tdy[j]];\n                              k=tdy[j];\n                        }\n                  }\n                  ans+=100;\n                  f[k]=false;\n            }else{\n                  ans+=50;\n            }\n      }\n      cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint main() {\n\tint n; cin >> n;\n\tvector<int> a(n), b(n);\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i] >> b[i];\n\tvector<bool> used(n);\n\tint ans = 0;\n\tfor (int t = 1; t <= 31; t++) {\n\t\tint _i, mini = INT_MAX;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] <= t && t <= b[i] && b[i] + used[i] * 100 < mini) {\n\t\t\t\t_i = i;\n\t\t\t\tmini = b[i] + used[i] * 100;\n\t\t\t}\n\t\tans += used[_i] ? 50 : 100;\n\t\tused[_i] = true;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n;\nvector<P> ps;\nbool used[100];\n\nint main(){\n  cin>>n;\n  rep(i,n){\n    ll a,b;\n    cin>>a>>b;\n    a--;\n    ps.push_back(P(a,b));\n  }\n  ll cnt=0;\n  rep(i,31){\n    ll mnse=INF,mnidx=-1;\n    rep(j,n){\n      if(used[j])continue;\n      if(ps[j].fi<=i&&i<ps[j].se){\n        if(mnse>ps[j].se){\n          mnse=ps[j].se;\n          mnidx=j;\n        }\n      }\n    }\n    if(mnidx!=-1){\n      used[mnidx]=true;\n      cnt++;\n    }\n  }\n  cout<<cnt*100+(31-cnt)*50<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 101\n#define INF (1e9)\nusing namespace std;\nint n,a[N],b[N],ans,c;\nbool used[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=1;i<=31;i++){\n    c=INF;\n    for(int j=0;j<n;j++)\n      if(!used[j]&&a[j]<=i&&i<=b[j]&&b[j]<c) c=j;\n    if(c!=INF) used[c]=true;\n  }\n  for(int i=0;i<n;i++)\n    if(used[i]) ans++;\n  cout<<ans*100+(31-ans)*50<<endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1566 Movie\n// 2018.2.6 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int a, b; } T;\nT tbl[101];\nchar seen[101];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint cmp(T *a, T *b) { if (a->b - b->b) return a->b - b->b; return a->a - b->a; }\n\nint main() \n{\n\tint n, i, j, saw, ans;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) tbl[i].a = in(), tbl[i].b = in();\n\tqsort(tbl, n, sizeof(T), cmp);\n\n\tans = 0, saw = 0;\n\tfor (i = 1; i <= 31; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i < tbl[j].a || tbl[j].b < i) continue;\n\t\t\tif (seen[j]) continue;\n\t\t\tans += 100, seen[j] = 1, saw++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tans += (31-saw)*50;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tMovie[] movies = new Movie[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tmovies[i] = new Movie(Integer.parseInt(tmpArray[0]), Integer.parseInt(tmpArray[1]));\n\t\t}\n\n\t\tArrays.sort(movies);\n\n\t\tint first = 0;\n\t\tint date = 0;\n\t\tfor(int i = 0; i < n ;i++){\n//\t\t\tint tmpDate = movies[i].start;\n\n\t\t\tfor(int j = movies[i].start ; j <= movies[i].end ; j++){\n\t\t\t\tif(j > date){\n\t\t\t\t\tfirst++;\n\t\t\t\t\tdate = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(50*31 + 50*first);\n\t}\n\n}\n\nclass Movie implements Comparable<Movie>{\n\tint start;\n\tint end;\n\tint interval;\n\n\tpublic Movie(int s, int e){\n\t\tthis.start = s;\n\t\tthis.end = e;\n\t\tthis.interval = e - s + 1;\n\t}\n\n\t@Override\n\tpublic int compareTo(Movie m) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\treturn this.start == m.start ? (this.interval == m.interval ? 0 : this.interval - m.interval) : this.start - m.start;\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tMovie[] movies = new Movie[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tmovies[i] = new Movie(Integer.parseInt(tmpArray[0]), Integer.parseInt(tmpArray[1]));\n\t\t}\n\n\t\tArrays.sort(movies);\n\n\t\t//debug\n//\t\tfor(int i = 0; i < n; i++){\n//\t\t\tSystem.out.println(movies[i].toString());\n//\t\t}\n\t\tint first = 0;\n\t\tint date = 0;\n\t\t\n\t\tfor(int i = 0; i < n ;i++){\n//\t\t\tint tmpDate = movies[i].start;\n\n\t\t\tfor(int j = movies[i].start ; j <= movies[i].end ; j++){\n\t\t\t\tif(j > date){\n\t\t\t\t\tfirst++;\n\t\t\t\t\tdate = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(50*31 + 50*first);\n\t}\n\n}\n\nclass Movie implements Comparable<Movie>{\n\tint start;\n\tint end;\n\tint interval;\n\n\tpublic Movie(int s, int e){\n\t\tthis.start = s;\n\t\tthis.end = e;\n\t\tthis.interval = e - s + 1;\n\t}\n\n\t@Override\n\tpublic int compareTo(Movie m) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\t//return this.start == m.start ? (this.interval == m.interval ? 0 : this.interval - m.interval) : this.start - m.start;\n\t\treturn this.end == m.end ? (this.start == m.start ? 0 : this.start - m.start) : this.end - m.end;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn \"from \"+start + \" to \"+end;\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tMovie[] movies = new Movie[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tmovies[i] = new Movie(Integer.parseInt(tmpArray[0]), Integer.parseInt(tmpArray[1]));\n\t\t}\n\n\t\tArrays.sort(movies);\n\n\t\t//debug\n//\t\tfor(int i = 0; i < n; i++){\n//\t\t\tSystem.out.println(movies[i].toString());\n//\t\t}\n\t\tint first = 0;\n\t\tint date = 0;\n\t\tboolean[] isFirst = new boolean[32];\n\t\t\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = movies[i].start ; j <= movies[i].end ; j++){\n\t\t\t\tif(!isFirst[j]){\n\t\t\t\t\tisFirst[j] = true;\n\t\t\t\t\tfirst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor(int i = 0; i < n ;i++){\n////\t\t\tint tmpDate = movies[i].start;\n//\n//\t\t\tfor(int j = movies[i].start ; j <= movies[i].end ; j++){\n//\t\t\t\tif(j > date){\n//\t\t\t\t\tfirst++;\n//\t\t\t\t\tdate = j;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tSystem.out.println(50*31 + 50*first);\n\t}\n\n}\n\nclass Movie implements Comparable<Movie>{\n\tint start;\n\tint end;\n\tint interval;\n\n\tpublic Movie(int s, int e){\n\t\tthis.start = s;\n\t\tthis.end = e;\n\t\tthis.interval = e - s + 1;\n\t}\n\n\t@Override\n\tpublic int compareTo(Movie m) {\n\t\t// TODO ?????????????????????????????????????????????\n//\t\treturn this.start == m.start ? (this.interval == m.interval ? 0 : this.interval - m.interval) : this.start - m.start;\n//\t\treturn this.end == m.end ? (this.start == m.start ? 0 : this.start - m.start) : this.end - m.end;\n\t\treturn this.interval == m.interval ? (this.start == m.start ? 0 : this.start - m.start) : this.interval - m.interval;\n\t}\n\n\tpublic String toString(){\n\t\treturn \"from \"+start + \" to \"+end;\n\t}\n\n\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var watched = new bool[n];\n        var to = new int[n];\n        var mo = new List<int>[32];\n        for (int i = 1; i <= 31; i++) mo[i] = new List<int>();\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var a = int.Parse(line[0]);\n            var b = int.Parse(line[1]);\n            for (int j = a; j <= b; j++) mo[j].Add(i);\n            to[i] = b;\n        }\n        var ret = getAns(mo, watched, to);\n        Console.WriteLine(100 * ret + 50 * (31 - ret));\n    }\n    public static int getAns(List<int>[] mo, bool[] watched, int[] to)\n    {\n        var count = 0;\n        for (int i = 1; i <= 31; i++)\n        {\n            var wlist = new List<int>();\n            foreach (var x in mo[i])\n                if (!watched[x]) wlist.Add(x);\n            if (wlist.Count() == 1) { count++; watched[wlist[0]] = true; }\n            else if (wlist.Count() > 1)\n            {\n                var a = getMovie(wlist, to);\n                count++;\n                watched[a] = true;\n            }\n        }\n        return count;\n    }\n    public static int getMovie(List<int> a, int[] to)\n    {\n        var tomin = to[a[0]];\n        var ret = a[0];\n        for (int i = 1; i < a.Count(); i++)\n            if (to[a[i]] < tomin) { tomin = to[a[i]]; ret = a[i]; }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class P\n{\n    public int from { get; set; }\n    public int to { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var te = new int[33];\n        var mv = new int[33];\n        var mv2 = new bool[33];\n        var wt = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var a = int.Parse(line[0]);\n            var b = int.Parse(line[1]);\n            wt[i] = new P { from = a, to = b };\n            te[a]++;\n            te[b + 1]--;\n        }\n        mv[1] = te[1];\n        for (int i = 2; i <= 31; i++) mv[i] = mv[i - 1] + te[i];\n        var ps = wt.OrderBy(x => x.to - x.from).ToArray();\n        var ret = getAns(mv, mv2, ps);\n        Console.WriteLine(ret * 100 + (31 - ret) * 50);\n    }\n    public static int getAns(int[] mv, bool[] mv2, P[] ps)\n    {\n        var c100 = 0;\n        foreach (var x in ps)\n        {\n            if (x.from == x.to)\n                if (mv2[x.from]) continue;\n                else { c100++; mv2[x.from] = true; continue; }\n            var tmin = mv[x.from]; var tmini = x.from;\n            if (tmin == 1 && !mv2[x.from]) { c100++; mv2[x.from] = true; continue; }\n            for (int i = x.from + 1; i <= x.to; i++)\n            {\n                if (mv[i] == 1 && !mv2[i]) { tmini = i; break; }\n                else if (mv[i] < tmin && !mv2[i]) { tmini = i; tmin = mv[i]; }\n            }\n            if (!mv2[tmini])\n            {\n                c100++;\n                mv2[tmini] = true;\n            }\n        }\n        return c100;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public bool watched { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var mo = new List<int>[32];\n        for (int i = 1; i <= 31; i++) mo[i] = new List<int>();\n        var ps = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var a = int.Parse(line[0]);\n            var b = int.Parse(line[1]);\n            for (int j = a; j <= b; j++) mo[j].Add(i);\n            ps[i] = new P { from = a, to = b };\n        }\n        var ret = getAns(ps, mo);\n        Console.WriteLine(100 * ret + 50 * (31 - ret));\n\n    }\n    public static int getAns(P[] ps, List<int>[] mo)\n    {\n        var count = 0;\n        for (int i = 1; i <= 31; i++)\n        {\n            var wlist = new List<int>();\n            foreach (var x in mo[i])\n                if (!ps[x].watched) wlist.Add(x);\n            if (wlist.Count() == 1) { count++; ps[wlist[0]].watched = true; }\n            else if (wlist.Count() > 1)\n            {\n                var a = getMovie(wlist, ps);\n                count++;\n                ps[a].watched = true;\n            }\n        }\n        return count;\n    }\n    public static int getMovie(List<int> a, P[] ps)\n    {\n        var tomin = ps[a[0]].to;\n        var ret = a[0];\n        for (int i = 1; i < a.Count(); i++)\n            if (ps[a[i]].to < tomin) { tomin = ps[a[i]].to; ret = a[i]; }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public bool watched { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var mo = new List<int>[32];\n        for (int i = 1; i <= 31; i++) mo[i] = new List<int>();\n        var ps = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var a = int.Parse(line[0]);\n            var b = int.Parse(line[1]);\n            for (int j = a; j <= b; j++) mo[j].Add(i);\n            ps[i] = new P { from = a, to = b };\n        }\n        var ret = getAns(ps, mo);\n        Console.WriteLine(100 * ret + 50 * (31 - ret));\n\n    }\n    public static int getAns(P[] ps, List<int>[] mo)\n    {\n        var count = 0;\n        var wlist = new List<int>();\n        for (int i = 1; i <= 31; i++)\n        {\n            wlist.Clear();\n            foreach (var x in mo[i])\n                if (!ps[x].watched) wlist.Add(x);\n            if (wlist.Count() == 1) { count++; ps[wlist[0]].watched = true; }\n            else if (wlist.Count() > 1)\n            {\n                var a = getMovie(wlist, ps);\n                count++;\n                ps[wlist[a]].watched = true;\n            }\n        }\n        return count;\n    }\n    public static int getMovie(List<int> a, P[] ps)\n    {\n        var tomin = ps[a[0]].to;\n        var ret = a[0];\n        for (int i = 1; i < a.Count(); i++)\n            if (ps[a[i]].to < tomin) { tomin = ps[a[i]].to; ret = a[i]; }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nN = int(input())\nAs = []\nBs = []\nmovies = [[] for x in range(31)]\nfor n in range(N):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    As.append(a)\n    Bs.append(b)\n    for day in range(a, b+1):\n        movies[day].append(n)\n\npicked = [False] * N\nans = 0\nfor day in range(31):\n    # ????????????????????????\n    unseen_movies = [m for m in movies[day] if not picked[m]]\n\n    # ???????????????????????????\n    if len(unseen_movies) == 0:\n        ans += 50\n    else:\n        # ????????????????????????????????????????????£??¨????????????????????????????????????\n        lastday = 1000\n        should_see = -1\n        for m in unseen_movies:\n            if Bs[m] < lastday:\n                lastday = Bs[m]\n                should_see = m\n        picked[should_see] = True\n        ans += 100\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nN = int(input())\nAs = []\nBs = []\nmovies = [[] for x in range(31)]\nfor n in range(N):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    As.append(a)\n    Bs.append(b)\n    for day in range(a, b+1):\n        movies[day].append(n)\nprint(movies)\n\npicked = [False] * N\nans = 0\nfor day in range(31):\n    # ????????????????????????\n    unseen_movies = [m for m in movies[day] if not picked[m]]\n\n    # ???????????????????????????\n    if len(unseen_movies) == 0:\n        ans += 50\n    else:\n        # ????????????????????????????????????????????£??¨????????????????????????????????????\n        lastday = 1000\n        should_see = -1\n        for m in unseen_movies:\n            if Bs[m] < lastday:\n                lastday = Bs[m]\n                should_see = m\n        picked[should_see] = True\n        ans += 100\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# AOJ 1566 Movie\n# Python3 2018.7.13 bal4u\n\nn = int(input())\ntbl = []\nfor i in range(n):\n\ta, b = map(int, input().split())\n\ttbl.append([b, a])\ntbl.sort()\nans = saw = 0\nseen = [0]*101\nfor i in range(1, 32):\n\tfor j in range(n):\n\t\tif i < tbl[j][1] or tbl[j][0] < i: continue\n\t\tif seen[j]: continue\n\t\tans += 100; seen[j] = 1; saw += 1\n\t\tbreak;\nprint(ans+(31-saw)*50)\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1566 Movie\n# Python3 2018.7.13 bal4u\n\nn = int(input())\ntbl = []\nfor i in range(n):\n\ta, b = map(int, input().split())\n\ttbl.append([b, a])\ntbl.sort()\nans = saw = 0\nseen = [0]*32\nfor i in range(1, 32):\n\tfor j in range(n):\n\t\tif i < tbl[j][1] or tbl[j][0] < i: continue\n\t\tif seen[j]: continue\n\t\tans += 100; seen[j] = 1; saw += 1\n\t\tbreak;\nprint(ans+(31-saw)*50)\n"
  },
  {
    "language": "Python",
    "code": "# coding:utf-8\n\nimport sys\nimport heapq\n# from collections import Counter, defaultdict\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\n\nn = II()\nM = [LI() for _ in range(n)]\nfor a in zip(* M):\n    start = set(a)\n    break\nM.sort()\n# print(start)\n\nans = 0\nindex = 0\nhq = []\nfor i in range(31):\n    if i + 1 in start:\n        while i + 1 in start and M[index][0] == i + 1:\n            heapq.heappush(hq, M[index][1])\n            index += 1\n            if index >= n:\n                break\n\n    while hq and hq[0] < i + 1:\n        if hq:\n            tmp = heapq.heappop(hq)\n        else:\n            break\n\n    if hq:\n        ans += 100\n        tmp = heapq.heappop(hq)\n    else:\n        ans += 50\n\n    # print(i+1, ans, hq)\n\nprint(ans)\n\n"
  }
]