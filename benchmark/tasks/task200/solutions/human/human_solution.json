[
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-512);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      //L *= 10;\n      //L = round(L);\n      //L /= 10.0;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nbool used[401];\nchar c;\nint n;\ndouble x,y;\nP p[401];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+401,0);\n\t\tint m=0;\n\t\tp[0]=P(0.0,0.0);\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tp[i+1]=P(x,y);\n\t\t}\n\t\tdouble ans=0.0;\n\t\tP v(0.0,1.0);\n\t\trep(h,n){\n\t\t\tused[m]=1;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n+1)if(i!=m&&!used[i]&&dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M){M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<endl;\n\t\t\tans+=abs(p[nx]-p[m]);\n\t\t\tused[nx]=1;\n\t\t\tm=nx;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n \nstruct Point{\n    double x,y;\n \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n \ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n \ntypedef Point Vector;\n \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nint main(){\n    int N;\n    while(cin >> N, N){\n\tPoint np(0,0);\n\tVector v(0,1);\n\tvector<Point> p(N);\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> p[i];\n\t}\n\tdouble res = 0;\n\tbool visited[MAX_N] = {false};\n\tfor(int i = 0 ; i < N ; i++){\n\t    int idx = -1;\n\t    double min = INF,d = INF;\n\t    for(int j = 0 ; j < N ; j++){\n\t\tif(visited[j]){ continue; }\n\t\tVector v2 = p[j]-np;\n\t\tdouble angle = acos(dot(v,v2)/abs(v)/abs(v2));\n\t\tif(lt(angle,min)){\n\t\t    d = dist(np,p[j]);\n\t\t    min = angle;\n\t\t    idx = j;\n\t\t}else if(equal(angle,min)){\n\t\t    if(lt(dist(np,p[j]),d)){\n\t\t\td = dist(np,p[j]);\n\t\t\tmin = angle;\n\t\t\tidx = j;\n\t\t    }\n\t\t}\n\t    }\n\t    visited[idx] = true;\n\t    res += dist(np,p[idx]);\n\t    v = p[idx]-np;\n\t    np = p[idx];\n\t}\n\tprintf(\"%.1f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\ntypedef complex<double> point;\n\n//#define PI 3.141592653589793238462643383279\n// e·éë·Ã\n#define EPS (1e-10)\n// 2ÂÌXJ[ªµ¢©Ç¤©\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nbool used[440];\n\nint main(){\n    int n,i,j;\n\n    while( cin >> n, n ){\n        memset(used, false, sizeof(used));\n        double run = 0.0;\n\n        vector<point> p;\n        rep(i,n){\n            int x,y; cin >> x >> y;\n            p.push_back(point(x,y));\n        }\n\n        point now(0,0), dir(0,1);\n\n        for(;;){\n            int id = -1;\n            double ag = 1000;\n            rep(i,n){\n                if( !used[i] ){\n                    double a = std::arg(dir/(p[i] - now));\n                    if( ag > a || (EQ(ag,a) && abs(p[id] - now) > abs(p[i] - now)) ){\n                        ag = a;\n                        id = i;\n                    }\n                }\n            }\n            if( id == -1 ) break;\n            run += abs(p[id] - now);\n            dir = (p[id] - now) / abs(p[id] - now);\n            now = p[id];\n            used[id] = true;\n        }\n\n        printf(\"%.1lf\\n\",run);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic Point flag[401];\n\t\tflag[0]=Point(0,0);\n\t\tfor(int i=1;i<=n;i++)\tscanf(\"%lf%lf\",&flag[i].x,&flag[i].y);\n\n\t\tint _1st=0,_2nd;\n\t\tint xmin=1<<30,ymin=1<<30;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(flag[i].x<xmin || (flag[i].x==xmin && flag[i].y<ymin)){\n\t\t\t\t_2nd=i;\n\t\t\t\txmin=(int)flag[i].x;\n\t\t\t\tymin=(int)flag[i].y;\n\t\t\t}\n\t\t}\n\n\t\tstatic bool checked[401];\n\t\tfor(int i=0;i<=n;i++)\tchecked[i]=false;\n\t\tchecked[_1st]=checked[_2nd]=true;\n\n\t\tvector<int> ans;\n\t\tans.pb(_1st);\n\t\tans.pb(_2nd);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint jopt;\n\t\t\tdouble minang=-1e9;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(checked[j])\tcontinue;\n\t\t\t\tPoint v1=flag[_2nd]-flag[_1st],v2=flag[j]-flag[_2nd];\n\t\t\t\tdouble ang=dot(v1,v2)/(sqrt(norm2(v1))*sqrt(norm2(v2)));\n\t\t\t\tif(minang+EPS<ang\n\t\t\t\t||(abs(ang-minang)<EPS && norm2(v2)+EPS<norm2(flag[jopt]-flag[_2nd]))){\n\t\t\t\t\tjopt=j;\n\t\t\t\t\tminang=ang;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.pb(jopt);\n\t\t\tchecked[jopt]=true;\n\t\t\t_1st=_2nd;\n\t\t\t_2nd=jopt;\n\t\t}\n\n\t\tdouble len=0;\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tlen+=sqrt(norm2(flag[ans[i+1]]-flag[ans[i]]));\n\t\t}\n\t\tprintf(\"%.1f\\n\",len);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\nstruct air{int X,Y;air() {};air (int a, int b) {X=a,Y=b;}};bool operator <(air a, air b) {if (a.X!=b.X) return a.X<b.X; return a.Y<b.Y;}\nair RB[405];int N;bool used[405];int Mahou[405];bool degree(int a, int b, int c) {int S=RB[a].X*RB[b].Y+RB[b].X*RB[c].Y+RB[c].X*RB[a].Y-RB[a].Y*RB[b].X-RB[b].Y*RB[c].X-RB[c].Y*RB[a].X;return (S>0);}\nint main() {\n    int i,j,k;while (1) {scanf(\"%d\",&N);if (!N) return 0;for (i=0;i<N;i++) {scanf(\"%d %d\",&j,&k);RB[i]=air(j,k);used[i]=1;}N++;RB[i]=air(0,0);sort(RB,RB+N);Mahou[0]=0,Mahou[1]=1,used[N-1]=1,used[0]=0,used[1]=0;\n        for (i=2,j=1,k=2;k<N;i+=j) {if (i==N) i=N-1,j=-1; else if (!i) j=1;if (!used[i]) continue;while (degree(Mahou[k-2],Mahou[k-1],i)) used[Mahou[--k]]=1;Mahou[k++]=i,used[i]=0;}\n\t\tdouble ans=0.00;for (i=1;i<N;i++) ans+=sqrt((RB[Mahou[i]].X-RB[Mahou[i-1]].X)*(RB[Mahou[i]].X-RB[Mahou[i-1]].X)+(RB[Mahou[i]].Y-RB[Mahou[i-1]].Y)*(RB[Mahou[i]].Y-RB[Mahou[i-1]].Y));printf(\"%.1lf\\n\",ans);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//geo\n#include <complex>\ntypedef complex<double> P;\ninline bool equal(double x, double y){\n  return abs(x - y) < EPS;\n}\ninline bool operator == (const P& x, const P& y){\n  return equal(x.real(), y.real()) && equal(x.imag(), y.imag());\n}\ndouble dot(P x, P y){\n  return real(conj(x) * y);\n}\ndouble cross(P x, P y){\n  return imag(conj(x) * y);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n//---\nint main(){\n  int n;\n  while(cin>>n && n ){\n    vector<P> points;\n    vector<bool> used(n);\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      points.push_back(P(x,y));\n    }\n    P now(0, 0);\n    double ans = 0;\n    REP(time, n){\n      int next = -1;\n      REP(i, n)if(!used[i]){\n        bool ok = true;\n        REP(j, n)if(!used[j] && i != j){\n          int cw = ccw(now, points[i], points[j]);\n          if(cw == 0 || cw == 1) {\n            ok = false;\n          }\n          assert(cw != 2);\n        }\n        if(ok){\n          assert(next == -1);\n          next = i;\n        }\n      }\n      assert(next != -1);\n      used[next] = true;\n      ans += abs(points[next] - now);\n      now = points[next];\n    }\n    printf(\"%.1lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\ntypedef pair<P,int> PP;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}}\ndouble toDo(double agl){return agl*180.0/M_PI;}\ndouble D(P a, P b) {\n  return sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\nP calc(P a, P b, P c) {\n  double r=toDo(atan2(c.imag()-b.imag(),c.real()-b.real()));\n  double r2=toDo(atan2(b.imag()-a.imag(),b.real()-a.real()));\n  double r3=r-r2;\n  if(r3<=0) r3+=360;\n  return P(-r3,D(b,c));\n}\nint main() {\n  int n;\n  while(cin >> n && n) {\n    P p=P(0,-1),q=P(0,0);\n    P a[n];\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    double ans=0;\n    for(int i=0; i<n; i++) {\n      vector<PP> v;\n      for(int j=0; j<n; j++) {\n        if(u[j]) continue;\n        P r=calc(p,q,a[j]);\n        v.push_back(PP(r,j));\n      }\n      sort(v.begin(),v.end());\n      ans+=v[0].first.imag();\n      u[v[0].second]=1;\n      swap(p,q);\n      q=a[v[0].second];\n    }\n    printf(\"%.1f\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n  point operator / (double d){return point(x/d,y/d);}\n  bool operator == (const point &p )const{return abs(x-p.x)<EPS && abs(y-p.y)<EPS;}\n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n    \n    sort(v.begin(),v.end(),cmp_x);    \n\n    double sum=dist(v[0],v[1]);\n    bool fg[401];\n    point prev=v[0],now=v[1];\n    int nowID=1;\n    fill(fg,fg+401,false);\n    fg[0]=true;\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && getAngle(prev,now,v[j])>angle){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])<dist(now,v[id])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tif(res*10-(int)(res*10)>=0.05){\n\t\t\tres+=0.05;\n\t\t}\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\nbool eq(double a, double b){\n    return ( a-b < 0.0000001 && a-b > -0.0000001 );\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( cin >> n, n ){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i];\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1f\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//テ「ツ?サテッツスツイテッツスツケテッツセツ津ッツセツ敕」ツ?ォテゥツ卍静」ツつ?\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n   \n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(ps[i]-cur1,cur1-cur2);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && minDist > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += minDist;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n/*\ndouble adjust(double theta) {\n  \n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n*/\n\ndouble calcCos(const P& a, const P& b) {\n  return dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) );\n}\n\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      \n      double cos_ = -10e9;\n      double len  = 10e9;\n      \n      /*\n      double angle = 10;\n      double len = 10e9;\n      */\n      \n      for(int i=0; i<n; i++) {\n\t\n\tif(!used[i]) {\n\t  /*\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\n\t   */\n\t  double costmp = calcCos(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( cos_ < costmp || ( equals(cos_, costmp) && len > lentmp ) ) {\n\t    cos_ = costmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t  \n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      double l = sqrt(norm(p[next] - curr));\n      ans += l;\n      orient = (p[next] - curr) / l;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    //double cosn=dot(a,b)/(abs(a)*abs(b));\n    //double sinn=cross(a,b);\n    //double angle=acos(cosn);\n    //if(sinn>0||EQ(sinn,0))\n    //    return angle;\n    //return 2*PI-angle;\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return 0;\n    //return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg(last_vector) - arg(*it - last_point);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      cerr << n << endl;\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cerr << ps[i].x << \" \" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-500);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t      //if(equals(getArgV2(cur-cur2,ps[next]-cur), getArgV2(cur-cur2,ps[i]-cur)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      \n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[500];\ndouble y[500];\nint v[500];\ndouble eps=1e-9;\ndouble PI=acos(-1.0);\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tdouble X=0;\n\t\tdouble Y=0;\n\t\tfor(int i=0;i<a;i++)v[i]=0;\n\t\tdouble ret=0;\n\t\tdouble now=PI/2;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble r=999999;\n\t\t\tdouble th=-999999;\n\t\t\tint at=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(v[j])continue;\n\t\t\t\tdouble tmp=atan2(y[j]-Y,x[j]-X);\n\t\t\t\twhile(tmp>now+eps){\n\t\t\t\t\ttmp-=PI*2;\n\t\t\t\t}\n\t\t\t\tif(th+eps<tmp||(th<tmp+eps&&r>sqrt((x[j]-X)*(x[j]-X)+(y[j]-Y)*(y[j]-Y)))){\n\t\t\t\t\tth=tmp;\n\t\t\t\t\tat=j;\n\t\t\t\t\tr=sqrt((x[at]-X)*(x[at]-X)+(y[at]-Y)*(y[at]-Y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow=th;\n\t\t\tv[at]=1;\n\t\t\tret+=r;\n\t\t\tX=x[at];Y=y[at];\n\t\t//\tprintf(\"%f %f\\n\",X,Y);\n\t\t}\n\t\tprintf(\"%.1f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//テ・ツ、ツ嘉ヲツ閉ーテ」ツ?ォテ、ツクツ?ヲツ猟ヲテ」ツ??」ツつ古」ツ?ヲテ」ツ?淌」ツつ嘉」ツ?ーテ」ツ?静」ツ?」テ」ツ??\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-500);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t      //if(equals(getArgV2(cur-cur2,ps[next]-cur), getArgV2(cur-cur2,ps[i]-cur)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      \n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n  double cosn=dot(a,b)/(abs(a)*abs(b));\n  double sinn=cross(a,b)/(abs(a)*abs(b));\n  if(cosn>=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn<=0){\n    double angle=acos(cosn);\n    return PI-angle+PI;\n  }\n  else if(cosn>=0&&sinn<=0){\n    double angle=acos(cosn);\n    return PI-angle+PI;\n  }\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        P cp=P(0,1);\n        double sum=0;\n        bool first=true;\n        P pp=P(0,0);\n        while(count(isUsed.begin(),isUsed.end(),true)!=points.size()){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i])\n                    continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp)){\n                        idx=i;\n                    }\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            //cout<<inc<<\" \"<<idx<<endl;\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n            first=false;\n        }\n        printf(\"%.1f\\n\",sum);\n        //cout<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n\ndouble adjust(double theta) {\n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      double angle = 10;\n      int next = -1;\n      for(int i=0; i<n; i++) {\n\tif(!used[i]) {\n\t  if(angle > calcAng(orient, p[i]-curr)) {\n\t    angle = calcAng(orient, p[i]-curr);\n\t    next = i;\n\t  }\n\t}\n      }\n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||abs(ps[i])<abs(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p;\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&cross(s-b,ps[j]-s)<=0){\n\t  p=ps[j];\n\t  break;\n\t}\n      }\n      for(int j=0;j<n;j++){\n\tif(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\tif(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\tif(equals(mycos(s-b,ps[j]-s),mycos(s-b,p-s))&&abs(s-ps[j])<abs(s-p)) p=ps[j];\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n\ndouble adjust(double theta) {\n  /*\n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  */\n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n\n#define equals(a, b) fabs((a) - (b)) < EPS\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // 譁ケ蜷代?繧ッ繝医Ν\n    P curr = P(0, 0);    // 迴セ蝨ィ菴咲スョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      double angle = 10;\n      double len = 10e9;\n      \n      for(int i=0; i<n; i++) {\n\tif(!used[i]) {\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg(*it - last_point) - arg(last_vector);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> P;\n\ndouble dist(P a, P b)\n{\n\treturn abs(a-b);\n}\n\ndouble angle(P a, P b, P c)\n{\n\treturn arg((c-b)/(b-a));\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool isequal(double a, double b)\n{\n\treturn fabs(a-b) < EPS;\n}\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N), N)\n\t{\n\t\tvector<P> v(N);\n\t\tvector<bool> used(N, false);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\", &x,&y);\n\t\t\tv[i]=P(x,y);\n\t\t}\n\n\t\tdouble ans=0;\n\t\tP a=P(0,-1),b=P(0,0);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint select=-1;\n\t\t\tdouble alg=0;\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(ccw(a,b,v[j]) > 0) continue;\n\t\t\t\t\n\t\t\t\tdouble t=angle(a,b,v[j]);\n\t\t\t\tif(select==-1)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(isequal(alg,t))\n\t\t\t\t{\n\t\t\t\t\tif(dist(b,v[j]) < dist(b, v[select]))\n\t\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t>alg)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[select]=true;\n\t\t\ta=b; b=v[select];\n\t\t\tans+=dist(a,b);\n\t\t}\n\n\t\tprintf(\"%.1lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cmath>\n\n#define ERROR 0x00\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> line,seg,pp;\n\nconst double eps = 1.0e-4;\nconst double pi = acos(-1.0);\nconst double infty = 1e10;\npoint base(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\nint main(){\n  while(true){\n    int n ;\n    elem ans=0;\n    vector<point> vp;\n    bool vis[500]={false,};\n    cin >> n;\n    if( n == 0 ) break;\n    vp.push_back(point(0,0));\n    REP(i,n){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back(point(x,y));\n    }\n    point prev=point(0,-10);\n    point now=vp[0];\n    vis[0]=true;\n    while(true){\n      int next_vis=0;\n      elem min_arg=3*pi;\n      elem min_dist=infty;\n      point next=vp[0];\n      REP(i,vp.size()){\n\tif(!vis[i]){\n\t  elem t = varg(now-prev,vp[i]-now);\n\t  // cout << now << \" -> \" << vp[i] << \" = \" << t << endl;\n\t  if( leq( t, min_arg ) ){\n\t    if( eq( t, min_arg ) ){\n\t      if( lt( abs(vp[i]-now), min_dist) ){\n\t\tmin_dist = abs(vp[i]-now);\n\t      }else continue;\n\t    }\n\t    min_arg = t;\n\t    min_dist = lt(abs(vp[i]-now),min_dist)?abs(vp[i]-now):min_dist;\n\t    next = vp[i];\n\t    next_vis = i;\n\t  }\n\t}\n      }\n      // cout << \" NEXT : \" << next << endl;\n      if( next_vis == 0 ) break;\n      else{\n\tans+=abs(next-now);\n\tprev=now;\n\tnow=next;\n\tvis[next_vis]=true;\n      }\n    }\n    printf(\"%.1lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x > b.x;\n  return a.y > b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y < p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n  /*\n  cout << \"in andrew, raw data\" << endl;\n  rep(i,l.size())cout << \"(\" << l[i].x << \",\" << l[i].y << \")\" << endl;\n  cout << endl;\n  */\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      /*\n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      */\n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      //cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a,b)/(abs(a)*abs(b)));\n}\n\nconst int MAXN = 401;\n\nint N;\nP ps[MAXN];\nbool used[MAXN];\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(used, used+MAXN, false);\n    P s(0,-1);\n    P t(0,0);\n    double sum = 0;\n    for(int tc = 0; tc < N; ++tc) {\n      int j = -1;\n      for(int i = 0; i < N; ++i) {\n        if(used[i]) continue;\n        if(j == -1) {\n          j = i; continue;\n        }\n        P p = ps[i];\n        P q = ps[j];\n        if(cross(t-s,p-s) > 0.0) continue;\n        if(cross(q-t,p-t) > 0.0 ||\n           cross(q-t,p-t) == 0.0 && norm(q-t) > norm(p-t)) {\n          j = i;\n        }\n      }\n      used[j] = true;\n      P u = ps[j];\n      sum += abs(u-t);\n      s = t;\n      t = u;\n    }\n    printf(\"%.1f\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dist(P a, P b)\n{\n\treturn abs(a-b);\n}\n\ndouble angle(P a, P b, P c)\n{\n\treturn arg((c-b)/(b-a));\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N), N)\n\t{\n\t\tvector<P> v(N);\n\t\tvector<bool> used(N, false);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\", &x,&y);\n\t\t\tv[i]=P(x,y);\n\t\t}\n\n\t\tdouble ans=0;\n\t\tP a=P(0,-1),b=P(0,0);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint select=-1;\n\t\t\tdouble alg=0;\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(ccw(a,b,v[j]) > 0) continue;\n\t\t\t\t\n\t\t\t\tdouble t=angle(a,b,v[j]);\n\t\t\t\tif(select==-1)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t==alg)\n\t\t\t\t{\n\t\t\t\t\tif(dist(b,v[j]) < dist(b, v[select]))\n\t\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t>alg)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[select]=true;\n\t\t\ta=b; b=v[select];\n\t\t\tans+=dist(a,b);\n\t\t}\n\n\t\tprintf(\"%.1lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef complex<double> ci;\ntypedef pair<double,pair<double,int> > pdd;\npint fg[400];\nbool used[400];\ndouble eps=1e-8;\nint main(){\n    int n;\n    while(cin>>n,n){ \n        rep(i,n) cin>>fg[i].first>>fg[i].second;\n        sort(fg,fg+n);\n        memset(used,0,sizeof(used));\n        ci ppr(0,0),pre(0,0),cur(fg[0].first,fg[0].second);\n        double sum=abs(cur-pre);\n        used[0]=true;\n        ppr=pre;pre=cur;\n        FOR(i,1,n){\n            vector<pdd> vp;\n            double mxag=10;\n            rep(j,n){\n                if(used[j]) continue;\n                ci c(fg[j].first,fg[j].second);\n                ci scur=c-pre;\n                double prag=arg(pre-ppr)+M_PI;\n                double cuag=arg(scur)+M_PI;\n                cuag=prag-cuag;\n                if(cuag<0) cuag+=2*M_PI;\n                mxag=mxag-cuag>eps?cuag:mxag;\n                if(abs(mxag-cuag)<eps){\n                    cuag=mxag;\n                    vp.pb(mp(cuag,mp(abs(scur),j)));\n                }\n            }\n            pdd p=*min_element(vp.begin(),vp.end());\n            used[p.second.second]=true;\n            sum+=p.second.first;\n            ppr=pre;\n            pre=ci(fg[p.second.second].first,fg[p.second.second].second);\n        }\n        cout<<fixed<<setprecision(1)<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n\n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y < p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  u.pop_back();\n\t}\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  l.pop_back();\n\t}\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n\n  vector<Point> ret;\n\n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n    }\n\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n    }\n\n\n  return ret;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint n;\nvector<Point> input;\n\nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n\n}\n \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point now = Point(0,0); \n  now.index = -1; \n  while(true)\n    {\n      vector<Point> vec;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  vec.push_back(input[i]);\n\t}\n\n      if(vec.empty())break;\n\n      vec.push_back(now);\n      vec = andrewScan(vec,now);\n\n      rep(i,vec.size())\n\t{\n\t      rep(k,n)\n\t\t{\n\t\t  if(used[k])continue;\n\t\t  if(input[k].index == vec[i].index || input[k].index == vec[(i+1)%vec.size()].index)continue;\n\t\t  if(equals(getDistanceSP(Segment(vec[i],vec[(i+1)%vec.size()]),input[k]),0))\n\t\t    {\n\t\t      //cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") and (\" << vec[(i+1)%vec.size()].x << \",\" << vec[(i+1)%vec.size()].y << \")  --- > (\" << input[k].x << \",\" << input[k].y << \")\" << endl;  \n\t\t      used[k] = true;\n\t\t  }\n\t\t  \n\t\t}\n\t}\n      /*\n      cout << \"remain \" << endl;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  cout << input[i].x << \",\" << input[i].y << endl;\n\t}\n      cout << endl;\n      */\n      /*\n      cout << \"after andrew, \" << endl;\n      rep(i,vec.size())\n\t{\n\t  cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") \" << vec[i].index << endl;\n\t}\n      cout << endl;\n      */\n      rep(i,vec.size()-1)\n\t{\n\t  L += sqrt(pow(vec[i].x-vec[i+1].x,2)+pow(vec[i].y-vec[i+1].y,2));\n\t  if(vec[i].index == -1)continue;\n\t  used[vec[i].index] = true;\n\t}\n      now = vec[vec.size()-1];\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n      solve();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic Point flag[401];\n\t\tflag[0]=Point(0,0);\n\t\tfor(int i=1;i<=n;i++)\tscanf(\"%lf%lf\",&flag[i].x,&flag[i].y);\n\n\t\tint _1st=0,_2nd;\n\t\tint xmin=1<<30,ymin=1<<30;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(flag[i].x<xmin || (flag[i].x==xmin && flag[i].y<ymin)){\n\t\t\t\t_2nd=i;\n\t\t\t\txmin=(int)flag[i].x;\n\t\t\t\tymin=(int)flag[i].y;\n\t\t\t}\n\t\t}\n\n\t\tstatic bool checked[401];\n\t\tfor(int i=0;i<=n;i++)\tchecked[i]=false;\n\t\tchecked[_1st]=checked[_2nd]=true;\n\n\t\tvector<int> ans;\n\t\tans.pb(_1st);\n\t\tans.pb(_2nd);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint jopt;\n\t\t\tdouble minang=-1e9;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(checked[j])\tcontinue;\n\t\t\t\tdouble ang=dot(flag[j]-flag[_2nd],flag[_2nd]-flag[_1st]);\n\t\t\t\tif(minang+EPS<ang\n\t\t\t\t||(abs(ang-minang)<EPS && norm2(flag[j]-flag[_2nd])+EPS<norm2(flag[jopt]-flag[_2nd]))){\n\t\t\t\t\tjopt=j;\n\t\t\t\t\tminang=ang;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.pb(jopt);\n\t\t\tchecked[jopt]=true;\n\t\t\t_1st=_2nd;\n\t\t\t_2nd=jopt;\n\t\t}\n\n\t\tdouble len=0;\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tlen+=sqrt(norm2(flag[ans[i+1]]-flag[ans[i]]));\n\t\t}\n\t\tprintf(\"%d\\n\",(int)(len+0.5));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n  \nusing namespace std;\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n \ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n \nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n \nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n \nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n \nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n \nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n \nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n \nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n \nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n      ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n \nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n         min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n \n \npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n \n \ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n \nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n \npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n \nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n \nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n \ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n \ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n  //return atan2(a.y,a.x)-atan2(b.y,b.x)*360;\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;ps.clear();\n    map<Point,int> m;m.clear();\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      ps.push_back(p);\n    }\n    sort(ps.begin(),ps.end());\n    for(int i=0;i<n;i++) m[ps[i]]=i;\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n    if(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n        if(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n    if(s.x||norm(ps[i])<norm(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p = Point(-1,-1);\n      for(int j=0;j<n;j++){\n    if(p.x<0){\n      if(!u[j]&&cross(s-b,ps[j]-s)<=0) p=ps[j];\n    }else{\n      if(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n      if(cross(p-s,ps[j]-s)==0.0){ \n        if(norm(ps[j]-s)<norm(p-s)) p=ps[j];\n      }else if(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n    }\n      }\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.1415926535;\n\nbool eq(double a, double b){\n    return fabs(a-b) < 1e-8;\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( cin >> n && n ){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i];\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv, ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        cout << fixed << setprecision(1) << (int)(sum*10+0.5)/10.0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n  //double cosn=dot(a,b)/(abs(a)*abs(b));\n  //double sinn=cross(a,b)/(abs(a)*abs(b));\n  //double angle=acos(cosn);\n  //if(sinn>=0)\n  //    return angle;\n  //return 2*PI-angle;\n    double angle=atan2(cross(a,b),dot(a,b));\n    return angle+PI;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nbool used[401];\nchar c;\nint n;\ndouble x,y;\nP p[401];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+400,0);\n\t\tint m=0;\n\t\tp[0]=P(0.0,0.0);\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tp[i+1]=P(x,y);\n\t\t}\n\t\tdouble ans=0.0;\n\t\tP v(0.0,1.0);\n\t\trep(h,n){\n\t\t\tused[m]=1;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n+1)if(i!=m&&!used[i]&&dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M){M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<endl;\n\t\t\tans+=abs(p[nx]-p[m]);\n\t\t\tused[nx]=1;\n\t\t\tm=nx;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 401\nusing namespace std;\ntypedef complex <double> P;\nP p[N];\nint n;\nconst double EPS = 1e-8; \n\ndouble dot(P a,P b){return real(conj(a)*b);}\ndouble cross(P a,P b){return imag(conj(a)*b);}\n\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)> EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool check(P s, P t){\n  if(t==P(-1,-1))return 0;\n  for(int i=0;i<n;i++){\n    if(p[i]==P(-1,-1)||p[i]==t)continue;\n    int r=ccw(s,p[i],t);\n    if(!(r==1||r==0)) return 0;\n  }\n  return 1;\n}\n\ndouble solve(){\n  double res=0;\n  P pos=P(0,0);\n  for(int i=0;i<n;i++)\n    if(check(pos,p[i])) {\n      res+=abs(pos-p[i]);\n      pos=p[i];\n      p[i]=P(-1,-1);\n      i=-1;\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,p[i]=P(x,y);\n    printf(\"%.1f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  //return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-500);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t      //if(equals(getArgV2(cur-cur2,ps[next]-cur), getArgV2(cur-cur2,ps[i]-cur)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      \n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg((*it - last_point) / last_vector);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\nbool eq(double a, double b){\n    return ( a-b < 0.002 && a-b > -0.002 );\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[800], y[800];\n    while( true ){\n        scanf(\" %d\", &n);\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf %lf\", x+i, y+i);\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1lf\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\nint n;\n\nint main()\n{\n  /*\n  Point a = Point(10,10);\n  Point b = Point(10,inf);\n  Point c = Point(0,0);\n\n  cout << getArg(a,b,c)*180/M_PI << endl;\n  */\n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,inf);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      double L = 0;\n      rep(_,n)\n\t{\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << i << \" ----------------- \" << ps[i].x << \",\" << ps[i].y << endl;\n\t      int res = ccw(cur1,cur2,ps[i]);\n\t      if(!(res == ONLINE_FRONT || res == ON_SEGMENT || res == CLOCKWISE || res == ONLINE_BACK))continue;\n\t      double arg = getArg(cur1,cur2,ps[i]);\n\t      //cout << \"arg = \" << arg*180/M_PI  << \" || \" << minArg*180/M_PI<< endl;\n\t      //cout <<\"equal? -> \" << equals(arg,minArg) << \" \" << arg << \" = \"<< minArg << endl;\n\t      if(equals(arg,minArg))\n\t\t{\n\t\t  //cout << \"equals!!!\" << endl;\n\t\t  if(minDist > norm(cur1-ps[i]))\n\t\t    {\n\t\t      //cout << \"change to \" << ps[i].x << \",\" << ps[i].y << endl;\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minArg = arg;\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\t      else if(arg < minArg)\n\t\t{\n\t\t  minArg = arg;\n\t\t  minDist = norm(cur1-ps[i]);\n\t\t  minpos = i;\n\t\t}\n\t    }\n\n\t  if(minpos == -inf)\n\t    {\n\t      //cout << \"inf!!!\" << endl;\n\t      rep(i,n)\n\t\t{\n\t\t  if(used[i])continue;\n\t\t  int res = ccw(cur1,cur2,ps[i]);\n\t\t  double arg = getArg(cur1,cur2,ps[i]);\n\t\t  if(equals(arg,minArg))\n\t\t    {\n\t\t      if(minDist > norm(cur1-ps[i]))\n\t\t\t{\n\t\t\t  minDist = norm(cur1-ps[i]);\n\t\t\t  minpos = i;\n\t\t\t}\n\t\t    }\n\t\t  else if(arg < minArg)\n\t\t    {\n\t\t      minArg = arg;\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(minDist);\n\t  if(equals(cur1.y,ps[minpos].y) || cur1.y < ps[minpos].y)cur2 = Point(ps[minpos].x,inf);\n\t  else                                                    cur2 = Point(ps[minpos].x,-inf);\n\t  cur1 = ps[minpos];\n\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n\n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y < p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  u.pop_back();\n\t}\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  l.pop_back();\n\t}\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n\n  vector<Point> ret;\n\n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n    }\n\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n    }\n\n\n  return ret;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint n;\nvector<Point> input;\n\nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n\n}\n \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point now = Point(0,0); \n  now.index = -1; \n  while(true)\n    {\n      vector<Point> vec;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  vec.push_back(input[i]);\n\t}\n\n      if(vec.empty())break;\n\n      vec.push_back(now);\n      vec = andrewScan(vec,now);\n\n      rep(i,vec.size())\n\t{\n\t      rep(k,n)\n\t\t{\n\t\t  if(used[k])continue;\n\t\t  if(input[k].index == vec[i].index || input[k].index == vec[(i+1)%vec.size()].index)continue;\n\t\t  if(equals(getDistanceSP(Segment(vec[i],vec[(i+1)%vec.size()]),input[k]),0))\n\t\t    {\n\t\t      //cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") and (\" << vec[(i+1)%vec.size()].x << \",\" << vec[(i+1)%vec.size()].y << \")  --- > (\" << input[k].x << \",\" << input[k].y << \")\" << endl;  \n\t\t      used[k] = true;\n\t\t  }\n\t\t  \n\t\t}\n\t}\n      /*\n      cout << \"remain \" << endl;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  cout << input[i].x << \",\" << input[i].y << endl;\n\t}\n      cout << endl;\n      */\n      /*\n      cout << \"after andrew, \" << endl;\n      rep(i,vec.size())\n\t{\n\t  cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") \" << vec[i].index << endl;\n\t}\n      cout << endl;\n      */\n      rep(i,vec.size()-1)\n\t{\n\t  L += sqrt(pow(vec[i].x-vec[i+1].x,2)+pow(vec[i].y-vec[i+1].y,2));\n\t  if(vec[i].index == -1)continue;\n\t  used[vec[i].index] = true;\n\t}\n      now = vec[vec.size()-1];\n    }\n\n  L *= 10.0;\n  L = floor(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n      solve();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||abs(ps[i])<abs(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p;\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&cross(s-b,ps[j]-s)<=0){\n\t  p=ps[j];\n\t  break;\n\t}\n      }\n      for(int j=0;j<n;j++){\n\tif(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\tif(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\tif(equals(mycos(s-b,ps[j]-p),mycos(s-b,p-s))&&abs(s-ps[j])<abs(s-p)) p=ps[j];\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;\n      u[m[s=p]]=1;\n    }\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.1415926535;\n\nbool eq(double a, double b){\n    return fabs(a-b) < 1e-8;\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( cin >> n, n ){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i];\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1lf\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define mp(a,b) make_pair(a, b)\n\ntypedef vector<int> vi;\nstruct P { double angle, dist; int idx; };\nbool operator<(const P& p1, const P& p2) {\n\tif(p1.angle != p2.angle) return p1.angle < p2.angle;\n\tif(p1.dist != p2.dist) return p1.dist < p2.dist;\n\treturn p1.idx < p2.idx;\n}\n\n\n\nconst double PI = atan(1.0) * 4.0;\n\nconst double EPS = 1.0e-10;\nconst int MAX_N = 410;\nint n;\nint x[MAX_N], y[MAX_N];\nbool used[MAX_N];\n\ndouble atan3(int x1, int y1, int x2, int y2) {\n\tdouble a = atan2((double)(y2-y1), (double)(x2-x1));\n\treturn a < 0.0 ? a + 2*PI : a;\n}\n\ndouble distance(int x1, int y1, int x2, int y2) {\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\n\tvector<P> v;\n\tint px = 0, py = 0;\n\tdouble d = PI / 2.0;\n\tdouble dist = 0.0;\n\tint visit = 0;\n\twhile(visit < n) {\n\t\tv.clear();\n\t\trep(i,n) {\n\t\t\tif(!used[i]) {\n\t\t\t\tdouble angle = atan3(px, py, x[i], y[i]);\n\t\t\t\tdouble dd = distance(px, py, x[i], y[i]);\n\t\t\t\tif(angle > d) angle -= 2.0 * PI;\n\t\t\t\tangle = dd < EPS ? 0.0 : d - angle;\n\t\t\t\tP p = { angle, dd, i };\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n\t\tint idx = v[0].idx;\n\t\tdist += v[0].dist; \n\t\tpx = x[idx];\n\t\tpy = y[idx];\n\t\td = d-v[0].angle;\n\t\t// printf(\"%d\\n\", idx);\n\t\tused[idx] = true;\n\t\tvisit++;\n\t}\n\tprintf(\"%.1f\\n\", dist);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\trep(i,n) scanf(\"%d%d\", &x[i], &y[i]);\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n  point operator / (double d){return point(x/d,y/d);}\n  bool operator == (const point &p )const{return abs(x-p.x)<EPS && abs(y-p.y)<EPS;}\n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n    \n    sort(v.begin(),v.end(),cmp_x);    \n\n    double sum=dist(v[0],v[1]);\n    bool fg[401];\n    point prev=v[0],now=v[1];\n    int nowID=1;\n    fill(fg,fg+401,false);\n    fg[0]=true;\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && getAngle(prev,now,v[j])>angle){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])<dist(now,v[id])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    printf(\"%.1f\\n\",sum+0.01);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 400;\nconst double EPS = 1e-6;\nconst double INF = 1e77;\n\nint n;\nvector<P> vec;\nbool vis[N];\n\nbool equals(double a, double b){\n  return abs(a - b) < EPS;\n}\n\ndouble dot(P a, P b){\n  return real(conj(a) * b);\n}\n\ndouble cross(P a, P b){\n  return imag(conj(a) * b);\n}\n\ndouble dist(P a, P b){\n  return abs(a - b);\n}\n\nint ccw(P p0, P p1, P p2){\n  P a = p1 - p0;\n  P b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\ndouble getr(P s, P t, P v){\n  int jd = ccw(s, v + s, t);\n  if(jd == 1){\n    return dot(v, t - s) / (abs(v) * abs(t - s));\n  }else if(jd == -1){\n    return 2 * M_PI - dot(v, t - s) / (abs(v) * abs(t - s));\n  }else if(jd == 2) return M_PI;\n  else if(jd == -2) return 0.0;\n  return -1;\n}\n\nmain(){\n  while(cin >> n && n){\n    vec.clear();\n    for(int i=0;i<n;i++){\n      double a, b;\n      cin >> a >> b;\n      vec.push_back(P(a, b));\n    }\n    fill(vis, vis+n, false);\n    P pos = P(0, 0);\n    P v = P(0, 1);\n    double ans = 0.0;\n    for(int j=0;j<n;j++){\n      int id;\n      double mr = INF, md = INF;\n      for(int i=0;i<n;i++){\n        if(vis[i]) continue;\n        double r = getr(pos, vec[i], v);\n        if(mr > r){\n          id = i;\n          mr = r;\n          md = dist(pos, vec[i]);\n        }else if(equals(mr, r)){\n          double d = dist(pos, vec[i]);\n          if(md > d){\n            id = i;\n            mr = r;\n            md = d;\n          }\n        }\n      }\n      //cout << pos << ' ' << vec[id] << ' ' << dist(pos, vec[id]) << endl;\n      ans += md;\n      vis[id] = true;\n      v = vec[id] - pos;\n      pos = vec[id];\n    }\n    printf(\"%.1f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tdouble out=0;\n\t\tdouble ns=PI/2;\n\t\tP now(0,0);\n\t\twhile(g.size()){\n\t\t\tdouble mid=inf;\n\t\t\tdouble mis=inf;\n\t\t\tint mi=0;\n\t\t\trep(i,g.size()){\n\t\t\t\tdouble s=abs(ns-arg(g[i]-now));\n\t\t\t\tif(s+EPS>PI)s=2*PI-s;\n\t\t\t\tdouble d=abs(g[i]-now);\n\t\t\t\tif(mis>s){\n\t\t\t\t\tmis=s;\n\t\t\t\t\tmi=i;\n\t\t\t\t\tmid=d;\n\t\t\t\t}else if(abs(mis-s)<EPS&&mid>d){\n\t\t\t\t\tmid=d;\n\t\t\t\t\tmi=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tns=arg(g[mi]-now);\n\t\t\tnow=g[mi];\n\t\t\tout+=mid;\n\t\t\tg.erase(g.begin()+mi);\n\t\t}\n\t\tcout<<shosu(1)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=-1;\n      int id=-1;\n      for(int j=1;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])<dist(now,v[id])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.1415926535;\n\nbool eq(double a, double b){\n   return fabs(a-b) < 1e-8;\n}\n\ndouble angle(double cur, double next){\n   double r = cur - next + 2*PI;\n   while( r >= 2*PI ) r -= 2*PI;\n   return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n   return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n   int n;\n   double x[400], y[400];\n   while( cin >> n && n ){\n       for(int i = 0; i < n; i++){\n           cin >> x[i] >> y[i];\n       }\n       double cx = 0, cy = 0, cang = atan2(0,-1);\n       double lv, ld, sum = 0.0;\n       int ln;\n       for(int i = 0; i < n; i++){\n           lv = 100, ld = 1000;\n           for(int j = 0; j < n; j++){\n               if( x[j] < 0 ) continue;\n               double ang = angle( cang,\n                                   atan2(y[j]-cy, x[j]-cx) );\n               if( ang < lv ||\n                   ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                   lv = ang; ln = j;\n                   ld = dist(cx, cy, x[j], y[j]);\n               }\n           }\n           sum += ld;\n           cang = atan2(y[ln]-cy, x[ln]-cx);\n           cx = x[ln]; cy = y[ln];\n           x[ln] = -1;\n       }\n       cout << fixed<< setprecision(1) << (int)(sum*10+0.5)/10.0 << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst int MAX = 450;\nconst double EPS = 1e-9;\n\ntypedef pair<int,int> P;\nvector<P> V;\nbool come[MAX];\n\n\ndouble dot(P a, P b){\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y-a.Y*b.X;\n}\n\ndouble getLength(P pre, P nex){\n  return sqrt((pre.X-nex.X)*(pre.X-nex.X)+(pre.Y-nex.Y)*(pre.Y-nex.Y));\n}\n\ndouble getAngle(P pre, P nex){\n  return acos(dot(pre,nex)/(getLength(pre,P(0,0))*getLength(nex,P(0,0))));\n}\n\nbool ccw(P p0, P p1, P p2){\n  P a = P(p1.first-p0.first,p1.second-p0.second);\n  P b = P(p2.first-p0.first,p2.second-p0.second);\n  return (cross(a,b) > EPS);\n}\n\n\nP Pminus(P a, P b){\n  a.first -= b.first;\n  a.second -= b.second;\n  return a;\n}\n\n\nvoid solve(){\n\n  sort(V.begin(),V.end());\n\n  double ans = getLength(P(0,0),V[0]);\n\n  P pre = P(0,0);\n  P now = V[0];\n\n  int roop = V.size()-1;\n\n  while(roop--){\n    int nex = -1;\n    double nexTheta;\n\n    for(int i = 1; i < V.size(); i++){\n      if(come[i]) continue;\n   \n      //  if(ccw(pre,now,V[i])) continue;\n   \n      if(nex == -1){\n\tnex = i;\n\tnexTheta = getAngle(Pminus(V[i],now),Pminus(now,pre));\n\tcontinue;\n      }\n\n\n      double theta = getAngle(Pminus(now,pre),Pminus(V[i],now));\n      \n      if(fabs(nexTheta-theta) > EPS && nexTheta > theta){\n\t  nex = i;\n\t  nexTheta = theta;\n      } \n      if(fabs(nexTheta-theta) < EPS && getLength(now,V[nex]) > getLength(now,V[i])){\n\tnex = i;\n\tnexTheta = theta;\n      }\n    }\n\n    //cout << nex << endl;\n\n    //  cout <<nex << \" \" <<  V[nex].X << \" \" << V[nex].Y << endl;\n    come[nex] = true;\n\n    ans += getLength(now,V[nex]);\n    pre = now;\n    now = V[nex];\n  }\n  printf(\"%.1f\\n\",ans);\n}\n\nint main(){\n\n  int n;\n  while(cin >> n && n){\n    memset(come,false,sizeof(come));\n    V.resize(n);\n    for(int i = 0; i < n; i++) cin >> V[i].X >> V[i].Y;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\nlong double cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nlong double norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;  \n  if (cross(b, c) < 0)   return -1;    \n  if (dot(b, c) < 0)     return +2;   \n  if (norm(b) < norm(c)) return -2;       \n  return 0;\n}\n\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n);\n    for(int i=0;i<n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[401];\n    point prev=point(0,-1),now=point(0,0);\n    int nowID=-1;\n\n    fill(fg,fg+401,false);\n\n    for(int i=0;i<v.size();i++){\n      if(nowID>=0)fg[nowID]=true;\n      long double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(fg[j])continue;\n\tint c=ccw(prev,now,v[j]);\n\tif(c<0){\n\t  if(-EPS>angle-getAngle(prev,now,v[j])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t  else if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t    if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t      id=j,angle=getAngle(prev,now,v[j]);\n\t    }\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> Point;\n\nint Signum(int n)\n{\n\treturn n>0?1:n<0?-1:0;\n}\nint Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\nint Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Dot(d1,d2)<0)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2))\n\t\treturn 2;\n\treturn 0;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Point> ps(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>real(ps[i])>>imag(ps[i]);\n\t\t\n\t\tvector<int> uses(n);\n\t\tPoint cur(0,0);\n\t\tdouble res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint j=-1;\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(uses[k])\n\t\t\t\t\tcontinue;\n\t\t\t\tint ccw=CCW(cur,ps[j],ps[k]);\n\t\t\t\tif(j==-1 || ccw==0 || ccw==1)\n\t\t\t\t\tj=k;\n\t\t\t}\n\t\t\tres+=sqrt(norm(ps[j]-cur));\n\t\t\tuses[j]=1;\n\t\t\tcur=ps[j];\n\t\t}\n\t\tcout<<fixed<<setprecision(1)<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble angle = acos(ab/(na*nb));\n\n\t\t\t\tif(minv > angle){\n\t\t\t\t\tnext = j;\n\t\t\t\t\tminv = angle;\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\tdist *= 10.0;\n\t\tdist = floor(dist);\n\t\tdist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    //double cosn=dot(a,b)/(abs(a)*abs(b));\n    //double sinn=cross(a,b)/(abs(a)*abs(b));\n    //double angle=acos(cosn);\n    //if(sinn>0||EQ(sinn,0))\n    //    return angle;\n    //return 2*PI-angle;\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\nconst int mx=400+10;\nstruct pt{\n   int x,y;   \n   pt(int x,int y):x(x),y(y){};\n   pt(){}\n   pt operator -(pt a){return pt(x-a.x,y-a.y);}\n   int cross(pt a){ return x*a.y-y*a.x; }\n   int d2(){ return x*x+y*y;}\n   double mod(){ return sqrt(d2()); }\n};\npt p[mx];\nbool used[mx];\nint o[mx];\npt base;\n\nbool cmp(int i,int j){\n   int x=(p[i]-base).cross(p[j]-base);\n   if(x!=0) return x<0;\n   return (p[i]-base).d2()<(p[j]-base).d2();\n}\nint main(){\n   int n;\n   while(scanf(\"%d\",&n)==1){\n      if(n==0)break;\n      for(int i=0;i<n;i++)\n         scanf(\"%d %d\",&p[i].x,&p[i].y);\n      memset(used,false,sizeof used);\n      base.x=base.y=0;\n      double ans=0.0;\n      for(int i=0;i<n;i++){\n         int l=0;\n         for(int j=0;j<n;j++)\n            if(!used[j])\n               o[l++]=j;\n         sort(o,o+l,cmp);\n         used[o[0]]=true;\n         pt a=p[o[0]];\n         ans+=(a-base).mod();\n         base=a;\n      }\n      printf(\"%.1lf\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n  point operator / (double d){return point(x/d,y/d);}\n  bool operator == (const point &p )const{return abs(x-p.x)<EPS && abs(y-p.y)<EPS;}\n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n    \n    sort(v.begin(),v.end(),cmp_x);    \n\n    double sum=dist(v[0],v[1]);\n    bool fg[401];\n    point prev=v[0],now=v[1];\n    int nowID=1;\n\n    fill(fg,fg+401,false);\n    fg[0]=true;\n\n    for(int i=0;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && -EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n    sum*=10;\n    sum=round(sum);\n    sum/=10;\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//23\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      v[i]=P(x,y);\n    }\n    P c=P(0,0),p(0,-1);\n    double l=0;\n    while(!v.empty()){\n      double ma=9;\n      double md=1<<30;\n      int x;\n      for(int i=0;i<v.size();i++){\n\tdouble ca=(arg(c-p)-arg(v[i]-c));\n\tif(ca<0){\n\t  ca+=acos(-1)*2;\n\t}\n\tdouble cd=abs(v[i]-c);\n\tif(ca<ma||ca==ma&&cd<md){\n\t  ma=ca;\n\t  md=cd;\n\t  x=i;\n\t}\n      }\n      l+=md;\n      p=c;\n      c=v[x];\n      v.erase(v.begin()+x);\n    }\n    cout.precision(1);\n    cout<<fixed<<l<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && minDist > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += minDist;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min) {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            float max = -abs(last_vector);\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = ((*it - last_point) * conj(last_vector)).real() / abs(*it - last_point);\n                if (temp > max) {max = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dist(P a, P b)\n{\n\treturn abs(a-b);\n}\n\ndouble angle(P a, P b, P c)\n{\n\treturn arg((c-b)/(b-a));\n}\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N), N)\n\t{\n\t\tvector<P> v(N);\n\t\tvector<bool> used(N, false);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\", &x,&y);\n\t\t\tv[i]=P(x,y);\n\t\t}\n\n\t\tdouble ans=0;\n\t\tP a=P(0,-1),b=P(0,0);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint select=-1;\n\t\t\tdouble alg=0;\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tdouble t=angle(a,b,v[j]);\n\t\t\t\tif(select==-1)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t==alg)\n\t\t\t\t{\n\t\t\t\t\tif(dist(b,v[j]) < dist(b, v[select]))\n\t\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t>alg)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[select]=true;\n\t\t\ta=b; b=v[select];\n\t\t\tans+=dist(a,b);\n\t\t}\n\n\t\tprintf(\"%.1lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    double cosn=dot(a,b)/(abs(a)*abs(b));\n    double sinn=cross(a,b);\n    double angle=acos(cosn);\n    if(sinn>0||EQ(sinn,0))\n        return angle;\n    return 2*PI-angle;\n    //double angle=atan2(cross(a,b),dot(a,b));\n    //if(angle<0)\n    //    return 2*PI+angle;\n    //return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n  point operator / (double d){return point(x/d,y/d);}\n  bool operator == (const point &p )const{return abs(x-p.x)<EPS && abs(y-p.y)<EPS;}\n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n    \n    sort(v.begin(),v.end(),cmp_x);    \n\n    double sum=dist(v[0],v[1]);\n    bool fg[401];\n    point prev=v[0],now=v[1];\n    int nowID=1;\n    fill(fg,fg+401,false);\n    fg[0]=true;\n    for(int i=0;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && getAngle(prev,now,v[j])>angle){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])<dist(now,v[id])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    printf(\"%.1f\\n\",sum+0.005);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n  double cosn=dot(a,b)/(abs(a)*abs(b));\n  double sinn=cross(a,b)/(abs(a)*abs(b));\n  if(cosn>=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn<=0){\n    double angle=acos(cosn);\n    return PI-angle+PI;\n  }\n  else if(cosn>=0&&sinn<=0){\n    double angle=acos(cosn);\n    return PI-angle+PI;\n  }\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        P cp=P(0,1);\n        double sum=0;\n        P pp=P(0,0);\n        while(count(isUsed.begin(),isUsed.end(),true)!=points.size()){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i])\n                    continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp)){\n                        idx=i;\n                    }\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum+EPS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n);\n    for(int i=0;i<n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[401];\n    point prev=point(0,-1),now=point(0,0);\n    int nowID=-1;\n\n    fill(fg,fg+401,false);\n\n    for(int i=0;i<v.size();i++){\n      if(nowID>=0)fg[nowID]=true;\n      long double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.1415926535;\n\nbool eq(double a, double b){\n    return ( a-b < 1e-8 && a-b > -1e-8 );\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( cin >> n, n ){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i];\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1f\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      cerr << n << endl;\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cerr << ps[i].x << \" \" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    double cosn=dot(a,b)/(abs(a)*abs(b));\n    double sinn=cross(a,b);\n    if(cosn>1.0)\n        cosn=1.0;\n    else if(cosn<-1.0)\n        cosn=-1.0;\n    double angle=acos(cosn);\n    if(sinn>0||EQ(sinn,0))\n        return angle;\n    return 2*PI-angle;\n    //double angle=atan2(cross(a,b)/(abs(a)*abs(b)),dot(a,b)/(abs(a)*abs(b)));\n    //if(angle<0)\n    //    return 2*PI+angle;\n    //return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n  double cosn=dot(a,b)/(abs(a)*abs(b));\n  double sinn=cross(a,b)/(abs(a)*abs(b));\n  double angle=acos(cosn);\n  if(sinn>=0)\n      return angle;\n  return 2*PI-angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n  /*\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  */\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  L += minDist;\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min) {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            float max = -abs(last_vector);\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = ((*it - last_point) * conj(last_vector)).real() / abs(*it - last_point);\n                if (temp > max) {max = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-12\n#define PI acos(-1.0)\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\ndouble dot(point va, point vb){\n\treturn real(va) * real(vb) + imag(va) * imag(vb);\n}\n\ndouble cross(point va, point vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble solve(polygon pts)\n{\n\tdouble len = 0;\n\tpoint p = point(0, 0), dvec= point(0, 1);\n\t\n\twhile( !pts.empty() )\n\t{\n\t\tint nexidx;\n\t\tdouble minarg = 4*3.1415;\n\t\tdouble mindist = 1e18;\n\t\t\n\t\tfor(int i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\tpoint vec = pts[i] - p;\n\t\t\tdouble nexarg = atan2(cross(vec, dvec), dot(vec, dvec));\n\t\t\tdouble nexdist = abs(vec);\n\t\t\t\n\t\t\tif( nexarg < minarg )\n\t\t\t{\n\t\t\t\tminarg = nexarg;\n\t\t\t\tmindist = nexdist;\n\t\t\t\tnexidx = i;\n\t\t\t}\n\t\t\telse if( abs(minarg - nexarg) < EPS && nexdist < mindist )\n\t\t\t{\n\t\t\t\tmindist = nexdist;\n\t\t\t\tnexidx = i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tlen += abs(pts[nexidx] - p);\n\t\t\n\t\tdvec = pts[nexidx] - p;\n\t\tp = pts[nexidx];\n\t\tpts.erase(pts.begin()+nexidx);\n\t}\n\t\n\treturn len;\n}\n\nint main()\n{\n\tint n;\n\tpolygon pts;\n\t\n\twhile( cin >> n, n)\n\t{\n\t\tpolygon pts;\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpts.push_back(point(x, y));\n\t\t}\n\t\t\n\t\tprintf(\"%.4lf\\n\", solve(pts));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = 10000.0;\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle <= 0.0 + EPS){\n\t\t\t\t\tif(abs(angle) < abs(minv)){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tminv = angle;\t\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\tdist *= 10.0;\n\t\tdist = floor(dist);\n\t\tdist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nstatic const double eps = 1e-8;\n\ninline double euclid(double dx, double dy)\n{\n  return sqrt(dx*dx + dy*dy);\n}\n\nint main()\n{\n  int n, x[401], y[401], visited[401];\n\n  while (scanf(\"%d\", &n), n) {\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < n; ++i)\n      scanf(\"%d%d\", x+i, y+i);\n\n    int curr_x = 0, curr_y = 0;\n    int prev_x = 0, prev_y = -1;\n    double length = 0;\n\n    for (int i = 0; i < n; ++i) {\n      int dx1 = curr_x - prev_x;\n      int dy1 = curr_y - prev_y;\n      int dist1 = euclid(dx1, dy1);\n\n      double max_cos = -1000;\n      double min_dist = 1000;\n      int min_index = -1;\n\n      for (int j = 0; j < n; ++j) {\n        if (visited[j])\n          continue;\n\n        int dx2 = x[j] - curr_x;\n        int dy2 = y[j] - curr_y;\n        double dist2 = euclid(dx2, dy2);\n        double cos = (dx1*dx2 + dy1*dy2) / (dist1 * dist2);\n\n        if (cos - max_cos > eps || (fabs(cos - max_cos) < eps && dist2 < min_dist)) {\n          max_cos = cos;\n          min_dist = dist2;\n          min_index = j;\n        }\n      }\n\n      prev_x = curr_x;\n      prev_y = curr_y;\n      curr_x = x[min_index];\n      curr_y = y[min_index];\n      visited[min_index] = true;\n      length += min_dist;\n    }\n\n    printf(\"%.1lf\\n\", length);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    double x[800], y[800];\n    while( true ){\n        int n;\n        scanf(\" %d\", &n);\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            scanf(\"   %lf  %lf\", &x[i], &y[i]);\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( ang == lv && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1lf\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Point np(0,0);\n    Vector v(0,1);\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i];\n    }\n    double res = 0;\n    bool visited[MAX_N] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int idx = -1;\n      double min = INF,d = INF;\n      for(int j = 0 ; j < N ; j++){\n        if(visited[j]){ continue; }\n        Vector v2 = p[j]-np;\n        double angle = acos(dot(v,v2)/abs(v)/abs(v2));\n        if(lt(angle,min)){\n          d = dist(np,p[j]);\n          min = angle;\n          idx = j;\n        }else if(equal(angle,min)){\n          if(lt(dist(np,p[j]),d)){\n            d = dist(np,p[j]);\n            min = angle;\n            idx = j;\n          }\n        }\n      }\n      visited[idx] = true;\n      res += dist(np,p[idx]);\n      v = p[idx]-np;\n      np = p[idx];\n    }\n    printf(\"%.1f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return (x != p.x?x<p.x:y<p.y);\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(fabs(minArg-arg) > EPS && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(fabs(minArg - arg) < EPS && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-12\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\ndouble dot(point va, point vb){\n\treturn real(va) * real(vb) + imag(va) * imag(vb);\n}\n\ndouble cross(point va, point vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble solve(polygon pts)\n{\n\tdouble len = 0.0;\n\tpoint p = point(0.0, 0.0), dvec= point(0.0, 1.0);\n\t\n\twhile( !pts.empty() )\n\t{\n\t\tint nexidx;\n\t\tdouble minarg = 4*3.1415;\n\t\tdouble mindist = 1.0e10;\n\t\t\n\t\tfor(int i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\tpoint vec = pts[i] - p;\n\t\t\tdouble nexarg = atan2(cross(vec, dvec), dot(vec, dvec));\n\t\t\tdouble nexdist = abs(vec);\n\t\t\t\n\t\t\tif( nexarg < minarg )\n\t\t\t{\n\t\t\t\tminarg = nexarg;\n\t\t\t\tmindist = nexdist;\n\t\t\t\tnexidx = i;\n\t\t\t}\n\t\t\telse if( abs(minarg - nexarg) < EPS && nexdist < mindist )\n\t\t\t{\n\t\t\t\tmindist = nexdist;\n\t\t\t\tnexidx = i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tlen += abs(pts[nexidx] - p);\n\t\t\n\t\tdvec = pts[nexidx] - p;\n\t\tp = pts[nexidx];\n\t\tpts.erase(pts.begin()+nexidx);\n\t}\n\t\n\treturn len;\n}\n\nint main()\n{\n\tint n;\n\tpolygon pts;\n\t\n\twhile( cin >> n, n)\n\t{\n\t\tpolygon pts;\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpts.push_back(point(x, y));\n\t\t}\n\t\t\n\t\tprintf(\"%.1lf\\n\", solve(pts));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=1;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])<dist(now,v[id])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef complex<double> ci;\ntypedef pair<double,pair<double,int> > pdd;\npint fg[400];\nbool used[400];\nint main(){\n    int n;\n    while(cin>>n,n){ \n        rep(i,n) cin>>fg[i].first>>fg[i].second;\n        sort(fg,fg+n);\n        memset(used,0,sizeof(used));\n        ci ppr(0,0),pre(0,0),cur(fg[0].first,fg[0].second);\n        double sum=abs(cur-pre);\n        used[0]=true;\n        ppr=pre;pre=cur;\n        FOR(i,1,n){\n            vector<pdd> vp;\n            double mxag=10;\n            rep(j,n){\n                if(used[j]) continue;\n                ci c(fg[j].first,fg[j].second);\n                ci scur=c-pre;\n                double prag=arg(pre-ppr)+M_PI;\n                double cuag=arg(scur)+M_PI;\n                cuag=prag-cuag;\n                if(cuag<0) cuag+=2*M_PI;\n                mxag=min(cuag,mxag);\n                if(mxag==cuag){\n                    cuag=mxag;\n                    vp.pb(mp(cuag,mp(abs(scur),j)));\n                }\n            }\n            pdd p=*min_element(vp.begin(),vp.end());\n            used[p.second.second]=true;\n            sum+=p.second.first;\n            ppr=pre;\n            pre=ci(fg[p.second.second].first,fg[p.second.second].second);\n        }\n        cout<<fixed<<setprecision(1)<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\nconstexpr double EPS = 1e-9;\n\nstruct point {\n  double x, y;\n  point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n  point(const point &p):x(p.x), y(p.y) {}\n\n  point operator+(const point &p) const {\n\treturn point(x + p.x, y + p.y);\n  }\n\n  point operator-(const point &p) const {\n\treturn point(x - p.x, y - p.y);\n  }\n};\n\nostream &operator<<(ostream &os, const point &p) {\n  return os << '(' << p.x << \", \" << p.y << ')';\n}\n\ndouble angle(const point &p) {\n  return atan2(p.y, p.x);\n}\n\ndouble norm(const point &p) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble normalize(double theta) {\n  if(theta < -M_PI) return theta + 2 * M_PI;\n  if(theta > M_PI) return theta - 2 * M_PI;\n  return theta;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout.precision(1);\n  cout.setf(ios::fixed);\n  constexpr double INF = 1e9;\n\n  for(int n; cin >> n && n;) {\n\tvector<point> flags;\n\tflags.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t  double x, y;\n\t  cin >> x >> y;\n\t  flags.emplace_back(x, y);\n\t}\n\n\tdouble ans = 0.0;\n\tpoint pos(0, 0);\n\tdouble dir = M_PI / 2;\n\tbitset<400> visited;\n\n\tfor(int i = 0; i < n; ++i) {\n\t  pair<double, double> best(INF, INF);\n\t  int next = -1;\n\t  double next_angle;\n\n\t  for(int v = 0; v < n; ++v) {\n\t\tif(visited[v]) continue;\n\n\t\tdouble dist2 = norm(flags[v] - pos);\n\t\tdouble theta = normalize(dir - angle(flags[v] - pos));\n\n\t\tpair<double, double> tmp(theta, dist2);\n\n\t\tif(tmp < best) {\n\t\t  best = tmp;\n\t\t  next = v;\n\t\t  next_angle = angle(flags[v] - pos);\n\t\t}\n\t  }\n\n\t  assert(next != -1);\n\n\t  ans += sqrt(best.second);\n\t  pos = flags[next];\n\t  dir = next_angle;\n\t  visited.set(next);\n\t}\n\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = 10000.0;\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle < 0){\n\t\t\t\t\tif(abs(angle) < abs(minv)){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tminv = angle;\t\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\tdist *= 10.0;\n\t\tdist = floor(dist);\n\t\tdist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n && n != 0) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg((*it - last_point) / last_vector);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nll sqr(ll x) { return x * x; }\nstruct poi {\n\tll x, y;\n\tvoid w() { cout << x << ' ' << y << '\\n'; }\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tll dot(poi p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tll len2() {\n\t\treturn dot(*this);\n\t}\n};\n\nint cmp(ll a, ll b, ll c, ll d) {\n\tif(a >= 0 && c < 0) return 1;\n\tif(a < 0 && c >= 0) return -1;\n\tll x = a * a * d, y = c * c * b;\n\tif(a >= 0)\n\t\treturn (x > y) - (x < y);\n\treturn -((x > y) - (x < y));\n}\n\nint main() {\n\tcout << fixed << setprecision(1);\n\tios :: sync_with_stdio(0);\n\n\tfor(int n; cin >> n && n; ) {\n\t\tvector <poi> v;\n\t\twhile(n --) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tv.pb({x, y});\n\t\t}\n\t\tpoi p = {0, 0};\n\t\tpoi d = {0, 1};\n\t\tdb ans = 0;\n\t\twhile(v.size()) {\n\t\t\tint id = 0;\n\t\t\t/*\n\t\t\tcout << \"------\\n\";\n\t\t\tfor(int i = 0; i < v.size(); i ++) {\n\t\t\t\tcout << d.dot(v[i] - p) << ' ' << (v[i] - p).len2() << '\\n';\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 1; i < v.size(); i ++) {\n\t\t\t\tll a = d.dot(v[i] - p);\n\t\t\t\tll b = (v[i] - p).len2();\n\t\t\t\tll c = d.dot(v[id] - p);\n\t\t\t\tll d = (v[id] - p).len2();\n\t\t\t\tif(cmp(a, b, c, d) > 0)\n\t\t\t\t\tid = i;\n\t\t\t\telse if(cmp(a, b, c, d) == 0 && b < d)\n\t\t\t\t\tid = i;\n\t\t\t}\n\t\t\td = v[id] - p;\n\t\t\tans += sqrt(d.len2());\n\t\t\tp = v[id];\n\t\t\t//p.w();\n\t\t\tv.erase(v.begin() + id);\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y-p.y, 2.0) + pow(x-p.x, 2.0));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x;\n    }\n    Point operator-(const Point& p) const{\n        return Point(y-p.y, x-p.x);\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Point> p(n, Point(0,0));\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        vector<bool> check(n, false);\n        Point prev(-1, 0);\n        Point curr(0, 0);\n        double ret = 0.0;\n        for(int i=0; i<n; ++i){\n            Point v = curr - prev;\n            int index;\n            double maxCosine = -DBL_MAX;\n            double minDist = DBL_MAX;\n            for(int j=0; j<n; ++j){\n                if(check[j])\n                    continue;\n                double dist = curr.dist(p[j]);\n                double cosine = v.dot(p[j]-curr) / dist;\n                if(cosine > maxCosine + EPS || (abs(cosine - maxCosine) < EPS && dist < minDist)){\n                    index = j;\n                    minDist = dist;\n                    maxCosine = cosine;\n                }\n            }\n            ret += curr.dist(p[index]);\n            check[index] = true;\n            prev = curr;\n            curr = p[index];\n            v = curr - prev;\n        }\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs(a+b)<EPS*(abs(a)+abs(b)))\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n            REP(j,coords.size()){\n                double angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n                if(GT(0,angle)){\n                    angle+=to_rad(360);\n                }\n                if(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n                    best_index=j;\n                    best_angle=angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle+=best_angle;\n            if(GT(runner_angle,to_rad(360))){\n                runner_angle-=to_rad(360);\n            }\n        }\n \n        printf(\"%.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-13;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tres=(int)(res*10);\n\t\tres/=10;\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n   \n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    double cosn=dot(a,b)/(abs(a)*abs(b));\n    double sinn=cross(a,b)/(abs(a)*abs(b));\n    double angle=acos(cosn);\n    if(sinn>0||EQ(sinn,0))\n        return angle;\n    return 2*PI+angle;\n    //double angle=atan2(cross(a,b),dot(a,b));\n    //if(angle<0)\n    //    return 2*PI+angle;\n    //return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||abs(ps[i])<abs(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p = Point(-1,-1);\n      for(int j=0;j<n;j++){\n\tif(p.x<0){\n\t  if(!u[j]&&cross(s-b,ps[j]-s)<=0) p=ps[j];\n\t}else{\n\t  if(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\t  if(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\t  if(equals(mycos(s-b,ps[j]-s),mycos(s-b,p-s))&&abs(ps[j]-s)<abs(p-s)) p=ps[j];\n\t}\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\nint n;\n\nint main()\n{\n  /*\n  Point a = Point(10,10);\n  Point b = Point(10,inf);\n  Point c = Point(0,0);\n\n  cout << getArg(a,b,c)*180/M_PI << endl;\n  */\n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,inf);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      double L = 0;\n      rep(_,n)\n\t{\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      int res = ccw(cur1,cur2,ps[i]);\n\t      if(!(res == ONLINE_FRONT || res == ON_SEGMENT || res == CLOCKWISE || res == ONLINE_BACK))continue;\n\t      double arg = getArg(cur1,cur2,ps[i]);\n\t      if(equals(arg,minArg))\n\t\t{\n\t\t  if(minDist > norm(cur1-ps[i]))\n\t\t    {\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\t      else if(arg < minArg)\n\t\t{\n\t\t  minArg = arg;\n\t\t  minDist = norm(cur1-ps[i]);\n\t\t  minpos = i;\n\t\t}\n\t    }\n\t  //cout << \"phase #\" << _ << \" \" << minpos << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(minDist);\n\t  if(equals(cur1.y,ps[minpos].y) || cur1.y < ps[minpos].y)cur2 = Point(ps[minpos].x,inf);\n\t  else                                                    cur2 = Point(ps[minpos].x,-inf);\n\t  cur1 = ps[minpos];\n\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Point np(0,0);\n    Vector v(0,1);\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i];\n    }\n    double res = 0;\n    bool visited[MAX_N] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int idx = -1;\n      double min = INF;\n      for(int j = 0 ; j < N ; j++){\n        if(visited[j]){ continue; }\n        Vector v2 = p[j]-np;\n        double angle = acos(dot(v,v2)/(abs(v)*abs(v2)));\n        if(angle < min){\n          min = angle;\n          idx = j;\n        }\n      }\n      visited[idx] = true;\n      res += dist(np,p[idx]);\n      v = p[idx]-np;\n      np = p[idx];\n    }\n    printf(\"%.10f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define mp(a,b) make_pair(a, b)\n\ntypedef vector<int> vi;\nstruct P { double angle, dist; int idx; };\nbool operator<(const P& p1, const P& p2) {\n\tif(p1.angle != p2.angle) return p1.angle < p2.angle;\n\tif(p1.dist != p2.dist) return p1.dist < p2.dist;\n\treturn p1.idx < p2.idx;\n}\n\n\n\nconst double PI = atan(1.0) * 4.0;\n\nconst double EPS = 1.0e-10;\nconst int MAX_N = 410;\nint n;\nint x[MAX_N], y[MAX_N];\nbool used[MAX_N];\n\ndouble atan3(int x1, int y1, int x2, int y2) {\n\treturn atan2((double)(y2-y1), (double)(x2-x1));\n}\n\ndouble distance(int x1, int y1, int x2, int y2) {\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\n\tvector<P> v;\n\tint px = 0, py = 0;\n\tdouble d = PI / 2.0;\n\tdouble dist = 0.0;\n\tint visit = 0;\n\twhile(visit < n) {\n\t\tv.clear();\n\t\trep(i,n) {\n\t\t\tif(!used[i]) {\n\t\t\t\tdouble angle = atan3(px, py, x[i], y[i]);\n\t\t\t\tdouble dd = distance(px, py, x[i], y[i]);\n\t\t\t\tif(angle > d) angle -= 2.0 * PI;\n\t\t\t\tangle = dd < EPS ? 0.0 : d - angle;\n\t\t\t\tP p = { angle, dd, i };\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n\t\tint idx = v[0].idx;\n\t\tdist += v[0].dist; \n\t\tpx = x[idx];\n\t\tpy = y[idx];\n\t\td = d-v[0].angle;\n\t\t// printf(\"%d\\n\", idx);\n\t\tused[idx] = true;\n\t\tvisit++;\n\t}\n\tprintf(\"%.1f\\n\", dist);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\trep(i,n) scanf(\"%d%d\", &x[i], &y[i]);\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs(a+b)<EPS*(abs(a)+abs(b)))\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n            REP(j,coords.size()){\n                double angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n                if(GT(0,angle)){\n                    angle+=to_rad(360);\n                }\n                if(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n                    best_index=j;\n                    best_angle=angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle+=best_angle;\n            if(GT(runner_angle,to_rad(360))){\n                runner_angle-=to_rad(360);\n            }\n        }\n \n        printf(\"%1.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// 凸包を求める (flag == true の時は下側, falseのときは上側を求める)\nvector<P> convex(vector<P> v, bool flag){\n\tsort( v.begin() , v.end() );\n\tif( flag ) reverse( v.begin() , v.end() );\n\t\n\tvector<P> ch( v.size() );\n    int n = 0;\n    for(int i = 0 ; i < v.size() ; i++ ) {\n        ch[n++] = v[i];\n        while( n >= 3 && ccw( ch[n-3] , ch[n-2] , ch[n-1]) == CCW ) {\n            ch[n-2] = ch[n-1];\n            n--;\n        }\n    }\n    \n    vector<P> result;\n    for(int i=0 ; i < n ; i++ ) result.push_back( ch[i] );\n    return result;\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n ), n ){\n\t\t// 入力\n\t\tvector<P> v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\", &x, &y );\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\t\n\t\tvector<P> ans;\n\t\tans.push_back( P(0,0) );\n\t\twhile( true ){\n\t\t\tvector<P> a = convex( v , false );\n\t\t\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\t\t\tif( i != a.size()-1 ) ans.push_back( a[i] );\n\t\t\t\tv.erase( find( v.begin(), v.end(), a[i] ) );\n\t\t\t}\n\t\t\tif( v.empty() ){\n\t\t\t\tans.push_back( a[a.size()-1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv.push_back( a[a.size()-1] );\n\t\t\t\n\t\t\ta = convex( v , true );\n\t\t\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\t\t\tif( i != a.size()-1 ) ans.push_back( a[i] );\n\t\t\t\tv.erase( find( v.begin(), v.end(), a[i] ) );\n\t\t\t}\n\t\t\tif( v.empty() ){\n\t\t\t\tans.push_back( a[a.size()-1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv.push_back( a[a.size()-1] );\n\t\t}\n\t\tdouble length = 0;\n\t\tfor(int i=1 ; i < ans.size() ; i++ ){\n\t\t\tlength += dist( ans[i-1] , ans[i] );\n\t\t}\n\t\tprintf(\"%.1f\\n\", length );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble angle = acos(ab/(na*nb));\n\n\t\t\t\tif(minv > angle){\n\t\t\t\t\tnext = j;\n\t\t\t\t\tminv = angle;\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nlong double x[100000], y[100000], n;\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\tlong double sum = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsum += sqrtl(pow(x[i] - x[i - 1], 2) + pow(y[i] - y[i - 1], 2));\n\t\t}\n\t\tprintf(\"%.1f\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n\ndouble adjust(double theta) {\n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n\n#define equals(a, b) fabs((a) - (b)) < EPS\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      double angle = 10;\n      double len = 10e9;\n      \n      for(int i=0; i<n; i++) {\n\tif(!used[i]) {\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tdouble out=0;\n\t\tdouble ns=PI/2;\n\t\tP now(0,0);\n\t\twhile(g.size()){\n\t\t\tdouble mid=inf;\n\t\t\tdouble mis=inf;\n\t\t\tint mi=0;\n\t\t\trep(i,g.size()){\n\t\t\t\tdouble s=abs(ns-arg(g[i]-now));\n\t\t\t\tif(s+EPS>PI)s=2*PI-s;\n\t\t\t\tdouble d=abs(g[i]-now);\n\t\t\t\tif(mis>s){\n\t\t\t\t\tmis=s;\n\t\t\t\t\tmi=i;\n\t\t\t\t\tmid=d;\n\t\t\t\t}else if(abs(mis-s)<EPS&&mid>d){\n\t\t\t\t\tmid=d;\n\t\t\t\t\tmi=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tns=arg(g[mi]-now);\n\t\t\tnow=g[mi];\n\t\t\tout+=mid;\n\t\t\tg.erase(g.begin()+mi);\n\t\t}\n\t\tcout<<shosu(2)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n   \n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Point np(0,0);\n    Vector v(0,1);\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i];\n    }\n    double res = 0;\n    bool visited[MAX_N] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int idx = -1;\n      double min = INF,d = INF;\n      for(int j = 0 ; j < N ; j++){\n        if(visited[j]){ continue; }\n        Vector v2 = p[j]-np;\n        double angle = acos(dot(v,v2)/abs(v)/abs(v2));\n        if(lt(angle,min)){\n          d = dist(np,p[j]);\n          min = angle;\n          idx = j;\n        }else if(equal(angle,min)){\n          if(lt(dist(np,p[j]),d)){\n            d = dist(np,p[j]);\n            min = angle;\n            idx = j;\n          }\n        }\n      }\n      visited[idx] = true;\n      res += dist(np,p[idx]);\n      v = p[idx]-np;\n      np = p[idx];\n    }\n    printf(\"%.10f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    double cosn=dot(a,b)/(abs(a)*abs(b));\n    double sinn=cross(a,b)/(abs(a)*abs(b));\n    double angle=acos(cosn);\n    if(sinn>0||EQ(sinn,0))\n        return angle;\n    return 2*PI-angle;\n    //double angle=atan2(cross(a,b),dot(a,b));\n    //return angle+PI;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tres=(int)(res*10);\n\t\tres/=10;\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n\tbool erased;\n};\n\ntypedef Info Vector;\n\nint N;\n\ndouble calc_dist(double from_x,double from_y,Info to){\n\treturn sqrt((from_x-to.x)*(from_x-to.x)+(from_y-to.y)*(from_y-to.y));\n}\n\ndouble calc(Vector v){\n\treturn sqrt((v.x)*(v.x)+(v.y)*(v.y));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nvoid func(){\n\n\tInfo info[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t\tinfo[i].erased = false;\n\t}\n\n\tdouble sum_dist = 0.0,min_dist,min_angle,tmp_dist,tmp_angle;\n\tdouble current_x = 0.0,current_y = 0.0;\n\tdouble naiseki,gaiseki;\n\n\tVector current,tmp,next;\n\tcurrent.x = 0;\n\tcurrent.y = 500;\n\n\n\tint next_index;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tmin_dist = DBL_MAX,min_angle = DBL_MAX;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].erased)continue;\n\n\t\t\ttmp.x = info[i].x - current_x;\n\t\t\ttmp.y = info[i].y - current_y;\n\n\t\t\tnaiseki = dot(current,tmp);\n\t\t\tgaiseki = cross(current,tmp);\n\n\t\t\ttmp_angle = atan2(gaiseki,naiseki);\n\n\t\t\tif(tmp_angle <= 0.0+EPS && fabs(tmp_angle) < fabs(min_angle)){\n\t\t\t\tmin_angle = tmp_angle;\n\t\t\t\tmin_dist = calc_dist(current_x,current_y,info[i]);\n\t\t\t\tnext_index = i;\n\t\t\t\tnext = tmp;\n\t\t\t}else if(fabs(min_angle-tmp_angle) < EPS){\n\t\t\t\ttmp_dist = calc_dist(current_x,current_y,info[i]);\n\t\t\t\tif(tmp_dist < min_dist){\n\t\t\t\t\tmin_dist = tmp_dist;\n\t\t\t\t\tnext_index = i;\n\t\t\t\t\tnext = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo[next_index].erased = true;\n\n\t\tsum_dist += min_dist;\n\n\t\tcurrent_x = info[next_index].x;\n\t\tcurrent_y = info[next_index].y;\n\n\t\tcurrent = next;\n\t}\n\n\tprintf(\"%.1lf\\n\",sum_dist);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    //double cosn=dot(a,b)/(abs(a)*abs(b));\n    //double sinn=cross(a,b)/(abs(a)*abs(b));\n    //double angle=acos(cosn);\n    //if(sinn>0||EQ(sinn,0))\n    //    return angle;\n    //return 2*PI-angle;\n    double angle=atan2(cross(a,b),dot(a,b));\n    return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n              //  cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 401\nusing namespace std;\ntypedef complex <double> P;\nP p[N];\nint n;\nconst double EPS = 1e-8; \n\ndouble dot(P a,P b){return real(conj(a)*b);}\ndouble cross(P a,P b){return imag(conj(a)*b);}\n\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)> EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool check(P s, P t){\n  if(t==P(-1,-1))return 0;\n  for(int i=0;i<n;i++){\n    if(p[i]==P(-1,-1)||p[i]==t)continue;\n    int r=ccw(s,p[i],t);\n    if(!(r==1||r==0)) return 0;\n  }\n  return 1;\n}\n\ndouble solve(){\n  double res=0;\n  P pos=P(0,0);\n  for(int i=0;i<n;i++)\n    if(check(pos,p[i])) {\n      res+=abs(pos-p[i]);\n      pos=p[i];\n      p[i]=P(-1,-1);\n      i=-1;\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,p[i]=P(x,y);\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[500];\ndouble y[500];\nint v[500];\ndouble eps=1e-9;\ndouble PI=acos(-1.0);\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tdouble X=0;\n\t\tdouble Y=0;\n\t\tfor(int i=0;i<a;i++)v[i]=0;\n\t\tdouble ret=0;\n\t\tdouble now=PI/2;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble r=999999;\n\t\t\tdouble th=-999999;\n\t\t\tint at=0;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(v[j])continue;\n\t\t\t\tdouble tmp=atan2(y[j]-Y,x[j]-X);\n\t\t\t\twhile(tmp>now+eps){\n\t\t\t\t\ttmp-=PI*2;\n\t\t\t\t}\n\t\t\t\tif(th+eps<tmp||(th<tmp+eps&&r>sqrt((x[at]-X)*(x[at]-X)+(y[at]-Y)*(y[at]-Y)))){\n\t\t\t\t\tth=tmp;\n\t\t\t\t\tat=j;\n\t\t\t\t\tr=sqrt((x[at]-X)*(x[at]-X)+(y[at]-Y)*(y[at]-Y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow=th;\n\t\t\tv[at]=1;\n\t\t\tret+=r;\n\t\t\tX=x[at];Y=y[at];\n\t\t//\tprintf(\"%f %f\\n\",X,Y);\n\t\t}\n\t\tprintf(\"%.1f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-9)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  Point C = Point(0,0);\n  double a = sqrt(norm(A-C));\n  double b = sqrt(norm(B-C));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && minDist > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += minDist;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y-p.y, 2.0) + pow(x-p.x, 2.0));\n    }\n    double len() const{\n        return sqrt(pow(y, 2.0) + pow(x, 2.0));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x;\n    }\n    Point operator-(const Point& p) const{\n        return Point(y-p.y, x-p.x);\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Point> p(n, Point(0,0));\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        vector<bool> check(n, false);\n        Point prev(-1, 0);\n        Point curr(0, 0);\n        double ret = 0.0;\n        for(int i=0; i<n; ++i){\n            Point v1 = curr - prev;\n            int k;\n            double maxCosine = -DBL_MAX;\n            double minDist = DBL_MAX;\n            for(int j=0; j<n; ++j){\n                if(check[j])\n                    continue;\n                Point v2 = p[j] - curr;\n                double dist = v2.len();\n                double cosine = v1.dot(v2) / v1.len() / dist;\n                if(cosine > maxCosine + EPS || (abs(cosine - maxCosine) < EPS && dist < minDist)){\n                    k = j;\n                    maxCosine = cosine;\n                    minDist = dist;\n                }\n            }\n            ret += curr.dist(p[k]);\n            check[k] = true;\n            prev = curr;\n            curr = p[k];\n        }\n        printf(\"%.1f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef complex<double> P;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tP p[n],dir=P(0,1);\n\t\trep(i,n)cin>>p[i].real()>>p[i].imag();\n\t\t\n\t\tint nuse=0,used[n]; rep(i,n)used[i]=0;\n\t\tdouble ans=0; P now=P(0,0);\n\t\t\n\t\twhile(nuse<n){\n\t\t\tdouble ang=1e9,tang; int mini;\n\t\t\trep(i,n)if(!used[i]){\n\t\t\t\ttang=arg(dir/(p[i]-now));\n\t\t\t\tif(tang<0)tang+=atan(1)*8;\n\t\t\t\tif(ang>tang)mini=i,ang=tang;\n\t\t\t}\n\t\t\tdir=p[mini]-now;\n\t\t\tans+=abs(dir);\n\t\t\tnow=p[mini];\n\t\t\tused[mini]=1;nuse++;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) <= min)\n                if(abs(complex<float>(y,x)) < abs(next_point))\n                    {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            float max = -abs(last_vector);\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = ((*it - last_point) * conj(last_vector)).real() / abs(*it - last_point);\n                if (temp > max) {max = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\nint next_flag(P &now, P &d, vector<P> &ps, vector<bool> &used){\n  int res = 0;\n  double a = 400.0;\n  REP(i, ps.size()){\n    if(used[i]) continue;\n    int ty = ps[i].imag() - now.imag();\n    int tx = ps[i].real() - now.real();\n    int ny = now.imag() - d.imag();\n    int nx = now.real() - d.real();\n    double tmpa = atan2(tx * ny - nx * ty, tx * nx + ty * ny);\n    if(tmpa < a || (abs(tmpa - a) < EPS && abs(now - ps[i]) < abs(now - ps[res]))){\n      res = i;\n      a = tmpa;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    vector<P> ps(N);\n    REP(i, N){\n      int x, y; cin >>x >>y;\n      ps[i] = P(x, y);\n    }\n    vector<bool> used(N, 0);\n    P now = P(0, 0), d = P(1, 0);\n    double res = 0.0;\n    REP(n, N){\n      int next = next_flag(now, d, ps, used);\n      used[next] = 1;\n      res += abs(now - ps[next]);\n      d = now;\n      now = ps[next];\n    }\n    printf(\"%.1lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic Point flag[401];\n\t\tflag[0]=Point(0,0);\n\t\tfor(int i=1;i<=n;i++)\tscanf(\"%lf%lf\",&flag[i].x,&flag[i].y);\n\n\t\tint _1st=0,_2nd;\n\t\tint xmin=1<<30,ymin=1<<30;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(flag[i].x<xmin || (flag[i].x==xmin && flag[i].y<ymin)){\n\t\t\t\t_2nd=i;\n\t\t\t\txmin=(int)flag[i].x;\n\t\t\t\tymin=(int)flag[i].y;\n\t\t\t}\n\t\t}\n\n\t\tstatic bool checked[401];\n\t\tfor(int i=0;i<=n;i++)\tchecked[i]=false;\n\t\tchecked[_1st]=checked[_2nd]=true;\n\n\t\tvector<int> ans;\n\t\tans.pb(_1st);\n\t\tans.pb(_2nd);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint jopt;\n\t\t\tdouble minang=-1e9;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(checked[j])\tcontinue;\n\t\t\t\tdouble ang=dot(flag[j]-flag[_2nd],flag[_2nd]-flag[_1st]);\n\t\t\t\tif(minang+EPS<ang\n\t\t\t\t||(abs(ang-minang)<EPS && norm2(flag[j]-flag[_2nd])+EPS<norm2(flag[jopt]-flag[_2nd]))){\n\t\t\t\t\tjopt=j;\n\t\t\t\t\tminang=ang;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.pb(jopt);\n\t\t\tchecked[jopt]=true;\n\t\t\t_1st=_2nd;\n\t\t\t_2nd=jopt;\n\t\t}\n\n\t\tdouble len=0;\n\t\tfor(int i=0;i<ans.size()-1;i++){\n\t\t\tlen+=sqrt(norm2(flag[ans[i+1]]-flag[ans[i]]));\n\t\t}\n\t\tprintf(\"%.1f\\n\",len);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n   \n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y-p.y, 2.0) + pow(x-p.x, 2.0));\n    }\n    double len() const{\n        return sqrt(pow(y, 2.0) + pow(x, 2.0));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x;\n    }\n    Point operator-(const Point& p) const{\n        return Point(y-p.y, x-p.x);\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Point> p(n, Point(0,0));\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y;\n\n        vector<bool> check(n, false);\n        Point prev(-1, 0);\n        Point curr(0, 0);\n        double ret = 0.0;\n        for(int i=0; i<n; ++i){\n            Point v1 = curr - prev;\n            int index;\n            double maxCosine = -DBL_MAX;\n            double minDist = DBL_MAX;\n            for(int j=0; j<n; ++j){\n                if(check[j])\n                    continue;\n                Point v2 = p[j] - curr;\n                double cosine = v1.dot(v2) / v1.len() / v2.len();\n                double dist = curr.dist(p[j]);\n                if(cosine > maxCosine + EPS || (abs(cosine - maxCosine) < EPS && dist < minDist)){\n                    index = j;\n                    maxCosine = cosine;\n                    minDist = dist;\n                }\n            }\n            ret += curr.dist(p[index]);\n            check[index] = true;\n            prev = curr;\n            curr = p[index];\n        }\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#define rep(i,a) for(int i = 0; i < a; i++)\n\nusing namespace std;\n\nconst int N = 1000010;\n\nstruct point {\n    int x, y;\n    point() {}\n    point(int x, int y) : x(x), y(y) {}\n    point operator +(const point& t) const {\n        return point(x + t.x, y + t.y);\n    }\n    point operator -(const point& t) const {\n        return point(x - t.x, y - t.y);\n    }\n};\n\nint n;\nvector<point> ps;\n\npoint perp(point p) {\n    return point(-p.y, p.x);\n}\n\nint dot(point p, point q) {\n    return p.x * q.x + p.y * q.y;\n}\n\nint side(point p1, point p2, point q) {\n    int d = dot(q - p1, perp(p2 - p1));\n    return d < 0 ? -1 : !!d;\n}\n\ndouble solve() {\n    vector<bool> visited(n, false);\n\n    double ans = 0.0;\n    point now(0, 0);\n    while (true) {\n        int nexti = -1;\n        point next;\n        for (int i = 0; i < n; ++i) {\n            if (visited[i])\n                continue;\n            if (nexti < 0 || side(now, next, ps[i]) > 0 || side(now, next, ps[i]) == 0 &&\n                hypot(next.x - now.x, next.y - now.y) > hypot(ps[i].x - now.x, ps[i].y - now.y)) {\n                nexti = i;\n                next = ps[i];\n            }\n        }\n\n        if (nexti == -1)\n            return ans;\n\n        ans += hypot(next.x - now.x, next.y - now.y);\n        visited[nexti] = true;\n        now = next;\n    }\n}\n\nint main(){\n    while (cin >> n, n) {\n        ps.clear();\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            ps.push_back(point(x, y));\n        }\n        printf(\"%.1f\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-13;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.14159265;\n\nbool eq(double a, double b){\n    return fabs(a-b) < 1e-7;\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( cin >> n && n ){\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i];\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv, ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100; ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j], y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n             }\n             sum += ld;\n             cang = atan2(y[ln]-cy, x[ln]-cx);\n             cx = x[ln]; cy = y[ln];\n             x[ln] = -1;\n         }\n         cout << fixed << setprecision(1)\n              << (int)(sum*10+0.5)/10.0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    double cosn=dot(a,b)/(abs(a)*abs(b));\n    double sinn=cross(a,b);\n    double angle=acos(cosn);\n    if(sinn>0||EQ(sinn,0))\n        return angle;\n    return 2*PI-angle;\n    //double angle=atan2(cross(a,b)/(abs(a)*abs(b)),dot(a,b)/(abs(a)*abs(b)));\n    //if(angle<0)\n    //    return 2*PI+angle;\n    //return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntypedef complex<double> P;\n\ndouble fix(double x){\n\twhile( x >=\n\t\t2 * PI ) x -= 2 * PI;\n\twhile( x < EPS ) x += 2 * PI;\n\treturn x;\n}\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tdouble ans = 0;\n\t\tvector<P> v;\n\t\tvector<bool> done(N);\n\t\t\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(P(x,y));\n\t\t}\n\t\tdouble cx = 0 , cy = 0;\n\t\tdouble dir = PI / 2;\n\t\twhile(count(done.begin(),done.end(),0) ){\n\t\t\t//cout << cx << \" \" << cy << \" \" << dir << endl;\n\t\t\tvector< pair<double,int> > next;\n\t\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\t\tif( done[i] ) continue;\n\t\t\t\tdouble ang = fix(atan2(v[i].imag()-cy,v[i].real()-cx) - dir);\n\t\t\t\tnext.push_back(make_pair(ang,i));\n\t\t\t}\n\t\t\tsort(next.rbegin(),next.rend());\n\t\t\tint cur = 0;\n\t\t\tfor(int i = 1 ; i < next.size() ; i++){\n\t\t\t\tif( fabs( next[i].first - next[0].first ) > EPS ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( abs(P(cx,cy)-v[next[i].second]) < abs(P(cx,cy)-v[next[cur].second]) ){\n\t\t\t\t\tcur = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdone[next[cur].second] = true;\n\t\t\tans += abs(P(cx,cy)-v[next[cur].second]);\n\t\t\tdir = fix(dir += next[cur].first);\n\t\t\tcx = v[next[cur].second].real();\n\t\t\tcy = v[next[cur].second].imag();\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"%.1lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg((*it - last_point) / last_vector);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = 10000.0;\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble angle = acos(ab/(na*nb));\n\n\t\t\t\tif(minv > angle){\n\t\t\t\t\tnext = j;\n\t\t\t\t\tminv = angle;\t\n\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t}\n\n\t\t\t\telse if(minv == angle){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\tdist *= 10.0;\n\t\tdist = floor(dist);\n\t\tdist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\nint n;\n\nint main()\n{\n  /*\n  Point a = Point(10,10);\n  Point b = Point(10,inf);\n  Point c = Point(0,0);\n\n  cout << getArg(a,b,c)*180/M_PI << endl;\n  */\n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,inf);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      double L = 0;\n      rep(_,n)\n\t{\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      int res = ccw(cur1,cur2,ps[i]);\n\t      if(!(res == ONLINE_FRONT || res == ON_SEGMENT || res == CLOCKWISE || res == ONLINE_BACK))continue;\n\t      double arg = getArg(cur1,cur2,ps[i]);\n\t      if(equals(arg,minArg))\n\t\t{\n\t\t  if(minDist > norm(cur1-ps[i]))\n\t\t    {\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\t      else if(arg < minArg)\n\t\t{\n\t\t  minArg = arg;\n\t\t  minDist = norm(cur1-ps[i]);\n\t\t  minpos = i;\n\t\t}\n\t    }\n\n\t  if(minpos == -inf)\n\t    {\n\t      rep(i,n)\n\t\t{\n\t\t  if(used[i])continue;\n\t\t  int res = ccw(cur1,cur2,ps[i]);\n\t\t  double arg = getArg(cur1,cur2,ps[i]);\n\t\t  if(equals(arg,minArg))\n\t\t    {\n\t\t      if(minDist > norm(cur1-ps[i]))\n\t\t\t{\n\t\t\t  minDist = norm(cur1-ps[i]);\n\t\t\t  minpos = i;\n\t\t\t}\n\t\t    }\n\t\t  else if(arg < minArg)\n\t\t    {\n\t\t      minArg = arg;\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\n\t    }\n\n\t  //cout << \"phase #\" << _ << \" \" << minpos << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(minDist);\n\t  if(equals(cur1.y,ps[minpos].y) || cur1.y < ps[minpos].y)cur2 = Point(ps[minpos].x,inf);\n\t  else                                                    cur2 = Point(ps[minpos].x,-inf);\n\t  cur1 = ps[minpos];\n\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||abs(ps[i])<abs(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p;\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&cross(s-b,ps[j]-s)<=EPS){\n\t  p=ps[j];\n\t  break;\n\t}\n      }\n      for(int j=0;j<n;j++){\n\tif(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\tif(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\tif(equals(mycos(s-b,ps[j]-p),mycos(s-b,p-s))&&abs(s-ps[j])<abs(s-p)) p=ps[j];\n      }\n      ans+=abs(s-p);\n      b=s;\n      u[m[s=p]]=1;\n    }\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-512);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      \n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;ps.clear();\n    map<Point,int> m;m.clear();\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||norm(ps[i])<norm(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p = Point(-1,-1);\n      for(int j=0;j<n;j++){\n\tif(p.x<0){\n\t  if(!u[j]&&cross(s-b,ps[j]-s)<=0) p=ps[j];\n\t}else{\n\t  if(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\t  if(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\t  if(equals(mycos(s-b,ps[j]-s),mycos(s-b,p-s))&&norm(ps[j]-s)<norm(p-s)) p=ps[j];\n\t}\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-3\nint n;\ndouble x[501],y[501];\nbool flag[501];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t\t}\n\t\tmemset(flag,false,sizeof(flag));\n\t\tdouble len=0.0,mang,ll;\n\t\tint v=0,p=-1,next=-1;\n\t\tflag[0]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble ang;\n\t\t\tif(p!=-1)ang=atan2(y[v]-y[p],x[v]-x[p]);\n\t\t\telse ang=M_PI/2.0;\n\t\t\t//printf(\"%f\\n\",ang);\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(flag[j])continue;\n\t\t\t\tdouble ang2=atan2(y[j]-y[v],x[j]-x[v]);\n\t\t\t\tdouble ang3=ang-ang2;\n\t\t\t\tif(ang3+EPS<0)ang3+=M_PI*2;\n\t\t\t\tif(next==-1 || mang>ang3){\n\t\t\t\t\tmang=ang3;\n\t\t\t\t\tll=sqrt((y[j]-y[v])*(y[j]-y[v])+(x[j]-x[v])*(x[j]-x[v]));\n\t\t\t\t\tnext=j;\n\t\t\t\t}else if(mang==ang3 && sqrt((y[j]-y[v])*(y[j]-y[v])+(x[j]-x[v])*(y[j]-y[v]))<ll){\n\t\t\t\t\tll=sqrt((y[j]-y[v])*(y[j]-y[v])+(x[j]-x[v])*(x[j]-x[v]));\n\t\t\t\t\tnext=j;\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %f %f %f %f\\n\",j,next,y[j]-y[v],x[j]-x[v],ang2,ang3);\n\t\t\t}\n\t\t\tlen+=ll;\n\t\t\tflag[next]=true;\n\t\t\t//printf(\"%d %d %d %f\\n\",p,v,next,len);\n\t\t\tp=v;\n\t\t\tv=next;\n\t\t\tnext=-1;\n\t\t}\n\t\tprintf(\"%.1f\\n\",len);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\n\nnamespace std{\n  bool operator<(const P &a, const P &b){\n    double arg1 = arg(a), arg2 = arg(b);\n    if (sig(arg1 - PI) >= 0) arg1 = -PI;\n    if (sig(arg2 - PI) >= 0) arg2 = -PI;\n    if(!eq(arg1, arg2)) return arg1 < arg2;\n    return norm(a) < norm(b);\n  }\n}\n\nP plr(double theta) {return polar(1., theta);}\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    vector<P> v;\n    rep (i, n) {\n      int x, y;\n      cin >> x >> y;\n      v.push_back(P(x, y));\n    }\n    rep (i, n) {\n      v[i] = v[i] * plr(PI / 2);\n      v[i].Y *= -1;\n    }\n    double res = 0;\n    rep (i, n) {\n      sort(v.begin(), v.end());\n      res += abs(v[0]);\n      vector<P> vv;\n      rep (j, v.size() - 1) {\n\tvv.push_back((v[j + 1] - v[0]) * plr(-PI - arg(v[0])));\n      }\n      v = vv;\n    }\n    printf(\"%.1lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i;\n  int n;\n  while(cin>>n,n){\n    deque<int> a,b;\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      a.push_back(p);\n      b.push_back(q);\n    }\n    int x=0,y=0;\n    double z=M_PI/2;\n    double sm=0;\n    while(a.size()){\n      int mn=0;\n      for(i=1;i<(int)a.size();i++){\n\tif(0){\n\t}else if((atan2(b[mn]-y,a[mn]-x)>z?atan2(b[mn]-y,a[mn]-x)-M_PI*2:atan2(b[mn]-y,a[mn]-x))<(atan2(b[i]-y,a[i]-x)>z?atan2(b[i]-y,a[i]-x)-M_PI*2:atan2(b[i]-y,a[i]-x))){\n\t  mn=i;\n\t}else if((atan2(b[mn]-y,a[mn]-x)>z?atan2(b[mn]-y,a[mn]-x)-M_PI*2:atan2(b[mn]-y,a[mn]-x))==(atan2(b[i]-y,a[i]-x)>z?atan2(b[i]-y,a[i]-x)-M_PI*2:atan2(b[i]-y,a[i]-x))){\n\t  if((a[mn]-x)*(a[mn]-x)+(b[mn]-y)*(b[mn]-y)>(a[i]-x)*(a[i]-x)+(b[i]-y)*(b[i]-y))\n\t    mn=i;\n\t}\n      }\n      sm+=sqrt((a[mn]-x)*(a[mn]-x)+(b[mn]-y)*(b[mn]-y));\n      z=atan2(b[mn]-y,a[mn]-x);\n      x=a[mn];\n      y=b[mn];\n      a.erase(a.begin()+mn);\n      b.erase(b.begin()+mn);\n    }\n    printf(\"%.1lf\\n\",sm);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n  point operator / (double d){return point(x/d,y/d);}\n  bool operator == (const point &p )const{return abs(x-p.x)<EPS && abs(y-p.y)<EPS;}\n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n    \n    sort(v.begin(),v.end(),cmp_x);    \n\n    double sum=dist(v[0],v[1]);\n    bool fg[401];\n    point prev=v[0],now=v[1];\n    int nowID=1;\n\n    fill(fg,fg+401,false);\n    fg[0]=true;\n\n    for(int i=0;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && -EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    printf(\"%.1f\\n\",sum+0.005);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#define rep(i,a) for(int i = 0; i < a; i++)\n\nusing namespace std;\n\nconst int N = 1000010;\n\nstruct point {\n    int x, y;\n    point() {}\n    point(int x, int y) : x(x), y(y) {}\n    point operator +(const point& t) const {\n        return point(x + t.x, y + t.y);\n    }\n    point operator -(const point& t) const {\n        return point(x - t.x, y - t.y);\n    }\n};\n\nint n;\nvector<point> ps;\n\npoint perp(point p) {\n    return point(-p.y, p.x);\n}\n\nint dot(point p, point q) {\n    return p.x * q.x + p.y * q.y;\n}\n\nint side(point p1, point p2, point q) {\n    int d = dot(q - p1, perp(p2 - p1));\n    return d < 0 ? -1 : !!d;\n}\n\ndouble solve() {\n    vector<bool> visited(n, false);\n\n    double ans = 0.0;\n    point now(0, 0);\n    while (true) {\n        int nexti = -1;\n        point next;\n        for (int i = 0; i < n; ++i) {\n            if (visited[i])\n                continue;\n            if (nexti < 0 || side(now, next, ps[i]) > 0 || side(now, next, ps[i]) == 0 &&\n                hypot(next.x - now.x, next.y - now.y) > hypot(ps[i].x - now.x, ps[i].y - now.y)) {\n                nexti = i;\n                next = ps[i];\n            }\n        }\n\n        if (nexti == -1)\n            return ans;\n\n        ans += hypot(next.x - now.x, next.y - now.y);\n        visited[nexti] = true;\n        now = next;\n    }\n}\n\nint main(){\n    while (cin >> n, n) {\n        ps.clear();\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            ps.push_back(point(x, y));\n        }\n        printf(\"%.1f\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n            REP(j,coords.size()){\n                double angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n                if(0>angle){\n                    angle+=to_rad(360);\n                }\n                if(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n                    best_index=j;\n                    best_angle=angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle+=best_angle;\n            if(runner_angle>to_rad(360)){\n                runner_angle-=to_rad(360);\n            }\n        }\n \n        printf(\"%.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n};\n\ndouble angle(const point &p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble normalize(double theta) {\n\treturn theta < 0 ? theta + 2 * M_PI : theta;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(1);\n\tcout.setf(ios::fixed);\n\tconstexpr double INF = 1e9;\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<point> flags;\n\t\tflags.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tflags.emplace_back(x, y);\n\t\t}\n\n\t\tdouble ans = 0.0;\n\t\tpoint pos(0, 0);\n\t\tdouble dir = M_PI / 2;\n\t\tbitset<400> visited;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tpair<double, double> best(INF, INF);\n\t\t\tint next = -1;\n\t\t\tdouble next_dir;\n\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tif(visited[v]) continue;\n\n\t\t\t\tconst double dist2 = norm(flags[v] - pos);\n\t\t\t\tconst double theta = normalize(dir - angle(flags[v] - pos));\n\n\t\t\t\tconst pair<double, double> tmp(theta, dist2);\n\n\t\t\t\tif(tmp < best) {\n\t\t\t\t\tbest = tmp;\n\t\t\t\t\tnext = v;\n\t\t\t\t\tnext_dir = angle(flags[v] - pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += sqrt(best.second);\n\t\t\tpos = flags[next];\n\t\t\tdir = next_dir;\n\t\t\tvisited.set(next);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=0;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && -EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    sum*=10;\n    sum=round(sum);\n    sum/=10;\n\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\ndouble func(Point a, Point b, Point c){\n    Vector A = c-b, B = c-a, C = b-a;\n    return (norm(B)+norm(C)-norm(A))/(2*abs(B)*abs(C));\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        vector<bool> used(n, 0);\n        vector<Point> vp(n);\n        for(int i = 0; i < n; i++){\n            cin >> vp[i].x >> vp[i].y;\n        }\n        Point a(0, 0), b(0, 1);\n        double ans = 0;\n        for(int i = 0; i < n; i++){\n            double val, dist, tmp;\n            int next = -1;\n            for(int j = 0; j < n; j++){\n                if(used[j]) continue;\n                if(next == -1 || func(a, b, vp[j]) > val+EPS || (equals(func(a,b,vp[j]),val) && getDistance(a,vp[j]) < tmp)){\n                    next = j;\n                    val = func(a, b, vp[j]);\n                    tmp = getDistance(a, vp[j]);\n                }\n            }\n            ans += tmp;\n            used[next] = true;\n            Vector diff = vp[next]-a;\n            a = vp[next];\n            b = a + diff;\n        }\n        ans = (int)(ans*10+0.5) / 10.0;\n        printf(\"%.1f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||norm(ps[i])<norm(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p = Point(-1,-1);\n      for(int j=0;j<n;j++){\n\tif(p.x<0){\n\t  if(!u[j]&&cross(s-b,ps[j]-s)<=0) p=ps[j];\n\t}else{\n\t  if(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\t  if(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\t  if(equals(mycos(s-b,ps[j]-s),mycos(s-b,p-s))&&norm(ps[j]-s)<norm(p-s)) p=ps[j];\n\t}\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define EQ(a,b) (abs((a)-(b))<EPS)\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n\t\t\tdouble best_abs_angle=0;\n            REP(j,coords.size()){\n\t\t\t\tdouble abs_angle=atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(abs_angle<0){\n\t\t\t\t\tabs_angle+=to_rad(360);\n\t\t\t\t}\n                double angle;\n\t\t\t\t//if(EQ(runner_angle,abs_angle)){\n\t\t\t\t//\tangle=0;\n\t\t\t\t//}else{\n\t\t\t\t\tangle=runner_angle-abs_angle;\n\t\t\t\t//}\n\t\t\t\tif(angle<0){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n                if(best_angle>angle||(EQ(angle,best_angle)&&dist(cur,coords[best_index])>dist(cur,coords[j]))){\n                    best_index=j;\n                    best_angle=angle;\n\t\t\t\t\tbest_abs_angle=abs_angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle=best_abs_angle;\n        }\n \n        printf(\"%.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <cfloat>\n#include <complex>\nusing namespace std;\n\n\nstruct Point {\n\tint x, y;\n\tstruct Vector operator-(const Point& other) const;\n\tdouble distance(const Point& other) const;\n};\nstruct Vector {\n\tint dx, dy;\n\tint cross(const Vector& other) const;\n\tint dot(const Vector& other) const;\n\tdouble length() const;\n};\n\nint main() {\n\twhile (true) {\n\t\tint n; cin >> n; if (n == 0) break;\n\t\tvector<Point> points(n);\n\t\tfor (auto& point : points) cin >> point.x >> point.y;\n\t\tPoint current{ 0, 0 }, prev{ 0, -1 };\n\t\tdouble result = 0;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tconst auto base_vector = current - prev;\n\t\t\tsort(points.begin(), points.end(), [&](const Point& a, const Point& b) {return (a - current).cross(base_vector) >= 0 && (b - current).cross(base_vector) >= 0 ? \n\t\t\t\t((b - current).cross(a - current) == 0 ? abs((b - current).dx) < abs((a - current).dx) : (b - current).cross(a - current) < (a - current).cross(b - current)): \n\t\t\t\t(a - current).cross(base_vector) < (b - current).cross(base_vector); });\n\t\t\tresult += current.distance(points.back());\n\t\t\tprev = current;\n\t\t\tcurrent = points.back();\n\t\t\tpoints.pop_back();\n\t\t}\n\t\tint t10 = round(result * 10);\n\t\tcout << t10 / 10 << '.' << t10 % 10 << '\\n';\n\t}\n}\n\nVector Point::operator-(const Point& other) const\n{\n\treturn Vector{ x - other.x, y - other.y };\n}\n\ndouble Point::distance(const Point& other) const\n{\n\treturn (*this - other).length();\n}\n\nint Vector::cross(const Vector& other) const\n{\n\treturn dx * other.dy - dy * other.dx;\n}\n\nint Vector::dot(const Vector& other) const\n{\n\treturn dx * other.dx + dy * other.dy;\n}\n\ndouble Vector::length() const\n{\n\treturn sqrt(dx * dx + dy * dy);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n\tbool erased;\n};\n\ntypedef Info Vector;\n\nint N;\n\ndouble calc(double from_x,double from_y,Info to){\n\treturn sqrt((from_x-to.x)*(from_x-to.x)+(from_y-to.y)*(from_y-to.y));\n}\n\ndouble calc(Vector v){\n\treturn sqrt((v.x)*(v.x)+(v.y)*(v.y));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble calc_degree(Vector v1,Vector v2){\n\n\tdouble len_1 = calc(v1);\n\tdouble len_2 = calc(v2);\n\n\tdouble cos_val = dot(v1,v2)/(len_1*len_2);\n\n\tdouble rad = acos(cos_val);\n\n\treturn rad*180.0/M_PI;\n}\n\nvoid func(){\n\n\tInfo info[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t\tinfo[i].erased = false;\n\t}\n\n\tdouble sum_dist = 0.0,min_dist,min_degree,tmp_dist,tmp_degree;\n\tdouble current_x = 0.0,current_y = 0.0;\n\n\tVector current,tmp,next;\n\tcurrent.x = 0;\n\tcurrent.y = 500;\n\n\n\tint next_index;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tmin_dist = DBL_MAX,min_degree = DBL_MAX;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].erased)continue;\n\n\t\t\ttmp.x = info[i].x - current_x;\n\t\t\ttmp.y = info[i].y - current_y;\n\n\t\t\ttmp_degree = calc_degree(current,tmp);\n\n\t\t\tif(tmp_degree < min_degree){\n\t\t\t\tmin_degree = tmp_degree;\n\t\t\t\tmin_dist = calc(current_x,current_y,info[i]);\n\t\t\t\tnext_index = i;\n\t\t\t\tnext = tmp;\n\t\t\t}else if(fabs(tmp_degree-min_degree) < EPS){\n\t\t\t\ttmp_dist = calc(current_x,current_y,info[i]);\n\t\t\t\tif(tmp_dist < min_dist){\n\t\t\t\t\tmin_dist = tmp_dist;\n\t\t\t\t\tnext_index = i;\n\t\t\t\t\tnext = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo[next_index].erased = true;\n\n\t\tsum_dist += min_dist;\n\n\t\tcurrent_x = info[next_index].x;\n\t\tcurrent_y = info[next_index].y;\n\n\t\tcurrent = next;\n\t}\n\n\tprintf(\"%.1lf\\n\",sum_dist);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//テ「ツ?サテッツスツイテッツスツケテッツセツ津ッツセツ敕」ツ?ォテゥツ卍静」ツつ?\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//geo\n#include <complex>\ntypedef complex<double> P;\ninline bool equal(double x, double y){\n  return abs(x - y) < EPS;\n}\ninline bool operator == (const P& x, const P& y){\n  return equal(x.real(), y.real()) && equal(x.imag(), y.imag());\n}\ndouble dot(P x, P y){\n  return real(conj(x) * y);\n}\ndouble cross(P x, P y){\n  return imag(conj(x) * y);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n//---\nint main(){\n  int n;\n  while(cin>>n && n ){\n    vector<P> points;\n    vector<bool> used(n);\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      points.push_back(P(x,y));\n    }\n    P now(0, 0);\n    double ans = 0;\n    REP(time, n){\n      int next = -1;\n      REP(i, n)if(!used[i]){\n        bool ok = true;\n        REP(j, n)if(!used[j] && i != j){\n          int cw = ccw(now, points[i], points[j]);\n          if(cw == 0 || cw == 1) {\n            ok = false;\n          }\n          assert(cw != 2);\n        }\n        if(ok){\n          assert(next == -1);\n          next = i;\n        }\n      }\n      assert(next != -1);\n      used[next] = true;\n      ans += abs(points[next] - now);\n      now = points[next];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef pair<double, Point> P2;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\nPoint Ps[500];\nbool used[500];\n\ndouble dis(Point p1, Point p2){\n\treturn sqrt((p1.real() - p2.real())*(p1.real()-p2.real()) + (p1.imag() - p2.imag())*(p1.imag() - p2.imag()));\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(used, false,sizeof(used));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tPs[i] = Point(x, y);\n\t\t}\n\t\tPoint pre = Point(0, 0);\n\t\tdouble res = 0.0;\n\t\tdouble theta = M_PI;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint best = 0;\n\t\t\tdouble bestang = 1e10;\n\t\t\tfor(int j= 0; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tdouble a = atan2(Ps[j].imag() - pre.imag(), Ps[j].real() - pre.real());\n\t\t\t\tdouble b;\n\t\t\t\tif(theta - a < 0.0) b = 2 * M_PI + theta - a;\n\t\t\t\telse b = theta - a;\n\t\t\t\tif(b < bestang - EPS || (b < bestang + EPS && b > bestang - EPS &&\n\t\t\t\t\tdis(pre, Ps[best]) > dis(pre, Ps[j]))) \n\t\t\t\t{\n\t\t\t\t\tbest = j;\n\t\t\t\t\tbestang = b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tused[best] = true;\n\t\t\tres += dis(pre, Ps[best]);\n\t\t\ttheta = atan2(Ps[best].imag()-pre.imag(), Ps[best].real()-pre.real());\n\t\t\tpre = Ps[best];\n\t\t}\n\t\tcout << fixed << setprecision(1) << (int)(res * 10 + 0.5) / 10.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      cerr << n << endl;\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cerr << ps[i].x << \" \" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define mp(a,b) make_pair(a, b)\n\ntypedef vector<int> vi;\nstruct P { double angle, dist; int idx; };\nbool operator<(const P& p1, const P& p2) {\n\tif(p1.angle != p2.angle) return p1.angle < p2.angle;\n\tif(p1.dist != p2.dist) return p1.dist < p2.dist;\n\treturn p1.idx < p2.idx;\n}\n\nconst double PI = atan(1.0) * 4.0;\n\nconst double EPS = 1.0e-10;\nconst int MAX_N = 410;\nint n;\nint x[MAX_N], y[MAX_N];\nbool used[MAX_N];\n\ndouble atan3(int x1, int y1, int x2, int y2) {\n\tdouble dot = x1 * x2 + y1 * y2;\n\tdouble det = x1 * y2 - x2 * y1;\n\tdouble a = atan2(det, dot);\n\treturn a;\n}\n\ndouble distance(int x1, int y1, int x2, int y2) {\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\n\tvector<P> v;\n\tint px = 0, py = 0;\n\tint prevx = 0, prevy = -1;\n\tdouble dist = 0.0;\n\tint visit = 0;\n\twhile(visit < n) {\n\t\tv.clear();\n\t\trep(i,n) {\n\t\t\tif(!used[i]) {\n\t\t\t\tdouble angle = atan3(x[i]-px, y[i]-py, px-prevx, py-prevy);\n\t\t\t\tdouble dd = distance(px, py, x[i], y[i]);\n\t\t\t\tP p = { angle, dd, i };\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n\t\tint idx = v[0].idx;\n\t\tdist += v[0].dist;\n\t\tprevx = px;\n\t\tprevy = py;\n\t\tpx = x[idx];\n\t\tpy = y[idx];\n\t\tused[idx] = true;\n\t\tvisit++;\n\t}\n\tprintf(\"%.1f\\n\", dist);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\trep(i,n) scanf(\"%d%d\", &x[i], &y[i]);\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;\n    map<Point,int> m;\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      m[p]=i;\n      ps.push_back(p);\n    }\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||abs(ps[i])<abs(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p;\n      for(int j=0;j<n;j++){\n\tif(!u[j]&&cross(s-b,ps[j]-s)<=0){\n\t  p=ps[j];\n\t  break;\n\t}\n      }\n      for(int j=0;j<n;j++){\n\tif(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\tif(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\tif(equals(mycos(s-b,ps[j]-p),mycos(s-b,p-s))&&abs(s-ps[j])<abs(s-p)) p=ps[j];\n      }\n      //cout << p.x << \" \" << p.y << endl;\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ninline double euclid(double dx, double dy)\n{\n  return sqrt(dx*dx + dy*dy);\n}\n\nint main()\n{\n  int n, x[401], y[401], visited[401];\n\n  while (scanf(\"%d\", &n), n) {\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < n; ++i)\n      scanf(\"%d%d\", x+i, y+i);\n\n    int curr_x = 0, curr_y = 0;\n    int prev_x = 0, prev_y = -1;\n    double length = 0;\n\n    for (int i = 0; i < n; ++i) {\n      int dx1 = curr_x - prev_x;\n      int dy1 = curr_y - prev_y;\n\n      double min_theta = -1000;\n      double min_dist = 1000;\n      int min_index = -1;\n\n      for (int j = 0; j < n; ++j) {\n        if (visited[j])\n          continue;\n\n        int dx2 = x[j] - curr_x;\n        int dy2 = y[j] - curr_y;\n        double theta = (dx1*dx2 + dy1*dy2) / (euclid(dx1, dy1) * euclid(dx2, dy2));\n        double dist = euclid(x[j] - curr_x, y[j] - curr_y);\n\n        if (theta > min_theta || (fabs(theta - min_theta) < 1e-8 && dist < min_dist)) {\n          min_theta = theta;\n          min_dist = dist;\n          min_index = j;\n        }\n      }\n\n      prev_x = curr_x;\n      prev_y = curr_y;\n      curr_x = x[min_index];\n      curr_y = y[min_index];\n      visited[min_index] = true;\n      length += min_dist;\n    }\n\n    printf(\"%.1lf\\n\", length);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<P> p(n);\n    REP(i, n) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x,y);\n    }\n    P now(0,0);\n    double ans = 0;\n    REP(i,n) {\n      int next = 0;\n      for (int i=1; i<p.size(); ++i) {\n        int c = ccw(now, p[i], p[next]);\n        if (c == -1 || c == -2) {\n          next = i;\n        }\n      }\n      ans += abs(p[next]-now);\n      now = p[next];\n      p.erase(p.begin()+next);\n    }\n    printf(\"%.1f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n\n     \n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){return a.real()*b.real() + a.imag()*b.imag();}\n\nint main(){\n  int n;\n  P p[400];\n  bool use[400];\n\n  for(;;){\n    scanf(\"%d\",&n);\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%lf %lf\",&p[i].real(),&p[i].imag());\n      use[i] = false;\n    }\n\n    int cnt = n;\n    double ans = 0.0;\n    P prv1,prv2;\n    prv1.real() = prv1.imag() = prv2.real() = 0.0;\n    prv2.imag() = 1000.0;\n\n    int num = -1;\n    double val = -2.0;\n    for(int i=0;i<n;i++){\n      double tmp = dot(prv2-prv1,p[i]-prv1)/(abs(prv2-prv1)*abs(p[i]-prv1));\n      if(val + EPS < tmp){\n\tval = tmp;\n\tnum = i;\n      }else if(abs(val-tmp)<EPS && abs(p[i]-prv1)+EPS < abs(p[num]-prv1)){\n\tval = tmp;\n\tnum = i;\n      }\n    }\n\n    ans += abs(p[num]-prv1);\n    prv2 = p[num];\n    use[num] = true;\n    cnt--;\n\n    while(cnt){\n      int num = -1;\n      double val = -2.0;\n      for(int i=0;i<n;i++){\n\tif(!use[i]){\n\t  double tmp = dot(prv2-prv1,p[i]-prv2)/(abs(prv2-prv1)*abs(p[i]-prv2));\n\t  if(val + EPS < tmp){\n\t    val = tmp;\n\t    num = i;\n\t  }else if(abs(val-tmp)<EPS && abs(p[i]-prv2)+EPS < abs(p[num]-prv2)){\n\t    val = tmp;\n\t    num = i;\n\t  }\n\t} \n      }\n      ans += abs(p[num]-prv2);\n      prv1 = prv2;\n      prv2 = p[num];\n      use[num] = true;\n      cnt--;\n    }\n    printf(\"%.1lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\nbool eq(double a, double b){\n    return ( a-b < 0.0001 && a-b > -0.0001 );\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[800], y[800];\n    while( true ){\n        scanf(\" %d\", &n);\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf %lf\", x+i, y+i);\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1lf\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  Point C = Point(0,0);\n  double a = sqrt(norm(A-C));\n  double b = sqrt(norm(B-C));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && minDist > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += minDist;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double PI = 3.14159265358979;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<complex<int> > cp(n);\n    for (int i = 0; i < n; ++i)\n      cin >> cp[i].real() >> cp[i].imag();\n\n    double ans = 0.0;\n    vector<int> visited(n, 0);\n    complex<int> p(0, 0), dv(0, 1);\n    for ( ; ; ) {\n      int minIndex = -1;\n      double minAngle = 1e10, minDistance = 1e10;\n      for (int i = 0; i < n; ++i) {\n\tif (visited[i])\n\t  continue;\n\n\tcomplex<int> v = cp[i] - p;\n\tdouble angle = atan2(v.real()*dv.imag()-v.imag()*dv.real(), v.real()*dv.real()+v.imag()*dv.imag());\n\tif (angle+EPS < minAngle) {\n\t  minIndex = i;\n\t  minAngle = angle;\n\t  minDistance = hypot(cp[i].real()-p.real(), cp[i].imag()-p.imag());\n\t} else if (abs(angle-minAngle) < EPS) {\n\t  double dist = hypot(cp[i].real()-p.real(), cp[i].imag()-p.imag());\n\t  if (dist < minDistance) {\n\t    minIndex = i;\n\t    minDistance = dist;\n\t  }\n\t}\n      }\n\n      if (minIndex == -1)\n\tbreak;\n\n      ans += minDistance;\n      dv = cp[minIndex] - p;\n      p = cp[minIndex];\n      visited[minIndex] = 1;\n    }\n    printf(\"%.1f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-512);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nll sqr(ll x) { return x * x; }\nstruct poi {\n\tll x, y;\n\tvoid w() { cout << x << ' ' << y << '\\n'; }\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tll dot(poi p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tll len2() {\n\t\treturn dot(*this);\n\t}\n};\n\nbool solve(ll a, ll b, ll c, ll d) {\n\tif(a >= 0 && c < 0) return 1;\n\tif(a < 0 && c >= 0) return 0;\n\treturn (a * a * d > c * c * b) ^ (a < 0);\n}\n\nint main() {\n\tcout << fixed << setprecision(1);\n\tios :: sync_with_stdio(0);\n\n\tfor(int n; cin >> n && n; ) {\n\t\tvector <poi> v;\n\t\twhile(n --) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tv.pb({x, y});\n\t\t}\n\t\tpoi p = {0, 0};\n\t\tpoi d = {0, 1};\n\t\tdb ans = 0;\n\t\twhile(v.size()) {\n\t\t\tint id = 0;\n\t\t\t/*\n\t\t\tcout << \"------\\n\";\n\t\t\tfor(int i = 0; i < v.size(); i ++) {\n\t\t\t\tcout << d.dot(v[i] - p) << ' ' << (v[i] - p).len2() << '\\n';\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 1; i < v.size(); i ++) {\n\t\t\t\tll a = d.dot(v[i] - p);\n\t\t\t\tll b = (v[i] - p).len2();\n\t\t\t\tll c = d.dot(v[id] - p);\n\t\t\t\tll d = (v[id] - p).len2();\n\t\t\t\tif(solve(a, b, c, d))\n\t\t\t\t\tid = i;\n\t\t\t}\n\t\t\td = v[id] - p;\n\t\t\tans += sqrt(d.len2());\n\t\t\tp = v[id];\n\t\t\t//p.w();\n\t\t\tv.erase(v.begin() + id);\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = numeric_limits<double>::max();\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\t//double na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\t//double nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle <= 0.0 + EPS & abs(angle) < abs(minv)){\n\t\t\t\t\tnext = j;\n\t\t\t\t\tminv = angle;\t\n\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t}\n\n\t\t\t\telse if(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\t//dist *= 10.0;\n\t\t//dist = floor(dist);\n\t\t//dist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n  /*\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  */\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n\n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y < p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  u.pop_back();\n\t}\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  l.pop_back();\n\t}\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n\n  /*\n  cout << \"in andrew, raw data\" << endl;\n  rep(i,l.size())cout << \"(\" << l[i].x << \",\" << l[i].y << \")\" << endl;\n  cout << endl;\n  */\n  vector<Point> ret;\n\n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n\t{\n\t  if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n\t  if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n\t}\n    }\n\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n\n      rep(j,s.size())\n\t{\n\t  if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n\t  if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n\t}\n\n    }\n\n\n  return ret;\n}\n\n\nint n;\nvector<Point> input;\n\nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n\n}\n \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point now = Point(0,0); \n  now.index = -1; \n  while(true)\n    {\n      vector<Point> vec;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  vec.push_back(input[i]);\n\t}\n\n      if(vec.empty())break;\n\n      vec.push_back(now);\n      /*\n      rep(i,vec.size())\n\t  cout << \"$(\" << vec[i].x << \",\" << vec[i].y << \")\" << endl;\n      cout << endl;\n      */\n      vec = andrewScan(vec,now);\n\n      rep(i,vec.size())\n\t{\n\t      rep(k,n)\n\t\t{\n\t\t  if(used[k])continue;\n\t\t  if(input[k].index == vec[i].index || input[k].index == vec[(i+1)%vec.size()].index)continue;\n\t\t  if(equals(getDistanceSP(Segment(vec[i],vec[(i+1)%vec.size()]),input[k]),0))\n\t\t    {\n\t\t      //cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") and (\" << vec[(i+1)%vec.size()].x << \",\" << vec[(i+1)%vec.size()].y << \")  --- > (\" << input[k].x << \",\" << input[k].y << \")\" << endl;  \n\t\t      used[k] = true;\n\t\t  }\n\t\t  \n\t\t}\n\t}\n      /*\n      cout << \"remain \" << endl;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  cout << input[i].x << \",\" << input[i].y << endl;\n\t}\n      cout << endl;\n      */\n      /*\n      cout << \"after andrew, \" << endl;\n      rep(i,vec.size())\n\t{\n\t  cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") \" << vec[i].index << endl;\n\t}\n      cout << endl;\n      */\n      rep(i,vec.size()-1)\n\t{\n\t  if(!PointEquals(vec[i],vec[i+1]))\n\t    L += sqrt(pow(vec[i].x-vec[i+1].x,2)+pow(vec[i].y-vec[i+1].y,2));\n\t  if(vec[i].index == -1)continue;\n\t  used[vec[i].index] = true;\n\t}\n      now = vec[vec.size()-1];\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n      solve();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define dle(a,b) (equals(a, b) || a < b)\nstatic const double PI = acos(-1);\n\nclass Point {\n public:\n  double x, y;\n  \n  Point (double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  \n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x+y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n  Segment(Point s = Point(), Point t = Point()): p1(s), p2(t) {}\n};\n\ndouble norm( Vector a ) { return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ) { return sqrt(norm(a)); }\ndouble getDistance( Vector a, Vector b ) { return a.x*b.x + a.y*b.y; }\ndouble dot( Vector a, Vector b ) { return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ) { return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a, b) < -EPS ) return CLOCKWISE;\n  if( dot(a, b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nint main() {\n  Point p[401];\n  int n;\n  \n  while(cin >> n, n){\n    for(int i = 0; i < n; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    bool flag=true;\n    int i, j, k;\n    for(i = 0; i < n; i++) {\n      flag = true;\n      for(j = 0; j < n; j++) {\n\tif(i == j) continue;\n\tfor(k = 0; k < n; k++) {\n\t  if(i == k || j == k) continue;\n\t  if(ccw(p[i],p[j],p[k]) == COUNTER_CLOCKWISE || ccw(p[i],p[j],p[k]) == ONLINE_BACK) swap(p[j],p[k])\n\t}\n\tif(flag) break;\n      }\n      if (flag) break;\n    }\n    \n    double d = 0;\n    for(int m = 1; m < n; m++) {\n      d += getDistance(p[m-1],p[m]);\n    }\n    cout << d << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nstatic const double eps = 1e-8;\n\ninline double dist(double dx, double dy) { return sqrt(dx*dx + dy*dy); }\n\nint main()\n{\n  int n, x[400], y[400], visited[400];\n\n  while (scanf(\"%d\", &n), n) {\n    memset(visited, false, sizeof(visited));\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", x+i, y+i);\n    }\n\n    int curr_x = 0, curr_y = 0;\n    int prev_x = 0, prev_y = -1;\n    double length = 0;\n\n    for (int i = 0; i < n; ++i) {\n      int dx1 = curr_x - prev_x;\n      int dy1 = curr_y - prev_y;\n      int dist1 = dist(dx1, dy1);\n\n      double max_cos = -2.0;\n      double min_dist;\n      int index;\n\n      for (int j = 0; j < n; ++j) {\n        if (visited[j])\n          continue;\n\n        int dx2 = x[j] - curr_x;\n        int dy2 = y[j] - curr_y;\n        double dist2 = dist(dx2, dy2);\n        double cos = (dx1*dx2 + dy1*dy2) / (dist1 * dist2);\n\n        if (cos - max_cos > eps || (fabs(cos - max_cos) < eps && dist2 < min_dist)) {\n          max_cos = cos;\n          min_dist = dist2;\n          index = j;\n        }\n      }\n\n      prev_x = curr_x;\n      prev_y = curr_y;\n      curr_x = x[index];\n      curr_y = y[index];\n      visited[index] = true;\n      length += min_dist;\n    }\n\n    printf(\"%.1lf\\n\", length);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-512);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//geo\n#include <complex>\ntypedef complex<double> P;\ninline bool equal(double x, double y){\n  return abs(x - y) < EPS;\n}\ninline bool operator == (const P& x, const P& y){\n  return equal(x.real(), y.real()) && equal(x.imag(), y.imag());\n}\ndouble dot(P x, P y){\n  return real(conj(x) * y);\n}\ndouble cross(P x, P y){\n  return imag(conj(x) * y);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n//---\nint main(){\n  int n;\n  while(cin>>n && n ){\n    vector<P> points;\n    vector<bool> used(n);\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      points.push_back(P(x,y));\n    }\n    P now(0, 0);\n    double ans = 0;\n    REP(time, n){\n      int next = -1;\n      REP(i, n)if(!used[i]){\n        bool ok = true;\n        REP(j, n)if(!used[j] && i != j){\n          int cw = ccw(now, points[i], points[j]);\n          if(cw == 0 || cw == 1) {\n            ok = false;\n            break;\n          }\n          assert(cw != 2);\n        }\n        if(ok){\n          assert(next == -1);\n          next = i;\n        }\n      }\n      assert(next != -1);\n      used[next] = true;\n      ans += abs(points[next] - now);\n      now = points[next];\n    }\n    printf(\"%.1lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n  double cosn=dot(a,b)/(abs(a)*abs(b));\n  double sinn=cross(a,b)/(abs(a)*abs(b));\n  if(cosn>=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn>=0){\n    double angle=acos(cosn);\n    return angle;\n  }\n  else if(cosn<=0&&sinn<=0){\n    double angle=acos(cosn);\n    return 2*PI-angle;\n  }\n  else if(cosn>=0&&sinn<=0){\n    double angle=acos(cosn);\n    return 2*PI-angle;\n  }\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum+EPS);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define mp(a,b) make_pair(a, b)\n\ntypedef vector<int> vi;\nstruct P { double angle, dist; int idx; };\nbool operator<(const P& p1, const P& p2) {\n\tif(p1.angle != p2.angle) return p1.angle < p2.angle;\n\tif(p1.dist != p2.dist) return p1.dist < p2.dist;\n\treturn p1.idx < p2.idx;\n}\n\n\n\nconst double PI = atan(1.0) * 4.0;\n\nconst int MAX_N = 410;\nint n;\nint x[MAX_N], y[MAX_N];\nbool used[MAX_N];\n\ndouble atan3(int x1, int y1, int x2, int y2) {\n\treturn atan2((double)(y2-y1), (double)(x2-x1));\n}\n\ndouble distance(int x1, int y1, int x2, int y2) {\n\tdouble dx = x2 - x1;\n\tdouble dy = y2 - y1;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nvoid solve() {\n\tmemset(used, 0, sizeof(used));\n\n\tvector<P> v;\n\tint px = 0, py = 0;\n\tdouble d = PI / 2.0;\n\tdouble dist = 0.0;\n\tint visit = 0;\n\twhile(visit < n) {\n\t\tv.clear();\n\t\trep(i,n) {\n\t\t\tif(!used[i]) {\n\t\t\t\tdouble angle = atan3(px, py, x[i], y[i]);\n\t\t\t\tdouble dd = distance(px, py, x[i], y[i]);\n\t\t\t\tif(angle > d) angle -= 2.0 * PI;\n\t\t\t\tP p = { d-angle, dd, i };\n\t\t\t\tv.push_back(p);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n\t\tint idx = v[0].idx;\n\t\tdist += v[0].dist; \n\t\tpx = x[idx];\n\t\tpy = y[idx];\n\t\td = d-v[0].angle;\n\t\t// printf(\"%d\\n\", idx);\n\t\tused[idx] = true;\n\t\tvisit++;\n\t}\n\tprintf(\"%.1f\\n\", dist);\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\trep(i,n) scanf(\"%d%d\", &x[i], &y[i]);\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n \n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n \n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y > p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \n \nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n \ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n \n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      u.pop_back();\n    }\n      u.push_back(s[i]);\n    }\n \n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n    {\n      l.pop_back();\n    }\n      l.push_back(s[i]);\n    }\n \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n \n\n  vector<Point> ret;\n \n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n    }\n \n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n \n      rep(j,s.size())\n    {\n      if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n      if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n    }\n \n    }\n \n \n  return ret;\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n} \n\n \nint n;\nvector<Point> input;\n \nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n}\n  \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point cur = Point(0,0); \n  cur.index = -1; \n\n  rep(_,n)\n    {\n      vector<Point> toConvex;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  toConvex.push_back(input[i]);\n\t}\n      toConvex.push_back(cur);\n\n      toConvex = convex_hull(toConvex);\n      reverse(toConvex.begin(),toConvex.end());\n\n      vector<Point> tmp;\n      rep(j,toConvex.size())\n\t{\n\t  tmp.push_back(toConvex[j]);\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      if(toConvex[j].index == input[i].index || toConvex[(j+1)%toConvex.size()].index == input[i].index)continue;\n\t      if(equals(getDistanceSP(Segment(toConvex[j],toConvex[(j+1)%toConvex.size()]),input[i]),0))\n\t\t{\n\t\t  tmp.push_back(input[i]);\n\t\t}\n\t    }\n\t}\n      toConvex = tmp;\n\n      \n      cout << \"toConvex----- cur : \" << cur.x << \",\" << cur.y << endl;\n      rep(i,toConvex.size())\n      {\n\t  cout << toConvex[i].x << \",\" << toConvex[i].y  << \" \" << toConvex[i].index<< endl;\n\t}\n      cout << endl;\n      \n\n      int next = -inf;\n      rep(i,toConvex.size())\n\t{\n\t  if(toConvex[i].index == cur.index)\n\t    {\n\t      next = toConvex[(i+1)%toConvex.size()].index;\n\t      break;\n\t    }\n\t}\n      \n      assert(next != -inf);\n      cout << \"next = \" << next << \" : \" << input[next].x << \",\" << input[next].y << endl;\n      used[next] = true;\n      L += sqrt(norm(cur-input[next]));\n      cur = input[next];\n\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n\n      solve();\n \n    }\n  return 0;\n}\n\n//変数に一旦いれてたらばぐった\n\n*/\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n#define pow2(a) (a)*(a)\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  return acos(dot(A,B)/(sqrt(norm(A))*sqrt(norm(B))));\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nPoint ps[1000];\nbool used[1000];\n\nint main()\n{\n \n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n      Point cur(0,0);\n      Point cur2(0,-512);\n      double L = 0;\n      int last = n;\n\n      rep(_,n)\n\t{\n\t  /*\n\t  cout << \"remain\"<<endl;\n\t  rep(i,last)\n\t    {\n\t      cout << ps[i].x << \",\" << ps[i].y << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  int next = 0;\n\t  REP(i,1,last)\n\t    {\n\t      //if(equals(atan2(ps[next].y-cur.y,ps[next].x-cur.x),atan2(ps[i].y-cur.y,ps[i].x-cur.x)))\n\t      if(equals(getArgV2(cur-cur2,ps[next]-cur), getArgV2(cur-cur2,ps[i]-cur)))\n\t\t{\n\t\t  if(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y) > pow2(cur.x-ps[i].x)+pow2(cur.y-ps[i].y))\n\t\t    {\n\t\t      next = i;\n\t\t    }\n\t\t}\n\t      else if(getArgV2(cur-cur2,ps[next]-cur) > getArgV2(cur-cur2,ps[i]-cur))\n\t\t{\n\t\t  next = i;\n\t\t}\n\t    }\n\t  //cout << \"erase : \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  L += sqrt(pow2(cur.x-ps[next].x)+pow2(cur.y-ps[next].y));\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  ps[next] = ps[last-1];\n\t  last--;\n\t}\n      \n      L *= 10;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      //printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n/*\nint main()\n{\n  Point A = Point(0,10);\n  Point B = Point(-10,15);\n\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n  B = Point(11,20);\n  cout << atan2(B.y-A.y,B.x-A.x)*180/M_PI << endl;\n\n\n  int n; \n  while(cin >> n,n)\n    {\n   \n\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  cout << i << \" :: \" << ps[i].x << \",\" << ps[i].y << endl;\n\t  used[i] = false;\n\t}\n      cout << atan2(ps[5].y-ps[4].y,ps[5].x-ps[4].x)*180/M_PI << endl;\n      cout << \"##### \" << getArgV2(ps[5]-ps[4],ps[4]-Point(0,0))*180/M_PI << endl;\n      sort(ps,ps+n,cmp);\n\n\n\n      bool f = true;\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      if(f)\n\t\t{\n\t\t  f = false;\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  continue;\n\t\t}\n\n\t      //cout << arg << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  //assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n*/\n/*\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nstruct Point\n{\n  double x,y;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &b)const\n  {\n    if(x != b.x)return x < b.x;\n    return y < b.y;\n  }\n};\n\nPoint ps[410];\nbool use[410];\n\ndouble toRad(double agl){ return agl*M_PI/180; }\n\ndouble getArg(Point a,Point bb)\n{\n\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  use[i] = false;\n\t}\n      sort(ps,ps+n);\n\n      Point cur = Point(0,0);\n      Point cur2 = Point(0,0);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(!_)\n\t    {\n\t      cur = ps[0];\n\t      use[0] = true;\n\t      L += sqrt(norm(cur-ps[0]));\n\t      continue;\n\t    }\n\t  cout << \"cur \" << cur.x << \",\" << cur.y << endl;\n\t  cout << \"cur2 \" << cur2.x << \",\" << cur2.y << endl;\n\t  int next = -inf;\n\t  double maxArg = -inf;\n\n\t  rep(i,n)\n\t    {\n\t      if(use[i])continue;\n\t      //cout << \"i = \"<< i << endl;\n\n\t      Point cc = cur - cur2;\n\t      double arg = atan2(ps[i].y-cc.y,ps[i].x-cc.x);\n\n\t      if(!equals(arg,toRad(90)) && arg > toRad(90))arg = toRad(-180)-(toRad(180)-arg);\n\t      cout << i << \" arg = \" << arg*180/M_PI << \" max : \" << maxArg << endl;\n\t      if(!equals(arg,maxArg) && arg > maxArg)\n\t\t{\n\t\t  maxArg = arg;\n\t\t  next = i;\n\t\t}\n\t      else if(equals(arg,maxArg) &&  norm(ps[next]-cur) > norm(ps[i]-cur) )\n\t\t{\n\t\t  next = i;\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  cout << \"next = \" << next << \" \" << ps[next].x << \",\" << ps[next].y << endl;\n\t  assert(next != -inf);\n\t  L += sqrt(pow(cur.x-ps[next].x,2)+pow(cur.y-ps[next].y,2));\n\t\n\n\t  cur2 = cur;\n\t  cur = ps[next];\n\t  use[next] = true;\n\t  cout << endl << endl;\n\t}\n\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}\n\n\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nlong long int gcd(long long int l, long long int r) {\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint N;cin>>N;\n\t\tif(!N)break;\n\t\tld ans=0;\n\n\t\tvector<pair<ld,ld>>ps(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x,y;cin>>x>>y;\n\t\t\tps[i]=make_pair(x,y);\n\t\t}\n\t\tvector<int>used(N);\n\t\tld nx=0;\n\t\tld ny=0;\n\t\tld nway = acos(-1.0) / 2;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint next_id(-1);\n\t\t\tld amin(1e18);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (!used[j]) {\n\t\t\t\t\tld dx=ps[j].first-nx;\n\t\t\t\t\tld dy=ps[j].second-ny;\n\n\t\t\t\t\tld away=atan2(dy,dx)-eps;\n\t\t\t\t\tif(away<0)away+=2*acos(-1.0);\n\n\t\t\t\t\tif (away > nway) {\n\t\t\t\t\t\taway-=2*acos(-1.0);\n\t\t\t\t\t}\n\t\t\t\t\tld score=nway-away+(abs(dx)+abs(dy))*0.000001;\n\t\t\t\t\tif (amin > score) {\n\t\t\t\t\t\tnext_id=j;\n\t\t\t\t\t\tamin=score;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=sqrt(powl(ps[next_id].first-nx,2)+powl(ps[next_id].second-ny,2));\n\t\t\tused[next_id]=true;\n\t\t\tnway = atan2(ps[next_id].second-ny,ps[next_id].first-nx);\n\t\t\tnx=ps[next_id].first;\n\t\t\tny=ps[next_id].second;\n\t\t}\n\n\t\tcout<<setprecision(1)<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\nint n;\n\nint main()\n{\n  /*\n  Point a = Point(10,10);\n  Point b = Point(10,inf);\n  Point c = Point(0,0);\n\n  cout << getArg(a,b,c)*180/M_PI << endl;\n  */\n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,inf);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      double L = 0;\n      rep(_,n)\n\t{\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << i << \" ----------------- \" << ps[i].x << \",\" << ps[i].y << endl;\n\t      int res = ccw(cur1,cur2,ps[i]);\n\t      if(!(res == ONLINE_FRONT || res == ON_SEGMENT || res == CLOCKWISE || res == ONLINE_BACK))continue;\n\t      double arg = getArg(cur1,cur2,ps[i]);\n\t      //cout << \"arg = \" << arg*180/M_PI  << \" || \" << minArg*180/M_PI<< endl;\n\t      //cout <<\"equal? -> \" << equals(arg,minArg) << \" \" << arg << \" = \"<< minArg << endl;\n\t      if(equals(arg,minArg))\n\t\t{\n\t\t  //cout << \"equals!!!\" << endl;\n\t\t  if(minDist > norm(cur1-ps[i]))\n\t\t    {\n\t\t      //cout << \"change to \" << ps[i].x << \",\" << ps[i].y << endl;\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minArg = arg;\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\t      else if(arg < minArg)\n\t\t{\n\t\t  minArg = arg;\n\t\t  minDist = norm(cur1-ps[i]);\n\t\t  minpos = i;\n\t\t}\n\t    }\n\n\t  if(minpos == -inf)\n\t    {\n\t      //cout << \"inf!!!\" << endl;\n\t      rep(i,n)\n\t\t{\n\t\t  if(used[i])continue;\n\t\t  int res = ccw(cur1,cur2,ps[i]);\n\t\t  double arg = getArg(cur1,cur2,ps[i]);\n\t\t  if(equals(arg,minArg))\n\t\t    {\n\t\t      if(minDist > norm(cur1-ps[i]))\n\t\t\t{\n\t\t\t  minDist = norm(cur1-ps[i]);\n\t\t\t  minpos = i;\n\t\t\t}\n\t\t    }\n\t\t  else if(arg < minArg)\n\t\t    {\n\t\t      minArg = arg;\n\t\t      minDist = norm(cur1-ps[i]);\n\t\t      minpos = i;\n\t\t    }\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(minDist);\n\t  if(!equals(cur1.y,ps[minpos].y) && cur1.y < ps[minpos].y)cur2 = Point(ps[minpos].x,inf);\n\t  else                                                    cur2 = Point(ps[minpos].x,-inf);\n\t  cur1 = ps[minpos];\n\n\t}\n      L *= 10.0;\n      L = round(L);\n      L /= 10.0;\n      cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n/*\ndouble adjust(double theta) {\n  \n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n*/\n\ndouble calcCos(const P& a, const P& b) {\n  return dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) );\n}\n\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      \n      double cos_ = -10e9;\n      double len  = 10e9;\n      \n      /*\n      double angle = 10;\n      double len = 10e9;\n      */\n      \n      for(int i=0; i<n; i++) {\n\t\n\tif(!used[i]) {\n\t  /*\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\n\t   */\n\t  double costmp = calcCos(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( cos_ < costmp || ( equals(cos_, costmp) && len > lentmp ) ) {\n\t    cos_ = costmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t  \n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=1;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    sum*=10;\n    sum=round(sum);\n    sum/=10;\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nconst int MAX = 450;\nconst double EPS = 1e-9;\n\ntypedef pair<int,int> P;\nvector<P> V;\nbool come[MAX];\n\n\ndouble dot(P a, P b){\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y-a.Y*b.X;\n}\n\ndouble getLength(P pre, P nex){\n  return sqrt((pre.X-nex.X)*(pre.X-nex.X)+(pre.Y-nex.Y)*(pre.Y-nex.Y));\n}\n\ndouble getAngle(P pre, P nex){\n  return acos(dot(pre,nex)/(getLength(pre,P(0,0))*getLength(nex,P(0,0))));\n}\n\nbool ccw(P p0, P p1, P p2){\n  P a = P(p1.first-p0.first,p1.second-p0.second);\n  P b = P(p2.first-p0.first,p2.second-p0.second);\n  return (cross(a,b) > EPS);\n}\n\n\nP Pminus(P a, P b){\n  a.first -= b.first;\n  a.second -= b.second;\n  return a;\n}\n\n\nvoid solve(){\n\n  sort(V.begin(),V.end());\n\n  double ans = getLength(P(0,0),V[0]);\n\n  P pre = P(0,0);\n  P now = V[0];\n\n  int roop = V.size()-1;\n\n  while(roop--){\n    int nex = -1;\n    double nexTheta;\n\n    for(int i = 1; i < V.size(); i++){\n      if(come[i]) continue;\n   \n      //  if(ccw(pre,now,V[i])) continue;\n   \n      if(nex == -1){\n\tnex = i;\n\tnexTheta = getAngle(Pminus(V[i],now),Pminus(now,pre));\n\tcontinue;\n      }\n\n\n      double theta = getAngle(Pminus(now,pre),Pminus(V[i],now));\n      \n      if(fabs(nexTheta-theta) > EPS && nexTheta > theta){\n\t  nex = i;\n\t  nexTheta = theta;\n      } \n      if(fabs(nexTheta-theta) < EPS && getLength(now,V[nex]) > getLength(now,V[i])){\n\tnex = i;\n\tnexTheta = theta;\n      }\n    }\n\n    //cout << nex << endl;\n\n    //  cout <<nex << \" \" <<  V[nex].X << \" \" << V[nex].Y << endl;\n    come[nex] = true;\n\n    ans += getLength(now,V[nex]);\n    pre = now;\n    now = V[nex];\n  }\n  printf(\"%.1f\\n\",ans);\n}\n\nint main(){\n\n  int n;\n  while(cin >> n && n){\n    memset(come,false,sizeof(come));\n    V.resize(n);\n    for(int i = 0; i < n; i++) cin >> V[i].X >> V[i].Y;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n  /*\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  */\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  Point C = Point(0,0);\n  double a = sqrt(norm(A-C));\n  double b = sqrt(norm(B-C));\n  return acos(dot(A,B)/(a*b));\n}\n\nint n;\n\nint main()\n{\n \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      else if(equals(arg,minArg) && minDist > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += minDist;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-5;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\ndouble to_rad(int angle){\n\treturn angle*PI*2/360;\n}\n\ndouble dist(pii l,pii r){\n\treturn sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp coords;\n\t\tcoords.push_back(make_pair(0,0));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tcoords.push_back(make_pair(x,y));\n\t\t}\n\n\t\tdouble res=0;\n\t\tint cur_index=0;\n\t\tdouble runner_angle=to_rad(90);\n\t\twhile(coords.size()>1){\n\t\t\tpii cur=coords[cur_index];\n\t\t\tcoords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n\t\t\tint best_index=0;\n\t\t\tdouble best_angle=1000;\n\t\t\tREP(j,coords.size()){\n\t\t\t\tdouble angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(GT(0,angle)){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n\t\t\t\tif(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n\t\t\t\t\tbest_index=j;\n\t\t\t\t\tbest_angle=angle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres+=dist(cur,coords[best_index]);\n\t\t\tcur_index=best_index;\n\t\t\trunner_angle+=best_angle;\n\t\t\tif(GT(runner_angle,to_rad(360))){\n\t\t\t\trunner_angle-=to_rad(360);\n\t\t\t}\n\t\t}\n\n\t\tres=(int)(res*10);\n\t\tres/=10;\n\t\tprintf(\"%.1f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-8;\ntypedef complex<double> P;\n\nint next_flag(P &now, P &d, vector<P> &ps, vector<bool> &used){\n  int res = 0;\n  double a = 400.0;\n  REP(i, ps.size()){\n    if(used[i]) continue;\n    int ty = ps[i].imag() - now.imag();\n    int tx = ps[i].real() - now.real();\n    int ny = now.imag() - d.imag();\n    int nx = now.real() - d.real();\n    double tmpa = atan2(tx * ny - nx * ty, tx * nx + ty * ny) / M_PI;\n    if(tmpa < a || (abs(tmpa - a) < EPS && abs(now - ps[i]) < abs(now - ps[res]))){\n      res = i;\n      a = tmpa;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    vector<P> ps(N);\n    REP(i, N){\n      int x, y; cin >>x >>y;\n      ps[i] = P(x, y);\n    }\n    vector<bool> used(N, 0);\n    P now = P(0, 0), d = P(1, 0);\n    double res = 0.0;\n    REP(n, N){\n      int next = next_flag(now, d, ps, used);\n      used[next] = 1;\n      res += abs(now - ps[next]);\n      d = now;\n      now = ps[next];\n    }\n    printf(\"%.1lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-10;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nenum { COUNTER_CLOCKWISE, CLOCKWISE, ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT };\nint ccw(P c, P a, P b)\n{\n  a = a - c;\n  b = b - c;\n  if(cross(a, b) >  EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS)   return ONLINE_BACK;\n  if(norm(a) < norm(b))  return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n  \n\nint main() {\n  \n  int n;\n  while(cin >> n && n) {\n    vector<P> p(n);\n    for(int i=0; i<n; i++) {\n      int x, y; cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    vector<bool> used(n);\n    P curr(0, 0);\n    double ans = 0.0;\n    \n    for(int i=0; i<n; i++) {\n      int num = -1;\n      for(int j=0; j<n; j++) {\n\tif(!used[j]) {\n\t  \n\t  if(num == -1) {\n\t    num = j;\n\t  } else {\n\t    int c = ccw(curr, p[num], p[j]);\n\t    if(c == COUNTER_CLOCKWISE || c == ON_SEGMENT) {\n\t      // テ・ツ?湘ィツァツ津」ツ?ョテ・ツキツョテ」ツ?古」ツつ暗」ツつ甘・ツーツ湘」ツ?陛」ツ?湘」ツ??」ツつ暗」ツつ甘・ツ、ツァテ」ツ?催」ツ?陛」ツ?古・ツーツ湘」ツ?陛」ツ??」ツつづ」ツ?ョテ」ツつ津ゥツ?クテヲツ環?\n\t      num = j;\n\t    }\n\t  }\n\t  \n\t}\n      }\n      ans += sqrt(norm(p[num]-curr));\n      used[num] = true;\n      curr = p[num];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\nconstexpr double EPS = 1e-9;\n\nstruct point {\n  double x, y;\n  point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n  point(const point &p):x(p.x), y(p.y) {}\n\n  point operator+(const point &p) const {\n\treturn point(x + p.x, y + p.y);\n  }\n\n  point operator-(const point &p) const {\n\treturn point(x - p.x, y - p.y);\n  }\n};\n\nostream &operator<<(ostream &os, const point &p) {\n  return os << '(' << p.x << \", \" << p.y << ')';\n}\n\ndouble angle(const point &p) {\n  return atan2(p.y, p.x);\n}\n\ndouble norm(const point &p) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble normalize(double theta) {\n  if(theta < -M_PI) return theta + 2 * M_PI;\n  if(theta > M_PI) return theta - 2 * M_PI;\n  return theta;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout.precision(1);\n  cout.setf(ios::fixed);\n  constexpr double INF = 1e9;\n\n  for(int n; cin >> n && n;) {\n\tvector<point> flags;\n\tflags.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t  double x, y;\n\t  cin >> x >> y;\n\t  flags.emplace_back(x, y);\n\t}\n\n\tdouble ans = 0.0;\n\tpoint pos(0, 0);\n\tdouble dir = M_PI / 2;\n\tbitset<40> visited;\n\n\tfor(int i = 0; i < n; ++i) {\n\t  pair<double, double> best(INF, INF);\n\t  int next = -1;\n\t  double next_angle;\n\n\t  for(int v = 0; v < n; ++v) {\n\t\tif(visited[v]) continue;\n\n\t\tdouble dist2 = norm(flags[v] - pos);\n\t\tdouble theta = normalize(dir - angle(flags[v] - pos));\n\n\t\tpair<double, double> tmp(theta, dist2);\n\n\t\tif(tmp < best) {\n\t\t  best = tmp;\n\t\t  next = v;\n\t\t  next_angle = angle(flags[v] - pos);\n\t\t}\n\t  }\n\n\t  assert(next != -1);\n\n\t  ans += sqrt(best.second);\n\t  pos = flags[next];\n\t  dir = next_angle;\n\t  visited.set(next);\n\t}\n\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y > b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define EQ(a,b) (abs((a)-(b))<EPS)\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n\t\t\tdouble best_abs_angle=0;\n            REP(j,coords.size()){\n\t\t\t\tdouble abs_angle=atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n\t\t\t\tif(abs_angle<0){\n\t\t\t\t\tabs_angle+=to_rad(360);\n\t\t\t\t}\n                double angle;\n\t\t\t\tif(EQ(runner_angle,abs_angle)){\n\t\t\t\t\tangle=0;\n\t\t\t\t}else{\n\t\t\t\t\tangle=runner_angle-abs_angle;\n\t\t\t\t}\n\t\t\t\tif(angle<0){\n\t\t\t\t\tangle+=to_rad(360);\n\t\t\t\t}\n                if(best_angle>angle||(EQ(angle,best_angle)&&dist(cur,coords[best_index])>dist(cur,coords[j]))){\n                    best_index=j;\n                    best_angle=angle;\n\t\t\t\t\tbest_abs_angle=abs_angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle=best_abs_angle;\n        }\n \n        printf(\"%.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\nlong double cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nlong double norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n);\n    for(int i=0;i<n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[401];\n    point prev=point(0,-1),now=point(0,0);\n    int nowID=-1;\n\n    fill(fg,fg+401,false);\n\n    for(int i=0;i<v.size();i++){\n      if(nowID>=0)fg[nowID]=true;\n      long double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(fg[j])continue;\n\tint c=ccw(prev,now,v[j]);\n\tif(c<0){\n\t  if(-EPS>angle-getAngle(prev,now,v[j])){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t  else if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t    if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t      id=j,angle=getAngle(prev,now,v[j]);\n\t    }\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n  /*\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  */\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \ndouble getAngle(point  A,point B,point C){\n  double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=0;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(!fg[j] && -EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(!fg[j] && abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n      if(!fg[id]){\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n      }\n    }\n\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a) * b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n\ndouble adjust(double theta) {\n  \n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      double angle = 10;\n      double len = 10e9;\n      \n      for(int i=0; i<n; i++) {\n\tif(!used[i]) {\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  \n\t  if( cross(p[i]-curr, orient) < -EPS ) continue;\n\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n/*\ndouble adjust(double theta) {\n  \n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n*/\n\n/*\ndouble calcCos(const P& a, const P& b) {\n  return dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) );\n}\n*/\n\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n      P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P prev = P(-1, 0);\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      \n      double cos_ = -10e9;\n      double len  = 10e9;\n      \n      P v1 = curr - prev;\n      \n      /*\n      double angle = 10;\n      double len = 10e9;\n      */\n      \n      for(int i=0; i<n; i++) {\n\t\n\tif(!used[i]) {\n\t  /*\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle + EPS > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\n\t   */\n\t  double costmp = dot(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( cos_ < costmp || ( equals(cos_, costmp) && len > lentmp ) ) {\n\t    cos_ = costmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t  \n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n\torient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dist(P a, P b)\n{\n\treturn abs(a-b);\n}\n\ndouble angle(P a, P b, P c)\n{\n\treturn arg((b-c)/(a-b));\n}\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N), N)\n\t{\n\t\tvector<P> v(N);\n\t\tvector<bool> used(N, false);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\", &x,&y);\n\t\t\tv[i]=P(x,y);\n\t\t}\n\n\t\tdouble ans=0;\n\t\tP a=P(0,-1),b=P(0,0);\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint select=-1;\n\t\t\tdouble alg=0;\n\t\t\tfor(int j=0; j<N; j++)\n\t\t\t{\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tdouble t=angle(a,b,v[j]);\n\t\t\t\tif(select==-1)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t==alg)\n\t\t\t\t{\n\t\t\t\t\tif(dist(b,v[j]) < dist(b, v[select]))\n\t\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t\telse if(t>alg)\n\t\t\t\t{\n\t\t\t\t\talg=t;\n\t\t\t\t\tselect=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[select]=true;\n\t\t\ta=b; b=v[select];\n\t\t\tans+=dist(a,b);\n\t\t}\n\n\t\tprintf(\"%.1lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    double x[400], y[400];\n    while( true ){\n        int n;\n        scanf(\" %d\", &n);\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            scanf(\"   %lf  %lf\", &x[i], &y[i]);\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( ang == lv && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1lf\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Point np(0,0);\n    Vector v(0,1);\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i];\n    }\n    double res = 0;\n    bool visited[MAX_N] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int idx = -1;\n      double min = INF;\n      for(int j = 0 ; j < N ; j++){\n        if(visited[j]){ continue; }\n        Vector v2 = p[j]-np;\n        double angle = acos(dot(v,v2)/(abs(v)*abs(v2)));\n        if(lt(angle,min)){\n          min = angle;\n          idx = j;\n        }\n      }\n      visited[idx] = true;\n      res += dist(np,p[idx]);\n      v = p[idx]-np;\n      np = p[idx];\n    }\n    printf(\"%.10f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble mycos(Point a,Point b){\n  return dot(a,b)/(abs(a)*abs(b));\n  //return atan2(a.y,a.x)-atan2(b.y,b.x)*360;\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps;ps.clear();\n    map<Point,int> m;m.clear();\n    for(int i=0;i<n;i++){\n      Point p;\n      cin>>p.x>>p.y;\n      ps.push_back(p);\n    }\n    sort(ps.begin(),ps.end());\n    for(int i=0;i<n;i++) m[ps[i]]=i;\n    bool u[n];\n    memset(u,0,sizeof(u));\n    Point s=ps[0],b=Point(0,0);\n    for(int i=0;i<n;i++){\n      if(ps[i].x){\n\tif(s.x&&s.y/s.x<ps[i].y/ps[i].x) s=ps[i]; \n      \tif(s.y+ps[i].y==0&&s.x>ps[i].x) s=ps[i]; \n      }else{\n\tif(s.x||norm(ps[i])<norm(s)) s=ps[i];\n      }\n    }\n    u[m[s]]=1;\n    double ans=abs(s);\n    for(int i=1;i<n;i++){\n      //cout << ans << endl;\n      Point p = Point(-1,-1);\n      for(int j=0;j<n;j++){\n\tif(p.x<0){\n\t  if(!u[j]&&cross(s-b,ps[j]-s)<=0) p=ps[j];\n\t}else{\n\t  if(u[j]||p==ps[j]||cross(s-b,ps[j]-s)>0) continue;\n\t  if(cross(p-s,ps[j]-s)==0.0){ \n\t    if(norm(ps[j]-s)<norm(p-s)) p=ps[j];\n\t  }else if(mycos(s-b,ps[j]-s)>mycos(s-b,p-s)) p=ps[j];\n\t}\n      }\n      ans+=abs(s-p);\n      b=s;s=p;\n      u[m[s]]=1;\n    }\n    for(int i=0;i<n;i++) assert(u[i]);\n    printf(\"%.1lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = 100000.0;\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle <= 0.0 + EPS){\n\t\t\t\t\tif(abs(angle) < abs(minv)){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tminv = angle;\t\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t\tprintf(\"%d %d\\n\",prev.x,prev.y);\n\t\t}\n\t\t//dist *= 10.0;\n\t\t//dist = floor(dist);\n\t\t//dist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            min = 10.0f;\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = arg((*it - last_point) / last_vector);\n                if (temp < min || (temp == min && abs(*it - last_point) < abs(*_it - last_point))) {min = temp; _it = it;}\n            }\n            next_point = *_it;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble getAngle(P a, P b) {\n  return acos(dot(a,b)/(abs(a)*abs(b)));\n}\n\nconst int MAXN = 401;\n\nint N;\nP ps[MAXN];\nbool used[MAXN];\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(used, used+MAXN, false);\n    P s(0,-1);\n    P t(0,0);\n    double sum = 0;\n    for(int tc = 0; tc < N; ++tc) {\n      int j;\n      pair<double,double> mini(inf,inf);\n      for(int i = 0; i < N; ++i) {\n        if(used[i]) continue;\n        P p = ps[i];\n        if(cross(t-s,p-s) > 0) continue;\n        pair<double,double> v(getAngle(t-s,p-t),abs(p-t));\n        if(mini > v) {\n          mini = v;\n          j = i;\n        }\n      }\n      used[j] = true;\n      P u = ps[j];\n      sum += abs(u-t);\n      s = t;\n      t = u;\n    }\n    printf(\"%.1f\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nbool equals(double a,double b)\n{\n  return fabs((a)-(b)) < EPS;\n}\n\nclass Point\n{\n  public:\n  int x,y;\n\n  Point(int x = -1,int y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (int a){return Point(a*x,a*y);}\n  Point operator / (int a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n/*\ndouble getArg(Point A,Point B,Point C)\n{\n  double a = sqrt(norm(B-C));\n  double b = sqrt(norm(A-C));\n  double c = sqrt(norm(A-B));\n  double cs = (b*b+c*c-a*a)/(2.0*b*c);\n  return acos(cs);\n}\n*/\ndouble getArgV2(Point A,Point B)\n{\n  double a = sqrt(norm(A));\n  double b = sqrt(norm(B));\n  return acos(dot(A,B)/(a*b));\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n  if(a.x != b.x)return a.x < b.x;\n  return a.y < b.y;\n}\n\nint main()\n{\n  int n; \n  while(cin >> n,n)\n    {\n      Point ps[n];\n      bool used[n];\n      Point cur1 = Point(0,0);\n      Point cur2 = Point(0,0);\n      rep(i,n)\n\t{\n\t  cin >> ps[i].x >> ps[i].y;\n\t  used[i] = false;\n\t}\n      sort(ps,ps+n,cmp);\n      double L = 0;\n      rep(_,n)\n\t{\n\t  if(_ == 0)\n\t    {\n\t      L += sqrt(norm(ps[0]-cur1));\n\t      cur1 = ps[0];\n\t      used[0] = true;\n\t      //cout << \"L = \" << L << endl;\n\t      continue;\n\t    }\n\t  double minArg = inf;\n\t  double minDist = inf;\n\t  int minpos = -inf;\n\t  rep(i,n)\n\t    {\n\t      if(used[i])continue;\n\t      //cout << \"cur1(\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t      //cout << \"cur2(\" << cur2.x << \",\" << cur2.y << \")\" << endl;\n\t      //cout << \"ps[\"<<i<<\"](\" << ps[i].x << \",\" << ps[i].y << \")\" << endl;\n\n\t      double arg = getArgV2(cur1-cur2,ps[i]-cur1);\n\n\t      //cout << arg*180/M_PI << \" ::: \" << endl;\n\t      if(!equals(arg,minArg) && arg < minArg)\n\t\t{\n\t\t  minpos = i;\n\t\t  minArg = arg;\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t}\n\t      if(equals(arg,minArg) && sqrt(norm(cur1-ps[minpos])) > sqrt(norm(cur1-ps[i])))\n\t\t{\n\t\t  minDist = sqrt(norm(cur1-ps[i]));\n\t\t  minpos = i;\n\t\t\n\t\t}\n\n\t    }\n\t  //cout << \"cur1 (\" << cur1.x << \",\" << cur1.y << \")\" << endl;\n\t  //cout << \"phase #\" << _ << \" \" << minpos << \"(\" << ps[minpos].x << \",\" << ps[minpos].y << \")\" << endl;\n\t  //cout << \"that arg is \" << minArg*180/M_PI << endl;\n\n\t  assert(minpos != -inf);\n\t  used[minpos] = true;\n\t  L += sqrt(norm(cur1-ps[minpos]));\n\t  cur2 = cur1;\n\t  cur1 = ps[minpos];\n\n\t  //cout << \"L = \" << L << endl << endl;\n\t}\n      //L *= 10.0;\n      //L = round(L);\n      //L /= 10.0;\n      //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n      printf(\"%.1f\\n\",L);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define MAX_N 400\n#define INF 1e9\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Point np(0,0);\n    Vector v(0,1);\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> p[i];\n    }\n    double res = 0;\n    bool visited[MAX_N] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int idx = -1;\n      double min = INF,d = INF;\n      for(int j = 0 ; j < N ; j++){\n        if(visited[j]){ continue; }\n        Vector v2 = p[j]-np;\n        double angle = acos(dot(v,v2)/(abs(v)*abs(v2)));\n        if(lt(angle,min)){\n          d = dist(np,p[j]);\n          min = angle;\n          idx = j;\n        }else if(equal(angle,min)){\n          if(lt(dist(np,p[j]),d)){\n            d = dist(np,p[j]);\n            min = angle;\n            idx = j;\n          }\n        }\n      }\n      visited[idx] = true;\n      res += dist(np,p[idx]);\n      v = p[idx]-np;\n      np = p[idx];\n    }\n    printf(\"%.10f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a) * b);\n}\n\ndouble adjust(double theta) {\n  while(theta<0)\n    theta += 2*M_PI;\n  \n  while(theta>=2*M_PI)\n    theta -= 2*M_PI;\n  \n  return theta;\n}\n\ndouble calcAng(const P& a, const P& b) {\n  return adjust( acos( dot(a, b) / ( sqrt( norm(a) ) * sqrt( norm(b) ) ) ) );\n}\n\n#define equals(a, b) fabs((a) - (b)) < EPS\n\nint main() {\n  int n;\n  \n  while(cin >> n && n) {\n    vector<P> p(n);\n    vector<bool> used(n);\n    P orient = P(0, 1);  // テヲツ鳴ケテ・ツ青妥」ツδ凖」ツつッテ」ツδ暗」ツδォ\n    P curr = P(0, 0);    // テァツ渉セテ・ツ慊ィテ、ツスツ催ァツスツョ\n    \n    for(int i=0; i<n; i++) {\n      double x, y;\n      cin >> x >> y;\n      p[i] = P(x, y);\n    }\n    \n    double ans = 0.0;\n    \n    while(1) {\n      int next = -1;\n      double angle = 10;\n      double len = 10e9;\n      \n      // different angle\n      for(int i=0; i<n; i++) {\n\tif(!used[i]) {\n\t  double tmp = calcAng(orient, p[i]-curr);\n\t  double lentmp = sqrt(norm(p[i]-curr));\n\t  if( angle > tmp || ( equals(angle, tmp) && len > lentmp ) ) {\n\t    angle = tmp;\n\t    next = i;\n\t    len = lentmp;\n\t  }\n\t}\n      }\n      \n      \n      if(next == -1) break;\n\n      used[next] = true;\n      ans += sqrt(norm(p[next] - curr));\n      orient = p[next] - curr;\n      curr = p[next];\n    }\n    printf(\"%.1f\\n\", round(ans*10)/10.0);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<sstream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define F first\n#define S second\n#define all(n) (n).begin(),(n).end()\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point\n{\n  double x,y;\n  int index;\n  Point(double x=-inf,double y=-inf):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double p){return Point(x*p,y*p);}\n\n  bool operator < (const Point& p)const\n  {\n    return !equals(x,p.x)?x < p.x:y < p.y;\n  }\n  bool operator == (const Point &p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1=Point(-inf,-inf),Point p2=Point(-inf,-inf)):p1(p1),p2(p2){}\n};\n\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) <-EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool PointEquals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon andrewScan(Polygon s,Point now)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n  sort(all(s));\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  REP(i,2,s.size())\n    {\n      for(int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  u.pop_back();\n\t}\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  l.pop_back();\n\t}\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  reverse(l.begin(),l.end());\n\n  /*\n  cout << \"in andrew, raw data\" << endl;\n  rep(i,l.size())cout << \"(\" << l[i].x << \",\" << l[i].y << \")\" << endl;\n  cout << endl;\n  */\n  vector<Point> ret;\n\n  bool f = false;\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = true;\n      if(f == false)continue;\n      ret.push_back(l[i]);\n      rep(j,s.size())\n\t{\n\t  if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n\t  if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n\t}\n    }\n\n  rep(i,l.size())\n    {\n      if(l[i].index == now.index)f = false;\n      if(f == false)break;\n      ret.push_back(l[i]);\n\n      rep(j,s.size())\n\t{\n\t  if(s[j].index == l[i].index || s[j].index == l[(i+1)%l.size()].index)continue;\n\t  if(getDistanceSP(Segment(l[i],l[(i+1)%l.size()]),s[j]) == ON_SEGMENT)ret.push_back(s[j]);\n\t}\n\n    }\n\n\n  return ret;\n}\n\n\nint n;\nvector<Point> input;\n\nvoid inputt()\n{\n  input.clear();\n  input.resize(n);\n  rep(i,n)\n    {\n      cin >> input[i].x >> input[i].y;\n      input[i].index = i; \n    }\n\n}\n \nvoid solve()\n{\n  bool used[n];\n  rep(i,n)used[i] = false;\n  double L = 0;\n  Point now = Point(0,0); \n  now.index = -1; \n  while(true)\n    {\n      vector<Point> vec;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  vec.push_back(input[i]);\n\t}\n\n      if(vec.empty())break;\n\n      vec.push_back(now);\n      /*\n      rep(i,vec.size())\n\t  cout << \"$(\" << vec[i].x << \",\" << vec[i].y << \")\" << endl;\n      cout << endl;\n      */\n      vec = andrewScan(vec,now);\n\n      rep(i,vec.size())\n\t{\n\t      rep(k,n)\n\t\t{\n\t\t  if(used[k])continue;\n\t\t  if(input[k].index == vec[i].index || input[k].index == vec[(i+1)%vec.size()].index)continue;\n\t\t  if(equals(getDistanceSP(Segment(vec[i],vec[(i+1)%vec.size()]),input[k]),0))\n\t\t    {\n\t\t      //cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") and (\" << vec[(i+1)%vec.size()].x << \",\" << vec[(i+1)%vec.size()].y << \")  --- > (\" << input[k].x << \",\" << input[k].y << \")\" << endl;  \n\t\t      used[k] = true;\n\t\t  }\n\t\t  \n\t\t}\n\t}\n      /*\n      cout << \"remain \" << endl;\n      rep(i,n)\n\t{\n\t  if(used[i])continue;\n\t  cout << input[i].x << \",\" << input[i].y << endl;\n\t}\n      cout << endl;\n      */\n      /*\n      cout << \"after andrew, \" << endl;\n      rep(i,vec.size())\n\t{\n\t  cout << \"(\" << vec[i].x << \",\" << vec[i].y << \") \" << vec[i].index << endl;\n\t}\n      cout << endl;\n      */\n      rep(i,vec.size()-1)\n\t{\n\t  if(!PointEquals(vec[i],vec[i+1]))\n\t    L += sqrt(pow(vec[i].x-vec[i+1].x,2)+pow(vec[i].y-vec[i+1].y,2));\n\t  if(vec[i].index == -1)continue;\n\t  used[vec[i].index] = true;\n\t}\n      now = vec[vec.size()-1];\n    }\n\n  L *= 10.0;\n  L = round(L);\n  L /= 10.0;\n  printf(\"%.1f\\n\",L);\n  //cout << setiosflags(ios::fixed) << setprecision(1) << L << endl;\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      inputt();\n      solve();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nconst int MAXN = 401;\n\nint N;\nP ps[MAXN];\nbool used[MAXN];\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    fill(used, used+MAXN, false);\n    P s(0,-1);\n    P t(0,0);\n    double sum = 0;\n    for(int tc = 0; tc < N; ++tc) {\n      int j = -1;\n      for(int i = 0; i < N; ++i) {\n        if(used[i]) continue;\n        if(j == -1) {\n          j = i; continue;\n        }\n        P p = ps[i];\n        P q = ps[j];\n        if(cross(t-s,p-s) > 0.0) continue;\n        if(cross(q-t,p-t) > 0.0 ||\n           cross(q-t,p-t) == 0.0 && norm(q-t) > norm(p-t)) {\n          j = i;\n        }\n      }\n      used[j] = true;\n      P u = ps[j];\n      sum += abs(u-t);\n      s = t;\n      t = u;\n    }\n    printf(\"%.1f\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iterator>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin>>n) {\n        vector<complex<float>> vs;\n        complex<float> next_point, last_vector;\n        next_point = complex<float>(500, 0);\n        float min = 10.0f;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            vs.push_back(complex<float>(y, x));\n            if (arg(complex<float>(y,x)) < min || (arg(complex<float>(y,x)) == min && abs(complex<float>(y,x)) < abs(next_point)))\n                {next_point = complex<float>(y, x); min = arg(next_point);}\n        }\n        cout<<next_point<<endl;\n        float length = abs(next_point);\n        auto last_point = last_vector = next_point;\n        vs.erase(find(begin(vs), end(vs), next_point));\n        for (int i = 1; i < n; i++) {\n            next_point = complex<float>(500,0);\n            auto _it = begin(vs);\n            float max = -abs(last_vector);\n            for (auto it = begin(vs); it != end(vs); it++) {\n                float temp = ((*it - last_point) * conj(last_vector)).real() / abs(*it - last_point);\n                if (temp > max) {max = temp; _it = it;}\n            }\n            next_point = *_it;\n            cout<<next_point<<endl;\n            vs.erase(_it);\n            last_vector = next_point - last_point;\n            length += abs(last_vector);\n            last_point = next_point;\n        }\n        cout<<fixed<<setprecision(1)<<length<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    //double cosn=dot(a,b)/(abs(a)*abs(b));\n    //double sinn=cross(a,b);\n    //double angle=acos(cosn);\n    //if(sinn>0||EQ(sinn,0))\n    //    return angle;\n    //return 2*PI-angle;\n    double angle=atan2(cross(a,b)/(abs(a)*abs(b)),dot(a,b)/(abs(a)*abs(b)));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef complex<double> P;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tP p[n],dir=P(0,1);\n\t\trep(i,n)cin>>p[i].real()>>p[i].imag();\n\t\t\n\t\tint nuse=0,used[n]; rep(i,n)used[i]=0;\n\t\tdouble ans=0; P now=P(0,0);\n\t\t\n\t\twhile(nuse<n){\n\t\t\tdouble ang=1e9,tang; int mini;\n\t\t\trep(i,n)if(!used[i]){\n\t\t\t\ttang=arg(dir/(p[i]-now));\n\t\t\t\tif(tang<0)tang+=atan(1)*8;\n\t\t\t\tif(ang>tang||abs(ang-tang)<1e-8&&abs(p[mini]-now)>abs(p[i]-now))mini=i,ang=tang;\n\t\t\t}\n\t\t\tdir=p[mini]-now;\n\t\t\tans+=abs(dir);\n\t\t\tnow=p[mini];\n\t\t\tused[mini]=1;nuse++;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int PI = 3.141593;\n\nbool eq(double a, double b){\n    return ( a-b < 0.002 && a-b > -0.002 );\n}\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n    int n;\n    double x[400], y[400];\n    while( true ){\n        scanf(\" %d\", &n);\n        if( !n ) break;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf %lf\", x+i, y+i);\n        }\n        double cx = 0, cy = 0, cang = atan2(0,-1);\n        double lv,ld, sum = 0.0;\n        int ln;\n        for(int i = 0; i < n; i++){\n            lv = 100, ld = 1000;\n            for(int j = 0; j < n; j++){\n                if( x[j] < 0 ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ||\n                    ( eq(ang, lv) && dist(cx, cy, x[j],y[j]) < ld ) ){\n                    lv = ang; ln = j;\n                    ld = dist(cx, cy, x[j], y[j]);\n                }\n            }\n            sum += ld;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            x[ln] = -1;\n        }\n        printf(\"%.1f\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n#define eq(a,b) (fabs(a-b)<EPS)\n#define eqv(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\n\ntypedef complex<double> P;\n\nbool used[401];\nchar c;\nint n;\ndouble x,y;\nP p[401];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+401,0);\n\t\tint m=0;\n\t\tp[0]=P(0.0,0.0);\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tp[i+1]=P(x,y);\n\t\t}\n\t\tdouble ans=0.0;\n\t\tP v(0.0,1.0);\n\t\trep(h,n){\n\t\t\tused[m]=1;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n+1)if(!used[i]&&(dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M+EPS||\n\t\t\t\teq(dot(v,(p[i]-p[m])/abs(p[i]-p[m])),M)&&abs(p[i]-p[m])<abs(p[nx]-p[m]))){/*cout<<p[i]<<\" \"<<abs(p[i]-p[m])<<endl;*/M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<\" \"<<abs(p[nx]-p[m])<<endl;\n\t\t\tans+=abs(p[nx]-p[m]);\n\t\t\tm=nx;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n#define eq(a,b) (fabs(a-b)<EPS)\n#define eqv(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\n\ntypedef complex<double> P;\n\nbool used[401];\nchar c;\nint n;\ndouble x,y;\nP p[401];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+401,0);\n\t\tint m=0;\n\t\tp[0]=P(0.0,0.0);\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tp[i+1]=P(x,y);\n\t\t}\n\t\tdouble ans=0.0;\n\t\tP v(0.0,1.0);\n\t\trep(h,n){\n\t\t\tused[m]=1;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n+1)if(i!=m&&!used[i]&&(dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M||eq(dot(v,(p[i]-p[m])/abs(p[i]-p[m])),M)&&abs(p[i]-p[m])<abs(p[nx]-p[m]))){M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<\" \"<<abs(p[nx]-p[m])<<endl;\n\t\t\tans+=abs(p[nx]-p[m]);\n\t\t\tused[nx]=1;\n\t\t\tm=nx;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#define ll long long\nusing namespace std;\nstruct POINT\n{\n    double x,y;\n    POINT(double a=0,double b=0) {x=a;y=b;}\n    //POINT(POINT & t) {x=t.x;y=t.y;}\n};\nstruct LINESEG\n{\n    POINT s,e;\n    LINESEG(POINT a,POINT b) {s=a;e=b;}\n    LINESEG() {}\n};\ndouble dist(POINT p1,POINT p2)                // 返回?点之?欧氏距?\n{\n    return( sqrt( (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y) ) );\n}\ndouble angle(POINT o,POINT s,POINT e)\n{\n    double cosfi,fi,norm;\n    double dsx = s.x - o.x;\n    double dsy = s.y - o.y;\n    double dex = e.x - o.x;\n    double dey = e.y - o.y;\n    cosfi=dsx*dex+dsy*dey;\n    norm=(dsx*dsx+dsy*dsy)*(dex*dex+dey*dey);\n    cosfi /= sqrt( norm );\n    if (cosfi >=  1.0 ) return 0;\n    if (cosfi <= -1.0 ) return -3.1415926;\n    fi=acos(cosfi);\n    if(dsx*dey-dsy*dex>0) return fi;      // ?明矢量os 在矢量 oe的???方向\n    return -fi;\n}\ndouble Isangle(LINESEG l1,LINESEG l2)\n{\n    POINT o,s,e;\n    o.x=o.y=0;\n    s.x=l1.e.x-l1.s.x;\n    s.y=l1.e.y-l1.s.y;\n    e.x=l2.e.x-l2.s.x;\n    e.y=l2.e.y-l2.s.y;\n    return angle(o,s,e);\n\n}\ndouble cosine(LINESEG l1,LINESEG l2)\n{\n    return (((l1.e.x-l1.s.x)*(l2.e.x-l2.s.x) +(l1.e.y-l1.s.y)*(l2.e.y-l2.s.y))/(dist(l1.e,l1.s)*dist(l2.e,l2.s))) ;\n}\nint vis[450];\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int n;\n    double x,y;\n    while(scanf(\"%d\",&n)&&n)\n    {\n        memset(vis,0,sizeof vis);\n        POINT Set[450];\n        double ans=0;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf\",&x,&y);\n            Set[i].x=x;\n            Set[i].y=y;\n        }\n        POINT ca(0,0);\n        POINT cb(0,0);\n        POINT cc(0,1);\n        LINESEG cl(ca,cc);\n\n        for(int i=0;i<n;i++)\n        {\n            double minn=9999;\n            int tt=0;\n            for(int j=0;j<n;j++)\n            {\n                if(vis[j]) continue;\n                LINESEG ct(cb,Set[j]);\n                double tan=acos(cosine(cl,ct));\n                if(tan<minn)\n                {\n                    minn=tan;\n                    tt=j;\n                }\n                else if(tan==minn)\n                {\n                    if(dist(cb,Set[j])<=dist(cb,Set[tt]))\n                    {\n                        tt=j;\n                    }\n                }\n            }\n            vis[tt]=1;\n            ans+=dist(cb,Set[tt]);\n            //cout<<dist(cb,Set[tt])<<\" \"<<cb.x<<\" \"<<cb.y<<\" \"<<Set[tt].x<<\" \"<<Set[tt].y<<endl;\n            ca=POINT(cb.x,cb.y);\n            cb=POINT(Set[tt].x,Set[tt].y);\n            cl=LINESEG(ca,cb);\n\n        }\n        printf(\"%.1f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n);\n    for(int i=0;i<n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[401];\n    point prev=point(0,-1),now=point(0,0);\n    int nowID=-1;\n\n    fill(fg,fg+401,false);\n\n    for(int i=0;i<v.size();i++){\n      if(nowID>=0)fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=0;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = 100000.0;\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle <= 0.0 + EPS){\n\t\t\t\t\tif(abs(angle) < abs(minv)){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tminv = angle;\t\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\t//dist *= 10.0;\n\t\t//dist = floor(dist);\n\t\t//dist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\nlong double EPS = 1e-10;\n\nlong double add(long double a, long double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  long double x, y;\n  point(){}\n  point(long double x,long double y) : x(x) , y(y){}\n\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nlong double dist(point a,point b){return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n \nlong double getAngle(point  A,point B,point C){\n  long double a = sqrt(pow(B.x-C.x,2)+pow(B.y-C.y,2));\n  long double b = sqrt(pow(A.x-C.x,2)+pow(A.y-C.y,2));\n  long double c = sqrt(pow(B.x-A.x,2)+pow(B.y-A.y,2));\n  return acos((a*a+c*c-b*b)/(2.0*a*c));\n}\n \nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>v(n+1);\n    v[0].x=v[0].y=0.0;\n    for(int i=1;i<=n;i++)cin >> v[i].x >> v[i].y;\n\n    long double sum=0;\n    bool fg[501];\n    point prev=point(0,-1),now=v[0];\n    int nowID=0;\n\n    fill(fg,fg+501,false);\n\n    for(int i=1;i<v.size();i++){\n      fg[nowID]=true;\n      double angle=0;\n      int id=0;\n      for(int j=1;j<v.size();j++){\n\tif(fg[j])continue;\n\tif(-EPS>angle-getAngle(prev,now,v[j])){\n\t  id=j,angle=getAngle(prev,now,v[j]);\n\t}\n\telse if(abs(getAngle(prev,now,v[j])-angle)<EPS){\n\t  if(dist(now,v[j])-dist(now,v[id])<-EPS){\n\t    id=j,angle=getAngle(prev,now,v[j]);\n\t  }\n\t}\n      }\n\tsum+=dist(now,v[id]);\n\tprev=now,now=v[id],nowID=id;\n    }\n\n    printf(\"%.1LLf\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \ntypedef vector<pii> vp;\n \ndouble to_rad(int angle){\n    return angle*PI*2/360;\n}\n \ndouble dist(pii l,pii r){\n    return sqrt(pow((double)l.second-r.second,2)+pow((double)l.first-r.first,2));\n}\n#define GT(a,b) ((a)>(b)+EPS)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vp coords;\n        coords.push_back(make_pair(0,0));\n        REP(i,n){\n            int x,y;\n            cin>>x>>y;\n            coords.push_back(make_pair(x,y));\n        }\n \n        double res=0;\n        int cur_index=0;\n        double runner_angle=to_rad(90);\n        while(coords.size()>1){\n            pii cur=coords[cur_index];\n            coords.erase(coords.begin()+cur_index,coords.begin()+cur_index+1);\n            int best_index=0;\n            double best_angle=1000;\n            REP(j,coords.size()){\n                double angle=runner_angle-atan2((double)(coords[j].second-cur.second),coords[j].first-cur.first);\n                if(0>angle){\n                    angle+=to_rad(360);\n                }\n                if(GT(best_angle,angle)||(EQ(angle,best_angle)&&(GT(dist(cur,coords[best_index]),dist(cur,coords[j]))))){\n                    best_index=j;\n                    best_angle=angle;\n                }\n            }\n            res+=dist(cur,coords[best_index]);\n            cur_index=best_index;\n            runner_angle+=best_angle;\n            if(runner_angle>360){\n                runner_angle-=to_rad(360);\n            }\n        }\n \n        printf(\"%.1f\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nstruct argcomp{\n\tP p;\n\tbool operator()(const P &a, const P &b){\n\t\treturn cross(a-p, b-p) < 0;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\tVP p(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = P(x, y);\n\t\t}\n\n\t\tP curr = P(0, 0);\n\t\targcomp comp;\n\t\tdouble ans = 0;\n\t\twhile(!p.empty()){\n\t\t\tcomp.p = curr;\n\t\t\tsort(p.begin(), p.end(), comp);\n\t\t\tP next = p[0];\n\t\t\tint lim = 1;\n\t\t\tfor(int i=1; i<(int)p.size(); i++){\n\t\t\t\tif(abs(cross(next -curr, p[i] -curr)) < EPS){\n\t\t\t\t\tlim++;\n\t\t\t\t\tif(abs(p[i] -curr) > abs(next -curr)){\n\t\t\t\t\t\tnext = p[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.erase(p.begin(), p.begin() +lim);\n\t\t\tans += abs(next -curr);\n\t\t\tcurr = next;\n\t\t}\n\t\tcout << fixed << setprecision(1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Pos{\npublic:\n\tint x;\n\tint y;\n\tPos(int _x,int _y) : x(_x),y(_y){}\t\n};\n\nbool used[500];\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(used,0,sizeof(used));\n\t\tvector<Pos> flags;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tflags.push_back(Pos(x,y));\n\t\t}\n\n\n\t\tdouble dist = 0.0;\n\t\tPos mdir(0,1);\n\t\tPos prev(0,0);\n\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tdouble minv = 100.0;\n\t\t\tint next = -1;\n\n\t\t\tdouble lineDist = numeric_limits<double>::max();\n\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tint line_dirx = flags[j].x-prev.x;\n\t\t\t\tint line_diry = flags[j].y-prev.y;\n\n\t\t\t\tdouble tmpDist = sqrt((double)(flags[j].x-prev.x)*(flags[j].x-prev.x) \n\t\t\t\t+ (double)(flags[j].y-prev.y)*(flags[j].y-prev.y));\n\n\t\t\t\tdouble na = sqrt((double)mdir.x*mdir.x+(double)mdir.y*mdir.y);\n\t\t\t\tdouble nb = sqrt((double)line_dirx*line_dirx+(double)line_diry*line_diry);\n\n\t\t\t\tdouble ab = mdir.x*line_dirx + mdir.y*line_diry;\n\t\t\t\tdouble axb = mdir.x*line_diry - mdir.y*line_dirx;\n  \n\t\t\t\tdouble angle = atan2(axb,ab);\n\n\t\t\t\tif(angle <= 0.0 + EPS){\n\t\t\t\t\tif(abs(angle) < abs(minv)){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tminv = angle;\t\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(minv - EPS < angle && angle < minv + EPS){\n\t\t\t\t\tif(tmpDist < lineDist){\n\t\t\t\t\t\tnext = j;\n\t\t\t\t\t\tlineDist = tmpDist;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(next==-1) break;\n\n\t\t\tdist += sqrt((double)(flags[next].x-prev.x)*(flags[next].x-prev.x) \n\t\t\t\t+ (double)(flags[next].y-prev.y)*(flags[next].y-prev.y));\n\t\t\tmdir = Pos(flags[next].x-prev.x,flags[next].y-prev.y);\n\n\t\t\tprev = Pos(flags[next].x,flags[next].y);\t\t\n\t\t\tused[next] = true;\n\t\t}\n\t\t//dist *= 10.0;\n\t\t//dist = floor(dist);\n\t\t//dist /= 10;\n\t\tprintf(\"%.1lf\\n\",dist);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double PI=4*atan(1.0);\ntypedef complex<double> P;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a©çbÖ¶üèÅ½x©\ndouble diffAngle(P a,P b){\n  // cos>0&&sin>0 -> 0 -> 90\n  // cos<0&&sin>0 -> 90->180\n  // cos<0&&sin<0 -> 180->270\n  // cos>0&&sin<0 -> 270 -> 359\n    //double cosn=dot(a,b)/(abs(a)*abs(b));\n    //double sinn=cross(a,b);\n    //double angle=acos(cosn);\n    //if(sinn>0||EQ(sinn,0))\n    //    return angle;\n    //return 2*PI-angle;\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n//    return 0;\n    return angle;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<P> points;\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            points.push_back(P(x,y));\n        }\n        vector<bool> isUsed(points.size(),false);\n        double sum=0;\n        P cp=P(0,1);\n        P pp=P(0,0);\n        int cnt=n;\n        while(cnt--){\n            int idx=-1;\n            double minAngle=100000000;\n            for(int i = 0; i < points.size(); i++){\n                if(isUsed[i]) continue;\n                double ca=diffAngle(points[i]-pp,cp);\n                //cout<<ca<<endl;\n                if(EQ(minAngle,ca)){\n                    if(abs(points[idx]-pp)>abs(points[i]-pp))\n                        idx=i;\n                }\n                else if(minAngle>ca){\n                    idx=i;\n                    minAngle=ca;\n                }\n            }\n            isUsed[idx]=true;\n            double inc=abs(points[idx]-pp);\n            sum+=inc;\n            P p=(points[idx]-pp);\n            cp=p/abs(p);\n            pp=points[idx];\n        }\n        printf(\"%.1f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nbool used[401];\nchar c;\nint n;\ndouble x,y;\nP p[401];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+401,0);\n\t\tint m=0;\n\t\tp[0]=P(0.0,0.0);\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tp[i+1]=P(x,y);\n\t\t}\n\t\tdouble ans=0.0;\n\t\tP v(0.0,1.0);\n\t\trep(h,n){\n\t\t\tused[m]=1;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n+1)if(i!=m&&!used[i]&&(dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M||fabs(dot(v,(p[i]-p[m])/abs(p[i]-p[m]))-M)<EPS&&abs(p[i]-p[m])<abs(p[nx]-p[m]))){M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<\" \"<<abs(p[nx]-p[m])<<endl;\n\t\t\tans+=abs(p[nx]-p[m]);\n\t\t\tused[nx]=1;\n\t\t\tm=nx;\n\t\t}\n\t\tprintf(\"%.1f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1107\nTitle Spiral Footrace\n13/5/30 WA\n*/\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n#include <limits.h>\n#define PAI (3.141592653589793)\n#define RAD2DEG (180/PAI)\n//Global data section\n#define MAXFLAG 400\nint flx[MAXFLAG],fly[MAXFLAG],useflag[MAXFLAG];\nint n;\n//\ndouble angle360(double x,double y)\n{\n        double q;\n\n        \n\n        //printf(\"a2p xy=%d %d\\n\",x,y);\n        if(x==0)\n        {\n                if(y>=0)\n                        return(90.0);\n                else\n                        return(270.0);\n        }\n        if(y==0)\n        {\n                if(x>0)\n                        return(0.0);\n                else\n                        return(180.0);\n        }\n        else\n        {\n                q=y/x;\n\n                if(x>0 && y > 0)\n                        return(atan(q)*RAD2DEG);\n                else if(x < 0 && y > 0)\n                        return(180+atan(q)*RAD2DEG);\n                else if(x < 0 && y < 0)\n                        return(180+atan(q)*RAD2DEG);\n                else \n                        return(360+atan(q)*RAD2DEG);\n        }\n}\ndouble angle_diff360(double dir,double dir2)\n{\n        double d;\n        d = dir-dir2;\n        if(d<0.0)\n                d+=360.0;\n        return(d);\n\n}\nvoid nextpoint(int x,int y,double dir,int *xn,int *yn,double * dirn)\n{\n        int i;\n        int minx, miny, minn;\n        double mind,dir2,dir_diff,dir22;\n\n        mind=999;minx=INT_MAX;miny=INT_MAX;minn=-1;\n        for(i=0;i<n;i++)\n        {\n                if(useflag[i])\n                        continue;\n                dir2=angle360((double)(flx[i]-x),(double)(fly[i]-y));\n\n                dir_diff=angle_diff360(dir,dir2);\n#ifdef DEBUG2\n                printf(\"%d %d %d %d %lf %lf\\n\",x,y,flx[i],fly[i],dir2,dir_diff);\n#endif\n                if(mind > dir_diff)\n                {\n                        minn=i;\n                        minx=flx[i];\n                        miny=fly[i];\n                        mind=dir_diff;\n                        dir22=dir2;   //save last direction\n                }\n        }\n#ifdef DEBUG\n        printf(\"xy=%d %d (%lf)\\n\",minx,miny,dir22);\n#endif\n                                useflag[minn]=-1;\n                                *xn=minx,*yn=miny;*dirn=dir22;\n}\ndouble total_spiral_len()\n{\n        int i;\n        int x,y,xn,yn;\n        double dir,dirn;\n        double total_len;\n\n        total_len=0.0;\n        dir=90.0;  //north pai/2 rad.\n        x=0;y=0;\n\n        for(i=0;i<n;i++)\n        {\n                nextpoint(x,y,dir,&xn,&yn,&dirn);\n                total_len+=sqrt((double)((x-xn)*(x-xn)+(y-yn)*(y-yn)));\n                x=xn;y=yn;dir=dirn;\n        }\n        return(total_len);\n}\nmain()\n{\n        double len;\n        int i;\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&flx[i],&fly[i]);\n                        useflag[i]=0;\n                }\n\n                len=total_spiral_len();\n\n                printf(\"%.1lf\\n\",len);\n        }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ntypedef struct{\n  double x;\n  double y;\n  double rad;\n}point;\n\nint main(){\n  int i,n;\n  int x,y,nxt,psize,j;\n  point ps[400];\n  double d,min,dist,nx,ny;\n  do{\n    d=atan2(1.0,0.0);\n    scanf(\"%d\",&n);\n    if(!n) break;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d\",&x,&y);\n      ps[i].x=(double)x;\n      ps[i].y=(double)y;\n      ps[i].rad=d-atan2(ps[i].y,ps[i].x);\n    }\n    for(i=0,psize=n,dist=0.0,nx=0.0,ny=0.0;i<n;i++){\n      for(j=1,nxt=0,min=ps[0].rad;j<psize;j++){\n\tif(ps[j].rad<min){\n\t  min=ps[j].rad;\n\t  nxt=j;\n\t}\n      }\n      dist+=sqrt((ps[nxt].x-nx)*(ps[nxt].x-nx)+\n\t\t (ps[nxt].y-ny)*(ps[nxt].y-ny));\n      d=atan2(ps[nxt].y-ny,ps[nxt].x-nx);\n      nx=ps[nxt].x;\n      ny=ps[nxt].y;\n      for(j=0;j<psize;j++){\n\tps[j].rad=d-atan2(ps[j].y-ny,ps[j].x-nx);\n\tif(ps[j].rad<0) ps[j].rad+=2*M_PI;\n      }\n      for(j=nxt+1;j<psize;j++){\n\tps[j-1]=ps[j];\n      }\n      psize--;\n    }\n    printf(\"%.1lf\\n\",dist);\n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,j,ax,ay,bx,by,a,b,c,d,x[400],y[400],mi;\n  double s,max,m;\n  while(scanf(\"%d\",&n),n){\n    for(i=ax=by=bx=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n    ay=-1;\n    int f[400]={0};\n    for(i=s=0;i<n;i++){\n      for(j=max=0;j<n;j++){\n\tif(f[j])continue;\n\ta=bx-ax;\n\tb=by-ay;\n\tc=x[j]-bx;\n\td=y[j]-by;\n\tm=(a*c+b*d)/hypot(a,b)/hypot(c,d);\n\tif(a*d>b*c)m=1-m;\n\telse       m+=3;\n\tif(fabs(max-m)<0.00000001){\n\t  if(hypot(x[mi]-bx,y[mi]-by)>hypot(x[j]-bx,y[j]-by))mi=j;\n\t}\n\tif(max<m){\n\t  max=m;\n\t  mi=j;\n\t}\n      }\n      f[mi]=1;\n      ax=bx;\n      ay=by;\n      bx=x[mi];\n      by=y[mi];//printf(\"%d %d\\n\",bx,by);\n      s+=hypot(bx-ax,by-ay);  \n    }\n    printf(\"%.1f\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nstruct cdnt{       //coordinate structure\n  int x;\n  int y;\n}*flag,now,pre,min={1000,1000};\n\nint main(void){\n  int n,i,j,mnum,*check;\n  double sum,d,md,l,plen,mlen;\n  while(scanf(\"%d\",&n)&&n!=0){\n    sum=0;\n    plen=1;\n    flag=(struct cdnt *)calloc(n,sizeof(struct cdnt));\n    check=(int *)calloc(n,sizeof(int));\n    for(i=0;i<n;i++) scanf(\"%d %d\",&flag[i].x,&flag[i].y);\n    now.x=0;\n    now.y=0;\n    for(i=0;i<n;i++){\n      md=-10;\n      mlen=750;\n      //printf(\"now:%d %d\\n\",now.x,now.y);\n      //printf(\"pre:%d %d\\n\",pre.x,pre.y);\n      for(j=0;j<n;j++){\n\tif(check[j]>0) continue;\n\tif(i==0){\n\t  d=flag[j].y;\n\t  l=sqrt(flag[j].x*flag[j].x+flag[j].y*flag[j].y);\n\t  //printf(\"%d :%f %f\\n\",j,d,l);\n\t}else{\n\t  d=(flag[j].x-now.x)*(now.x-pre.x)+(flag[j].y-now.y)*(now.y-pre.y);\n\t  l=sqrt(((double)flag[j].x-now.x)*((double)flag[j].x-now.x)+((double)flag[j].y-now.y)*((double)flag[j].y-now.y))*plen;\n\t  //printf(\"%d :%f %f %f\\n\",j,d,l/plen,l);\n\t}\n\t//puts(\"d/l\");\n\td/=l;\n\t//printf(\"%d:%f md:%f\\n\",j,d,md);\n\tif(md<d){\n\t  //puts(\"modify\");\n\t  mnum=j;\n\t  md=d;\n\t  mlen=l;\n\t}else if(md==d){\n\t  if(mlen>l){\n\t    mnum=j;\n\t    mlen=l;\n\t  }\n\t}\n\t//printf(\"md %d\\n\",md);\n      }\n      pre.x=now.x;\n      pre.y=now.y;\n      now.x=flag[mnum].x;\n      now.y=flag[mnum].y;\n      plen=mlen/plen;\n      sum+=plen;\n      check[mnum]++;\n      //printf(\"%f\\n\",plen);\n    }\n    printf(\"%.1f\\n\",sum);\n    free(check);\n    free(flag);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1107\nTitle Spiral Footrace\n13/5/30 WA\n*/\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n#include <limits.h>\n#define PAI (3.141592653589793)\n#define RAD2DEG (180/PAI)\n//Global data section\n#define MAXFLAG 400\nint flx[MAXFLAG],fly[MAXFLAG],useflag[MAXFLAG];\nint n;\n//\ndouble angle360(double x,double y)\n{\n        double q;\n\n        \n\n        //printf(\"a2p xy=%d %d\\n\",x,y);\n        if(x==0)\n        {\n                if(y>=0)\n                        return(90.0);\n                else\n                        return(270.0);\n        }\n        if(y==0)\n        {\n                if(x>0)\n                        return(0.0);\n                else\n                        return(180.0);\n        }\n        else\n        {\n                q=y/x;\n\n                if(x>0 && y > 0)\n                        return(atan(q)*RAD2DEG);\n                else if(x < 0 && y > 0)\n                        return(180+atan(q)*RAD2DEG);\n                else if(x < 0 && y < 0)\n                        return(180+atan(q)*RAD2DEG);\n                else \n                        return(360+atan(q)*RAD2DEG);\n        }\n}\ndouble angle_diff360(double dir,double dir2)\n{\n        double d;\n        d = dir-dir2;\n        if(d<0.0)\n                d+=360.0;\n        return(d);\n\n}\nvoid nextpoint(int x,int y,double dir,int *xn,int *yn,double * dirn)\n{\n        int i;\n        int minx, miny, minn;\n        double mind,minlen2,len2,dir2,dir_diff,dir22;\n\n        mind=999;minx=INT_MAX;miny=INT_MAX;minn=-1;minlen2=100000;\n        for(i=0;i<n;i++)\n        {\n                if(useflag[i])\n                        continue;\n                dir2=angle360((double)(flx[i]-x),(double)(fly[i]-y));\n\n                dir_diff=angle_diff360(dir,dir2);\n#ifdef DEBUG2\n                printf(\"%d %d %d %d %lf %lf\\n\",x,y,flx[i],fly[i],dir2,dir_diff);\n#endif\n                len2=(flx[i]-x)*(flx[i]-x)+(fly[i]-y)*(fly[i]-y);\n\n                if(mind > dir_diff ||(mind == dir_diff && minlen2 > len2))\n                {\n                        minn=i;\n                        minx=flx[i];\n                        miny=fly[i];\n                        mind=dir_diff;\n                        dir22=dir2;   //save last direction\n                        minlen2 = len2;\n                }\n        }\n#ifdef DEBUG\n        printf(\"xy=%d %d (%lf)\\n\",minx,miny,dir22);\n#endif\n                                useflag[minn]=-1;\n                                *xn=minx,*yn=miny;*dirn=dir22;\n}\ndouble total_spiral_len()\n{\n        int i;\n        int x,y,xn,yn;\n        double dir,dirn;\n        double total_len;\n\n        total_len=0.0;\n        dir=90.0;  //north pai/2 rad.\n        x=0;y=0;\n\n        for(i=0;i<n;i++)\n        {\n                nextpoint(x,y,dir,&xn,&yn,&dirn);\n                total_len+=sqrt((double)((x-xn)*(x-xn)+(y-yn)*(y-yn)));\n                x=xn;y=yn;dir=dirn;\n        }\n        return(total_len);\n}\nmain()\n{\n        double len;\n        int i;\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&flx[i],&fly[i]);\n                        useflag[i]=0;\n                }\n\n                len=total_spiral_len();\n\n                printf(\"%.1lf\\n\",len);\n        }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\ntypedef struct{\n  int x;\n  int y;\n}cdnt;\n\nconst double PI=atan(1.0)*4;\n\nint main(void){\n  cdnt p[400],pre,save;\n  short flg[400];\n  int n,i,j,inner,outer,det;\n  double mtheta,theta,mr,r,sum;\n  while(scanf(\"%d\",&n) && n){\n    memset(flg,0,sizeof(flg));\n    sum=0;\n    pre.x=0;\n    pre.y=1;\n    for(i=0;i<n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n    for(i=0;i<n;i++){\n      //printf(\"i:%d\\n\",i);\n      mtheta=10;\n      mr=4096;\n      det=0;\n      //printf(\"pre:(%d %d)\\n\",pre.x,pre.y);\n      for(j=0;j<n;j++){\n\tif(!flg[j]){\n\t  inner=pre.x*p[j].x+pre.y*p[j].y;\n\t  outer=pre.y*p[j].x-pre.x*p[j].y;\n\t  //printf(\"%d in:%d,out:%d\\t\",j,inner,outer);\n\t  theta=atan2(outer,inner);\n\t  r=hypot(p[j].x,p[j].y);\n\t  //printf(\"%d (%d %d),theta:%f,r:%f\\t\",j,p[j].x,p[j].y,theta,r);\n\t  //if(theta<0) theta=2*PI-theta;\n\t  if(theta<mtheta || (theta==mtheta && mr>r)){\n\t    mtheta=theta;\n\t    mr=r;\n\t    det=j;\n\t  }\n\t}\n\t//puts(\"ok\");\n      }\n      //puts(\"complete\");\n      //printf(\"det:%d\\n\",det);\n      flg[det]=1;\n      pre.x=p[det].x;\n      pre.y=p[det].y;\n      for(j=0;j<n;j++){\n\tp[j].x-=pre.x;\n\tp[j].y-=pre.y;\n      }\n      sum+=mr;\n    }\n    printf(\"%.1f\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1107\nTitle\n*/\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n#include <limits.h>\n#define PAI (3.141592653589793)\n#define RAD2DEG (180/PAI)\n//Global data section\n#define MAXFLAG 400\nint flx[MAXFLAG],fly[MAXFLAG],useflag[MAXFLAG];\nint n;\n//\ndouble angle360(double x,double y)\n{\n        double q;\n\n        \n\n        //printf(\"a2p xy=%d %d\\n\",x,y);\n        if(x==0)\n        {\n                if(y>=0)\n                        return(90.0);\n                else\n                        return(270.0);\n        }\n        else\n        {\n                q=y/x;\n\n                if(x>0 && y > 0)\n                        return(atan(q)*RAD2DEG);\n                else if(x < 0 && y > 0)\n                        return(180+atan(q)*RAD2DEG);\n                else if(x < 0 && y < 0)\n                        return(180+atan(q)*RAD2DEG);\n                else \n                        return(360+atan(q)*RAD2DEG);\n        }\n}\ndouble angle_diff360(double dir,double dir2)\n{\n        double d;\n        d = dir-dir2;\n        if(d<0.0)\n                d+=360.0;\n        return(d);\n\n}\nvoid nextpoint(int x,int y,double dir,int *xn,int *yn,double * dirn)\n{\n        int i;\n        int minx, miny, minn;\n        double mind,dir2,dir_diff,dir22;\n\n        mind=999;minx=INT_MAX;miny=INT_MAX;minn=-1;\n        for(i=0;i<n;i++)\n        {\n                if(useflag[i])\n                        continue;\n                dir2=angle360((double)(flx[i]-x),(double)(fly[i]-y));\n\n                dir_diff=angle_diff360(dir,dir2);\n#ifdef DEBUG2\n                printf(\"%d %d %d %d %lf %lf\\n\",x,y,flx[i],fly[i],dir2,dir_diff);\n#endif\n                if(mind > dir_diff)\n                {\n                        minn=i;\n                        minx=flx[i];\n                        miny=fly[i];\n                        mind=dir_diff;\n                        dir22=dir2;   //save last direction\n                }\n        }\n#ifdef DEBUG\n        printf(\"xy=%d %d (%lf)\\n\",minx,miny,dir22);\n#endif\n                                useflag[minn]=-1;\n                                *xn=minx,*yn=miny;*dirn=dir22;\n}\ndouble total_spiral_len()\n{\n        int i;\n        int x,y,xn,yn;\n        double dir,dirn;\n        double total_len;\n\n        total_len=0.0;\n        dir=90.0;  //north pai/2 rad.\n        x=0;y=0;\n\n        for(i=0;i<n;i++)\n        {\n                nextpoint(x,y,dir,&xn,&yn,&dirn);\n                total_len+=sqrt((double)((x-xn)*(x-xn)+(y-yn)*(y-yn)));\n                x=xn;y=yn;dir=dirn;\n        }\n        return(total_len);\n}\nmain()\n{\n        double len;\n        int i;\n\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                for(i=0;i<n;i++)\n                {\n                        scanf(\"%d %d\",&flx[i],&fly[i]);\n                        useflag[i]=0;\n                }\n\n                len=total_spiral_len();\n\n                printf(\"%.1lf\\n\",len);\n        }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,j,ax,ay,bx,by,a,b,c,d,x[400],y[400],mi;\n  double s,max,m;\n  while(scanf(\"%d\",&n),n){\n    for(i=ax=by=bx=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n    ay=-1;\n    int f[400]={0};\n    for(i=s=0;i<n;i++){\n      for(j=max=0;j<n;j++){\n\tif(f[j])continue;\n\ta=bx-ax;\n\tb=by-ay;\n\tc=x[j]-bx;\n\td=y[j]-by;\n\tm=(a*c+b*d)/hypot(a,b)/hypot(c,d);\n\tif(a*d>b*c)m=1-m;\n\telse       m+=3;\n\tif(max<m){\n\t  max=m;\n\t  mi=j;\n\t}\n      }\n      f[mi]=1;\n      ax=bx;\n      ay=by;\n      bx=x[mi];\n      by=y[mi];//printf(\"%d %d\\n\",bx,by);\n      s+=hypot(bx-ax,by-ay);  \n    }\n    printf(\"%.1f\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nstruct cdnt{       //coordinate structure\n  int x;\n  int y;\n}*flag,now,pre,min={1000,1000};\n\nint main(void){\n  int n,i,j,mnum,*check;\n  double sum,d,md,l,plen,mlen;\n  while(scanf(\"%d\",&n)&&n!=0){\n    sum=0;\n    plen=1;\n    flag=(struct cdnt *)calloc(n,sizeof(struct cdnt));\n    check=(int *)calloc(n,sizeof(int));\n    for(i=0;i<n;i++) scanf(\"%d %d\",&flag[i].x,&flag[i].y);\n    now.x=0;\n    now.y=0;\n    for(i=0;i<n;i++){\n      md=-10;\n      mlen=750;\n      //printf(\"now:%d %d\\n\",now.x,now.y);\n      //printf(\"pre:%d %d\\n\",pre.x,pre.y);\n      for(j=0;j<n;j++){\n\tif(check[j]>0) continue;\n\tif(i==0){\n\t  d=flag[j].y;\n\t  l=sqrt(flag[j].x*flag[j].x+flag[j].y*flag[j].y);\n\t  //printf(\"%d :%f %f\\n\",j,d,l);\n\t}else{\n\t  d=(flag[j].x-now.x)*(now.x-pre.x)+(flag[j].y-now.y)*(now.y-pre.y);\n\t  l=sqrt(((double)flag[j].x-now.x)*((double)flag[j].x-now.x)+((double)flag[j].y-now.y)*((double)flag[j].y-now.y))*plen;\n\t  //printf(\"%d :%f %f %f\\n\",j,d,l/plen,l);\n\t}\n\t//puts(\"d/l\");\n\td/=l;\n\t//printf(\"%d:%f md:%f\\n\",j,d,md);\n\tif(md<d){\n\t  //puts(\"modify\");\n\t  mnum=j;\n\t  md=d;\n\t  mlen=l;\n\t}else if(md==d){\n\t  if(mlen>l){\n\t    mnum=j;\n\t    mlen=l;\n\t  }\n\t}\n\t//printf(\"md %d\\n\",md);\n      }\n      pre.x=now.x;\n      pre.y=now.y;\n      now.x=flag[mnum].x;\n      now.y=flag[mnum].y;\n      plen=mlen/plen;\n      sum+=plen;\n      check[mnum]++;\n      //printf(\"%f\\n\",plen);\n    }\n    printf(\"%.1f\\n\",sum);\n    free(check);\n    free(flag);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define DEBUG 0\n\ndouble distance(int x,int y){\n  return sqrt( x*x+y*y );\n}\n\nint main(void){\n  int n;  // 1<= n <= 400\n  int fx[401],fy[401];\n  char flag[401];\n\n  char s1[50],s2[10];\n  int i,j,k;\n\n  int loop;\n  int look1,look2;\n\n  int x0,y0;\n  int dx,dy;\n  int min;\n  double minth,minr;\n  double th,r;\n\n  double ans;\n\n  while( 1 ){\n    scanf( \"%d \",&n );\n\n    if( DEBUG==1 )\n      printf(\"n=%d\\n\",n);\n \n    if( !n )\n      break;\n\n    fx[0]=0;fy[0]=0;\n    for( i=1;i<=n;i++ ){\n      fgets(s1,50,stdin);\n      for( j=0; s1[j]==' '||s1[j]=='\\t' ;j++ ) ;\n      for( k=0; '0'<=s1[j]&&s1[j]<='9' ;j++,k++ )\n\ts2[k]=s1[j];\n      s2[k] = '\\0';\n      sscanf(s2,\"%d \",&fx[i] );\n      for(  ; s1[j]==' '||s1[j]=='\\t';j++ ) ;\n      for( k=0; '0'<=s1[j]&&s1[j]<='9' ;j++,k++ )\n\ts2[k]=s1[j];\n      s2[k] = '\\0';\n      sscanf(s2,\"%d \",&fy[i] );\n      \n      if( DEBUG==1 )\n\tprintf(\" %3d : %3d %3d\\n\",i,fx[i],fy[i]);\n      \n      flag[i] = 0;\n    }\n\n    look1=0; flag[0]=1;\n    ans = 0.0;\n    x0 = 0;     y0 = 1;\n\n    while( 1 ){\n      minth = 300.0;\n      minr = 1000000000000.0;\n\n      look2=-1;\n      for(loop=1 ;loop<=n;loop++ ){\n\tif( flag[loop]!=0 )\n\t  continue;\n\n\tlook2=loop;\n\tdx = fx[look2]-fx[look1];\n\tdy = fy[look2]-fy[look1];\n\tth = acos( ( dx*x0 + dy*y0 ) / \n\t\t   ( distance(x0,y0)*distance(dx,dy) )  );\n\n\tif( DEBUG==1 ){\n\t  printf(\"%2d : (%3d,%3d)-(%3d,%3d) dx=%3d dy=%3d th=%f ans=%.1f\\n\",\n\t\t look2,fx[look1],fy[look1],fx[look2],fy[look2],dx,dy,th,ans);\n\t  printf(\"\\tx0=%d, y0=%d th[DEGREE]=%5.1f\\n\",x0,y0,th*180.0/3.14 );\n\t}\n\tif( th<minth ){\n\t  minth = th;\n\t  minr = distance(dx,dy );\n\t  min = look2;\n\t}else if( th==minth ){\n\t  r = distance(dx,dy);\n\t  if( r<minr ){\n\t    minth = th;\n\t    minr  = r;\n\t    min = look2;\n\t  }\n\t}\n      }\n      if( look2==-1 )\n\tbreak;\n\n      dx = fx[min]-fx[look1];\n      dy = fy[min]-fy[look1];\n      ans += distance(dx,dy);\n      flag[ min ]=1;\n      x0 = dx;\n      y0 = dy;\n\n      look1 = min;\n      if( DEBUG==1 )\n\tprintf(\"CHOOSE : %d\\tans=%.1f\\n\",min,ans);\n    }\n    printf(\"%.1f\\n\",ans);\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ntypedef struct{\n    int x;\n    int y;\n} point;\n\ntypedef struct{\n    double x;\n    double y;\n} vector;\n\ndouble distp(point *a, point *b);\ndouble distv(vector *a, vector *b);\nvector *relative(const point *a, const point *b, vector *r);\nvector *normalize(vector *v);\nvoid solve(int n);\ndouble min(double a, double b);\nint is_on_a_line(point *a, point *b, point *c);\n\nint main()\n{\n    int n;\n    char buf[128];\n    while(1){\n        fgets(buf, sizeof(buf), stdin);\n        sscanf(buf, \"%d\", &n);\n        if(n == 0) break;\n        solve(n);\n    }\n\n    return 0;\n}\n\nvoid solve(int n)\n{\n    int i;\n    char buf[128];\n    int x, y;\n    point points[512];\n    int visited[512];\n    int pos;\n    int mp;\n    int all_visited;\n    double len;\n    double m;\n    double d;\n    vector dir;\n    vector r;\n\n    // initialize\n    for(i = 0; i < n; i++) visited[i] = 0;\n    for(i = 0; i < n; i++){\n        fgets(buf, sizeof(buf), stdin);\n        sscanf(buf, \" %d %d\", &x, &y);\n        points[i].x = x;\n        points[i].y = y;\n    }\n    points[n].x = 0; points[n].y = 0; \n    pos = n;\n    len = 0;\n    dir.x = 0; dir.y = 1.0;\n\n    // solve\n    while(1){\n        all_visited = 1;\n        m = 3;\n        // direction\n        for(i = 0; i < n; i++){\n            if(!visited[i]){\n                all_visited = 0;\n                d = distv(normalize(&dir), normalize(relative(points+pos, points+i, &r)));\n                if(d < m){\n                    m = d;\n                    mp = i;\n                }\n            }\n        }\n        if(all_visited) break;\n\n        // on a line\n        for(i = 0; i < n; i++)\n            if(!visited[i] && i != mp)\n                if(is_on_a_line(points+pos, points+mp, points+i))\n                    if(distp(points+pos, points+mp) > distp(points+pos, points+i))\n                        mp = i;\n\n        // update\n        visited[mp] = 1;\n        len += distp(points+pos, points+mp);\n        relative(points+pos, points+mp, &dir);\n        pos = mp;\n    }\n\n    printf(\"%.1lf\\n\", len);\n}\n\nint is_on_a_line(point *a, point *b, point *c)\n{\n    int dx1 = a->x - b->x;\n    int dy1 = a->y - b->y;\n    int dx2 = a->x - c->x;\n    int dy2 = a->y - c->y;\n    return dx1*dy2 == dx2*dy1;\n}\n\nvector *relative(const point *a, const point *b, vector *r)\n{\n    r->x = b->x - a->x;\n    r->y = b->y - a->y;\n    return r;\n}\n\ndouble distp(point *a, point *b)\n{\n    int dx = a->x - b->x;\n    int dy = a->y - b->y;\n    int sq = dx * dx + dy * dy;\n    \n    return sqrt((double)sq);\n}\n\ndouble distv(vector *a, vector *b)\n{\n    double dx = a->x - b->x;\n    double dy = a->y - b->y;\n    double sq = dx * dx + dy * dy;\n    \n    return sqrt((double)sq);\n}\n\nvector *normalize(vector *v)\n{\n    double norm = sqrt(v->x * v->x + v->y * v->y);\n    v->x /= norm;\n    v->y /= norm;\n    return v;\n}\n\ndouble min(double a, double b)\n{\n    return (a < b ? a : b);\n}\n\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1107: Spiral Footrace\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-6\n\nint x[405], y[405];\nchar f[405];\ndouble ans;\n\ndouble theta(int x1, int y1, int x2, int y2)\n{\n    int dx, dy, ax, ay;\n    double t;\n\n    dx = x2 - x1;\n    ax = dx < 0 ? -dx : dx;\n    dy = y2 - y1;\n    ay = dy < 0 ? -dy : dy;\n    t = (ax + ay == 0) ? 0 : (double)dy/(double)(ax+ay);\n    if (dx < 0) t = 2 - t;\n    else if (dy < 0) t = 4 + t;\n    return t * 90.0;\n}\n\nvoid convexHull(int pn, int *x, int *y)\n{\n    int i, j, px, py;\n    int min;\n    double minang, nowang;\n    double dist, d, rad;\n\n    min = 0, minang = 90, px = py = 0;\n    for (j = 0; j < pn; j++) {\n        dist = 0x7ffffff, nowang = minang; minang = -360;\n\t\tif (nowang < 0) nowang += 360;\n        for (i = 0; i < pn; i++) {\n\t\t\tif (f[i]) continue;\n            d = sqrt((x[i]-px)*(x[i]-px)+(y[i]-py)*(y[i]-py));\n            rad = theta(px, py, x[i], y[i]);\n\t        if (d == 0) continue;\n\t\t\tif (rad > nowang) rad -= 360;\n            if (rad < nowang+EPS) {\n                if (rad - EPS > minang) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                } else if (fabs(rad-minang) <= EPS && d < dist) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                }\n            }\n#if 0\n\t\t\telse if (fabs(rad-nowang) < EPS && d > EPS &&\n                       fabs(rad-minang) > EPS || d < dist) {\n                dist = d;\n                minang = rad;\n                min = i;\n            }\n#endif\n        }\n\t\tf[min] = 1;\n\t\tans += sqrt((px-x[min])*(px-x[min])+(py-y[min])*(py-y[min]));\n\t\tpx = x[min], py = y[min];\n    }\n}\n\nint main()\n{\n\tint n, i;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d\", x+i, y+i);\n\t\tans = 0; convexHull(n, x, y);\n\t\tprintf(\"%.1lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n \n    public Main() {\n        while(true){\n            int n = in.nextInt();\n            if(n==0)break;\n            new AOJ1107().doIt(n);\n        }\n    }\n     \n    class AOJ1107{\n    \tdouble EPS = 1.0e-8;\n    \tint comp(double x,double y){\n    \t\tif(Math.abs(x-y)<EPS)return 0;\n    \t\tif(x<y)return -1;\n    \t\treturn 1;\n    \t}\n    \t\n        void doIt(int n){\n            Point2D[] p = new Point2D[n];\n            for(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(), in.nextDouble());\n            boolean[] used = new boolean[n];\n            double result = 0;\n            Point2D before = new Point2D.Double(0,-1);\n            Point2D now = new Point2D.Double(0,0);\n            int visit = 0;\n            while(visit!=n){\n                double max = Integer.MIN_VALUE;\n                double len = Double.MAX_VALUE;\n                int index = -1;\n                for(int i=0;i<n;i++)if(!used[i]){\n                    //内積\n                    double ccw = dot(sub(now, before),sub(p[i],now));\n                    double res = now.distance(p[i]);\n//                  System.out.println(sub(now, before));\n//                  System.out.println(sub(p[i], now));\n                    ccw /= sub(now,before).distance(0,0);\n                    ccw /= sub(p[i],now).distance(0,0);\n//                  System.out.println(\"CCW \" + ccw+\" \"+i+\" \"+p[i]);\n                    int diff = comp(max, ccw);\n                    if((diff<0)||(diff==0&&res<len)){\n                        max = ccw;\n                        index = i;\n                        len = res;\n                    }\n                }\n \n//              System.out.println(sub(now, before));\n//              System.out.println(sub(p[index], now));\n                used[index] = true;\n//              System.out.println(\"CCW \"+index+\" \"+p[index]);\n                result += p[index].distance(now);\n                before = now;\n                now = p[index];\n                visit++;\n            }\n            System.out.printf(\"%.1f\\n\",result);\n        }\n        double dot(Point2D p1,Point2D p2){\n            return p1.getX()*p2.getX()+p1.getY()*p2.getY();\n        }\n        Point2D sub(Point2D p1,Point2D p2){\n            return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tdouble EPS = 1e-6;\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+EPS<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Math.abs(thita-min)<EPS&&dist<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\" + \" D:\" + d);\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tdouble EPS = 1e-6;\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n//\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n\t\t\t\t\tdouble thita = Math.atan2(x1*y2-x2*y1, x1*x2+y1*y2);\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+EPS<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Math.abs(thita-min)<EPS&&dist<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\" + \" D:\" + d);\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 ) break;\n\n\t\t\tps = new Point2D[n+1];\n\n\t\t\tps[0] = new Point2D.Double(0,0);\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tps[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t}\n\n\t\t\tdouble ans = 0;\n\t\t\tbefore = null;\n\t\t\twhile(ps != null){\n\t\t\t\tans += convexHull();\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%.1f\\n\",ans);\n\t\t}\n\t}\n\n\tprivate static Point2D[] ps;\n\tprivate static Point2D before;\n\n\tprivate static double convexHull(){\n\t\tdouble res = 0;\n\t\tint n = ps.length;\n\n\t\tArrays.sort(ps,new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2){\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t});\n\n\t\tif(n <= 2){\n\t\t\tif(n == 2) res = ps[0].distance(ps[1]);\n\t\t\tps = null;\n\t\t\treturn res;\n\t\t}\n\n\t\tint k = 0;\n\t\tPoint2D[] ch = new Point2D[2*n];\n\t\tLinkedList<Point2D> ot = new LinkedList<Point2D>(Arrays.asList(ps));\n\n\t\tfor(int i=0;i<n;ch[k++] = ps[i++]){\n\t\t\twhile(k>=2 && Line2D.relativeCCW(ch[k-2].getX(),ch[k-2].getY(),ch[k-1].getX(),ch[k-1].getY(),ps[i].getX(),ps[i].getY()) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=n-2, t=k+1;i>=0;ch[k++]=ps[i--]){\n\t\t\twhile(k>=t && Line2D.relativeCCW(ch[k-2].getX(),ch[k-2].getY(),ch[k-1].getX(),ch[k-1].getY(),ps[i].getX(),ps[i].getY()) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\n\t\tint start = 0;\n\t\tif(before != null){\n\t\t\tfor(;!ch[start].equals(before);start++);\n\t\t}\n\t\t//System.out.println(\"start:\" + start + \" \" + before);\n\n\t\tif(n < k - 1) k = k / 2 + 1;\n\n\t\tot.remove(ch[start]);\n\t\tfor(int i=1;i<k-1;i++){\n\t\t\tint a = (start + i) % (k - 1);\n\t\t\tint b = (start + i - 1) % (k - 1);\n\t\t\tres += ch[b].distance(ch[a]);\n\t\t\tot.remove(ch[a]);\n\t\t}\n\t\tbefore = ch[(start - 1 + (k-1)) % (k - 1)];\n\t\tif(!ot.isEmpty()) ot.add(before);\n\n\t\t//System.out.println(k-1);\n\t\t//System.out.println(Arrays.toString(Arrays.copyOf(ch,k-1)));\n\n\t\tif(n > k-1)\n\t\t\tps = (Point2D[])ot.toArray(new Point2D[]{});\n\t\telse\n\t\t\tps = null;\n\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-6;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+EPS<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Math.abs(thita-min)<EPS&&dist+EPS<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\" + \" D:\" + d);\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+1e-8<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(thita==min&&dist<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\");\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 ) break;\n\n\t\t\tps = new Point2D[n+1];\n\n\t\t\tps[0] = new Point2D.Double(0,0);\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tps[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t}\n\n\t\t\tdouble ans = 0;\n\t\t\tbefore = null;\n\t\t\twhile(ps != null){\n\t\t\t\tans += convexHull();\n\t\t\t}\n\n\t\t\tSystem.out.printf(\"%.1f\\n\",ans);\n\t\t}\n\t}\n\n\tprivate static Point2D[] ps;\n\tprivate static Point2D before;\n\n\tprivate static double convexHull(){\n\t\tdouble res = 0;\n\t\tint n = ps.length;\n\n\t\tArrays.sort(ps,new Comparator<Point2D>(){\n\t\t\tpublic int compare(Point2D o1,Point2D o2){\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t});\n\n\t\tif(n <= 2){\n\t\t\tif(before != null) res += before.distance(ps[0]);\n\t\t\tif(n == 2) res = ps[0].distance(ps[1]);\n\t\t\tps = null;\n\t\t\treturn res;\n\t\t}\n\n\t\tint k = 0;\n\t\tPoint2D[] ch = new Point2D[2*n];\n\t\tLinkedList<Point2D> ot = new LinkedList<Point2D>(Arrays.asList(ps));\n\n\t\tfor(int i=0;i<n;ch[k++] = ps[i++]){\n\t\t\twhile(k>=2 && Line2D.relativeCCW(ch[k-2].getX(),ch[k-2].getY(),ch[k-1].getX(),ch[k-1].getY(),ps[i].getX(),ps[i].getY()) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=n-2, t=k+1;i>=0;ch[k++]=ps[i--]){\n\t\t\twhile(k>=t && Line2D.relativeCCW(ch[k-2].getX(),ch[k-2].getY(),ch[k-1].getX(),ch[k-1].getY(),ps[i].getX(),ps[i].getY()) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\n\t\tif(before != null) res += before.distance(ch[0]);\n\t\tot.remove(ch[0]);\n\t\tfor(int i=1;i<k-1;i++){\n\t\t\tres += ch[i-1].distance(ch[i]);\n\t\t\tot.remove(ch[i]);\n\t\t}\n\t\tbefore = ch[k-2];\n\n\t\tif(n > k-1)\n\t\t\tps = (Point2D[])ot.toArray(new Point2D[]{});\n\t\telse\n\t\t\tps = null;\n\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn x==o.x?y-o.y:x-o.x;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n\t\t\t\t\tif(thita<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(thita==min&&dist<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\");\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n== 0) break;\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tboolean [] visited = new boolean[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint nowx = 0, nowy = 0;\n\t\t\tdouble dis = 0, nowdeg = 0.0;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdouble degmin = 720.0;\n\t\t\t\tint ind = -1;\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(! visited[j]){\n\t\t\t\t\t\tif(! isinLine(nowx, nowy, xlist[j], ylist[j], xlist,ylist)){\n\t\t\t\t\t\t\t//calc deg\n\t\t\t\t\t\t\tdouble res = getDeg(nowx, nowy, xlist[j], ylist[j]);\n\t\t\t\t\t\t\t//System.out.println(\"j=\" + j +\" degmin= \" + degmin + \" \" + res + \"ind= \" + ind);\n\t\t\t\t\t\t\tif(res < nowdeg){\n\t\t\t\t\t\t\t\tres+= 360;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(degmin > res){\n\t\t\t\t\t\t\t\tdegmin = res;\n\t\t\t\t\t\t\t\tind = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//System.out.println(\"intersect!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited[ind] = true;\n\t\t\t\tdis += Point2D.Double.distance(nowx, nowy, xlist[ind], ylist[ind]);\n\t\t\t\tnowx = xlist[ind];\n\t\t\t\tnowy = ylist[ind];\n\t\t\t\tnowdeg =degmin % 360;\n\t\t\t\t//System.out.printf(\"ind= %d nowdeg= %.3f degmin= %.3f \\n\",ind+1, nowdeg, degmin);\n\t\t\t\t//System.out.println(dis + \" \" + (ind + 1) );\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.1f\\n\",dis);\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug=\");\n//\t\t\tLine2D.Double line =new Line2D.Double(0,0,20,0);\n//\t\t\tint temp = line.relativeCCW(10, 0);\n//\t\t\tSystem.out.println(temp);\n\t\t}\n\t}\n\n\tprivate boolean isinLine(int nowx, int nowy, int nextx, int nexty, int[] xlist,int[] ylist) {\n\t\tLine2D.Double line =new Line2D.Double(nowx,nowy,nextx,nexty);\n\t\tfor(int i=0; i < xlist.length; i++){\n\t\t\tif((nowx == xlist[i] && nowy == ylist[i]) || (nextx == xlist[i] && nexty == ylist[i]) ) continue;\n\t\t\tif(line.relativeCCW(xlist[i],ylist[i]) == 0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate double getDeg(int nowx, int nowy, int nextx, int nexty) {\n\t\tdouble dis = Point2D.Double.distance(nowx, nowy, nextx, nexty);\n\t\tdouble sin = (double)(nextx - nowx) / dis;\n\t\tdouble asin = Math.asin(sin);\n\t\tdouble deg = Math.toDegrees(asin);\n\t\tdouble degRevision = revision(nowx,nowy,nextx,nexty,deg);\n\t\treturn degRevision;\n\t}\n\t\n\tprivate double revision(int nowx, int nowy, int nextx, int nexty,double deg){\n\t\tif(nowx <= nextx && nowy <= nexty){\n\t\t\treturn deg;\n\t\t}\n\t\tif(nowx <= nextx && nowy >= nexty){\n\t\t\treturn ((double)180 - deg);\n\t\t}\n\t\tif(nowx >= nextx && nowy <= nexty){\n\t\t\treturn ((double)360+deg);\n\t\t}\n\t\tif(nowx >= nextx && nowy >= nexty){\n\t\t\treturn ((double)180-deg);\n\t\t}\n\t\telse{\n\t\t\treturn deg;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+1e-8<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Math.abs(thita-min)<1e-8&&dist+1e-8<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\");\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Spiral Footrace\npublic class Main{\n\n\tclass P{\n\t\tint x, y;\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new P(sc.nextInt(), sc.nextInt());\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tP t = new P(0, 0);\n\t\t\tP h = new P(0, 1);\n\t\t\tP pre = new P(0, 0);\n\t\t\tdouble res = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint id = -1;\n\t\t\t\tdouble min = 360;\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[j])continue;\n\t\t\t\t\tdouble dist = Math.hypot(p[j].x-pre.x, p[j].y-pre.y);\n\t\t\t\t\tdouble x1 = p[j].x-pre.x;\n\t\t\t\t\tdouble y1 = p[j].y-pre.y;\n\t\t\t\t\tdouble x2 = h.x-t.x;\n\t\t\t\t\tdouble y2 = h.y-t.y;\n\t\t\t\t\tdouble thita = Math.acos((x1*x2+y1*y2)/(Math.hypot(x1, y1)*Math.hypot(x2, y2)));\n\t\t\t\t\tif(thita<1e-5)thita = 0;\n//\t\t\t\t\tSystem.out.println(\"ID:\" + j + \" THIA:\" + thita);\n\t\t\t\t\tif(thita+1e-5<min){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\tmin = thita;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Math.abs(thita-min)<1e-5&&dist+1e-5<d){\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t\td = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"P: (\" +p[id].x+\",\"+p[id].y+\")\");\n\t\t\t\tu[id] = true;\n\t\t\t\tres += d;\n\t\t\t\tpre = p[id];\n\t\t\t\tif(i==0){\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt = h;\n\t\t\t\t\th = p[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_array = new int[n + 1];\n\t\t\tint[] y_array = new int[n + 1];\n\t\t\t\n\t\t\tx_array[0] = 0;\n\t\t\ty_array[0] = 0;\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tx_array[i] = sc.nextInt();\n\t\t\t\ty_array[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] visited = new boolean[n+1];\n\t\t\t\n\t\t\tint cur_place = 0;\n\t\t\tdouble sum_dist = 0;\n\t\t\tdouble cur_angle = Math.PI / 2;\n\t\t\tfor(int run = 0; run < n; run++){\n\t\t\t\tvisited[cur_place] = true;\n\t\t\t\t\n\t\t\t\t//System.out.println(cur_place);\n\t\t\t\t\n\t\t\t\tint next_place = -1;\n\t\t\t\tdouble min_angle = Math.PI * 2;\n\t\t\t\tdouble min_dist = 0;\n\t\t\t\t\n\t\t\t\tfor(int next = 0; next < n + 1; next++){\n\t\t\t\t\tif(visited[next]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdouble d = Math.sqrt((x_array[cur_place] - x_array[next]) * (x_array[cur_place] - x_array[next]) +\n\t\t\t\t\t\t\t(y_array[cur_place] - y_array[next]) * (y_array[cur_place] - y_array[next]));\n\t\t\t\t\tdouble a = Math.atan2(y_array[next] - y_array[cur_place], x_array[next] - x_array[cur_place]);\n\t\t\t\t\t\n\t\t\t\t\tdouble diff_a = cur_angle - a;\n\t\t\t\t\tif(diff_a < 0){\n\t\t\t\t\t\tdiff_a += Math.PI * 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min_angle >= diff_a){\n\t\t\t\t\t\tif(min_angle > diff_a){\n\t\t\t\t\t\t\tmin_dist = d;\n\t\t\t\t\t\t\tmin_angle = diff_a;\n\t\t\t\t\t\t\tnext_place = next;\n\t\t\t\t\t\t}else if(min_dist > d){\n\t\t\t\t\t\t\tmin_dist = d;\n\t\t\t\t\t\t\tnext_place = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcur_angle = Math.atan2(y_array[next_place] - y_array[cur_place], x_array[next_place] - x_array[cur_place]);\n\t\t\t\tcur_place = next_place;\n\t\t\t\tsum_dist += min_dist;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.printf(\"%.1f\\n\", sum_dist);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ1107().doIt();\n\t}\n\t\n\tclass AOJ1107{\n\t\tvoid doIt(){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(), in.nextDouble());\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tdouble result = 0;\n\t\t\tPoint2D before = new Point2D.Double(0,-1);\n\t\t\tPoint2D now = new Point2D.Double(0,0);\n\t\t\tint visit = 0;\n\t\t\twhile(visit!=n){\n\t\t\t\tdouble max = Integer.MIN_VALUE;\n//\t\t\t\tdouble len = -1;\n\t\t\t\tint index = -1;\n\t\t\t\tfor(int i=0;i<n;i++)if(!used[i]){\n\t\t\t\t\t//内積\n\t\t\t\t\tdouble ccw = dot(sub(now, before),sub(p[i],now));\n//\t\t\t\t\tSystem.out.println(sub(now, before));\n//\t\t\t\t\tSystem.out.println(sub(p[i], now));\n\t\t\t\t\tccw /= sub(now,before).distance(0,0);\n\t\t\t\t\tccw /= sub(p[i],now).distance(0,0);\n//\t\t\t\t\tSystem.out.println(ccw+\" \"+i+\" \"+p[i]);\n\t\t\t\t\tif(max<=ccw){\n\t\t\t\t\t\tif(max==ccw)continue;\n\t\t\t\t\t\tmax = ccw;\n\t\t\t\t\t\tindex = i;\n//\t\t\t\t\t\tlen = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[index] = true;\n//\t\t\t\tSystem.out.println(index);\n\t\t\t\tresult += p[index].distance(now);\n\t\t\t\tbefore = now;\n\t\t\t\tnow = p[index];\n\t\t\t\tvisit++;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\",result);\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n== 0) break;\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tboolean [] visited = new boolean[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint nowx = 0, nowy = 0;\n\t\t\tdouble dis = 0, nowdeg = 0.0;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdouble degmin = 720.0;\n\t\t\t\tint ind = -1;\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(! visited[j] && ! isinLine(nowx, nowy, xlist[j], ylist[j], xlist,ylist)){\n\t\t\t\t\t\t//calc deg\n\t\t\t\t\t\tdouble res = getDeg(nowx, nowy, xlist[j], ylist[j]);\n\t\t\t\t\t\t//System.out.println(\"j=\" + j +\" degmin= \" + degmin + \" \" + res + \"ind= \" + ind);\n\t\t\t\t\t\tif(res < nowdeg){\n\t\t\t\t\t\t\tres+= 360;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(degmin > res){\n\t\t\t\t\t\t\tdegmin = res;\n\t\t\t\t\t\t\tind = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited[ind] = true;\n\t\t\t\tdis += Point2D.Double.distance(nowx, nowy, xlist[ind], ylist[ind]);\n\t\t\t\tnowx = xlist[ind];\n\t\t\t\tnowy = ylist[ind];\n\t\t\t\tnowdeg =degmin % 360;\n\t\t\t\t//System.out.printf(\"ind= %d nowdeg= %.3f degmin= %.3f \\n\",ind+1, nowdeg, degmin);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.1f\\n\",dis);\n\t\t\t\n\t\t}\n\t}\n\n\tprivate boolean isinLine(int nowx, int nowy, int nextx, int nexty, int[] xlist,int[] ylist) {\n\t\tLine2D.Double line =new Line2D.Double(nowx,nowy,nextx,nexty);\n\t\tfor(int i=0; i < xlist.length; i++){\n\t\t\tif(line.contains(xlist[i],ylist[i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate double getDeg(int nowx, int nowy, int nextx, int nexty) {\n\t\tdouble dis = Point2D.Double.distance(nowx, nowy, nextx, nexty);\n\t\tdouble sin = (double)(nextx - nowx) / dis;\n\t\tdouble asin = Math.asin(sin);\n\t\tdouble deg = Math.toDegrees(asin);\n\t\tdouble degRevision = revision(nowx,nowy,nextx,nexty,deg);\n\t\treturn degRevision;\n\t}\n\t\n\tprivate double revision(int nowx, int nowy, int nextx, int nexty,double deg){\n\t\tif(nowx <= nextx && nowy <= nexty){\n\t\t\treturn deg;\n\t\t}\n\t\tif(nowx <= nextx && nowy >= nexty){\n\t\t\treturn ((double)180 - deg);\n\t\t}\n\t\tif(nowx >= nextx && nowy <= nexty){\n\t\t\treturn ((double)360+deg);\n\t\t}\n\t\tif(nowx >= nextx && nowy >= nexty){\n\t\t\treturn ((double)180-deg);\n\t\t}\n\t\telse{\n\t\t\treturn deg;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(in.hasNext())new AOJ1107().doIt();\n\t}\n\t\n\tclass AOJ1107{\n\t\tvoid doIt(){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(), in.nextDouble());\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tdouble result = 0;\n\t\t\tPoint2D before = new Point2D.Double(0,-1);\n\t\t\tPoint2D now = new Point2D.Double(0,0);\n\t\t\tint visit = 0;\n\t\t\twhile(visit!=n){\n\t\t\t\tdouble max = Integer.MIN_VALUE;\n\t\t\t\tdouble len = Double.MAX_VALUE;\n\t\t\t\tint index = -1;\n\t\t\t\tfor(int i=0;i<n;i++)if(!used[i]){\n\t\t\t\t\t//内積\n\t\t\t\t\tdouble ccw = dot(sub(now, before),sub(p[i],now));\n\t\t\t\t\tdouble res = now.distance(p[i]);\n//\t\t\t\t\tSystem.out.println(sub(now, before));\n//\t\t\t\t\tSystem.out.println(sub(p[i], now));\n\t\t\t\t\tccw /= sub(now,before).distance(0,0);\n\t\t\t\t\tccw /= sub(p[i],now).distance(0,0);\n//\t\t\t\t\tSystem.out.println(\"CCW \" + ccw+\" \"+i+\" \"+p[i]);\n\t\t\t\t\tif(max<=ccw){\n\t\t\t\t\t\tif(max==ccw&&res>len)continue;\n\t\t\t\t\t\tmax = ccw;\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tlen = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\n//\t\t\t\tSystem.out.println(sub(now, before));\n//\t\t\t\tSystem.out.println(sub(p[index], now));\n\t\t\t\tused[index] = true;\n//\t\t\t\tSystem.out.println(\"CCW \"+index+\" \"+p[index]);\n\t\t\t\tresult += p[index].distance(now);\n\t\t\t\tbefore = now;\n\t\t\t\tnow = p[index];\n\t\t\t\tvisit++;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\",result);\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1107().doIt(n);\n\t\t}\n\t}\n\t\n\tclass AOJ1107{\n\t\tvoid doIt(int n){\n\t\t\tdouble EPS = 1.0e-8;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++)p[i] = new Point2D.Double(in.nextDouble(), in.nextDouble());\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tdouble result = 0;\n\t\t\tPoint2D before = new Point2D.Double(0,-1);\n\t\t\tPoint2D now = new Point2D.Double(0,0);\n\t\t\tint visit = 0;\n\t\t\twhile(visit!=n){\n\t\t\t\tdouble max = Integer.MIN_VALUE;\n\t\t\t\tdouble len = Double.MAX_VALUE;\n\t\t\t\tint index = -1;\n\t\t\t\tfor(int i=0;i<n;i++)if(!used[i]){\n\t\t\t\t\t//内積\n\t\t\t\t\tdouble ccw = dot(sub(now, before),sub(p[i],now));\n\t\t\t\t\tdouble res = now.distance(p[i]);\n//\t\t\t\t\tSystem.out.println(sub(now, before));\n//\t\t\t\t\tSystem.out.println(sub(p[i], now));\n\t\t\t\t\tccw /= sub(now,before).distance(0,0);\n\t\t\t\t\tccw /= sub(p[i],now).distance(0,0);\n//\t\t\t\t\tSystem.out.println(\"CCW \" + ccw+\" \"+i+\" \"+p[i]);\n\t\t\t\t\tif((max<ccw)||(Math.abs(max-ccw)<EPS&&res<len)){\n\t\t\t\t\t\tmax = ccw;\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tlen = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\n//\t\t\t\tSystem.out.println(sub(now, before));\n//\t\t\t\tSystem.out.println(sub(p[index], now));\n\t\t\t\tused[index] = true;\n//\t\t\t\tSystem.out.println(\"CCW \"+index+\" \"+p[index]);\n\t\t\t\tresult += p[index].distance(now);\n\t\t\t\tbefore = now;\n\t\t\t\tnow = p[index];\n\t\t\t\tvisit++;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.1f\\n\",result);\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n  def <=>(p)\n    @y!=p.y ? @y<=>p.y : @x<=>p.x\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def angle\n    Math::atan2(@y, @x)\n  end\nend\n\nwhile (n=gets.to_i) != 0 do\n  flag = Array.new\n  n.times do\n    flag.push(Point.new(*gets.split.reverse))\n  end\n\n  pre = Point.new\n  now = flag.sort!.shift\n  length = (now-pre).abs\n  while !flag.empty? do\n    min = 2.0 * Math::PI\n    nextPoint = nil\n    flag.each do |nex|\n      angle = (nex-now).angle - (now-pre).angle\n      angle += 2.0 * Math::PI if angle < 0.0\n      next if min < angle\n      next if min==angle && (nextPoint-now).abs<(nex-now).abs\n      nextPoint = nex\n      min = angle\n    end\n    pre, now = now, nextPoint\n    flag.delete(nextPoint)\n    length += (now-pre).abs\n  end\n  printf \"%.1f\\n\", length\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nPI2 = Math::PI * 2\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  pts = n.times.map{gets.split.map(&:to_f)}\n  visited = n.times.map{false}\n  #p pts\n\n  cx, cy, vx, vy = [0.0, 0.0, 0.0, 1.0]\n\n  cnt = 0\n  lsum = 0.0\n\n  while cnt < n\n    cth = Math.atan2(vy, vx)\n\n    max_th = -10.0\n    max_i = nil\n    max_d2 = nil\n\n    for i in (0...n)\n      next if visited[i]\n\n      px, py = pts[i]\n      vx = px - cx\n      vy = py - cy\n      d2 = vx * vx + vy * vy\n      th = Math.atan2(py - cy, px - cx)\n      th -= PI2 if th > cth\n\n      if max_th < th || max_th == th && max_d2 > d2\n        max_th = th\n        max_i = i\n        max_d2 = d2\n      end\n    end\n\n    visited[max_i] = true\n    lsum += Math.sqrt(max_d2)\n    cnt += 1\n\n    vx = pts[max_i][0] - cx\n    vy = pts[max_i][1] - cy\n    cx, cy = pts[max_i]\n  end\n\n  puts \"%.1f\" % lsum\nend"
  },
  {
    "language": "Ruby",
    "code": "loop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tpoints = (1..n).map{ gets.split.map(&:to_i) }\n\tpoints << [0, 0]\n\tpoints.sort!\n\t#p points\n\n\troute = []\n\tloop {\n\t\tpath = [points[0]]\n\t\t1.upto(points.size-1){|i|\n\t\t\tif path.size >= 2\n\t\t\t\tx1, y1 = path[-2]\n\t\t\t\tx2, y2 = path[-1]\n\t\t\t\tx3, y3 = points[i]\n\n\t\t\t\tif x1 != x2\n\t\t\t\t\tif x2 == x3 || (y2 - y1).to_f / (x2 - x1) < (y3 - y2).to_f / (x3 - x2) \n\t\t\t\t\t\tpath.pop\n\t\t\t\t\t\tredo\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tpath << points[i]\n\t\t}\n\t\t#p path\n\t\tif path.size == points.size\n\t\t\troute += path\n\t\t\tbreak\n\t\tend\n\t\tpath.pop\n\t\troute += path\n\t\tpoints -= path\n\t\tpoints.reverse!\n\t}\n\t#p route\n\ttotal_dist = route.each_cons(2).map{|u, v|\n\t\tx1, y1 = u\n\t\tx2, y2 = v\n\t\tMath.sqrt((x1-x2)**2 + (y1-y2)**2)\n\t}.inject(:+)\n\tprintf(\"%.1f\\n\", total_dist)\n}"
  },
  {
    "language": "Ruby",
    "code": "loop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tpoints = [[0, 0]] + (1..n).map{ gets.split.map(&:to_i) }.sort\n\troute = []\n\n\tloop {\n\t\tpath = [points[0]]\n\t\t(1..points.size-1).each{|i|\n\t\t\tif path.size >= 2\n\t\t\t\tx1, y1 = path[-2]\n\t\t\t\tx2, y2 = path[-1]\n\t\t\t\tx3, y3 = points[i]\n\n\t\t\t\tif x1 != x2\n\t\t\t\t\tif x2 == x3 || (y2 - y1).to_f / (x2 - x1) < (y3 - y2).to_f / (x3 - x2) \n\t\t\t\t\t\tpath.pop\n\t\t\t\t\t\tredo\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tpath << points[i]\n\t\t}\n\n\t\tif path.size == points.size\n\t\t\troute += path\n\t\t\tbreak\n\t\tend\n\n\t\tpath.pop\n\t\troute += path\n\t\tpoints -= path\n\t\tpoints.reverse!\n\t}\n\n\ttotal_dist = route.each_cons(2).map{|u, v|\n\t\tx1, y1 = u\n\t\tx2, y2 = v\n\t\tMath.sqrt((x1-x2)**2 + (y1-y2)**2)\n\t}.inject(:+)\n\tprintf(\"%.1f\\n\", total_dist)\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\ndouble dot(int[] u, int[] v) {\n\treturn u[0]*v[0]+u[1]*v[1];\n}\ndouble cross(int[] u, int[] v) {\n\treturn u[0]*v[1]-u[1]*v[0];\n}\ndouble angle(int[] u, int[] v) {\n\treturn 1-dot(u,v)/sqrt(dot(u,u))/sqrt(dot(v,v));\n}\n\nbool near(int[] p0, int[] p1, int[] p2, int[] p3) {\n\tint[2] v1 = p1[] - p0[];\n\tint[2] v2 = p2[] - p1[];\n\tint[2] v3 = p3[] - p1[];\n\tdouble a2 = angle(v1, v2);\n\tdouble a3 = angle(v1, v3);\n\tdouble eps = 1e-5;\n\tif(abs(a2-a3) < eps)\n\t\treturn dot(v2, v2) < dot(v3,v3);\n\telse\n\t\treturn a2<a3;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint[][] p;\n\t\tforeach(i; 0..n) {\n\t\t\tp ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\n\t\tint[] p0 = [0,-1];\n\t\tint[] p1 = [0,0];\n\t\tdouble l = 0;\n\t\twhile(n--) {\n\t\t\tint pi = 0;\n\t\t\tforeach(i; 1..p.length) {\n\t\t\t\tif(near(p0, p1, p[i], p[pi]))\n\t\t\t\t\tpi = cast(int)i;\n\t\t\t}\n\t\t\tint[2] v = p[pi][] - p1[];\n\t\t\tl += sqrt(dot(v,v));\n\t\t\tp0 = p1;\n\t\t\tp1 = p[pi];\n\t\t\tp = p[0..pi]~p[pi+1..$];\n\t\t}\n\t\twritefln(\"%.1f\",l);\n\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / sqrt(n.norm2 * v.norm2));\n                //if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t + EPS < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-10;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) <= EPS && n.norm < (P[next] - c).norm) {\n                    next = i;\n                    min_t = t;\n                } else if (t < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (t < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-10;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / sqrt(n.norm2 * v.norm2));\n                //if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) == 0 && n.norm < (P[next] - c).norm) {\n                    next = i;\n                    min_t = t;\n                } else if (t < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-16;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                //if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-20;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t + EPS < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-17;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t + EPS < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-16;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-19;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) {\n        static if (op == \"-\") {\n            return Point(x - a.x, y - a.y);\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble dot2(in Point a, in Point b) {\n    double d = dot(a, b);\n    return d * d;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble norm2(in Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid main() {\n    int N;\n    Point[] P;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        P.clear;\n        foreach (i; 0 .. N) {\n            double x, y;\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P ~= Point(x, y);\n        }\n        return true;\n    }\n    void solve() {\n        auto c = Point(0, 0),\n             v = Point(0, 1);\n        auto used = new bool[N];\n        double Ans = 0;\n        while (true) {\n            double min_t = double.max;\n            int next;\n            foreach (i; 0 .. N) {\n                if (used[i]) continue;\n                Point n = P[i] - c;\n                double t = acos(dot(n, v) / (n.norm * v.norm));\n                if (cross(n, v) < -EPS) t += PI;\n                if (abs(t - min_t) < EPS && n.norm2 <= (P[next] - c).norm2) {\n                    next = i;\n                    min_t = t;\n                } else if (t + 1e-19 < min_t) {\n                    next = i;\n                    min_t = t;\n                }\n            }\n            if (min_t == double.max) break;\n            used[next] = true;\n            //writeln(next);\n            Ans += (c - P[next]).norm;\n            v = P[next] - c;\n            c = P[next];\n        }\n        writefln(\"%.1f\", Ans);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        N = input()    \n        if N == 0:\n            break\n        points = [Vector(map(int, raw_input().split())) for _ in xrange(N)]\n        seq = [Vector([0, -1]), Vector([0, 0])]\n        while len(points) != 0:\n            pre = seq[-1] - seq[-2]\n            points.sort(key=lambda x: abs(x-seq[-1]), reverse=True)\n            #print points\n            points.sort(key=lambda x: (x-seq[-1]).norm() * pre.norm())\n            #print points\n            p = map(lambda x: (x-seq[-1]).norm() * pre.norm(), points)\n            #print pre, points\n            #print \"\\n\".join(map(str, reversed(zip(points, p))))\n            seq += [points.pop()]\n        print round(sum(abs(v2 - v1) for v1, v2 in zip(seq[1:], seq[2:])), 1)\n\nclass Vector(tuple):\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __abs__(self):\n        return sum(x ** 2 for x in self) ** 0.5\n\n    def __add__(self, v):\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return Vector([x1 + x2 for x1, x2 in zip(self, v)])\n\n    def __sub__(self, v):\n        return self.__add__(-v)\n    \n    def norm(self):\n        a = self.__abs__()\n        return Vector([x / a for x in self])\n\n    def __mul__(self,  v):\n        \"\"\"dot product\"\"\"\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        #  return sum(x1 * x2 for x1, x2 in zip(self, v))\n        return round(sum(x1 * x2 for x1, x2 in zip(self, v)), 14)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        N = input()    \n        if N == 0:\n            break\n        points = [Vector(map(int, raw_input().split())) for _ in xrange(N)]\n        seq = [Vector([0, -1]), Vector([0, 0])]\n        while len(points) != 0:\n            pre = seq[-1] - seq[-2]\n            points.sort(key=lambda x: (x-seq[-1]).norm() * pre.norm())\n            seq += [points.pop()]\n        print round(sum(abs(v2 - v1) for v1, v2 in zip(seq[1:], seq[2:])), 1)\n\nclass Vector(tuple):\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __abs__(self):\n        return sum(x ** 2 for x in self) ** 0.5\n\n    def __add__(self, v):\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return Vector([x1 + x2 for x1, x2 in zip(self, v)])\n\n    def __sub__(self, v):\n        return self.__add__(-v)\n    \n    def norm(self):\n        a = self.__abs__()\n        return Vector([x / a for x in self])\n\n    def __mul__(self,  v):\n        \"\"\"dot product\"\"\"\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return sum(x1 * x2 for x1, x2 in zip(self, v))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        N = input()    \n        if N == 0:\n            break\n        points = [Vector(map(int, raw_input().split())) for _ in xrange(N)]\n        seq = [Vector([0, -1]), Vector([0, 0])]\n        while len(points) != 0:\n            pre = seq[-1] - seq[-2]\n            points.sort(key=lambda x: (x-seq[-1]).norm() * pre.norm())\n            seq += [points.pop()]\n        print round(sum(abs(v2 - v1) for v1, v2 in zip(seq[1:], seq[2:])), 2)\n\nclass Vector(tuple):\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __abs__(self):\n        return sum(x ** 2 for x in self) ** 0.5\n\n    def __add__(self, v):\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return Vector([x1 + x2 for x1, x2 in zip(self, v)])\n\n    def __sub__(self, v):\n        return self.__add__(-v)\n    \n    def norm(self):\n        a = self.__abs__()\n        return Vector([x / a for x in self])\n\n    def __mul__(self,  v):\n        \"\"\"dot product\"\"\"\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return sum(x1 * x2 for x1, x2 in zip(self, v))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        N = input()    \n        if N == 0:\n            break\n        points = [Vector(map(int, raw_input().split())) for _ in xrange(N)]\n        seq = [Vector([0, -1]), Vector([0, 0])]\n        while len(points) != 0:\n            pre = seq[-1] - seq[-2]\n            points.sort(key=lambda x: abs(x-seq[-1]), reverse=True)\n            points.sort(key=lambda x: (x-seq[-1]).norm() * pre.norm())\n            p = map(lambda x: (x-seq[-1]).norm() * pre.norm(), points)\n            seq += [points.pop()]\n        print round(sum(abs(v2 - v1) for v1, v2 in zip(seq[1:], seq[2:])), 1)\n\nclass Vector(tuple):\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __abs__(self):\n        return sum(x ** 2 for x in self) ** 0.5\n\n    def __add__(self, v):\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return Vector([x1 + x2 for x1, x2 in zip(self, v)])\n\n    def __sub__(self, v):\n        return self.__add__(-v)\n    \n    def norm(self):\n        a = self.__abs__()\n        return Vector([x / a for x in self])\n\n    def __mul__(self,  v):\n        \"\"\"dot product\"\"\"\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        #  sum(x1 * x2 for x1, x2 in zip(self, v))\n        return round(sum(x1 * x2 for x1, x2 in zip(self, v)), 14)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        N = input()    \n        if N == 0:\n            break\n        points = [Vector(map(int, raw_input().split())) for _ in xrange(N)]\n        seq = [Vector([0, -1]), Vector([0, 0])]\n        while len(points) != 0:\n            pre = seq[-1] - seq[-2]\n            points.sort(key=lambda x: abs(x-seq[-1]), reverse=True)\n            points.sort(key=lambda x: (x-seq[-1]).norm() * pre.norm())\n            seq += [points.pop()]\n        print round(sum(abs(v2 - v1) for v1, v2 in zip(seq[1:], seq[2:])), 1)\n\nclass Vector(tuple):\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __abs__(self):\n        return sum(x ** 2 for x in self) ** 0.5\n\n    def __add__(self, v):\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return Vector([x1 + x2 for x1, x2 in zip(self, v)])\n\n    def __sub__(self, v):\n        return self.__add__(-v)\n    \n    def norm(self):\n        a = self.__abs__()\n        return Vector([x / a for x in self])\n\n    def __mul__(self,  v):\n        \"\"\"dot product\"\"\"\n        if len(self) != len(v):\n            raise ValueError, \"Same dimension is required.\"\n        return round(sum(x1 * x2 for x1, x2 in zip(self, v)), 14)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef getangle(pointstart,pointend):\n    [sx,sy]=pointstart\n    [ex,ey]=pointend\n    return math.atan2(ey-sy,ex-sx)\n    \ndef getdistance(pointstart,pointend):\n    [sx,sy]=pointstart\n    [ex,ey]=pointend\n    return math.sqrt((ex-sx)**2+(ey-sy)**2)\n\nwhile(1):\n    n=int(raw_input())\n    if n==0:\n        break\n    else:\n        pointsnotyet=[]\n        for i in range(n):\n            pointsnotyet.append([int(x) for x in raw_input().split()])\n        pointstart=[0,0]\n        angle=math.pi/2\n        ans=0\n        for i in range(n):\n            pointangle=getangle(pointstart,pointsnotyet[0])\n            diff=-pointangle+angle\n            if diff<0:\n                diff+=math.pi*2\n            candidateangle=diff\n            candidatedistance=getdistance(pointstart,pointsnotyet[0])\n            candidateindex=0\n            for j in range(1,len(pointsnotyet)):\n                pointangle=getangle(pointstart,pointsnotyet[j])\n                pointdistance=getdistance(pointstart,pointsnotyet[j])\n                diff=-pointangle+angle\n                if diff<0:\n                    diff+=math.pi*2\n                if diff<candidateangle:\n                    candidateangle=diff\n                    candidatedistance=pointdistance\n                    candidateindex=j\n                elif diff==candidateangle and pointdistance<candidatedistance:\n                    candidateangle=diff\n                    candidatedistance=pointdistance\n                    candidateindex=j\n            pointend=pointsnotyet.pop(candidateindex)\n            ans+=getdistance(pointstart,pointend)\n            angle=getangle(pointstart,pointend)\n            pointstart=pointend\n        print round(ans,1)\n                "
  }
]