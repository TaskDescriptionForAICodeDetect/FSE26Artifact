[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n    int visited;\n} Point;\n\ndouble calculate_angle(double dx, double dy) {\n    double angle = atan2(dy, dx);\n    if (angle < 0) angle += 2 * M_PI;\n    return angle;\n}\n\ndouble calculate_distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint find_next_flag(Point *flags, int n, Point current, double current_angle) {\n    int next_flag = -1;\n    double min_angle_diff = 2 * M_PI;\n    double min_distance = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (flags[i].visited) continue;\n\n        double dx = flags[i].x - current.x;\n        double dy = flags[i].y - current.y;\n        double angle = calculate_angle(dx, dy);\n        double angle_diff = angle - current_angle;\n\n        if (angle_diff < 0) angle_diff += 2 * M_PI;\n\n        double distance = calculate_distance(current, flags[i]);\n\n        if (angle_diff < min_angle_diff - 1e-9) {\n            min_angle_diff = angle_diff;\n            min_distance = distance;\n            next_flag = i;\n        } else if (fabs(angle_diff - min_angle_diff) < 1e-9 && distance < min_distance) {\n            min_distance = distance;\n            next_flag = i;\n        }\n    }\n\n    return next_flag;\n}\n\nint main() {\n    int dataset = 1;\n    int n;\n\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point *flags = malloc(n * sizeof(Point));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &flags[i].x, &flags[i].y);\n            flags[i].visited = 0;\n        }\n\n        Point current = {0.0, 0.0};\n        double current_angle = M_PI / 2; // Facing north\n        double total_distance = 0.0;\n\n        for (int i = 0; i < n; i++) {\n            int next_flag = find_next_flag(flags, n, current, current_angle);\n            if (next_flag == -1) break;\n\n            total_distance += calculate_distance(current, flags[next_flag]);\n            current_angle = calculate_angle(flags[next_flag].x - current.x, flags[next_flag].y - current.y);\n            current = flags[next_flag];\n            flags[next_flag].visited = 1;\n        }\n\n        printf(\"Dataset %d: Total distance = %.2lf\\n\", dataset++, total_distance);\n        free(flags);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:03:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SpiralRace {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static double calculateDistance(List<Point> flags) {\n        Point current = new Point(0, 0);\n        double totalDistance = 0;\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        int direction = 0;\n\n        for (Point flag : flags) {\n            double angle = calculateAngle(current, flag, direction);\n            totalDistance += Math.sqrt(Math.pow(flag.x - current.x, 2) + Math.pow(flag.y - current.y, 2));\n            current = flag;\n            direction = (direction + 1) % 4;\n        }\n\n        return totalDistance;\n    }\n\n    private static double calculateAngle(Point current, Point flag, int currentDirection) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        \n        double currentAngle = Math.atan2(dy[currentDirection], dx[currentDirection]);\n        double flagAngle = Math.atan2(flag.y - current.y, flag.x - current.x);\n        \n        double angle = flagAngle - currentAngle;\n        if (angle < 0) angle += 2 * Math.PI;\n        \n        return angle;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int i = 0; i < datasets; i++) {\n            int flagCount = scanner.nextInt();\n            List<Point> flags = new ArrayList<>();\n            \n            for (int j = 0; j < flagCount; j++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                flags.add(new Point(x, y));\n            }\n            \n            double result = calculateDistance(flags);\n            System.out.printf(\"%.2f%n\", result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:03:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\ndouble calculateDistance(const Point& a, const Point& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble calculateAngle(const Point& a, const Point& b) {\n    return atan2(b.y - a.y, b.x - a.x);\n}\n\ndouble normalizeAngle(double angle) {\n    while (angle < 0) angle += 2 * M_PI;\n    while (angle >= 2 * M_PI) angle -= 2 * M_PI;\n    return angle;\n}\n\nvector<Point> spiralOrder(const vector<Point>& flags) {\n    vector<Point> result;\n    if (flags.empty()) return result;\n\n    set<Point> visited;\n    Point current(0, 0);\n    double currentAngle = M_PI / 2; // Facing north\n\n    result.push_back(current);\n    visited.insert(current);\n\n    while (visited.size() < flags.size() + 1) {\n        Point nextFlag = current;\n        double minAngleDiff = 2 * M_PI;\n        double minDistance = numeric_limits<double>::max();\n        bool found = false;\n\n        for (const auto& flag : flags) {\n            if (visited.find(flag) != visited.end()) continue;\n\n            double angle = calculateAngle(current, flag);\n            double angleDiff = normalizeAngle(currentAngle - angle);\n            angleDiff = 2 * M_PI - angleDiff; // Clockwise\n\n            double distance = calculateDistance(current, flag);\n\n            if (angleDiff < minAngleDiff || \n                (angleDiff == minAngleDiff && distance < minDistance)) {\n                minAngleDiff = angleDiff;\n                minDistance = distance;\n                nextFlag = flag;\n                found = true;\n            }\n        }\n\n        if (!found) break;\n\n        currentAngle = calculateAngle(current, nextFlag);\n        current = nextFlag;\n        result.push_back(current);\n        visited.insert(current);\n    }\n\n    return result;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<Point> flags;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            flags.emplace_back(x, y);\n        }\n\n        vector<Point> path = spiralOrder(flags);\n        double totalDistance = 0.0;\n\n        for (size_t i = 1; i < path.size(); ++i) {\n            totalDistance += calculateDistance(path[i-1], path[i]);\n        }\n\n        cout << static_cast<int>(round(totalDistance)) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <float.h>\n\n#define MAX_FLAGS 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble angle_between_vectors(Point start, Point current, Point target) {\n    double dx1 = current.x - start.x;\n    double dy1 = current.y - start.y;\n    double dx2 = target.x - start.x;\n    double dy2 = target.y - start.y;\n    \n    double dot_product = dx1 * dx2 + dy1 * dy2;\n    double mag1 = sqrt(dx1 * dx1 + dy1 * dy1);\n    double mag2 = sqrt(dx2 * dx2 + dy2 * dy2);\n    \n    double cos_angle = dot_product / (mag1 * mag2);\n    double angle = acos(fmax(-1.0, fmin(1.0, cos_angle)));\n    \n    double cross_product = dx1 * dy2 - dx2 * dy1;\n    return cross_product >= 0 ? angle : 2 * M_PI - angle;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    while (datasets--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        Point flags[MAX_FLAGS];\n        int visited[MAX_FLAGS] = {0};\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &flags[i].x, &flags[i].y);\n        }\n        \n        Point current = {0, 0};\n        Point start = {0, 0};\n        Point direction = {0, 1};  // North\n        double total_distance = 0;\n        \n        for (int visit = 0; visit < n; visit++) {\n            double min_angle = DBL_MAX;\n            int next_flag = -1;\n            \n            for (int i = 0; i < n; i++) {\n                if (!visited[i]) {\n                    double angle = angle_between_vectors(current, current, flags[i]);\n                    double dist = distance(current, flags[i]);\n                    \n                    if (angle < min_angle || \n                        (angle == min_angle && dist < distance(current, flags[next_flag]))) {\n                        min_angle = angle;\n                        next_flag = i;\n                    }\n                }\n            }\n            \n            total_distance += distance(current, flags[next_flag]);\n            current = flags[next_flag];\n            visited[next_flag] = 1;\n            direction = current;\n        }\n        \n        printf(\"%.2f\\n\", total_distance);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble distance(const Point& p1, const Point& p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ndouble calculateAngle(const Point& from, const Point& to) {\n    double dx = to.x - from.x;\n    double dy = to.y - from.y;\n    double angle = atan2(dy, dx);\n    \n    if (angle < 0) angle += 2 * PI;\n    return angle;\n}\n\ndouble findNextCheckpoint(const Point& current, double currentAngle, const vector<Point>& flags, vector<bool>& visited) {\n    double minDiff = numeric_limits<double>::max();\n    int nextIndex = -1;\n    \n    for (int i = 0; i < flags.size(); ++i) {\n        if (visited[i]) continue;\n        \n        double angle = calculateAngle(current, flags[i]);\n        double angleDiff = angle - currentAngle;\n        \n        if (angleDiff < 0) angleDiff += 2 * PI;\n        \n        if (angleDiff < minDiff) {\n            minDiff = angleDiff;\n            nextIndex = i;\n        }\n        else if (abs(angleDiff - minDiff) < 1e-9) {\n            double currDist = distance(current, flags[i]);\n            double minDist = distance(current, flags[nextIndex]);\n            \n            if (currDist < minDist) {\n                nextIndex = i;\n            }\n        }\n    }\n    \n    return nextIndex;\n}\n\ndouble solveSpiralRace(vector<Point>& flags) {\n    Point current(0, 0);\n    double currentAngle = PI / 2;  // Initially facing north\n    vector<bool> visited(flags.size(), false);\n    double totalDistance = 0;\n    \n    while (true) {\n        int nextIndex = findNextCheckpoint(current, currentAngle, flags, visited);\n        \n        if (nextIndex == -1) break;\n        \n        totalDistance += distance(current, flags[nextIndex]);\n        current = flags[nextIndex];\n        currentAngle = calculateAngle(current, Point(current.x, current.y + 1));\n        visited[nextIndex] = true;\n    }\n    \n    return totalDistance;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    cout << fixed << setprecision(2);\n    \n    while (T--) {\n        int N;\n        cin >> N;\n        \n        vector<Point> flags(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> flags[i].x >> flags[i].y;\n        }\n        \n        double result = solveSpiralRace(flags);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y;\n    boolean visited;\n\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n        this.visited = false;\n    }\n\n    double distance(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\n\npublic class SpiralRace {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<Point> flags = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                double x = scanner.nextDouble();\n                double y = scanner.nextDouble();\n                flags.add(new Point(x, y));\n            }\n\n            double totalDistance = 0;\n            Point current = new Point(0, 0);\n            double currentDirection = Math.PI / 2; // Facing north (90 degrees)\n\n            for (int i = 0; i < n; i++) {\n                Point nextFlag = null;\n                double minAngle = Double.MAX_VALUE;\n                double minDistance = Double.MAX_VALUE;\n\n                for (Point flag : flags) {\n                    if (flag.visited) continue;\n                    double dx = flag.x - current.x;\n                    double dy = flag.y - current.y;\n                    double distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance == 0) continue;\n\n                    double angle = Math.atan2(dy, dx);\n                    double relativeAngle = currentDirection - angle;\n                    while (relativeAngle < 0) relativeAngle += 2 * Math.PI;\n                    while (relativeAngle >= 2 * Math.PI) relativeAngle -= 2 * Math.PI;\n\n                    if (relativeAngle < minAngle || \n                        (relativeAngle == minAngle && distance < minDistance)) {\n                        minAngle = relativeAngle;\n                        minDistance = distance;\n                        nextFlag = flag;\n                    }\n                }\n\n                if (nextFlag != null) {\n                    nextFlag.visited = true;\n                    totalDistance += current.distance(nextFlag);\n                    current = nextFlag;\n                    currentDirection = Math.atan2(nextFlag.y - current.y, nextFlag.x - current.x);\n                }\n            }\n\n            System.out.printf(\"%.2f\\n\", totalDistance);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:05:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_angle_and_distance(current, flag):\n    dx = flag[0] - current[0]\n    dy = flag[1] - current[1]\n    distance = math.sqrt(dx ** 2 + dy ** 2)\n    angle = math.atan2(dy, dx)\n    return angle, distance\n\ndef spiral_distance(checkpoints):\n    checkpoints = [(x, y) for x, y in checkpoints]\n    current_pos = (0, 0)\n    current_angle = math.pi / 2  # Initially facing north\n    total_distance = 0\n    visited = set()\n    \n    while checkpoints:\n        best_flag = None\n        smallest_angle_diff = float('inf')\n        best_distance = float('inf')\n\n        for flag in checkpoints:\n            if flag not in visited:\n                angle, distance = calculate_angle_and_distance(current_pos, flag)\n                angle_diff = ((angle - current_angle) + 2 * math.pi) % (2 * math.pi)\n                \n                if (angle_diff < smallest_angle_diff) or \\\n                   (angle_diff == smallest_angle_diff and distance < best_distance):\n                    smallest_angle_diff = angle_diff\n                    best_distance = distance\n                    best_flag = flag\n\n        total_distance += best_distance\n        visited.add(best_flag)\n        checkpoints.remove(best_flag)\n        current_pos = best_flag\n        current_angle = math.atan2(current_pos[1] - current_pos[1], current_pos[0] - current_pos[0])\n\n    return total_distance\n\n# Example usage\ndatasets = [\n    [(1, 2), (3, 4), (5, 0)],\n    [(0, 1), (1, 1), (2, 1)],\n]\n\nresults = [spiral_distance(dataset) for dataset in datasets]\n\n# Should print the total distance for each dataset\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 02:13:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Footrace {\n    static class Flag {\n        int x, y;\n\n        Flag(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        double distance(Flag other) {\n            return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDatasets = scanner.nextInt();\n\n        for (int i = 0; i < numDatasets; i++) {\n            int numFlags = scanner.nextInt();\n            List<Flag> flags = new ArrayList<>();\n            for (int j = 0; j < numFlags; j++) {\n                flags.add(new Flag(scanner.nextInt(), scanner.nextInt()));\n            }\n\n            double totalDistance = findSpiralOrderDistance(flags);\n            System.out.printf(\"%.2f%n\", totalDistance);\n        }\n    }\n\n    private static double findSpiralOrderDistance(List<Flag> flags) {\n        Flag current = new Flag(0, 0);\n        int directionX = 0, directionY = 1; // Initially facing north\n        double totalDistance = 0;\n\n        while (!flags.isEmpty()) {\n            Flag nextFlag = null;\n            double minAngle = Double.MAX_VALUE;\n            double minDistance = Double.MAX_VALUE;\n            for (Flag flag : flags) {\n                int dx = flag.x - current.x;\n                int dy = flag.y - current.y;\n                double angle = calculateAngle(directionX, directionY, dx, dy);\n                double distance = current.distance(flag);\n                if ((angle < minAngle) || (angle == minAngle && distance < minDistance)) {\n                    minAngle = angle;\n                    minDistance = distance;\n                    nextFlag = flag;\n                }\n            }\n\n            totalDistance += current.distance(nextFlag);\n            directionX = nextFlag.x - current.x;\n            directionY = nextFlag.y - current.y;\n            current = nextFlag;\n\n            flags.remove(nextFlag);\n        }\n        return totalDistance;\n    }\n\n    private static double calculateAngle(int directionX, int directionY, int dx, int dy) {\n        double angle = Math.atan2(dy, dx) - Math.atan2(directionY, directionX);\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n}",
    "timestamp": "2025-08-13 02:13:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\n#define PI 3.14159265358979323846\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble calculate_distance(Point a, Point b) {\n    return sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n}\n\ndouble calculate_angle(Point origin, Point direction, Point target) {\n    Point v1 = {direction.x - origin.x, direction.y - origin.y};\n    Point v2 = {target.x - origin.x, target.y - origin.y};\n    double dot_product = v1.x * v2.x + v1.y * v2.y;\n    double mag_v1 = sqrt(v1.x * v1.x + v1.y * v1.y);\n    double mag_v2 = sqrt(v2.x * v2.x + v2.y * v2.y);\n    return acos(dot_product / (mag_v1 * mag_v2));\n}\n\nvoid find_spiral_order(Point flags[], int n, double *total_distance) {\n    Point current = {0.0, 0.0};\n    Point direction = {0.0, 1.0}; // Facing north initially\n    int visited[n];\n    for (int i = 0; i < n; ++i) visited[i] = 0;\n\n    *total_distance = 0.0;\n    for (int i = 0; i < n; ++i) {\n        double min_angle = DBL_MAX;\n        double min_distance = DBL_MAX;\n        int next_index = -1;\n\n        for (int j = 0; j < n; ++j) {\n            if (!visited[j]) {\n                double angle = calculate_angle(current, direction, flags[j]);\n                if (angle < min_angle ||\n                   (angle == min_angle && calculate_distance(current, flags[j]) < min_distance)) {\n                    min_angle = angle;\n                    min_distance = calculate_distance(current, flags[j]);\n                    next_index = j;\n                }\n            }\n        }\n\n        if (next_index != -1) {\n            visited[next_index] = 1;\n            *total_distance += calculate_distance(current, flags[next_index]);\n            current = flags[next_index];\n            direction.x = flags[next_index].x - current.x;\n            direction.y = flags[next_index].y - current.y;\n        }\n    }\n}\n\nint main() {\n    int t, n;\n    scanf(\"%d\", &t); // number of datasets\n\n    for (int dataset = 0; dataset < t; ++dataset) {\n        scanf(\"%d\", &n); // number of flags\n        Point flags[n];\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%lf %lf\", &flags[i].x, &flags[i].y);\n        }\n\n        double total_distance;\n        find_spiral_order(flags, n, &total_distance);\n        printf(\"Dataset %d: Total Distance = %lf\\n\", dataset + 1, total_distance);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:14:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_total_distance(flags):\n    current_pos = (0, 0)\n    current_angle = math.pi / 2  # Facing north initially\n    visited = set()\n    total_distance = 0\n\n    while len(visited) < len(flags):\n        min_angle_diff = float('inf')\n        next_flag = None\n\n        for flag in flags:\n            if flag in visited:\n                continue\n\n            # Calculate angle and distance from current position to flag\n            dx = flag[0] - current_pos[0]\n            dy = flag[1] - current_pos[1]\n            angle_to_flag = math.atan2(dy, dx)\n\n            # Normalize angle difference to clockwise rotation\n            angle_diff = (angle_to_flag - current_angle + 2 * math.pi) % (2 * math.pi)\n\n            # Check if this flag is the best next flag\n            if angle_diff < min_angle_diff or (angle_diff == min_angle_diff and \n               math.hypot(dx, dy) < math.hypot(next_flag[0] - current_pos[0], next_flag[1] - current_pos[1])):\n                min_angle_diff = angle_diff\n                next_flag = flag\n\n        # Move to the next flag\n        total_distance += math.hypot(next_flag[0] - current_pos[0], next_flag[1] - current_pos[1])\n        current_pos = next_flag\n        current_angle = math.atan2(next_flag[1] - current_pos[1], next_flag[0] - current_pos[0])\n        visited.add(next_flag)\n\n    return round(total_distance, 2)\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        flags = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            flags.append((x, y))\n\n        print(f\"{calculate_total_distance(flags):.2f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:14:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_total_distance(datasets):\n    results = []\n    for flags in datasets:\n        if not flags:\n            results.append(0.0)\n            continue\n        \n        total_distance = 0.0\n        current_pos = (0.0, 0.0)\n        remaining_flags = flags.copy()\n        \n        # Initial direction is north (0, 1)\n        current_dir = (0, 1)\n        \n        while remaining_flags:\n            next_flag = None\n            min_angle = float('inf')\n            min_distance = float('inf')\n            \n            for flag in remaining_flags:\n                dx = flag[0] - current_pos[0]\n                dy = flag[1] - current_pos[1]\n                \n                if dx == 0 and dy == 0:\n                    continue\n                \n                # Calculate the angle between current_dir and the vector to the flag\n                angle = math.atan2(current_dir[0] * dy - current_dir[1] * dx, \n                                  current_dir[0] * dx + current_dir[1] * dy)\n                angle = angle % (2 * math.pi)\n                \n                # We want the smallest angle to the right (clockwise)\n                if angle < 0:\n                    angle += 2 * math.pi\n                \n                distance = math.hypot(dx, dy)\n                \n                if angle < min_angle - 1e-9:\n                    min_angle = angle\n                    min_distance = distance\n                    next_flag = flag\n                elif abs(angle - min_angle) < 1e-9:\n                    if distance < min_distance:\n                        min_distance = distance\n                        next_flag = flag\n            \n            if next_flag is None:\n                break\n            \n            total_distance += min_distance\n            current_pos = next_flag\n            remaining_flags.remove(next_flag)\n            \n            # Update direction to the vector from current_pos to next_flag\n            dx = next_flag[0] - current_pos[0]\n            dy = next_flag[1] - current_pos[1]\n            if dx != 0 or dy != 0:\n                current_dir = (dx, dy)\n                # Normalize direction (not necessary but for consistency)\n                norm = math.hypot(current_dir[0], current_dir[1])\n                current_dir = (current_dir[0] / norm, current_dir[1] / norm)\n        \n        results.append(total_distance)\n    \n    return results\n\n# Example usage:\n# datasets = [\n#     [(1, 0), (0, 1), (-1, 0), (0, -1)],\n#     [(1, 1), (2, 2), (3, 3)],\n#     [(5, 5)]\n# ]\n# print(calculate_total_distance(datasets))",
    "timestamp": "2025-08-13 02:14:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstruct Flag {\n    int x, y;\n};\n\nstruct Runner {\n    int x, y;\n    double angle;\n\n    Runner() : x(0), y(0), angle(0) {}\n\n    void moveTo(const Flag& flag) {\n        x = flag.x;\n        y = flag.y;\n    }\n\n    double distanceTo(const Flag& flag) const {\n        return std::hypot(flag.x - x, flag.y - y);\n    }\n\n    double angleTo(const Flag& flag) const {\n        double delta_x = flag.x - x;\n        double delta_y = flag.y - y;\n        return std::atan2(delta_y, delta_x) - angle;\n    }\n};\n\ndouble calculateTotalDistance(const std::vector<Flag>& flags) {\n    Runner runner;\n    double total_distance = 0;\n\n    std::vector<Flag> remainingFlags = flags;\n\n    while (!remainingFlags.empty()) {\n        auto nextFlagIt = std::min_element(\n            remainingFlags.begin(), remainingFlags.end(),\n            [&runner](const Flag& a, const Flag& b) {\n                double angle_a = std::fmod(runner.angleTo(a) + 2 * M_PI, 2 * M_PI);\n                double distance_a = runner.distanceTo(a);\n                double angle_b = std::fmod(runner.angleTo(b) + 2 * M_PI, 2 * M_PI);\n                double distance_b = runner.distanceTo(b);\n                if (std::abs(angle_a - angle_b) < 1e-9) {\n                    return distance_a < distance_b;\n                }\n                return angle_a < angle_b;\n            });\n\n        total_distance += runner.distanceTo(*nextFlagIt);\n        runner.angle = std::atan2(nextFlagIt->y - runner.y, nextFlagIt->x - runner.x);\n        runner.moveTo(*nextFlagIt);\n\n        remainingFlags.erase(nextFlagIt);\n    }\n\n    return total_distance;\n}\n\nint main() {\n    int datasets;\n    std::cin >> datasets;\n\n    for (int i = 0; i < datasets; ++i) {\n        int flagCount;\n        std::cin >> flagCount;\n        std::vector<Flag> flags(flagCount);\n\n        for (int j = 0; j < flagCount; ++j) {\n            std::cin >> flags[j].x >> flags[j].y;\n        }\n\n        double totalDistance = calculateTotalDistance(flags);\n        std::cout << totalDistance << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:50"
  }
]