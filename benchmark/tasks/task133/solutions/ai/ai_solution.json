[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_L 100\n\nint maxScore(int L, char pieces[], char directions[]) {\n    int score = 0;\n    int occupied[MAX_L] = {0};\n    \n    for (int i = 0; i < L; i++) {\n        if (pieces[i] == '1') {\n            occupied[i] = 1;\n        }\n    }\n    \n    for (int i = 0; i < L; i++) {\n        if (pieces[i] == '1') {\n            int best_move = 0;\n            int best_score = -1;\n            for (int move = -1; move <= 1; move += 2) {\n                int new_pos = i + move;\n                if (new_pos >= 0 && new_pos < L && !occupied[new_pos]) {\n                    int current_score = (directions[i] == 'R' && move == 1) ? 1 : \n                                       (directions[i] == 'L' && move == -1) ? 1 : -1;\n                    if (current_score > best_score) {\n                        best_score = current_score;\n                        best_move = move;\n                    }\n                }\n            }\n            if (best_score != -1) {\n                int new_pos = i + best_move;\n                occupied[i] = 0;\n                occupied[new_pos] = 1;\n                score += best_score;\n            }\n        }\n    }\n    \n    return score;\n}\n\nint main() {\n    int L;\n    scanf(\"%d\", &L);\n    \n    char pieces[MAX_L + 1];\n    char directions[MAX_L + 1];\n    \n    scanf(\"%s\", pieces);\n    scanf(\"%s\", directions);\n    \n    printf(\"%d\\n\", maxScore(L, pieces, directions));\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaximumScoreArrangement {\n    public static int maxScore(int L, int[] pieces, char[] directions) {\n        int n = pieces.length;\n        int[][] dp = new int[n + 1][L + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= L; j++) {\n                dp[i][j] = Integer.MIN_VALUE;\n                \n                for (int k = 1; k <= L; k++) {\n                    if (pieces[i - 1] == k) continue;\n                    \n                    int score = 0;\n                    if (Math.abs(k - pieces[i - 1]) == 1) {\n                        if (k < pieces[i - 1] && directions[i - 1] == 'L') score++;\n                        if (k > pieces[i - 1] && directions[i - 1] == 'R') score++;\n                        if (k < pieces[i - 1] && directions[i - 1] == 'R') score--;\n                        if (k > pieces[i - 1] && directions[i - 1] == 'L') score--;\n                    }\n                    \n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + score);\n                }\n            }\n        }\n        \n        int maxScore = Integer.MIN_VALUE;\n        for (int j = 1; j <= L; j++) {\n            maxScore = Math.max(maxScore, dp[n][j]);\n        }\n        \n        return maxScore;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int L = scanner.nextInt();\n        int n = scanner.nextInt();\n        \n        int[] pieces = new int[n];\n        char[] directions = new char[n];\n        \n        for (int i = 0; i < n; i++) {\n            pieces[i] = scanner.nextInt();\n            directions[i] = scanner.next().charAt(0);\n        }\n        \n        int result = maxScore(L, pieces, directions);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:46:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int L, N;\n    cin >> L >> N;\n    vector<pair<int, char>> pieces(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> pieces[i].first >> pieces[i].second;\n    }\n    sort(pieces.begin(), pieces.end());\n\n    vector<int> targets(N);\n    for (int i = 0; i < N; ++i) {\n        if (pieces[i].second == 'R') {\n            targets[i] = L - N + i + 1;\n        } else {\n            targets[i] = i + 1;\n        }\n    }\n\n    long long score = 0;\n    for (int i = 0; i < N; ++i) {\n        int pos = pieces[i].first;\n        int target = targets[i];\n        if (pieces[i].second == 'R') {\n            score += target - pos;\n        } else {\n            score += pos - target;\n        }\n    }\n\n    cout << score << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_L 100\n\nint L;\nchar board[MAX_L + 1];\nchar arrows[MAX_L + 1];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve() {\n    int dp[MAX_L + 1][MAX_L + 1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int len = 1; len <= L; len++) {\n        for (int start = 1; start + len - 1 <= L; start++) {\n            int end = start + len - 1;\n            \n            for (int k = start; k <= end; k++) {\n                if (board[k] == '0') continue;\n\n                int left_score = 0, right_score = 0;\n\n                // Try moving left\n                if (k > start) {\n                    int new_score = (arrows[k] == 'L' ? 1 : -1);\n                    left_score = dp[start][k-1] + dp[k+1][end] + new_score;\n                }\n\n                // Try moving right\n                if (k < end) {\n                    int new_score = (arrows[k] == 'R' ? 1 : -1);\n                    right_score = dp[start][k-1] + dp[k+1][end] + new_score;\n                }\n\n                dp[start][end] = max(dp[start][end], max(left_score, right_score));\n            }\n        }\n    }\n\n    return dp[1][L];\n}\n\nint main() {\n    scanf(\"%d\", &L);\n    scanf(\"%s\", board + 1);\n    scanf(\"%s\", arrows + 1);\n\n    printf(\"%d\\n\", solve());\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint solve(int L, vector<int>& pieces, vector<char>& directions) {\n    int n = pieces.size();\n    vector<vector<int>> dp(n, vector<int>(L + 1, INT_MIN));\n    \n    // Initialize first piece's possible positions\n    for (int j = 1; j <= L; j++) {\n        if (find(pieces.begin(), pieces.end(), j) == pieces.end()) {\n            int score = (directions[0] == 'L' && j < pieces[0]) || \n                        (directions[0] == 'R' && j > pieces[0]) ? 1 : -1;\n            dp[0][j] = score;\n        }\n    }\n    \n    // Dynamic programming to find max score\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j <= L; j++) {\n            if (find(pieces.begin(), pieces.end(), j) == pieces.end()) {\n                for (int k = 1; k <= L; k++) {\n                    if (pieces[i-1] == k) {\n                        if (abs(j - k) == 1) {\n                            int score = (directions[i] == 'L' && j < pieces[i]) || \n                                        (directions[i] == 'R' && j > pieces[i]) ? 1 : -1;\n                            dp[i][j] = max(dp[i][j], dp[i-1][k] + score);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Find maximum score\n    int maxScore = INT_MIN;\n    for (int j = 1; j <= L; j++) {\n        maxScore = max(maxScore, dp[n-1][j]);\n    }\n    \n    return maxScore;\n}\n\nint main() {\n    int L, n;\n    cin >> L >> n;\n    \n    vector<int> pieces(n);\n    vector<char> directions(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> pieces[i] >> directions[i];\n    }\n    \n    cout << solve(L, pieces, directions) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxScorePieces {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int L = scanner.nextInt();\n        int N = scanner.nextInt();\n        int[] positions = new int[N];\n        char[] directions = new char[N];\n        \n        for (int i = 0; i < N; i++) {\n            positions[i] = scanner.nextInt();\n            directions[i] = scanner.next().charAt(0);\n        }\n        \n        Arrays.sort(positions);\n        List<Integer> leftPieces = new ArrayList<>();\n        List<Integer> rightPieces = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            if (directions[i] == 'L') {\n                leftPieces.add(positions[i]);\n            } else {\n                rightPieces.add(positions[i]);\n            }\n        }\n        \n        int score = 0;\n        for (int i = 0; i < leftPieces.size(); i++) {\n            score += leftPieces.get(i) - (i + 1);\n        }\n        for (int i = 0; i < rightPieces.size(); i++) {\n            score += (L - rightPieces.size() + i + 1) - rightPieces.get(i);\n        }\n        \n        System.out.println(score);\n    }\n}",
    "timestamp": "2025-08-05 18:46:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(L, pieces):\n    max_score = 0\n    free_positions = [i for i in range(1, L+1) if i not in pieces]\n    \n    def dfs(score, used_positions, remaining_pieces):\n        nonlocal max_score\n        if not remaining_pieces:\n            max_score = max(max_score, score)\n            return\n\n        piece = remaining_pieces[0]\n        direction = remaining_pieces[piece]\n        for move in [-1, 1]:\n            new_pos = piece + move\n            if new_pos in free_positions and new_pos not in used_positions:\n                new_score = score + (1 if move == direction else -1)\n                dfs(new_score, used_positions | {new_pos}, {p: remaining_pieces[p] for p in remaining_pieces if p != piece})\n    \n    dfs(0, set(), pieces)\n    return max_score\n\n# Example usage\nL = 10\npieces = {2: 1, 5: 1, 7: -1}  # Example pieces configuration\nprint(max_score(L, pieces))",
    "timestamp": "2025-08-13 00:50:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MaximumScore {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int L = scanner.nextInt();\n        String board = scanner.next();\n        scanner.close();\n\n        char[] squares = board.toCharArray();\n        int maxScore = calculateMaxScore(squares, L);\n        System.out.println(maxScore);\n    }\n\n    private static int calculateMaxScore(char[] squares, int L) {\n        // Initialize variables\n        int score = 0;\n\n        // Iterate over the squares array\n        for (int i = 0; i < L; i++) {\n            if (squares[i] == 'L') {\n                if (i > 0 && squares[i - 1] == '.') {\n                    squares[i - 1] = 'L';\n                    squares[i] = '.';\n                    score++;\n                }\n            } else if (squares[i] == 'R') {\n                if (i < L - 1 && squares[i + 1] == '.') {\n                    squares[i + 1] = 'R';\n                    squares[i] = '.';\n                    score++;\n                }\n            }\n        }\n\n        for (int i = 0; i < L; i++) {\n            if (squares[i] == 'L') {\n                if (i < L - 1 && squares[i + 1] == '.') {\n                    squares[i + 1] = 'L';\n                    squares[i] = '.';\n                    score--;\n                }\n            } else if (squares[i] == 'R') {\n                if (i > 0 && squares[i - 1] == '.') {\n                    squares[i - 1] = 'R';\n                    squares[i] = '.';\n                    score--;\n                }\n            }\n        }\n\n        return score;\n    }\n}",
    "timestamp": "2025-08-13 00:51:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_L 100\n\nint maxScore(int L, char *arrangement) {\n    char current[MAX_L + 1];\n    strcpy(current, arrangement);\n\n    int score = 0;\n    for (int i = 1; i <= L; i++) {\n        if (current[i - 1] == '>') {\n            if (i < L && current[i] == '.') {\n                current[i - 1] = '.';\n                current[i] = '>';\n                score += 1;\n            } else if (i > 1 && current[i - 2] == '.') {\n                current[i - 1] = '.';\n                current[i - 2] = '>';\n                score -= 1;\n            }\n        } else if (current[i - 1] == '<') {\n            if (i > 1 && current[i - 2] == '.') {\n                current[i - 1] = '.';\n                current[i - 2] = '<';\n                score += 1;\n            } else if (i < L && current[i] == '.') {\n                current[i - 1] = '.';\n                current[i] = '<';\n                score -= 1;\n            }\n        }\n    }\n    \n    return score;\n}\n\nint main() {\n    int L;\n    char arrangement[MAX_L + 1];\n\n    scanf(\"%d\", &L);\n    scanf(\"%s\", arrangement);\n\n    printf(\"%d\\n\", maxScore(L, arrangement));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:51:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(L, pieces):\n    def solve(state, visited):\n        if state in visited:\n            return float('-inf')\n        visited.add(state)\n        \n        best_score = float('-inf')\n        for i, (pos, direction) in enumerate(state):\n            for new_pos in [pos-1, pos+1]:\n                if 1 <= new_pos <= L and new_pos not in [p for p, _ in state]:\n                    new_state = list(state)\n                    new_state[i] = (new_pos, direction)\n                    new_state.sort()\n                    \n                    score_change = 1 if new_pos - pos == direction else -1\n                    sub_score = solve(tuple(new_state), visited)\n                    \n                    best_score = max(best_score, score_change + sub_score)\n        \n        return 0 if best_score == float('-inf') else best_score\n    \n    initial_state = tuple(sorted(pieces))\n    return solve(initial_state, set())",
    "timestamp": "2025-08-13 00:51:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_max_score(L, pieces):\n    # Separate pieces into left and right pointers\n    left = []\n    right = []\n    for pos, direction in pieces:\n        if direction == 'L':\n            left.append(pos)\n        else:\n            right.append(pos)\n    \n    left.sort()\n    right.sort()\n    \n    max_score = 0\n    \n    # Calculate the score for right-pointing pieces\n    # They want to move to higher positions (right)\n    # The optimal is to move them to the rightmost available positions\n    available_positions = [i for i in range(1, L + 1) if i not in [p[0] for p in pieces]]\n    available_positions.sort()\n    \n    # Assign right-pointing pieces to the highest available positions to their right\n    r_ptr = 0\n    a_ptr = 0\n    m = len(right)\n    n = len(available_positions)\n    \n    while r_ptr < m and a_ptr < n:\n        if right[r_ptr] < available_positions[a_ptr]:\n            max_score += 1\n            r_ptr += 1\n            a_ptr += 1\n        else:\n            a_ptr += 1\n    \n    # Assign left-pointing pieces to the lowest available positions to their left\n    left_ptr = len(left) - 1\n    available_ptr = len(available_positions) - 1\n    \n    while left_ptr >= 0 and available_ptr >= 0:\n        if left[left_ptr] > available_positions[available_ptr]:\n            max_score += 1\n            left_ptr -= 1\n            available_ptr -= 1\n        else:\n            available_ptr -= 1\n    \n    return max_score",
    "timestamp": "2025-08-13 00:51:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint calculateMaxScore(int L, string arrangement) {\n    int maxScore = 0;\n    int n = arrangement.size();\n    vector<int> arrows, positions;\n    \n    // Parse the arrangement to separate arrows and initial positions\n    for (int i = 0; i < n; ++i) {\n        char c = arrangement[i];\n        if (c == '>' || c == '<') {\n            arrows.push_back(c == '>' ? 1 : -1);\n            positions.push_back(i + 1);\n        }\n    }\n\n    unordered_map<int, int> posArrowMap;\n    for (int i = 0; i < positions.size(); ++i) {\n        posArrowMap[positions[i]] = arrows[i];\n    }\n\n    // Dynamic programming to calculate maximum score\n    vector<int> dp(L + 1, 0);\n    for (int i = 1; i <= L; ++i) {\n        dp[i] = dp[i - 1];\n        if (posArrowMap.count(i)) {\n            int arrow = posArrowMap[i];\n            // Calculate max score if moved left or right\n            if (i > 1) {\n                dp[i] = max(dp[i], dp[i - 1] + (arrow == -1 ? 1 : -1));\n            }\n            if (i < L) {\n                dp[i] = max(dp[i], dp[i] + (arrow == 1 ? 1 : -1));\n            }\n        }\n    }\n    maxScore = dp[L];\n    return maxScore;\n}\n\nint main() {\n    int L;\n    string arrangement;\n    cin >> L >> arrangement;\n    cout << calculateMaxScore(L, arrangement) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:18"
  }
]