[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  val Array(n, l) = readLine.trim.split(' ').map(_.toInt)\n  val pawns = Array.fill(n){\n    readLine.trim.split(' ').map(_.toInt) match {\n      case Array(pos, 0) ⇒ Left(pos)\n      case Array(pos, 1) ⇒ Right(pos)\n    }\n  }.sortBy(_.position)\n  var currentScore = 0L\n  val forward = Array.fill(n){0L}\n  for (i ← pawns.indices) {\n    pawns(i) match {\n      case Left(pos) ⇒\n        currentScore += pos - i - 1\n      case Right(pos) ⇒\n        currentScore += i - pos + 1\n    }\n    forward(i) = currentScore\n  }\n  currentScore = 0L\n  val backward = Array.fill(n){0L}\n  for (i ← pawns.indices.reverse) {\n    pawns(i) match {\n      case Left(pos) ⇒\n        currentScore += pos - (l - (n - i - 1))\n      case Right(pos) ⇒\n        currentScore += (l - (n - i - 1)) - pos\n    }\n    backward(i) = currentScore\n  }\n  var min = math.max(forward.last, backward.head)\n  for (i ← pawns.indices.tail) {\n    min = math.max(min, forward(i - 1) + backward(i))\n  }\n  println(min)\n  sealed class Pawn(val position: Int)\n  case class Left(override val position: Int) extends Pawn(position)\n  case class Right(override val position: Int) extends Pawn(position)\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, l;\nlong long m = 0;\nint a[100000];\n\nint main()\n{\n\tcin >> n >> l;\n\n\tvector<pair<int, int>> p(n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> p[i].first >> p[i].second;\n\n\tsort(p.begin(), p.end());\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (p[i].second == 0)\n\t\t\tm += p[i].first - i - 1;\n\t\telse\n\t\t\tm -= p[i].first - i - 1;\n\t}\n\n\tlong long m1 = m;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (p[n - i - 1].second == 1)\n\t\t\tm1 += l - n;\n\t\telse\n\t\t\tm1 -= l - n;\n\n\t\tif (m1 > m)\n\t\t\tm = m1;\n\t}\n\n\tcout << m << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n    vector<pii> vp(N);\n    rep(i, N) {\n        int p, d;\n        cin >> p >> d;\n        vp[i] = MP(p, d);\n    }\n    sort(All(vp));\n    ll res = 0;\n    rep(i, N) {\n        if(vp[i].second == 0) {\n            res += vp[i].first - (i + 1);\n        } else {\n            res -= vp[i].first - (i + 1);\n        }\n    }\n    ll tmp = res;\n    int c = 0;\n    for(int i = N - 1; i >= 0; i--) {\n        if(vp[i].second == 0) {\n            tmp -= L - c - (i + 1);\n        } else {\n            tmp += L - c - (i + 1);\n        }\n        c++;\n        res = max(res, tmp);\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define LL long long\n\nLL N, L;\nLL p[100010];\nLL d[100010];\nsigned main(){\n    cin.tie(0); \n    ios::sync_with_stdio(false);\n    cin >> N >> L;\n    vector<pair<int, int>> v(N);\n    /** 前処理 **/\n    /**\n      すべての矢印を位置の昇順で整列し、i番目までの矢印をすべて左に詰めたときのスコアを動的計画法で求めておく。右へ詰める方向も同様に求めておく。\n      **/\n    for(int i=0; i<N; i++){\n        cin >> v[i].first >> v[i].second;\n    }\n    sort(v.begin(), v.end());\n    for(int i=0; i<N; i++){\n        p[i] = v[i].first;\n        d[i] = v[i].second;\n    }\n\n    LL ans = 0;\n    LL tmp = 0;\n    for(int i=0; i<N; i++){\n        tmp += (p[i]-(i+1)) * (d[i] == 0 ? 1 : -1);\n    }\n    ans = tmp;\n    for(int i=0; i<N; i++){\n        tmp += ((L-i)-(N-i)) * (d[N-i-1] == 1 ? 1 : -1);\n        ans = max(ans, tmp);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int int64_t\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define reps(i, a, n) for (int i = (n - 1); i > (a - 1); --i)\n#define arep(i, x) for (auto &&i : (x))\ntemplate <class A, class B>\nbool chmax(A &a, const B &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class A, class B>\nbool chmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nusing P = pair<int, int>;\n#define all(x) (x).begin(), (x).end()\nconstexpr int inf = 0x3f3f3f3f;\n\nsigned main() {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n\n  int N, L;\n  cin >> N >> L;\n  vector<P> a;\n  rep(i, 0, N) {\n    int p, d;\n    cin >> p >> d;\n    a.emplace_back(p, d * 2 - 1);\n  }\n  sort(all(a));\n  // arep(i, a) cout << i.first << ' ' << i.second << '\\n';\n\n  int ans = 0;\n  int now = 0;\n\n  rep(i, 0, N) now -=\n      (a[i].first - (i + 1)) * a[i].second;  // cout << now << ' ';\n  // cout << '\\n';\n  ans = now;\n  reps(i, 0, N) {\n    now += (L - N) * a[i].second;\n    chmax(ans, now);\n    // cout << now << ' ';\n  }\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nint main(void) {\n  ll i, j, n, l, ans = 0, now = 0;\n  scanf(\"%lld%lld\", &n, &l);\n  pair<ll, ll> p[n];\n  for(i = 0; i < n; ++i) scanf(\"%lld%lld\", &p[i].first, &p[i].second);\n  sort(p, p + n);\n  for(i = 0; i < n; ++i) {\n    if(p[i].second) now -= p[i].first - i - 1;\n    else now += p[i].first - i - 1;\n  }\n  if(ans < now) ans = now;\n  for(i = n - 1; i >= 0; --i) {\n    if(p[i].second) now += l - n;\n    else now -= l - n;\n    if(ans < now) ans = now;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n\n    var(int, N, L);\n\n    vector<pair<int, int>> vs(N);\n    rep(i, 0, N) {\n        var(intmax_t, p, d);\n        vs[i] = {p, d};\n    }\n\n    sort(all(vs));\n\n    vector<int> ps(N), ds(N);\n    rep(i, 0, N) {\n        ps[i] = vs[i].first, ds[i] = vs[i].second;\n    }\n\n    vector<intmax_t> go_left(N);\n    rep(i, 0, N) {\n        intmax_t value;\n        if (ds[i] == 0) {\n            value = ps[i] - 1 - i;\n        } else {\n            value = 1 - ps[i] + i;\n        }\n        if (i == 0) go_left[i] = value;\n        else go_left[i] = go_left[i - 1] + value;\n    }\n\n    vector<intmax_t> go_right(N);\n    repr(i, N - 1, 0) {\n        intmax_t value;\n        if (ds[i] == 1) {\n            value = L - ps[i] - (N - 1 - i);\n        } else {\n            value = ps[i] - L + (N - 1 - i);\n        }\n        if (i == N - 1) go_right[i] = value;\n        else go_right[i] = go_right[i + 1] + value;\n    }\n\n    intmax_t res = -INF;\n    chmax(res, go_right[0]);\n    rep(l, 0, N - 1) {\n        chmax(res, go_left[l] + go_right[l + 1]);\n    }\n    chmax(res, go_left[N - 1]);\n\n    output(res);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, l;\n    cin >> n >> l;\n    vector<pair<int,int>> vp;\n    for(int i = 0; i < n; i++){\n        int p, d;\n        cin >> p >> d;\n        vp.push_back({p, d});\n    }\n    sort(vp.begin(), vp.end());\n    vector<ll> dpl(n), dpr(n);\n    for(int i = 0; i < n; i++){\n        dpl[i] = (i==0 ? 0 : dpl[i-1]) + (vp[i].second==0 ? 1 : -1)*(vp[i].first-i-1);\n    }\n    for(int i = n-1; i >= 0; i--){\n        dpr[i] = (i==n-1 ? 0 : dpr[i+1]) + (vp[i].second==1 ? 1 : -1)*(l-(n-1-i)-vp[i].first);\n    }\n    ll ans = max(dpl.back(), dpr[0]);\n    for(int i = 0; i+1 < n; i++){\n        ans = max(ans, dpl[i]+dpr[i+1]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n\nLL N, L;\nLL p[100000], d[100000];\nint main(){\n\tcin >> N >> L;\n\tvector<pair<int, int>> v(N);\n\tfor(int i=0; i<N; i++) cin >> v[i].first >> v[i].second;\n\tsort(v.begin(), v.end());\n\tfor(int i=0; i<N; i++){\n\t\tp[i] = v[i].first;\n\t\td[i] = v[i].second;\n\t}\n\n\tLL ans = 0;\n\tLL tmp = 0;\n\tfor(int i=0; i<N; i++){\n\t\ttmp += (p[i]-(i+1)) * (d[i] == 0 ? 1 : -1);\n\t}\n\tans = tmp;\n\tfor(int i=0; i<N; i++){\n\t\ttmp += ((L-i)-(N-i)) * (d[N-i-1] == 1 ? 1 : -1);\n\t\tans = max(ans, tmp);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long lint;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n// 全ての駒は最終的に左端か右端に移動すると考える\nint main() {\n    lint n,l; cin >> n >> l;\n    pair<lint,lint> pd[100000];\n    rep(i,n) {\n        cin >> pd[i].first >> pd[i].second;\n    }\n    sort(pd,pd+n);\n    lint leftcsum[100001];\n    lint rightcsum[100001];\n    leftcsum[0] = 0;\n    rightcsum[0] = 0;\n    rep(i, n) {\n        lint dis = pd[i].first - (i+1);\n        if (pd[i].second == 0) leftcsum[i+1] = leftcsum[i] + dis;\n        else leftcsum[i+1] = leftcsum[i] - dis;\n\n        dis = (l-n+i+1) - pd[i].first;\n        if (pd[i].second == 1) rightcsum[i+1] = rightcsum[i] + dis;\n        else rightcsum[i+1] = rightcsum[i] - dis;\n    }\n    lint ans = 0;\n    rep(i,n+1) {\n        lint t = leftcsum[i] + rightcsum[n] - rightcsum[i];\n        ans = max(ans, t);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 100005\n\nstruct Info{\n\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn loc < arg.loc;\n\t}\n\n\tll loc,dir;\n};\n\nint N;\nll L;\nll left_dp[SIZE],right_dp[SIZE];\nInfo info[SIZE];\n\n\nint main(){\n\n\tscanf(\"%d %lld\",&N,&L);\n\tL--;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld %lld\",&info[i].loc,&info[i].dir);\n\t\tinfo[i].loc--;\n\t}\n\n\tsort(info,info+N);\n\n\tleft_dp[0] = 0;\n\n\t//i番目まで左詰めした時の、左端方向の得点\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(info[i].dir == 0){ //左向き\n\n\t\t\tleft_dp[i+1] = left_dp[i]+(info[i].loc-i);\n\n\t\t}else{ //右向き\n\n\t\t\tleft_dp[i+1] = left_dp[i]-(info[i].loc-i);\n\t\t}\n\t}\n\n\tright_dp[N] = 0;\n\n\t//i番目まで右詰めした時の、右端方向の得点\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\tif(info[i].dir == 0){ //左向き\n\n\t\t\tright_dp[i] = right_dp[i+1]-((L-(N-1-i))-info[i].loc);\n\n\t\t}else{ //右向き\n\n\t\t\tright_dp[i] = right_dp[i+1]+((L-(N-1-i))-info[i].loc);\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i <= N; i++){\n\n\t\tans = max(ans,left_dp[i]+right_dp[i]);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n, l;\n  cin >> n >> l;\n  vector<pair<int, int>> pd(n);\n  int i, j;\n  for (i = 0; i < n; i++) {\n    cin >> pd[i].first >> pd[i].second;\n  }\n  sort(pd.begin(), pd.end());\n  long long score = 0, result = 0;\n  for (i = 0; i < n; i++) {\n    score += (pd[i].second ? -(pd[i].first - i - 1) : pd[i].first - i - 1);\n    result = max(result, score);\n  }\n  for (i = n - 1; i >= 0; i--) {\n    score += (pd[i].second ? l - n : -(l - n));\n    result = max(result, score);\n  }\n  result = max(result, score);\n  cout << result << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nint main(){\n\tLL n,l;\tcin>>n>>l;\n\tvector< pair<LL,char> > data(n);\n\tfor(LL i=0;i<n;i++){\n\t\tLL p,d;\tcin>>p>>d;\n\t\tchar dir=(d==1? 'R':'L');\n\t\tdata[i]={p,dir};\n\t}\n\tsort(data.begin(), data.end());\n\n\tvector<LL> L(n), R(n);\n\tfor(LL i=0;i<n;i++){\n\t\tL[i]=(abs(data[i].first-1)-i) * (data[i].second=='L'? 1:-1);\n\t\tR[i]=(abs(l-data[i].first)-(n-i-1)) * (data[i].second=='R'? 1:-1);\n\t}\n\n\tfor(LL i=1; i<n; i++){\n\t\tL[i]+=L[i-1];\n\t}\n\tfor(LL i=n-2; i>=0; i--){\n\t\tR[i]+=R[i+1];\n\t}\n\n\tLL ans=0;\n\tfor(LL i=0; i+1<n; i++){\n\t\tans=max(ans, L[i]+R[i+1]);\n\t}\n\tans=max(ans,max(L[n-1], R[0]));\n\n\t//for(int i=0;i<n;i++){\n\t//\tcout<<\"[\"<<i<<\"] \"<<\"L=\"<<L[i]<<\", \"<<\"R=\"<<R[i]<<endl;\n\t//}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//17:00~\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\t\n\tllint n,L,i,ans=0,gen=0;cin>>n>>L;\n\tvector<pair<llint,int>>koma(n);\n\tfor(i=0;i<n;i++){cin>>koma[i].fir>>koma[i].sec;koma[i].sec*=2;koma[i].sec--;}\n\tSO(koma);\n\tfor(i=0;i<n;i++){gen-=(koma[i].fir-i-1)*koma[i].sec;}ans=gen;\n\tfor(i=n-1;i>=0;i--){gen+=(L-n)*koma[i].sec;maxeq(ans,gen);}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = INT_MAX / 2; const ll INF = LLONG_MAX / 2;\n//template end\n\n\n\nint main(){\n    int n,l; scanf(\"%d%d\",&n,&l);\n    vector<P> a(n);\n    rep(i,0,n)scanf(\"%d%d\",&a[i].first,&a[i].second);\n    sort(ALL(a));\n    ll sum[100010]={},pre[100010]={};\n    rep(i,0,n){\n        int diff=i+1-a[i].first;\n        if(a[i].second==0)diff*=-1;\n        sum[i+1]=sum[i]+diff;\n    }\n    rrep(i,n-1,-1){\n        int diff=l-n+i+1-a[i].first;\n        if(a[i].second==0)diff*=-1;\n        pre[i]=pre[i+1]+diff;\n    }\n    ll ans=0;\n    rep(i,0,n+1)chmax(ans,sum[i]+pre[i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <iomanip>\n//#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n//#include <set>\n//#include <map>\n//#include <stack>\n//#include <deque>\n//#include <bitset>\n//#include <math.h>\nusing namespace std ;\nusing ll = long long ;\n//using ld = long double ;\nusing vll = vector<ll> ;\n//using vvll = vector<vll> ;\n//using vc = vector<char> ;\n//using vvc = vector<vc> ;\n//using vb = vector<bool> ;\n//using vvb = vector<vb> ;\nusing pll = pair<ll,ll> ;\n\n//ll mod = 1000000007 ;\n//long double pie = acos(-1) ;\n\n//void yorn(bool a){if(a) cout << \"Yes\" << endl ; else cout << \"No\" << endl ;}\n//void YorN(bool a){if(a) cout << \"YES\" << endl ; else cout << \"NO\" << endl ;}\nll gcd(long long a,long long b){if(b==0) return a ; return gcd(b,a%b) ;}\nll lcm(long long a,long long b){return a/gcd(a,b)*b ;}\n//ll sa(long long a,long long b){if(a>b) return a-b ; return b-a ;}\nvoid mysort(vector<pll> &a){sort(a.begin(),a.end()) ;}\n//void myrev(vector<long long> &a){reverse(a.begin(),a.end()) ;}\n\nint main(){\n\tll n,l ;\n\tcin >> n >> l ;\n\tvector<pll> p(n) ;\n\tfor(int i=0;i<n;i++){\n\t\tll a,b ;\n\t\tcin >> a >> b ;\n\t\tp.at(i) = make_pair(a,b) ;\n\t}\n\tll ans = 0 ;\n\tll cnt_r = 0,cnt_l = 0 ;\n\tmysort(p) ;\n\tfor(int i=0;i<n;i++){\n\t\tif(p.at(i).second==0){\n\t\t\tif(i==0){\n\t\t\t\tans += p.at(i).first-1 ;\n\t\t\t\tp.at(i).first = 1 ;\n\t\t\t}else{\n\t\t\t\tif(cnt_r==cnt_l+1){\n\t\t\t\t\tans += p.at(i).first-p.at(i-1).first-1 ;\n\t\t\t\t\tp.at(i).first = i+1 ;\n\t\t\t\t\tcnt_r = cnt_l = 0 ;\n\t\t\t\t}else if(cnt_r==0){\n\t\t\t\t\tans += p.at(i).first-(i+1) ;\n\t\t\t\t\tp.at(i).first = i+1 ;\n\t\t\t\t\tcnt_r = cnt_l = 0 ;\n\t\t\t\t}else{\n\t\t\t\t\tcnt_l++ ;\n\t\t\t\t\tif(i==n-1){\n\t\t\t\t\t\tans += (cnt_r-cnt_l)*(l-p.at(i).first) ;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans += (cnt_r-cnt_l)*(p.at(i+1).first-p.at(i).first-1) ;\n\t\t\t\t\t\tp.at(i).first = p.at(i+1).first-1 ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcnt_r++ ;\n\t\t\tif(i==n-1) ans += (l-p.at(i).first)*(cnt_r-cnt_l) ;\n\t\t\telse{\n\t\t\t\tans += (p.at(i+1).first-p.at(i).first-1)*(cnt_r-cnt_l) ;\n\t\t\t\tp.at(i).first = p.at(i+1).first-1 ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long //int64_t\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define reps(i, a, n) for (int i = (n - 1); i > (a - 1); --i)\n#define arep(i, x) for (auto &&i : (x))\ntemplate <class A, class B>\nbool chmax(A &a, const B &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class A, class B>\nbool chmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nusing P = pair<int, int>;\n#define all(x) (x).begin(), (x).end()\nconstexpr int inf = 0x3f3f3f3f;\n \nsigned main() {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n \n  int N, L;\n  cin >> N >> L;\n  vector<P> a;\n  rep(i, 0, N) {\n    int p, d;\n    cin >> p >> d;\n    a.emplace_back(p, d * 2 - 1);\n  }\n  sort(all(a));\n \n  int ans = 0;\n  int now = 0;\n \n  rep(i, 0, N) now -= (a[i].first - (i + 1)) * a[i].second;\n  ans = now;\n  reps(i, 0, N) {\n    now += (L - N) * a[i].second;\n    chmax(ans, now);\n  }\n \n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 100005\n\nstruct Info{\n\n\tbool operator<(const struct Info &arg) const{\n\n\t\treturn loc < arg.loc;\n\t}\n\n\tll loc,dir;\n};\n\nint N;\nll L;\nll left_dp[SIZE],right_dp[SIZE];\nInfo info[SIZE];\n\n\nint main(){\n\n\tscanf(\"%d %lld\",&N,&L);\n\tL--;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld %lld\",&info[i].loc,&info[i].dir);\n\t\tinfo[i].loc--;\n\t}\n\n\tsort(info,info+N);\n\n\tleft_dp[0] = 0;\n\n\t//i番目まで左詰めした時の、左端方向の得点\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(info[i].dir == 0){ //左向き\n\n\t\t\tleft_dp[i+1] = left_dp[i]+(info[i].loc-i);\n\n\t\t}else{ //右向き\n\n\t\t\tleft_dp[i+1] = left_dp[i]-(info[i].loc-i);\n\t\t}\n\t}\n\n\tright_dp[N] = 0;\n\n\t//i番目まで右詰めした時の、右端方向の得点\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\tif(info[i].dir == 0){ //左向き\n\n\t\t\tright_dp[i] = right_dp[i+1]-((L-(N-1-i))-info[i].loc);\n\n\t\t}else{ //右向き\n\n\t\t\tright_dp[i] = right_dp[i+1]+((L-(N-1-i))-info[i].loc);\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i <= N; i++){\n\n\t\tans = max(ans,left_dp[i]+right_dp[i]);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing ll = long long int;\nusing namespace std;\nint main() {\n    ll N, L; scanf(\"%lld%lld\", &N, &L);\n\n    vector< pair<int, int> > rooks;\n    for(int i=0; i<N; i++) {\n        int p, d; scanf(\"%d%d\", &p, &d);\n        rooks.emplace_back(p, d);\n    }\n    sort(rooks.begin(), rooks.end());\n\n    vector<ll> S1(N+2), S2(N+2);\n    for(int i=0; i<N; i++) {\n        ll d = rooks[i].first - (i + 1);\n        ll r = rooks[i].second;\n        if(d > 0) {\n            if(r == 0) S1[i+1] = S1[i] + d;\n            if(r == 1) S1[i+1] = S1[i] - d;\n        }\n        else {\n            d = -d;\n            if(r == 0) S1[i+1] = S1[i] - d;\n            if(r == 1) S1[i+1] = S1[i] + d;\n        }\n    }\n    for(int i=N-1; i>=0; i--) {\n        ll d = rooks[i].first - (L - (N - 1 - i));\n        // fprintf(stderr, \"i = %d, d = %lld\\n\", i, d);\n        ll r = rooks[i].second;\n        if(d > 0) {\n            if(r == 0) S2[i+1] = S2[i+2] + d;\n            if(r == 1) S2[i+1] = S2[i+2] - d;\n        }\n        else {\n            d = -d;\n            if(r == 0) S2[i+1] = S2[i+2] - d;\n            if(r == 1) S2[i+1] = S2[i+2] + d;\n        }\n    }\n\n    ll ans = 0;\n    for(int i=0; i<=N; i++) {\n        // fprintf(stderr, \"S1[%d] = %lld, S2[%d] = %lld\\n\", i, S1[i], i+1, S2[i+1]);\n        ans = max(ans, S1[i] + S2[i+1]);\n    }\n    printf(\"%lld\\n\", ans);\n    \n    /*\n    rooks.emplace_back(0, 0);\n    rooks.emplace_back(L+1, 1);\n    sort(rooks.begin(), rooks.end());\n\n    vector< pair< int, vector<int> > > rle;\n    for(size_t i=0; i<rooks.size(); i++) {\n        int p, d; tie(p, d) = rooks[i];\n        if(rle.empty() or rle.back().first != d) {\n            rle.emplace_back(d, vector<int>(1, p));\n        }\n        else rle.back().second.emplace_back(p);\n    }\n\n    for(auto e : rle) {\n        auto v = e.second;\n        for(auto x : v) cerr << x << \" \";\n        cerr << endl;\n    }\n    \n    ll ans = 0;\n    for(size_t i=0; i<rle.size(); i++) {\n        int d = rle[i].first;\n        if(d == 0) {\n            int p = rle[i].second.front();\n            for(size_t j=0; j<rle[i].second.size(); j++) {\n                int t = p + j;\n                ans += rle[i].second[j] - t;\n            }\n        }\n        if(d == 1) {\n            int p = rle[i].second.back();\n            int M = rle[i].second.size();\n            for(size_t j=0; j<rle[i].second.size(); j++) {\n                int t = p - j;\n                ans += t - rle[i].second[M-1-j];\n            }\n        }\n    }\n    \n    // RL RL ...\n    for(size_t i=1; i+1<rle.size(); i+=2) {\n        ll r = rle[i].second.back();\n        ll l = rle[i+1].second.front();\n        ans += (l - r - 1) * max(rle[i].second.size(),\n                                 rle[i+1].second.size());\n    }\n\n    printf(\"%lld\\n\", ans);\n    */\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tint N,L;\n\tcin >> N >> L;\n\tvector<pair<int,int> > PD(N);\n\tint i;\n\tfor(i=0;i<N;i++)cin >> PD[i].first >> PD[i].second;\n\tsort(PD.begin(),PD.end());\n\tvector<int> cntR(N+1),cntL(N+1);\n\tcntR[0] = cntL[0] = 0;\n\tfor(i=0;i<N;i++) {\n\t\tcntR[i+1] = cntR[i] + PD[i].second;\n\t\tcntL[i+1] = cntL[i] + 1-PD[N-i-1].second;\n\t}\n\tint point = 0;\n\tfor(i=1;i<=N;i++)if(cntR[i]+cntL[N-i] < cntR[point]+cntL[N-point])point = i;\n\tlong long ans = 0;\n\tfor(i=0;i<point;i++)ans += (PD[i].first-i-1)*(PD[i].second == 0?1:-1);\n\tfor(i=N-1;i>=point;i--)ans += (L-(N-i-1)-PD[i].first)*(PD[i].second == 1?1:-1);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvoid solve()\n{\n    int n, l;\n    cin >> n >> l;\n    vector<pair<int, int>> ps(n);\n    for (auto &p : ps)\n    {\n        cin >> p.first >> p.second;\n        p.first--;\n    }\n    sort(ps.begin(), ps.end());\n    //i番目以降を全て右に寄せた時のスコア\n    vector<long> rs(n + 1);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        int rbound = l - (n - 1 - i) - 1;\n        if (ps[i].second)\n        {\n            rs[i] = rs[i + 1] + rbound - ps[i].first;\n        }\n        else\n        {\n            rs[i] = rs[i + 1] - rbound + ps[i].first;\n        }\n        //cout << rs[i] << ' ';\n    }\n    //cout << endl;\n    long ans = max(0L, rs[0]), lscore = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (ps[i].second)\n        {\n            lscore -= ps[i].first - i;\n        }\n        else\n        {\n            lscore += ps[i].first - i;\n        }\n        ans = max(ans, rs[i + 1] + lscore);\n        //cout << lscore << ' ';\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int (i)=(a);(i)<(n);++(i))\n#define eFOR(i,a,n) for(int (i)=(a);(i)<=(n);++(i))\n#define rFOR(i,a,n) for(int (i)=(n)-1;(i)>=(a);--(i))\n#define erFOR(i,a,n) for(int (i)=(n);(i)>=(a);--(i))\n#define each(i, a) for(auto &i : a)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\n#define out(y,x) ((y) < 0 || h <= (y) || (x) < 0 || w <= (x))\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& elemnt : v)is >> elemnt; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& elemnt : v)is >> elemnt; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\n\nint main() {\n    init();\n\n    int n; ll m; cin >> n >> m;\n    vector<pair<int, ll>> pd(n); cin >> pd;\n\n    SORT(pd);\n    ll ans = 0;\n    FOR(i, 0, n) {\n        if (pd[n - 1 - i].second == 0)ans -= m - i - pd[n - 1 - i].first;\n        else ans += m - i - pd[n - 1 - i].first;\n    }\n\n\n    ll cap = m - n;\n    int r = 0, l = 0;\n    FOR(i, 0, n) {\n        if (pd[i].second == 0)++l;\n        else ++r;\n        if (l > r) {\n            ans += cap * (l - r);\n            l = r = 0;\n        }\n    }\n\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[100001];\n\nint64_t solve(const int N, const int L){\n\tint64_t score = 0;\n\t\n\tmap<int,int> mp;\n\n\tfor(int x=1; x<=N; ++x){\n\t\tint pos;\n\t\tcin >> pos;\n\t\tcin >> mp[pos];\n\t}\n\n\tint x=1;\n\tfor(auto e: mp){\n\t\tint pos = e.first;\n\t\td[x] = e.second;\n\t\tscore += (pos - x) * (d[x]==0?1:-1);\n\t\t++x;\n\t}\n\n\tint64_t best = score;\n\tfor(int x=N,l=L; x>0; --x,--l){\n\t\tscore += (l - x) * (d[x]==0?-1:1);\n\t\tbest = max(best, score);\n\t}\n\treturn best;\n}\n\nint main(){\n\tint N,L;\n\tcin>>N>>L;\n\tcout<<solve(N,L)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (((a)%mod) * ((b)%mod)) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define dmt(x, y, z) make_tuple(x, y, z)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T, typename U, typename V>\nostream &operator<<(ostream &os, const tuple<T, U, V> &t){\n  os << \"(\" << get<0>(t) << \",\" << get<1>(t) << \",\" << get<2>(t) << \")\";\n  return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n  }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef tuple<int, int, int> TT;\ntypedef pair<int, TT> PT;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n// int sum = accumulate(a, a+n, 0LL);\n// int mx = max_element(a, a+n);\n// int mn = min_element(a, a+n);\n// int cnt = count(a, a+n, k);\n\n\nint a[200000], b[200000];\nP p[200000];\nsigned main(){\n  // 入力\n  int n, l;\n  cin >> n >> l;\n  rep(i,n){\n    int x, y;cin >> x >> y;\n    p[i] = P(x, y);\n  }\n  sort(p, p+n);\n  rep(i,n){a[i] = p[i].fi;b[i] = p[i].se;}\n  a[n] = l+1;b[n] = 1;\n  n++;\n  \n  int last = 0;   // 左の塊の一番右の位置\n  int ans = 0;    // 得点\n  int pos = 0;\n  int right = 0;    // 右向きの駒の数\n  int left = 0;    // 左向きの駒の数\n  rep(i,n){\n    ans += (right-left)*(a[i]-pos-1);\n    if(b[i] == 1)right++;\n    else left++;\n    if(right <= left){\n      ans += (left-right)*((a[i]-(left+right-1))-last-1);\n      last += left+right;\n      left = right = 0;\n    }\n    pos = a[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n\nstruct Problem {\n\tUL N, L;\n\tpair<UL, UL> pd[100000];\n\tLL lans[100001], rans[100001];\n\tvoid Solve() {\n\t\tcin >> N >> L;\n\t\trep(i, N) cin >> pd[i].first >> pd[i].second;\n\t\tsort(pd, pd + N);\n\t\tLL lp = 1, rp = L;\n\t\tlans[0] = 0; rans[N] = 0;\n\t\tfor (UL i = 1; i <= N; i++) {\n\t\t\tUL ri = N - i;\n\t\t\tlans[i] = lans[i - 1];\n\t\t\trans[ri] = rans[ri + 1];\n\t\t\tif (pd[i - 1].second == 0) {\n\t\t\t\tlans[i] += pd[i - 1].first - lp;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlans[i] -= pd[i - 1].first - lp;\n\t\t\t}\n\t\t\tif (pd[ri].second == 0) {\n\t\t\t\trans[ri] -= rp - pd[ri].first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trans[ri] += rp - pd[ri].first;\n\t\t\t}\n\t\t\tlp++; rp--;\n\t\t}\n\t\tLL ans = 0;\n\t\trep(i, N + 1) {\n\t\t\tans = max(ans, lans[i] + rans[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Data {\n    int d;\n    ll p;\n    Data(ll p, int d) : p(p), d(d){}\n    bool operator < (const Data &d) const {\n        return p < d.p;\n    }\n};\n\nint main() {\n    int N;\n    ll L;\n    cin >> N >> L;\n    ll p[N];\n    int d[N];\n    vector<Data> v;\n    for (int i = 0; i < N; i++) {\n        cin >> p[i] >> d[i];\n        v.push_back(Data(p[i], d[i]));\n    }\n    \n    sort(v.begin(), v.end());\n    ll l[N + 1]{};\n    ll r[N + 1]{};\n    for (int i = 0; i < N; i++) {\n        if (v[i].d == 0) {\n            l[i + 1] = l[i] + v[i].p - i - 1;\n        } else {\n            l[i + 1] = l[i] - (v[i].p - i - 1);\n        }\n        if (v[N - i - 1].d == 0) {\n            r[i + 1] = r[i] - (L - v[N - i - 1].p - i);\n        } else {\n            r[i + 1] = r[i] + (L - v[N - i - 1].p - i);\n        }\n    }\n    \n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        ll t = r[i] + l[N - i];\n        ans = max(ans, t);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,l;\n  cin>>n>>l;\n  vector<Int> ps(n),ds(n);\n  for(Int i=0;i<n;i++) cin>>ps[i]>>ds[i];\n  {\n    using P = pair<Int, Int>;\n    vector<P> vp;\n    for(Int i=0;i<n;i++) vp.emplace_back(ps[i],ds[i]);\n    sort(vp.begin(),vp.end());\n    for(Int i=0;i<n;i++) tie(ps[i],ds[i])=vp[i];\n  }\n\n  // dp[i] : [0, i)\n  vector<Int> dp(n+1,0);\n  for(Int i=0;i<n;i++){\n    Int dif=(i+1)-ps[i];\n    Int cst=dif*(ds[i]==0?-1:1);\n    dp[i+1]=dp[i]+cst;\n  }\n\n  // pd[i] : [i, n)\n  vector<Int> pd(n+1,0);\n  for(Int i=n-1;i>=0;i--){\n    Int dif=(l-n)+(i+1)-ps[i];\n    Int cst=dif*(ds[i]==0?-1:1);\n    pd[i]=pd[i+1]+cst;\n  }\n\n  Int ans=0;\n  for(Int i=0;i<=n;i++) chmax(ans,dp[i]+pd[i]);\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tlong long N, L; cin >> N >> L;\n\tvector<pair<long long, long long> > pd(N);\n\tfor (auto& a : pd)  cin >> a.first >> a.second;\n\tsort(pd.begin(), pd.end());\n\tvector<long long> left(N + 1), right(N + 1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tleft[i + 1] = left[i] +\n\t\t\t(pd[i].first - i - 1) * (pd[i].second ? -1 : 1);\n\t}\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tright[i] = right[i + 1] +\n\t\t\t(L - N + i + 1 - pd[i].first) * (pd[i].second ? 1 : -1);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= N; ++i) ans = max(ans, left[i] + right[i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\nusing LD = long double;\nusing VB = vector<bool>;\nusing VVB = vector<VB>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing VS = vector<string>;\nusing VD = vector<LD>;\nusing PII = pair<int, int>;\nusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\nusing VPL = vector<PLL>;\ntemplate <class T> using PQ = priority_queue<T>;\ntemplate <class T> using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1e9;\nconstexpr long long inf_ll = 1e18, MOD = 1000000007;\nconstexpr long double PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate <class T> static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()))\n\t\t\t;\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear();\n\t\tchar c;\n\t\tfor (i(c); !isspace(c); c = gc()) v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c); c = gc()) v = v * 10 + (c - '0');\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1;\n\t\tbool neg = false, adp = false;\n\t\tv = 0;\n\t\tchar c;\n\t\ti(c);\n\t\tif (c == '-') {\n\t\t\tneg = true;\n\t\t\tc = gc();\n\t\t}\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')\n\t\t\t\tadp = true;\n\t\t\telse if (adp)\n\t\t\t\tv += (c - '0') * (dp *= 0.1);\n\t\t\telse\n\t\t\t\tv = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg) v = -v;\n\t}\n\ttemplate <class T, class U> static void i(pair<T, U>& v) {\n\t\ti(v.first);\n\t\ti(v.second);\n\t}\n\ttemplate <class T> static void i(vector<T>& v) {\n\t\tfor (auto& e : v) i(e);\n\t}\n\tstruct InputV {\n\t\tint n, m;\n\t\tInputV(int _n) : n(_n), m(0) {}\n\t\tInputV(const pair<int, int>& nm) : n(nm.first), m(nm.second) {}\n\t\ttemplate <class T> operator vector<T>() {\n\t\t\tvector<T> v(n);\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t\ttemplate <class T> operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(m));\n\t\t\ti(v);\n\t\t\treturn v;\n\t\t}\n\t};\n\npublic:\n\tstatic string get_line() {\n\t\tstring v;\n\t\tchar c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc()) v += c;\n\t\treturn v;\n\t}\n\ttemplate <class T> static T in() {\n\t\tT v;\n\t\ti(v);\n\t\treturn v;\n\t}\n\ttemplate <class T> operator T() const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int) const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n) const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n) const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()() const {}\n\ttemplate <class H, class... T> void operator()(H&& h, T&&... t) const {\n\t\ti(h);\n\t\toperator()(forward<T>(t)...);\n\t}\n} in;\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(long long)\n#define STR input(string)\n#define inputs(T, ...) \\\n\tT __VA_ARGS__;     \\\n\tin(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(long long, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char *t, *f;\n\tBoolStr(const char* _t, const char* _f) : t(_t), f(_f) {}\n} Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char *d, *l;\n\tDivStr(const char* _d, const char* _l) : d(_d), l(_l) {}\n} spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{Yes};\n\tDivStr D{spc};\n\tvoid p(int v) const {\n\t\tif (v < 0) putchar_unlocked('-'), v = -v;\n\t\tchar b[10];\n\t\tint i = 0;\n\t\twhile (v) b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i) b[i++] = '0';\n\t\twhile (i--) putchar_unlocked(b[i]);\n\t}\n\tvoid p(long long v) const {\n\t\tif (v < 0) putchar_unlocked('-'), v = -v;\n\t\tchar b[20];\n\t\tint i = 0;\n\t\twhile (v) b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i) b[i++] = '0';\n\t\twhile (i--) putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v) const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v) const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v) const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v) const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate <class T> void p(const T& v) const {\n\t\tcout << v;\n\t}\n\ttemplate <class T, class U> void p(const pair<T, U>& v) const {\n\t\tp(v.first);\n\t\tp(D.d);\n\t\tp(v.second);\n\t}\n\ttemplate <class T> void p(const vector<T>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.d);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\ttemplate <class T> void p(const vector<vector<T>>& v) const {\n\t\trep(i, sz(v)) {\n\t\t\tif (i) p(D.l);\n\t\t\tp(v[i]);\n\t\t}\n\t}\n\npublic:\n\tOutput& operator()() {\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H> Output& operator()(H&& h) {\n\t\tp(h);\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class H, class... T> Output& operator()(H&& h, T&&... t) {\n\t\tp(h);\n\t\tp(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate <class It> Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) {\n\t\t\tif (i != l) p(D.d);\n\t\t\tp(*i);\n\t\t}\n\t\tp(D.l);\n\t\treturn *this;\n\t}\n\ttemplate <class T> Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate <class... T> void exit(T&&... t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b;\n\t\treturn *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d;\n\t\treturn *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f);\n\t\treturn *this;\n\t}\n} out;\n\n// --- step --- //\ntemplate <class T> struct Step {\n\tclass It {\n\t\tT a, b, c;\n\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this;\n\t\t\t--b;\n\t\t\ta += c;\n\t\t\treturn tmp;\n\t\t}\n\t\tconstexpr const T& operator*() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->() const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i) const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i) const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start() const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T count() const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step() const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin() const {\n\t\treturn be;\n\t}\n\tconstexpr It end() const {\n\t\treturn en;\n\t}\n\tconstexpr T start() const {\n\t\treturn be.start();\n\t}\n\tconstexpr T count() const {\n\t\treturn be.count();\n\t}\n\tconstexpr T step() const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum() const {\n\t\treturn start() * count() + step() * (count() * (count() - 1) / 2);\n\t}\n\toperator vector<T>() const {\n\t\treturn to_a();\n\t}\n\ttemplate <class F> void each(const F& f) const {\n\t\tfor (T i : *this) f(i);\n\t}\n\tauto to_a() const {\n\t\tvector<T> res;\n\t\tres.reserve(count());\n\t\teach([&](T i) { res.push_back(i); });\n\t\treturn res;\n\t}\n\ttemplate <class F, class U = decay_t<result_of_t<F(T)>>> auto map(const F& f) const {\n\t\tvector<U> res;\n\t\tres.reserve(count());\n\t\teach([&](T i) { res.push_back(f(i)); });\n\t\treturn res;\n\t}\n\ttemplate <class F> auto select(const F& f) const {\n\t\tvector<T> res;\n\t\teach([&](T i) {\n\t\t\tif (f(i)) res.push_back(i);\n\t\t});\n\t\treturn res;\n\t}\n\ttemplate <class F> int count_if(const F& f) const {\n\t\tint res = 0;\n\t\teach([&](T i) {\n\t\t\tif (f(i)) ++res;\n\t\t});\n\t\treturn res;\n\t}\n\ttemplate <class F> T find_if(const F& f) const {\n\t\tfor (T i : *this)\n\t\t\tif (f(i)) return i;\n\t\treturn 0;\n\t}\n\ttemplate <class F> auto max_by(const F& f) const {\n\t\tauto v = map(f);\n\t\treturn *max_element(v.begin(), v.end());\n\t}\n\ttemplate <class F> auto min_by(const F& f) const {\n\t\tauto v = map(f);\n\t\treturn *min_element(v.begin(), v.end());\n\t}\n\ttemplate <class F> bool all_of(const F& f) const {\n\t\tfor (T i : *this)\n\t\t\tif (!f(i)) return false;\n\t\treturn true;\n\t}\n\ttemplate <class F> bool any_of(const F& f) const {\n\t\tfor (T i : *this)\n\t\t\tif (f(i)) return true;\n\t\treturn false;\n\t}\n\ttemplate <class F, class U = decay_t<result_of_t<F(T)>>> auto sum(const F& f) const {\n\t\tU res = 0;\n\t\teach([&](T i) { res += static_cast<U>(f(i)); });\n\t\treturn res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\n\nprivate:\n\tIt be, en;\n};\ntemplate <class T> inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate <class T> inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- functions --- //\ninline namespace {\n\ttemplate <class T> inline void Sort(T& a) {\n\t\tsort(all(a));\n\t}\n\ttemplate <class T> inline void RSort(T& a) {\n\t\tsort(rall(a));\n\t}\n\ttemplate <class T, class F> inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), f);\n\t}\n\ttemplate <class T, class F> inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), f);\n\t}\n\ttemplate <class T> inline T Sorted(T a) {\n\t\tSort(a);\n\t\treturn a;\n\t}\n\ttemplate <class T> inline T RSorted(T a) {\n\t\tRSort(a);\n\t\treturn a;\n\t}\n\ttemplate <class T, class F> inline T Sorted(T& a, const F& f) {\n\t\tSort(a, f);\n\t\treturn a;\n\t}\n\ttemplate <class T, class F> inline T RSorted(T& a, const F& f) {\n\t\tRSort(a, f);\n\t\treturn a;\n\t}\n\ttemplate <class T, class F> inline void SortBy(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) { return f(x) < f(y); });\n\t}\n\ttemplate <class T, class F> inline void RSortBy(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) { return f(x) < f(y); });\n\t}\n\ttemplate <class T> inline void Reverse(T& a) {\n\t\treverse(all(a));\n\t}\n\ttemplate <class T> inline void Unique(T& a) {\n\t\ta.erase(unique(all(a)), a.end());\n\t}\n\ttemplate <class T> inline void Uniq(T& a) {\n\t\tSort(a);\n\t\tUnique(a);\n\t}\n\ttemplate <class T> inline void Rotate(T& a, int left) {\n\t\trotate(a.begin(), a.begin() + left, a.end());\n\t}\n\ttemplate <class T> inline T Reversed(T a) {\n\t\tReverse(a);\n\t\treturn a;\n\t}\n\ttemplate <class T> inline T Uniqued(T a) {\n\t\tUnique(a);\n\t\treturn a;\n\t}\n\ttemplate <class T> inline T Uniqed(T a) {\n\t\tUniq(a);\n\t\treturn a;\n\t}\n\ttemplate <class T> inline T Rotated(T a, int left) {\n\t\tRotate(a, left);\n\t\treturn a;\n\t}\n\ttemplate <class T> inline auto Max(const T& a) {\n\t\treturn *max_element(all(a));\n\t}\n\ttemplate <class T> inline auto Min(const T& a) {\n\t\treturn *min_element(all(a));\n\t}\n\ttemplate <class T> inline int MaxPos(const T& a) {\n\t\treturn max_element(all(a)) - a.begin();\n\t}\n\ttemplate <class T> inline int MinPos(const T& a) {\n\t\treturn min_element(all(a)) - a.begin();\n\t}\n\ttemplate <class T, class F> inline auto MaxBy(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) { return f(x) < f(y); });\n\t}\n\ttemplate <class T, class F> inline auto MinBy(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) { return f(x) < f(y); });\n\t}\n\ttemplate <class T, class U> inline int Count(const T& a, const U& v) {\n\t\treturn count(all(a), v);\n\t}\n\ttemplate <class T, class F> inline int CountIf(const T& a, const F& f) {\n\t\treturn count_if(all(a), f);\n\t}\n\ttemplate <class T, class U> inline int Find(const T& a, const U& v) {\n\t\treturn find(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class F> inline int FindIf(const T& a, const F& f) {\n\t\treturn find_if(all(a), f) - a.begin();\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Sum(const T& a) {\n\t\treturn accumulate(all(a), U());\n\t}\n\ttemplate <class T, class U> inline bool Includes(const T& a, const U& v) {\n\t\treturn find(all(a), v) != a.end();\n\t}\n\ttemplate <class T, class F> inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(*v.begin()), [&](auto a, auto b) { return a + f(b); });\n\t}\n\ttemplate <class T, class U> inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class U> inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate <class T, class F> inline void RemoveIf(T& a, const F& f) {\n\t\ta.erase(remove_if(all(a), f), a.end());\n\t}\n\ttemplate <class F> inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size);\n\t\tfor (size_t i = 0; i < size; ++i) res[i] = f(i);\n\t\treturn res;\n\t}\n\ttemplate <class T> inline auto Grid(size_t h, size_t w, const T& v = T()) {\n\t\treturn vector<vector<T>>(h, vector<T>(w, v));\n\t}\n\ttemplate <class T> inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate <class T, class F> inline auto Each(const T& v, F&& f) {\n\t\tfor (auto& i : v) f(i);\n\t}\n\ttemplate <class T, class F> inline auto Select(const T& v, const F& f) {\n\t\tT res;\n\t\tfor (const auto& e : v)\n\t\t\tif (f(e)) res.push_back(e);\n\t\treturn res;\n\t}\n\ttemplate <class T, class F> inline auto Map(const T& v, F&& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0;\n\t\tfor (const auto& e : v) res[i++] = f(e);\n\t\treturn res;\n\t}\n\ttemplate <class T, class F> inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0;\n\t\tfor (auto it = v.begin(); it != v.end(); ++it, ++i) res[i] = f(i, *it);\n\t\treturn res;\n\t}\n\ttemplate <class T, class F> inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res;\n\t\tfor (size_t i = 0; i < v.size(); ++i)\n\t\t\tif (f(v[i])) res.push_back(i);\n\t\treturn res;\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline auto Indexed(const T& v) {\n\t\tvector<pair<U, int>> res(v.size());\n\t\tfor (int i = 0; i < (int)v.size(); ++i) res[i] = make_pair(static_cast<U>(v[i]), i);\n\t\treturn res;\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i) res += s;\n\t\treturn res;\n\t}\n\ttemplate <class T> inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2));\n\t\treturn v;\n\t}\n\ttemplate <class T> inline T Ceil(T n, T m) {\n\t\treturn (n + m - 1) / m;\n\t}\n\ttemplate <class T> inline T Ceil2(T n, T m) {\n\t\treturn Ceil(n, m) * m;\n\t}\n\ttemplate <class T> inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate <class T> inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate <class T> inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\ttemplate <class T> inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) {\n\t\t\ta = b;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\ttemplate <class T> inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate <class T> inline bool isSquere(T n) {\n\t\tT s = sqrt(n);\n\t\treturn s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate <class T = long long> inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate <class T> inline T Gcd(T n, T m) {\n\t\treturn m ? Gcd(m, n % m) : n;\n\t}\n\ttemplate <class T> inline T Lcm(T n, T m) {\n\t\treturn n / Gcd(n, m) * m;\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate <class T, class U = typename T::value_type> inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate <class T> inline T Pow(T a, T n) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) r *= a;\n\t\t\ta *= a;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate <class T> inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1)\n\t\t\t\tr = r * a % m, n--;\n\t\t\telse\n\t\t\t\ta = a * a % m, n /= 2;\n\t\t}\n\t\treturn r;\n\t}\n}  // namespace\n\n// --- dump --- //\n#if __has_include(\"/home/yuruhiya/contest/library/dump.hpp\")\n#include \"/home/yuruhiya/contest/library/dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in;\n\tll l = in;\n\tvector<pair<ll, int>> xd = in[n];\n\tSort(xd);\n\tVL x = step(n).map([&](int i) { return xd[i].first; });\n\tVB d = step(n).map([&](int i) -> bool { return xd[i].second; });\n\n\tVL acc_r(n + 1);\n\trep(i, n) {\n\t\tacc_r[i + 1] = acc_r[i] + (x[i] - (i + 1)) * (d[i] ? -1 : 1);\n\t}\n\tVL acc_l(n + 1);\n\trrep(i, n) {\n\t\tacc_l[i] = acc_l[i + 1] + ((l - n + i + 1) - x[i]) * (d[i] ? 1 : -1);\n\t}\n\tdump(acc_r, acc_l);\n\n\tll ans = -inf_ll;\n\trep(i, n + 1) {\n\t\tchmax(ans, acc_r[i] + acc_l[i]);\n\t}\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < int(n); i++)\n#define repr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n\nint main(){\n    int N;\n    lint L;\n    cin >> N >> L;\n    vector<pair<lint, int>> koma(N);\n    rep(i, N){\n        cin >> koma[i].first >> koma[i].second;\n    }\n    sort(all(koma));\n    lint L_sum[N + 2], R_sum[N + 2]; // 左埋め、右埋め\n    L_sum[0] = R_sum[N + 1] = 0;\n    rep(i, N){\n        if(koma[i].second == 0){ // 左向き\n            L_sum[i + 1] = L_sum[i] - (i + 1 - koma[i].first);\n        }else{ // 右向き\n            L_sum[i + 1] = L_sum[i] + (i + 1 - koma[i].first);\n        }\n    }\n    repr(i, N){\n        if(koma[i].second == 0){ // 左向き\n            R_sum[i + 1] = R_sum[i + 2] - (L - N + i + 1 - koma[i].first);\n        }else{ // 右向き\n            R_sum[i + 1] = R_sum[i + 2] + (L - N + i + 1 - koma[i].first);\n        }\n    }\n    lint ans = 0;\n    rep(i, N + 1){\n        ans = max(ans, L_sum[i] + R_sum[i + 1]);\n    }\n    /*rep(i, N + 1){\n        cout << L_sum[i] << \" \" << R_sum[i + 1] << endl;\n    }*/\n    cout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define repp(i,l,r)for(long long i=(l);i<(r);i++)\n#define rep(i,n) for (long long i = 0; i < (n); ++i)\n#define per(i,n) for (long long i = (n); i >= 0; --i)\nconst int INF = 2147483647;//int max\nconst long long int MOD = 1000000007;\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//ミョ(-ω- ?)\n//this cord is learned from beet\nint main() {\n    ll n,l;\n    cin >> n >> l;\n    vector<pair<ll,ll>> p(n);\n    rep(i,n){\n        cin >> p[i].first >> p[i].second;\n    }\n    sort(p.begin(),p.end());\n    //左側(iが小さい側)に詰める\n    // [0,i)\n    vector<ll> dp(n+1,0);\n    rep(i,n){\n        ll dif = (i + 1) - p[i].first;//基本的には負になる\n        dp[i+1] = dp[i] + dif*((p[i].second != 0) ? 1:-1);\n    }\n    //右側に詰める\n    //[i,n)\n    vector<ll> pd(n+1,0);\n    per(i,n-1){\n        ll dif = (l - n + i + 1) - p[i].first;//基本的には正\n        pd[i] = pd[i+1] + dif*((p[i].second != 0) ? 1:-1);\n    }\n    ll res = 0;\n    rep(i,n+1)chmax(res,dp[i]+pd[i]);\n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <assert.h>\nusing namespace std;\n\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\nll r[110000], r2[110000];\nll n, l;\nint main() {\n\tcin >> n >> l;\n\tvector<P> s(n);\n\tREP(i, n) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\ts[i] = P(a, b);\n\t}\n\tsort(ALL(s));\n\tREP(i, n) {\n\t\tll cost = s[i].first - i - 1;\n\t\tif (s[i].second == 1) cost *= -1;\n\t\tr[i + 1] = r[i] + cost;\n\t}\n\tREPR(i, n - 1) {\n\t\tll cost = l - s[i].first - (n - i - 1);\n\t\tif (s[i].second == 0) cost *= -1;\n\t\tr2[i] = r2[i + 1] + cost;\n\t}\n\tll ans = 0;\n\tREP(i, n + 1) ans = max(ans, r[i] + r2[i]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int N, L;\n  cin >> N >> L;\n  vector<pair<int, int>> P(N);\n  for (int i = 0; i < N; i++){\n    int p, c;\n    cin >> p >> c;\n    P[i] = make_pair(p, c);\n  }\n  sort(P.begin(), P.end());\n  vector<long long> left(N + 1, 0);\n  for (int i = 0; i < N; i++){\n    if (P[i].second == 0){\n      left[i + 1] = left[i] + (P[i].first - (i + 1));\n    } else {\n      left[i + 1] = left[i] - (P[i].first - (i + 1));\n    }\n  }\n  vector<long long> right(N + 1, 0);\n  for (int i = N - 1; i >= 0; i--){\n    if (P[i].second == 1){\n      right[i] = right[i + 1] + (L - (N - 1 - i) - P[i].first);\n    } else {\n      right[i] = right[i + 1] - (L - (N - 1 - i) - P[i].first);\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= N; i++){\n    ans = max(ans, left[i] + right[i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\n#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, pii > piii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint N, L;\npair<int, int> p[100100];\nint l[100100], r[100100];\n\nsigned main(){\n    cin >> N >> L;\n    for(int  i = 0; i < N; i++){\n        int a,b;\n        cin >> a >> b;\n        p[i] = mk(a, b);\n    }\n    sort(p, p + N);\n    for(int i = 0; i < N; i++){\n        int num = p[i].first;\n        int dir = p[i].second;\n        if(dir){\n            l[i] = -(num - i - 1);\n        }\n        else {\n            l[i] = num - i - 1;\n        }\n        if(i > 0)l[i] += l[i - 1];\n\n        num = p[N-1-i].first;\n        dir = p[N-1-i].second;\n        if(dir){\n            r[N-1-i] = L - i - num;\n        }\n        else {\n            r[N-1-i] = -(L - i - num);\n        }\n        r[N-1-i] += r[N-1-i + 1];\n    }\n    int ans = r[0];\n    for(int i = 0; i < N; i++){\n        ans = max(ans, l[i] + r[i + 1]);\n    }\n    cout << ans << endl;\n    \n\n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  cin.tie(0);\t\n  ios::sync_with_stdio(false);\n  int n,m;\n  cin>>n>>m;\n  pair<int,int> a[100000];\n  int ll,lr,rl,rr;\n  ll=lr=rl=rr=0;\n  int ans=0;\n  int prev=0;\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    a[i]=make_pair(x,y);\n    if(y==0){\n      ll++;\n      //ans+=(y-1);\n    }\n    else{\n      rl++;\n      //ans-=(y-1);\n    }\n  }\n  sort(a,a+n);\n  rep(i,n){\n    if(a[i].scd==0){\n      //ll++;\n      ans+=(a[i].fst-1);\n      ans-=i;\n    }\n    else{\n      //rl++;\n      ans-=(a[i].fst-1);\n      ans+=i;\n    }\n  }\n  //cout<<ans<<endl;\n  int now=ans;\n  repn(i,n-1){\n    if(a[i].scd==0){\n      now-=(m-n);\n    }\n    else{\n      now+=(m-n);\n    }\n    ans=max(ans,now);\n  }\n  cout<<ans<<endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n/*\n\t@・ω・@\n*/\n\n// Memo:https://scrapbox.io/hitsujirere-memo/\n\n/*****/\n\n/**/\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n/**/\n\n#include <bits/stdc++.h>\n\n//#define int long long\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing pll = pair<long long, long long>;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing grapth = vec<vec<T>>;\n\n#define rep(i, n) for (ll i = 0, i##_len = (n); i < i##_len; ++i)\n#define rep1(i, n) for (ll i = 1, i##_len = (n); i <= i##_len; ++i)\n#define rrep(i, n) for (ll i = (n)-1; i >= 0; --i)\n#define rrep1(i, n) for (ll i = (n); i > 0; --i)\n#define step(i, a, n) for (ll i = (a), i##_len = (a) + (n); i < i##_len; ++i)\n#define rstep(i, a, n) for (ll i = (a) + (n)-1, i##_len = (a); i >= i##_len; --i)\n#define range(i, a, b) for (ll i = (a), i##_len = (b); i < i##_len; ++i)\n#define rrange(i, a, b) for (ll i = (b)-1, i##_len = (a); i >= i##_len; --i)\n\nconstexpr int INF = numeric_limits<int>::max();\nconstexpr ll INFL = numeric_limits<ll>::max();\n\nstd::string strMulti(const char c, const int n)\n{\n\tstd::string out = \"\";\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tout += c;\n\t}\n\treturn out;\n}\nstd::string strMulti(const std::string t, const int n)\n{\n\tstd::string out = \"\";\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tout += t;\n\t}\n\treturn out;\n}\nstd::string tab(const int n)\n{\n\treturn strMulti('\\t', n);\n}\nstd::string join(const vector<string> &v, const char *delim = 0)\n{\n\tstd::string s;\n\tif (!v.empty())\n\t{\n\t\ts += v[0];\n\t\tfor (decltype(v.size()) i = 1, c = v.size(); i < c; ++i)\n\t\t{\n\t\t\tif (delim)\n\t\t\t\ts += delim;\n\t\t\ts += v[i];\n\t\t}\n\t}\n\treturn s;\n}\n\nstring to_string(string &s) { return '\"' + s + '\"'; }\nstring to_string(char &c) { return string({'\\'', c, '\\''}); }\ntemplate <class T1, class T2>\nstring to_string(pair<T1, T2> p)\n{\n\treturn \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <class Tuple, size_t... I>\nstring _to_string_tuple(Tuple &&t, std::index_sequence<I...>)\n{\n\tvector<string> texts = {to_string(std::get<I>(t))...};\n\treturn \"(\" + join(texts, \", \") + \")\";\n}\ntemplate <class... Args>\nstring to_string(tuple<Args...> t)\n{\n\tusing Tuple = tuple<Args...>;\n\treturn _to_string_tuple(std::forward<Tuple>(t),\n\t\t\t\t\t\t\tstd::make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>{});\n}\ntemplate <class T>\nstring to_string(vector<T> ar)\n{\n\tvector<string> texts(ar.size());\n\tfor (size_t i = 0; i < ar.size(); ++i)\n\t{\n\t\ttexts[i] = to_string(ar[i]);\n\t}\n\treturn \"{\" + join(texts, \", \") + \"}\";\n}\ntemplate <class T>\nstring to_string(initializer_list<T> il)\n{\n\tvector<string> texts(il.size());\n\tsize_t i = 0;\n\tfor (T v : il)\n\t{\n\t\ttexts[i] = to_string(v);\n\t\ti++;\n\t}\n\treturn \"{\" + join(texts, \", \") + \"}\";\n}\n\n#ifdef DEBUG_BUILD\n#define debugvar(x) debugln(#x, (x))\n#define debugvartab(x, t) debugln(tab(t) + #x, (x))\nvoid debug(string name)\n{\n\tstd::cerr << name;\n}\nvoid debugln(string name)\n{\n\tstd::cerr << name << '\\n';\n}\ntemplate <class T>\nvoid debug(string name, T v)\n{\n\tstd::cerr << name << \" = \" << to_string(v);\n}\ntemplate <class T>\nvoid debugln(string name, T v)\n{\n\tstd::cerr << name << \" = \" << to_string(v) << '\\n';\n}\ntemplate <class T>\nvoid debug(string name, initializer_list<T> il)\n{\n\tstd::cerr << name << \" = \" << to_string(il);\n}\ntemplate <class T>\nvoid debugln(string name, initializer_list<T> il)\n{\n\tstd::cerr << name << \" = \" << to_string(il) << '\\n';\n}\ntemplate <class... Args>\nvoid debug(string name, Args... args)\n{\n\tstd::cerr << name << \" = \" << to_string(tuple<Args...>(args...));\n}\ntemplate <class... Args>\nvoid debugln(string name, Args... args)\n{\n\tstd::cerr << name << \" = \" << to_string(tuple<Args...>(args...)) << '\\n';\n}\n#else\n#define debugvar(x)\n#define debugvartab(x, t)\nvoid debug(string name)\n{\n}\nvoid debugln(string name) {}\ntemplate <class T>\nvoid debug(string name, T v) {}\ntemplate <class T>\nvoid debugln(string name, T v) {}\ntemplate <class T>\nvoid debug(string name, initializer_list<T> il) {}\ntemplate <class T>\nvoid debugln(string name, initializer_list<T> il) {}\ntemplate <class... Args>\nvoid debug(string name, Args... args) {}\ntemplate <class... Args>\nvoid debugln(string name, Args... args) {}\n#endif\n\n#define all(x) (x).begin(), (x).end()\n#define pair(a, b) make_pair(a, b)\n\ntemplate <class T>\nbool chmax(T &a, const T b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\nbool chmin(T &a, const T b)\n{\n\tif (a > b)\n\t{\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\nT divup(const T a, const T b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn a / b;\n\t}\n\treturn a / b + 1;\n}\ntemplate <class T>\nbool cmp_2nd(pair<T, T> a, pair<T, T> b)\n{\n\tif (a.second != b.second)\n\t{\n\t\treturn a.second < b.second;\n\t}\n\treturn a.first < b.first;\n}\nll modpow(ll x, ll n, const ll &p)\n{\n\tll ret = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t{\n\t\t\t(ret *= x) %= p;\n\t\t}\n\t\t(x *= x) %= p;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate <class T>\nT modinv(T a, const T &p)\n{\n\tT b = p, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tT t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= p;\n\tif (u < 0)\n\t{\n\t\tu += p;\n\t}\n\treturn u;\n}\ntemplate <class T>\nT math_P(T m, T n)\n{\n\tT ret = 1;\n\tfor (T i = m; i > m - n; i--)\n\t{\n\t\tret *= i;\n\t}\n\treturn ret;\n}\ntemplate <class T>\nT math_C(T m, T n)\n{\n\tT ret = math_P(m, n);\n\tfor (T i = 2; i <= n; i++)\n\t{\n\t\tret /= i;\n\t}\n\treturn ret;\n}\nll extended_euclidean(ll u, ll v)\n{\n\tll r0 = u;\n\tll r1 = v;\n\tll s0 = 1;\n\tll s1 = 0;\n\tll t0 = 0;\n\tll t1 = 1;\n\twhile (r1 != 0)\n\t{\n\t\tll q = r0 / r1;\n\t\tll r = r0 - q * r1;\n\t\tll s = s0 - q * s1;\n\t\tll t = t0 - q * t1;\n\t\tr0 = r1;\n\t\ts0 = s1;\n\t\tt0 = t1;\n\t\tr1 = r;\n\t\ts1 = s;\n\t\tt1 = t;\n\t}\n\tif (t0 < 0)\n\t{\n\t\treturn t0 + u;\n\t}\n\telse\n\t{\n\t\treturn t0;\n\t}\n}\nll math_C_mod(ll n, ll c, const ll &p)\n{\n\tll upe = 1;\n\tll dow = 1;\n\tfor (ll i = 1; i < c + 1; ++i)\n\t{\n\t\tupe = upe * n % p;\n\t\tdow = dow * i % p;\n\t\tn -= 1;\n\t}\n\treturn (upe * extended_euclidean(p, dow)) % p;\n}\ntemplate <class T>\nT math_gcd(T a, T b)\n{\n\tif (b == 0)\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn math_gcd(b, a % b);\n\t}\n}\ntemplate <class T>\nT math_lcm(T a, T b) { return a / math_gcd(a, b) * b; }\ntemplate <class T>\nT SumStep(T a, T n, T d) { return n * (2 * a + (n - 1) * d) / 2; }\ntemplate <class T>\nT SumRange(T a, T b, T d) { return SumStep(a, (b - a) / d, d); }\n\n//constexpr ll MOD = 1000000007; // 10^9+7\nconstexpr ll MOD = 1000000; // 10^6\n\n/*****/\n\nvoid Main()\n{\n\tll N, Long;\n\tcin >> N >> Long;\n\tvec<array<ll, 2>> D(N);\n\trep(i, N) cin >> D[i][0] >> D[i][1];\n\tsort(all(D));\n\n\tvec<ll> R(N + 1), L(N + 1);\n\trep(i, N)\n\t{\n\t\tR[i + 1] = R[i] + (D[i][1] ? -1 : 1) * (D[i][0] - i - 1);\n\t}\n\trrep(i, N)\n\t{\n\t\tL[i] = L[i + 1] + (D[i][1] ? 1 : -1) * (Long - D[i][0] - (N - i - 1));\n\t}\n\n\tdebugvar(R);\n\tdebugvar(L);\n\n\tll ret = 0;\n\trep(i, N + 1)\n\t{\n\t\tchmax(ret, R[i] + L[i]);\n\t}\n\n\tcout << ret << endl;\n}\n\n/*****/\n\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tstd::cout << std::fixed << std::setprecision(10);\n\n\tMain();\n\tstd::cerr << flush;\n\tstd::cout << flush;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int p { get; set; }\n    public bool d { get; set; }\n}\n\npublic class hello\n{\n    public static int n, L;\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        n = int.Parse(line[0]);\n        L = int.Parse(line[1]);\n        var ps = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            var p = int.Parse(line[0]) - 1;\n            var d = line[1] == \"0\";\n            ps[i] = new P { p = p, d = d };\n        }\n        ps = ps.OrderBy(x => x.p).ToArray();\n        getTable(ps);\n    }\n    static void getTable(P[] ps)\n    {\n        var h = new long[n];\n        var m = new long[n];\n        var preh = 0L;\n        var prem = 0L;\n        var pth = 0;\n        var ptm = L - 1;\n        for (int i = 0; i < n; i++)\n        {\n            var a = ps[i].p - pth++;\n            h[i] = ps[i].d ? preh + a : preh - a;\n            preh = h[i];\n            var b = ptm-- - ps[n - 1 - i].p;\n            m[n - 1 - i] = ps[n - 1 - i].d ? prem - b : prem + b;\n            prem = m[n - 1 - i];\n        }\n        var ans = Max(h[n - 1], m[0]);\n        for (int i = 0; i < n - 1; i++)\n            ans = Max(ans, h[i] + m[i + 1]);\n        Console.WriteLine(ans);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "# AOJ Volume4 0411\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0411\n\nN, L = list(map(int, input().split()))\nc = []\nfor _ in range(0, N):\n    p, d = list(map(int, input().split()))\n    c += [(p, d)]\nc.sort()\nmasu = [p for p, d in c]\ndir  = [d for p, d in c]\n\nresult = 0\n\nscore = 0\nfor j in range(0, N):\n    if dir[j] == 0:\n        score += masu[j] - j - 1\n    elif dir[j] == 1:\n        score -= masu[j] - j - 1\n    masu[j] = j + 1\nresult = score\n\nfor i in range(N - 1, -1, -1):\n    if dir[i] == 1:\n        score += L - (N - i) - masu[i] + 1\n    elif dir[i] == 0:\n        score -= L - (N - i) - masu[i] + 1\n    masu[i] = L - (N - i) + 1\n    \n    result = max(result, score)\nprint(result)\n\n"
  }
]