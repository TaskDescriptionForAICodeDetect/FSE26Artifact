[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\ntypedef struct {\n    Point *data;\n    int front;\n    int rear;\n    int size;\n} Queue;\n\nQueue* createQueue(int size) {\n    Queue *q = (Queue*)malloc(sizeof(Queue));\n    q->data = (Point*)malloc(size * sizeof(Point));\n    q->front = 0;\n    q->rear = -1;\n    q->size = size;\n    return q;\n}\n\nvoid enqueue(Queue *q, Point p) {\n    if (q->rear == q->size - 1) {\n        return;\n    }\n    q->data[++q->rear] = p;\n}\n\nPoint dequeue(Queue *q) {\n    return q->data[q->front++];\n}\n\nbool isEmpty(Queue *q) {\n    return q->front > q->rear;\n}\n\nint countReachableCells(int turns, Point start, Point obstacles[], int numObstacles, int gridSize) {\n    bool **visited = (bool**)malloc(gridSize * sizeof(bool*));\n    bool **isObstacle = (bool**)malloc(gridSize * sizeof(bool*));\n    for (int i = 0; i < gridSize; i++) {\n        visited[i] = (bool*)calloc(gridSize, sizeof(bool));\n        isObstacle[i] = (bool*)calloc(gridSize, sizeof(bool));\n    }\n\n    for (int i = 0; i < numObstacles; i++) {\n        isObstacle[obstacles[i].x][obstacles[i].y] = true;\n    }\n\n    int directions[6][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, -1}, {-1, 1}};\n    Queue *q = createQueue(gridSize * gridSize);\n    enqueue(q, start);\n    visited[start.x][start.y] = true;\n    int count = 0;\n\n    for (int t = 0; t <= turns; t++) {\n        int levelSize = q->rear - q->front + 1;\n        while (levelSize--) {\n            Point current = dequeue(q);\n            count++;\n            for (int i = 0; i < 6; i++) {\n                int nx = current.x + directions[i][0];\n                int ny = current.y + directions[i][1];\n                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited[nx][ny] && !isObstacle[nx][ny]) {\n                    visited[nx][ny] = true;\n                    enqueue(q, (Point){nx, ny});\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < gridSize; i++) {\n        free(visited[i]);\n        free(isObstacle[i]);\n    }\n    free(visited);\n    free(isObstacle);\n    free(q->data);\n    free(q);\n\n    return count;\n}\n\nint main() {\n    int turns, numObstacles, gridSize;\n    Point start;\n    scanf(\"%d %d %d\", &turns, &gridSize, &numObstacles);\n    scanf(\"%d %d\", &start.x, &start.y);\n    Point obstacles[numObstacles];\n    for (int i = 0; i < numObstacles; i++) {\n        scanf(\"%d %d\", &obstacles[i].x, &obstacles[i].y);\n    }\n    printf(\"%d\\n\", countReachableCells(turns, start, obstacles, numObstacles, gridSize));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <tuple>\n\nusing namespace std;\n\nconst int dx[] = {1, 1, 0, -1, -1, 0};\nconst int dy[] = {0, 1, 1, 0, -1, -1};\n\nint count_reachable_cells(int turns, const vector<pair<int, int>>& obstacles) {\n    set<pair<int, int>> blocked(obstacles.begin(), obstacles.end());\n    set<pair<int, int>> visited;\n    queue<tuple<int, int, int>> q;\n    \n    q.push({0, 0, 0});\n    visited.insert({0, 0});\n    \n    int count = 0;\n    \n    while (!q.empty()) {\n        auto [x, y, t] = q.front();\n        q.pop();\n        \n        if (t > turns) continue;\n        count++;\n        \n        for (int i = 0; i < 6; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (blocked.find({nx, ny}) == blocked.end() && visited.find({nx, ny}) == visited.end()) {\n                visited.insert({nx, ny});\n                q.push({nx, ny, t + 1});\n            }\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int turns, n;\n    cin >> turns >> n;\n    vector<pair<int, int>> obstacles(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> obstacles[i].first >> obstacles[i].second;\n    }\n    cout << count_reachable_cells(turns, obstacles) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class HexagonalGrid {\n    private static final int[][] DIRECTIONS = {\n        {1, 0}, {1, -1}, {0, -1},\n        {-1, 0}, {-1, 1}, {0, 1}\n    };\n\n    public static int countReachableCells(int turns, int startX, int startY, Set<String> obstacles) {\n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(new int[]{startX, startY, turns});\n        visited.add(startX + \",\" + startY);\n\n        int count = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int remainingTurns = current[2];\n\n            if (remainingTurns >= 0) {\n                count++;\n            } else {\n                continue;\n            }\n\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                String key = newX + \",\" + newY;\n\n                if (!obstacles.contains(key) && !visited.contains(key) && remainingTurns > 0) {\n                    visited.add(key);\n                    queue.offer(new int[]{newX, newY, remainingTurns - 1});\n                }\n            }\n        }\n\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 21:19:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass HexGridReachability {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, 1}, {1, -1}};\n\n    public static int countReachableCells(int startX, int startY, int turns, Set<String> obstacles) {\n        Set<String> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{startX, startY, 0});\n        visited.add(startX + \",\" + startY);\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], currentTurns = current[2];\n\n            if (currentTurns == turns) continue;\n\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                String key = newX + \",\" + newY;\n\n                if (!obstacles.contains(key) && !visited.contains(key)) {\n                    queue.offer(new int[]{newX, newY, currentTurns + 1});\n                    visited.add(key);\n                }\n            }\n        }\n\n        return visited.size();\n    }\n}",
    "timestamp": "2025-08-05 21:19:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_GRID 100\n#define MAX_TURNS 100\n\n// Hexagonal grid directions\nconst int dx[6] = {1, 0, -1, -1, 0, 1};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\ntypedef struct {\n    int x, y;\n} Point;\n\nbool visited[MAX_GRID][MAX_GRID][MAX_TURNS + 1];\nbool obstacles[MAX_GRID][MAX_GRID];\n\nint countReachableCells(int startX, int startY, int turns, int gridSize) {\n    memset(visited, 0, sizeof(visited));\n    memset(obstacles, 0, sizeof(obstacles));\n\n    Point queue[MAX_GRID * MAX_GRID * MAX_TURNS];\n    int front = 0, rear = 0;\n    int reachableCells = 0;\n\n    queue[rear++] = (Point){startX, startY};\n    visited[startX][startY][0] = true;\n\n    while (front < rear) {\n        Point current = queue[front++];\n        \n        if (!obstacles[current.x][current.y]) {\n            reachableCells++;\n        }\n\n        for (int turn = 1; turn <= turns; turn++) {\n            if (visited[current.x][current.y][turn]) continue;\n\n            for (int dir = 0; dir < 6; dir++) {\n                int newX = current.x + dx[dir];\n                int newY = current.y + dy[dir];\n\n                if (newX >= 0 && newX < gridSize && \n                    newY >= 0 && newY < gridSize && \n                    !obstacles[newX][newY] && \n                    !visited[newX][newY][turn]) {\n                    \n                    queue[rear++] = (Point){newX, newY};\n                    visited[newX][newY][turn] = true;\n                }\n            }\n        }\n    }\n\n    return reachableCells;\n}\n\nint main() {\n    int gridSize, turns, startX, startY, obstacleCount;\n    \n    scanf(\"%d %d %d %d %d\", &gridSize, &turns, &startX, &startY, &obstacleCount);\n\n    for (int i = 0; i < obstacleCount; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        obstacles[x][y] = true;\n    }\n\n    int result = countReachableCells(startX, startY, turns, gridSize);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nclass HexGridNavigator {\nprivate:\n    vector<pair<int, int>> directions = {\n        {-1, 0}, {1, 0}, {-1, 1}, {0, 1}, {0, -1}, {1, -1}\n    };\n\npublic:\n    int countReachableCells(int startX, int startY, int maxTurns, vector<pair<int, int>>& obstacles) {\n        unordered_set<string> obstacleSet;\n        for (auto& obs : obstacles) {\n            obstacleSet.insert(to_string(obs.first) + \",\" + to_string(obs.second));\n        }\n\n        unordered_set<string> visited;\n        queue<pair<pair<int, int>, int>> q;\n        q.push({{startX, startY}, 0});\n        visited.insert(to_string(startX) + \",\" + to_string(startY));\n\n        while (!q.empty()) {\n            auto curr = q.front();\n            q.pop();\n\n            if (curr.second >= maxTurns) continue;\n\n            for (auto& dir : directions) {\n                int newX = curr.first.first + dir.first;\n                int newY = curr.first.second + dir.second;\n                string key = to_string(newX) + \",\" + to_string(newY);\n\n                if (obstacleSet.count(key) == 0 && visited.count(key) == 0) {\n                    q.push({{newX, newY}, curr.second + 1});\n                    visited.insert(key);\n                }\n            }\n        }\n\n        return visited.size();\n    }\n};",
    "timestamp": "2025-08-05 21:19:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def reachable_cells(start, turns, obstacles):\n    # Directions in which you can move in a hex grid\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1)]\n    \n    # Set of obstacles for easy lookup\n    obstacles_set = set(obstacles)\n    \n    # BFS to explore reachable cells within the given number of turns\n    visited = set()\n    queue = [(start, 0)]  # (current_position, turns_taken)\n    \n    while queue:\n        position, turns_taken = queue.pop(0)\n        \n        if turns_taken > turns:\n            continue\n        \n        if position in visited or position in obstacles_set:\n            continue\n        \n        visited.add(position)\n        \n        for direction in directions:\n            next_position = (position[0] + direction[0], position[1] + direction[1])\n            if next_position not in visited and next_position not in obstacles_set:\n                queue.append((next_position, turns_taken + 1))\n    \n    return len(visited)\n\n# Example usage:\nstart_position = (0, 0)\ntotal_turns = 3\nobstacle_positions = [(1, 1), (0, 2)]\nprint(reachable_cells(start_position, total_turns, obstacle_positions))",
    "timestamp": "2025-08-13 05:56:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class HexGridReachability {\n\n    static int[][] directions = {\n        // Hex grid directions\n        {1, 0}, {0, 1}, {-1, 1},\n        {-1, 0}, {0, -1}, {1, -1}\n    };\n\n    public static int reachableCells(int startX, int startY, int turns, Set<String> obstacles) {\n        Set<String> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        \n        queue.offer(new int[]{startX, startY, 0});\n        visited.add(startX + \",\" + startY);\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int currentTurns = current[2];\n            \n            if (currentTurns < turns) {\n                for (int[] dir : directions) {\n                    int newX = x + dir[0];\n                    int newY = y + dir[1];\n                    String key = newX + \",\" + newY;\n                    \n                    if (!visited.contains(key) && !obstacles.contains(key)) {\n                        visited.add(key);\n                        queue.offer(new int[]{newX, newY, currentTurns + 1});\n                    }\n                }\n            }\n        }\n        \n        return visited.size();\n    }\n    \n    public static void main(String[] args) {\n        Set<String> obstacles = new HashSet<>();\n        // Add obstacles as needed, e.g. obstacles.add(\"2,3\");\n\n        int startX = 0;\n        int startY = 0;\n        int turns = 3; // Example number of turns\n        \n        System.out.println(reachableCells(startX, startY, turns, obstacles));\n    }\n}",
    "timestamp": "2025-08-13 05:56:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_GRID_SIZE 100\n#define MAX_TURNS 100\n\ntypedef struct {\n    int x, y;\n} Cell;\n\nconst Cell hex_directions[6] = {\n    {1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, -1}, {-1, 1}\n};\n\nbool is_valid_cell(int x, int y, int grid_size, bool obstacles[MAX_GRID_SIZE][MAX_GRID_SIZE]) {\n    if (x < 0 || x >= grid_size || y < 0 || y >= grid_size)\n        return false;\n    return !obstacles[x][y];\n}\n\nint count_reachable_cells(int grid_size, int start_x, int start_y, int turns, bool obstacles[MAX_GRID_SIZE][MAX_GRID_SIZE]) {\n    bool visited[MAX_GRID_SIZE][MAX_GRID_SIZE] = {false};\n    Cell queue[MAX_GRID_SIZE * MAX_GRID_SIZE];\n    int front = 0, back = 0;\n\n    queue[back++] = (Cell){start_x, start_y};\n    visited[start_x][start_y] = true;\n    int reachable_cells = 1;\n\n    for (int t = 0; t < turns; ++t) {\n        int qsize = back - front;\n        for (int i = 0; i < qsize; ++i) {\n            Cell current = queue[front++];\n            for (int d = 0; d < 6; ++d) {\n                int nx = current.x + hex_directions[d].x;\n                int ny = current.y + hex_directions[d].y;\n                if (is_valid_cell(nx, ny, grid_size, obstacles) && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    queue[back++] = (Cell){nx, ny};\n                    ++reachable_cells;\n                }\n            }\n        }\n    }\n\n    return reachable_cells;\n}\n\nint main() {\n    int grid_size, start_x, start_y, turns, num_obstacles;\n    bool obstacles[MAX_GRID_SIZE][MAX_GRID_SIZE] = {false};\n\n    // Example input for testing purposes:\n    grid_size = 5;\n    start_x = 2;\n    start_y = 2;\n    turns = 3;\n    num_obstacles = 3;\n    Cell obstacle_list[] = {{1, 2}, {2, 3}, {3, 2}};\n\n    for (int i = 0; i < num_obstacles; ++i) {\n        int ox = obstacle_list[i].x;\n        int oy = obstacle_list[i].y;\n        obstacles[ox][oy] = true;\n    }\n\n    int result = count_reachable_cells(grid_size, start_x, start_y, turns, obstacles);\n    printf(\"Reachable cells: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:56:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef count_reachable_cells(grid_size: int, start: Tuple[int, int], max_turns: int, obstacles: List[Tuple[int, int]]) -> int:\n    # Hex grid movement directions\n    directions = [\n        (1, 0), (1, -1), (0, -1), \n        (-1, 0), (-1, 1), (0, 1)\n    ]\n    \n    # Convert obstacles to a set for O(1) lookup\n    obstacle_set = set(obstacles)\n    \n    # Track visited cells and reachable cells\n    visited = set()\n    reachable = set()\n    \n    # BFS queue with (x, y, turns_left)\n    queue = deque([(start[0], start[1], max_turns)])\n    \n    while queue:\n        x, y, turns = queue.popleft()\n        \n        # Skip if already processed or out of turns\n        if (x, y, turns) in visited or turns < 0:\n            continue\n        \n        visited.add((x, y, turns))\n        reachable.add((x, y))\n        \n        # Try moving in each direction\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            \n            # Check grid boundaries and obstacles\n            if (0 <= new_x < grid_size and \n                0 <= new_y < grid_size and \n                (new_x, new_y) not in obstacle_set):\n                queue.append((new_x, new_y, turns - 1))\n    \n    return len(reachable)",
    "timestamp": "2025-08-13 05:57:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef count_reachable_cells(start, obstacles, turns):\n    directions = [ (1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1) ]\n    obstacle_set = set((x, y) for x, y in obstacles)\n    visited = set()\n    queue = deque()\n    start_x, start_y = start\n    queue.append((start_x, start_y, 0))\n    visited.add((start_x, start_y))\n    count = 0\n    \n    while queue:\n        x, y, t = queue.popleft()\n        if t > turns:\n            continue\n        count += 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in obstacle_set and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, t + 1))\n    return count",
    "timestamp": "2025-08-13 05:57:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n// Directions for hexagonal grid movement\nconst vector<pair<int, int>> directions = {\n    {1, 0}, {0, 1}, {-1, 1},\n    {-1, 0}, {0, -1}, {1, -1}\n};\n\nint reachableCells(int startX, int startY, int turns, set<pair<int, int>>& obstacles) {\n    set<pair<int, int>> visited;  // Set of visited cells\n    queue<pair<pair<int, int>, int>> q;  // Queue for BFS (cell, steps)\n\n    visited.insert({startX, startY});\n    q.push({{startX, startY}, 0});\n\n    while (!q.empty()) {\n        auto [current, steps] = q.front();\n        q.pop();\n\n        if (steps == turns) continue;\n\n        for (auto [dx, dy] : directions) {\n            int newX = current.first + dx;\n            int newY = current.second + dy;\n            pair<int, int> newCell = {newX, newY};\n\n            if (obstacles.count(newCell) == 0 && visited.count(newCell) == 0) {\n                visited.insert(newCell);\n                q.push({newCell, steps + 1});\n            }\n        }\n    }\n\n    return visited.size();\n}\n\nint main() {\n    int startX, startY, turns, numObstacles;\n    cin >> startX >> startY >> turns >> numObstacles;\n\n    set<pair<int, int>> obstacles;\n    for (int i = 0; i < numObstacles; ++i) {\n        int x, y;\n        cin >> x >> y;\n        obstacles.insert({x, y});\n    }\n\n    cout << reachableCells(startX, startY, turns, obstacles) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:14"
  }
]