[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\nimport scala.collection.mutable.{Set => MutableSet}\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def next(edge: Set[(Int, Int)], trace: Set[(Int, Int)], restStep: Int): Set[(Int, Int)] =\n    if (restStep == 0) {\n      edge ++ trace\n    } else {\n      next(\n        edge.flatMap(neighbors).filter(neighbor => !(edge ++ trace).contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor)),\n        edge ++ trace,\n        restStep - 1\n      )\n    }\n\n\n  def count(): Int = {\n    next(Set(startPos), Set(), turn).size\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def next(edge: Set[(Int, Int)], innerEdge: Set[(Int, Int)], trace: Int, restStep: Int): Int =\n    if (restStep == 0) {\n      edge.size + trace\n    } else {\n      next(\n        edge.flatMap(neighbors).filter(neighbor => !(edge ++ innerEdge).contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor)),\n        edge,\n        edge.size + trace,\n        restStep - 1\n      )\n    }\n\n\n  def count(): Int = {\n    next(Set(startPos), Set(), 0, turn)\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\nimport collection.mutable.{Set => MutableSet}\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())).toSeq,\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def count(): Int = {\n    val reachable: MutableSet[(Int, Int)] = MutableSet(startPos)\n    (1 to turn).foreach(i =>\n      reachable ++= reachable.flatMap(base => neighbors(base).filter(pos => !reachable.contains(pos)).filter(pos => !obstacles.contains(pos)))\n    )\n    reachable.size\n  }\n\n  def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\nimport collection.mutable.{Set => MutableSet}\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())).toSeq,\n        StdIn.readLine()\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  implicit def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def count(): Int = {\n    val reachable: MutableSet[(Int, Int)] = MutableSet(startPos)\n    (1 to turn).foreach(i =>\n      reachable ++= reachable.flatMap(neighbors).filter(pos => !obstacles.contains(pos)).filter(pos => !reachable.contains(pos))\n    )\n    reachable.size\n  }\n\n  def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1),\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n  while(Reader.hasNext()) {\n    println(Reader.next().count())\n  }\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(step: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) extends Iterator[Int] {\n  private var counter = 0\n  private var restStep = step\n  private var edge: Set[(Int, Int)] = Set(startPos)\n  private var innerEdge: Set[(Int, Int)] = Set()\n\n  def count() = {\n    while (this.hasNext()) {\n      this.next()\n    }\n    counter\n  }\n\n  override def hasNext() = {\n    restStep >= 0\n  }\n\n  override def next() = {\n    restStep = restStep - 1\n    counter = counter + edge.size\n\n    val nextEdge = edge.flatMap(neighbors).filter(neighbor => !(edge ++ innerEdge).contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor))\n    innerEdge = edge\n    edge = nextEdge\n\n    counter\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(step: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) extends Iterator[Int] {\n  private var counter = 0\n  private var restStep = step\n  private var edge: Set[(Int, Int)] = Set(startPos)\n  private var innerEdge: Set[(Int, Int)] = Set()\n\n  def count() = {\n    while (this.hasNext) {\n      this.next()\n    }\n    counter\n  }\n\n  override def hasNext = {\n    restStep >= 0\n  }\n\n  override def next() = {\n    restStep = restStep - 1\n    counter = counter + edge.size\n\n    val nextEdge = edge.flatMap(neighbors).filter(neighbor => !(edge ++ innerEdge).contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor))\n    innerEdge = edge\n    edge = nextEdge\n\n    counter\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def next(pos: (Int, Int), trace: Set[(Int, Int)], restStep: Int): Set[(Int, Int)] =\n    if (restStep == 0) {\n      trace + pos\n    } else {\n      neighbors(pos).filter(neighbor => !trace.contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor)).flatMap(neighbor => {\n        next(neighbor, trace + neighbor, restStep - 1)\n      }) + pos\n    }\n\n\n  def count(): Int = {\n    next(startPos, Set(), turn).size\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\nimport collection.mutable.{Set => MutableSet}\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())).toSeq,\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def count(): Int = {\n    val reachable: MutableSet[(Int, Int)] = MutableSet(startPos)\n    (1 to turn).foreach(i =>\n      reachable ++= reachable.flatMap(neighbors).filter(pos => !obstacles.contains(pos)).filter(pos => !reachable.contains(pos))\n    )\n    reachable.size\n  }\n\n  def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def next(edge: Set[(Int, Int)], innerEdge: Set[(Int, Int)], trace: Set[(Int, Int)], restStep: Int): Set[(Int, Int)] =\n    if (restStep == 0) {\n      edge ++ trace\n    } else {\n      next(\n        edge.flatMap(neighbors).filter(neighbor => !(edge ++ innerEdge).contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor)),\n        edge,\n        edge ++ trace,\n        restStep - 1\n      )\n    }\n\n\n  def count(): Int = {\n    next(Set(startPos), Set(), Set(), turn).size\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "\nimport scala.io.StdIn\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())),\n        createTuple(StdIn.readLine())\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def next(pos: (Int, Int), trace: Set[(Int, Int)], restStep: Int): Set[(Int, Int)] =\n    if (restStep == 0) {\n      trace + pos\n    } else {\n      neighbors(pos).filter(neighbor => !trace.contains(neighbor)).filter(neighbor => !obstacles.contains(neighbor)).flatMap(neighbor => {\n        next(neighbor, trace + neighbor, restStep - 1)\n      }) + pos\n    }\n\n\n  def count(): Int = {\n    next(startPos, Set(), turn).size\n  }\n\n  private def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\nimport collection.mutable.{Set => MutableSet}\n\nobject Main extends App {\n  Reader.foreach(story =>\n    println(story.count())\n  )\n}\n\nobject Reader extends Iterator[BraveForceStory] {\n  private var nextVal = readOnce()\n\n  override def hasNext() = {\n    nextVal.nonEmpty\n  }\n\n  override def next() = {\n    val retVal = nextVal.get\n    nextVal = readOnce()\n    retVal\n  }\n\n  private def readOnce(): Option[BraveForceStory] = {\n    val first = createTuple(StdIn.readLine())\n    if (first != (0, 0)) {\n      Option(BraveForceStory(first._1,\n        (1 to first._2).map(i => createTuple(StdIn.readLine())).toSeq,\n        StdIn.readLine()\n      ))\n    } else {\n      Option.empty\n    }\n  }\n\n  implicit def createTuple(line: String): (Int, Int) = {\n    val splited = line.split(\"\\\\s\").map(str => str.toInt)\n    (splited(0), splited(1))\n  }\n}\n\ncase class BraveForceStory(turn: Int, obstacles: Seq[(Int, Int)], startPos: (Int, Int)) {\n\n  def count(): Int = {\n    val reachable: MutableSet[(Int, Int)] = MutableSet(startPos)\n    (1 to turn).foreach(i =>\n      reachable ++= reachable.flatMap(neighbors).filter(pos => !obstacles.contains(pos)).filter(pos => !reachable.contains(pos))\n    )\n    reachable.size\n  }\n\n  def neighbors(pos: (Int, Int)): Set[(Int, Int)] = {\n    Set(\n      (pos._1 + 1, pos._2 + 1),\n      (pos._1 + 1, pos._2),\n      (pos._1, pos._2 + 1),\n      (pos._1, pos._2 - 1),\n      (pos._1 - 1, pos._2),\n      (pos._1 - 1, pos._2 - 1)\n    )\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nconst int MAX = 200;\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\n\nint t, n, x, y;\nbool obst[MAX][MAX];\nint dist[MAX][MAX];\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> t >> n) {\n        if (t == 0) break;\n        memset(dist, -1, sizeof(dist));\n        memset(obst, 0, sizeof(obst));\n        \n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y;\n            obst[x+100][y+100] = true;\n        }\n        cin >> x >> y;\n        x += 100, y += 100;\n        \n        int res = 1;\n        dist[x][y] = 0;\n        queue<pint> que;\n        que.push(MP(x, y));\n        while (!que.empty()) {\n            pint p = que.front(); que.pop();\n            \n            //cout << p << \" : \" << dist[p.FI][p.SE] << endl;\n            \n            if (dist[p.FI][p.SE] == t) continue;\n            \n            for (int i = 0; i < 6; ++i) {\n                int nx = p.FI + dx[i], ny = p.SE + dy[i];\n                //if (nx < 20 || nx > 80 || ny < 20 || ny > 80) continue;\n                if (dist[nx][ny] == -1 && !obst[nx][ny]) {\n                    dist[nx][ny] = dist[p.FI][p.SE] + 1;\n                    que.push(MP(nx,ny));\n                    ++res;\n                }\n            }\n        }\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 151\n#define INF 1e9\n \nstruct P{\n    int x, y, d;\n    P(int x, int y, int d){\n\tthis->x = x;\n\tthis->y = y;\n\tthis->d = d;\n    }\n};\n \nint t, sx, sy;\nbool impossible[MAX][MAX];\nint dist[MAX][MAX];\nconst int dx[] = {-1,0,0,-1,1,1};\nconst int dy[] = {-1,-1,1,0,0,1};\n \nint bfs(int x, int y){\n    bool visited[MAX][MAX];\n    memset(visited,false,sizeof(visited));\n    fill(dist[0],dist[MAX],INF);\n \n    queue<P> que;\n    que.push(P(x,y,0));\n    dist[x][y] = 0;\n \n    while(!que.empty()){\n\tP p = que.front(); que.pop();\n \n\tif(impossible[p.x][p.y] || p.d > t || \n\t   visited[p.x][p.y]){\n\t    continue;\n\t}\n\tvisited[p.x][p.y] = true;\n \n\tfor(int i = 0 ; i < 6 ; i++){\n\t    int nx = p.x + dx[i];\n\t    int ny = p.y + dy[i];\n       \n\t    if(impossible[nx][ny] || dist[nx][ny] != INF){\n\t\tcontinue;\n\t    }\n \n\t    dist[nx][ny] = dist[p.x][p.y] + 1;\n\t    que.push(P(nx,ny,dist[nx][ny]));\n\t}\n    }\n \n    int res = 0;\n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX ; j++){\n\t    if(dist[i][j] <= t){\n\t\tres++;\n\t    }\n\t}\n    }\n    return res;\n}\n \nint main(){\n    int n, x, y;\n \n    while(cin >> t >> n , (t | n)){\n\tmemset(impossible,false,sizeof(impossible));\n\tfor(int i = 0 ; i < n ; i++){\n\t    cin >> x >> y;\n\t    x += 75, y += 75;\n\t    impossible[x][y] = true;\n\t}\n\tcin >> sx >> sy;\n\tcout << bfs(sx+75, sy+75) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\n#define MAX 30\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n\tint t, n, x, y;\n\tbool m[MAX * 4 + 1][MAX * 4 + 1];\n\tqueue<pair<int, pair<int, int>>> q;\n\twhile (cin >> t >> n, t) {\n\t\tfill(m[0], m[MAX * 4 + 1], false);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx += MAX * 2; y += MAX * 2;\n\t\t\tm[y][x] = true;\n\t\t}\n\t\tcin >> x >> y;\n\t\tx += MAX * 2; y += MAX * 2;\n\t\tint c = 1;\n\t\tm[y][x] = true;\n\t\tq.push(make_pair(t, make_pair(x, y)));\n\t\twhile (!q.empty()) {\n\t\t\tauto e = q.front();\n\t\t\tq.pop();\n\t\t\tt = e.first; x = e.second.first; y = e.second.second;\n\t\t\tif (t > 0) {\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (!m[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tm[y + dy[i]][x + dx[i]] = true;\n\t\t\t\t\t\tq.push(make_pair(t - 1, make_pair(x + dx[i], y + dy[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#define range(x,y,h1,h2) x >= 0 && x < h1 && y >= 0 && y < h2\n\nusing namespace std;\n\nint main(void){\n\tint t, n, i, j, field[61][61], ix, iy, count;\n\tconst int standard = 30, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<int> x, y;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t == 0 && n == 0)\n\t\t\tbreak;\n\t\tmemset(field,-1,sizeof(field));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&ix,&iy);\n\t\t\tfield[iy + standard][ix + standard] = 0;\n\t\t}\n\t\tscanf(\"%d%d\",&ix,&iy);\n\t\tx.push(standard + ix),y.push(standard + iy);\n\t\tfield[standard + iy][standard + ix] = 0;\n\t\twhile(x.size()){\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(field[y.front() + dy[i]][x.front() + dx[i]] == -1 && field[y.front()][x.front()] < t && range(x.front() + dx[i],y.front() + dy[i],61,61)){\n\t\t\t\t\tx.push(x.front() + dx[i]),y.push(y.front() + dy[i]);\n\t\t\t\t\tfield[y.front() + dy[i]][x.front() + dx[i]] = field[y.front()][x.front()] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.pop(), y.pop();\n\t\t}\n\t\tcount = 1;\n\t\tfor(i = 0;i < 61;i++){\n\t\t\tfor(j = 0;j < 61;j++)\n\t\t\t\tif(field[i][j] > 0)\n\t\t\t\t\tcount++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\t\n\twhile(cin >> t >> n, t) {\n\t\tqueue<state> Q;\n\t\tvvi field(61, vi(61, 0));\n\t\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tint count = 0;\n\t\tif(field[sx+30][sy+30] == 0) {\n\t\t\tfield[sx+30][sy+30] = 1;\n\t\t\tcount++;\n\t\t}\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(st.t < t) {\n\t\t\t\tREP(d, 6) {\n\t\t\t\t\tif(abs(st.x+dx[d]-30)<= 30 && abs(st.y+dy[d]-30)<=30) {\n\t\t\t\t\t\tif(field[st.x+dx[d]][st.y+dy[d]] == 0) {\n\t\t\t\t\t\t\tfield[st.x+dx[d]][st.y+dy[d]] = 1;\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#define dot pair<int,int>\nusing namespace std;\nint main(){\n  int dx[6]={1,-1,0,0,1,-1};\n  int dy[6]={0,0,1,-1,1,-1};\n  int field[90][90];\n  int t,n;\n  while(cin >>t>>n,t||n){\n    for(int i=0; i<90; i++) for(int j=0; j<90; j++) field[i][j] = 0;\n    for(int i=0,a,b; i<n; i++){\n      cin >>a>>b;\n      field[a+45][b+45] = 1;\n    }\n    int sx,sy;\n    cin >>sx>>sy;\n    queue<dot > f;\n    int ans = 0;\n    f.push(make_pair(45+sx,45+sy));\n    field[45+sx][45+sy] = 1;\n    while(!f.empty()){\n      ans++;\n      dot x = f.front();\n      f.pop();\n      if(field[x.first][x.second]<=t){\n\tfor(int i=0; i<6; i++){\n\t  if(field[x.first+dx[i]][x.second+dy[i]] == 0 &&\n\t     x.first+dx[i]>=15 && x.first+dx[i]<=75 &&\n\t     x.second+dy[i]>=15 && x.second+dy[i]<=75){\n\t    field[x.first+dx[i]][x.second+dy[i]] = field[x.first][x.second]+1;\n\t    f.push(make_pair(x.first+dx[i],x.second+dy[i]));\n\t  }\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n#include <cstdio>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[64][64] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    //cin >> tt >> nn;\n    scanf(\"%d%d\",&tt, &nn);\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      //cin >> x >> y;\n      scanf(\"%d%d\",&x, &y);\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    //cin >> x >> y;\n    scanf(\"%d%d\",&x, &y);\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<64;j++){\n      for(k=0;k<64;k++){\n        visited[j][k]=0;\n      }\n    }\n    cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  //if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  if(t==1){\n    if(visited[x][y]==1) return ans;\n    else {visited[x][y]=1;return ans+1;}\n  }\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nbool isRange(int x,int y){\n\n    return -50<=x && x<=49 && -50<=y && y<=49;\n}\nint main(){\n    int t,n;\n    int dx[6]={1,1,0,-1,-1,0};\n    int dy[6]={1,0,-1,-1,0,1};\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(100,vector<int>(100,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+50][y+50]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        vector<vector<int>> been(100,vector<int>(100,0));\n        been[s.first+50][s.second+50]=1;\n        int cnt=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        while(!q.empty()){\n            auto state=q.front();\n            q.pop();\n            auto p=state.first;\n            int turn=state.second;\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isRange(tox,toy) && !ob[tox+50][toy+50] && !been[tox+50][toy+50]){\n                    been[tox+50][toy+50]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n                }\n\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int t,n;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0)break;\n    vector<vi> v(65,vi(65,INF));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      v[x+30][y+30]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<pii> q;\n    q.push(pii(sx+30,sy+30));\n    v[sx+30][sy+30]=0;\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      if(v[x][y]>=t)continue;\n      rep(i,6){\n\tint nx=x+dx[i];\n\tint ny=y+dy[i];\n\tif(nx>=0 && nx<=60 && ny>=0 && ny<=60 && v[nx][ny]>=0 && v[nx][ny]>v[x][y]){\n\t  v[nx][ny]=v[x][y]+1;\n\t  q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    int ans=0;\n    rep(i,61)rep(j,61)\n      if(v[i][j]>=0 && v[i][j]<INF)ans++;\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst long long INF = LLONG_MAX / 2;\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i, r, n) for(int i=(ll)(r); i<(ll)(n); i++) \n#define REP(i, n) FOR(i, (0), n)\n#define ALL(r) r.begin(), r.end()\n#define ll long long int\nusing namespace std;\nstring s;\nvector<ll> v;\nvector<pair<ll, ll>> vp;\nvector<vector<ll>> vv(110, vector<ll>(110, INF));\nvector<tuple<ll, ll, ll>> vt;\nset<ll> st;\nmap<char, ll> mp;\n\nll n, m;\nset<pair<ll, ll>> done, imp;\n\nvoid solve(int dep, int x, int y)\n{\n\tif (dep <= n)\n\t{\n\t\tif (!imp.count(make_pair(x, y))) {\n\t\t\tdone.emplace(x, y);\n\t\t\tif (dep < n)\n\t\t\t{\n\t\t\t\tsolve(dep + 1, x + 1, y + 1);\n\t\t\t\tsolve(dep + 1, x + 1, y);\n\t\t\t\tsolve(dep + 1, x, y + 1);\n\t\t\t\tsolve(dep + 1, x, y - 1);\n\t\t\t\tsolve(dep + 1, x - 1, y);\n\t\t\t\tsolve(dep + 1, x - 1, y - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tdone.clear(); imp.clear();\n\t\tcin >> n >> m;\n\t\tif (!n && !m) break;\n\t\tREP(i, m)\n\t\t{\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\timp.emplace(a, b);\n\t\t}\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tsolve(0, x, y);\n\t\tcout << done.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nint n,t;\nmap<pii,int> mp;\nset<pii> s;\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\nint solve(){\n    mp.clear(); s.clear();\n    int res = 0;\n    for(int i = 0; i < n;i++){\n        int x,y; cin >> x >> y;\n        s.insert(make_pair(x,y));\n    }\n    int x,y; cin >> x >> y;\n    using piii = pair<pii,int>;\n    queue<piii> q; q.push({{x,y},1});\n//    mp[make_pair(x,y)] = 1;\n    while(q.size()){\n        int T,X,Y; auto P = q.front(); q.pop();\n        T = P.second; tie(X,Y) = P.first;\n        if(mp[{X,Y}] == 0 || mp[{X,Y}] > T){\n            mp[{X,Y}] = T;\n        }\n        if(T > t) continue;\n        for(int k = 0; k < 6;k++){\n            int nX = X + dx[k],nY = Y + dy[k];\n            if(s.find({nX,nY}) != s.end()) continue;\n            q.push({{nX,nY},T+1});\n        }\n    }\n    res = (int)mp.size();\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> t >> n,t){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint panel[101][101];\nint dd[] = {0, 1, 1, 0, -1, -1, 0};\n\nvoid wfs(int x, int y, int t) {\n  priority_queue<PIP> q;\n  q.push(PIP(t, P(x, y)));\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    if (panel[p.se.se][p.se.fi] == 1) continue;\n    else panel[p.se.se][p.se.fi] = 1;\n\n    if (p.fi == 0) continue;\n    rep(i, 6) {\n      int yy = p.se.se + dd[i], xx = p.se.fi + dd[i + 1];\n      if (panel[yy][xx] == 0) q.push(PIP(p.fi - 1, P(xx, yy)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t, n;\n  while(cin >> t >> n, t | n) {\n    rep(i, 101)rep(j, 101) panel[i][j] = 0;\n\n    rep(i, n) {\n      int x, y;\n      cin >> x >> y; x += 50, y += 50;\n      if (0 <= x && x < 101 && 0 <= y && y < 101) panel[y][x] = 2;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    wfs(x + 50, y + 50, t);\n\n    int ans = 0;\n    rep(i, 101)rep(j, 101) if (panel[i][j] == 1) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 35\n#define NN 2*N\n#define UNKNOWN 10000\nusing namespace std;\n#define S pair<int,int>\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,1,0,-1,-1,0};\n  int dy[6] = {1,0,-1,-1,0,1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[y][x] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n    queue<S> q; q.push( S(x,y) );\n    d[y][x]=0;\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      int nt = d[s.second][s.first] + 1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.first+dx[i], ny=s.second+dy[i];\n\tif( nx<0 || nx>=NN ) continue;\n\tif( ny<0 || ny>=NN ) continue;\n\tif( d[ny][nx]==UNKNOWN ){\n\t  d[ny][nx]=nt; ans++;\n\t  if( nt<t ) q.push( S(nx,ny) );\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint main(){\n\tint t,N;\n\tint dx[6]={1,1,0,-1,-1,0};\n\tint dy[6]={0,1,1,0,-1,-1};\n\twhile(cin>>t>>N && (t!=0||N!=0)){\n\t\tint visited[121][121]={0};\n\t\tint tx,ty,ans=0;\n\t\tqueue<pair<int,int>> q;\n\t\tREP(i,0,N){\n\t\t\tcin>>tx>>ty;\n\t\t\tvisited[ty+60][tx+60]=-1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tq.push({sx+60,sy+60});\n\t\tvisited[sy+60][sx+60]=1;\n\t\twhile(!q.empty()){\n\t\t\tint nowx=q.front().first,nowy=q.front().second;\n\t\t\tq.pop();\n\t\t\tREP(k,0,6){\n\t\t\t\tint nextx=nowx+dx[k],nexty=nowy+dy[k];\n\t\t\t\tif(visited[nexty][nextx]==-1||visited[nexty][nextx]!=0) continue;\n\t\t\t\tvisited[nexty][nextx]=visited[nowy][nowx]+1;\n\t\t\t\tif(visited[nexty][nextx]<=t)\t\tq.push({nextx,nexty});\n\t\t\t}\n\t\t}\n\t\tREP(i,0,121)\tREP(j,0,121)\tif(visited[i][j]>0)\tans++;\n\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int INF = numeric_limits<int>::max() / 2;\n\nint sx,sy,n,t;\nint field[200][200];//0:can't 1:can\nint d[200][200];\nint dx[6]={1,0,1,-1,0,-1},dy[6]={1,1,0,-1,-1,0};\n\nvoid solve(){\n  queue<pii> que;\n  for(int i=0;i<200;i++) for(int j=0;j<200;j++) d[i][j]=INF;\n  que.push(pii(sx+100,sy+100));\n  d[sx+100][sy+100]=0;\n\n  while(que.size()){\n    pii p=que.front();que.pop();\n    for(int i=0;i<6;i++){\n      int nx=p.first+dx[i],ny=p.second+dy[i];\n\n      if(0<=nx&&nx<200&&0<=ny&&ny<200&&field[nx][ny]&&d[nx][ny]==INF){\n        que.push(pii(nx,ny));\n        d[nx][ny]=d[p.first][p.second]+1;\n      }\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n    cin >>t >> n;\n    if(n==0&&t==0)break;\n    for(int i=0;i<200;i++) for(int j=0;j<200;j++) field[i][j]=1;\n    for(int i=0;i<n;i++){\n      int x,y;cin >> x>> y;\n      field[x+100][y+100]=0;\n    }\n    cin >> sx>>sy;\n    solve();\n    int res=0;\n    for(int i=0;i<200;i++) for(int j=0;j<200;j++) if(d[i][j]<=t) res++;\n    cout <<res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mStep;\n  int mX;\n  int mY;\n  State(int step,int x,int y) : mStep(step), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mStep < s.mStep;\n  }\n\n  bool operator >(const State& s) const{\n    return mStep > s.mStep;\n  }\n};\n\n// int CoundVisitedCell(map<P,int>& stage){\n//   int count = 0;\n//   for(int y=-30;y<=30;y++){\n//     for(int x=-30;x<=30;x++){\n//       if(stage.find(P(x,y)) == stage.end()) continue;\n//       if(stage[P(x,y)] >= 0) count++;\n//     }\n//   }\n//   return count;\n// }\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(0,sx,sy));\n    stage[P(sx,sy)] = 0;\n\n    int res = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      res++;\n      if(s.mStep >= t) continue;\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\n\t//obstacle\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\n\t//small step count is better\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && s.mStep+1 >= stage[P(dx,dy)] ) continue;\n\n\tstage[P(dx,dy)] = s.mStep+1;\n\tque.push(State(s.mStep+1,dx,dy));\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nconst int MAXINT=100;\nint dx[6]={1,-1,0,0,1,-1};\nint dy[6]={0,0,1,-1,1,-1};\nbool used[MAXINT][MAXINT];\nbool rock[MAXINT][MAXINT];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,MAXINT){\n\t\t\tfill(used[i],used[i]+MAXINT,false);\n\t\t\tfill(rock[i],rock[i]+MAXINT,false);\n\t\t}\n\t\tint x,y;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trock[y+MAXINT/2][x+MAXINT/2]=true;\n\t\t}\n\t\tcin>>x>>y;\n\t\tused[y+MAXINT/2][x+MAXINT/2]=true;\n\t\tqueue<piii> que;\n\t\tque.push(piii(0,pii(x+MAXINT/2,y+MAXINT/2)));\n\t\twhile(!que.empty()){\n\t\t\tpiii now=que.front();\n\t\t\tused[now.second.second][now.second.first]=true;\n\t\t\tque.pop();\n\t\t\trep(i,6){\n\t\t\t\tif(used[now.second.second+dy[i]][now.second.first+dx[i]]||rock[now.second.second+dy[i]][now.second.first+dx[i]])continue;\n\t\t\t\tif(now.first+1>t)continue;\n\t\t\t\tused[now.second.second+dy[i]][now.second.first+dx[i]]=true;\n\t\t\t\tque.push(piii(now.first+1,pii(now.second.first+dx[i],now.second.second+dy[i])));\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\trep(i,MAXINT){\n\t\t\trep(j,MAXINT){\n\t\t\t\tif(used[i][j])cnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(0);\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<class T>void swap(T &a, const T &b) {\n\tT tmp = a;\n\ta = b;\n\tb = a;\n\treturn;\n}//aとbを入れ替える\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll POW_MOD(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {//最小公倍数\n\treturn a * b / gcd(a, b);\n}\nint mergecount(vector<int> &a) {\n\t//反転数(バブルソートの交換回数)を数える\n\tint count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += mergecount(b);\n\t\tcount += mergecount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nbool  Warshall_Floyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> dijkstra(int i, vector<vector<edge>> graph) {\n\t//第一引数 i:始点\n\t//第二引数 グラフ(辺の重み付き)\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool Bellman_Ford(int start, int E, int V, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:E 辺の数\n\t//第三引数:V 頂点数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\t/*\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tif (t[V - 1]) {\n\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\t*/\n\treturn true;\n}\nbool topological_sort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> articulationPoint(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nedge tree_diameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<ll> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<ll> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tint d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tint t, n; cin >> t >> n;\n\t\tif (t == 0 && n == 0) { return 0; }\n\n\t\tvector<int> block_x(n), block_y(n);\n\n\t\tint MMMM = 70;\n\t\tvector<vector<bool>> check(150, vector<bool>(150, true));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> block_x[i] >> block_y[i];\n\t\t\tblock_x[i] += MMMM;\n\t\t\tblock_y[i] += MMMM;\n\t\t\tcheck[block_x[i]][block_y[i]] = false;\n\t\t}\n\n\t\tint a, b; cin >> a >> b;\n\n\t\tvector<vector<int>> f;\n\t\tresize(f, 150, 150);\n\n\t\tqueue<pair<pair<int, int>, int>> q;\n\t\tq.push(make_pair(make_pair(a + MMMM, b + MMMM), 0));\n\n\t\tint ans = 1;\n\t\tcheck[a + MMMM][b + MMMM] = false;\n\n\t\twhile (q.size()) {\n\n\t\t\tint x = q.front().first.first, y = q.front().first.second, k = q.front().second; q.pop();\n\n\t\t\tif (k == t) { break; }\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tbool g = true;\n\t\t\t\tif (check[nx][ny]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tcheck[nx][ny] = false;\n\t\t\t\t\tq.push(make_pair(make_pair(nx, ny), k + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#define MAXX 60\n#define MAXY 60\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\nint ccc;\n\n\n//深さ優先の再帰関数\nvoid solve2(int x,int y,int depth){\n\t//深さ0で終了\n\tif(depth==0) return;\n\t//x,y点周辺を探索済みにする\n\tfor(int i=0;i<6;i++){\n\t\tif(!flg[(x+xd[i])%MAXX][(y+yd[i])%MAXY] && mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY] ){\n\t\t\tccc++;\n\t\t}\n\t\tflg[(x+xd[i])%MAXX][(y+yd[i])%MAXY]=true;\n\t}\n\t//x,y点周辺でかつ，障害物のない点を探索する\n\tfor(int i=0;i<6;i++)\n\t\tif(mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY])\n\t\t\tsolve2((x+xd[i])%MAXX,(y+yd[i])%MAXY,depth-1);\n}\n\n//再帰関数を呼び出し，数え上げるための関数\nint solve(int x,int y,int depth){\n\treturn 0;\n\tccc=1;\n\t//始点を探索済みにする\n\tflg[x][y]=true;\n\t//始点より深さ優先\n\tsolve2(x,y,depth);\n\t//解を出力\n\treturn ccc;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+60·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_COOR 121\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 60][obsy + 60] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 60;\n\t\tstarty += 60;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<\"ans = \" <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÌ½ßÌì)\n\t\t\t\tif(/*nowx <= 60 && nowx >= 0 && nowy <= 60 && nowy >= 0 && */endcnt[nowx][nowy] == false){\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\nstruct Node {\n\tint x, y, step;\n};\n\nint _m[200][200] = {0};\nbool _reached[200][200] = {0};\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfill(&_m[0][0], &_m[0][0]+200*200, 0);\n\t\tint (*m)[200] = _m + 100;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tm[y][x] = true;\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\n\t\tfill(&_reached[0][0], &_reached[0][0]+200*200, false);\n\t\tbool (*reached)[200] = _reached + 100;\n\t\tqueue<Node> Q; Q.push({sx, sy, 0});\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.front(); Q.pop();\n\t\t\tint step = node.step, x = node.x, y = node.y;\n\t\t\tif (step > t) continue;\n\t\t\tif (m[y][x]) continue;\n\t\t\tif (reached[y][x]) continue;\n\t\t\treached[y][x] = true;\n\n\t\t\tQ.push({x+1, y+1, step+1});\n\t\t\tQ.push({x+1, y, step+1});\n\t\t\tQ.push({x, y-1, step+1});\n\t\t\tQ.push({x-1, y-1, step+1});\n\t\t\tQ.push({x-1, y, step+1});\n\t\t\tQ.push({x, y+1, step+1});\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int y = -60; y <= 60; ++y) {\n\t\t\tfor (int x = -60; x <= 60; ++x) {\n\t\t\t\tif ( reached[y][x] ) {\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\n\nbool checkSyougai(vector<pair<int, int> > syougai, int x, int y){\n\tfor(int i = 0; i < syougai.size(); i++){\n\t\tif(syougai[i].first == x && syougai[i].second == y) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint dx[] = {-1, -1, 0, 0, 1, 1};\n\tint dy[] = {-1, 0, 1, -1, 0, 1};\n\tmap<int, map<int, bool> > field;\n\tint t, n;\n\tvector<pair<int, int> > syougai;\n\tpair<int, int> start;\n\n\twhile(cin >> t >> n && (t != 0 || n != 0)){\n\t\t//fieldの初期化\n\t\tfor(int i = -30; i <= 30; i++){\n\t\t\tfor(int j = -30; j <= 30; j++){\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\t//障害物とスタート地点の読み込み\n\t\tsyougai.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpair<int, int> tmp;\n\t\t\tcin >> tmp.X >> tmp.Y;\n\t\t\tsyougai.push_back(tmp);\n\t\t}\n\t\tcin >> start.X >> start.Y;\n\n\t\t//□■■\n\t\t//■■■\n\t\t//■■□fieldは普通の配置を想定して、こんなかんじで探索\n\t\tqueue<pair<int, int> > a;\n\t\tint count = 1;\n\t\ta.push(start);\n\t\tfield[start.Y][start.X] = true;\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tqueue<pair<int, int> > b;\n\t\t\twhile(!a.empty()){\n\t\t\t\tpair<int, int> tmp = a.front();\n\t\t\t\ta.pop();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\tif((tmp.X + dx[i] < -30 && tmp.X + dx[i] > 30) || (tmp.Y + dy[i] < -30 && tmp.Y + dy[i] > 30)) continue;\n\t\t\t\tif(checkSyougai(syougai, tmp.X + dx[i], tmp.Y + dy[i]) && field[tmp.Y + dy[i]][tmp.X + dx[i]] != true){\n\t\t\t\t\t\tpair<int ,int> next(tmp.X + dx[i], tmp.Y + dy[i]);\n\t\t\t\t\t\tb.push(next);\n\t\t\t\t\t\tfield[tmp.Y + dy[i]][tmp.X + dx[i]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta = b;\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint flag[70][70],a[70][70],dp[70][70],t,r,cnt;\n\nvoid bfs(int x,int y, int how){\n  if(how>t) return;\n  if(x<0||x>60 || y<0||y>60) return;\n  if(flag[y][x]&&dp[y][x]<how) return;\n  if(a[y][x]) return;\n  cnt++;\n  dp[y][x]=max(how,dp[y][x]);\n  flag[y][x]=1;\n  bfs(x+1,y,how+1);\n  bfs(x,y+1,how+1);\n  bfs(x+1,y+1,how+1);\n  bfs(x-1,y,how+1);\n  bfs(x,y-1,how+1);\n  bfs(x-1,y-1,how+1);\n\n}\n\nint main(){\n  for(;;){\n  int q;\n  cin>>t>>q;\n  if(t==0&&q==0) break;\n  for(int i=0;i<70;i++) for(int j=0;j<70;j++){\n      flag[i][j]=a[i][j]=0;\n      dp[i][j]=-1;\n    }\n  r=cnt=0;\n  for(int i=0,t1,t2;i<q;i++){\n    cin>>t1>>t2;\n    a[t2+30][t1+30]=1;\n  }\n  int y0,x0;\n  cin>>x0>>y0;\n  x0+=30;\n  y0+=30;\n  bfs(x0,y0,0);\n  for(int i=0;i<61;i++)\tfor(int\tj=0;j<61;j++) if(dp[i][j]+1) r++;\n  /*  for(int i=0;i<61;i++){                                                                                                                                                                   \n    for(int j=0;j<61;j++) cout<<(flag[j][i]?\"1\":\" \")<<\" \";                                                                                                                                     \n    cout<<endl;                                                                                                                                                                                \n    } */\n  cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;++i)\n#define M(a,b) make_pair(a,b)\n#define f first\n#define s second\nusing namespace std;\nint dx[]={0,0,1,1,-1,-1,},dy[]={1,-1,1,0,-1,0};\nbool v[200][200];\nint a,b,t,n;\nint main(){\n  while(cin>>t>>n,t){\n    r(i,200)r(j,200)v[i][j]=0;\n    while(n--){\n      cin>>b>>a;\n      v[a+100][b+100]=1;\n    }cin>>a>>b;int c=0;\n    queue<pair<pair<int,int>,int> >q;\n    q.push(M(M(b+100,a+100),0));\n    while(!q.empty()){\n      pair<pair<int,int>,int > p=q.front();q.pop();\n      if(p.s==t+2)continue;\n      c++;\n      v[p.f.f][p.f.s]=1;\n      r(i,6)if(!v[p.f.f+dy[i]][p.f.s+dx[i]]&&p.s+1<=t){\n        q.push(M(M(p.f.f+dy[i],p.f.s+dx[i]),p.s+1));\n        v[p.f.f+dy[i]][p.f.s+dx[i]]=1;\n      }\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 100>, 100> hex, array<array<int32_t, 100>, 100> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 0;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t posx = x + iter->first;\n      int32_t posy = y + iter->second;\n      if (0 <= posx && posx < (int32_t)dists.size() && 0 <= posy && posy < (int32_t)dists[0].size() && !hex[posx][posy] &&\n          dists[posx][posy] == INT32_MAX) {\n        dists[posx][posy] = dists[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 100>, 100> hex;\n    array<array<int32_t, 100>, 100> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = INT32_MAX;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 50][y + 50] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 50, y + 50);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (*i <= t) {\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[6] = { 0, 1, 1, 0, -1, -1 };\nint dy[6] = { 1, 1, 0, -1, -1, 0 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nsigned main() {\n    int t, n;\n    while (cin >> t >> n) {\n\tif (t == 0 && n == 0) break;\n\n\tset<pair<int, int>> s;\n\trep(i, n) {\n\t    int x, y;\n\t    cin >> x >> y;\n\t    s.insert(make_pair(x, y));\n\t}\n\tint x, y;\n\tcin >> x >> y;\n\n\tset<pair<int, int>> visited;\n\tqueue<pair<int, int>> q, nq;\n\tq.push(make_pair(x, y));\n\n\trep(i, t + 1) {\n\t    while (!q.empty()) {\n\t\tpair<int, int> now = q.front(); q.pop();\n\t\tif (visited.find(now) != visited.end()) continue;\n\t\tif (s.find(now) != s.end()) continue;\n\t\tvisited.insert(now);\n\t\trep(dir, 6) {\n\t\t    auto nx = make_pair(now.first + dx[dir], now.second + dy[dir]);\n\t\t    nq.push(nx);\n\t\t}\n\t    }\n\t    swap(q, nq);\n\t}\n\n\tcout << visited.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[1100][1100], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] >= t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[1100][1100] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define RREP(i,n) for(int i=(n)-1;i>=0;i--)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n#define INF (1<<28)\n#define int(n) int n; cin >> n;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){if(n < m) return 0;\n    unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\nint quadratic(int a, int b, int c){return (int)(-b + sqrt(b*b - 4*a*c)) / 2*a;}\n\nvoid cp(int from[], int to[], int l){REP(i, l) to[i] = from[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double x1, double y1, double x2, double y2, double x3, double y3, double res[3]){\n    double xp1 = (y1-y3)*(y1*y1-y2*y2+x1*x1-x2*x2) - (y1-y2)*(y1*y1-y3*y3+x1*x1-x3*x3);\n    double xp2 = 2*(y1-y3)*(x1-x2)-2*(y1-y2)*(x1-x3);\n    res[0] = xp1/xp2;\n    double yp1 = (x1-x3)*(x1*x1-x2*x2+y1*y1-y2*y2) - (x1-x2)*(x1*x1-x3*x3+y1*y1-y3*y3);\n    double yp2 = 2*(x1-x3)*(y1-y2)-2*(x1-x2)*(y1-y3);\n    res[1] = yp1/yp2;\n    double r = (x3-res[0])*(x3-res[0])+(y3-res[1])*(y3-res[1]);\n    res[2] = sqrt(r);\n}\n\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\n\n\nint table[70][70], forbidden[70][70], visited[70][70];\n\nint vy[6] = {-1, 1, 0, 0, 1, -1}, vx[6] = {0, 0, -1, 1, 1, -1};\nint main(int argc, const char * argv[]){\n    while (true) {\n        REP(i, 70) REP(j, 70){\n            table[i][j] = 0;\n            forbidden[i][j] = 0;\n            visited[i][j] = 0;\n        }\n        \n        int t, n;\n        cin >> t >> n;\n        if(!(t+n)) break;\n        \n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            x+=35; y+=35;\n            forbidden[y][x] = 1;\n        }\n    \n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 35, sy += 35;\n        \n        queue<int> qy, qx, qcnt;\n        visited[sy][sx] = 1;\n        int ans = 1;\n        qy.push(sy);\n        qx.push(sx);\n        qcnt.push(0);\n        while(!qy.empty()){\n            int y = qy.front(); qy.pop();\n            int x = qx.front(); qx.pop();\n            int cnt = qcnt.front(); qcnt.pop();\n            \n            if(cnt >= t) continue;\n            \n            REP(k, 6){\n                int ny = y + vy[k];\n                int nx = x + vx[k];\n                if(!visited[ny][nx] && !forbidden[ny][nx]){\n                    // cout << ny  << \" \" << nx << endl;\n                    qy.push(ny);\n                    qx.push(nx);\n                    qcnt.push(cnt + 1);\n                    visited[ny][nx] = 1;\n                    ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define REP(i,a,n) for(ll i=a;i<n;i++)\n#define ALL(s) s.begin(),s.end()\n#define P pair<ll,ll>\n#define vl vector<ll>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vvl vector<vector<ll>>\n#define print(n) cout<<n<<endl\nconst int M=100010;\nconst int inf=1000000007;\nconst long long INF=1000000000000000007;\nusing ll=long long;\n//int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,t;\nint m[200][200],fast[200][200];\nint dx[6]={0,1,0,-1,1,-1},dy[6]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n\tm[y][x]=1;\n\tif(len<t&&len<fast[y][x]){\n\t\tfast[y][x]=len;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tif(m[y+dy[i]][x+dx[i]]!=-1)\n\t\t\t\tDFS(y+dy[i],x+dx[i],len+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t\tfast[i][j]=100;\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tm[100+y][100+x]=-1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tDFS(y+100,x+100,0);\n\t\tint ans=0;\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tif(m[i][j]==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\ntypedef pair<pii,int>piii;\nint dx[]={0,-1,1};\nint dy[]={0,-1,1}\n;int main(){\n    int t,n;\n    while(cin>>t>>n){\n        int ans=0;\n        if(t+n==0)break;\n        map<pii,int>mp;\n        pii s;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>s.first>>s.second;\n        queue<piii>que;\n        que.push(make_pair(s,0));\n        while(!que.empty()){\n            piii now=que.front();que.pop();\n            if(abs(now.first.first)>30||abs(now.first.second)>30)continue;\n            if(now.second>t)continue;\n            if(now.second>mp[now.first]&&mp[now.first]!=0)continue;\n            if(mp[now.first]==0)ans++;\n            mp[now.first]=now.second;\n            if(now.first==s)mp[s]=-INF;\n            rep(i,3)rep(j,3){\n                if(dx[i]+dy[j]==0)continue;\n                pii next=pii(now.first.first+dx[i],now.first.second+dy[j]);\n                if(mp[next]==-INF)continue;\n                if(mp[next]<now.second+1){\n                    piii hoge;\n                    hoge.first=next;\n                    hoge.second=now.second+1;\n                    que.push(hoge);\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\t//iostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvoid solve() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) return;\n\t\tmap<pair<int, int>, int> next;\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tnext[mp(a, b)] = 1;\n\t\t}\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tqueue<pair<int, int>> gogo;\n\t\tgogo.push(mp(a, b));\n\t\tmap<pair<int, int>, int> visited;\n\t\tvisited[mp(a, b)] = 1;\n\t\tint ans = 0;\n\t\twhile (gogo.empty() == false) {\n\t\t\tpair<int, int> now = gogo.front();\n\t\t\tgogo.pop();\n\t\t\tans++;\n\t\t\tint dx[6] = { 0,-1,-1,0,1,1 };\n\t\t\tint dy[6] = { 1,0,-1,-1,0,1 };\n\t\t\tREP(q, 6) {\n\t\t\t\tint x = now.first + dx[q];\n\t\t\t\tint y = now.second + dy[q];\n\t\t\t\tif (next[mp(x, y)] == 1) continue;\n\t\t\t\tif (visited[mp(x, y)] != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[mp(x, y)] = visited[now] + 1;\n\t\t\t\tif (visited[mp(x, y)] != n + 1) {\n\t\t\t\t\tgogo.push(mp(x, y));\n\t\t\t\t}\n\t\t\t\telse ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nclass state{\npublic:\n\tint x;\n\tint y;\n\tint turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tif(field[s.x+1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y+1, s.turn+1));\n\t\t\t\t\tfield[s.x][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x-1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y-1, s.turn+1));\t\n\t\t\t\t\tfield[s.x][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x+1][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y+1, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y-1, s.turn+1));\n\t\t\t\t\tfield[s.x-1][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint visited[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  visited[y][x] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[y][x-1] && i+1 < visited[y][x-1]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[y-1][x] && i+1 < visited[y-1][x]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[y-1][x-1] && i+1 < visited[y-1][x-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[y][x+1] && i+1 < visited[y][x+1]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[y+1][x] && i+1 < visited[y+1][x]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[y+1][x+1] && i+1 < visited[y+1][x+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        visited[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[y+30][x+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (visited[i][j] < INF) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint main() {\n  int t, n;\n  while(cin >> t >> n && (t|n)) {\n    int M[62][62] = {};\n    int const BX = 31, BY = 31;\n    for(int i=0; i<n; i++) {\n      int x, y;\n      cin >> x >> y;\n      M[y+BY][x+BX] = 1;\n    }\n    \n    int const dx[] = {-1,1,0,0,1,-1};\n    int const dy[] = {0,0,-1,1,1,-1};\n    \n    typedef pair<int, int> Pii;\n    typedef pair<Pii, int> P;\n    \n    bool used[62][62] = {};\n    int ans = 0;\n    \n    int sx, sy;\n    cin >> sx >> sy; sx += BX, sy += BY;\n    \n    queue<P> Q;\n    Q.push(P(Pii(sx, sy), t));\n    used[sy][sx] = true;\n    \n    while(!Q.empty()) {\n      P const p = Q.front(); Q.pop();\n      ans ++;\n      \n      if(p.snd <= 0) continue;\n      \n      for(int i=0; i<6; i++) {\n\tint nx = p.fst.fst + dx[i], ny = p.fst.snd + dy[i];\n\tif(!used[ny][nx] && M[ny][nx] == 0) {\n\t  Q.push( P(Pii(nx, ny), p.snd-1) );\n\t  used[ny][nx] = true;\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\n#define mp(a,b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\nint main() {\n\n\tconst int SIZE = 62;\n\tconst int OFFSET = 31;\n\tconst int\tmx[] = {0, 1, 1, 0, -1, -1},\n\t\t\t\tmy[] = {1, 1, 0, -1, -1, 0};\n\n\tint t, n;\n\n\twhile(cin >> t >> n,t||n) {\n\t\tvector< vector<bool> > f(SIZE, vector<bool>(SIZE, true));\n\t\tqueue< pair< pair<int, int>, int> > open;\n\n\t\twhile (n--) {\n\t\t\tint x, y;\n\t\t\tcin >>x >>y;\n\n\t\t\tf[y+OFFSET][x+OFFSET] = false;\n\t\t}\n\n\t\tint x, y, cnt = 0;\n\t\tcin >>x >>y;\n\t\tx += OFFSET; y += OFFSET;\n\t\tf[y][x] = false;\n\t\topen.push(mp(mp(x, y), 0) );\n\n\t\twhile(!open.empty()) {\n\t\t\tpair<xy, int> tmp = open.front(); open.pop();\n\t\t\txy tmp2 = tmp.first;\n\t\t\tint x = tmp2.first,\n\t\t\t\ty = tmp2.second,\n\t\t\t\tc = tmp.second;\n\n\t\t\tcnt++;\n\t\t\tif (c >= t) continue;\n\n\t\t\tfor( int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + mx[i],\n\t\t\t\t\tny = y + my[i];\n\n\t\t\t\tif ( !(0 <= nx && 0 <= ny && nx < SIZE && ny < SIZE) ) continue;\n\t\t\t\tif ( f[ny][nx] != true ) continue;\n\n\t\t\t\tf[ny][nx] = false;\n\t\t\t\topen.push( mp(mp(nx,ny), c+1));\n\t\t\t}\n\t\t}\n\t\tcout <<cnt <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*cout <<\"Debug\"\ncout <<x-30<<' '<<y-30<<endl;*/\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[200][200];\nint cnt = 0;\nint d_x[] = {1, 1, 0, -1, -1, 0};\nint d_y[] = {1, 0, -1, -1, 0, 1};\nint t;\n/*\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cout <<\"Debug \";\n  cout <<x-30<<' '<<y-30<<endl;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  int used[6] = {0};\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(watasi < t)&&(mp[nx][ny] == 0)){\n        dfs(nx,ny,watasi);\n        used[dx] = 1;\n    }\n    for(int i = 0;i<6;i++){\n      if(used[i]){\n        if((nx == x + d_x[i])&&(ny == y + d_y[i])){\n          dfs(nx,ny,watasi);\n        }\n      }\n    }\n    }\n}\n*/\nint main(){\n  int n,t;\n\n  cin >>t>>n;\n  while(!((t == 0)&&(n == 0))){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<200;i++){\n      for(int j = 0;j<200;j++){\n        mp[i][j]=-1;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+100][y+100] = 1;\n    }\n    cin >>fx>>fy;\n\n    cnt = 0;\n\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(fx+100,fy+100));\n    mp[fx+100][fy+100] = 0;\n    while (!qu.empty()) {\n      pair<int ,int> pr = qu.front();\n      qu.pop();\n      int nx = pr.first,ny= pr.second;\n      cnt++;\n      if(mp[nx][ny] == t)continue;\n      for(int i = 0;i<6;i++){\n        int cx = nx+d_x[i],cy = ny+d_y[i];\n        if(mp[cx][cy] != -1)continue;\n        mp[cx][cy] = mp[nx][ny] + 1;\n        qu.push(make_pair(cx,cy));\n      }\n    }\n\n    cout <<cnt<<endl;\n    cin >>t>>n;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint dx[6] = {1,1,0,0,-1,-1};\nint dy[6] = {0,1,1,-1,0,-1};\n\nint main(){\n    int t, n;\n    while(cin >> t >> n, t+n){\n        bool visit[121][121] = {};\n        int x, y;\n        for(int i = 0; i < n; i++){\n            cin >> x >> y;\n            visit[x+60][y+60] = true;\n        }\n        cin >> x >> y;\n        queue<pair<pair<int,int>, int>> s;\n        s.push({{x,y},0});\n        int cnt = 0;\n        while(!s.empty()){\n            pair<pair<int,int>,int> p = s.front(); s.pop();\n            if(p.second > t)    break;\n            x = p.first.first, y = p.first.second;\n            if(visit[x+60][y+60]) continue;\n            cnt++;\n            visit[x+60][y+60] = true;\n            for(int k = 0; k < 6; k++){\n                int nx = x + dx[k], ny = y + dy[k];\n                if(!visit[nx+60][ny+60]){\n                    s.push({{nx,ny},p.second+1});\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \nint main()\n{\n  int x,y,t,n,map[200][200],d[200][200],color[200][200],a,b,sum;\n  int H[6][2]={{-1,-1},{0,-1},{-1,0},{1,0},{0,1},{1,1}};\n  queue<pair<int,int> > Q;\n  pair<int,int> u;\n  while(1){\n    cin>>t>>n;\n    if(t==0&&n==0)break;\n    sum=0;\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++){\n\tmap[i][j]=0;\n\td[i][j]=401;\n\tcolor[i][j]=0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      map[100+x][100+y]=1;\n    }\n    cin>>x>>y;\n    x+=100;\n    y+=100;\n    sum++;\n    d[x][y]=0;color[x][y]=1;\n    Q.push(make_pair(x,y));\n    while(!Q.empty()){\n      u=Q.front();Q.pop();\n      a=u.first;b=u.second;\n      for(int i=0;i<6;i++){\n\tif(map[a+H[i][0]][b+H[i][1]]==0 && color[a+H[i][0]][b+H[i][1]]==0){\n\t  d[a+H[i][0]][b+H[i][1]]=d[a][b]+1;\n\t  color[a+H[i][0]][b+H[i][1]]=1;\n\t  if(d[a+H[i][0]][b+H[i][1]]<=t){\n\t    sum++;\n\t    Q.push(make_pair(a+H[i][0],b+H[i][1]));\n\t  }\n\t}\n\tcolor[a][b]=2;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 50\n#define NN 2*N\n#define UNKNOWN 10000\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN; // 何ステップで行けるのかわからない\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[x][y] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;    q.push( S(x,y,0) );\n    d[x][y] = 0;\n\n    int dx[6] = {1,1,0,-1,-1,0};\n    int dy[6] = {1,0,-1,-1,0,1};\n\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n\n      int nt = s.t+1;\n      if( nt>t ) continue;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( nx<0 || nx>=NN ) continue;\n\tif( ny<0 || ny>=NN ) continue;\n\tif( nt>=d[nx][ny] ) continue;\n\tif( d[nx][ny]==UNKNOWN ) ans++;\n\td[nx][ny]=nt;\n\tq.push( S(nx,ny,nt) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint b[70][70], d[70][70], t, n, sx, sy, dx[] = {-1, -1, 0, 0, 1, 1}, dy[] = {0, -1, 1, -1, 0, 1};\n\nsigned main(void) {\n  while (true) {\n    cin >> t >> n;\n    if(!t && !n) break;\n    REP(i, 70) REP(j, 70) {\n      b[i][j] = 0;\n      d[i][j] = INF;\n    }\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      b[y + 30][x + 30] = -1;\n    }\n    cin >> sx >> sy;\n\n    queue<VI> que;\n    que.push({sx, sy, 0});\n    d[sy + 30][sx + 30] = 0;\n\n    while (que.size()) {\n      VI p = que.front();\n      que.pop();\n      if (p[2] == t)\n        continue;\n      REP(i, 6) {\n        int nx = p[0] + dx[i], ny = p[1] + dy[i];\n        if (abs(nx) <= 30 && abs(ny) <= 30 && !b[ny + 30][nx + 30] &&\n            d[ny + 30][nx + 30] == INF) {\n          que.push({nx, ny, p[2] + 1});\n          d[ny + 30][nx + 30] = d[p[1] + 30][p[0] + 30] + 1;\n        }\n      }\n    }\n\n    int ret = 0;\n    REP(i, 65) REP(j, 65) {\n      if (d[i][j] <= t)\n        ret++;\n    }\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1, 1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nint board[310][310], check[310][310];\nint solve_testcase() {\n    int T, N; scanf(\"%d%d\", &T, &N);\n    if(T == 0 and N == 0) return 1;\n\n    const int ofs = 70;\n    const int MAXS = 305;\n    fill(board[0], board[MAXS], 0);\n    fill(check[0], check[MAXS], INF);\n    for(int i=0; i<N; i++) {\n        int x, y; scanf(\"%d%d\", &y, &x);\n        x += ofs, y += ofs;\n        board[x][y] = 1;\n    }\n\n    int sx, sy; scanf(\"%d%d\", &sy, &sx);\n    sx += ofs, sy += ofs;\n    int ans = 0;\n    check[sx][sy] = 0;\n\n    queue< tuple<int, int, int> > que;\n    que.emplace(sx, sy, 0);\n    while(que.size()) {\n        int x, y, c; tie(x, y, c) = que.front();\n        que.pop();\n        ans++;\n        if(c > check[x][y] or c == T) continue;\n        for(int k=0; k<6; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(board[nx][ny] == 0 and check[nx][ny] > c + 1) {\n                check[nx][ny] = c + 1;\n                que.emplace(nx, ny, c + 1);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\n\nint solve(set<int> field,map<int,int> &visited,int turn,int x,int y){\n\tif(field.find(100*x+y) != field.end()) return 0;\n\tfield.insert(100*x+y);\n\tint sum = 1;\n\tif(visited.find(100*x+y) != visited.end()){\n\t\tif(visited[100*x+y] < turn) sum = 0;\n\t\telse return 0;\n\t}\n\tvisited.insert(map<int,int>::value_type(100*x+y,turn));\n\tfor(int i=-1;i<=1&&turn;++i){\n\t\tfor(int j=-1;j<=1;++j){\n\t\t\tif(i+j==0) continue;\n\t\t\tsum += solve(field, visited, turn-1, x+i, y+j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,!(t==0&&n==0)){\n\t\tset<int> field;\n\t\tmap<int,int> visited;\n\t\tfor(int i=0,x,y;i<n;++i){\n\t\t\tcin>>x>>y;\n\t\t\tfield.insert(100*x+y);\n\t\t}\n\t\tint st_x,st_y;\n\t\tcin>>st_x>>st_y;\n\t\tcout<<solve(field,visited,t,st_x,st_y)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint ans;\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tint cnt = f[p] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << f[p_] << endl;\n\t\tif( cnt > t )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p_(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p_] == -2 ) continue;\n\t\t\t\n\t\t\tif( f[p_] == -1 ){\n\t\t\t\tans++;\n\t\t\t\tf[p_] = cnt;\n\t\t\t\tque.push( p_ );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\t\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -2;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 0;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tans = 1;\n\t\tsolve( t , f , que );\n\t\t\n\t\t/*for(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] > 0 ) ans++;\n\t\t\t}\n\t\t}*/\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int x;\n    int y;\n    int cnt;\n    P(int x, int y, int cnt){\n        this->x = x;\n        this->y = y;\n        this->cnt = cnt;\n    }\n};\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y, cnt = 0;\n        cin >> x >> y;\n        x += 50; y += 50;\n\n        int ans = 0;\n        queue< P > que;\n        que.push( P(x, y, 0) );\n\n        while(!que.empty()){\n            P q = que.front(); que.pop();\n            x = q.x; y = q.y; cnt = q.cnt;\n            if(cnt > t) break;\n            ans++;\n\n            used[y][x] = true;\n            for(int d = 0; d < 6; d++){\n                int nx = x + dx[d], ny = y + dy[d];\n                if(used[ny][nx] == true || g[ny][nx] == 1) continue;\n                used[ny][nx] = true;\n                que.push(P(nx, ny, cnt+1));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\nint dfs(int x, int y, int turn){\n    if(used[y][x] || g[y][x] == 1 || turn > t ) return 0;\n    used[y][x] = true;\n\n    int res = 0;\n    for(int d = 0; d < 6; d++){\n        int nx = x + dx[d], ny = y + dy[d];\n        res += dfs(nx, ny, turn+1);\n    }\n    used[y][x] = false;\n    return res + 1;\n}\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y;\n        cin >> x >> y;\n        x += 50; y += 50;\n        cout << dfs(x, y, 0) << endl;\n    }\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 100\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+40][y+40] = 1;\n\t\t}*/\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+40,sY+40)); \n\t\td[sX+40][sY+40] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int> P;\ntypedef tuple<int,int,int> Tr;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1};\n\nconst int NMAX = 100;\nint field[NMAX][NMAX];\n#define MAP(x, y) field[x + 50][y + 50]\n\nint main() {\n  cout << fixed << setprecision(10);\n  int T, N;\n  while (cin >> T >> N and T) {\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      MAP(x, y) = INF;\n    }\n    REP(i, N) {\n      int x, y;\n      cin >> x >> y;\n      MAP(x, y) = -1;\n    }\n\n    int sx,sy;\n    cin >> sx >> sy;\n    priority_queue<Tr,vector<Tr>,greater<Tr>> que;\n    que.push(Tr(1,sx,sy));\n\n    while (!que.empty()) {\n      int turn, x, y;\n      tie(turn, x, y) = que.top(); que.pop();\n      if (turn >= MAP(x, y)) continue;\n      MAP(x, y) = turn;\n      if (turn > T) continue;\n      REP(j, 6) {\n        que.push(Tr(turn + 1, x + dx[j], y + dy[j]));\n      }\n    }\n\n    int sum = 0;\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      if (MAP(x, y) > 0 and MAP(x, y) < 40) sum++;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\n\nint board[64][64];\nint geta = 32;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  while (1) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    memset(board, 0, sizeof(board));\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      board[y+geta][x+geta] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    queue<T> que;\n    que.push(T(sx, sy, t));\n\n    while (!que.empty()) {\n      int x, y, rest;\n      tie(x, y, rest) = que.front();\n      que.pop();\n\n      if (rest < 0 || board[y+geta][x+geta] != 0) continue;\n\n      board[y+geta][x+geta] = 1;\n      REP(i, 6) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\t  que.push(T(nx, ny, rest - 1));\n      }\n    }      \n      \n    int ans = 0;\n    for (int y = -30; y <= 30; y++) {\n      for (int x = -30; x <= 30; x++) {\n\tans += board[y+geta][x+geta] > 0;\n      }\n    }\n    cout << ans << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define mp       make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int dx[]={1,1,0,-1,-1,0},dy[]={0,1,1,0,-1,-1};\n\nint main(){\n\tfor(int t,n;scanf(\"%d%d\",&t,&n),t;){\n\t\tstatic bool visited[130][130];\n\t\tmemset(visited,0,sizeof visited);\n\t\trep(i,n){\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\tx+=60, y+=60;\n\t\t\tvisited[y][x]=true;\n\t\t}\n\t\tint x0,y0; scanf(\"%d%d\",&x0,&y0);\n\t\tx0+=60, y0+=60;\n\t\tvisited[y0][x0]=true;\n\n\t\tqueue< pair<int,pii> > qu; qu.push(mp(0,mp(y0,x0)));\n\t\twhile(!qu.empty()){\n\t\t\tpair<int,pii> a=qu.front(); qu.pop();\n\t\t\tint turn=a.first,x=a.second.second,y=a.second.first;\n\t\t\tif(turn>=t) continue;\n\n\t\t\trep(i,6){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(!visited[yy][xx]){\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t\tqu.push(mp(turn+1,mp(yy,xx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=-n;\n\t\trep(i,130) rep(j,130) if(visited[i][j]) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 62;\n\nclass S{\npublic:\n  int y, x, c;\n  S() : y(0), x(0), c(0) {}\n  S(int y, int x, int c) : y(y), x(x), c(c) {}\n};\n\nint t, n, sy, sx;\nbool mapData[N][N];\nbool visited[N][N];\nint dy[] = {1, 0, -1, -1, 0, 1};\nint dx[] = {1, 1, 0, -1, -1, 0};\n\nvoid bfs(){\n  fill(visited[0], visited[N], false);\n  S u;\n  queue<S> q;\n  q.push(S(sy, sx, 0));\n  visited[sy][sx] = true;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(!mapData[ny][nx]) continue;\n      //if(visited[ny][nx]) continue;\n      visited[ny][nx] = true;\n      if(u.c+1 < t) q.push(S(ny, nx, u.c+1));\n    }\n  }\n}\n\n\nmain(){\n  while(cin >> t >> n && (t|n)){\n    fill(mapData[0], mapData[N], true);\n    for(int i=0;i<n;i++){\n      int y, x;\n      cin >> x >> y; \n      mapData[y+N/2][x+N/2] = false;\n    }\n    cin >> sx >> sy;\n    sx += N/2;\n    sy += N/2;\n    bfs();\n    int ans = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(visited[i][j]) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nchar field[100][100];\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tqueue< pair<int,int> > point;\n\t\tpoint.push(make_pair(s_x+50,s_y+50));\n\t\tint sum = 0;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tint p_x = point.front().first, p_y = point.front().second;\n\t\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] != -1){point.push(make_pair(p_x-1,p_y));}}\n\t\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] != -1){point.push(make_pair(p_x,p_y-1));}}\n\t\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] != -1){point.push(make_pair(p_x+1,p_y));}}\n\t\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] != -1){point.push(make_pair(p_x,p_y+1));}}\n\t\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] != -1){point.push(make_pair(p_x-1,p_y-1));}}\n\t\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] != -1){point.push(make_pair(p_x+1,p_y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n\nint data[200][200]={};\nint t,n;\n\n\nint main(){\n    while(cin>>t>>n){\n        if(t==0 && n==0)break;\n        \n        rep(i,100)rep(j,100)data[i][j]=100;\n        \n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            x+=50;y+=50;\n            data[y][x]=-1;\n        }\n        int a,b;\n        cin>>a>>b;\n        a+=50;b+=50;\n        data[b][a]=0;\n        \n        int dx[]={0,1,1,0,-1,-1};\n        int dy[]={1,1,0,-1,-1,0};\n        \n        for(int time=1;time<=t;time++){\n            rep(i,100){\n                rep(j,100){\n                    if(data[i][j]==time-1){\n                        rep(k,6){\n                            if(data[i+dy[k]][j+dx[k]]!=-1) data[i+dy[k]][j+dx[k]]=min(data[i+dy[k]][j+dx[k]],time);\n                        }\n                    }\n                    \n                }\n            }\n        }\n        int c=0;\n        rep(i,100){\n            rep(j,100){\n                if(data[i][j]!=-1 && data[i][j]!=100)c++;\n            }\n        }\n        \n        cout<<c<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[61][61];\nint cnt = 0;\nint d_x[] = {0,1,0,-1,1,-1};\nint d_y[] = {1,0,-1,0,1,-1};\nint t;\n\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(mp[nx][ny] == 0)&&(watasi < t)){\n      dfs(nx,ny,watasi);\n    }\n}\n}\nint main(){\n  int n;\n\n  cin >>t>>n;\n  while((t != 0)&&(n != 0)){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<61;i++){\n      for(int j = 0;j<61;j++){\n        mp[i][j]=0;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+30][y+30] = 1;\n    }\n    cin >>fx>>fy;\n\n    dfs(fx+30,fy+30,-1);\n\n    ansl.push_back(cnt);\n    cin >>t>>n;\n  }\n\n  for(int i = 0;i<(int)ansl.size();i++){\n    cout <<ansl[i]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define MAX 61\n#define INF 128\n\nint main()\n{\n\tconst int dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\twhile(1) {\n\t\tbool is_wall[MAX][MAX] = {false};\n\t\tint d[MAX][MAX] = {0};\n\t\tqueue<P> que;\n\t\tint t, n;\n\t\tint px, py;\n\t\tint ans = 0;\n\t\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &t, &n);\n\t\tif(!t && !n) break;\n\t\twhile(n--) {\n\t\t\tint wx, wy;\n\t\t\tscanf(\"%d %d\", &wx, &wy);\n\t\t\tis_wall[wx+30][wy+30] = true;\n\t\t}\n\t\tscanf(\"%d %d\", &px, &py);\n\t\tque.push(P(px, py));\n\t\td[px+30][py+30] = 0;\n\t\twhile(!que.empty()) {\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(d[x+30][y+30] == t) continue;\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif(-30 <= xx && xx <= 30 && -30 <= yy && yy <= 30 && !is_wall[xx+30][yy+30] ) {\n\t\t\t\t\tif(d[xx+30][yy+30] > d[x+30][y+30] + 1) {\n\t\t\t\t\t\td[xx+30][yy+30] = d[x+30][y+30] + 1;\n\t\t\t\t\t\tque.push(P(xx, yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(d[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace\tstd;\nint flag[70][70],a[70][70],t,r;\n\nvoid bfs(int x,int y, int how){\n  if(how>t) return;\n  if(x<0||x>60 || y<0||y>60) return;\n  //  if(flag[y][x]) return;                                                                                                                                                                   \n  if(a[y][x]) return;\n  if(!flag[y][x]) r++;\n  flag[y][x]=1;\n  bfs(x+1,y+1,how+1);\n  bfs(x-1,y-1,how+1);\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++)\n      if(!(i*j)&&i+j) bfs(x+i,y+j,how+1);\n}\n\nint main(){\n  for(;;){\n  int q;\n  cin>>t>>q;\n  if(t==0&&q==0) break;\n  for(int i=0;i<70;i++) for(int j=0;j<70;j++) flag[i][j]=a[i][j]=0;\n  r=0;\n  for(int i=0,t1,t2;i<q;i++){\n    cin>>t1>>t2;\n    a[t2+30][t1+30]=1;\n  }\n  int y0,x0;\n  cin>>x0>>y0;\n  x0+=30;\n  y0+=30;\n  bfs(x0,y0,0);\n  /* for(int i=0;i<61;i++){                                                                                                                                                                    \n    for(int j=0;j<61;j++) cout<<(flag[j][i]?\"1\":\" \")<<\" \";                                                                                                                                     \n    cout<<endl;                                                                                                                                                                                \n    } */\n  cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n}\n\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\nint main(){\n    int n,t;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        queue<tuple<int,int,int>> q;\n        q.push(make_tuple(x+30,y+30,0));\n        while(!q.empty()){\n            auto now=q.front();\n            q.pop();\n            int x=get<0>(now);\n            int y=get<1>(now);\n            int turn=get<2>(now);\n            iscan[x][y]=1;\n            if(turn>=t)\n                continue;\n            REP(i,6){\n             int nx=x+dx[i];\n             int ny=y+dy[i];\n             if(isRange(nx,ny) && !ob[nx][ny]&&!iscan[nx][ny])\n                q.push(make_tuple(nx,ny,turn+1));\n            }\n        }\n      int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\n\n\n                   "
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+70·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_COOR 150\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 70][obsy + 70] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 70;\n\t\tstarty += 70;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<\"ans = \" <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÌ½ßÌì)\n\t\t\t\tif(endcnt[nowx][nowy] == false){\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint data[100][100]={0};\n\nbool inrange(int x,int y){\n  if(x<-30||x>30||y<-30||y>30) return false;\n  else return true;\n}\nqueue<pair<int,pair<int,int> > > q;\nint turn;\n\nint search(){\n  int res = 0;\n  while(!q.empty()){\n    int tmpturn = q.front().first;\n    pair<int,int> tmpq = q.front().second;\n    int px = tmpq.first;\n    int py = tmpq.second;\n    q.pop();\n    if(tmpturn>0){\n      REP(i,6){\n        int nx = px+dx[i];\n        int ny = py+dy[i];\n        if(inrange(nx,ny)&&(data[nx+30][ny+30]==0)){\n          res++;\n          data[nx+30][ny+30] = 1;\n          q.push(make_pair(tmpturn-1,make_pair(nx,ny)));\n        }\n      }\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  while(1){\n    cin >> turn >> n;\n    if(turn==0&&n==0) break;\n    REP(i,100) REP(j,100) data[i][j] = 0;\n    REP(i,n){\n      int tx,ty;\n      cin >> tx >> ty;\n      data[tx+30][ty+30] = -1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    data[sx+30][sy+30] = 1;\n    q.push(make_pair(turn,make_pair(sx,sy)));\n    cout << search()+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": " \n#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (n) ;i++)\n  \nint vec1[] = {0,1,-1,1,-1,0};\nint vec2[] = {1,1,0,0,-1,-1};\n  \nint t,n;\nint table[200][200];\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n  \nint ans;\n  \nint solve(int y,int x){\n    queue <piii> q1;\n    q1.push(make_pair(0,make_pair(y,x)));\n    while(!q1.empty()){\n        if(t <= q1.front().first)\n            return 0;\n        REP(i,6){\n            int n_y = q1.front().second.first + vec1[i];\n            int n_x = q1.front().second.second + vec2[i];\n            if(table[n_y][n_x] == 0){\n                ans++;\n                table[n_y][n_x] = 1;\n                q1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n            }\n        }\n        q1.pop();\n    }\n    return 0;\n}\n  \nint main(){\n    while(cin >> t  >> n , t+n){\n        ans = 0;\n        fill_n(table[0],200*200,0);\n        REP(i,n){\n            int x,y;\n            cin >> x >> y;\n            table[100 + y][100 + x] = 1;\n        }\n        int x,y;\n        cin >> x >> y;\n        table[100+y][100+x] = 1;\n        solve(100+y,100+x);\n        cout << ans + 1<< endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    //print1 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) cout << \"X \";\n        else cout << memo[i][j] << \" \";\n      }\n      cout << el;\n    }\n    */\n    //print1 end\n\n    // print2 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          if (map[30-i+j][60-i]) cout << \"* \";\n          else if (memo[30-i+j][60-i] == INF) cout << \"X \";\n          else cout << memo[30-i+j][60-i] << \" \";\n        }\n        if (map[60][60-i]) cout << \"*\";\n        else if (memo[60][60-i] == INF) cout << \"X\";\n        else cout << memo[60][60-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (map[j][30]) cout << \"* \";\n          else if (memo[j][30] == INF) cout << \"X \";\n          else cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          if (map[j][60-i]) cout << \"* \";\n          else if (memo[j][60-i] == INF) cout << \"X \";\n          else cout << memo[j][60-i] << \" \";\n        }\n        if (map[90-i][60-i]) cout << \"*\";\n        else if (memo[90-i][60-i] == INF) cout << \"X\";\n        else cout << memo[90-i][60-i];\n      }\n      cout << el;\n    }\n    */\n    // prin2 end\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 31 + i; j++) {\n          if (memo[30-i+j][60-i] < INF) res++;\n        }\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (memo[j][30] < INF) res++;\n        }\n      } else {\n        for (int j = 0; j < 91 - i; j++) {\n          if (memo[j][60-i] < INF) res++;\n        }\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 0;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tint field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tsum++;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>19){if(!field[x-1][y]){field[x-1][y] = 1;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>19){if(!field[x][y-1]){field[x][y-1] = 1;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<79){if(!field[x+1][y]){field[x+1][y] = 1;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<79){if(!field[x][y+1]){field[x][y+1] = 1;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>19 && y>19){if(!field[x-1][y-1]){field[x-1][y-1] = 1;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<79 && y<79){if(!field[x+1][y+1]){field[x+1][y+1] = 1;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_T=130;\nconst int dx[6]={0,1,1,-1,-1,0};\nconst int dy[6]={1,1,0,0,-1,-1};\n\nint t,n,x,y,ans;\nint d[MAX_T][MAX_T];\nqueue<pair<int,int>> que;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> t >> n,t){\n        for (int i=0;i<MAX_T;++i)\n            for (int j=0;j<MAX_T;++j)\n                d[i][j]=-1;\n        for (int i=0;i<n;++i){\n            cin >> x >> y;\n            d[x+MAX_T/2][y+MAX_T/2]=-2;\n        }\n        cin >> x >> y;\n        d[x+MAX_T/2][y+MAX_T/2]=0;\n        que.emplace(x+MAX_T/2,y+MAX_T/2);\n        while(!que.empty()){\n            auto p=que.front(); que.pop();\n            x=p.first,y=p.second;\n            for (int i=0;i<6;++i){\n                int nx=x+dx[i],ny=y+dy[i];\n                if (nx<0||MAX_T<=nx||ny<0||MAX_T<=ny) continue;\n                if (d[nx][ny]!=-1) continue;\n                d[nx][ny]=d[x][y]+1;\n                que.emplace(nx,ny);\n            }\n        }\n        ans=0;\n        for (int i=0;i<MAX_T;++i)\n            for (int j=0;j<MAX_T;++j)\n                ans+=(0<=d[i][j]&&d[i][j]<=t);\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\nint mp[610][610];\nvoid dfs(int x, int y, int n) {\n  if (n == 0 || mp[y][x] == 9)\n    return;\n  mp[y][x] = 7;\n  dfs(x + 1, y, n - 1);\n  dfs(x, y + 1, n - 1);\n  dfs(x - 1, y, n - 1);\n  dfs(x, y - 1, n - 1);\n  dfs(x + 1, y + 1, n - 1);\n  dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n, t;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    memset(mp, 0, sizeof(mp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing p = pair<int, int>;\n\nint n, t;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\nmap<p, bool> mp;\np st;\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> t >> n;\n    if(t + n == 0) break;\n    for(int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      mp[{x + 60, y + 60}] = 1;\n    }\n    cin >> st.fi >> st.se;\n    st.fi += 60;\n    st.se += 60;\n    cout << solve() << endl;\n    mp.erase(mp.begin(), mp.end());\n  }\n  return 0;\n}\n\nint solve() {\n  vector<vector<int>> v;\n  int ans = 0;\n  queue<p> qu;\n  v.resize(121);\n  for(int i = 0; i < 121; ++i) v[i].assign(121, -1);\n  v[st.fi][st.se] = 0;\n  qu.push(st);\n  while(qu.size() > 0) {\n    p now = qu.front();\n    qu.pop();\n    int nowt = v[now.fi][now.se];\n    if(nowt >= t) continue;\n    for(int i = 0; i < 6; ++i) {\n      p nextp = now;\n      nextp.fi += dx[i];\n      nextp.se += dy[i];\n      if(mp.find(nextp) != mp.end() ||\n         v[nextp.fi][nextp.se] >= 0)\n        continue;\n      v[nextp.fi][nextp.se] = nowt + 1;\n      qu.push(nextp);\n    }\n  }\n  for(int i = 0; i < 121; ++i)\n    for(int j = 0; j < 121; ++j)\n      if(v[i][j] >= 0 && v[i][j] <= t) ++ans;\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nint dx[6] = {-1, -1, 0, 1, 1, 0};\nint dy[6] = {0, -1, -1, 0, 1, 1};\nbool issearched[70][70];\n\nint t, n;\nint islandmap[70][70];\nint tesu[70][70];\n\nvoid search(int a, int b);\n\nint main()\n{\n    while(1){\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 70; i++){\n            for(int j = 0; j < 70; j++){\n                islandmap[i][j] = 0;\n                issearched[i][j] = false;\n                tesu[i][j] = 0;\n            }\n        }\n        int obstacle_x, obstacle_y;\n        for(int i = 0; i < n; i++){\n            cin >> obstacle_x >> obstacle_y;\n            islandmap[obstacle_x + 35][obstacle_y + 35] = -1;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        issearched[start_x + 35][start_y + 35] = true;\n        search(start_x + 35, start_y + 35);\n        int ans = 1;\n        for(int i = 0; i < 70; i++){\n            for(int j = 0; j < 70; j++){\n                if(tesu[i][j] < t + 1 && tesu[i][j] > 0) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nvoid search(int a, int b)\n{\n    int x, y, nx, ny;\n    queue<pair < int, int> > qu;\n    qu.push(make_pair<int, int>(a, b));\n    while(!qu.empty()){\n        x = (qu.front()).first;\n        y = (qu.front()).second;\n        for(int i = 0; i < 6; i++){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if(nx < 0|| ny < 0|| nx > 69|| ny > 69) continue;\n            if(islandmap[nx][ny] != -1 && issearched[nx][ny] == false){\n                tesu[nx][ny] = tesu[x][y] + 1;\n                qu.push(make_pair<int, int>(nx, ny));\n                issearched[nx][ny] = true;\n            }\n        }\n        qu.pop();\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n   \nusing namespace std;\n    \n#define NMAX 50\n#define INF 1000000\n#define WALL -1\ntypedef map<int,int>::value_type VT;\n   \nstruct data{\n    int x,y,turn;\n};\n   \nint main(void){\n       \n    int t,n;\n    int x,y;\n    map<int,int> road;\n    stack<data> no;\n    data tm,da;\n    int dx[]={1,1,0,-1,-1,0};\n    int dy[]={0,1,1,0,-1,-1};\n    int cnt;\n   \n    for(int i=-71;i<=71;i++){\n        for(int j=-71;j<=71;j++){\n        road.insert(VT(i+j*1000,INF));\n        }\n    }\n    while(1){\n        cin>>t>>n;\n        if(t==0&&n==0) break;\n        for(int i=-71;i<=71;i++){\n            for(int j=-71;j<=71;j++){\n                road[i+j*1000]=INF;\n            }\n        }\n   \n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            road[y+x*1000]=WALL;\n        }\n        cin>>x>>y;\n        tm.x=x,tm.y=y,tm.turn=0;\n        no.push(tm);\n        road[y+x*1000]=0;\n        cnt=1;\n        while(!no.empty()){\n            tm=no.top();\n            no.pop();\n            if(tm.turn==t) continue;\n            for(int i=0;i<6;i++){\n                if(road[(tm.y+dy[i])+(tm.x+dx[i])*1000]>road[(tm.y)+(tm.x)*1000]+1){\n                    if(road[(tm.y+dy[i])+(tm.x+dx[i])*1000]==INF) cnt++;\n                    road[(tm.y+dy[i])+(tm.x+dx[i])*1000]=road[(tm.y)+(tm.x)*1000]+1;\n                    da.x=tm.x+dx[i];\n                    da.y=tm.y+dy[i];\n                    da.turn=tm.turn+1;\n                    no.push(da);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto ele=q.front();\n            auto p=ele.first;\n            int turn=ele.second;\n            if(turn==t)\n                continue;\n            if(turn>t)\n                for(;;){}\n\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef std::array<bool, 63> Line;\ntypedef std::array<Line, 63> Table;\n\nTable table; // [X][Y]\nstd::array< std::array<int, 63>, 63> standed; // [X][Y]\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + 32;\n}\n\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"sample.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tfor_each(table.begin(), table.end(), [](Line & line) {\n\t\t\tline.fill(false);\n\t\t});\n\t\tfor_each(standed.begin(), standed.end(), [](std::array<int, 63> & line) {\n\t\t\tline.fill(-1);\n\t\t});\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    //print1 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) cout << \"X \";\n        else cout << memo[i][j] << \" \";\n      }\n      cout << el;\n    }\n    */\n    //print1 end\n\n    // print2 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          if (map[30-i+j][60-i]) cout << \"* \";\n          else if (memo[30-i+j][60-i] == INF) cout << \"X \";\n          else cout << memo[30-i+j][60-i] << \" \";\n        }\n        if (map[60][60-i]) cout << \"*\";\n        else if (memo[60][60-i] == INF) cout << \"X\";\n        else cout << memo[60][60-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (map[j][30]) cout << \"* \";\n          else if (memo[j][30] == INF) cout << \"X \";\n          else cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          if (map[j][60-i]) cout << \"* \";\n          else if (memo[j][60-i] == INF) cout << \"X \";\n          else cout << memo[j][60-i] << \" \";\n        }\n        if (map[90-i][60-i]) cout << \"*\";\n        else if (memo[90-i][60-i] == INF) cout << \"X\";\n        else cout << memo[90-i][60-i];\n      }\n      cout << el;\n    }\n    */\n    // prin2 end\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j <= 30 + i; j++) {\n          if (memo[30-i+j][60-i] < INF) res++;\n        }\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (memo[j][30] < INF) res++;\n        }\n      } else {\n        for (int j = 0; j <= 90 - i; j++) {\n          if (memo[j][60-i] < INF) res++;\n        }\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[62][62];\nbool flag[62][62];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\tmp[tx+30][ty+30]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint sum=1;\n\t\tflag[sx+30][sy+30]=true;\n\t\tqueue<pair<int,PII> >q;\n\t\tq.push(MP(t,MP(sx+30,sy+30)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tif(pi.first==0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(pi.first-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint t, n, sx, sy;\nint field[100][100];\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid solve(){\n\tfield[sy][sx] = 0;\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\tif (field[p.first][p.second] == t || field[p.first][p.second] == -1){\n\t\t\tcontinue;\n\t\t}\n\n\t\tREP(i, 6){\n\t\t\tint ny = p.first + dy[i], nx = p.second + dx[i];\n\t\t\tif (ny >= 20 && ny <= 80 && nx >= 20 && nx <= 80){\n\t\t\t\tif (field[ny][nx] == INF){\n\t\t\t\t\tfield[ny][nx] = field[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\twhile (cin >> t >> n&&t + n){\n\t\tint ans = 0;\n\t\tREP(i, 100)REP(j, 100)field[i][j] = INF;\n\t\tREP(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 50;\n\t\t\ty += 50;\n\t\t\tfield[y][x] = -1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\t\tsolve();\n\t\tREP(i, 100){\n\t\t\tREP(j, 100){\n\t\t\t\tif (field[i][j] >= 0 && field[i][j] <= t){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define TEST 0\n#if TEST\nFILE *in = freopen(\"./q.txt\", \"r\", stdin);\nFILE *out = freopen(\"./a.txt\", \"w\", stdout);\n#endif\n\nint dx[6] = { 0, 1, 1, 0,-1,-1};\nint dy[6] = { 1, 1, 0,-1,-1, 0};\n\ninline void pusuQueue(queue<int>& q, int x, int y, int t){\n\tq.push(x), q.push(y), q.push(t);\n}\ninline void popQueue(queue<int>& q, int& x, int& y, int& t){\n\tx = q.front(); q.pop();\n\ty = q.front(); q.pop();\n\tt = q.front(); q.pop();\n}\n\nint main(){\n\twhile (1){\n\t\tint t, n; cin >> t >> n;\n\t\tif (!t && !n) break;\n\n\t\tmap<pair<int, int>, bool> isBar;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tisBar[make_pair(x, y)] = true;\n\t\t}\n\t\t\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tisBar[make_pair(sx, sy)] = true;\n\n\t\tint cnt = 0;\n\t\tqueue<int> q;\n\t\tpusuQueue(q, sx, sy, 0);\n\t\twhile (!q.empty()){\n\t\t\tint x, y, turn; popQueue(q, x, y, turn);\n\t\t\tcnt++;\n\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (turn < t && !isBar[make_pair(nx, ny)]){\n\t\t\t\t\tpusuQueue(q, nx, ny, turn+1);\n\t\t\t\t\tisBar[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\n\t}\n\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[1000][1000];\nbool flag[1000][1000];\n\nstruct pr{\n\tint nx,ny,cnt;\n};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=300;ty+=300;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=300;sy+=300;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pr>q;\n\t\tpr p;\n\t\tp.nx=sx;p.ny=sy;p.cnt=0;\n\t\tq.push(p);\n\t\twhile(!q.empty()){\n\t\t\tpr pi=q.front();q.pop();\n\t\t\tint x=pi.nx;\n\t\t\tint y=pi.ny;\n\t\t\tint tt=pi.cnt;\n\t\t\tif(tt>=t)continue;\n\t\t\tREP(j,6)if(!flag[x+dx[j]][y+dy[j]]&&!mp[x+dx[j]][y+dy[j]]){\n\t\t\t\tflag[x+dx[j]][y+dy[j]]=true;\n\t\t\t\tsum++;\n\t\t\t\tpr p2;p2.nx=x+dx[j];p2.ny=y+dy[j];p2.cnt=tt+1;\n\t\t\t\tq.push(p2);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    deque<P> que;\n    que.clear();\n    que.push_back(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > t) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop_front();\n            REP(i, 6){\n                if(cur.first + dy[i] >= 0 && cur.first + dy[i] <= 64 && cur.second + dx[i] >= 0 && cur.second + dx[i] <= 64){\n                    if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                        que.push_back(P(cur.first + dy[i], cur.second + dx[i]));\n                        close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                        graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                    }\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 65) REP(j, 65) if(graph[i][j] != INF){\n        //cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 65){\n            REP(j, 65){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nbool field[100][100];\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = 1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tqueue< pair<int,int> > point;\n\t\tpoint.push(make_pair(s_x+50,s_y+50));\n\t\tint sum = 0;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tint p_x = point.front().first, p_y = point.front().second;\n\t\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] == 0){point.push(make_pair(p_x-1,p_y));}}\n\t\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] == 0){point.push(make_pair(p_x,p_y-1));}}\n\t\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] == 0){point.push(make_pair(p_x+1,p_y));}}\n\t\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] == 0){point.push(make_pair(p_x,p_y+1));}}\n\t\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] == 0){point.push(make_pair(p_x-1,p_y-1));}}\n\t\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] == 0){point.push(make_pair(p_x+1,p_y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nbool f[200][200];\nint tbl[200][200];\n\nint dx[] = {-1,-1,0,0,1,1};\nint dy[] = {-1,0,-1,1,0,1};\nint main(){\n  int t,n;\n  while(cin>>t>>n,t||n){\n    memset(f,0,sizeof(f));\n    memset(tbl,0,sizeof(tbl));\n    queue<P> Q;\n    for(int i=0;i<n;++i){\n      int x,y;\n      cin>>x>>y;\n      x+=100;y+=100;\n      f[x][y]=true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    sx+=100;sy+=100;\n    Q.push(P(sx,sy));\n    int cnt = 1;\n    f[sx][sy] = true;\n    while(!Q.empty()){\n      P p = Q.front(); Q.pop();\n      if(tbl[p.first][p.second]>=t) continue;\n      for(int i=0;i<6;++i){\n\tint mx = p.first + dx[i];\n\tint my = p.second + dy[i];\n\tif(!f[mx][my] && !tbl[mx][my]){\n\t  ++cnt;\n\t  Q.push(P(mx,my));\n\t  tbl[mx][my] = tbl[p.first][p.second]+1;\n\t}\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 35\n#define NN 2*N\n#define UNKNOWN 10000\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,1,0,-1,-1,0};\n  int dy[6] = {1,0,-1,-1,0,1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN; // 何ステップで行けるのかわからない\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[y][x] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;    q.push( S(x,y,0) );\n    d[y][x] = 0;\n\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      int nt = s.t+1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( nx<0 || nx>=NN ) continue;\n\tif( ny<0 || ny>=NN ) continue;\n\tif( d[ny][nx]==UNKNOWN ){\n\t  if( nt<t )\n\t    q.push( S(nx,ny,nt) );\n\t  d[ny][nx]=nt; ans++;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = { 1,1,0,-1,-1,0 };\nconst int dy[] = { 0,1,1,0,-1,-1 };\nconst int geta = 30;\n\nint main()\n{\n\twhile (true) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\t\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint map[61][61];\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tmap[y + geta][x + geta] = 1;\n\t\t}\n\n\t\tint startx, starty;\n\t\tcin >> startx >> starty;\n\n\t\tint ans = 1;\n\t\tint now = 0;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push({ starty + geta,startx + geta });\n\t\tmap[starty + geta][startx + geta] = 1;\n\n\t\twhile (q.empty() == false && now < t) {\n\t\t\tunsigned int count = q.size();\n\n\t\t\twhile (count > 0) {\n\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tcount--;\n\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint ny = temp.first + dy[i];\n\t\t\t\t\tint nx = temp.second + dx[i];\n\n\t\t\t\t\tif (ny >= 0 && ny < 61 && nx >= 0 && nx < 61 && map[ny][nx] == 0) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tmap[ny][nx] = 1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2253\n\n#include <iostream>\n\nusing namespace std;\n\nint field[128][128];\nint dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, 0, 1};\nint t;\n\nvoid dfs(int y, int x, int depth)\n{\n\tfield[y][x] |= 1;\n\tif (t == depth) return;\n\tfor (int i = 0; i < 6; i++){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (y < 0 || x < 0 || 128 <= y || 128 <= x) continue;\n\t\tif (field[ny][nx] == 2) continue;\n\t\t// cout << \"*\" << endl;\n\t\tdfs(ny, nx, depth + 1);\n\t}\n\treturn;\n}\nint main(void)\n{\n\tint n;\n\twhile (cin >> t >> n){\n\t\tif (t == 0 && n == 0) break;\n\t\tint y, x;\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\ty += 50;\n\t\t\tx += 50;\n\t\t\tfield[y][x] = 2;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\n\t\tdfs(sy, sx, 0);\n\t\t// y, x, depth\n\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (field[i][j] == 1){\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int INF = numeric_limits<int>::max() / 2;\n\nint sx, sy, n, t;\nint field[200][200]; //0:can't 1:can\nint d[200][200];\nint dx[6] = {1, 0, 1, -1, 0, -1}, dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid solve()\n{\n    queue<pii> que;\n    for (int i = 0; i < 200; i++)\n        for (int j = 0; j < 200; j++)\n            d[i][j] = INF;\n    que.push(pii(sx + 100, sy + 100));\n    d[sx + 100][sy + 100] = 0;\n\n    while (que.size())\n    {\n        pii p = que.front();\n        que.pop();\n        for (int i = 0; i < 6; i++)\n        {\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n\n            if (0 <= nx && nx < 200 && 0 <= ny && ny < 200 && field[nx][ny] && d[nx][ny] == INF)\n            {\n                que.push(pii(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true)\n    {\n        cin >> t >> n;\n        if (n == 0 && t == 0)\n            break;\n        for (int i = 0; i < 200; i++)\n            for (int j = 0; j < 200; j++)\n                field[i][j] = 1;\n        for (int i = 0; i < n; i++)\n        {\n            int x, y;\n            cin >> x >> y;\n            field[x + 100][y + 100] = 0;\n        }\n        cin >> sx >> sy;\n        solve();\n        int res = 0;\n        for (int i = 0; i < 200; i++)\n            for (int j = 0; j < 200; j++)\n                if (d[i][j] <= t)\n                    res++;\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int t, n;\n    int dx[] = {1,-1,0,0,1,-1}, dy[] = {0,0,1,-1,1,-1};\n    while (cin >> t >> n && (t != 0 || n != 0)){\n        map<P, int> w;\n        while(n--){\n            int x, y;\n            cin >> x >> y;\n            w[make_pair(x, y)] = 1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        map<P, int> dist; \n        queue<P> que;\n        que.push(make_pair(sx, sy));\n        dist[make_pair(sx, sy)] = 1;\n        int ans = 0;\n        while(!que.empty()){\n            P p = que.front();\n            que.pop();\n            int i = p.first, j = p.second;\n            ans++;\n            if (dist[make_pair(i, j)] == t+1) continue;\n            REP(k,6){\n                int ii = i+dx[k], jj = j+dy[k];\n                if (w[make_pair(ii, jj)] || dist[make_pair(ii, jj)] > 0) continue;\n                dist[make_pair(ii, jj)] = dist[make_pair(i, j)] + 1;\n                que.push(make_pair(ii, jj));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n}\n\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\nint main(){\n    int n,t;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        queue<tuple<int,int,int>> q;\n        q.push(make_tuple(x+30,y+30,0));\n        while(!q.empty()){\n            auto now=q.front();\n            q.pop();\n            int x=get<0>(now);\n            int y=get<1>(now);\n            int turn=get<2>(now);\n            iscan[x][y]=1;\n            if(turn>=t)\n                continue;\n            REP(i,6){\n             int nx=x+dx[i];\n             int ny=y+dy[i];\n             if(isRange(nx,ny)）\n 　　　　　if(!ob[nx][ny]&&!iscan[nx][ny])\n                q.push(make_tuple(nx,ny,turn+1));\n            }\n        }\n      int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\n\n\n                   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nusing P = pair<int, int>;\nconstexpr int INF = 1e9;\n\nint main() {\n    int t, n;\n    while(cin >> t >> n, t || n) {\n        vector<vector<int>> v(121, vector<int>(121, INF));\n        for(int i=0; i<n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            v[x+60][y+60] = INF+1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 60;\n        sy += 60;\n    \n        queue<P> que;\n        que.push(make_pair(sx, sy));\n        v[sx][sy] = 0;\n        int dx[6] = {0, 1, 0, -1, 1, -1}, dy[6] = {1, 0, -1, 0, 1, -1};\n        while(!que.empty()) {\n            P p = que.front();\n            que.pop();\n            for(int i=0; i<6; ++i) {\n                int nx = p.first + dx[i],\n                    ny = p.second + dy[i];\n                if(0 <= nx && nx < 121 && 0 <= ny && ny < 121 && v[nx][ny] == INF) {\n                    que.push(make_pair(nx, ny));\n                    v[nx][ny] = v[p.first][p.second] + 1;\n                }\n            }\n        }\n        int ret = 0;\n        for(int i=0; i<v.size(); ++i) {\n            for(int j=0; j<v[i].size(); ++j) {\n                if(v[i][j] <= t) {\n                    ret++;\n                } \n            }\n        }\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef pair<int,int> P;\nint d[70][70],dx[6]={0,1,1,0,-1,-1},dy[6]={1,1,0,-1,-1,0},mid=35,t;\nbool obs[70][70];\nvoid bfs(int x,int y){\n\td[x][y]=0;\n\tqueue<P> que;\n\tque.push(P(x,y));\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tint x=p.first,y=p.second;\n\t\tif(d[x][y]==t) break;\n\t\trep(i,6){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(obs[nx][ny] || d[nx][ny]!=1e8) continue;\n\t\t\td[nx][ny]=d[x][y]+1;\n\t\t\tque.push(P(nx,ny));\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> t >> n;\n\t\tif(t==0) break;\n\t\trep(i,70) rep(j,70) d[i][j]=1e8,obs[i][j]=0;\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=mid,y+=mid;\n\t\t\tobs[x][y]=true;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tbfs(x+mid,y+mid);\n\t\tint cnt=0;\n\t\trep(i,70) rep(j,70) if(d[i][j]!=1e8) cnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t,n;\ntypedef pair<int,int> P;\nconst int C = 60;\nconst int MAX_N=130;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[MAX_N][MAX_N];\n    bool ok[MAX_N][MAX_N];\n    rep(i,MAX_N) rep(j,MAX_N) dist[i][j]=INF,ok[i][j]=true;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        ok[x][y]=false;\n        \n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(x,y));\n    dist[x][y]=0;\n\n    int ans = 0;\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first;\n        int y = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(ok[nx][ny] && dist[nx][ny] == INF) {\n                dist[nx][ny] = dist[x][y]+1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n    rep(i,MAX_N) rep(j,MAX_N) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[100][101]={};\nbool vis[100][100]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.emplace(x,y,t);\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&0<=na&&0<=nb&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.emplace(na,nb,c-1);\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,100)rep(j,100)cnt+=vis[i][j];\n  return cnt;\n}\n\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=30;y+=30;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=30;sy+=30;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\n\n#define TEST 1\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./ans.txt\", \"w\", stdout);\n#endif\n\nusing namespace std;\n\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nmap<pair<int, int>, bool> state;\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[make_pair(nx,ny)] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[make_pair(nx, ny)]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[make_pair(nx + dx[i],ny + dy[i])]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[make_pair(x,y)]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\tcout << f(sx, sy, 0) << endl;\n\n\t\tstate.clear();\n\n\t}\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1, 0, 1, 1, 0, -1};\nint dy[]={0, 1, 1, 0, -1, -1};\n\nint d[1010][1010];\n\nint main(){\n\twhile(1){\n\t\tint n, t;\n\t\tcin>>t>>n;\n\t\tif(n == 0 && t == 0) break;\n\t\t\n\t\trep(i, 1010) rep(j, 1010) d[i][j] = INF;\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\td[y + 500][x + 500] = -1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin>>sx>>sy;\n\t\tsx += 500;\n\t\tsy += 500;\n\t\t\n\t\tqueue<pii> q;\n\t\tq.push({0, sy * 1000 + sx});\n\t\td[sy][sx] = 0;\n\t\tint ans = 1;\n\t\tpii p;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tp = q.front();\tq.pop();\n\t\t\tint x = p.se % 1000, y = p.se / 1000, c = p.fi;\n\t\t\tif(c >= t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(d[ny][nx] != INF) continue;\n\t\t\t\td[ny][nx] = c + 1;\n\t\t\t\tq.push({c + 1, ny * 1000 + nx});\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> p;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] = 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0)\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t, n;\nbool used[200][200], block[200][200];\n\nstruct State {\n  int x, y, t;\n  State(){}\n  State(int ax, int ay, int at):\n  x(ax), y(ay), t(at)\n  {}\n};\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 100; ty += 100;\n    block[ty][tx] = true;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 100; sy += 100;\n  \n  int res = 0;\n  queue<State> que;\n  que.push(State(sx, sy, t));\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    if (used[s.y][s.x] || block[s.y][s.x]) continue;\n    used[s.y][s.x] = true;\n    res++;\n    \n    if (s.t <= 0) continue;\n    for (int z = 0; z < 6; z += 1) {\n      int tx = s.x + dx[z];\n      int ty = s.y + dy[z];\n      \n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(State(tx, ty, s.t-1));\n    }\n  }\n  /*\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  */\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 0;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tint field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tsum++;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>20){if(!field[x-1][y]){field[x-1][y] = 1;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>20){if(!field[x][y-1]){field[x][y-1] = 1;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<80){if(!field[x+1][y]){field[x+1][y] = 1;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<80){if(!field[x][y+1]){field[x][y+1] = 1;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>20 && y>20){if(!field[x-1][y-1]){field[x-1][y-1] = 1;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<80 && y<80){if(!field[x+1][y+1]){field[x+1][y+1] = 1;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {0, 1, -1, 1, -1, 0};\nconst int dy[] = {1, 1, 0, 0, -1, -1};\nint t, n;\nint d[123][123];\nint can[123][123];\nint x, y;\nint N = 35;\n\nint main()\n{\n  while(cin >> t >> n, t){\n    rep(i, 123) rep(j, 123) d[i][j] = 0;\n    rep(i, 123) rep(j, 123) can[i][j] = INF;\n    rep(i, n){\n      cin >> x >> y;\n      can[x+N][y+N] = -INF;\n    }\n    cin >> x >> y;\n\n   queue<pair<pii, int> > que;\n   can[x+N][y+N] = false;\n   d[x+N][y+N] = 1;\n   que.push(mp(mp(x, y), 0));\n   while(!que.empty()){\n     pair<pii, int> here = que.front();  que.pop();\n     int hx = here.first.first;\n     int hy = here.first.second;\n     int cnt = here.second;\n     if(cnt >= t) continue;\n     rep(k, 6){\n       int nx = hx + dx[k];\n       int ny = hy + dy[k];\n       if(minup(can[nx+N][ny+N], cnt + 1)){\n         d[nx+N][ny+N] = 1;\n         que.push(mp(mp(nx, ny), cnt + 1));\n       }\n     }\n   }\n\n   int res = 0;\n   rep(i, 123) rep(j, 123) res += d[i][j];\n\n   cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\nusing namespace std;\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nbool state[1000][1000];\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[nx][ny] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[nx][ny]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[nx][ny] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[nx + dx[i]][ny + dy[i]]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\t\tfor (int i = 0; i < 1000; ++i){\n\t\t\tfor (int j = 0; j < 1000; ++j){\n\t\t\t\tstate[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[x+500][y+500] = true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tcout << f(sx+500, sy+500,0) << endl;\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n && (t || n)) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[a][b] = 2;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[a][b]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[x][y] == 1) {\n\t\t\t\t\tg[x][y]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[nx][ny] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint tile[140][70];\nusing vpii = vector<pair<int,int>>;\nint dx[] = {1,-1,0,0,-1,1};\nint dy[] = {1,-1,1,-1,0,0};\n\n\nint main()\n{\n  int t,n;\n  while(cin >> t >> n,t+n){\n    REP(i,140){\n      REP(j,140){\n        tile[i][j] = 0;\n      }\n    }\n    vpii pii;\n    REP(i,n){\n      int c,k;\n      cin >> c >> k;\n      pii.push_back({k,c});\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    tile[70][70] = 1;\n    for(auto x : pii){\n      tile[x.first-sy+70][x.second-sx+70] = 2;\n    }\n    REP(_t,t){\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j] == 1){\n           REP(k,6){\n            auto ny = max(0,min(139,i + dy[k]));\n            auto nx = max(0,min(139,j+dx[k]));\n            if(tile[ny][nx]==0){\n              tile[ny][nx] = -1;\n            }\n           }\n          }\n        }\n      }\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j]==-1){\n            tile[i][j] = 1;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i,140){\n      REP(j,140){\n        if(tile[i][j]==1){\n          ans++;\n        }\n      }\n    }\n    cout << ans<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[]={0,1,1,0,-1,-1},dy[]={1,1,0,-1,-1,0};\n\nint trans(int n){\n\treturn 100-n;\n}\n\tint t,n;\n\nint dfs(vvi &m,int x,int y,int step){\n\tm[x][y]=1;\n\tif(step==t){\n\t\treturn 1;\n\t}\n\tint ans=1;\n\tREP(i,6){\n\t\tint xx=x+dx[i];\n\t\tint yy=y+dy[i];\n\t\tif(!m[xx][yy]){\n\t\t\tans+=dfs(m,xx,yy,step+1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nstruct node{\n\tint x,y,step;\n\tnode(int x,int y,int step):x(x),y(y),step(step){}\n};\nint main(){\n\twhile(cin>>t>>n,t|n){\n\t\tvvi m(200,vi(200));\n\t\tvi x(n),y(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tREP(i,n){\n\t\t\tm[trans(x[i]-sx)][trans(y[i]-sy)]=1;\n\t\t}\n\t\tqueue<node> q;\n\t\tq.push(node(trans(0),trans(0),0));\n\t\tm[trans(0)][trans(0)]=1;\n\t\tint ans=1;\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.front();\n\t\t\tq.pop();\n\t\t\tif(n.step==t){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,6){\n\t\t\t\tint xx=n.x+dx[i];\n\t\t\t\tint yy=n.y+dy[i];\n\t\t\t\tif(!m[xx][yy]){\n\t\t\t\t\tm[xx][yy]=1;\n\t\t\t\t\tans++;\n\t\t\t\t\tq.push(node(xx,yy,n.step+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define mp(a, b) make_pair(a, b)\ntypedef pair<pair<int, int>, int> State;\n\nstatic const int MAX = 30;\nstatic const int N =  2*MAX+1;\nstatic const int dx[6] = {1, 1, 0, -1, -1, 0};\nstatic const int dy[6] = {0, 1, 1, 0, -1, -1};\nmain(){\n  bool O[N][N];\n  int t, n, x, y, sx, sy;\n  while(1){\n    cin >> t >> n;\n    if ( t == 0 && n == 0 ) break;\n    rep(i, N) rep(j, N) O[i][j] = false;\n    rep(i, n){\n      cin >> x >> y;\n      O[x+MAX][y+MAX] = true;\n    }\n    cin >> sx >> sy;\n    sx += MAX;\n    sy += MAX;\n    queue<State> Q;\n    State u;\n    Q.push(mp(mp(sx, sy), 0));\n    O[sx][sy] = true;\n    int cnt = 0;\n    while(!Q.empty()){\n      u = Q.front(); Q.pop();\n\n      cnt++;\n      for ( int r = 0; r < 6; r++ ){\n\tint nx = u.first.first + dx[r];\n\tint ny = u.first.second + dy[r];\n\tif ( O[nx][ny] || u.second+1 > t) continue;\n\tO[nx][ny] = true;\n\tQ.push(mp(mp(nx, ny), u.second+1));\n      }\n    }\n    cout << cnt << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,t;\nint map[200][200],fast[200][200];\nint dx[6]={0,1,0,-1,1,-1},dy[6]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n    map[y][x]=1;\n    if(len<t&&len<fast[y][x]){\n    fast[y][x]=len;\n    for(int i=0;i<6;i++){\n        if(map[y+dy[i]][x+dx[i]]!=-1)\n            DFS(y+dy[i],x+dx[i],len+1);\n    }\n    }\n}\nint main(){\n    while(true){\n    cin>>t>>n;\n    if(t==0&&n==0)\n        break;\n    for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n            map[i][j]=0;\n            fast[i][j]=100;\n        }\n    }\n    int x,y;\n    for(int i=0;i<n;i++){\n        cin>>x>>y;\n        map[100+y][100+x]=-1;\n    }\n    cin>>x>>y;\n    DFS(y+100,x+100,0);\n    int ans=0;\n    for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n            if(map[i][j]==1)\n                ans++;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 0, 1,-1};\nconst int dy[] = {1, 0,-1,-1, 1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[66][66];\n        bool w[66][66];\n        for (int i = 0; i < 66; i++) for (int j = 0; j < 66; j++) {d[i][j] = INF; w[i][j] = true;}\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 30][t2 + 30] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 30][y + 30] = 0;\n        queue<P> q;\n        q.push(P(x + 30, y + 30));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (0 <= nx && nx <= 60 && 0 <= ny && ny <= 60) {\n                    if (d[nx][ny] != -1 && d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                        if (w[nx][ny]) count++, w[nx][ny] = false;\n                        q.push(P(nx,ny));\n                        d[nx][ny] = d[p.first][p.second] + 1;\n                    }\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntemplate<class T1,class T2>\nusing Hash = unordered_map<T1, T2>;\n\nint dx[]{ 0,1,1,0,-1,-1 }, dy[]{ 1,1,0,-1,-1,0 };\nint main() {\n\tint t, n;\n\twhile (scanf(\"%d%d\", &t, &n), t) {\n\t\tHash<int, Hash<int, int>>mp, d;\n\t\trep(i, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tmp[x][y] = 1;\n\t\t}\n\t\tfor (int i = -50; i <= 50; i++)for (int j = -50; j <= 50; j++) {\n\t\t\td[i][j] = INT_MAX;\n\t\t}\n\t\tint sx, sy; scanf(\"%d%d\", &sx, &sy);\n\t\tqueue<P>que;\n\t\tint cnt = 1;\n\t\tque.push(P(sx, sy));\n\t\td[sx][sy] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (d[p.first][p.second] >= t)continue;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (!mp[nx][ny] && d[nx][ny] == INT_MAX) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[200][200];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sx-data[1][i])>2*t+1){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (100-sx);\n\t\t\ttmpY += (100-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=100;\n\t\tsy=100;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[150][150];\nbool used[150][150];\nbool come[150][150];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)ta[i][j]=0,used[i][j]=0,come[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=50,ty+=50;\n\tta[ty][tx]=1;\n\t}\n\tused[50][50]=1;\n\tmasu start;\n\tstart.x=50,start.y=50,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\t//cout<<nx<<\" \"<<ny<<endl;\n\tif(come[ny][nx]==1)continue;\n\tcome[ny][nx]=1;\n\tused[ny][nx]=1;\n\tif(ntn>=t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]==0&&used[nexty][nextx]==0){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)if(used[i][j])ans++;\n\tint ttt;\n\tcin>>ttt>>ttt;\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x_;\n    int y_;\n    int t_;\n\n    State(int x, int y, int t) {\n        x_ = x;\n        y_ = y;\n        t_ = t;\n    }\n};\n\nint main (int argc, char *argv[]) {\n    int n, t;\n    int dx[6] = {1, 1, 0, -1, -1, 0};\n    int dy[6] = {0, 1, 1, 0, -1, -1};\n    while (cin>>t>>n, t||n) {\n        int sx, sy;\n        bool ob[60][60] = {false};\n        bool visited[60][60] = {false};\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin>>x>>y;\n            ob[x+30][y+30] = true;\n        }\n        cin>>sx>>sy;\n        queue<State> que;\n        que.push(State(sx, sy, 0));\n        visited[sx+30][sy+30] = true;\n        while (!que.empty()) {\n            State s = que.front();\n            que.pop();\n            for (int i = 0; i < 6; ++i) {\n                int nx = s.x_ + dx[i];\n                int ny = s.y_ + dy[i];\n                if (-30 <= nx && nx <= 30 && -30 <= ny && ny <= 30 \n                && !visited[nx+30][ny+30] && !ob[nx+30][ny+30] && s.t_ < t) {\n                    que.push(State(nx, ny, s.t_ + 1));\n                    // printf(\"(%d, %d)\\n\", nx, ny);\n                    visited[nx+30][ny+30] = true;\n                    ans++;\n                }\n            }\n        }\n        cout<<ans + 1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(long long int i=0;i<n;++i)\ntypedef long long int ll;\n\nint main(){\n\n    while(1){\n        int t,n;\n        cin >> t >> n;\n        if(t==0&&n==0){\n            break;\n        }\n        int dx[]={0,1,1,0,-1,-1};\n        int dy[]={1,1,0,-1,-1,0};\n        int gen=100;\n        vector<vector<int>> m(201,vector<int>(201,-1));\n        for(int i=0;i<n;i++){\n            int tx,ty;\n            cin >> tx >> ty;\n            tx+=gen;\n            ty+=gen;\n            m[ty][tx]=100000;\n        }\n        int stx,sty;\n        cin >> stx >> sty;\n        stx+=gen;\n        sty+=gen;\n        m[sty][stx]=0;\n        queue<pair<int,int>> q;\n        q.push({sty,stx});\n        int ans=0;\n        while(q.size()!=0){\n            pair<int,int> now=q.front();\n            q.pop();\n            for(int i=0;i<6;i++){\n                int ny=now.first+dy[i];\n                int nx=now.second+dx[i];\n                if(0<=nx&&nx<201&&0<=ny&&ny<201){\n                    if(m[ny][nx]==-1){\n                        m[ny][nx]=m[now.first][now.second]+1;\n                        q.push({ny,nx});\n                    }\n                }\n            }\n        }\n        for(int i=0;i<201;i++){\n            for(int j=0;j<201;j++){\n                if(m[i][j]<=t&&m[i][j]!=-1){\n                    ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint min = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] == INT_MIN)\n\t\t\t\t{\n\t\t\t\t\tmin++;\n\t\t\t\t}\n\n\t\t\t\tif (map[i][j] == INT_MAX)\n\t\t\t\t{\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 100 * 100 - min - max;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\nint a[1000][1000];\n// int vis[1000][1000];\nint dx[]={0,-1,-1,0,1,1};\nint dy[]={1,0,-1,-1,0,1};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,1000){\n\t\t\trep(j,1000){\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta[x+500][y+500]=1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint ans=0;\n\t\tsx+=500;\n\t\tsy+=500;\n\t\tqueue<pii> q;\n\t\tq.push(mkp(sx,sy));\n\t\ta[sx][sy]=1;\n\t\tans++;\n\t\trep(i,t){\n\t\t\tint qs=q.size();\n\t\t\trep(j,qs){\n\t\t\t\tpii top=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(l,6){\n\t\t\t\t\tint xx=top.F+dx[l];\n\t\t\t\t\tint yy=top.S+dy[l];\n\t\t\t\t\tif(a[xx][yy]==0){\n\t\t\t\t\t\tq.push(mkp(xx,yy));\n\t\t\t\t\t\ta[xx][yy]=1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,t;\nint map[100][100];\nint dx[]={0,1,0,-1,1,-1},dy[]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n\tmap[y][x]=1;\n\tif(len<t){\n\tfor(int i=0;i<6;i++){\n\t\tif(map[y+dy[i]][x+dx[i]]!=-1)\n\t\t\tDFS(y+dy[i],x+dx[i],len+1);\n\t}\n\t}\n}\nint main(){\n\twhile(true){\n\tcin>>t>>n;\n\tif(t==0&&n==0)\n\t\tbreak;\n\tfor(int i=0;i<100;i++)\n\t\tfor(int j=0;j<100;j++)\n\t\t\tmap[i][j]=0;\n\tint x,y;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x>>y;\n\t\tmap[50+y][50+x]=-1;\n\t}\n\tcin>>x>>y;\n\tDFS(y+50,x+50,0);\n\tint ans=0;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(map[i][j]==1)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[6]={1,1,0,-1,-1,0};\nconst int dy[6]={1,0,-1,-1,0,1};\nint board[1500][1500];\nint t,n;//ターン数、障害物の数\ntypedef pair<int,int> P;\nqueue<P> que;\nqueue<int> cost;\nint main(){\n  int x;\n  int y;\n  int sx,sy;\n  while(cin>>t>>n,n||t){\n    \n    for(int i =0;i <= 1000;i++){\n      for(int j = 0;j <= 1000;j++){\n\tboard[i][j] = 0;\n      }\n    }\n    for(int i = 0;i <n;i++){\n      cin>>x>>y;\n      board[y+200][x+200] = 1;\n    }\n    cin>>sx>>sy;\n    sx+=200;\n    sy+=200;\n    que.push(P(sy,sx));\n    cost.push(0);\n    int ans = 0;\n    while(!que.empty()){\n      P p =que.front();\n      que.pop();\n      int turn = cost.front();\n      cost.pop();\n      if(turn >t){\n\tcontinue;\n      }\n      int px = p.second;\n      int py = p.first;\n      if(board[py][px]==1){\n\tcontinue;\n      }\n      board[py][px] =1;\n      ans++;\n      for(int i = 0;i < 6;i++){\n\tint nx = px +dx[i];\n\tint ny = py +dy[i];\n\tif(board[ny][nx]==0){\n\t  cost.push(turn+1);\n\t  que.push(P(ny,nx));\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nmap<pair<int, int>, int> dp;\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {0, 1, 1, 0, -1, -1};\n\n\nint main() {\n    int t, n;   // ターン数 t, 障害物の数 n\n    while (cin >> t >> n, t) {\n        dp.clear();\n        while (n--) {\n            int x, y; cin >> x >> y;\n            dp[{x, y}] = -1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        queue<pair<pair<int, int>, int>> q;\n        q.emplace(make_pair(sx, sy), t);\n        while (!q.empty()) {\n            auto p = q.front(); q.pop();\n            int cx = p.first.first, cy = p.first.second, t = p.second;\n            if (dp[make_pair(cx, cy)] != 0) continue;\n            if (t < 0) continue;\n            dp[make_pair(cx, cy)] = 1;\n            for (int i = 0; i < 6; i++) {\n                q.emplace(make_pair(cx + dx[i], cy + dy[i]), t - 1);\n            }\n        }\n        int cnt = 0;\n        for (auto p : dp) if (p.second == 1) cnt++;\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\nstruct Point {\n\tint cost, x, y;\n};\n\nbool passed[200][200];\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint main(){\n\twhile(true){\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0){ break; }\n\t\tmemset(passed, 0, sizeof(passed));\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpassed[y + 100][x + 100] = true;\n\t\t}\n\t\tqueue<Point> q;\n\t\tPoint first = { 0, 0, 0 };\n\t\tcin >> first.x >> first.y;\n\t\tfirst.x += 100; first.y += 100;\n\t\tq.push(first);\n\t\tpassed[first.y][first.x] = true;\n\t\tint answer = 0;\n\t\twhile(!q.empty()){\n\t\t\tPoint p = q.front();\n\t\t\tq.pop();\n\t\t\tif(p.cost > t){ break; }\n\t\t\t++answer;\n\t\t\tfor(int i = 0; i < 6; ++i){\n\t\t\t\tint x = p.x + dx[i], y = p.y + dy[i];\n\t\t\t\tif(!passed[y][x]){\n\t\t\t\t\tpassed[y][x] = true;\n\t\t\t\t\tq.push((Point){ p.cost + 1, x, y });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nconst int dx[6] = { 1, 0, -1, -1, 0, 1 };\nconst int dy[6] = { 0, -1, -1, 0, 1, 1 };\nstruct Point {\n  int x, y, cost;\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n  bool operator<(const Point &rhs) const {\n    if (x != rhs.x) { return x < rhs.x; }\n    return y < rhs.y;\n  }\n};\n\nint main() {\n  int t, n;\n  while (scanf(\"%d %d\", &t, &n), t|n) {\n    set<Point> visit;\n    REP(i, n) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      visit.insert(Point(x, y, 0));\n    }\n    int sx, sy;\n    scanf(\"%d %d\", &sx, &sy);\n    queue<Point> que;\n    que.push(Point(sx, sy, 0));\n    while (!que.empty()) {\n      Point p = que.front();\n      que.pop();\n      if (visit.count(p)) { continue; }\n      visit.insert(p);\n      REP(dir, 6) {\n        int nx = p.x + dx[dir];\n        int ny = p.y + dy[dir];\n        int ncost = p.cost + 1;\n        if (ncost > t) { continue; }\n        que.push(Point(nx, ny, ncost));\n      }\n    }\n    printf(\"%d\\n\", (int)visit.size() - n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[6] = { 1,1,0,-1,-1,0};\nconst int dy[6] = { 0,1,1,0,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif (!t)break;\n\t\tvvi v(63, vi(63, 0));\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv[y + 31][x + 31] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tvvi depth(63, vi(63, INF));\n\t\tdepth[sy + 31][sx + 31] = 0;\n\t\tqueue<pii> q;\n\t\tq.push(make_pair(sx, sy));\n\t\twhile (!q.empty()) {\n\t\t\tpii a = q.front(); q.pop();\n\t\t\tint x = a.first, y = a.second;\n\t\t\tREP(i, 6) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (ny <= 31 && nx <= 31 && nx >= -31 && ny >= -31 && v[ny + 31][nx + 31] == 0&&depth[ny+31][nx+31]==INF) {\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\tdepth[ny + 31][nx + 31] = depth[y + 31][x + 31] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 63) {\n\t\t\tREP(j, 63) {\n\n\t\t\t\tif (depth[i][j] <= t)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint cnt;\nbool field[62][62];\n\nvoid dfs(int x, int y, int depth){\n    if(x < -30 || 30 < x || y < -30 || 30 < y) return;\n    if(!field[x+30][y+30]) cnt++;\n    field[x+30][y+30] = true;\n    if(depth>0){\n        REP(i,6){\n            dfs(x+dx[i], y+dy[i], depth-1);\n        }\n    }\n    return;\n}\n\nint main(){\n    int t,n;\n    while(cin >> t >> n){\n        if(t + n == 0) break;\n        memset(field, false, sizeof(field));\n        cnt = 0;\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            field[x+30][y+30] = true;\n        }\n        cin >> x >> y;\n        dfs(x,y,t);\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\nconst int dx[6] = { 0, 1, 1, 0, -1, -1 };\nconst int dy[6] = { 1, 1, 0, -1, -1, 0 };\n\nint main( void ) \n{\n    int t, n;\n    while ( cin >> t >> n && t ) {\n        // init\n        set <PII> O;\n        set <PII> V;\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            PII o;\n            cin >> o.first >> o.second;\n            O.insert( o );\n        }\n        PII start;\n        cin >> start.first >> start.second;\n\n        // proc\n        queue <PIP> Q;\n        PIP start_node( 0, start );\n        Q.push( start_node );\n        V.insert( start );\n\n        while ( !Q.empty() ) {\n            PIP node = Q.front();\n            Q.pop();\n\n            int next_t = node.first + 1;\n            PII pos = node.second;\n            if ( next_t > t ) continue;\n\n            for ( int i = 0; i < 6; i++ ) {\n                PII next_pos = pos;\n                next_pos.first += dx[i];\n                next_pos.second += dy[i];\n                if ( O.count( next_pos ) || V.count( next_pos ) ) continue;\n                V.insert( next_pos );\n\n                PIP next_node( next_t, next_pos );\n                Q.push( next_node );\n            }\n        }\n\n        cout << V.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 150;\n\nint dx[6] = {-1, 0, 1, 1, 0, -1};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\tint t, n;\n\tint field[450][450];\n\twhile(cin >> t >> n, t+n){\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 450)rep(j, 450) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tfield[sx][sy] = 1;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(sx, sy));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y] > t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(field[nx][ny] != -1 && (field[x][y]+1 < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\trep(i, 450)rep(j, 450) if(0 < field[i][j] && field[i][j] < 1e7) count++;\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint main()\n{\n    int t,n;\n    while(cin >> t >> n) {\n        if(t == 0 && n == 0) break;\n        \n\n        int GETA = 100;\n        bool used[200][200];\n        memset(used,0,sizeof(used));\n\n        rep(i,n) {\n            int x,y;\n            cin >> x >> y;\n            \n            used[y+GETA][x+GETA] = true;\n        }\n\n        queue<pair<pair<int,int>,int> > que;\n        int sx,sy;\n        cin >> sx >> sy;\n\n        sy += GETA;\n        sx += GETA;\n\n        que.push(mp(mp(sy,sx),0));\n\n        int ans = 1;\n        used[sy][sx] = true;\n\n        while(que.size()) {\n            int y = que.front().first.first;\n            int x = que.front().first.second;\n            int cnt = que.front().second;\n            que.pop();\n\n            if(cnt < t) {\n                rep(i,6) {\n                    int ny = y + dy[i];\n                    int nx = x + dx[i];\n\n                    if(!used[ny][nx]) {\n                        used[ny][nx] = true;\n                        ans++;\n\n                        // cout << ny << \" \" << nx << endl;\n                        \n                        que.push(mp(mp(ny,nx),cnt+1));\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;cin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#include <cstdio>\n#include <cstring>\n\n#define REP(i, n) for(typeof(n) i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int offset = 100;\n\nint memo[200][200];\n\nconst int dx[] = { 1, 1, 0,-1,-1, 0 };\nconst int dy[] = { 1, 0,-1,-1, 0, 1 };\n\nint main(){\n  int t, n;\n\n  while(scanf(\"%d%d\", &t, &n), t + n){\n    int sx, sy;\n    int ans = 1;\n    queue<pair<int, int> > q;\n\n    REP(i, 200) REP(j, 200) memo[i][j] = -1;\n\n    REP(i, n){\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      memo[y + offset][x + offset] = 0;\n    }\n\n    scanf(\"%d%d\", &sx, &sy);\n\n    q.push(make_pair(sx, sy));\n    memo[sy + offset][sx + offset] = 0;\n\n    while(q.size()){\n      int x = q.front().first;\n      int y = q.front().second;\n      int turn = memo[y + offset][x + offset];\n\n      q.pop();\n\n      if(turn == t) continue;\n\n      REP(i, 6){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(memo[yy + offset][xx + offset] == -1){\n          memo[yy + offset][xx + offset] = turn + 1;\n          q.push(make_pair(xx, yy));\n          ans++;\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint t, n, d[100][100];\nbool s[100][100];\n\n\nvoid bfs(int x, int y, int k){\n    if(k == 0)return;\n    \n    if(d[x + 1][y] + 1 < k && !s[x + 1][y]){\n        d[x + 1][y] = k - 1;\n        bfs(x + 1, y, k - 1);\n    }\n    if(d[x - 1][y] + 1 < k && !s[x - 1][y]){\n        d[x - 1][y] = k - 1;\n        bfs(x - 1, y, k - 1);\n    }\n    if(d[x + 1][y + 1] + 1 < k && !s[x + 1][y + 1]){\n        d[x + 1][y + 1] = k - 1;\n        bfs(x + 1, y + 1, k - 1);\n    }\n    if(d[x - 1][y - 1] + 1 < k && !s[x - 1][y - 1]){\n        d[x - 1][y - 1] = k - 1;\n        bfs(x - 1, y - 1, k - 1);\n    }\n    if(d[x][y + 1] + 1 < k && !s[x][y + 1]){\n        d[x][y + 1] = k - 1;\n        bfs(x, y + 1, k - 1);\n    }\n    if(d[x][y - 1] + 1 < k && !s[x][y - 1]){\n        d[x][y - 1] = k - 1;\n        bfs(x, y - 1, k - 1);\n    }\n}\n\nint main() {\n    int sx, sy;\n    \n    cin >> t >> n;\n    \n    while(t != 0 || n != 0){\n        REP(i, 100){\n            REP(j, 100){\n                d[i][j] = -INF;\n                s[i][j] = false;\n            }\n        }\n        \n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            s[x + 50][y + 50] = true;\n        }\n        \n        cin >> sx >> sy;\n        \n        d[sx + 50][sy + 50] = t;\n        bfs(sx + 50, sy + 50, t);\n        \n        int ans = 0;\n        REP(i, 100){\n            REP(j, 100){\n                if(d[i][j] != -INF)ans++;\n            }\n        }\n        \n        cout << ans << endl;\n        \n        cin >> t >> n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nint HV[][2]{\n        {0,  1},\n        {1,  1},\n        {1,  0},\n        {0,  -1},\n        {-1, -1},\n        {-1, 0},\n};\n\nint main() {\n    int t, n;\n    while (cin >> t >> n) {\n        if ((t | n) == 0) break;\n\n        unordered_map<int, unordered_set<int>> o;   //obstacle\n\n        while (n--) {\n            int x, y;\n            cin >> x >> y;\n            o[x].insert(y);\n        }\n\n        int sx, sy;\n        cin >> sx >> sy;\n        o[sx].insert(sy);\n\n        int ans = 1;\n        queue<tuple<int, int, int>> que;\n\n        que.emplace(sx, sy, 0);\n        while (!que.empty()) {\n            int x, y, c;\n            x = get<0>(que.front());\n            y = get<1>(que.front());\n            c = get<2>(que.front());\n            que.pop();\n            if (c == t) continue;\n            for (auto hv : HV) {\n                int nx, ny;\n                nx = x + hv[0];\n                ny = y + hv[1];\n                if (o.find(nx) == o.end() || o[nx].find(ny) == o[nx].end()) {\n                    que.emplace(nx, ny, c + 1);\n                    o[nx].insert(ny);\n                    ans++;\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<int> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint dx[] = {1, -1, 0, 1, 0, -1};\nint dy[] = {0, 0, 1, 1, -1, -1};\n\nsigned main() {\n    int t, n;\n    while(cin >> t >> n, t || n) {\n        set<pii> used, obstacle;\n        rep(i,0,n) {\n            int x, y; cin >> x >> y;\n            obstacle.insert(pii(x, y));\n        }\n        int x, y; cin >> x >> y;\n\n        queue< pair<P, int> > q;\n        q.push(make_pair(P(x, y), 0));\n        while(!q.empty()) {\n            pair<P, int> cur = q.front(); q.pop();\n            used.insert(pii(cur.first.X, cur.first.Y));\n            if(cur.second == t) continue;\n\n            int sx = cur.first.X, sy = cur.first.Y;\n            rep(i,0,6) {\n                int nx = sx + dx[i];\n                int ny = sy + dy[i];\n                if(obstacle.count(pii(nx, ny))) continue;\n                if(used.count(pii(nx, ny))) continue;\n                q.push(make_pair(P(nx, ny), cur.second+1));\n            }\n        }\n        cout << used.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nint N = 250;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\tint ans(1);\n\tvector<int> dx{ 1,1,0,-1,-1,0 }, dy{ 0, 1, 1, 0, -1, -1 };\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (field[a.first][a.second] == 1)continue;\n\n\t\trep(i, 0, dx.size()) {\n\t\t\tint ax = a.first + dx[i], ay = a.second + dy[i];\n\t\t\tif (0 <= ax&&ax < N && 0 <= ay&&ay < N&&field[ax][ay] == -1) {\n\t\t\t\tfield[ax][ay] = max(0, field[a.first][a.second] - 1);\n\t\t\t\tQ.push(make_pair(ax, ay));\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\trep(i, 0, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += N / 2; y += N / 2;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += N / 2; sy += N / 2;\n\t\tfield[sx][sy] = t + 1;\n\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (ll i = 0, i##_len = (n); i < i##_len; i++)\nusing namespace std;\nusing ll = long signed long;\n\nusing point = pair<ll, ll>;\n\nvector<point> neighborhood_of(const point &xy) {\n    const ll x = xy.first, y = xy.second;\n    return {\n        {x-1, y-1},\n        {x  , y-1},\n        {x-1, y  },\n        {x+1, y  },\n        {x  , y+1},\n        {x+1, y+1}\n    };\n}\n\nint main() {\n\n    vector<ll> anss;\n\n    for (ll t, n; cin >> t >> n, t; ) {\n\n        set<point> o;\n        REP(i, n) {\n            ll x, y; cin >> x >> y;\n            o.insert(point(x, y));\n        }\n\n        ll rx, ry; cin >> rx >> ry;\n\n        set<point> vst;\n        map<point, ll> dep;\n        deque<point> q;\n        q.emplace_back(rx, ry);\n        vst.insert(q.back());\n        dep[q.back()] = 0;\n        while (q.size()) {\n            point u = q.front(); q.pop_front();\n            const ll d = dep[u];\n            if (d >= t) continue;\n            for (const point &v : neighborhood_of(u)) {\n                if (o.find(v) == o.end() && vst.find(v) == vst.end()) {\n                    q.push_back(v);\n                    vst.insert(v);\n                    dep[v] = d + 1;\n                }\n            }\n        }\n\n        anss.emplace_back(vst.size());\n\n    }\n\n    for (ll ans : anss) cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct point {\n  int x, y;\n};\n\nconst int dir[6][2] = { {1, 0}, {-1, 0}, {1, 1}, {-1, -1}, {0, 1}, {0, -1} };\n\nint main() {\n  int t, n;\n  while(scanf(\"%d%d\", &t, &n) != EOF && t) {\n    bool visited[100][100]; // 障害物＝もう訪れた、とする。\n    fill(&visited[0][0], &visited[0][0]+100*100, false);\n    for (int i=0; i<n; i++) {\n      int tx, ty;\n      scanf(\"%d%d\", &tx, &ty);  tx += 50; ty += 50;\n      visited[tx][ty] = true;\n    }\n    queue<pair<point,int>> Q; // 幅優先探索で解く。\n    int sx, sy;\n    scanf(\"%d%d\", &sx, &sy); sx += 50; sy += 50;\n    point p = { sx, sy };\n    Q.push(make_pair(p, 0));\n    int count = 0;\n    while (! Q.empty()) {\n      int times = Q.front().second;\n      if (times > t) break;\n      p = Q.front().first;\n      Q.pop();\n      if (! visited[p.x][p.y]) {\n\tvisited[p.x][p.y] = true;\n\tcount++;\n\tfor (int i=0; i<6; i++) {\n\t  int tx = p.x+dir[i][0];\n\t  int ty = p.y+dir[i][1];\n\t  if (! visited[tx][ty]) {\n\t    point temp = {tx, ty};\n\t    Q.push(make_pair(temp, times+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return true;\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto p=q.front().first;\n            int turn=q.front().second;\n            q.pop();\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n,s=70;\n\tvvi field(s*2+3,vi(s*2+3,0));\n\tfor(auto y:{0,s*2+2})rep(x,s*2+3)field[y][x]=field[x][y]=1;\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=s+1,y+=s+1;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=2;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\t\n\tint t, n;\n\t\n\twhile(true){\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tbool visited[200][200] = {};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint num1, num2;\n\t\t\tcin >> num1 >> num2;\n\t\t\tvisited[num1 + 100][num2 + 100] = true;\n\t\t}\n\t\t\n\t\tint x1, y1;\n\t\tcin >> x1 >> y1;\n\t\t\n\t\tqueue<P> que;\n\t\t\n\t\tP poyo;\n\t\tpoyo.first = x1;\n\t\tpoyo.second = y1;\n\t\tque.push(poyo);\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int loop = 0; loop <= t; loop++){\n\t\t\tint N = que.size();\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tP p = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(visited[p.first + 100][p.second + 100]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\tvisited[p.first + 100][p.second + 100] = true;\n\t\t\t\tP p1 = p;\n\t\t\t\tp1.second++;\n\t\t\t\tque.push(p1);\n\t\t\t\tp1 = p;\n\t\t\t\tp1.second--;\n\t\t\t\tque.push(p1);\n\t\t\t\tp1 = p;\n\t\t\t\tp1.first++;\n\t\t\t\tque.push(p1);\n\t\t\t\tp1 = p;\n\t\t\t\tp1.first--;\n\t\t\t\tque.push(p1);\n\t\t\t\tp1 = p;\n\t\t\t\tp1.first--;\n\t\t\t\tp1.second--;\n\t\t\t\tque.push(p1);\n\t\t\t\tp1 = p;\n\t\t\t\tp1.first++;\n\t\t\t\tp1.second++;\n\t\t\t\tque.push(p1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\n#define SZ 30\n\nbool visited[SZ*2+5][SZ*2+5];\n\nbool isin(int x, int y){\n    if((x-SZ)*(y-SZ)>=0) return x>=0 && x<=SZ*2 && y>=0 && y<=SZ*2;\n    else return abs(x-SZ)+abs(y-SZ)<=SZ;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[SZ*2+5], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+SZ][y+SZ]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+SZ, sy+SZ), 0));\n        visited[sx+SZ][sy+SZ]=true;\n        int res=1;\n        while (!q.empty()){\n            const int dx[] = {1,1,0,-1,-1,0};\n            const int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second==t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n//                    cout<<nx-SZ<<\",\"<<ny-SZ<<endl;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint tile[140][70];\nusing vpii = vector<pair<int,int>>;\nint dx[] = {1,-1,0,0,-1,1};\nint dy[] = {1,-1,1,-1,0,0};\n\n\nint main()\n{\n  int t,n;\n  while(cin >> t >> n,t+n){\n    REP(i,140){\n      REP(j,140){\n        tile[i][j] = 0;\n      }\n    }\n    vpii pii;\n    REP(i,n){\n      int c,k;\n      cin >> c >> k;\n      pii.push_back({k,c});\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    tile[70][70] = 1;\n    for(auto x : pii){\n      tile[x.first-sy+70][x.second-sx+70] = 2;\n    }\n    REP(_t,t){\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j] == 1){\n           REP(k,6){\n            auto ny = max(0,min(139,i + dy[k]));\n            auto nx = max(0,min(139,j+dx[k]));\n            if(tile[ny][nx]==0){\n              tile[ny][nx] = -1;\n            }\n           }\n          }\n        }\n      }\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j]==-1){\n            tile[i][j] = 1;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i,140){\n      REP(j,140){\n        if(tile[i][j]==1){\n          ans++;\n        }\n      }\n    }\n    cout << ans<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n;\nbool used[100][100], block[100][100];\n\nvoid solve() {\n  memset(block, false, sizeof block);\n  memset(used, false, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = true;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 61\n#define CONT 30\n\nint T,N;\n\nvoid dfs(int x, int y, int turn, vector< vector<int> > &field)\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\tif(x < 0 || x >= MAX || y < 0 || y >= MAX){ return; } //範囲外\n\n\tif(turn > T){ return; } //ターン数オーバー\n\n\tif(field[x][y] <= turn && field[x][y]){ return; } //到達修正\n\tif(field[x][y] == -1){ return; } //障害物\n\n\tfield[x][y] = turn;\n\t\n\trep(i,6){\n\t\tdfs(x+dx[i], y+dy[i], turn+1, field);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> T >> N )\n\t{\n\t\tif(T == 0 && N == 0){ break; }\n\n\t\tvector< vector<int> > field(MAX,vector<int>(MAX,0));\n\t\n\t\tint X,Y;\n\t\trep(nth,N)\n\t\t{\n\t\t\tcin >> X >> Y;\n\t\t\tfield[X+CONT][Y+CONT] = -1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\n\t\tint ans = 0;\n\t\tdfs(sx+CONT,sy+CONT,0,field);\n\t\tfield[sx+CONT][sy+CONT] = 1;\n\t\t\n\t\trep(y,MAX){\n\t\t\trep(x,MAX){\n\t\t\t\tif(field[x][y] > 0){ ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dx[6] = {-1,-1, 0, 1, 1, 0};\nint dy[6] = {-1, 0, 1, 1, 0,-1};\n\nint bfs(int sy, int sx, int st, vvi& board, vvi& used){\n\n  queue<piii> que;\n  que.push(piii(pii(sy,sx),st));\n  \n  int ans = 0;\n  while(que.size()){\n    int y = que.front().first.first;\n    int x = que.front().first.second;\n    int t = que.front().second;\n    que.pop();\n    if(y > 60 || y < 0 || x > 60 || x < 0) continue; // ?£????\n    if(used[y][x]  == 1) continue;  // ??¢?´¢?????? \n    if(board[y][x] == 1) continue;;  // ?????????\n    if(t < 0) continue; // ???????????°??????\n    \n    ans++;\n    used[y][x] = 1; \n    for(int i=0; i<6; i++){\n      int nx = x + dx[i]; int ny = y + dy[i];\n      que.push(piii(pii(ny,nx),t-1));\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(!t and !n)break;\n    \n    vvi board(200,vi(200,0));\n    vvi used(200,vi(200,0));\n    for(int i=0; i<n; i++){\n      int x,y; cin >> x >> y;\n      board[y+30][x+30] = 1; // ?????????\n    }\n    int sx,sy; cin >> sx >> sy;\n    cout << bfs(sy+30,sx+30,t,board,used) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\nconst int MAX = 200 ;\n\nint a[MAX][MAX];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif(a[p.real() + MAX/2][p.imag() + MAX/2] == -2) return 0;\n\tif(k <= a[p.real() + MAX/2][p.imag() + MAX/2]) return 0;\n\n\tint res = 0;\n\tif(a[p.real() + MAX/2][p.imag() + MAX/2] == -1) res++;\n\ta[p.real() + MAX/2][p.imag() + MAX/2] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p + dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tmemset(a, -1, sizeof(a));\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x + MAX/2][y + MAX/2] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n# define rep(i, n) for (int i = 0; i < (int)(n); i++)\n \nusing namespace std;\n \nnamespace utils{\n  template <typename T> void print(vector<vector<T>> mat) {\n    rep (i, mat.size()) {\n      rep (j, mat[0].size()) cout << mat[i][j] << ' ';\n      cout << endl;\n    }\n  }\n \n  template <typename T> void print(vector<T> v) {\n    rep (i, v.size()) cout << v[i] << ' ';\n    cout << endl;\n  }\n \n  template <typename T> pair<T, T> shape(vector<vector<T>> mat) {\n    int d1, d2;\n \n    d1 = mat.size();\n    if (d1 > 0) d2 = mat[0].size();\n    else int d2 = 0;\n    cout << \"(\" << d1 << \", \" << d2 << \")\" << endl;\n    return make_pair(0, 0);\n  }\n \n  template <typename T> vector<vector<T>> empty(int n, int m) {\n    vector<vector<T>> mat(n, vector<T>(m));\n    return mat;\n  }\n}\n \n \nconst int OFFSET = 30;\n \nint main() {\n  int t, n;\n  int cx, cy;\n  int sx, sy;\n \n  vector<int> dx = {1, 1, 0, -1, -1, 0};\n  vector<int> dy = {1, 0, -1, -1, 0, 1};\n \n  queue<pair<pair<int, int>, int>> s;\n \n  while (cin >> t >> n && (t || n)) {\n    vector<vector<bool>> visited = utils::empty<bool>(60, 60);\n    rep (i, 60) fill(visited[i].begin(), visited[i].end(), false);\n \n    rep (i, n) {\n      cin >> cx >> cy;\n      cx += OFFSET; cy += OFFSET;\n      visited[cx][cy] = true;\n    }\n\n    cin >> sx >> sy;\n    sx += OFFSET;\n    sy += OFFSET;\n\n    //initialize\n    s.push(make_pair(make_pair(sx, sy), 0));\n    int ans = 0;\n \n    while (!s.empty()) {\n      pair<pair<int, int>, int> q = s.front(); s.pop();\n      int cx = q.first.first;\n      int cy = q.first.second;\n      int turn = q.second;\n\n\n      if (cx < 0 || cy < 0 || cx >= 60 || cy >= 60 || visited[cx][cy]) continue;\n      ans++;\n      visited[cx][cy] = true;\n \n      rep (i, 6) {\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n \n        if (turn < t) {\n          s.push(make_pair(make_pair(nx, ny), turn+1));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define INF 1e8\nusing namespace std;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nbool table[150][150];\nint d[150][150];\nint turn;\nvoid bfs(int x,int y){\n    d[x][y] = 0;\n    queue<pair<int,int> > que;\n    que.push(pair<int,int>(x,y));\n    while(!que.empty()){\n\t\tpair<int,int> p = que.front();\n        que.pop();\n        int x = p.first,y = p.second;\n        if(d[x][y] == turn) break;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(table[nx][ny] || d[nx][ny] != INF) continue;\n            d[nx][ny] = d[x][y] + 1;\n            que.push(pair<int,int>(nx,ny));\n        }\n    }\n}\nint main(){\n    int block;\n    while(cin >> turn >> block){\n        if(turn == 0 && block == 0) break;\n        rep(i,150){\n            rep(j,150) {\n                d[i][j] = INF;\n                table[i][j] = 0;\n            }\n        }\n        int x,y;\n        rep(i,block){\n            cin >> x >> y;\n            table[x+70][y+70] = 1;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx += 70; sy += 70;\n        bfs(sx,sy);\n        int ans = 0;\n        rep(i,150){\n            rep(j,150){\n                if(d[i][j] != INF) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,-1}, dy[] = {0,1,0,-1,1,-1};\n\nstruct P {\n    int x, y, depth;\n};\n\nint main() {\n    int turn, block_n;\n    while (cin >> turn >> block_n, turn|block_n) {\n        bool field[62][62] = {};\n        REP(i, block_n) {\n            int x, y;\n            cin >> x >> y;\n            x += 30;\n            y += 30;\n            field[y][x] = true;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        start_x += 30;\n        start_y += 30;\n\n        int cnt = 1;\n\n        queue<P> que;\n        que.push({start_x, start_y, 0});\n        field[start_y][start_x] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.depth == turn) continue;\n            REP(i, 6) {\n                int sx = p.x + dx[i];\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx <= 60 && 0 <= sy && sy <= 60) {\n                    if (!field[sy][sx]) {\n                        field[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy, p.depth+1});\n                    }\n                }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n \nusing namespace std;\n \nconst int MAX = 200;\nconst int BASE = 70;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n \nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n \nvoid dfs(int x, int y, int t){\n \n  // cout << x << \" \"  << y << endl;\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n \n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(!wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n \nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0) ans++;\n  cout << ans << endl;\n}\n \nint main(){\n \n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nbool inside(PII p) {\n    return 0 <= p.first && p.first < 60 && 0 <= p.second && p.second < 60;\n}\nvoid solve(int t, int n) {\n    int cnt = 0;\n    vector<vector<bool>> used(65, vector<bool>(65, false));\n    int dx[] = {0, 0, -1, -1, 1, 1};\n    int dy[] = {-1, 1, -1, 0, 0, 1};\n    set<PII> block;\n    PII start;\n    REP(_, n) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        used[x + 30][y + 30] = true;\n    }\n    int x, y; scanf(\"%d%d\", &x, &y);\n    start = MP(x + 30, y + 30);\n    queue<pair<PII, int>> q;\n    q.push(MP(start, 0));\n    while (!q.empty()) {\n        auto buf = q.front(); q.pop();\n        PII now = buf.first;\n        if (buf.second > t) continue;\n        if (used[now.first][now.second]) continue;\n        used[now.first][now.second] = true;\n        cnt++;\n        REP(i, 6) {\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n            if (!inside(MP(nx, ny))) continue;\n            q.push(MP(MP(nx, ny), buf.second + 1));\n        }\n    }\n    cout << cnt << endl;\n    return;\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    while (cin >> n >> m, n) {\n        solve(n, m);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nconst int offsetX = 30;\nconst int offsetY = 30;\n\nconst int fieldObstacle = -1;\nconst int fieldNothing = 0;\nconst int fieldWalked = 1;\n\nstruct Point {\n\tint x, y;\n\tint t;\n\tPoint(int x, int y, int t) : x(x), y(y), t(t) {}\n};\n\nclass Answer {\n\tint m_m;\n\tstd::vector< std::vector<int> > m_field;\n\tint m_w, m_h;\npublic:\n\tAnswer(int w, int h) :\n\t\tm_m(0),\n\t\tm_field(h, std::vector<int>(w, fieldNothing)),\n\t\tm_w(w),\n\t\tm_h(h)\n\t{\n\t}\n\tint num() const\n\t{\n\t\treturn m_m;\n\t}\n\tvoid addObstacle(int x, int y)\t// ツ閉崢催ャツ用\n\t{\n\t\tm_field[y][x] = fieldObstacle;\n\t}\n\tvoid calc(int t, int x, int y);\t// ツ閉崢催ャツ用\n\tbool walkable(int x, int y, int t) const\n\t{\n\t\treturn t >= 0 && x >= 0 && x < m_w && y >= 0 && y < m_h && m_field[y][x] == fieldNothing;\n\t}\n\tvoid pushIfWalkable(std::queue< Point > *q, int x, int y, int t) const\n\t{\n\t\tif (walkable(x, y, t)) {\n\t\t\tq->push(Point(x, y, t));\n\t\t}\n\t}\n};\n\nvoid Answer::calc(int t, int x, int y)\n{\n\tstd::queue< Point > q;\n\tpushIfWalkable(&q, x, y, t);\n\twhile (!q.empty()) {\n\t\tPoint p = q.front(); q.pop();\n\t\tint x = p.x, y = p.y;\n\t\tif (m_field[y][x] == fieldNothing) {\n\t\t\t++m_m;\n\t\t\tm_field[y][x] = fieldWalked;\n\t\t}\n\t\tint t = p.t - 1;\n\t\tpushIfWalkable(&q, x + 1, y, t);\n\t\tpushIfWalkable(&q, x + 1, y + 1, t);\n\t\tpushIfWalkable(&q, x, y + 1, t);\n\t\tpushIfWalkable(&q, x - 1, y, t);\n\t\tpushIfWalkable(&q, x - 1, y - 1, t);\n\t\tpushIfWalkable(&q, x, y - 1, t);\n\t}\n}\n\nint main()\n{\n\tint t, n;\n\twhile (std::cin >> t >> n, t != 0 || n != 0) {\n\t\tAnswer answer(2 * offsetY + 1, 2 * offsetX + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\t// ツ湘。ツ害ツ閉ィ\n\t\t\tstd::cin >> x >> y;\n\t\t\tanswer.addObstacle(x + offsetX, y + offsetY);\t// ツ閉崢催ャツ用\n\t\t}\n\t\tint x, y;\t// ツスツタツーツトツ暗環置\n\t\tstd::cin >> x >> y;\n\t\tanswer.calc(t, x + offsetX, y + offsetY);\t// ツ閉崢催ャツ用\n\t\tstd::cout << answer.num() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MIN (-1000)\n#define MAX 10000\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint cd;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 1, 1, 0, -1, -1, 0 };\n\tint dy[] = { 0, 1, 1, 0, -1, -1 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[60 + 1][60 + 1];\n\t\tfor (int i = 0; i < 60 + 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 60 + 1; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 30][p.first + 30] = MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 30;\n\t\tfirst.cy = startY + 30;\n\t\tfirst.cd = 0;\n\t\tq.push(first);\n\t\tmap[startY + 30][startX + 30] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tint cd = d.cd;\n\t\t\tif (t <= cd)continue;\n\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (t <= cd)continue;\n\t\t\t\tif (nx < 0 || nx >= 61 || ny < 0 || ny >= 61)continue;\n\t\t\t\tif (map[ny][nx] == MIN)continue;\n\t\t\t\tint pre = map[ny][nx];\n\t\t\t\tmap[ny][nx] = min(map[ny][nx], cd + 1);\n\t\t\t\tif (map[ny][nx] == pre)continue;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.cd = cd + 1;\n\t\t\t\tq.push(next);\n\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 60 + 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 60 + 1; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != MIN && map[i][j] != MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[100][100];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif((k<0) || (a[p.real()+50][p.imag()+50] == -2)) return 0;\n\tif(a[p.real()+50][p.imag()+50] >= k) return 0;\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == -1) res++;\n\ta[p.real()+50][p.imag()+50] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tmemset(a, -1, sizeof(a));\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[100][100];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sx-data[1][i])>t){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (50-sx);\n\t\t\ttmpY += (50-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=50;\n\t\tsy=50;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define MAX 1000\n\nint dy[6]={1,1,0,-1,-1,0};\nint dx[6]={1,0,-1,-1,0,1};\n\n\nint t,n;\nbool visited[MAX][MAX];\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      visited[i][j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>t>>n;\n    if(t==0&&n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      int a,b;\n      cin>>a>>b;\n      visited[a+500][b+500]=true;\n    }\n    int ans=1,a,b;\n    cin>>a>>b;\n    queue<int> qy,qx,cnt;\n    qy.push(a+500);qx.push(b+500);cnt.push(0);\n    visited[a+500][b+500]=true;\n    while(!qy.empty()){\n      int y=qy.front();qy.pop();\n      int x=qx.front();qx.pop();\n      int z=cnt.front();cnt.pop();\n      if(z==t)continue;\n      for(int i=0;i<6;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(visited[ny][nx])continue;\n\tvisited[ny][nx]=1;\n\tqy.push(ny);\n\tqx.push(nx);\n\tcnt.push(z+1);\n\tans++;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint map[500][500];\nint mapcnt[500][500];\nint t, n;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid search(int x, int y, int t){\n\tqueue<pair<pair<int, int>, int> > q;\n\tq.push(make_pair(make_pair(x,y),t));\n\twhile(!q.empty()){\n\t\tpair<pair<int, int>, int> p = q.front();\n\t\tq.pop();\n\t\tpair<int , int> id = p.first;\n\t\tif(map[id.first][id.second] != 0) continue;\n\t\tif(!p.second) continue;\n\t\tmap[id.first][id.second] = 1;\n\t\tfor(int i = 0; i < 6; i++){\n//printf(\"push : %d %d %d\\n\", id.first+dx[i], id.second+dy[i], p.second);\n\t\t\tif(map[id.first+dx[i]][id.second+dy[i]] != 0) continue;\n\t\t\tq.push(make_pair(make_pair(id.first+dx[i],id.second+dy[i]),p.second-1));\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x, y;\n\twhile(cin >> t >> n, t || n){\n\t\tfor(int i = 0; i < 500; i++) for(int j = 0; j < 500; j++){ mapcnt[i][j] = 0; map[i][j] = 0;}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x + 50][y + 50] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tsearch(x+50, y+50, t+1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 500; i++){\n\t\t\tfor(int j = 0; j < 500; j++){\n\t\t\t\tif(map[i][j] == 1) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\nconst double EPS = (1e-10);\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst Int MOD = 1000000007;\n\nvoid fast_input() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint solve(int T, int N) {\n    int INF = 1000000000;\n    vector<vector<int>> field(1000, vector<int>(1000));\n    for (int i = 0; i < 1000; i++) {\n        for (int j = 0; j < 1000; j++) {\n            field[i][j] = INF;\n            if (i == 0 || i == 999 || j == 0 || j == 999) {\n                field[i][j] = -1;\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        int x, y; cin >> x >> y;\n        x += 500;\n        y += 500;\n        field[x][y] = -1; \n    }\n    int startX; cin >> startX;\n    int startY; cin >> startY;\n    startX += 500;\n    startY += 500;\n    field[startX][startY] = 0;\n\n    int dx[] = {0, 1, 1, 0, -1, -1};\n    int dy[] = {1, 1, 0, -1, -1, 0};\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    while (!q.empty()) {\n        pair<int, int> crt = q.front();\n        q.pop();\n        for (int i = 0; i < 6; i++) {\n            int nx = crt.first + dx[i];\n            int ny = crt.second + dy[i];\n            if (field[nx][ny] != -1 && field[crt.first][crt.second] + 1 < field[nx][ny]) {\n                field[nx][ny] = field[crt.first][crt.second] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    int ret = 0;\n    for (int i = 0; i < 1000; i++) {\n        for (int j = 0; j < 1000; j++) {\n            if (field[i][j] <= T && 0 <= field[i][j]) ret++;\n        }\n    }\n    return ret;\n} \n\nint main(void) {\n    int T, N;\n    vector<int> ans;\n    while (1) {\n        cin >> T >> N;\n        if (!T && !N) break;\n        ans.push_back(solve(T, N));\n    }\n    for (auto i : ans) {\n        cout << i << endl;\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint field[100][100];\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tqueue<int> point_x;\n\t\tqueue<int> point_y;\n\t\tpoint_x.push(s_x+50);\n\t\tpoint_y.push(s_y+50);\n\t\tint sum = 0;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point_x.empty()){break;}\n\t\t\tint r = point_x.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tint p_x = point_x.front(), p_y = point_y.front();\n\t\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] != -1){point_x.push(p_x-1);point_y.push(p_y);}}\n\t\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] != -1){point_x.push(p_x);point_y.push(p_y-1);}}\n\t\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] != -1){point_x.push(p_x+1);point_y.push(p_y);}}\n\t\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] != -1){point_x.push(p_x);point_y.push(p_y+1);}}\n\t\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] != -1){point_x.push(p_x-1);point_y.push(p_y-1);}}\n\t\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] != -1){point_x.push(p_x+1);point_y.push(p_y+1);}}\n\t\t\t\t}\n\t\t\t\tpoint_x.pop();\n\t\t\t\tpoint_y.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint mas[61][61];\nint used[61][61];\n\nint dx[] = { 1, 1, 0, -1, -1, 0 }, dy[] = { 1, 0, -1, -1, 0, 1 };\n\nint rec(int t, int x, int y) {\n    if(t == 0) {\n        int ret = !used[y][x];\n        used[y][x]++;\n        return ret;\n    }\n\n    int ret = !used[y][x];\n    used[y][x]++;\n    for(int i = 0; i < 6; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(!mas[ny][nx]) {\n            ret += rec(t - 1, nx, ny);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, t;\n    while(cin >> t >> n, t) {\n        memset(mas, 0, sizeof(mas));\n        memset(used, 0, sizeof(used));\n        for(int i = 0; i < n; i++) {\n            int x, y; cin >> x >> y;\n            mas[y + 30][x + 30] = 1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        cout << rec(t, sx + 30, sy + 30) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint dx[6] = {1,1,0,-1,-1,0}, dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n\tint t,n;\n\twhile(scanf(\"%d%d\", &t, &n),t||n){\n\t\tint deta[100][100];\n\t\tint cost[100][100];\n\t\trep(i,100) rep(j,100) deta[i][j] = 0;\n\t\trep(i,100) rep(j,100) cost[i][j] = INF;\n\t\trep(i,n){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tx += 50; y += 50;\n\t\t\tdeta[x][y] = 1;\n\t\t}\n\t\tif(t == 0){\n\t\t\tcout << \"1\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint sx, sy;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tsx += 50; sy += 50;\n\t\tdeta[sx][sy] = 2;\n\t\tcost[sx][sy] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(sx,sy));\n\t\twhile(que.size() != 0){\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(i,6){\n\t\t\t\tP tmp = p;\n\t\t\t\ttmp.fi += dx[i];\n\t\t\t\ttmp.sec += dy[i];\n\t\t\t\tif(deta[tmp.fi][tmp.sec] == 0 && cost[tmp.fi][tmp.sec] > cost[p.fi][p.sec]+1){\n\t\t\t\t\tdeta[tmp.fi][tmp.sec] = 2;\n\t\t\t\t\tcost[tmp.fi][tmp.sec] = cost[p.fi][p.sec]+1;\n\t\t\t\t\tif(cost[tmp.fi][tmp.sec] != t) que.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i,100) rep(j,100){\n\t\t\tif(deta[i][j] == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\nint a[100][100];\nint vis[1000][1000];\nint dx[]={0,-1,-1,0,1,1};\nint dy[]={1,0,-1,-1,0,1};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,1000){\n\t\t\trep(j,1000){\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta[x+500][y+500]=1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint ans=0;\n\t\tsx+=500;\n\t\tsy+=500;\n\t\tqueue<pii> q;\n\t\tq.push(mkp(sx,sy));\n\t\ta[sx][sy]=1;\n\t\tans++;\n\t\trep(i,t){\n\t\t\tint qs=q.size();\n\t\t\trep(j,qs){\n\t\t\t\tpii top=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(l,6){\n\t\t\t\t\tint xx=top.F+dx[l];\n\t\t\t\t\tint yy=top.S+dy[l];\n\t\t\t\t\tif(a[xx][yy]==0){\n\t\t\t\t\t\tq.push(mkp(xx,yy));\n\t\t\t\t\t\ta[xx][yy]=1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\n#define SZ 70\n\nbool visited[SZ*2+5][SZ*2+5];\n\nbool isin(int x, int y){\n    if((x-SZ)*(y-SZ)>=0) return x>=0 && x<=SZ*2 && y>=0 && y<=SZ*2;\n    else return abs(x-SZ)+abs(y-SZ)<=SZ;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[SZ*2+5], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+SZ][y+SZ]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+SZ, sy+SZ), 0));\n        visited[sx+SZ][sy+SZ]=true;\n        int res=1;\n        while (!q.empty()){\n            const int dx[] = {1,1,0,-1,-1,0};\n            const int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second==t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n//                    cout<<nx-SZ<<\",\"<<ny-SZ<<endl;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <typeinfo>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nvoid reach(int a[][61],int b)//b回目のリーチで行ける場所をb+1に塗りつぶす\n{\n\tint x[6]={-1,-1,0,1,0,1};\n\tint y[6]={-1,0,-1,0,1,1};\n\t\n\tfor(int i=0;i<61;i++)\n\t{\n\t\tfor(int j=0;j<61;j++)\n\t\t{\n\t\t\tif(a[i][j]==b)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<6;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i+x[k]>-1 && i+x[k]<61 && j+y[k]>-1 && j+y[k]<61)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+x[k]][j+y[k]]==0)a[i+x[k]][j+y[k]]=b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\tint t,n;\n\twhile(cin>>t>>n&&!(n==0&&t==0))\n\t{\n\t\tint a[61][61]={};//座標は0~60\n\t\tREP(i,n){int x,y;cin>>x>>y;a[x+30][y+30]=100;} //a[x][y]=100なら障害物あり\n\t\tint x,y;cin>>x>>y;a[x+30][y+30]=1;//便宜所スタート地点は1にする。nターン目に行ける場所をn+1で塗りつぶす\n\t\tREP(i,t) reach(a,i+1);\n\t\tint ans(0);\n\t\tREP(i,61)REP(j,61)if(a[i][j]!=0&&a[i][j]!=100)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define FIELDSIZE 200\n#define INF 10000\n\nint field[FIELDSIZE][FIELDSIZE];\nint offset = 100;\n\nstruct tile{\n    int x, y;\n    int turn;\n    tile(int x, int y, int turn) : x(x), y(y), turn(turn) {};\n};\n\nvoid init() {\n    for (int i = 0; i < FIELDSIZE; i++) {\n        for (int j = 0; j < FIELDSIZE; j++) {\n            field[i][j] = -1;\n        }\n    }\n//    field[0+offset][0+offset] = 0;\n    field[-31+offset][0+offset] = INF;\n    field[31+offset][0+offset] = INF;\n    field[0+offset][31+offset] = INF;\n    field[0+offset][-31+offset] = INF;\n    field[31+offset][31+offset] = INF;\n    field[-31+offset][-31+offset] = INF;\n}\n\n//int count = 0;\n//void visit(int x, int y, int turn) {\n//    if (field[x+offset][y+offset] == INF) {\n//        return;\n//    }\n//    if (field[x+offset][y+offset] == -1) {\n//        field[x+offset][y+offset] = turn;\n//        count++;\n//    }\n//\n//    visit(x+1, y, turn+1);\n//    visit(x-1, y, turn+1);\n//    visit(x, y+1, turn+1);\n//    visit(x, y-1, turn+1);\n//    visit(x+1, y+1, turn+1);\n//    visit(x-1, y-1, turn+1);\n//}\n\n\nint main() {\n    int last_t, n;\n\n    while (cin >> last_t >> n) {\n        if (last_t == 0 && n == 0) break;\n        init();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            field[x+offset][y+offset] = INF;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        queue<tile> q;\n        q.push(tile(start_x, start_y, 0));\n        field[start_x+offset][start_y+offset] = 0;\n        while (!q.empty()) {\n            tile t = q.front(); q.pop();\n//            cout << q.size() << endl;\n//            field[t.x+offset][t.y+offset] = t.turn;\n            //cout << t.x << endl;\n\n            if (t.turn == last_t) {\n                continue;\n            }\n\n            if (field[t.x+1+offset][t.y+offset] == -1) {\n                field[t.x+1+offset][t.y+offset] = t.turn+1;\n                q.push(tile(t.x+1, t.y, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y+offset] == -1) {\n                field[t.x-1+offset][t.y+offset] = t.turn+1;\n                q.push(tile(t.x-1, t.y, t.turn+1));\n            }\n            if (field[t.x+offset][t.y+1+offset] == -1) {\n                field[t.x+offset][t.y+1+offset] = t.turn+1;\n                q.push(tile(t.x, t.y+1, t.turn+1));\n            }\n            if (field[t.x+offset][t.y-1+offset] == -1) {\n                field[t.x+offset][t.y-1+offset] = t.turn+1;\n                q.push(tile(t.x, t.y-1, t.turn+1));\n            } \n            if (field[t.x+1+offset][t.y+1+offset] == -1) {\n                field[t.x+1+offset][t.y+1+offset] = t.turn+1;\n                q.push(tile(t.x+1, t.y+1, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y-1+offset] == -1) {\n                field[t.x-1+offset][t.y-1+offset] = t.turn+1;\n                q.push(tile(t.x-1, t.y-1, t.turn+1));\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < FIELDSIZE; i++) {\n            for (int j = 0; j < FIELDSIZE; j++) {\n                if (field[i][j] != -1 && field[i][j] != INF) {\n                    count++;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<pair<int, int>,int> pxyi;\ntypedef pair<int,int> pii;\n\nvector<pii> N;\nset <pii> s;\nconst int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {0, 1, 1, 0, -1, -1};\n  \nvoid bfs(int sx, int sy, int st)\n{\n  queue<pxyi> q;\n  q.push(pxyi(make_pair(sx,sy),st));\n  while(!q.empty()){\n    int x, y, t;\n    x = q.front().first.first;\n    y = q.front().first.second;\n    t = q.front().second;\n    q.pop();\n    s.insert(make_pair(x,y));\n    if(t == 0){\n      if(q.empty()) break;\n      else continue;\n    }\n    bool flag;\n    for(int i = 0; i < 6; i++){\n      flag = false;\n      int next_x = x + dx[i], next_y = y + dy[i];\n      for(int j = 0; j < (int)N.size(); j++){\n        if(N[j].first == next_x && N[j].second == next_y)\n          flag = true;\n      }\n      if(flag) continue;\n      q.push(pxyi(make_pair(next_x,next_y),t-1));\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    s.clear();\n    N.clear();\n    int t, n;\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      N.push_back(pii(x,y));\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    bfs(start_x,start_y,t);\n    cout << s.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <memory.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n//int o[500][500];\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[500][500];\n  int count = 0;\n\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n\n  for(int i = 0; i < n; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define ini 31\nusing namespace std ;\n\ntypedef pair<int,int> P ;\n\nqueue<P> q ;\nint dx[] = {0,1,1,0,-1,-1} ;\nint dy[] = {1,1,0,-1,-1,0} ;\n\nint main(){\n\t\n\tint t , n ;\n\tint x , y ;\n\tint ans ;\n\tint field[62][62] ;\n\t\n\twhile( cin >> t >> n , t ){\n\t\tfor( int i=0 ; i<62 ; i++ ){\n\t\t\tfor( int j=0 ; j<62 ; j++ ){\n\t\t\t\tif( i==0 || i==61 || j==0 || j==61 ) field[i][j] = -1 ;\n\t\t\t\telse field[i][j] = 0 ;\n\t\t\t}\n\t\t}ans = 1 ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> x >> y ;\n\t\t\tfield[y+ini][x+ini]  = -1 ;\n\t\t}cin >> x >> y ;\n\t\t\n\t\tq.push( P(x+ini,y+ini) ) ;\n\t\tfield[y+ini][x+ini] = 1 ;\n\t\t\n\t\tint j=0 , k=0 ;\n\t\twhile( !q.empty() ){\n\t\t\tx = q.front().first ;\n\t\t\ty = q.front().second ;\n\t\t\t//cout << \"OK\" << endl ;//--------------------\n\t\t\tif( field[y][x] > t ) break ;\n\t\t\tfor( int i=0 ; i<6 && field[y][x] <= t ; i++ ){\n\t\t\t\tif( field[y+dy[i]][x+dx[i]] == 0 ){\n\t\t\t\t\tfield[y+dy[i]][x+dx[i]] = field[y][x]+1 ;\n\t\t\t\t\tq.push( P(x+dx[i],y+dy[i]) ) ;\n\t\t\t\t\t//cout<<\"# \"<<x-ini<<\" \"<<y-ini<<endl;\n\t\t\t\t\tans++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop() ;\n\t\t}\n\t\t\n\t\tcout << ans << endl ;\n\t\t\n\t\twhile( !q.empty()  ){\n\t\t\tq.pop() ;\n\t\t}\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nbool isrange(int x,int y)\n{\n\treturn -30<=x && x<=30 && -30<=y && y<=30;\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t || n){\n\t\tvector<vector<int> > ob(61,vector<int>(61,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tob[x+30][y+30]=1;\n\t\t}\n\t\tpair<int,int> s;\n\t\tcin>>s.first>>s.second;\n\t\tqueue<pair<pair<int,int>, int> > q;\n\t\tvector<vector<int> > been(61,vector<int>(61,0));\n\t\tbeen[s.first+30][s.second+30]=1;\n\t\tq.push(make_pair(s,0));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front().first;\n\t\t\tint turn=q.front().second;\n\t\t\tq.pop();\n\t\t\tif(turn==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint tx=p.first+dx[i];\n\t\t\t\tint ty=p.second+dy[i];\n\t\t\t\tif(isrange(tx,ty) && !ob[tx+30][ty+30] && !been[tx+30][ty+30]){\n\t\t\t\t\tbeen[tx+30][ty+30]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(tx,ty),turn+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint cnt=0;\t\t\n\t\tfor(int i=0;i<61;i++){\n\t\t\tfor(int j=0;j<61;j++)\n\t\t\t\tif(been[i][j])\n\t\t\t\t\tcnt++;\n\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int MID = 65;\nconst int INF = 1 << 28;\nint dx[] = { 0, 1, 1, 0, -1, -1 }, dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid dfs ( int x, int y, int t, VVI& m )\n{\n\tif ( !t || m[y][x] == -1 ) {\n\t\treturn;\n\t}\n\tfor ( int d = 0; d < 6 ; ++d ) {\n\t\tint nx = x + dx[d],\n\t\t\tny = y + dy[d];\n\t\tif ( m[ny][nx] > m[y][x] + 1 ) {\n\t\t\tm[ny][nx] = m[y][x] + 1;\n\t\t\tdfs( nx, ny, t - 1, m );\n\t\t}\n\t}\n}\n\nint main() {\n\tint t, n;\n\twhile ( cin >> t >> n, t | n ) {\n\t\tVVI m( 2 * MID, VI( 2 * MID, INF ) );\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tm[y + MID][x + MID] = -1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\t\n\t\tm[sy + MID][sx + MID] = 0;\n\t\tdfs( sx + MID, sy + MID, t, m );\n\t\t\n\t\tint ans = 0;\n\t\tfor ( int y = 0; y < 2 * MID; ++y ) {\n\t\t\tfor ( int x = 0; x < 2 * MID; ++x ) {\n\t\t\t\tint val = m[y][x];\n\t\t\t\tans += 0 <= val && val <= t;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <complex>\n#include <queue>\nusing namespace std;\n#define P pair<int, int>\n#define PP pair<int, P>\n#define mp(a, b) make_pair(a, b)\n\nint main() {\n  int t, n;\n  while (cin >> t >> n, t|n) {\n    vector<vector<int> > f(61, vector<int>(61, 0));\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      f[x+30][y+30] = 1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    int cnt = 0;\n    queue<PP> q;\n    q.push(mp(0,mp(sx+30, sy+30)));\n    const int dx[] = {1, 1, 0,  0, -1, -1};\n    const int dy[] = {0, 1, 1, -1,  0, -1};\n\n    while (!q.empty()) {\n      int c = q.front().first;\n      P p = q.front().second;\n      q.pop();\n      if (f[p.first][p.second]) continue;\n      f[p.first][p.second] = 1;\n      cnt++;\n      for (int i = 0; i < 6; i++) {\n        int xx = p.first  + dx[i];\n        int yy = p.second + dy[i];\n        if (xx >= 0 && xx < 61 && yy >= 0 && yy < 61 && c < t) {\n          q.push(mp(c+1,mp(xx, yy)));\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    array<int, 6> di{1, 1, 0, 0, -1, -1}, dj{0, 1, -1, 1, -1, 0};\n    int t, n;\n    while(cin >> t >> n, t){\n        map<pair<int, int>, int> v, visited;\n        for (int i = 0; i < n; ++i) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            v[{b, a}] = 1;\n        }\n        int x, y;\n        cin >> x >> y;\n        queue<pair<int, int>> q;\n        q.emplace(y, x);\n        int ans = 0;\n        v[{y, x}] = 0;\n        while(!q.empty()){\n            int a, b; tie(a, b) = q.front(); q.pop();\n            visited[{a, b}] = 1;\n            if(v[{a, b}] == t) continue;\n            for (int k = 0; k < 6; ++k) {\n                if(!v.count({a+di[k], b+dj[k]}) && !visited.count({a+di[k], b+dj[k]})){\n                    v[{a+di[k], b+dj[k]}] = v[{a, b}]+1;\n                    ans++;\n                    q.emplace(a+di[k], b+dj[k]);\n                }\n            }\n        }\n        cout << ans+1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nvoid wfs(array<array<int32_t, 100>, 100> &hex, int32_t x, int32_t y) {\n  queue<pair<int32_t, int32_t>> q;\n\n  hex[x][y] = 0;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> p = q.front();\n    int32_t x = p.first;\n    int32_t y = p.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vecs{{0, 1}, {1, 1},   {-1, 0},\n                                        {1, 0}, {-1, -1}, {0, -1}};\n    for (uint32_t i = 0; i < vecs.size(); i++) {\n      int32_t posx = x + vecs[i].first;\n      int32_t posy = y + vecs[i].second;\n      if (0 <= posx && posx < 100 && 0 <= posy && posy < 100 &&\n          hex[posx][posy] == INT32_MAX) {\n        hex[posx][posy] = hex[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main() {\n  while (true) {\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    array<array<int32_t, 100>, 100> hex;\n    for (uint32_t i = 0; i < hex.size(); i++) {\n      for (uint32_t j = 0; j < hex[0].size(); j++) {\n        hex[i][j] = INT32_MAX;\n      }\n    }\n\n    for (uint32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 50][y + 50] = -1;\n    }\n    int32_t x, y;\n    cin >> x >> y;\n\n    wfs(hex, x + 50, y + 50);\n\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < hex.size(); i++) {\n      for (uint32_t j = 0; j < hex[0].size(); j++) {\n        if (0 <= hex[i][j] && hex[i][j] <= t) {\n          count++;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\n\n// s[y][x] := ツ鳴「ツ探ツ催オツづ個づ?つォINF, ツ探ツ催オツ催渉づ敖づ個づ?つォツタツーツδ督青板つェツ禿シツづゥ\nint s[200][200];\n// b[P(x,y)] := ツ津環づェツづ按つ「ツづ?つォtrue\nint b[200][200];\n\nint bfs(int sx , int sy , int t ){\n\ts[sy][sx] = 0;\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tint cnt = s[y][x];\n\t\tq.pop();\n\t\t\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\t// if( mx < 0 || my < 0 || mx > 60 || my > 60 ) continue;\n\t\t\tif( b[my][mx] ) continue;\n\t\t\t \n\t\t\tif( cnt + 1 <= t && s[my][mx] == INF ){\n\t\t\t\ts[my][mx] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint result = 0;\n\tfor(int y=0 ; y < 200 ; y++ ){\n\t\tfor(int x = 0 ; x < 200 ; x++ ){\n\t\t\tif( s[y][x] != INF ){\n\t\t\t\tresult++;\n\t\t\t} \n\t\t}\n\t}\n\tif( result == 0 ) result = 1;\n\treturn result;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\t\n\t\tfor(int y = 0 ; y < 200 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 200 ; x++ ){\n\t\t\t\ts[y][x] = INF;\n\t\t\t\tb[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 100;\n\t\t\ty += 100;\n\t\t\tb[y][x] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = bfs( sx+100 , sy+100 , t );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint panel[121][121];\nint dd[] = {0, 1, 1, 0, -1, -1, 0};\n\nvoid wfs(int x, int y, int t) {\n  priority_queue<PIP> q;\n  q.push(PIP(t, P(x, y)));\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    if (panel[p.se.se][p.se.fi] == 1) continue;\n    else panel[p.se.se][p.se.fi] = 1;\n\n    if (p.fi == 0) continue;\n    rep(i, 6) {\n      int yy = p.se.se + dd[i], xx = p.se.fi + dd[i + 1];\n      if (panel[yy][xx] == 0) q.push(PIP(p.fi - 1, P(xx, yy)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t, n;\n  while(cin >> t >> n, t | n) {\n    rep(i, 121)rep(j, 121) panel[i][j] = 0;\n\n    rep(i, n) {\n      int x, y;\n      cin >> x >> y; x += 60, y += 60;\n      if (0 <= x && x < 121 && 0 <= y && y < 121) panel[y][x] = 2;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    wfs(x + 60, y + 60, t);\n\n    int ans = 0;\n    rep(i, 121)rep(j, 121) if (panel[i][j] == 1) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, k, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k;\n\t\tif (n == 0 && k == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\ty[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (x[j][k] == 0 && y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (x[dx[l] + j][dy[l] + k] == 0) {\n\t\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= n) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nbool map[100][100];\nbool cnt[100][100];\n\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\n\nvoid check(int x,int y, int t)\n{\n  //cout<<x<<\" \"<<y<<endl;\n  cnt[x][y]=true;\n  if(t<=0)\n    return;\n  map[x][y]=false;\n  for(int i=0;i<6;i++)\n    {\n      if(map[x+dx[i]][y+dy[i]] && x+dx[i]-50<=30 && y+dy[i]-50<=30 && x+dx[i]-50>=-30 && y+dy[i]-50>=-30)\n\tcheck(x+dx[i],y+dy[i],t-1);\n    }\n}\n\nint main()\n{\n  int t,n;\n  for(;cin>>t>>n,t;)\n    {\n      memset(map,true,sizeof(map));\n      memset(cnt,false,sizeof(cnt));\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin>>x>>y;\t \n\t  x+=50;\n\t  y+=50;\n\t  map[x][y]=false;\n\t}\n      int x,y;\n      cin>>x>>y;\n      x+=50;\n      y+=50;\n      check(x,y,t);\n      int ans=0;\n      for(int i=0;i<100;i++)\n\tfor(int j=0;j<100;j++)\n\t  if(cnt[i][j])\n\t    ans++;\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint t, n;\n\tint DX[6] = { 0,1,1,0,-1,-1 }, DY[6] = { 1,1,0,-1,-1,0 };\n\twhile (cin >> t >> n&&t)\n\t{\n\t\tint z = 50;\n\t\tint a[100][100];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ta[x+z][y+z] = -2;\n\t\t}\n\t\tpii st;\n\t\tcin >> st.first >> st.second;\n\t\tst.first += z;\n\t\tst.second += z;\n\t\ta[st.first][st.second] = t;\n\t\tqueue<pii> que;\n\t\tque.push(st);\n\t\tint ans = 1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front();\n\t\t\tque.pop();\n\t\t\tif (a[now.first][now.second] == 0)continue;\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += DX[i];\n\t\t\t\tnext.second += DY[i];\n\t\t\t\tif (a[next.first][next.second] != -2&&a[next.first][next.second]<a[now.first][now.second]-1)\n\t\t\t\t{\n\t\t\t\t\tif (a[next.first][next.second] !=-1)ans--;\n\t\t\t\t\ta[next.first][next.second] = a[now.first][now.second] - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n\nvoid dfs(int x,int y,int turn,vvi &ob,vvi &iscan);\nint t;\n\nint main(){\n    int n;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        dfs(x+30,y+30,0,ob,iscan);\n        int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                cnt++; \n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n\n}\nvoid dfs(int x,int y,int turn,vvi &ob,vvi &iscan){\n    iscan[x][y]=1;\n    if(turn>=t)\n        return;\n    REP(i,6){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(isRange(nx,ny)&&!ob[nx][ny])\n            dfs(nx,ny,turn+1,ob,iscan);\n    }\n    return;\n\n\n\n}\n              "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pxy;\n\nconst int dx[]={0,-1,-1,0,1,1}; const int dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n  int t,n,ox,oy,sx,sy,x,y;\n\n  for(;;){\n    cin>>t>>n;\n    if(!(t|n)) break;\n    int map[200][200]={};\n    for(int i=0;i<n;i++){\n      cin>>ox>>oy;\n      map[ox+100][oy+100]=1;\n    }\n    cin>>sx>>sy;\n\n    int count=1;\n    queue<pxy> q;\n    \n    q.push(pxy(sx+100,sy+100));\n    map[q.front().first][q.front().second]=1;\n    while(!q.empty()){\n      x=q.front().first; y=q.front().second;\n      q.pop();\n      for(int i=0;i<6;i++){\n\tint next_x=x+dx[i],next_y=y+dy[i];\n\tif(map[next_x][next_y]) continue;\n\tmap[next_x][next_y]=map[x][y]+1;\n\tcount++;\n\tif(map[x][y]<t)\n\t  q.push(pxy(next_x,next_y));\n      }\n    }\n    cout<<count<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ?????¬???????????¬??????\n#pragma region MACRO\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define PED cout << \"\\n\"\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n#define REP(i,x,n) for(int i=x; i<(int)n; ++i)\n#define repi(i,n) for(int i=0; i<=(int)n; ++i)\n#define REPI(i,x,n) for(int i=x; i<=(int)n; ++i)\n#define ILP while(true)\n#define FOR(i,c) for(__typeof((c).begin())!=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#pragma endregion\n\n// ???\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pss;\ntypedef pair<string, int> psi;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long double> vld;\ntypedef vector<long> vl;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\n#pragma endregion\n\n// Effective std\n#pragma region ESTD\ntemplate<typename C, typename T> int count(C& c, T t) { return count(ALL(c), t); }\ntemplate<typename C, typename F> int count_if(C& c, F f) { return count_if(ALL(c), f); }\ntemplate<typename C, typename T> void erase(C& c, T t) { remove(ALL(c), t), c.end(); }\ntemplate<typename C> void remove(vector<C>& c, unsigned int index) { c.erase(c.begin()+index); }\ntemplate<typename C, typename T, typename U> void replace(C& c, T t, U u) { replace(ALL(c), t, u); }\ntemplate<typename C, typename F, typename U> void replace_if(C& c, F f, U u) { (ALL(c), f, u); }\ntemplate<typename C> void reverse(C& c) { reverse(ALL(c)); }\ntemplate<typename C> void sort(C& c) { sort(ALL(c)); }\ntemplate<typename C, typename Pred> void sort(C& c, Pred p) { sort(ALL(c), p); }\n#pragma endregion\n\n// ?????°\n#pragma region CONST_VAL\nconstexpr int PI = (2*acos(0.0));\nconstexpr int EPS = (1e-9);\nconstexpr int MOD = (int)(1e9+7);\nconstexpr int INF = 100000000;\n#pragma endregion\n\n#define int long long\n\nconst int MAX = 100;\nchar flag[MAX*2][MAX*2];\n\nsigned main()\n{\n    while(true) {\n        int t, n;\n        cin >> t >> n;\n        if(t==0&&n==0) break;\n        fill(flag[0], flag[MAX*2-1]+MAX*2, 0);\n        for(int i=0; i<n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            flag[y+MAX][x+MAX] = 1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n\n        queue<pair<pair<int,int>, int> > q;\n        q.push(make_pair(pair<int, int>(sx,sy),0));\n        int c = 0;\n        while(!q.empty()) {\n            pair<pair<int, int>, int> p = q.front();\n            pair<int, int> a = p.first;\n            int step = p.second;\n            q.pop();\n\n            if(flag[a.second+MAX][a.first+MAX]) continue;\n            flag[a.second+MAX][a.first+MAX] = 1;\n            c++;\n            if(step<t) {\n                q.push(make_pair(pair<int,int>(a.first+1,a.second),step+1));\n                q.push(make_pair(pair<int,int>(a.first-1,a.second),step+1));\n                q.push(make_pair(pair<int,int>(a.first,a.second+1),step+1));\n                q.push(make_pair(pair<int,int>(a.first,a.second-1),step+1));\n                q.push(make_pair(pair<int,int>(a.first+1,a.second+1),step+1));\n                q.push(make_pair(pair<int,int>(a.first-1,a.second-1),step+1));\n            }\n        }\n        cout << c << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define MAX 129\n#define MAR (MAX-1) / 2\n#define INF 128\n\nint main()\n{\n\tconst int dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\twhile(1) {\n\t\tbool is_wall[MAX][MAX] = {false};\n\t\tint d[MAX][MAX] = {0};\n\t\tqueue<P> que;\n\t\tint t, n;\n\t\tint px, py;\n\t\tint ans = 0;\n\t\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &t, &n);\n\t\tif(!t && !n) break;\n\t\twhile(n--) {\n\t\t\tint wx, wy;\n\t\t\tscanf(\"%d %d\", &wx, &wy);\n\t\t\tis_wall[wx+MAR][wy+MAR] = true;\n\t\t}\n\t\tscanf(\"%d %d\", &px, &py);\n\t\tque.push(P(px, py));\n\t\td[px+MAR][py+MAR] = 0;\n\t\twhile(!que.empty()) {\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(d[x+MAR][y+MAR] == t) continue;\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif(-MAR <= xx && xx <= MAR && -MAR <= yy && yy <= MAR && !is_wall[xx+MAR][yy+MAR] ) {\n\t\t\t\t\tif(d[xx+MAR][yy+MAR] > d[x+MAR][y+MAR] + 1) {\n\t\t\t\t\t\td[xx+MAR][yy+MAR] = d[x+MAR][y+MAR] + 1;\n\t\t\t\t\t\tque.push(P(xx, yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(d[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Brave Force Story\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair< pair<int, int>, int> Q;\n#define INF -1\nint dx[6]={1, 1, 0, -1, -1, 0}, dy[6]={1, 0, -1, -1, 0, 1};\nint mp[121][121];//+60\nint d[121][121]; //+30\n\nQ make_Q(int x, int y, int z){\n  Q ret;\n  ret.first.first=x;\n  ret.first.second=y;\n  ret.second=z;\n  return ret;\n}\n\nint main(){\n  int t, n;\n  while(cin>>t>>n, !(t==0&&n==0)){\n    memset(mp, 0, sizeof(mp));\n    for(int i=0; i<121; i++)\n      for(int j=0; j<121; j++)\n\td[i][j]=INF;\n    while(n--){\n      int tmp_x, tmp_y;\n      cin>>tmp_x>>tmp_y;\n      mp[tmp_x+60][tmp_y+60]=INF;\n    }\n    int sx, sy;\n    cin>>sx>>sy;\n    d[sx+60][sy+60]=0;\n    queue<Q> q;\n    q.push(make_Q(sx+60, sy+60, t));\n    while(!q.empty()){\n      Q now=q.front(); q.pop();\n      if(now.second==0)break;\n      for(int i=0; i<6; i++){\n\tint nx=now.first.first+dx[i], ny=now.first.second+dy[i];\n\tif(0<=nx && nx<121 && 0<=ny && ny<121 && mp[nx][ny]!=INF && d[nx][ny]==INF){\n\t  q.push(make_Q(nx, ny, now.second-1));\n\t  d[nx][ny]=d[now.first.first][now.first.second]+1;\n\t}\n      }\n    }\n    int cnt=0;\n    for(int i=0; i<121; i++)\n      for(int j=0; j<121; j++)\n\tif(d[i][j]!=INF)cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\n\nvoid bfs(int y,int x,int et){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    int t = 1;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=t;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t>et) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t+1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nconst int N = 80;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (a.first < 0 || N <= a.first || a.second < 0 || N <= a.second)continue;\n\n\t\tint b = a.first + 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first + 1, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t}\n\n\tint ans(0);\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (0 < field[i][j] && field[i][j] < INF)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\tint x, y;\n\t\trep(i, 0, n) {\n\t\t\tcin >> x >> y;\n\t\t\tx += 40; y += 40;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += 40; sy += 40;\n\t\tfield[sx][sy] = t+1;\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 30;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t < 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) <= 30 && abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE) <= 30 && abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint T,N;\nint sx,sy;\n\nvoid solve(){\n    set<pair<int,int>> obs;\n    for(int i=0;i<N;i++){\n        int x,y;\n        cin >> x >> y;\n        obs.insert(make_pair(x,y));\n    }\n    cin >> sx >> sy;\n    obs.insert(make_pair(sx,sy));\n\n    using Node = tuple<int,int,int>;\n    using P = pair<int,int>;\n\n    map<P,bool> vis;\n    queue<Node> que;\n    vis[P(sx,sy)] = 0;\n    que.push(Node(sx,sy,0));\n    while(!que.empty()){\n        int x,y,t;\n        tie(x,y,t) = que.front();\n        que.pop();\n        if(t == T) continue;\n\n        for(int dx=-1;dx<=1;dx++){\n            for(int dy=-1;dy<=1;dy++){\n                if(dx*dy==-1 or (dx==0 and dy==0)) continue;\n                int nx = x + dx;\n                int ny = y + dy;\n                if(abs(nx) > 30 or abs(ny) > 30) continue;\n                if(obs.count(make_pair(nx,ny))) continue;\n\n                if(vis.count(P(nx,ny)) and vis[P(nx,ny)] <= t+1) continue;\n                vis[P(nx,ny)] = t+1;\n                que.push(Node(nx,ny,t+1));\n            }\n        }\n    }\n    int cnt = 0;\n    for(auto p : vis){\n        cnt++;\n        //cout << p.first << endl;\n    }\n    cout << cnt << endl;\n}\n\nint main(){\n    while(1){\n        cin >> T >> N;\n        if(T==0 and N==0) break;\n        //cout << \"OK\" << endl;\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n\nusing namespace std;\n \n#define NMAX 50\n\ntypedef map<int,bool>::value_type VT;\n\nstruct data{\n\tint x,y,turn;\n};\n\nint main(void){\n\t\n\tint t,n;\n\tint x,y;\n\tmap<int,bool> road,ok[31];\n\tstack<data> no;\n\tdata tm,da;\n\tint dx[]={1,1,0,-1,-1,0};\n\tint dy[]={0,1,1,0,-1,-1};\n\tint cnt;\n\n\tfor(int i=-31;i<=31;i++){\n\t\tfor(int j=-31;j<=31;j++){\n\t\t\troad.insert(VT(i+j*100,true));\n\t\t\tfor(int k=0;k<31;k++){\n\t\t\t\tok[k].insert(VT(i+j*100,true));\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=-30;i<=30;i++){\n\t\t\tfor(int j=-30;j<=30;j++){\n\t\t\t\troad[i+j*100]=true;\n\t\t\t\tfor(int k=0;k<31;k++){\n\t\t\t\t\tok[k][i+j*100]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-31;i<=31;i++){\n\t\t\troad[-31+i*100]=false;\n\t\t\troad[31+i*100]=false;\n\t\t\troad[i+31*100]=false;\n\t\t\troad[i-31*100]=false;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\troad[y+x*100]=false;\n\t\t}\n\t\tcin>>x>>y;\n\t\ttm.x=x,tm.y=y,tm.turn=0;\n\t\tno.push(tm);\n\t\troad[y+x*100]=false;\n\t\tcnt=1;\n\t\twhile(!no.empty()){\n\t\t\ttm=no.top();\n\t\t\tno.pop();\n\t\t\tif(tm.turn==t){\n\t\t\t\tif(ok[tm.turn][tm.y+tm.x*100]==true){\n\t\t\t\t\tok[tm.turn][tm.y+tm.x*100]=false;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==true&&ok[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n\t\t\t\t\tok[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]=false;\n\t\t\t\t\tda.x=tm.x+dx[i];\n\t\t\t\t\tda.y=tm.y+dy[i];\n\t\t\t\t\tda.turn=tm.turn+1;\n\t\t\t\t\tno.push(da);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nbool visited[61][61];\n\nvoid visit(int t, int x, int y) {\n  visited[x][y] = true;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && !visited[x-1][y]) visit(t-1, x-1, y);\n  if (y > 0 && !map[x][y-1] && !visited[x][y-1]) visit(t-1, x, y-1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && !visited[x-1][y-1]) visit(t-1, x-1, y-1);\n  if (x < 60 && !map[x+1][y] && !visited[x+1][y]) visit(t-1, x+1, y);\n  if (y < 60 && !map[x][y+1] && !visited[x][y+1]) visit(t-1, x, y+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && !visited[x+1][y+1]) visit(t-1, x+1, y+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = visited[i][j] = false;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (visited[i][j]) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  int N;\n  while(true){\n    cin >> N;\n    if(N == 0){\n      break;\n    }\n    int time[N][N+1];\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N+1; ++j){\n\tcin >> time[i][j];\n      }\n    }\n    int min_time[N][1<<N];\n    fill_n((int*) min_time, N*(1<<N), 1<<22);\n    for(int i = 0; i < N; ++i){\n      min_time[i][0] = time[i][0];\n    }\n    for(int i = 0; i < N; ++i){\n      for(int b = 0; b < (1<<N); ++b){\n\tfor(int j = 0; j < N; ++j){\n\t  int t = b |(1<<j);\n\t  min_time[i][t] = min(min_time[i][t], time[i][j+1]);\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int b = 0; b < (1<<N); ++b){\n\tcout << min_time[i][b] << \", \";\n      }\n      cout << endl;\n    }\n    */\n    int table[1<<N];\n    fill_n(table, 1<<N, 1<<22);\n    table[0] = 0;\n    for(int i = 0; i < N; ++i){\n      table[1<<i] = time[i][0];\n    }\n    for(int b = 0; b < (1<<N); ++b){\n      for(int i = 0; i < N; ++i){\n\tint t = b |(1<<i);\n\ttable[t] = min(table[t], table[b]+min_time[i][b]);\n      }\n    }\n    cout << table[(1<<N)-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\n\nconst int MAX_N = 100005;\nconst int dx[] = {1,1,0,0,-1,-1};\nconst int dy[] = {0,1,-1,1,0,-1};\n\nint t,n;\nint ans;\n\nint main()\n{\n    while(1){\n        cin >> t >> n;\n        if(t == 0){\n            break;\n        }\n        map<P,int> mp;\n        map<P,int> flag;\n        ans = 0;\n        rep(i,n){\n            int a,b;\n            cin >> a >> b;\n            mp[P(a,b)]++;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        queue<PP> que;\n        que.push(PP(P(sx,sy),1));\n        flag[P(sx,sy)]++;\n        ans++;\n        while(!que.empty()){\n            PP p = que.front();\n            que.pop();\n            rep(i,6){\n                int nx = (p.fi).fi + dx[i];\n                int ny = (p.fi).se + dy[i];\n                if(abs(nx) <= 30 && abs(ny) <= 30 && mp[P(nx,ny)] == 0 && flag[P(nx,ny)] == 0){\n                    flag[P(nx,ny)]++;\n                    ans++;\n                    if(p.se < t){\n                        que.push(PP(P(nx,ny),p.se+1));\n                    }\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\nconst int WMAX = 100, HMAX = 100;\n#define MAP(y, x) (field[(y) + 50][(x) + 50])\nlli t, n;\nint field[HMAX][WMAX];\n\nvoid dfs(int y, int x, int turn) {\n  int nor = y * y + x * x;\n  if (nor > 900 || turn <= 0 || MAP(y, x) >= turn) return;\n  MAP(y, x) = turn;\n  REP(i, 6) {\n    dfs(y + dy[i], x + dx[i], turn - 1);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n\n  while (cin >> t >> n and t) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = 0;\n    }\n    REP(i, n) {\n      int y, x;\n      cin >> x >> y;\n      MAP(y, x) = INF;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    dfs(sy, sx, t + 1);\n    int sum = 0;\n    FOR(y, -32, 32) FOR(x, -32, 32) {\n      if (MAP(y, x) > 0 and MAP(y, x) != INF) sum ++;\n    }\n    cout << sum << endl;\n/*    FOR(y, -10, 10) {\n      REP(i, 10 - y) cout << ' ';\n      FOR(x, -10, 10) {\n        if (MAP(y, x) == INF) cout << 'x';\n        else if (MAP(y, x) == 0)   cout << '.';\n        else if (y == sy and x == sx) cout << 'S';\n        else cout << 'o';\n        cout << ' ';\n      }\n      cout << endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct point {\n  int x;\n  int y;\n  int t;\n} POINT;\n\nint t, n, sx, sy, cnt;\nbool d[63][63];\nbool f[63][63];\nqueue<POINT> que;\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &t, &n);\n  if (!t && !n) return false;\n  fill(d[0], d[0] + 63 * 63, true);\n  fill(f[0], f[0] + 63 * 63, true);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &sx, &sy);\n    d[sy + 31][sx + 31] = false;\n  }\n  scanf(\"%d %d\", &sx, &sy);\n\n  while (!que.empty()) que.pop();\n\n  return true;\n}\n\nint main() {\n  POINT a, b;\n\n  while (input()) {\n    a.x = sx + 31;\n    a.y = sy + 31;\n    a.t = t + 1;\n    cnt = 0;\n    que.push(a);\n    while (!que.empty()) {\n      a = que.front();\n      que.pop();\n      //printf(\"%d %d %d\\n\", a.x, a.y, a.t);\n      if (!a.t) break;\n      if (!d[a.y][a.x] || !f[a.y][a.x]) continue;\n      f[a.y][a.x] = false;\n      cnt++;\n      \n      b.x = a.x + 1;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n    }\n    printf(\"%d\\n\", cnt);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n\n  while( cin>>t>>n && (t|n) ){\n    char d[100][100]; // 50 geta\n    for( int i=0;i<100;i++ )\n      for( int j=0;j<100;j++ )\n\td[i][j] = 0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y;\n      d[x+50][y+50] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=50; y+=50;\n\n    queue<S> q;\n    q.push( S(x,y,t+1) );\n    int dx[6] = {1,1,0,-1,-1,0};\n    int dy[6] = {1,0,-1,-1,0,1};\n    int ans=0;\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      if( s.t==0 ) continue;\n      if( d[s.x][s.y]!=0 ) continue;\n      d[s.x][s.y]=1; ans++;\n      int nt = s.t-1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( d[nx][ny]!=0 ) continue;\n\tq.push( S(nx,ny,nt) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[900][900]={};\nbool vis[900][900]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.emplace(x,y,t);\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.emplace(na,nb,c-1);\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,900)rep(j,900)cnt+=vis[i][j];\n  return cnt;\n}\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=30;y+=30;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=30;sy+=30;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MIN -1000\n#define MAX 10000\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint cd;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[60 + 1][60 + 1];\n\t\tfor (int i = 0; i < 60 + 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 60 + 1; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 30][p.first + 30] = MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 30;\n\t\tfirst.cy = startY + 30;\n\t\tfirst.cd = 0;\n\t\tq.push(first);\n\t\tmap[startY + 30][startX + 30] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tint cd = d.cd;\n\t\t\tif (t <= cd)continue;\n\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (t <= cd)continue;\n\t\t\t\tif (nx < 0 || nx >= 61 || ny < 0 || ny >= 61)continue;\n\t\t\t\tif (map[ny][nx] == MIN)continue;\n\t\t\t\tif (map[ny][nx] != MAX)continue;\n\t\t\t\tmap[ny][nx] = cd + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.cd = cd + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 60 + 1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 60 + 1; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != MIN && map[i][j] != MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+60·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_COOR 150\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 60][obsy + 60] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 60;\n\t\tstarty += 60;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<\"ans = \" <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÌ½ßÌì)\n\t\t\t\tif(endcnt[nowx][nowy] == false){\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,-1}, dy[] = {0,1,0,-1,1,-1};\n\nstruct P {\n    int x, y, depth;\n};\n\nint main() {\n    int turn, block_n;\n    while (cin >> turn >> block_n, turn|block_n) {\n        bool field[200][200] = {};\n        REP(i, block_n) {\n            int x, y;\n            cin >> x >> y;\n            x += 100;\n            y += 100;\n            field[y][x] = true;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        start_x += 100;\n        start_y += 100;\n\n        int cnt = 1;\n\n        queue<P> que;\n        que.push({start_x, start_y, 0});\n        field[start_y][start_x] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.depth == turn) continue;\n            REP(i, 6) {\n                int sx = p.x + dx[i];\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx < 200 && 0 <= sy && sy < 200) {\n                    if (!field[sy][sx]) {\n                        field[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy, p.depth+1});\n                    }\n                }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {0, 1, -1, 1, -1, 0};\nconst int dy[] = {1, 1, 0, 0, -1, -1};\nint t, n;\nint d[77][77];\nbool can[77][77];\nint x, y;\nint N = 35;\n\nint main()\n{\n  while(cin >> t >> n, t){\n    rep(i, 77) rep(j, 77) d[i][j] = 0;\n    rep(i, 77) rep(j, 77) can[i][j] = true;\n   rep(i, n){\n      cin >> x >> y;\n      can[x+N][y+N] = false;\n    }\n   cin >> x >> y;\n\n   queue<pair<pii, int> > que;\n   can[x+N][y+N] = false;\n   d[x+N][y+N] = 1;\n   que.push(mp(mp(x, y), 0));\n   while(!que.empty()){\n     pair<pii, int> here = que.front();  que.pop();\n     int hx = here.first.first;\n     int hy = here.first.second;\n     int cnt = here.second;\n     if(cnt < t) rep(k, 6){\n       int nx = hx + dx[k];\n       int ny = hy + dy[k];\n       if(!can[nx+N][ny+N]) continue;\n       d[nx+N][ny+N] = 1;\n       can[nx+N][ny+N] = false;\n       que.push(mp(mp(nx, ny), cnt + 1));\n     }\n   }\n\n   int res = 0;\n   rep(i, 77) rep(j, 77) res += d[i][j];\n\n   cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\n\nbool checkSyougai(vector<pair<int, int> > syougai, int x, int y){\n\tfor(int i = 0; i < syougai.size(); i++){\n\t\tif(syougai[i].first == x && syougai[i].second == y) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint dx[] = {-1, -1, 0, 0, 1, 1};\n\tint dy[] = {-1, 0, 1, -1, 0, 1};\n\tmap<int, map<int, bool> > field;\n\tint t, n;\n\tvector<pair<int, int> > syougai;\n\tpair<int, int> start;\n\n\twhile(cin >> t >> n && (t != 0 || n != 0)){\n\t\t//fieldの初期化\n\t\tfor(int i = -30; i <= 30; i++){\n\t\t\tfor(int j = -30; j <= 30; j++){\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\t//障害物とスタート地点の読み込み\n\t\tsyougai.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpair<int, int> tmp;\n\t\t\tcin >> tmp.X >> tmp.Y;\n\t\t\tsyougai.push_back(tmp);\n\t\t}\n\t\tcin >> start.X >> start.Y;\n\n\t\t//□■■\n\t\t//■■■\n\t\t//■■□fieldは普通の配置を想定して、こんなかんじで探索\n\t\tqueue<pair<int, int> > a;\n\t\tint count = 1;\n\t\ta.push(start);\n\t\tfield[start.Y][start.X] = true;\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tqueue<pair<int, int> > b;\n\t\t\twhile(!a.empty()){\n\t\t\t\tpair<int, int> tmp = a.front();\n\t\t\t\ta.pop();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\tif((tmp.X + dx[i] < -30 && tmp.X + dx[i] >= 30) || (tmp.Y + dy[i] < -30 && tmp.Y + dy[i] >= 30)) continue;\n\t\t\t\tif(checkSyougai(syougai, tmp.X + dx[i], tmp.Y + dy[i]) && field[tmp.Y + dy[i]][tmp.X + dx[i]] != true){\n\t\t\t\t\t\tpair<int ,int> next(tmp.X + dx[i], tmp.Y + dy[i]);\n\t\t\t\t\t\tb.push(next);\n\t\t\t\t\t\tfield[tmp.Y + dy[i]][tmp.X + dx[i]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta = b;\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {1,1,0,-1,-1,0}; const int dy[] = {1,0,-1,-1,0,1};\n\nbool table[120][120];\n\nint main() {\n    int t, n;\n\n    while(cin >> t >> n, t|n){\n        fill_n((bool *)table, 120 * 120, false);\n\n        pii s;\n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            table[y + 60][x + 60] = true;\n        }\n        int xx, yy;\n        cin >> s.first >> s.second;\n        s.first += 60;\n        s.second += 60;\n\n        queue<pii> que;\n        que.push(s);\n        que.push({500,500});\n\n        int cnt = 1;\n        while(!que.empty()){\n            pii p = que.front(); que.pop();\n            if(p.first == 500){\n                if(--t == 0){\n                    cout << cnt << endl;\n                    break;\n                }\n                que.push(p);\n                continue;\n            }\n            table[p.second][p.first] = true;\n\n            REP(i, 6){\n                int sx = p.first + dx[i];\n                int sy = p.second + dy[i];\n                if(table[sy][sx] == false){\n                    table[sy][sx] = true;\n//                        LOG(\"%d %d <- %d %d %d\\n\",sx-30, sy-30 ,p.first-30,p.second-30, t);\n                    cnt ++;\n                    que.push({sx, sy});\n                }\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nconst int sz=150;\n#define P(a) ((a)+sz/2)\nint dy[]={1,1,0,-1,-1,0},dx[]={0,1,1,0,-1,-1};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t|n){\n\t\tvvi f(sz,vi(sz));\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tf[P(y)][P(x)]=1;\n\t\t}\n\t\tpii start;\n\t\tcin>>start.second>>start.first;\n\t\tqueue<pii> q;\n\t\tvvi cost(sz,vi(sz,-1));\n\t\tq.push(start);\n\t\tcost[P(start.first)][P(start.second)]=0;\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.front();q.pop();\n\t\t\tREP(d,6){\n\t\t\t\tint y=p.first+dy[d];\n\t\t\t\tint x=p.second+dx[d];\n\t\t\t\tif(!f[P(y)][P(x)]&&cost[P(y)][P(x)]==-1){\n\t\t\t\t\tint newcost=cost[P(p.first)][P(p.second)]+1;\n\t\t\t\t\tcost[P(y)][P(x)]=newcost;\n\t\t\t\t\tif(newcost<t){\n\t\t\t\t\t\tq.push(make_pair(y,x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,sz){\n\t\t\tREP(j,sz){\n\t\t\t\tif(cost[i][j]!=-1){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n\nint t,n;\nint fie[120][120];\nbool used[120][120];\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\nint sx,sy;\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int ix,int iy,int it){\n\t\tx=ix;\n\t\ty=iy;\n\t\tt=it;\n\t}\n};\n\nint bfs(){\n\tstd::queue<data> que;\n\tmemset(used,false,sizeof(used));\n\tque.push(data(sx,sy,0));\n\tused[sx][sy]=true;\n\tint res=1;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tif(d.t==t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx=d.x+dx[i],ny=d.y+dy[i];\n\t\t\t//if(nx<5 || nx>=66 || ny<5 || ny>=66)continue;\n\t\t\tif(!used[nx][ny] && fie[nx][ny]==0){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tres++;\n\t\t\t\tque.push(data(nx,ny,d.t+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&t,&n);\n\t\tif(t+n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint bx,by;\n\t\t\tscanf(\"%d %d\",&bx,&by);\n\t\t\tbx+=60;\n\t\t\tby+=60;\n\t\t\tfie[bx][by]=-1;\n\t\t}\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx+=60,sy+=60;\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\nconst int MAX = 1000;\nconst int base=500;\n\nvoid solve(int t,int n){\n  int x,y;\n  bool d[MAX][MAX],used[MAX][MAX];\n  int dx[6]={1,1,0,-1,-1,0};\n  int dy[6]={1,0,-1,-1,-0,1};\n\n  rep(i,MAX)rep(j,MAX){\n    d[i][j]=true;\n    used[i][j]=false;\n  }\n  \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    d[a+base][b+base]=false;\n  }\n  cin>>x>>y;\n  \n  queue<pi> que;\n  que.push(mp(x,y));\n  used[x+base][y+base]=true;\n  for(int i=0;i<t;i++){\n    int size=que.size();\n    for(int j=0;j<size;j++){\n      pi dir=que.front();que.pop();\n      for(int k=0;k<6;k++){\n\tpi tmp=mp(dir.first+dx[k],dir.second+dy[k]);\n\tif(!used[tmp.first+base][tmp.second+base]&&d[tmp.first+base][tmp.second+base]){\n\t  que.push(tmp);\n\t  used[tmp.first+base][tmp.second+base]=true;\n\t}\n      }\n    }\n  }\n  int ans=0;\n  rep(i,MAX)rep(j,MAX)ans+=used[i][j];\n  cout<<ans<<endl;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0&&n==0)break;\n    solve(t,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\ntypedef pair<pii,int>piii;\nint dx[]={0,-1,1};\nint dy[]={0,-1,1}\n;int main(){\n    int t,n;\n    while(cin>>t>>n){\n        int ans=0;\n        if(t+n==0)break;\n        map<pii,int>mp;\n        pii s;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>s.first>>s.second;\n        queue<piii>que;\n        que.push(make_pair(s,0));\n        while(!que.empty()){\n            piii now=que.front();que.pop();\n            if(abs(now.first.first)>30||abs(now.first.second)>30)continue;\n            if(now.second>t)continue;\n            if(now.second>mp[now.first]&&mp[now.first]!=0)continue;\n            if(mp[now.first]==0)ans++;\n            mp[now.first]=now.second;\n            if(now.first==s)mp[s]=INF;\n            rep(i,3)rep(j,3){\n                if(dx[i]+dy[j]==0)continue;\n                pii next=pii(now.first.first+dx[i],now.first.second+dy[j]);\n                if(mp[next]==-INF)continue;\n                piii hoge;\n                hoge.first=next;\n                hoge.second=now.second+1;\n                que.push(hoge);\n                \n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint depth;\nbool field[62][62];\nll d[62][62];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    REP(i,62){\n        REP(j,62) d[i][j] = INF;\n    }\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx < 0 || 60 < nx || ny < 0 || 60 < ny || d[nx][ny] != INF || field[nx][ny] || d[p.first][p.second]+1 > depth) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        memset(field, false, sizeof(field));\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            field[x+30][y+30] = true;\n        }\n        cin >> x >> y;\n        int res = bfs(x+30,y+30);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint data[300][300]={0};\n\nbool inrange(int x,int y){\n  if(x<-100||y<-100) return false;\n  else return true;\n}\nqueue<pair<int,pair<int,int> > > q;\nint turn;\n\nint search(){\n  int res = 0;\n  while(!q.empty()){\n    int tmpturn = q.front().first;\n    pair<int,int> tmpq = q.front().second;\n    int px = tmpq.first;\n    int py = tmpq.second;\n    q.pop();\n    if(tmpturn>0){\n      REP(i,6){\n        int nx = px+dx[i];\n        int ny = py+dy[i];\n        if(inrange(nx,ny)&&(data[nx+100][ny+100]==0)){\n          res++;\n          data[nx+100][ny+100] = 1;\n          q.push(make_pair(tmpturn-1,make_pair(nx,ny)));\n        }\n      }\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  while(1){\n    cin >> turn >> n;\n    if(turn==0&&n==0) break;\n    REP(i,300) REP(j,300) data[i][j] = 0;\n    REP(i,n){\n      int tx,ty;\n      cin >> tx >> ty;\n      data[tx+100][ty+100] = -1;\n    }\n    while(!q.empty()) q.pop();\n    int sx,sy;\n    cin >> sx >> sy;\n    data[sx+100][sy+100] = 1;\n    q.push(make_pair(turn,make_pair(sx,sy)));\n    cout << search()+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > t) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            REP(i, 6){\n                if(cur.first + dy[i] >= 0 && cur.first + dy[i] <= 64 && cur.second + dx[i] >= 0 && cur.second + dx[i] <= 64){\n                    if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                        que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                        close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                        graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                    }\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        //cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 65){\n            REP(j, 65){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint t,n,x,y,T;\nbool mp[61][61];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nint bfs(){\n  queue<P> Q;\n  int cnt=0;\n  Q.push(P(0,(x+30)*61+y+30));\n  while(!Q.empty()){\n    P p=Q.front();\n    Q.pop();\n    T=p.first;\n    x=p.second/61,y=p.second%61;\n    if(mp[x][y])continue;\n    if(T==t+1)return cnt;\n    mp[x][y]=1;\n    cnt++;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(0<=nx&&nx<61&&0<=ny&&ny<61&&!mp[nx][ny])\n\tQ.push(P(T+1,nx*61+ny));\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while(cin>>t>>n&&(t||n)){\n    memset(mp,0,sizeof(mp));\n    while(n--){\n      cin>>x>>y;\n      mp[x+30][y+30]=1;\n    }\n    cin>>x>>y;\n    cout<<bfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int K = 100;\nconst int INF = 100000;\nconst int dx[] = {-1, 0, 1, 0, 1, -1};\nconst int dy[] = {0, -1, 0, 1, 1, -1};\n\nstruct STATE\n{\n\tint x, y, d;\n};\n\nbool grid[201][201];\nint done[201][201];\n\nint main()\n{\t\n\tint t, n;\n\twhile (scanf(\"%d %d\", &t, &n), t + n){\n\t\tmemset(grid, 0, sizeof(grid));\n\t\tfor (int i = 0; i <= 200; i++){\n\t\t\tfor (int j = 0; j <= 200; j++){\n\t\t\t\tdone[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tgrid[x + K][y + K] = true;\n\t\t}\n\t\t\n\t\tint sx, sy;\n\t\tscanf(\"%d %d\", &sx, &sy);\n\t\t\n\t\tqueue<STATE> que;\n\t\tque.push({sx + K, sy + K, 0});\n\t\twhile (!que.empty()){\n\t\t\tSTATE st = que.front(); que.pop();\n\t\t\tif (done[st.x][st.y] <= st.d || st.d > t) continue;\n\t\t\t\n\t\t\tdone[st.x][st.y] = st.d;\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 6; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\t\n\t\t\t\tif (done[tx][ty] > st.d + 1 && !grid[tx][ty]){\n\t\t\t\t\tque.push({tx, ty, st.d + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i <= 200; i++){\n\t\t\tfor (int j = 0; j <= 200; j++){\n\t\t\t\tcnt += done[i][j] != INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n\n//???????????????\nint di[6] = {1, 1, 0, -1, -1, 0};\nint dj[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\n    while(1){\n\n        int n, t; cin >> t >> n;\n        if(n == 0 && t == 0) break;\n        vector<vector<bool> > canGo(100, vector<bool> (100, true));\n        for(int k = 0; k < n; k++){\n            int i, j; cin >> i >> j;\n\n            //??§?¨???????\n            i += 40;\n            j += 40;\n            canGo[i][j] = false;\n        }\n        int si, sj; cin >> si >> sj;\n        si += 40;\n        sj += 40;\n\n        //???????????????s????????±????????\\??????????????????????????¢????????????\n        queue<pair<int, pair<int, int> > > wait;\n        wait.push(make_pair(0, make_pair(si, sj)));\n        canGo[si][sj] = false;\n\n        //??\\???????????????\n        int counter = 1;\n        while(!wait.empty()){    //?????\\???????????????????????§\n            //?????\\????????????????´????????????????\n            int nowcost = wait.front().first;\n            int nowi = wait.front().second.first;\n            int nowj = wait.front().second.second;\n\n            wait.pop();\n\n            //???????????°??????????????????????????¢?´¢?????????\n            if(nowcost == t){\n                continue;\n            }\n\n            //??????????????¢?´¢\n            for(int k = 0; k < 6; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //??????????????????????????????\n                if(canGo[nexti][nextj]){\n                    //????????????????????\\???????????????\n                    //??????????´¢???????????¨????????????????£???§?????????\n                    wait.push(make_pair(nowcost + 1, make_pair(nexti, nextj)));\n                    canGo[nexti][nextj] = false;\n                    counter++;\n                }\n            }\n        }\n\n        cout << counter << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define MAX 101\n#define INF 1e9\n\nstruct P{\n  int x, y, d;\n  P(int x, int y, int d){\n    this->x = x;\n    this->y = y;\n    this->d = d;\n  }\n};\n\nint t, sx, sy;\nbool impossible[MAX][MAX];\nint dist[MAX][MAX];\nconst int dx[] = {-1,0,0,-1,1,1};\nconst int dy[] = {-1,-1,1,0,0,1};\n\nbool check(int x, int y){\n  if(0 <= x && x <= 60 && \n     0 <= y && y <= 60){\n    return true;\n  }\n  return false;\n}\n\nint bfs(int x, int y){\n  fill(dist[0],dist[MAX],INF);\n\n  queue<P> que;\n  que.push(P(x,y,0));\n  dist[x][y] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n\n    if(impossible[p.x][p.y] || p.d >= t){\n      continue;\n    }\n\n    for(int i = 0 ; i < 6 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      \n      if(!check(nx,ny) || impossible[nx][ny] ||\n         dist[nx][ny] != INF){\n        continue;\n      }\n\n      dist[nx][ny] = dist[p.x][p.y] + 1;\n      que.push(P(nx,ny,dist[nx][ny]));\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dist[i][j] <= t){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, x, y;\n\n  while(cin >> t >> n , (t | n)){\n    memset(impossible,false,sizeof(impossible));\n    for(int i = 0 ; i < n ; i++){\n      cin >> x >> y;\n      x += 50, y += 50;\n      impossible[x][y] = true;\n    }\n    cin >> sx >> sy;\n    cout << bfs(sx+50, sy+50) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define K (50)\n#define INF (1145141919)\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, 1, 0, -1, -1};\nconst int dy[] = {0, 1, 1, 0, -1, -1, 0};\n\nbool map[100][100];\nbool dp[100][100][100];\n\nint main()\n{\n\tint t, n;\n\twhile (scanf(\"%d %d\", &t, &n), t + n){\n\t\tmemset(map, false, sizeof(map));\n\t\tmemset(dp, false, sizeof(dp));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\n\t\t\tmap[x + K][y + K] = true;\n\t\t}\n\t\t\n\t\tint X, Y;\n\t\tscanf(\"%d %d\", &X, &Y);\n\t\tdp[0][X + K][Y + K] = true;\n\t\t\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tfor (int x = 0; x < 100; x++){\n\t\t\t\tfor (int y = 0; y < 100; y++){\n\t\t\t\t\tif (dp[i][x][y]){\n\t\t\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\t\t\tif (!map[x + dx[j]][y + dy[j]]){\n\t\t\t\t\t\t\t\tdp[i + 1][x + dx[j]][y + dy[j]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcnt += dp[t][i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n,s=70;\n\tvvi field(s*2+3,vi(s*2+3,0));\n\tfor(auto y:{0,s*2+2})rep(x,s*2+3)field[y][x]=field[x][y]=1;\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=s+1,y+=s+1;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=2;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 133. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define NREP(i, n) FOR(i, 1, n + 1)\n\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n#define RREP(i, n) RFOR(i, n - 1, 0)\n#define RNREP(i, n) RFOR(i, n, 1)\n\n// Usual REP runs from 0 to n-1 (R: n-1 to 0)\n// Natural REP runs from 1 to n (R: n to 1)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\nconst ll dx[6] = {0, 1, -1, 1, -1, 0};\nconst ll dy[6] = {1, 1, 0, 0, -1, -1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\n\n/* ------------- Functions -------------- */\n\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        ll t, N;\n        cin >> t >> N;\n        if (t == 0) break;\n\n        V<V<ll>> field(200, V<ll>(200, 1000));\n        REP(_, N) {\n            ll x, y;\n            cin >> x >> y;\n            field[x + 100][y + 100] = -1;\n        }\n\n        ll x, y;\n        cin >> x >> y;\n\n        queue<P<ll, ll>> que;\n        que.push(mp(x + 100, y + 100));\n        field[x + 100][y + 100] = 0;\n\n        while (!que.empty()) {\n            auto p = que.front();\n            que.pop();\n\n            if (field[p.fst][p.snd] >= t) continue;\n\n            REP(i, 6) {\n                ll nx = p.fst + dx[i];\n                ll ny = p.snd + dy[i];\n\n                if (field[nx][ny] == 1000) {\n                    field[nx][ny] = field[p.fst][p.snd] + 1;\n                    que.push(mp(nx, ny));\n                }\n            }\n        }\n\n        ll ans = 0;\n        REP(x, 200) {\n            REP(y, 200) {\n                if (field[x][y] >= 0 && field[x][y] <= t) ans++;\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+70·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_COOR 150\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 70][obsy + 70] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 70;\n\t\tstarty += 70;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÌ½ßÌì)\n\t\t\t\tif(endcnt[nowx][nowy] == false){\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[100][100];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sx-data[1][i])>t+5){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (50-sx);\n\t\t\ttmpY += (50-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=50;\n\t\tsy=50;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\n#define SZ 90\n\nbool visited[SZ*2+5][SZ*2+5];\n\nbool isin(int x, int y){\n    return x>=0 && x<=SZ*2 && y>=0 && y<=SZ*2;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[SZ*2+5], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+SZ][y+SZ]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+SZ, sy+SZ), 0));\n        visited[sx+SZ][sy+SZ]=true;\n        int res=1;\n        while (!q.empty()){\n            int dx[] = {1,1,0,-1,-1,0};\n            int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second>=t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n//                    cout<<nx-SZ<<\",\"<<ny-SZ<<endl;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pi;\n\nint dx[]={-1,-1,0,1,1,0},dy[]={0,-1,-1,0,1,1};\n\nint main()\n{\n\tint t,n;\n\t\n\twhile(cin>>t>>n,t||n){\n\t\tint obj[200][200]={}, sx,sy, x,y;\n\t\tint v[200][200]={};\n\t\trep(i,n)cin>>x>>y,obj[y+100][x+100]=1;\n\t\tcin>>sx>>sy;\n\t\t\n\t\tqueue<pair<int,pi> > q; q.push(mp(0,mp(sy+100,sx+100)));\n\t\tv[sy+100][sx+100]=1;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ty=q.front().second.first, x=q.front().second.second;\n\t\t\tint ct=q.front().first; q.pop();\n\t\t\t\n\t\t\tif(ct>=t)continue;\n\t\t\t\n\t\t\trep(d,6){\n\t\t\t\tint ny=y+dy[d], nx=x+dx[d];\n\t\t\t\tif(obj[ny][nx]||v[ny][nx])continue;\n\t\t\t\tq.push(mp(ct+1,mp(ny,nx)));\n\t\t\t\tv[ny][nx]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\trep(i,200)rep(j,200)if(v[i][j])ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n//bool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { 0, 1, -1, 1, -1, 0 };\nint dy[] = { 1, 1, 0, 0, -1, -1 };\n\nbool fld[200][200];\nint cnt[200][200];\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n, t)\n\t{ \n\t\tMS(fld, false);\n\t\tREP(i, 200)REP(j, 200)\n\t\t{\n\t\t\tcnt[i][j] = INF;\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 100; y += 100;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100, sy += 100;\n\t\tcnt[sx][sy] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\twhile (que.size())\n\t\t{\n\t\t\tP now = que.front();\n\t\t\tint tx = now.first;\n\t\t\tint ty = now.second;\n\t\t\tque.pop();\n\t\t\tif (cnt[tx][ty] == t) break;\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i];\n\t\t\t\tint ny = ty + dy[i];\n\t\t\t\tif (fld[nx][ny]) continue;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tchmin(cnt[nx][ny], cnt[tx][ty] + 1);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 200)REP(j, 200)\n\t\t{\n\t\t\tif (cnt[i][j] < INF) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[100][100];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif(a[p.real()+50][p.imag()+50] == -2) return 0;\n\tif(k <= a[p.real()+50][p.imag()+50]) return 0;\n\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == -1) res++;\n\ta[p.real()+50][p.imag()+50] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tfor(int i=0;i<100;i<++) for(int j=0;j<100;j++) a[i][j] = -1;\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, k, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k;\n\t\tif (n == 0 && k == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tx[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (x[j][k] == 0 && y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= n) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 30;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[70][70]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (nx < 0 || ny < 0 || nx > 2 * base || ny > 2 * base)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\n\n#define TEST 0\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./ans.txt\", \"w\", stdout);\n#endif\n\nusing namespace std;\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nmap<pair<int, int>, bool> state;\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[make_pair(nx,ny)] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[make_pair(nx,ny)]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[make_pair(nx,ny)] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[make_pair(nx + dx[i],ny + dy[i])]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[make_pair(x,y)]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tcout << f(sx, sy,0) << endl;\n\t\tstate.clear();\n\n\t}\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[6] = { 1,1,0,-1,-1,0};\nconst int dy[6] = { 0,1,1,0,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif (!n)break;\n\t\tvvi v(61, vi(61, 0));\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv[y + 30][x + 30] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tvvi depth(61, vi(61, INF));\n\t\tdepth[sy + 30][sx + 30] = 0;\n\t\tqueue<pii> q;\n\t\tq.push(make_pair(sx, sy));\n\t\twhile (!q.empty()) {\n\t\t\tpii a = q.front(); q.pop();\n\t\t\tint x = a.first, y = a.second;\n\t\t\tREP(i, 6) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (ny <= 30 && nx <= 30 && nx >= -30 && ny >= -30 && v[ny + 30][nx + 30] == 0&&depth[ny+30][nx+30]==INF) {\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\tdepth[ny + 30][nx + 30] = depth[y + 30][x + 30] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 61) {\n\t\t\tREP(j, 61) {\n\n\t\t\t\tif (depth[i][j] <= t)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nint main(){\n    int a,b;\n    while(cin >> a >> b,a){\n        int bfs[200][200];\n        int ban[200][200];\n        rep(i,200)rep(j,200)ban[i][j]=bfs[i][j]=0;\n        rep(i,b){\n            int x,y;\n            cin >> x >> y;\n            x+=100;\n            y+=100;\n            ban[y][x]=1;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=100;\n        sy+=100;\n        queue<int> qy;\n        queue<int> qx;\n        qx.push(sx);\n        qy.push(sy);\n        bfs[sy][sx] = a+1;\n        while(qx.size()){\n            int y = qy.front();\n            int x = qx.front();\n            qx.pop();qy.pop();\n            if(bfs[y][x] == 1) break;\n            rep(i,6){\n                int nx = x+dx[i];\n                int ny = y+dy[i];\n                if(!bfs[ny][nx]&&!ban[ny][nx]){\n                    bfs[ny][nx] = bfs[y][x]-1;\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n        int ret = 0;\n        rep(i,200)rep(j,200)if(bfs[i][j])ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nint dy[]={1, 1, 0, 0, -1, -1};\nint dx[]={1, 0, 1, -1, 0, -1};\ntypedef pair<int, int> pii;\n\nint main(){\n\n    while(1){\n        int t, n;\n        cin>> t>> n;\n        if(!(t||n)) break;\n        int px[n], py[n];\n        for(int i=0; i<n; i++){\n            cin>> px[i]>> py[i];\n        }\n        int sx, sy;\n        cin>> sx>> sy;\n\n        int K=200;\n        int a[K][K];\n        for(int i=0; i<K; i++){\n            for(int j=0; j<K; j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0; i<n; i++){\n            a[py[i]+K/2][px[i]+K/2]=-1;\n        }\n\n        queue<tuple<int, int, int>> Q;\n        Q.push(make_tuple(sy+K/2, sx+K/2, 0));\n        a[sy+K/2][sx+K/2]=1;\n        while(!Q.empty()){\n            int i, j, turn;\n            tie(i, j, turn)=Q.front(); Q.pop();\n            if(turn==t) continue;\n            for(int k=0; k<6; k++){\n                int ni=i+dy[k];\n                int nj=j+dx[k];\n                if(a[ni][nj]==0){\n                    a[ni][nj]=1;\n                    Q.push(make_tuple(ni, nj, turn+1));\n                }\n            }\n        }\n\n        int s=0;\n        for(int i=0; i<K; i++){\n            for(int j=0; j<K; j++){\n                s+=(a[i][j]==1);\n            }\n        }\n\n\n        cout<< s<< endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    int t,n;\n    while (cin>>t>>n) {\n        if (t==0&&n==0) {\n            break;\n        }\n        int x,y;\n        std::map<pair<int,int>, bool> seen;\n        for (int i=0;i<50;i++) {\n            for (int j=0;j<50;j++) {\n                seen[make_pair(i,j)]=false;\n            }\n        }\n        for (int i=0;i<n;i++) {\n            cin>>x>>y;\n            seen[make_pair(x,y)]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n        seen[make_pair(sx,sy)]=true;\n        std::deque<pair<int,int>> deq;\n        deq.emplace_back(make_pair(sx,sy));\n        std::map<pair<int,int>, int> node_check;\n        int count=1,node=0;\n        while (deq.size()!=0) {\n            int tmpx=deq.front().first;\n            int tmpy=deq.front().second;\n            node=node_check[make_pair(tmpx,tmpy)];\n            if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx+1,tmpy)]==false) {\n                deq.emplace_back(make_pair(tmpx+1,tmpy));\n                seen[make_pair(tmpx+1,tmpy)]=true;\n                node_check[make_pair(tmpx+1,tmpy)]=node+1;\n                //cout<<tmpx+1<<\" \"<<tmpy<<\" node=\"<<node+1<<endl;\n                count++;\n            } else if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx-1,tmpy)]==false) {\n                deq.emplace_back(make_pair(tmpx-1,tmpy));\n                seen[make_pair(tmpx-1,tmpy)]=true;\n                node_check[make_pair(tmpx-1,tmpy)]=node+1;\n                //cout<<tmpx-1<<\" \"<<tmpy<<\" node=\"<<node+1<<endl;\n                count++;\n            } else if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx,tmpy+1)]==false) {\n                deq.emplace_back(make_pair(tmpx,tmpy+1));\n                seen[make_pair(tmpx,tmpy+1)]=true;\n                node_check[make_pair(tmpx,tmpy+1)]=node+1;\n                //cout<<tmpx<<\" \"<<tmpy+1<<\" node=\"<<node+1<<endl;\n                count++;\n            } else if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx,tmpy-1)]==false) {\n                deq.emplace_back(make_pair(tmpx,tmpy-1));\n                seen[make_pair(tmpx,tmpy-1)]=true;\n                node_check[make_pair(tmpx,tmpy-1)]=node+1;\n                //cout<<tmpx<<\" \"<<tmpy-1<<\" node=\"<<node+1<<endl;\n                count++;\n            } else if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx+1,tmpy+1)]==false) {\n                deq.emplace_back(make_pair(tmpx+1,tmpy+1));\n                seen[make_pair(tmpx+1,tmpy+1)]=true;\n                node_check[make_pair(tmpx+1,tmpy+1)]=node+1;\n                //cout<<tmpx+1<<\" \"<<tmpy+1<<\" node=\"<<node+1<<endl;\n                count++;\n            } else if (node_check[make_pair(tmpx,tmpy)]<t&&seen[make_pair(tmpx-1,tmpy-1)]==false) {\n                deq.emplace_back(make_pair(tmpx-1,tmpy-1));\n                seen[make_pair(tmpx-1,tmpy-1)]=true;\n                node_check[make_pair(tmpx-1,tmpy-1)]=node+1;\n                //cout<<tmpx-1<<\" \"<<tmpy-1<<\" node=\"<<node+1<<endl;\n                count++;\n            } else {\n                deq.pop_front();\n            }\n        }\n        cout<<count<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1},dy[]={0,1,0,-1,1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nvoid solve(int t,int n){\n\tint sx,sy;\n\tvvi vv(200,vi(200,INF));\n\trep(i,n){\n\t\tcin>>sx>>sy;\n\t\tsx+=100;sy+=100;\n\t\tvv[sx][sy]=-1;\n\t}\n\tcin>>sx>>sy;\n\tsx+=100,sy+=100;\n\tqueue<pii> q;\n\tq.push(pii(sx,sy));\n\tvv[sx][sy]=0;\n\tint ans=1;\n\twhile(!q.empty()){\n\t\ttie(sx,sy)=q.front();q.pop();\n\t\tif(vv[sx][sy]>=t)continue;\n\t\trep(i,6){\n\t\t\tif(vv[sx+dx[i]][sy+dy[i]]<=vv[sx][sy]+1)continue;\n\t\t\tans++;\n\t\t\tvv[sx+dx[i]][sy+dy[i]]=vv[sx][sy]+1;\n\t\t\tq.push(pii(sx+dx[i],sy+dy[i]));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint t,n;\n\twhile(cin>>t>>n,t|n)solve(t,n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\n#define INF (int)1e09\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::setprecision;\nusing std::fixed;\nusing std::pair;\nusing std::make_pair;\nusing std::min;\nusing std::max;\nusing std::string;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::set; // insert erase find count\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n\ntemplate <typename T> using Vec = vector<T>; // c++11\ntypedef pair<int, int> PII;\ntypedef pair<int, pair<int, int> > PIII;\n\nstruct Coord {\n    int y;\n    int x;\n\n    Coord() {}\n    Coord(int y0, int x0) {\n        y = y0;\n        x = x0;\n    }\n};\n\nint dx[6] = {-1, -1, 0, 0, 1, 1};\nint dy[6] = {-1, 0, -1, 1, 0, 1};\n\nvoid dump (Vec<Vec<int> > &table, int t) {\n    for (int i = 0; i < 2 * t + 3; i++) {\n        for (int j = 0; j < 2 * t + 3; j++) {\n            cout << table[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return;\n}\n\nvoid bfs (Vec<Vec<int> > &table, int t) {\n    queue<pair<int, Coord> > que;\n    Coord start(t + 1, t + 1);\n    que.push(make_pair(0, start));\n\n    while (!que.empty()) {\n        int dist = que.front().first;\n        Coord coord = que.front().second;\n        que.pop();\n\n        for (int i = 0; i < 6; i++) {\n            Coord new_coord(coord.y + dy[i], coord.x + dx[i]);\n            if (table[new_coord.y][new_coord.x] == -1) {\n                que.push(make_pair(dist + 1, new_coord));\n                table[new_coord.y][new_coord.x] = dist + 1;\n            }\n        }\n    }\n    return;\n}\n\nint check (Vec<Vec<int> > &table, int t) {\n    int count = 0;\n    for (int i = 1; i < 2 * t + 2; i++) {\n        for (int j = 1; j < 2 * t + 2; j++) {\n            if (table[i][j] >= 0 && table[i][j] <= t) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint main(void) {\n    while (1) {\n        int t;\n        int n;\n        cin >> t >> n;\n        if (t == 0 && n == 0) {\n            break;\n        }\n        Vec<Vec<int> > table(2 * t + 3, Vec<int>(2 * t + 3, INF));\n        for (int i = 1; i < 2 * t + 2; i++) {\n            for (int j = 1; j < 2 * t + 2; j++) {\n                table[i][j] = -1;\n            }\n        }\n\n        Vec<Coord> temp(n);\n        for (int i = 0; i < n; i++) {\n            cin >> temp[i].x >> temp[i].y;\n        }\n\n        Coord start;\n        cin >> start.x >> start.y;\n        table[t + 1][t + 1] = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (abs(temp[i].y -start.y) > t || abs(temp[i].x -start.x) > t) {\n                //cout << \"HEREIF\" << endl;\n                //cout << temp[i].x << \" \" << temp[i].y << endl;\n                continue;\n            }\n            //cout << \"HERE\" << endl;\n            //cout << temp[i].x << \" \" << temp[i].y << endl;\n            table[temp[i].y - start.y + t + 1][temp[i].x - start.x + t + 1] = INF;\n        }\n\n        //dump(table, t);\n        bfs(table, t);\n        //dump(table, t);\n        cout << check(table, t) << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int t,n;cin>>t>>n,t|n;){\n\t\tint grid[61][61]={}; // -1:block,0:empty,1:visitable\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tgrid[30+y][30+x]=-1;\n\t\t}\n\t\tint x0,y0; cin>>x0>>y0;\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(x0,y0,0);\n\t\twhile(!q.empty()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint cx=get<0>(c),cy=get<1>(c),ct=get<2>(c);\n\t\t\tif(abs(cx)>30 || abs(cy)>30 || abs(cy-cx)>30 || grid[30+cy][30+cx] || ct>t)\n\t\t\t\tcontinue;\n\t\t\tgrid[30+cy][30+cx]=1;\n\t\t\tint dx[]={1,1,0,-1,-1,0},dy[]={0,1,1,0,-1,-1};\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t\tq.emplace(cx+dx[i],cy+dy[i],ct+1);\n\t\t}\n\t\t\n\t\tint res=0;\n\t\tfor(int i=0;i<61;i++)\n\t\t\tfor(int j=0;j<61;j++)\n\t\t\t\tres+=grid[i][j]==1;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\nint Map[250][250];\n\nint main(){\n\n    while(1){\n        int t, n; cin >> t >> n;\n        if(!t) break;\n\n        for(int i = 0; i < 250; i++){\n            for(int j = 0; j < 250; j++){\n                Map[i][j] = 1;\n            }\n        }\n\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y;\n            x += 100;\n            y += 100;\n            Map[x][y] = 0;\n        }\n\n        int sx, sy; cin >> sx >> sy;\n\n        int ans = 1;\n        queue<pair<int, pair<int, int> > > q;\n        q.push({0, {sx + 100, sy + 100}});\n        Map[sx + 100][sy + 100] = 0;\n        while(!q.empty()){\n            int cost = q.front().first;\n            int nowx = q.front().second.first;\n            int nowy = q.front().second.second;\n            //cout << nowx-100 << \" \" << nowy-100 << \" \" << cost  << endl;\n            q.pop();\n            if(cost >= t) continue;\n\n            for(int h = 0; h < 6; h++){\n                int nx = nowx + dx[h];\n                int ny = nowy + dy[h];\n                if(Map[nx][ny]){\n                    ans++;\n                    Map[nx][ny] = 0;\n                    q.push({cost + 1, {nx, ny}});\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nbool isRange(int x,int y){\n    return -75<=x && x<=75 && -75<=y && y<=75;\n}\nint main(){\n    int t,n;\n    int dx[6]={1,1,0,-1,-1,0};\n    int dy[6]={1,0,-1,-1,0,1};\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(151,vector<int>(151,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+75][y+75]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        vector<vector<int>> been(151,vector<int>(151,0));\n        been[s.first+75][s.second+75]=1;\n        int cnt=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        while(!q.empty()){\n            auto state=q.front();\n            q.pop();\n            auto p=state.first;\n            int turn=state.second;\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isRange(tox,toy) && !ob[tox+75][toy+75] && !been[tox+75][toy+75]){\n                    been[tox+75][toy+75]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n                }\n\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+30, x.back()+30));\n    int cnt = 0;\n    while(!que.empty()){\n        if(cnt > n) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            if(graph[cur.first][cur.second] > cnt){\n                graph[cur.first][cur.second] = cnt;\n            }\n            REP(i, 6){\n                if(graph[cur.first + dy[i]][cur.second + dx[i]] > i){\n                    que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 61){\n            REP(j, 61){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            graph[30 + y[i]][30 + x[i]] = -INF;\n        }\n        graph[30 + y.back()][30 + x.back()] = 0;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nbool isrange(int x,int y)\n{\n\treturn -30<=x && x<=30 && -30<=y && y<=30;\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tvector<vector<int> > ob(61,vector<int>(61,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tob[x+30][y+30]=1;\n\t\t}\n\t\tpair<int,int> s;\n\t\tcin>>s.first>>s.second;\n\t\tqueue<pair<pair<int,int>, int> > q;\n\t\tvector<vector<int> > been(61,vector<int>(61,0));\n\t\tbeen[s.first+30][s.second+30]=1;\n\t\tq.push(make_pair(s,0));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front().first;\n\t\t\tint turn=q.front().second;\n\t\t\tq.pop();\n\t\t\tif(turn==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint tx=p.first+dx[i];\n\t\t\t\tint ty=p.second+dy[i];\n\t\t\t\tif(isrange(tx,ty) && !ob[tx+30][ty+30] && !been[tx+30][ty+30]){\n\t\t\t\t\tbeen[tx+30][ty+30]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(tx,ty),turn+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint cnt=0;\t\t\n\t\tfor(int i=0;i<61;i++){\n\t\t\tfor(int j=0;j<61;j++)\n\t\t\t\tcnt+=been[i][j];\n\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[900][900]={};\nbool vis[900][900]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.emplace(x,y,t);\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.emplace(na,nb,c-1);\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,900)rep(j,900)cnt+=vis[i][j];\n  return cnt;\n}\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=100;y+=100;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=100;sy+=100;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n          //  cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 100\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+40][y+40] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+40,sY+40)); \n\t\td[sX+40][sY+40] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\t//cout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30];\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 999999;\n\n\nqueue<pair<int, int> > que;\nint maze[300][300];\nint d[300][300];\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\n//今回 arr[y][x] で設計する\nvoid bfs(int sx, int sy){\n\tque.push(make_pair(sy, sx));\n\td[sy][sx] = 0;\n\n\n\twhile(que.size()){\n\t\tint y = que.front().first;\n\t\tint x = que.front().second;\n\t\tque.pop();\n\n\t\t//seach around\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(0 <= ny and ny < 300 and 0 <= nx and nx < 300 and d[ny][nx] == INF and maze[ny][nx]){\n\t\t\t\tque.push(make_pair(ny, nx));\n\t\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\nwhile(1){//start\n\tint t, n;\n\tcin >> t >> n;\n\tif(t == 0 and n == 0) break;\n\n\t//init\n\tfor(int i = 0; i < 300; i++){\n\t\tfor(int j = 0; j < 300; j++){\n\t\t\td[i][j] = INF;\n\t\t\tmaze[i][j] = 1;\n\t\t}\n\t}\n\n\t//0なら移動不可　1なら移動可能\n\tfor(int i = 0; i < n; i++){\n\t\tint tx, ty;\n\t\tcin >> tx >> ty;\n\t\tmaze[ty + 150][tx + 150] = 0;\n\t}\n\tint sx, sy;\n\tcin >> sx >> sy;\n\n\tbfs(sx + 150, sy + 150);\n\n\tint cnt = 0;\n\tfor(int i = 0; i < 300; i++){\n\t\tfor(int j = 0; j < 300; j++){\n\t\t\tif(d[i][j] <= t) cnt++;\n\t\t}\n\t}\n\n\tcout << cnt << endl;\n}//end\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tvisited.insert(fr);\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(fr.first.first+dx[i],fr.first.second+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end())q.push(piii(cur,fr.second+1));\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n\n#define N 60\n\nusing namespace std;\n\nstatic int d[ N * 2 + 1 ][ N * 2 + 1 ];\n#define D(X,Y) \\\n  d[ N + (X) ][ N + (Y) ]\n\nstruct Cell\n{\n  int x;\n  int y;\n  int t;\n};\ntypedef struct Cell Cell;\n\nstatic Cell\ncons (\n  int x,\n  int y,\n  int t\n  )\n{\n  Cell res = { x, y, t };\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  queue<Cell> lis;\n\n  for ( ; ; )\n  {\n    int x, y;\n    int t, n;\n    int res = 0;\n\n    scanf ( \"%d%d\", &t, &n );\n    if ( !( t | n ) ) break ;\n\n    memset ( d, 0, sizeof ( d ) );\n    while ( n-- )\n    {\n      scanf ( \"%d%d\", &x, &y );\n      D( x, y ) = 1;\n    }\n\n    scanf ( \"%d%d\", &x, &y );\n    lis.push ( cons ( x, y, t + 1 ) );\n    while ( !lis.empty ( ) )\n    {\n      const Cell c = lis.front ( );\n      lis.pop ( );\n\n      if ( !( c.t )\n        || c.x < -N || c.x > N\n        || c.y < -N || c.y > N\n        || D( c.x, c.y ) ) continue ;\n      ++res;\n\n      D( c.x, c.y ) = 1;\n      lis.push ( cons ( c.x + 1, c.y    , c.t - 1 ) );\n      lis.push ( cons ( c.x + 1, c.y + 1, c.t - 1 ) );\n      lis.push ( cons ( c.x    , c.y + 1, c.t - 1 ) );\n      lis.push ( cons ( c.x - 1, c.y    , c.t - 1 ) );\n      lis.push ( cons ( c.x - 1, c.y - 1, c.t - 1 ) );\n      lis.push ( cons ( c.x    , c.y - 1, c.t - 1 ) );\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<set>\n#include<queue>\nusing namespace std;\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nset<pair<int,int> > OB;\nset<pair<int,int> > D;\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n && t!=0){\n\t\tOB.clear();\n\t\tD.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tOB.insert(make_pair(x,y));\n\t\t}\n\t\tqueue<pair<pair<int,int> ,int> > Q;\n\t\tint x,y; cin>>x>>y;\n\t\tQ.push(make_pair(make_pair(x,y),0));\n\t\twhile(!Q.empty()){\n\t\t\tpair<int,int> now=Q.front().first;\n\t\t\tint cost=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif(OB.count(now)) continue;\n\t\t\tif(D.count(now)) continue;\n\t\t\tD.insert(now);\n\t\t\tif(cost==t) continue;\n\t\t\tfor(int r=0;r<6;r++)\n\t\t\t\tQ.push(make_pair(make_pair(now.first+dx[r],now.second+dy[r]),cost+1));\n\t\t}\n\t\tcout<<D.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x,y,cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[100][100];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 50;\n      Y += 50;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\nint t,n,sx,sy;\nbool used[1111][1111];\nint dx[] = {1,-1,0,0,1,-1};\nint dy[] = {0,0,1,-1,1,-1};\nint main(void){\n  while(cin >> t >> n && t){\n    memset(used,false,sizeof(used));\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      used[x+300][y+300] = true;;\n    }\n    cin >> sx >> sy;\n\n    queue<pair<int,pair<int,int> > > que;\n    que.push(make_pair(0,make_pair(sx+300,sy+300)));\n    used[sx+300][sy+300] = true;\n    int res = 0;\n    while(!que.empty()){\n      int nt = que.front().first;\n      int x = que.front().second.first;\n      int y = que.front().second.second;\n      que.pop();\n      if(nt > t) continue;\n      res++;\n      for(int i = 0; i < 6; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(used[nx][ny]) continue;\n\tused[nx][ny] = true;\n\tque.push(make_pair(nt+1,make_pair(nx,ny)));\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nbool out(int x,int y){\n\tif(10<=x&&x<=70&&10<=y&&y<=70){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint dx[6]={1,0,-1,-1,0,1};\n\tint dy[6]={0,-1,-1,0,1,1};\n\tint n,t;\n\twhile(cin>>t>>n&&t){\n\t\tint board[80][80]; rep(i,80)rep(j,80) board[i][j]=INF;\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tboard[x+40][y+40]=-1;\n\t\t}\n\t\tint sx,sy; cin>>sx>>sy;\n\t\tboard[sx+40][sy+40]=0;\n\t\tqueue<pair<int,int>> q;\n\t\tq.push(make_pair(sx+40,sy+40));\n\n\t\tint cnt=1;\n\t\twhile(q.size()){\n\t\t\tpair<int,int> p=q.front();\n\t\t\tq.pop();\n\t\t\tint nowx=p.first,nowy=p.second;\n\t\t\tif(board[nowx][nowy]==t) continue;\n\t\t\trep(i,6){\n\t\t\t\tint nex=nowx+dx[i],ney=nowy+dy[i];\n\t\t\t\tif(out(nex,ney)&&board[nex][ney]==INF){\n\t\t\t\t\tboard[nex][ney]=board[nowx][nowy]+1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tq.push(make_pair(nex,ney));\n\t\t\t\t\t// cout<<nex<<\" \"<<ney<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[63][63];\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = t+1;\n\tif(t==0) return;\n\tfor(int i=0;i<6;i++){\n\t\tint x2 = x+dx[i];\n\t\tint y2 = y+dy[i];\n\t\tif(hoge[x2][y2] != -1 && hoge[x2][y2] < t){\n\t\t\tf(x2, y2, t-1, ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<63;i++){\n\t\t\tfor(int j=0;j<63;j++){\n\t\t\t\tif(i==0 || j==0 || i==62 || j==62){\n\t\t\t\t\thoge[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\thoge[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 31;\n\t\t\ty += 31;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 31;\n\t\ty += 31;\n\t\t\n\t\tint ans = 0;\n\t\tf(x, y, t, ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\nstruct Node\n{\n\tint x, y, turn;\n};\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<int, 61>, 61> field;\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tfield = { {0} };\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 30][x + 30] = 1;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 30][startX + 30] = 1;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX+30, startY+30, 0 });\n\t\t\tint dx[] = {1, 0, -1, -1, 0, 1};\n\t\t\tint dy[] = {0, -1, -1, 0, 1, 1};\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 60 || next.y < 0 || next.y > 60) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = 2;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (next.turn >= t) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t\t\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int offsetX = 30;\nconst int offsetY = 30;\n\nconst int fieldObstacle = 2;\nconst int fieldWalked = 1;\nconst int fieldNothing = 0;\n\nclass Answer {\n\tint m_m;\n\tstd::vector< std::vector<int> > m_field;\n\tint m_w, m_h;\npublic:\n\tAnswer(int w, int h) :\n\t\tm_m(0),\n\t\tm_field(h, std::vector<int>(w, fieldNothing)),\n\t\tm_w(w),\n\t\tm_h(h)\n\t{\n\t}\n\tint num() const\n\t{\n\t\treturn m_m;\n\t}\n\tvoid addObstacle(int x, int y)\t// ツ閉崢催ャツ用\n\t{\n\t\tm_field[y][x] = fieldObstacle;\n\t}\n\tvoid calc(int t, int x, int y);\t// ツ閉崢催ャツ用\n};\n\nvoid Answer::calc(int t, int x, int y)\n{\n\tif (x < 0 || x >= m_w || y < 0 || y >= m_h || m_field[y][x] == fieldObstacle) {\n\t\treturn;\n\t}\n\tif (m_field[y][x] == fieldNothing) {\n\t\tm_field[y][x] = fieldWalked;\t// ツ督楪達ツフツδ可グ\n\t\t++m_m;\t// ツつアツつアツづ?青板つヲツづゥ\n\t}\n\tif (t > 0) {\n\t\tcalc(t - 1, x + 1, y);\n\t\tcalc(t - 1, x + 1, y + 1);\n\t\tcalc(t - 1, x, y + 1);\n\t\tcalc(t - 1, x - 1, y);\n\t\tcalc(t - 1, x - 1, y - 1);\n\t\tcalc(t - 1, x, y - 1);\n\t}\n}\n\nint main()\n{\n\tint t, n;\n\twhile (std::cin >> t >> n, t != 0 || n != 0) {\n\t\tAnswer answer(2 * offsetY + 1, 2 * offsetX + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\t// ツ湘。ツ害ツ閉ィ\n\t\t\tstd::cin >> x >> y;\n\t\t\tanswer.addObstacle(x + offsetX, y + offsetY);\t// ツ閉崢催ャツ用\n\t\t}\n\t\tint x, y;\t// ツスツタツーツトツ暗環置\n\t\tstd::cin >> x >> y;\n\t\tanswer.calc(t, x + offsetX, y + offsetY);\t// ツ閉崢催ャツ用\n\t\tstd::cout << answer.num() << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 0x3f3f3f3f;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int t, n;\n  while (cin >> t >> n, t) {\n    vector<vector<bool>> b(121, vector<bool>(121, true));\n    while (n--) {\n      int x, y;\n      cin >> x >> y;\n      x += 60, y += 60;\n      b[x][y] = false;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += 60, sy += 60;\n    vector<vector<int>> d(121, vector<int>(121, inf));\n    queue<pair<int, int>> que;\n    d[sx][sy] = 0;\n    que.emplace(sx, sy);\n    while (not que.empty()) {\n      int x, y;\n      tie(x, y) = que.front();\n      que.pop();\n      for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n          if (dx + dy) {\n            int nx = x + dx, ny = y + dy;\n            if (0 <= nx and nx <= 120 and 0 <= ny and ny <= 120 and b[nx][ny] and d[nx][ny] == inf) {\n              d[nx][ny] = d[x][y] + 1;\n              que.emplace(nx, ny);\n            }\n          }\n        }\n      }\n    }\n    int res = 0;\n    for (int x = 0; x <= 120; ++x) {\n      for (int y = 0; y <= 120; ++y) {\n        res += d[x][y] <= t;\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint t, n;\n\twhile (cin >> t >> n, t | n) {\n\t\tset<PII> objects;\n\t\tset<PII> visited;\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tobjects.insert(MP(y, x));\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue< pair<PII, int> > q;\n\t\tq.push(MP(MP(sy, sx), 0));\n\t\tint dy[] = { 1, 0, -1, -1, 0, 1 };\n\t\tint dx[] = { 1, 1, 0, -1, -1, 0 };\n\t\tint ans = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpair<PII, int> tmp = q.front(); q.pop();\n\t\t\tPII p = tmp.F; int turn = tmp.S;\n\t\t\tif (turn > t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (EXIST(visited, p) || EXIST(objects, p)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ans;\n\t\t\tvisited.insert(p);\n\t\t\tREP (d, 6) {\n\t\t\t\tint ny = p.F + dy[d], nx = p.S + dx[d];\n\t\t\t\tPII np = MP(ny, nx);\n\t\t\t\tif (abs(ny) > 30 || abs(nx) > 30) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(MP(np, turn + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, m, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t\ty[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (x[dx[l] + j][dy[l] + k] == 0) {\n\t\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= n) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i<n;i++)\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> q1;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] == 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0);\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n, N) for(ll i=(n); i<(N); i++)\n#define RREP(i, n, N) for(ll i=(N-1); i>=(n); i--)\n#define LREP(lst,itr) for(auto itr = lst.begin(); itr != lst.end(); ++itr)\n#define CK(n, a, b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(),(v).end()\n#define MCP(a, b) memcpy(b,a,sizeof(b))\n#define P(s) cout<<(s)<<endl\n#define P2(a, b) cout<<(a)<<\" \"<<(b)<<endl\n#define V2(T) vector<vector<T>>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n\nconst int dif = 100;\nstruct zahyo\n{\n    int x;\n    int y;\n    int turn;\n};\n\n\nint board[200][200];\nqueue<zahyo> points;\n\n\nvoid point_process(int x, int y, int turn){\n    if(board[x][y]==0){\n        board[x][y]=1;\n        points.push({x+1,y,turn+1});\n        points.push({x+1,y+1,turn+1});\n        points.push({x,y+1,turn+1});\n        points.push({x,y-1,turn+1});\n        points.push({x-1,y,turn+1});\n        points.push({x-1,y-1,turn+1});\n    }\n}\n\nint main(){\n    while(1){\n        int turn,n,x,y;\n        cin >> turn >> n;\n        if(turn==0)break;\n        \n        //初期化\n        REP(i,0,200) REP(j,0,200) board[i][j]=0;\n        queue<zahyo>().swap(points);\n\n        //障害物を2に設定\n        REP(i,0,n){\n            cin >> x >> y;\n            //P2(x,y);\n            board[x+dif][y+dif]=2;\n        }\n        \n\n        cin >> x >> y;\n        //P(\"start\");\n        //P2(x,y);\n        points.push({x+dif,y+dif,0});\n\n        while(!points.empty()){\n            if(points.front().turn>turn)break;\n            point_process(points.front().x, points.front().y, points.front().turn);\n            points.pop();\n        }\n        /**\n        REP(i,0,61){\n            REP(j,0,61){\n                cout << board[i][j];\n            }\n            cout << endl;\n        }\n        cout << endl;\n        **/\n        \n        int ans=0;\n        REP(i,0,200) REP(j,0,200) if(board[i][j]==1)ans++;\n        cout << ans << endl;\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int t,n;\n  while(cin>>t>>n&&t+n){\n    int a[63][63];\n    memset(a,-1,sizeof(a));\n    for(i=1;i<62;i++)\n      for(j=1;j<62;j++)\n\ta[j][i]=0;\n    for(i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      x+=31;\n      y+=31;\n      a[x][y]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=31;\n    sy+=31;\n    int b[63][63];\n    memset(b,-1,sizeof(b));\n    queue<pair<pair<int,int>,int> > c;\n    c.push(make_pair(make_pair(sx,sy),0));\n    int ct=0;\n    while(c.empty()==0){\n      int x,y,z;\n      x=c.front().first.first;\n      y=c.front().first.second;\n      z=c.front().second;\n      c.pop();\n      if(z>t)\n\tbreak;\n      if(a[x][y]==0&&b[x][y]==-1){\n\tct++;\n\tb[x][y]=1;\n\tc.push(make_pair(make_pair(x+1,y+1),z+1));\n\tc.push(make_pair(make_pair(x+1,y),z+1));\n\tc.push(make_pair(make_pair(x,y-1),z+1));\n\tc.push(make_pair(make_pair(x-1,y-1),z+1));\n\tc.push(make_pair(make_pair(x-1,y),z+1));\n\tc.push(make_pair(make_pair(x,y+1),z+1));\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntemplate<class T1,class T2>\nusing Hash = unordered_map<T1, T2>;\n\nint dx[]{ 0,1,1,0,-1,-1 }, dy[]{ 1,1,0,-1,-1,0 };\nint main() {\n\tint t, n;\n\twhile (scanf(\"%d%d\", &t, &n), t) {\n\t\tHash<int, Hash<int, int>>mp, d;\n\t\trep(i, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tmp[x][y] = 1;\n\t\t}\n\t\tfor (int i = -30; i <= 30; i++)for (int j = -30; j <= 30; j++) {\n\t\t\td[i][j] = INT_MAX;\n\t\t}\n\t\tint sx, sy; scanf(\"%d%d\", &sx, &sy);\n\t\tqueue<P>que;\n\t\tint cnt = 1;\n\t\tque.push(P(sx, sy));\n\t\td[sx][sy] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (d[p.first][p.second] >= t)break;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (!mp[nx][ny] && d[nx][ny] == INT_MAX) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n \n#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (n) ;i++)\n  \nint vec1[] = {0,1,-1,1,-1,0};\nint vec2[] = {1,1,0,0,-1,-1};\n  \nint t,n;\nint table[200][200];\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n  \nint ans;\n  \nint solve(int y,int x){\n    queue <piii> q1;\n    q1.push(make_pair(0,make_pair(y,x)));\n    while(!q1.empty()){\n        if(t <= q1.front().first)\n            return 0;\n        REP(i,6){\n            int n_y = q1.front().second.first + vec1[i];\n            int n_x = q1.front().second.second + vec2[i];\n            if(table[n_y][n_x] == 0){\n                ans++;\n                table[n_y][n_x] = 1;\n                q1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n            }\n        }\n        q1.pop();\n    }\n    return 0;\n}\n  \nint main(){\n    while(cin >> t  >> n , t+n){\n        ans = 0;\n        fill_n(table[0],200*200,0);\n        REP(i,n){\n            int x,y;\n            cin >> x >> y;\n            table[100 + y][100 + x] = 1;\n        }\n        int x,y;\n        cin >> x >> y;\n        table[100+y][100+x] = 1;\n        solve(100+y,100+x);\n        cout << ans + 1<< endl;\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint t, n;\n\tint DX[6] = { 0,1,1,0,-1,-1 }, DY[6] = { 1,1,0,-1,-1,0 };\n\twhile (cin >> t >> n&&t)\n\t{\n\t\tint z = 50;\n\t\tint a[100][100];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ta[x+z][y+z] = -2;\n\t\t}\n\t\tpii st;\n\t\tcin >> st.first >> st.second;\n\t\tst.first += z;\n\t\tst.second += z;\n\t\ta[st.first][st.second] = t;\n\t\tqueue<pii> que;\n\t\tque.push(st);\n\t\tint ans = 1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front();\n\t\t\tque.pop();\n\t\t\tif (a[now.first][now.second] == 0)continue;\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += DX[i];\n\t\t\t\tnext.second += DY[i];\n\t\t\t\tif (a[next.first][next.second] == -1)\n\t\t\t\t{\n\t\t\t\t\ta[next.first][next.second] = a[now.first][now.second] - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint x[150][150][2], n, m, c, d, i, j, k, sum;\n#define A(B,C) if(x[B][C][0]==0 && x[B][C][1]==1){x[B][C][0]=2;sum++;}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0) { break; }sum = 1; memset(x, 0, sizeof(x));\n\t\tfor (i = 40; i <= 100; i++) { for (j = 40; j <= 100; j++) { x[i][j][1] = 1; } }\n\t\tfor (i = 0; i < m; i++) { cin >> c >> d; x[c + 70][d + 70][1] = 0; }cin >> c >> d; x[c + 70][d + 70][0] = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 141; j++) {\n\t\t\t\tfor (k = 0; k < 141; k++) {\n\t\t\t\t\tif (x[j][k][0] == 1) {\n\t\t\t\t\t\tA(j - 1, k - 1);\n\t\t\t\t\t\tA(j - 1, k);\n\t\t\t\t\t\tA(j, k - 1);\n\t\t\t\t\t\tA(j, k + 1);\n\t\t\t\t\t\tA(j + 1, k);\n\t\t\t\t\t\tA(j + 1, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < 141; j++) { for (k = 0; k < 141; k++) { if (x[j][k][0] == 2) { x[j][k][0] = 1; } } }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    //print1 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) cout << \"X \";\n        else cout << memo[i][j] << \" \";\n      }\n      cout << el;\n    }\n    */\n    //print1 end\n\n    // print2 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          if (map[30-i+j][60-i]) cout << \"* \";\n          else if (memo[30-i+j][60-i] == INF) cout << \"X \";\n          else cout << memo[30-i+j][60-i] << \" \";\n        }\n        if (map[60][60-i]) cout << \"*\";\n        else if (memo[60][60-i] == INF) cout << \"X\";\n        else cout << memo[60][60-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (map[j][30]) cout << \"* \";\n          else if (memo[j][30] == INF) cout << \"X \";\n          else cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          if (map[j][60-i]) cout << \"* \";\n          else if (memo[j][60-i] == INF) cout << \"X \";\n          else cout << memo[j][60-i] << \" \";\n        }\n        if (map[90-i][60-i]) cout << \"*\";\n        else if (memo[90-i][60-i] == INF) cout << \"X\";\n        else cout << memo[90-i][60-i];\n      }\n      cout << el;\n    }\n    */\n    // prin2 end\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 31 + i; j++) {\n          if (memo[30-i+j][60-i] < INF) res++;\n        }\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (memo[j][30] < INF) res++;\n        }\n      } else {\n        for (int j = 0; j < 91 - i; j++) {\n          if (memo[j][60-i] < INF) res++;\n        }\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n#define fcout cout << setprecision(10)\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\ntemplate <typename T>\nvoid debug(vector<T> &vec) {\n    for (auto x : vec) {\n        cout << x << \" \";\n    }\n    cout << endl;\n    return;\n}\n\ntemplate <typename A, size_t N, typename T>\nvoid FILL(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nclass BFS {\n   private:\n    int H, W;\n    int dx[6] = {0, 1, 0, -1, 1, -1};\n    int dy[6] = {1, 0, -1, 0, 1, -1};\n\n   public:\n    vector<string> field;\n    vector<vector<int>> cost;\n\n    BFS(vector<string> f) : field(f) {\n        H = f.size();\n        W = f[0].size();\n        cost.assign(H, vector<int>(W, -1));\n    }\n\n    void bfs(queue<pair<int, int>> starts) {\n        queue<pair<int, int>> que = starts;\n        while (!que.empty()) {\n            auto top = que.front();\n            que.pop();\n            int ny = top.first, nx = top.second;\n            for (int i = 0; i < 6; i++) {\n                int tx = nx + dx[i], ty = ny + dy[i];\n                if (ty < H && tx < W && ty > -1 && tx > -1) {\n                    if (field[ty][tx] == '#') continue;\n                    if (cost[ty][tx] == -1) {\n                        cost[ty][tx] = cost[ny][nx] + 1;\n                        que.push(make_pair(ty, tx));\n                    }\n                }\n            }\n        }\n    }\n\n    void debug() {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) cout << cost[i][j] << \" \";\n            cout << endl;\n        }\n    }\n};\n\nvoid solve(int t, int n) {\n    vector<string> field(200, string(200, '.'));\n    int bias = 100;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        field[y + bias][x + bias] = '#';\n    }\n\n    int sx, sy;\n    cin >> sx >> sy;\n\n    BFS bfs(field);\n    bfs.cost[bias + sy][bias + sx] = 0;\n\n    queue<pair<int, int>> que;\n    que.push(make_pair(bias + sy, bias + sx));\n    bfs.bfs(que);\n\n    int ans = 0;\n    for (int i = -bias; i < bias; i++) {\n        for (int j = -bias; j < bias; j++) {\n            if (bfs.cost[i + bias][j + bias] == -1) continue;\n            if (bfs.cost[i + bias][j + bias] > t) continue;\n            ans += 1;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    int t, n;\n    while (cin >> t >> n && t) {\n        solve(t, n);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n// Example: dy[i%2][d] ( i is 0-indexed )\nconst int dx[2][6] = {{ 1,-1, 0, 0,1,-1},{ 1,-1, 0, 0,1,-1}};\nconst int dy[2][6] = {{ 1,-1,-1, 1,0,0 },{ 1,-1,-1, 1,0,0 }};\ntypedef complex<int> P;\n\nnamespace std{\n\tbool operator < (const P &a,const P &b){\n\t\treturn a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nint main(){\n\tint T,N;\n\twhile(cin >> T >> N , T || N){\n\t\tmap<P,bool> done,bad;\n\t\trep(i,N){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tbad[P(x,y)] = true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tqueue< pair<P,int> > Q;\n\t\tQ.push(make_pair(P(sx,sy),0));\n\t\tint ans = 0;\n\t\twhile(Q.size() && Q.front().second <= T){\n\t\t\tP q = Q.front().first;\n\t\t\tint c = Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif(bad[q] || done[q])continue;\n\t\t\telse done[q] = true , ans++;\n\t\t\trep(i,6){\n\t\t\t\tP next(q.real() + dx[abs(q.imag())%2][i] , q.imag() + dy[abs(q.imag())%2][i]);\n\t\t\t\tQ.push(make_pair(next,c+1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,t;\nint map[200][200],fast[200][200];\nint dx[6]={0,1,0,-1,1,-1},dy[6]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n    map[y][x]=1;\n    if(len<t&&len<fast[y][x]){\n    fast[y][x]=len;\n    for(int i=0;i<6;i++){\n        if(map[y+dy[i]][x+dx[i]]!=-1)\n            DFS(y+dy[i],x+dx[i],len+1);\n    }\n    }\n}\nint main(){\n    while(true){\n    cin>>t>>n;\n    if(t==0&&n==0)\n        break;\n    for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n            map[i][j]=0;\n            fast[i][j]=100;\n        }\n    }\n    int x,y;\n    for(int i=0;i<n;i++){\n        cin>>x>>y;\n        map[100+y][100+x]=-1;\n    }\n    cin>>x>>y;\n    DFS(y+100,x+100,0);\n    int ans=0;\n    for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n            if(map[i][j]==1)\n                ans++;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    while(true){\n        int field[100][100];\n        int cfield[100][100];\n        int t, n;\n        scanf(\"%d%d\", &t, &n);\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                field[i][j] = cfield[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            x += 50; y += 50;\n            field[x][y] = -1;\n            cfield[x][y] = -1;\n        }\n        int cx, cy;\n        scanf(\"%d%d\", &cx, &cy);\n        cx += 50; cy += 50;\n        field[cx][cy] = cfield[cx][cy] = 1;\n        for(int _ = 0; _ < t; _++){\n            for(int i = 0; i < 100; i++){\n                for(int j = 0; j < 100; j++){\n                    if(field[i][j] > 0){\n                        for(int d = 0; d < 6; d++){\n                            if(cfield[i + dx[d]][j + dy[d]] >= 0){\n                                cfield[i + dx[d]][j + dy[d]] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            for(int i = 0; i < 100; i++){\n                for(int j = 0; j < 100; j++){\n                    field[i][j] = cfield[i][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                if(field[i][j] > 0){\n                    ++ans;\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\nint mass[80][80];\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nvoid dfs(int x, int y, int turn){\n  if(turn == 1) return;\n  REP(i, 6){\n    int nx = x + dx[i]; int ny = y + dy[i];\n    if(nx < 0 or nx >= 80 or ny < 0 or ny >= 80) continue;\n    if(mass[nx][ny] < turn-1 and mass[nx][ny] >= 0) { mass[nx][ny] = turn-1; dfs(nx, ny, turn-1); }\n  }\n}\n\nint main(){\n  int t, n;\n  while(cin >> t >> n and t + n){\n    memset(mass, 0, sizeof(mass));\n    REP(i, n){\n      int x, y; cin >> x >> y;\n      mass[x+40][y+40] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    mass[sx+40][sy+40] = t+1;\n    dfs(sx+40, sy+40, t+1);\n    int res = 0;\n    REP(i, 80) REP(j, 80) if(mass[i][j] > 0) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define DIFF 75\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nbool point[151][151];\nbool searched[151][151];\nint recturn[151][151];\nP start;\n\nint dx[6] = {1, 0, -1, 0, 1, -1}, dy[6] = {0, 1, 0, -1, 1, -1};\n\nint bfs(int t, int n) {\n  queue<P> q1;\n  P temp;\n  int count = 0;\n  int turn = 0;\n  temp.first = start.first;\n  temp.second = start.second;\n  searched[temp.first + DIFF][temp.second + DIFF] = true;\n  recturn[temp.first + DIFF][temp.second + DIFF] = 0;\n  q1.push(temp);\n  count++;\n  while (q1.empty() == false) {\n    temp = q1.front();\n    q1.pop();\n    if (recturn[temp.first + DIFF][temp.second + DIFF] == t) break;\n    for (int i = 0; i < 6; i++) {\n      P s;\n      s.first = temp.first + dx[i];\n      s.second = temp.second + dy[i];\n      if (point[s.first + DIFF][s.second + DIFF]\n\t  && !searched[s.first + DIFF][s.second + DIFF]) {\n\tq1.push(s);\n\tsearched[s.first + DIFF][s.second + DIFF] = true;\n\trecturn[s.first + DIFF][s.second + DIFF]\n\t  = recturn[temp.first + DIFF][temp.second + DIFF] + 1;\n\tcount++;\n      }\n    }\n  }\n  return count;\n}\n\nint main() {\n  while (true) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) return 0;\n\n    for (int i = 0; i < 151; i++) {\n      for (int j = 0; j < 151; j++) {\n\tpoint[i][j] = true;\n\tsearched[i][j] = false;\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x  >> y;\n      point[x + DIFF][y + DIFF] = false;\n    }\n\n    cin >> start.first >> start.second;\n\n    int ans = bfs(t, n);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[6] = { 1, 1, 0, 0, -1, -1 };\nint dy[6] = { 1, 0, -1, 1, 0, -1 };\n\nbool field[150][150];\nint turn;\n\nint bfs( int sx, int sy ) {\n\tint ans = 1;\n\n\tqueue<pair<P, int> > que;\n\tque.emplace( MP( sx, sy ), 0);\n\tfield[sx][sy] = false;\n\n\twhile( !que.empty() ) {\n\t\tpair<P, int> t = que.front(); que.pop();\n\t\tif( t.second == turn ) break;\n\n\t\tREP( i, 6 ) {\n\t\t\tint nx = t.X + dx[i];\n\t\t\tint ny = t.Y + dy[i];\n\n\t\t\tif( field[nx][ny] ) {\n\t\t\t\tfield[nx][ny] = false;\n\t\t\t\tans++;\n\t\t\t\tque.emplace( MP( nx, ny ), t.second + 1 );\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn ans;\n\n}\n\nsigned main() {\n\tint n;\n\twhile( cin >> turn >> n, turn ) {\n\t\tfill( field[0], field[150], true );\n\t\tREP( i, n ) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfield[x + 60][y + 60] = false;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\n\t\tcout << bfs( sx + 60, sy + 60 ) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\nconst int MAX = 1000;\nconst int base=500;\n\nvoid solve(int t,int n){\n  int x,y;\n  bool d[MAX][MAX],used[MAX][MAX];\n  int dx[6]={1,1,0,-1,-1,0};\n  int dy[6]={1,0,-1,-1,-0,1};\n\n  rep(i,MAX)rep(j,MAX){\n    d[i][j]=true;\n    used[i][j]=false;\n  }\n  \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    d[a+base][b+base]=false;\n  }\n  cin>>x>>y;\n  \n  queue<pi> que;\n  que.push(mp(x,y));\n  used[x+base][y+base]=true;\n  for(int i=0;i<t;i++){\n    int size=que.size();\n    for(int j=0;j<size;j++){\n      pi dir=que.front();que.pop();\n      for(int k=0;k<6;k++){\n\tpi tmp=mp(dir.first+dx[k],dir.second+dy[k]);\n\tif(!used[tmp.first+base][tmp.second+base]&&d[tmp.first+base][tmp.second+base]){\n\t  que.push(tmp);\n\t  used[tmp.first+base][tmp.second+base]=true;\n\t}\n      }\n    }\n  }\n  int ans=0;\n  rep(i,MAX)rep(j,MAX)ans+=used[i][j];\n  cout<<ans<<endl;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0&&n==0)break;\n    solve(t,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 1,1, 0, -1, -1,0 }; const int dy2[] = { 0, 1, 1,0,-1, -1 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint t,n;\n\twhile (cin >> t >> n, t | n) {\n\t\tset<pii> jama;\n\t\tREP(i,n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tjama.insert(pii(x, y));\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tqueue<pii> Q;\n\t\tQ.push(pii(sx, sy));\n\t\tset<pii> S;\n\t\tS.insert(pii(sx, sy));\n\t\tint ans = 1;\n\t\tREP(i, t) {\n\t\t\tqueue<pii> Q2;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\t\n\t\t\t\tpii q = Q.front();Q.pop();\n\t\t\t\tREP(j,6) {\n\t\t\t\t\tif (-30 <= q.first + dx2[j] && q.first + dx2[j] <= 30 && -30 <= q.second + dy2[j] && q.second + dy2[j] <= 30 && S.find(pii(q.first + dx2[j], q.second + dy2[j])) == S.end()&& jama.find(pii(q.first + dx2[j], q.second + dy2[j])) == jama.end()) {\n\t\t\t\t\t\tS.insert(pii(q.first + dx2[j], q.second + dy2[j]));\n\t\t\t\t\t\tQ2.push(pii(q.first + dx2[j], q.second + dy2[j]));\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ = Q2;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nint dx[6] = {-1, -1, 0, 1, 1, 0};\nint dy[6] = {0, -1, -1, 0, 1, 1};\nbool issearched[140][140];\n\nint t, n;\nint islandmap[140][140];\nint tesu[140][140];\nint start_x, start_y;\n\nvoid search(int a, int b);\n\nint main()\n{\n    while(1){\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 140; i++){\n            for(int j = 0; j < 140; j++){\n                islandmap[i][j] = 0;\n                issearched[i][j] = false;\n                tesu[i][j] = 0;\n            }\n        }\n        int obstacle_x, obstacle_y;\n        for(int i = 0; i < n; i++){\n            cin >> obstacle_x >> obstacle_y;\n            islandmap[obstacle_x + 70][obstacle_y + 70] = -1;\n        }\n        cin >> start_x >> start_y;\n        issearched[start_x + 70][start_y + 70] = true;\n        search(start_x + 70, start_y + 70);\n        int ans = 1;\n        for(int i = start_x + 70 - t; i < start_x + 71 + t; i++){\n            for(int j = start_y + 70 - t; j < start_y + 71 + t; j++){\n                if(tesu[i][j] < t + 1 && tesu[i][j] > 0) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nvoid search(int a, int b)\n{\n    int x, y, nx, ny;\n    queue<pair < int, int> > qu;\n    qu.push(make_pair<int, int>(a, b));\n    while(!qu.empty()){\n        x = (qu.front()).first;\n        y = (qu.front()).second;\n        for(int i = 0; i < 6; i++){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if(nx < start_x + 70 - t|| ny < start_y + 70 - t|| nx > start_x + 71 + t|| ny > start_y + 71 + t) continue;\n            if(islandmap[nx][ny] != -1 && issearched[nx][ny] == false){\n                tesu[nx][ny] = tesu[x][y] + 1;\n                qu.push(make_pair<int, int>(nx, ny));\n                issearched[nx][ny] = true;\n            }\n        }\n        qu.pop();\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,n,x,y,ans,sx,sy;\n  int mp[61][61];\n  while(1){\n    cin>>t>>n;\n    for(int i=0;i<61;i++){\n      for(int j=0;j<61;j++){\n\tmp[i][j]=0;\n      }\n    }\n    ans=0;\n    if(t==0 && n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      mp[y+30][x+30]=-1;\n    }\n    cin>>sx>>sy;\n    mp[sy+30][sx+30]=1;\n    for(int i=1;i<=t;i++){\n      for(int j=0;j<61;j++){\n\tfor(int k=0;k<61;k++){\n\t  if(mp[j][k]==i){\n\t    for(int l=-1;l<2;l++){\n\t      if(mp[j+l][k]==0 && j+l!=60 && j+l!= -1){\n\t\tmp[j+l][k]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j][k+l]==0 && k+l!=60 && k+l!= -1){\n\t\tmp[j][k+l]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j+l][k+l]==0 && k+l!=60 && j+l!=60 && k+l!= -1 && j+l != -1){\n\t\tmp[j+l][k+l]=i+1;\n\t\tans++;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/03 04:41:12\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\n// 1 1 0 0 -1 -1\n// 0 1 -1 1 0 1\n\nint main()\n{\n    constexpr int dx[] = {1, 1, 0, 0, -1, -1};\n    constexpr int dy[] = {0, 1, -1, 1, 0, -1};\n    for (int T, N;;) {\n        cin >> T >> N;\n        if (T == 0 and N == 0) { break; }\n        constexpr int S = 100;\n        using P = pair<int, int>;\n        vector<vector<bool>> used(2 * S + 1, vector<bool>(2 * S + 1, false));\n        for (int i = 0, x, y; i < N; i++) { cin >> x >> y, used[y + S][x + S] = true; }\n        queue<pair<P, int>> q;\n        int sx, sy;\n        cin >> sx >> sy;\n        used[S + sy][S + sx] = true, q.push({{S + sy, S + sx}, 0});\n        while (not q.empty()) {\n            const int y = q.front().first.first, x = q.front().first.second, t = q.front().second;\n            q.pop();\n            if (t == T) { continue; }\n            for (int i = 0; i < 6; i++) {\n                const int newy = y + dy[i], newx = x + dx[i];\n                if (used[newy][newx]) { continue; }\n                used[newy][newx] = true, q.push({{newy, newx}, t + 1});\n            }\n        }\n        int ans = -N;\n        for (int i = -S; i <= S; i++) {\n            for (int j = -S; j <= S; j++) {\n                if (used[i + S][j + S]) { ans++; }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > n) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            REP(i, 6){\n                if(cur.first + dy[i] >= 0 && cur.first + dy[i] <= 64 && cur.second + dx[i] >= 0 && cur.second + dx[i] <= 64){\n                    if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                        que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                        close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                        graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                    }\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        //cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 65){\n            REP(j, 65){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\nconst int dy[]={-1,-1,0,0,1,1};\nconst int dx[]={-1,0,-1,1,0,1};\nint main(){\n\n\tint n,t;\n\tconst int base=150;\n\tconst int MAX_P=301;\n\twhile(cin>>t>>n&&!(t==0&&n==0)){\n\t\tbool passed[MAX_P][MAX_P];\n\t\tint isArrival[2][MAX_P][MAX_P];\n\t\tbool obj[MAX_P][MAX_P];\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tmemset(obj,0,sizeof(obj));\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tobj[y+base][x+base]=true;\n\t\t}\n\t\tint sy,sx;\n\t\tcin>>sx>>sy;\n\t\tisArrival[0][sy+base][sx+base]=true;\n\t\tpassed[sy+base][sx+base]=true;\n\t\tfor(int l = 0; l < t; l++){\n\t\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\t\tif(isArrival[l%2][i][j]){\n\t\t\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tif(!obj[ny][nx]){\n\t\t\t\t\t\t\t\tisArrival[(l+1)%2][ny][nx]=true;\n\t\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisArrival[l%2][i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\tif(passed[i][j])\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[200][200], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] >= t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[100][100] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint panel[61][61];\nint dd[] = {0, 1, 1, 0, -1, -1, 0};\n\nvoid wfs(int x, int y, int t) {\n  priority_queue<PIP> q;\n  q.push(PIP(t, P(x, y)));\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    if (panel[p.se.se][p.se.fi] == 1) continue;\n    else panel[p.se.se][p.se.fi] = 1;\n\n    if (p.fi == 0) continue;\n    rep(i, 6) {\n      int yy = p.se.se + dd[i], xx = p.se.fi + dd[i + 1];\n      if (panel[yy][xx] == 0) q.push(PIP(p.fi - 1, P(xx, yy)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t, n;\n  while(cin >> t >> n, t | n) {\n    rep(i, 61)rep(j, 61) panel[i][j] = 0;\n\n    rep(i, n) {\n      int x, y;\n      cin >> x >> y; x += 30, y += 30;\n      if (0 <= x && x < 61 && 0 <= y && y < 61) panel[y][x] = 2;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    wfs(x + 30, y + 30, t);\n\n    int ans = 0;\n    rep(i, 61)rep(j, 61) if (panel[i][j] == 1) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<utility>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nbool check[62][62];\nbool jama_grid[62][62];\n\nint main(){\n    int t, n;\n    int x, y;\n    int origin_x, origin_y;\n    int ans;\n    \n    while(1){\n        //初期化\n        ans = 0;\n        for(int i = 0; i < 62; i++){\n            for(int j = 0; j <62; j++){\n                check[i][j] = false;\n                jama_grid[i][j] = false;\n            }\n        }\n\n        cin>>t>>n;\n        if(n == 0 && t == 0)break;\n        for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            jama_grid[y+30][x+30] = true;\n        }\n        cin >> origin_x >> origin_y;\n\n        // move_dfs(origin_y+30, origin_x+30, t);\n\n        // BFSの処理\n        queue<PP> Q;\n        PP start = mp(mp(origin_x + 30, origin_y + 30), t);\n        Q.push(start);\n\n        while (!Q.empty()) {\n            PP now = Q.front();\n            Q.pop();\n            check[now.first.second][now.first.first] = true;\n            int dx[6] = {-1, 0, 1, 0, -1, 1}, dy[6] = {0, -1, 0, 1, -1, 1};\n            for (int i = 0; i < 6; i++) {\n                int nx = now.first.first + dx[i], ny = now.first.second + dy[i];\n                if (nx >= 0 && nx <= 60 && ny >= 0 && ny <= 60 && now.second > 0 && !jama_grid[ny][nx] && !check[ny][nx]) Q.push(mp(mp(nx, ny), now.second - 1));\n            }\n        }\n\n        for (int i = 0; i < 62; i++) for (int j = 0; j < 62; j++) {\n            if (check[i][j]) ans++;\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint visited[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  visited[x][y] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && i+1 < visited[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < visited[x][y-1]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < visited[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[x+1][y] && i+1 < visited[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < visited[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < visited[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        visited[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (visited[i][j] < INF) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main() {\n\tint d1[6] = { 1,0,-1,0,1,-1 };\n\tint d2[6] = { 0,1,0,-1,1,-1 };\n\tint t, n;\n\twhile (cin >> t>>n, t) {\n\t\tint p[100][100] = {};\n\t\tint x, y, sta, las;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[x + 50][y + 50] = 1;\n\t\t}\n\t\tcin >> sta >> las; sta += 50; las += 50;\n\t\tint used[100][100] = {};\n\t\tused[sta][las] = 1;\n\t\tvector<P> v;\n\t\tv.push_back({ sta,las });\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint len = v.size();\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tint nx = v[0].first; int ny = v[0].second; v.erase(v.begin());\n\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\tif (p[nx + d1[k]][ny + d2[k]] == 0 && used[nx + d1[k]][ny + d2[k]]==0) {\n\t\t\t\t\t\tused[nx + d1[k]][ny + d2[k]] = 1;\n\t\t\t\t\t\tv.push_back({ nx + d1[k],ny + d2[k] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif (used[i][j] == 1)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nclass state{\npublic:\n\tint x;\n\tint y;\n\tint turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tif(field[s.x+1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y+1, s.turn+1));\n\t\t\t\t\tfield[s.x][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x-1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y-1, s.turn+1));\t\n\t\t\t\t\tfield[s.x][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x+1][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y+1, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y-1, s.turn+1));\n\t\t\t\t\tfield[s.x-1][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nstruct pr{\n\tint nx,ny,cnt;\n};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pr>q;\n\t\tpr p;\n\t\tp.nx=sx;p.ny=sy;p.cnt=0;\n\t\tq.push(p);\n\t\twhile(!q.empty()){\n\t\t\tpr pi=q.front();q.pop();\n\t\t\tint x=pi.nx;\n\t\t\tint y=pi.ny;\n\t\t\tint tt=pi.cnt;\n\t\t\tif(tt>=t)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tpr p2;p2.nx=x+dx[i];p2.ny=y+dy[i];p2.cnt=tt+1;\n\t\t\t\tq.push(p2);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst auto gcu = getchar_unlocked;\nconst auto pcu = putchar_unlocked;\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _sc _il bool scan\n_T T in(int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_il int in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _ot _il void out\n#define _ol _il void outl\n_ot(bool b) {pcu('0'+b);}\n_ot(const char *s){while(*s)pcu(*s++);}\n_ot(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_ot(string s){for(char c:s)pcu(c);}\n#endif\n_T _ot(T n){static char b[20];char *p=b,m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=n%10*m+'0',n/=10;while(p!=b)pcu(*--p);}\n_ol(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _ot(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _ot(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _ol(T&&... t){out(move(t)...);outl();}\n\nstruct map {\n\tstruct node {int x, y, c;};\n\tint c;\n\tvector<vector<bool>> t;\n\tmap(int i) : c(i), t(i * 2 + 1, vector<bool>(i * 2 + 1, true)) {}\n\tvoid put(int x, int y) {\n\t\tt[y][x] = false;\n\t}\n\tint walk(int x, int y, int c) {\n\t\tstatic const int tx[] = {1, 0, -1, -1, 0, 1}, ty[] = {0, -1, -1, 0, 1, 1};\n\t\tqueue<node> q;\n\t\tq.push({x, y, c});\n\t\tput(x, y);\n\t\tint r = 1;\n\t\twhile (!q.empty()) {\n\t\t\tnode n = q.front();\n\t\t\tq.pop();\n\t\t\tif (n.c--)\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx = n.x + tx[i], ny = n.y + ty[i];\n\t\t\t\t\tif (t[ny][nx]) {\n\t\t\t\t\t\tq.push({nx, ny, n.c});\n\t\t\t\t\t\tput(nx, ny);\n\t\t\t\t\t\tr++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n};\n\nint main() {\n\tfor (int t, n; t = in(), n = in(), t || n;) {\n\t\tmap m(30 + t);\n\t\twhile (n--) {\n\t\t\tint x = in(), y = in();\n\t\t\tm.put(x + m.c, y + m.c);\n\t\t}\n\t\tint x = in(), y = in();\n\t\toutl(m.walk(x + m.c, y + m.c, t));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\n\nconst int MAX_N = 100005;\nconst int dx[] = {1,1,0,0,-1,-1};\nconst int dy[] = {0,1,-1,1,0,-1};\n\nint t,n;\nint ans;\n\nint main()\n{\n    while(1){\n        cin >> t >> n;\n        if(t == 0){\n            break;\n        }\n        map<P,int> mp;\n        ans = 0;\n        rep(i,n){\n            int a,b;\n            cin >> a >> b;\n            mp[P(a,b)]++;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        queue<PP> que;\n        que.push(PP(P(sx,sy),1));\n        mp[P(sx,sy)]++;\n        ans++;\n        while(!que.empty()){\n            PP p = que.front();\n            que.pop();\n            rep(i,6){\n                int nx = (p.fi).fi + dx[i];\n                int ny = (p.fi).se + dy[i];\n                if(abs(nx) <= 60 && abs(ny) <= 60 && mp[P(nx,ny)] == 0){\n                    mp[P(nx,ny)]++;\n                    ans++;\n                    if(p.se < t){\n                        que.push(PP(P(nx,ny),p.se+1));\n                    }\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\ntypedef pair<pii,int>piii;\nint dx[]={0,-1,1};\nint dy[]={0,-1,1}\n;int main(){\n    int t,n;\n    while(cin>>t>>n){\n        int ans=0;\n        if(t+n==0)break;\n        map<pii,int>mp;\n        pii s;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>s.first>>s.second;\n        queue<piii>que;\n        que.push(make_pair(s,0));\n        while(!que.empty()){\n            piii now=que.front();que.pop();\n            if(abs(now.first.first)>30||abs(now.first.second)>30)continue;\n            if(now.second>30)continue;\n            if(now.second>t)continue;\n            if(now.second>mp[now.first]&&mp[now.first]!=0)continue;\n            if(mp[now.first]==0)ans++;\n            mp[now.first]=now.second;\n            if(now.first==s)mp[s]=INF;\n            rep(i,3)rep(j,3){\n                if(dx[i]+dy[j]==0)continue;\n                pii next=pii(now.first.first+dx[i],now.first.second+dy[j]);\n                if(mp[next]==-INF)continue;\n                piii hoge;\n                hoge.first=next;\n                hoge.second=now.second+1;\n                que.push(hoge);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cctype>\n#include <cstdlib>      // srand,rand\n\n\nusing namespace std;\n#define modd 1000000007\n\n\n\ntypedef pair<long long, long long> pl;\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\n\n\n#define ll long long\n\n\n\n\nclass UnionFind {\npublic:\n\tvector <ll> par;\n\tvector <ll> siz;\n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1LL){\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i;\n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { // 根の検索\n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\n\t\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\n\n\tbool issame(ll x, ll y) { // 連結判定\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) { // 素集合のサイズ\n\t\treturn siz[root(x)];\n\t}\n\n\n};\n\n\nclass SegmentTree {\nprivate:\n\tint n;\n\tvector <ll> node;\n\npublic:\n\t// 元の配列　v をセグメントツリーで表現する。\n\tSegmentTree(vector<ll> v) {\n\t\t//最下段のノード数は元配列のサイズ以上になる最小の2冪->これをnとおく。\n\t\t//セグ木全体で必要なノード数は2n-1個である。\n\t\tint sz = v.size();\n\t\tn = 1; \n\t\twhile (n < sz)n *= 2;\n\n\t}\n\n};\n\n\n\n\nlong long N, M, K, a, b, c, d, e, H, W, L,T;\nll A[2][300005] = {};\nll B[2][100005] = {};\nll C[2][300005] = {};\nbool f, ff;\nstring S,SS;\nset <long long>sll;\n\nvector <long long>vl[100005];\nvector <long long>vll;\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset[50];\nmultiset<ll> llmset;\n\n\nstruct ST\n{\n\tll first;\n\tll second;\n\tll kaisuu;\n\t\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn first < another.first;//比較\n\t};\n\n};\n\n\n\n/*vector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\nll minn, maxx;\ndouble ansa;\n\nbool turnleft[300000];\n\nll zettai(ll aa) {\n\n\tif (aa < 0) {\n\t\taa *= -1;\n\t}\n\treturn aa;\n\n}\n\nbool itta[201][201];\nll x, y;\n\nqueue<ST> qpl;\nST bufpll;\n\nST bufpl;\n\nint main() {\n\t\n\n\twhile (true) {\n\n\t\tcin >> T >> N;\n\n\t\tif (T == 0 && N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 201; i++) {\n\t\t\tfor (int j = 0; j < 201; j++) {\n\t\t\t\titta[i][j] = false;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> a>>b;\n\t\t\titta[a+100][b+100] = true;\n\t\t}\n\n\t\tcin >> x >> y;\n\n\n\t\tbufpl.first = x+100;\n\t\tbufpl.second = y+100;\n\t\tbufpl.kaisuu = 0;\n\t\titta[x + 100][y + 100] = true;\n\n\t\tqpl.push(bufpl);\n\n\n\n\t\ta = 1;\n\t\tb = 1;\n\n\t\twhile (!qpl.empty()) {\n\t\t\tx = qpl.front().first;\n\t\t\ty = qpl.front().second;\n\t\t\tb = qpl.front().kaisuu;\n\t\t\tbufpl.kaisuu = b + 1;\n\t\t\tif (b < T) {\n\n\t\t\t\tif (itta[x - 1][y - 1] == false) {\n\t\t\t\t\titta[x - 1][y - 1] = true;\n\t\t\t\t\ta++;\n\t\t\t\t\tbufpl.first = x - 1;\n\t\t\t\t\tbufpl.second = y - 1;\n\n\t\t\t\t\t\n\t\t\t\t\tqpl.push(bufpl);\n\n\t\t\t\t}\n\n\t\t\t\tif (itta[x + 1][y + 1] == false) {\n\t\t\t\t\titta[x + 1][y + 1] = true;\n\t\t\t\t\ta++;\n\n\t\t\t\t\tbufpl.first = x + 1;\n\t\t\t\t\tbufpl.second = y + 1;\n\t\t\t\t\tqpl.push(bufpl);\n\t\t\t\t}\n\n\t\t\t\tif (itta[x - 1][y] == false) {\n\t\t\t\t\titta[x - 1][y] = true;\n\t\t\t\t\ta++;\n\n\t\t\t\t\tbufpl.first = x - 1;\n\t\t\t\t\tbufpl.second = y;\n\t\t\t\t\tqpl.push(bufpl);\n\t\t\t\t}\n\n\t\t\t\tif (itta[x][y - 1] == false) {\n\t\t\t\t\titta[x][y - 1] = true;\n\t\t\t\t\ta++;\n\n\t\t\t\t\tbufpl.first = x;\n\t\t\t\t\tbufpl.second = y - 1;\n\t\t\t\t\tqpl.push(bufpl);\n\t\t\t\t}\n\n\t\t\t\tif (itta[x + 1][y] == false) {\n\t\t\t\t\titta[x + 1][y] = true;\n\t\t\t\t\ta++;\n\n\t\t\t\t\tbufpl.first = x + 1;\n\t\t\t\t\tbufpl.second = y;\n\t\t\t\t\tqpl.push(bufpl);\n\t\t\t\t}\n\n\t\t\t\tif (itta[x][y + 1] == false) {\n\t\t\t\t\titta[x][y + 1] = true;\n\t\t\t\t\ta++;\n\n\t\t\t\t\tbufpl.first = x;\n\t\t\t\t\tbufpl.second = y + 1;\n\t\t\t\t\tqpl.push(bufpl);\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tqpl.pop();\n\n\t\t}\n\n\t\t\n\t\tcout << a << endl;\n\n\n\t}\n\n\n\t//cout << fixed << setprecision(10) << ansa << endl;\n\treturn 0;\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint t, n;\n\twhile (cin >> t >> n, t | n) {\n\t\tset<PII> objects;\n\t\tset<PII> visited;\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tobjects.insert(MP(y, x));\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue< pair<PII, int> > q;\n\t\tq.push(MP(MP(sy, sx), 0));\n\t\tint dy[] = { 1, 0, -1, -1, 0, 1 };\n\t\tint dx[] = { 1, 1, 0, -1, -1, 0 };\n\t\tint ans = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpair<PII, int> tmp = q.front(); q.pop();\n\t\t\tPII p = tmp.F; int turn = tmp.S;\n\t\t\tif (turn > t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (abs(p.F) > 30 || abs(p.S) > 30) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (EXIST(visited, p) || EXIST(objects, p)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ans;\n\t\t\tvisited.insert(p);\n\t\t\tREP (d, 6) {\n\t\t\t\tint ny = p.F + dy[d], nx = p.S + dx[d];\n\t\t\t\tPII np = MP(ny, nx);\n\t\t\t\tq.push(MP(np, turn + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\n\nint board[128][128];\nint geta = 64;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  while (1) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    memset(board, 0, sizeof(board));\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      board[y+geta][x+geta] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    queue<T> que;\n    que.push(T(sx, sy, t));\n\n    while (!que.empty()) {\n      int x, y, rest;\n      tie(x, y, rest) = que.front();\n      que.pop();\n\n      if (rest < 0 || board[y+geta][x+geta] != 0) continue;\n\n      board[y+geta][x+geta] = 1;\n      REP(i, 6) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\t  que.push(T(nx, ny, rest - 1));\n      }\n    }      \n      \n    int ans = 0;\n    for (int y = -30; y <= 30; y++) {\n      for (int x = -30; x <= 30; x++) {\n\tans += board[y+geta][x+geta] > 0;\n      }\n    }\n    cout << ans << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint d[]={0,1,-1};\n#define piii pair<pii,int>\npiii _pi(pii t,int h) {piii hoge; hoge.first=t; hoge.second=h; return hoge;}\nint main(){\n    int t,n;\n    while(cin>>t>>n, t+n){\n        map<pii,int>mp;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            temp=pii(temp.first+300,temp.second+300);\n            mp[temp]++;\n        }\n        pii s; cin>>s.first>>s.second;\n        vvi visit(1001,vi(1001,INF));\n        queue<pii>que;\n        que.push(pii(s.first+300,s.second+300));\n        visit[s.first+300][s.second+300]=0;\n        int ans=1;\n        while(!que.empty()){\n            pii now=que.front(); que.pop();\n            if(visit[now.first][now.second]+1>t)continue;\n            rep(i,3)rep(j,3){\n                if(d[i]+d[j]==0)continue;\n                pii hoge=pii(now.first+d[i],now.second+d[j]);\n                if(mp[hoge])continue;\n                if(visit[hoge.first][hoge.second]==INF)ans++;\n                if(visit[hoge.first][hoge.second]<visit[now.first][now.second]+1)continue;\n                visit[hoge.first][hoge.second]=visit[now.first][now.second]+1;\n                que.push(hoge);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint main(void)\n{\n\tint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\n\tint used[200][200];\n\tint t,n;\n\tint X,Y;\n\tqueue<int> xs,ys;\n\twhile (cin>>t>>n,t) {\n\t\tmemset(used,0,sizeof(used));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tused[Y+40][X+40]=1;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\txs.push(X+40); ys.push(Y+40);\n\t\tused[Y+40][X+40]=1;\n\t\tint ans=1;\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front();\n\t\t\txs.pop(); ys.pop();\n\t\t\tif(used[y][x]<=t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\tused[ny][nx]=used[y][x]+1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int n,t;\n  while(cin>>t>>n,n+t){\n    bool Map[200][200]={};\n    bool Map2[200][200]={};\n\n    for(int i=0;i<n;i++){\n      int a,b;cin>>a>>b;\n      Map2[a+100][b+100]=true;\n    }\n    int aa,bb;cin>>aa>>bb;\n    Map[aa+100][bb+100]=true;\n    int ans=0;\n    int vx[6]={1,0,-1,0,-1,1};\n    int vy[6]={0,-1,0,1,1,-1};\n    queue<pair<pair<int,int>,int> >que;\n    que.push(mp(mp(aa+100,bb+100),0));\n    while(!que.empty()){\n      pair<pair<int,int>,int >now=que.front();\n      que.pop();\n      if(now.S>=t)break;;\n      for(int i=0;i<6;i++){\n\tint x=now.F.F+vx[i],y=now.F.S+vy[i];\n\tif((!Map[x][y])&&(!Map2[x][y])){\n\t  Map[x][y]=true;\n\t  que.push(mp(mp(x,y),now.S+1));\n\t}\n      }\n    }\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)\n\tif(Map[i][j])\n\t  ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0, 1, -1};\nint dy[] = {0, 0, 1, -1, 1, -1};\n\nint T, N;\nint maze[100][100];\n\nstruct State{\n\tint x, y, t;\n\tState(int _x, int _y, int _t){\n\t\tx = _x;\n\t\ty = _y;\n\t\tt = _t;\n\t}\n};\n\nbool check(int x, int y){\n\treturn x >= 0 && x < 100 && y >= 0 && y < 100 && maze[x][y] != 2;\n}\n\nint main() {\n\twhile(cin >> T >> N && (T || N)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tint a, b;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> a >> b;\n\t\t\tmaze[a + 50][b + 50] = 2;\n\t\t}\n\t\tint sx, sy, count = 0;\n\t\tcin >> sx >> sy;\n\t\tqueue<State> q;\n\t\tq.push(State(sx + 50, sy + 50, 0));\n\t\twhile(!q.empty()){\n\t\t\tState st = q.front(); q.pop();\n\t\t\tif(st.t > T || maze[st.x][st.y] == -1)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tmaze[st.x][st.y] = -1;\n\t\t\tcount++;\n\t\t\tfor(int i = 0; i < 6; ++i){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tif(check(nx, ny))\n\t\t\t\t\tq.push(State(nx, ny, st.t + 1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << count << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\n\nint solve(set<pair<int,int> > field,set<pair<int,int> > &visited,int turn,int x,int y){\n\tif(field.find(make_pair(x,y)) != field.end()) return 0;\n\tfield.insert(make_pair(x,y));\n\tint sum;\n\tif(visited.find(make_pair(x,y)) != visited.end())\n\t\tsum = 0;\n\telse \n\t\tsum = 1;\n\tvisited.insert(make_pair(x,y));\n\tfor(int i=-1;i<=1&&turn;++i){\n\t\tfor(int j=-1;j<=1;++j){\n\t\t\tif(i+j==0) continue;\n\t\t\tsum += solve(field, visited, turn-1, x+i, y+j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,!(t==0&&n==0)){\n\t\tset<pair<int,int> > field;\n\t\tset<pair<int,int> > visited;\n\t\tfor(int i=0,x,y;i<n;++i){\n\t\t\tcin>>x>>y;\n\t\t\tfield.insert(make_pair(x,y));\n\t\t}\n\t\tint st_x,st_y;\n\t\tcin>>st_x>>st_y;\n\t\tcout<<solve(field,visited,t,st_x,st_y)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n-1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tvector< vector<int> > hyou(61, vector<int>(61, 0));\n\tint t, n, x, y;\n\twhile (cin >> t >> n) {\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\thyou[x+30][y+30] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tqueue<Q> q;\n\t\tQ qq;\n\t\tqq.first = 0;\n\t\t(qq.second).first = x+30;\n\t\t(qq.second).second = y+30;\n\t\tq.push(qq);\n\t\tint counter = 1;\n\t\thyou[x+30][y+30] = -1;\n\t\tint dx[] = {0, 1, 1, 0, -1, -1};\n\t\tint dy[] = {1, 1, 0, -1, -1, 0};\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tif (hyou[(p.second).first+dx[i]][(p.second).second+dy[i]] == 0) {\n\t\t\t\t\tcounter++;\n\t\t\t\t\thyou[(p.second).first+dx[i]][(p.second).second+dy[i]] = -1;\n\t\t\t\t\tQ p2 = p;\n\t\t\t\t\tp2.first++;\n\t\t\t\t\t(p2.second).first += dx[i];\n\t\t\t\t\t(p2.second).second += dy[i];\n\t\t\t\t\tif (p2.first < t) {\n\t\t\t\t\t\tq.push(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nstring s = \"abcdefghijklmnopqrstuvwxyzABCDE\";\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] < INF) res++;\n      }\n    }\n    //print begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < i; j++) {\n        cout << \" \";\n      }\n      for (int j = 0; j < 61; j++) {\n        if (map[j][60-i]) cout << \"* \";\n        else if (memo[j][60-i] < INF) cout << s[memo[j][60-i]] << \" \";\n        else cout << \"X \";\n      }\n      cout << el;\n    }\n    */\n    //print end\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define PII pair<int,int>\n#define MP make_pair\nclass Data\n{\npublic:\n\tData(PII p, int t)\n\t{\n\t\tXY = p;\n\t\tT = t;\n\t}\n\tPII XY;\n\tint T;\n};\nint dx[6] = { 1,1,0,-1,-1,0 };\nint dy[6] = { 0,1,1,0,-1,-1 };\nint main()\n{\n\twhile (1)\n\t{\n\t\tint MAP[61][61] = {};\n\t\tint t, n;\n\t\tqueue <Data> q;\n\t\tcin >> t >> n;\n\t\tif (t == 0)break;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tMAP[y + 30][x + 30] = 1;\n\t\t}\n\t\tint self_x, self_y;\n\t\tcin >> self_x >> self_y;\n\t\tq.push(Data(MP(self_x+30, self_y+30),t));\n\t\tint ans = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tif (q.front().T != t)t--;\n\t\t\tif (t == -1)break;\n\t\t\tint tx = q.front().XY.first;\n\t\t\tint ty = q.front().XY.second;\n\t\t\tFOR(i, 0, 6)\n\t\t\t{\n\t\t\t\tint TX = tx + dx[i];\n\t\t\t\tint TY = ty + dy[i];\n\t\t\t\tif (TX < 0 || 60 < TX || TY < 0 || 60 < TY)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (MAP[TY][TX] != 1)\n\t\t\t\t{\n\t\t\t\t\tData temp(MP(TX, TY), t - 1);\n\t\t\t\t\tq.push(temp);\n\t\t\t\t\tif (temp.T >= 0)ans++;\n\t\t\t\t\tMAP[TY][TX] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMAP[ty][tx] = 1;\n\t\t\tq.pop();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nclass State{\npublic:\n  int x,y,cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint n,m;\nint sx,sy;\nbool t[1000][1000];\nbool closed[1000][1000];\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  int ans = 0;\n\n  while(!open.empty()){\n    State st = open.front(); open.pop();\n    if(closed[st.x][st.y] || st.cost>n || t[st.y][st.x]) continue;\n    closed[st.x][st.y] = true;\n\n    ans++;\n\n    for(int i = 0; i < 6; i++){\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx,ny,st.cost+1));\n    }\n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(cin>>n>>m,n||m){\n    memset(t,0,sizeof(t));\n    for(int i = 0; i < m; i++){\n      int x,y;\n      cin>>x>>y;\n      x += 300;\n      y += 300;\n      t[y][x] = true;\n    }\n\n    cin>>sx>>sy;\n    sx += 300;\n    sy += 300;\n\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** Brave Force Story***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define CX 35  // Center of x\n#define CY 35  // Center of y\n\nint main(){\n\tint t, n;\n\tint dx[6]={1, 1, 0, -1, -1, 0};\n\tint dy[6]={0, 1, 1, 0, -1, -1};\n\t\n\twhile(cin>>t>>n, t||n){\n\t\tint sx, sy;\n\t\tint hist[71][71];\n\t\tbool obs[71][71];\n\t\tmemset(hist, -1, sizeof hist);\n\t\tmemset(obs, false, sizeof obs);\n\t\t\n\t\tREP(i, 0, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobs[y+CY][x+CX]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tqueue<pair<int, int>> qu;\n\t\tqu.push(make_pair(sy+CY, sx+CX));\n\t\thist[sy+CY][sx+CX]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\tpair<int, int> q=qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tint y=q.first, x=q.second;\n\t\t\tREP(k, 0, 6){\n\t\t\t\tint yy=y+dy[k], xx=x+dx[k];\n\t\t\t\tif(hist[yy][xx]!=-1 || obs[yy][xx]) continue;\n\t\t\t\thist[yy][xx]=hist[y][x]+1;\n\t\t\t\tif(hist[yy][xx]<t) qu.push(make_pair(yy, xx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tREP(i, 0, 71){\n\t\t\tREP(j, 0, 71){\n\t\t\t\tif(hist[i][j]!=-1) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MIN -1000\n#define MAX 10000\n\nusing namespace std;\ntypedef struct d\n{\n\tint cx;\n\tint cy;\n\tint cd;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tfirst.cd = 0;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tint cd = d.cd;\n\t\t\tif (t <= cd)continue;\n\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (t <= cd)continue;\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == MIN)continue;\n\t\t\t\tif (map[ny][nx] != MAX)continue;\n\t\t\t\tmap[ny][nx] = cd + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.cd = cd + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != MIN && map[i][j] != MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#define dot pair<int,int>\nusing namespace std;\nint main(){\n  int dx[6]={1,-1,0,0,1,-1};\n  int dy[6]={0,0,1,-1,1,-1};\n  int field[90][90];\n  int t,n;\n  while(cin >>t>>n,t||n){\n    for(int i=0; i<90; i++) for(int j=0; j<90; j++) field[i][j] = 0;\n    for(int i=0,a,b; i<n; i++){\n      cin >>a>>b;\n      field[a+30][b+30] = 1;\n    }\n    int sx,sy;\n    cin >>sx>>sy;\n    queue<dot > f;\n    int ans = 0;\n    f.push(make_pair(30+sx,30+sy));\n    field[30+sx][30+sy] = 1;\n    while(!f.empty()){\n      ans++;\n      dot x = f.front();\n      f.pop();\n      if(field[x.first][x.second]<=t){\n\tfor(int i=0; i<6; i++){\n\t  if(field[x.first+dx[i]][x.second+dy[i]] == 0){\n\t    field[x.first+dx[i]][x.second+dy[i]] = field[x.first][x.second]+1;\n\t    f.push(make_pair(x.first+dx[i],x.second+dy[i]));\n\t  }\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\nint mass[80][80];\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nvoid dfs(int x, int y, int turn){\n  if(turn == 0) return;\n  REP(i, 6){\n    int nx = x + dx[i]; int ny = y + dy[i];\n    if(nx < 0 or nx >= 80 or ny < 0 or ny >= 80) continue;\n    if(mass[nx][ny] < turn and mass[nx][ny] >= 0) { mass[nx][ny] = turn; dfs(nx, ny, turn-1); }\n  }\n}\n\nint main(){\n  int t, n;\n  while(cin >> t >> n and t + n){\n    memset(mass, 0, sizeof(mass));\n    REP(i, n){\n      int x, y; cin >> x >> y;\n      mass[x+40][y+40] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    mass[sx+40][sy+40] = t+1;\n    dfs(sx+40, sy+40, t);\n    int res = 0;\n    REP(i, 80) REP(j, 80) if(mass[i][j] > 0) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 300;\nconst int BASE = 100;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n\n  // cout << x << \" \"  << y << endl;\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) <= 30 && abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE) <= 30 && abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint turn;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tint map[100][100];\n\t\tbool object[100][100];\n\t\tmemset(object, false, sizeof(object));\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobject[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<data> q;\n\t\tdata f;\n\t\tf.cx = sx + 50;\n\t\tf.cy = sy + 50;\n\t\tf.turn = 0;\n\t\tmap[f.cy][f.cx] = 0;\n\t\tq.push(f);\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\td.turn++;\n\t\t\tif (d.turn > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = d.cx + dx[i];\n\t\t\t\tint ny = d.cy + dy[i];\n\t\t\t\t\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 100 || ny >= 100)continue;\n\t\t\t\tif (object[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] <= d.turn)continue;\n\t\t\t\tmap[ny][nx] = d.turn;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.turn = d.turn;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MAX)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 200;\nconst int BASE = 100;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n\n  // cout << x << \" \"  << y << endl;\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) <= 30 && abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\ntypedef pair<int,int> P;\n\n//-----------------------------------------------------------------------\n\nint dy[]={0,-1,-1,0,1,1};\nint dx[]={1,0,-1,-1,0,1};\nconst int SZ=200;\nconst int off=100;\n\nint t,n;\nbool isEntry[SZ][SZ];\nbool isVisited[SZ][SZ];\n\nint bfs(int sy,int sx)\n{\n    queue<P> que;\n    isVisited[sy+off][sx+off]=true;\n    que.push(P(sy,sx));\n\n    int cnt=1;\n    REP(i,t){\n\tint sz=que.size();\n\twhile(sz--){\n\t    int y=que.front().first;\n\t    int x=que.front().second;\n\t    que.pop();\n\t    REP(j,6){\n\t\tint ny=y+dy[j],nx=x+dx[j];\n\t\tif(isEntry[ny+off][nx+off] && !isVisited[ny+off][nx+off])\n\t\t{\n\t\t    isVisited[ny+off][nx+off]=true;\n\t\t    que.push(P(ny,nx));\n\t\t    cnt++;\n\t\t}\n\t    }\n\t}\n    }\n    return cnt;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>t>>n,t)\n    {\n\tREP(i,SZ) REP(j,SZ){\n\t    isEntry[i][j]=true,isVisited[i][j]=false;\n\t}\n\tREP(i,n){\n\t    int x,y; cin>>x>>y;\n\t    isEntry[y+off][x+off]=false;\n\t}\n\tint sx,sy; cin>>sx>>sy;\n\tcout<<bfs(sy,sx)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\t//for(int i=0;i<jama.size();i++)\n\t//\t\tcout<<jama[i].first<<\"\\t\"<<jama[i].second<<endl;\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(!q.empty()&&q.front().second<=t){\n\t\t\tpiii fr=q.front();\n\t\t\tpii p=fr.first;\n\t\t\tint x=fr.first.first;\n\t\t\tint y=fr.first.second;\n\t\t\tint c=fr.second;\n\t\t\tq.pop();\n\t\t\tif(visited.find(p)!=visited.end())continue;\n\t\t\tvisited.insert(p);\n\t\t\tcerr<<\"data:\\t\"<<x<<\"\\t\"<<y<<\"\\t\"<<c<<\"\\t\"<<endl;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(x+dx[i],y+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end()){\n\t\t\t\t\tq.push(piii(cur,c+1));\n\t\t\t\t\tcerr<<\"\\t\\t\\t\\tpush:\\t\"<<cur.first<<\"\\t\"<<cur.second<<\"\\t\"<<c+1<<\"\\t\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n\n#define N 160\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nusing namespace std;\n\nint main(void)\n{\n\n\tint t,n;\n\tint xx,yy;\n\tint x,y;\n\tint start_x,start_y;\n\t\n\tint i1,i2;\n\n\tint f[N][N];\n\n\tint num;\n\tint count;\n\n\n\n\twhile(1){\n\n\t\tfor(i1=0;i1<N;i1++){\n\t\t\tfor(i2=0;i2<N;i2++){\n\t\t\t\tf[i1][i2] = 100;\n\t\t\t}\n\t\t}\n\n\t\tcin >> t;\n\t\tcin >> n;\n\t\tif(t == 0 && n == 0) break;\n\n\n\t\tfor(i1=0;i1<n;i1++){\n\t\t\tcin >> xx;\n\t\t\tcin >> yy;\n\n\n\t\t\tf[yy+(N/2)][xx+(N/2)] = 500;\n\t\t}\n\n\t\tcount = 1;\n\t\tnum = 0;\n\n\n\t\tcin >> start_x;\n\t\tcin >> start_y;\n\n\t\tstart_x += (N/2);\n\t\tstart_y += (N/2);\n\n\n\t\tqueue<pair<int, int> > q;\n\n\t\tf[start_y][start_x] = 0;\n\t\tq.push(make_pair(start_x,start_y));\n\n\n\t\twhile(!q.empty()) {\n\n\t\t\tx = q.front().first;\n\t\t\ty = q.front().second;\n\t\t\tq.pop();\n\n//\t\t\t\tcout << x << \" \" << y << \" \" << num << endl;\n\t\t\tif ( f[y][x] < t){\n\t\t\t\tnum = f[y][x];\n\n\t\t\t\tfor(i1=0;i1<6;i1++){\n\n\t\t\t\t\tif (f[y+dy[i1]][x+dx[i1]]==100){\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]] = num + 1;\n\t\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\tcout << count << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[61][61];\nint t,n;\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty() && q.front().first < t){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n\tgrid[ny][nx]=-1;\n      }\n    }\n  }\nreturn res;\n}\n\nint main(){\n    while(cin>>t>>n){\n      if(t==0 && n==0)break;\n      memset(grid,0,sizeof(grid));\n      for(int i=0;i<n;i++){\n\tint x,y;\n\tcin>>x>>y;\n\tgrid[y+30][x+30]=-1;\n      }\n      int sx,sy;\n      cin>>sx>>sy;\n      grid[sy+30][sx+30]=-1;\n      cout <<  bfs(sx+30,sy+30) << endl;\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 70;\nconst int D = 31;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint main(void){\n    for(int t, n, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vector< vector<bool> > trap(N, vector<bool>(N));\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            trap[y + D][x + D] = true;\n        }\n        rep(i, D) trap[0][i] = trap[D * 2][i] = trap[i][0] = trap[i][D * 2] = true;\n\n        pii s; cin >> s.X >> s.Y;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(mp(s.X + D, s.Y + D), 0));\n\n        while(!q.empty()){\n            pii p = q.front().first;\n            int turn = q.front().second;\n            q.pop();\n\n            if(turn == t + 1) continue;\n            if(trap[p.Y][p.X]) continue;\n\n            res++;\n            trap[p.Y][p.X] = true;\n\n            rep(i, 6){\n                q.push(mp(mp(p.X + dx[i], p.Y + dy[i]), turn + 1));\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int,int> P1;\ntypedef pair<P1,int> P2;\n\nint dx[6]={0,1,1,0,-1,-1},dy[6]={1,1,0,-1,-1,0};\n\nint main() {\n\tint n,t;\n\twhile(scanf(\"%d %d\",&t,&n),t||n) {\n\t\tmap<P1,bool> mp1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tmp1[P1(x,y)]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tqueue<P2> que;\n\t\tque.push(P2(P1(sx,sy),0));\n\t\tmap<P1,bool> mp2;\n\t\tmp2[P1(sx,sy)]=true;\n\t\tint ans=1;\n\t\twhile(!que.empty()) {\n\t\t\tP2 p2=que.front();que.pop();\n\t\t\tif(p2.second==t) break;\n\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\tint nx=p2.first.first+dx[i],ny=p2.first.second+dy[i];\n\t\t\t\tif(mp1.find(P1(nx,ny))==mp1.end()&&mp2.find(P1(nx,ny))==mp2.end()) {\n\t\t\t\t\tmp2[P1(nx,ny)]=true;ans++;\n\t\t\t\t\tque.push(P2(P1(nx,ny),p2.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define repi(i, a, b) for( int i = a; i < b; i++ )\n#define m_t 30\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nvoid dfs( int x, int y, int a ){\n    //if( a >= t ) return;\n    rep(i, 6){\n        int nx = x + dx[i];\n        int ny = (y + dy[i]) * (m_t*2 + m_t*2+1-abs(y+dy[i])) / 2;\n        if( field[zero+nx+ny] != -1 ){\n            //cout << nx << ' ' << y+dy[i] << endl;\n            if( field[zero+nx+ny] == 0 ) cnt++;\n            field[zero+nx+ny] = 1;\n            if( a+1 < t ) dfs(nx, y+dy[i], a+1);\n        }\n    }\n}\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 0 );\n        int x, y;\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = -1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 1;\n        cnt = 1;\n        dfs(sx, sy, 0);\n        /*queue<pair<int, int> > que;\n        que.push(mp(sx, sy));\n        while( !que.empty() ){\n            int cx = que.front().first;\n            int cy = que.front().second;\n            que.pop();\n            rep(i, 6){\n                int nx = cx + dx[i];\n                int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                if( field[zero+nx+ny] != -1 ){\n                    //cout << nx << ' ' << y+dy[i] << endl;\n                    field[zero+nx+ny] = field[zero+cx+cy]+1;\n                    //cnt++;\n                    if( field[zero+nx+ny] < t ) que.push(mp(nx, cy+dy[i]));\n                }\n            }\n        }*/\n        //cout << cx << ' ' << cy << endl;\n\n        /*rep(i, max){\n            if( field[i] == 1 ) cnt++;\n        }*/\n        cout << cnt << endl;\n        /*int l = 0;\n        rep(i, m_t*2+1){\n            rep(j, m_t*2+1-abs(m_t-i)){\n                cout << field[l++];\n            }\n            cout << endl;\n        }*/\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int FIRST = 30;\nconst int dx[6] = {0,1,-1,1,-1,0};\nconst int dy[6] = {1,1,0,0,-1,-1};\n\nvoid bfs(vector<vector<int> > &map,int x1,int y1,int t){\n  queue<pair<int,int> > que;\n  que.push(pair<int,int>(x1,y1));\n  map[x1][y1] = 1;\n  while(!que.empty()){\n    int x,y;\n    pair<int,int> tmp = que.front();que.pop();\n    x = tmp.first;y = tmp.second;\n    if(map[x][y] > t) continue;\n    for(int i = 0;i < 6;i++){\n      if(x+dx[i] >= 0 && x+dx[i] < 61 && y+dy[i] >= 0&& y+dy[i] < 61 ){\n\tif(map[x+dx[i]][y+dy[i]] ==  0 ){\n\t  map[x+dx[i]][y+dy[i]] = map[x][y]+1;\n\t  que.push(pair<int,int>(x+dx[i],y+dy[i]));\n\t}\n      }\n    }\n  }\n  \n}\nint solve(vector<vector<int> > &map){\n  int ans = 0;\n  for(int i = 0;i < 61;i++){\n    for(int j = 0;j < 61;j++){\n      if(map[i][j] > 0){\n\tans++;\n      }\n    }\n  }\n  return ans;\n}\nvoid fun(vector<vector<int> > map){\n  for(int i = 20;i < 41;i++){\n    for(int j = 20;j < i;j++){\n      cout << \" \" ;\n    }\n    for(int j = 20;j < 41;j++){\n      if(map[j][i] == -1){\n\tcout << 9;\n      }else{\n\tcout << map[j][i];\n      }\n    }\n    cout << endl;\n  }\n\n}\nint main(){\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(t == 0 && n == 0)break;\n    vector<vector<int > > map(61,vector<int>(61,0));\n    for(int i = 0;i < n;i++){\n      int x,y;\n      cin >> x >> y;\n      map[FIRST+x][FIRST+y] = -1;\n    }\n    int f_x,f_y;\n    cin >> f_x >> f_y;\n    \n    bfs(map,FIRST+f_x,FIRST+f_y,t);\n    //    fun(map);\n    cout << solve(map) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\t\tint ans = 1;\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\t//if (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tif (map[cy][cx] + 1 > t)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tans++;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set>\nusing namespace std;\n/*int p = 998244353;*/\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a,p - 2);\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\ntemplate<typename T>\nV<T> uni(V<T> &v) {\n\tif (v.size() == 0) { return v; }\n\tsor(v);\n\tV<T> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\ta = abs(a);\n\tb = abs(b);\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nvel dx{ 1,1,0,0,-1,-1 };\nvel dy{ 0,1,1,-1,-1,0 };\nsigned main() {\n\tvel ans;\n\twhile (true) {\n\t\tint t, n; cin >> t >> n;\n\t\tif (t == 0 and n == 0) { break; }\n\t\tV<veb> syou(150, veb(150, false));\n\t\tint x, y;\n\t\trep(i, n) { cin >> x >> y; x += 60; y += 60; syou[x][y] = true; }\n\t\tvvel dist(150, vel(150, -1));\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += 60; sy += 60;\n\t\tdist[sx][sy] = 0;\n\t\tqueue<pin> q; q.push(mkp(sx, sy));\n\t\tint count = 0;\n\t\tcount++;\n\t\twhile(!q.empty()) {\n\t\t\tpin poi = q.front(); q.pop();\n\t\t\trep(i, 6) {\n\t\t\t\tint x = poi.first + dx[i];\n\t\t\t\tint y = poi.second + dy[i];\n\t\t\t\tif (0 <= x and x < 150 and 0 <= y and y < 150) {\n\t\t\t\t\tif (dist[x][y] == -1 and !syou[x][y]) {\n\t\t\t\t\t\tq.push(mkp(x, y));\n\t\t\t\t\t\tdist[x][y] = dist[poi.first][poi.second] + 1;\n\t\t\t\t\t\tif (dist[x][y] <= t) { count++; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(count);\n\t}\n\tfor (auto x : ans) { cout << x << endl; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[] = {-1, 0, 1, 1, 0, -1};\nint dy[] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n\tfor (;;) {\n\t\tint t, n; cin >> t >> n;\n\t\tif (t == 0 && n == 0) break;\n\t\tvector< vector<int> > a(121, vector<int>(121, INT_MAX));\n\t\twhile (n--) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx += 60; y += 60;\n\t\t\ta[y][x] = 0;\n\t\t}\n\t\tint xs, ys; cin >> xs >> ys;\n\t\txs += 60; ys += 60;\n\t\ta[ys][xs] = 0;\n\t\tqueue<i_i> q;\n\t\tq.push(i_i(xs, ys));\n\t\tint ans = 0;\n\t\twhile (!q.empty()) {\n\t\t\ti_i p = q.front(); q.pop();\n\t\t\tans++;\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif (a[y][x] == t) continue;\n\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\tint _x = x + dx[k], _y = y + dy[k];\n\t\t\t\tif (a[_y][_x] > a[y][x] + 1) {\n\t\t\t\t\ta[_y][_x] = a[y][x] + 1;\n\t\t\t\t\tq.push(i_i(_x, _y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,t;};\nint main(){\n  int t,n,i,j,k,x,y;\n  cin >> t >> n;\n  while(t!=0||n!=0){\n    \n    int m[62][62]={{}};\n    int dis[62][62]={{}};\n    queue <Point> ps;\n    Point p,b;\n    for(i=0;i<n;i++){\n      cin >> x >> y;\n      dis[31+x][31+y]=1;\n    }\n    cin >> p.x  >> p.y;\n    p.x+=31;p.y+=31;\n    m[p.x][p.y]=1;\n    p.t=0;\n    ps.push(p);\n    int o=0;\n    while(!ps.empty()){\n      o++;\n      p=ps.front();\n      ps.pop();\n      if(p.t<t){\n\tif(m[p.x+1][p.y]+dis[p.x+1][p.y]==0){\n\t  b.x=p.x+1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y+1]+dis[p.x][p.y+1]==0){\n\t  b.x=p.x;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x+1][p.y+1]+dis[p.x+1][p.y+1]==0){\n\t  b.x=p.x+1;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y]+dis[p.x-1][p.y]==0){\n\t  b.x=p.x-1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y-1]+dis[p.x][p.y-1]==0){\n\t  b.x=p.x;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y-1]+dis[p.x-1][p.y-1]==0){\n\t  b.x=p.x-1;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n      }\n    }\n    cout << o << endl;\n    cin >> t >> n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dx[6] = {-1,-1, 0, 1, 1, 0};\nint dy[6] = {-1, 0, 1, 1, 0,-1};\n\nint bfs(int sy, int sx, int st, vvi& board, vvi& used){\n\n  queue<piii> que;\n  que.push(piii(pii(sy,sx),st));\n  \n  int ans = 0;\n  while(que.size()){\n    int y = que.front().first.first;\n    int x = que.front().first.second;\n    int t = que.front().second;\n    que.pop();\n    if(y > 200 || y < 0 || x > 200 || x < 0) continue; // ?£????\n    if(used[y][x]  == 1) continue;  // ??¢?´¢?????? \n    if(board[y][x] == 1) continue;;  // ?????????\n    if(t < 0) continue; // ???????????°??????\n    \n    ans++;\n    used[y][x] = 1; \n    for(int i=0; i<6; i++){\n      int nx = x + dx[i]; int ny = y + dy[i];\n      que.push(piii(pii(ny,nx),t-1));\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(!t and !n)break;\n    \n    vvi board(200,vi(200,0));\n    vvi used(200,vi(200,0));\n    for(int i=0; i<n; i++){\n      int x,y; cin >> x >> y;\n      board[y+50][x+50] = 1; // ?????????\n    }\n    int sx,sy; cin >> sx >> sy;\n    cout << bfs(sy+50,sx+50,t,board,used) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint zz[121][121]={0};\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tint z[121][121],ka[121][121];\n\t\tfor(int x=0;x<=120;x++){\n\t\t\tfor(int y=0;y<=120;y++){\n\t\t\t\tz[x][y]=zz[x][y];\n\t\t\t\tka[x][y]=zz[x][y];\n\t\t\t}\n\t\t}\n\t\tif(t==0&&n==0) break;\n\t\tint x,y,ct=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tz[x+60][y+60]=2;\n\t\t\tka[x+60][y+60]=2;\n\t\t}\n\t\tcin>>x>>y;\n\t\tz[x+60][y+60]=1;\n\t\tka[x+60][y+60]=1;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tfor(int j=0;j<=120;j++){\n\t\t\t\tfor(int k=0;k<=120;k++){\n\t\t\t\t\tif(z[j][k]==1){\n\t\t\t\t\t\tif(z[j-1][k]==0){\n\t\t\t\t\t\t\tka[j-1][k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j+1][k]==0){\n\t\t\t\t\t\t\tka[j+1][k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j][k-1]==0){\n\t\t\t\t\t\t\tka[j][k-1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j][k+1]==0){\n\t\t\t\t\t\t\tka[j][k+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j+1][k+1]==0){\n\t\t\t\t\t\t\tka[j+1][k+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j-1][k-1]==0){\n\t\t\t\t\t\t\tka[j-1][k-1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=120;j++){\n\t\t\t\tfor(int k=0;k<=120;k++){\n\t\t\t\t\tz[j][k]=ka[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tfor(int k=0;k<=120;k++){\n\t\t\t\tif(z[j][k]==1) ct++;\n\t\t\t}\n\t\t}\n\t\tcout<<ct<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nint ans_count,T,N,table[200][200],div_x[6] = {0,1,-1,1,-1,0},div_y[6] = {1,1,0,0,-1,-1};\nint BASE = 100;\n\nbool rangeCheck(int x,int y){\n\tif(abs(x) <= T && abs(y) <= T)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int x,int y,int turn){\n\tfor(int i = 0; i < 6; i++){\n\t\tif(turn <= T && table[BASE+y+div_y[i]][BASE+x+div_x[i]] != -1){\n\t\t\tif(table[BASE+y+div_y[i]][BASE+x+div_x[i]] == 0){\n\t\t\t\ttable[BASE+y+div_y[i]][BASE+x+div_x[i]] = turn;\n\t\t\t\tans_count++;\n\t\t\t\trecursive(x+div_x[i],y+div_y[i],turn+1);\n\t\t\t}else if(table[BASE+y+div_y[i]][BASE+x+div_x[i]] > turn){\n\t\t\t\ttable[BASE+y+div_y[i]][BASE+x+div_x[i]] = turn;\n\t\t\t\trecursive(x+div_x[i],y+div_y[i],turn+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200;i++){\n\t\tfor(int k = 0; k < 200;k++)table[i][k] = 0;\n\t}\n\n\tint x,y;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\n\t\ttable[BASE+y][BASE+x] = -1;\n\t}\n\n\tscanf(\"%d %d\",&x,&y);\n\n\ttable[BASE+y][BASE+x] = 1;\n\n\tans_count = 1;\n\n\trecursive(x,y,1);\n\n\tprintf(\"%d\\n\",ans_count);\n\n}\n\nint main(){\n\n   while(true){\n\t   scanf(\"%d %d\",&T,&N);\n\t   if(T == 0 && N == 0)break;\n\n\t   func();\n   }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\n#define REP(i,n)  for(int i=0;i<n;i++)\n\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> p;\n\tq1.push(make_pair(0,pale_pair(y,x)));\n\twhile(!p1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] = 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,ma;e_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0)\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint dx[6] = {1,1,0,-1,-1,0}, dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n\tint t,n;\n\twhile(scanf(\"%d%d\", &t, &n),t||n){\n\t\tint deta[100][100];\n\t\tint cost[100][100];\n\t\trep(i,100) rep(j,100) deta[i][j] = 0;\n\t\trep(i,100) rep(j,100) cost[i][j] = INF;\n\t\trep(i,n){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tx += 50; y += 50;\n\t\t\tdeta[x][y] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tsx += 50; sy += 50;\n\t\tdeta[sx][sy] = 2;\n\t\tcost[sx][sy] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(sx,sy));\n\t\twhile(que.size() != 0){\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(i,6){\n\t\t\t\tP tmp = p;\n\t\t\t\ttmp.fi += dx[i];\n\t\t\t\ttmp.sec += dy[i];\n\t\t\t\tif(deta[tmp.fi][tmp.sec] == 0 && cost[tmp.fi][tmp.sec] > cost[p.fi][p.sec]+1){\n\t\t\t\t\tdeta[tmp.fi][tmp.sec] = 2;\n\t\t\t\t\tcost[tmp.fi][tmp.sec] = cost[p.fi][p.sec]+1;\n\t\t\t\t\tif(cost[tmp.fi][tmp.sec] != t) que.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i,100) rep(j,100){\n\t\t\tif(deta[i][j] == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint main() {\n  int t, n;\n  while(cin >> t >> n && (t|n)) {\n    int M[121][121] = {};\n    int const BX = 60, BY = 60;\n    for(int i=0; i<n; i++) {\n      int x, y;\n      cin >> x >> y;\n      M[y+BY][x+BX] = 1;\n    }\n    \n    int const dx[] = {-1,1,0,0,1,-1};\n    int const dy[] = {0,0,-1,1,1,-1};\n    \n    typedef pair<int, int> Pii;\n    typedef pair<Pii, int> P;\n    \n    bool used[121][121] = {};\n    int ans = 0;\n    \n    int sx, sy;\n    cin >> sx >> sy; sx += BX, sy += BY;\n    \n    queue<P> Q;\n    Q.push(P(Pii(sx, sy), t));\n    used[sy][sx] = true;\n    \n    while(!Q.empty()) {\n      P const p = Q.front(); Q.pop();\n      ans ++;\n      \n      if(p.snd <= 0) continue;\n      \n      for(int i=0; i<6; i++) {\n\tint nx = p.fst.fst + dx[i], ny = p.fst.snd + dy[i];\n\tif(!used[ny][nx] && M[ny][nx] == 0) {\n\t  Q.push( P(Pii(nx, ny), p.snd-1) );\n\t  used[ny][nx] = true;\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    //print1 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) cout << \"X \";\n        else cout << memo[i][j] << \" \";\n      }\n      cout << el;\n    }\n    */\n    //print1 end\n    // print2 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          if (map[30-i+j][60-i]) cout << \"* \";\n          else if (memo[30-i+j][60-i] == INF) cout << \"X \";\n          else cout << memo[30-i+j][60-i] << \" \";\n        }\n        if (map[60][60-i]) cout << \"*\";\n        else if (memo[60][60-i] == INF) cout << \"X\";\n        else cout << memo[60][60-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (map[j][30]) cout << \"* \";\n          else if (memo[j][30] == INF) cout << \"X \";\n          else cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          if (map[j][60-i]) cout << \"* \";\n          else if (memo[j][60-i] == INF) cout << \"X \";\n          else cout << memo[j][60-i] << \" \";\n        }\n        if (map[90-i][60-i]) cout << \"*\";\n        else if (memo[90-i][60-i] == INF) cout << \"X\";\n        else cout << memo[90-i][60-i];\n      }\n      cout << el;\n    }\n    */\n    // prin2 end\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j <= 30 + i; j++) {\n          if (memo[30-i+j][60-i] < INF) res++;\n        }\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (memo[j][30] < INF) res++;\n        }\n      } else {\n        for (int j = 0; j <= 90 - i; j++) {\n          if (memo[j][60-i] < INF) res++;;\n        }\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define N 100\n#define G 50\n#define KABE -1\n#define NON  0\n\nint map[N][N];\n\nint ans;\nvoid dfs(int x, int y, int t ){\n  if( t<0 )\n    return;\n  if( map[x][y] == KABE )\n    return;\n\n  if( abs(x-G) > 30 ||  abs(y-G) > 30 )\n    return;\n\n  if( map[x][y] >= t )\n    return;\n\n  if( map[x][y] == NON )\n    ans++;\n  map[x][y] = t;\n\n\n  t--;\n  int dx[] = {1,1,0,-1,-1, 0};\n  int dy[] = {0,1,1, 0,-1,-1};\n  for( int d=0;d<6;d++ )\n    dfs(x+dx[d], y+dy[d], t );\n}\n\nint main(){\n  int t,n;\n  while( cin>>t>>n && (t|n) ){\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\tmap[i][j] = NON;\n\n    int y,x;\n    while( n-- ){\n      cin >> x >> y;\n      map[x+G][y+G] = KABE;\n    }\n    cin >> x >> y;\n\n    x+=G; y+=G;\n    ans = 0;\n    dfs(x, y, t+1 );\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n//#include <cmath>\n//#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        //fill( field.begin(), field.end(), 1 );  // reset\n        rep(i, max) field[i] = 1;\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[200][200];\nint t,n;\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty() && q.front().first < t){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n\tgrid[ny][nx]=-1;\n      }\n    }\n  }\nreturn res;\n}\n\nint main(){\n    while(cin>>t>>n){\n      if(t==0 && n==0)break;\n      memset(grid,0,sizeof(grid));\n      for(int i=0;i<n;i++){\n\tint x,y;\n\tcin>>x>>y;\n\tgrid[y+30][x+30]=-1;\n      }\n      int sx,sy;\n      cin>>sx>>sy;\n      grid[sy+30][sx+30]=-1;\n      cout <<  bfs(sx+30,sy+30) << endl;\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nint dy[]={1, 1, 0, 0, -1, -1};\nint dx[]={1, 0, 1, -1, 0, -1};\ntypedef pair<int, int> pii;\n\nint main(){\n\n    while(1){\n        int t, n;\n        cin>> t>> n;\n        if(!(t||n)) break;\n        int px[n], py[n];\n        for(int i=0; i<n; i++){\n            cin>> px[i]>> py[i];\n        }\n        int sx, sy;\n        cin>> sx>> sy;\n\n        int K=100;\n        int a[K][K];\n        for(int i=0; i<K; i++){\n            for(int j=0; j<K; j++){\n                a[i][j]=0;\n            }\n        }\n        for(int i=0; i<n; i++){\n            a[py[i]+K/2][px[i]+K/2]=-1;\n        }\n\n        queue<tuple<int, int, int>> Q;\n        Q.push(make_tuple(sy+K/2, sx+K/2, 0));\n        a[sy+K/2][sx+K/2]=1;\n        while(!Q.empty()){\n            int i, j, turn;\n            tie(i, j, turn)=Q.front(); Q.pop();\n            if(turn==t) continue;\n            for(int k=0; k<6; k++){\n                int ni=i+dy[k];\n                int nj=j+dx[k];\n                if(a[ni][nj]==0){\n                    a[ni][nj]=1;\n                    Q.push(make_tuple(ni, nj, turn+1));\n                }\n            }\n        }\n\n        int s=0;\n        for(int i=0; i<K; i++){\n            for(int j=0; j<K; j++){\n                s+=(a[i][j]==1);\n            }\n        }\n\n\n        cout<< s<< endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[100][100];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])>t || abs(sx-data[1][i])>t){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (50-sx);\n\t\t\ttmpY += (50-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=50;\n\t\tsy=50;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\n\nint board[64][64];\nint geta = 32;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  while (1) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    memset(board, 0, sizeof(board));\n    REP(i, n) {\n      \n      int x, y;\n      cin >> x >> y;\n      board[x+geta][y+geta] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    queue<T> que;\n    que.push(T(sx, sy, t));\n\n    while (!que.empty()) {\n      int x, y, rest;\n      tie(x, y, rest) = que.front();\n      que.pop();\n\n      if (rest < 0 || board[y+geta][x+geta] != 0) continue;\n\n      board[y+geta][x+geta] = 1;\n      REP(i, 6) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\t  que.push(T(nx, ny, rest - 1));\n      }\n    }      \n      \n    int ans = 0;\n    for (int y = -30; y <= 30; y++) {\n      for (int x = -30; x <= 30; x++) {\n\tans += board[y+geta][x+geta] > 0;\n      }\n    }\n    cout << ans << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nint dx[6]={-1,-1, 0, 0, 1, 1};\nint dy[6]={-1, 0,-1, 1, 0, 1};\n\nstruct info{\n    int x;\n    int y;\n    int t;\n    info(int x, int y, int t):x(x),y(y),t(t){}\n};\n\nint main(){\n    while(1){\n        int t,n;\n        cin >> t >> n;\n        if(t==0) break;\n\n        vector<vector<bool> > map(61, vector<bool>(61,true));\n        for(int i=0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            map[x+30][y+30]=false;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=30; sy+=30;\n\n        int count = 1;\n        map[sx][sy]=false;   \n        queue<info> q;\n        q.push(info(sx,sy,t));\n        while(!q.empty()){\n            info now = q.front();\n            q.pop();\n            if(now.t<=0) continue;\n            for(int i=0; i<6; i++){\n                if(map[now.x+dx[i]][now.y+dy[i]]){\n                    count++;\n                    map[now.x+dx[i]][now.y+dy[i]] = false;\n                    q.push(info(now.x+dx[i], now.y+dy[i], now.t-1));\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tvector< vector<int> > hyou(61, vector<int>(61, 0));\n\tint t, n, x, y;\n\twhile (cin >> t >> n) {\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\thyou[x+30][y+30] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tqueue<Q> q;\n\t\tQ qq;\n\t\tqq.first = 0;\n\t\t(qq.second).first = x+30;\n\t\t(qq.second).second = y+30;\n\t\tq.push(qq);\n\t\tint counter = 1;\n\t\thyou[x+30][y+30] = -1;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tif ((p.second).second+1 <= 60 && hyou[(p.second).first][(p.second).second+1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first][(p.second).second+1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).second++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((p.second).first+1 <= 60 && (p.second).second+1 <= 60 && hyou[(p.second).first+1][(p.second).second+1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first+1][(p.second).second+1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first++;\n\t\t\t\t(p2.second).second++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((p.second).first+1 <= 60 && hyou[(p.second).first+1][(p.second).second] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first+1][(p.second).second] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((p.second).second-1 >= 0 && hyou[(p.second).first][(p.second).second-1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first][(p.second).second-1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).second--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((p.second).first-1 >= 0 && (p.second).second-1 >= 0 && hyou[(p.second).first-1][(p.second).second-1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first-1][(p.second).second-1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first--;\n\t\t\t\t(p2.second).second--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((p.second).first-1 >= 0 && hyou[(p.second).first-1][(p.second).second] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first-1][(p.second).second] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <stack>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\nint g[100][100];\nint used[100][100];\nint ans=0;\n\nvoid dfs(int i, int j, int times){\n    if(times<0 or used[i][j]>=times or g[i][j]==1) return;\n    if(used[i][j]==-1) ans++;\n    used[i][j]=times;\n    dfs(i+1, j,times-1);\n    dfs(i-1, j,times-1);\n    dfs(i, j+1,times-1);\n    dfs(i, j-1,times-1);\n    dfs(i+1, j+1,times-1);\n    dfs(i-1, j-1,times-1);\n}\n\nint main(){\n    for (;;) {\n        int t,n;\n        cin >> t >> n;\n        if(!t and !n)break;\n        memset(g, 0, sizeof(g));\n        memset(used, -1, sizeof(used));\n        ans = 0;\n        for (int i=0; i<n; i++) {\n            int x,y;\n            cin >> x >> y;\n            g[x+50][y+50]=1;\n        }\n        int xx,yy;\n        cin >> xx >> yy;\n        dfs(xx+50,yy+50,t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int x,y,t;\n};\n\nint T,N;\nint F[311][311];\nint H[311][311];\n\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\n\nint main(){\n  while( cin >> T >> N && (T||N) ){\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin >> x >> y;\n      x+=150; y+=150;\n      F[x][y] = 1;\n    }\n    int x,y;\n    cin >> x >> y;\n    x+=150; y+=150;\n    queue<state> q;\n    q.push(  (state){x,y,0} );\n    H[x][y] = 1;\n    while( !q.empty() ){\n      state p = q.front(); q.pop();\n      if( p.t == T ) continue;\n      for(int i=0;i<6;i++){\n\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\tif( F[nx][ny] ) continue;\n\tif( !H[nx][ny] ) {\n\t  H[nx][ny] = 1;\n\t  q.push( (state){nx,ny,p.t+1} );\n\t}\n      }\n    }\n    int cnt = 0;\n    for(int i=0;i<=300;i++){\n      for(int j=0;j<=300;j++){\n\tif( H[j][i] ) cnt++;\n      }\n    }\n    cout << cnt << endl;\n    memset(H,0,sizeof(H));\n    memset(F,0,sizeof(F));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <complex>\n#include <queue>\nusing namespace std;\n#define P pair<int, int>\n#define PP pair<int, P>\n#define mp(a, b) make_pair(a, b)\n\nint main() {\n  int t, n;\n  while (cin >> t >> n, t|n) {\n    vector<vector<int> > f(61, vector<int>(61, 0));\n    vector<vector<int> > v(61, vector<int>(61, 100));\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      v[x+30][y+30] = 0;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    int cnt = 0;\n    queue<PP> q;\n    q.push(mp(0,mp(sx+30, sy+30)));\n    const int dx[] = {1, 1, 0,  0, -1, -1};\n    const int dy[] = {0, 1, 1, -1,  0, -1};\n\n    while (!q.empty()) {\n      int c = q.front().first;\n      P p = q.front().second;\n      q.pop();\n      if (v[p.first][p.second] < c) continue;\n      if (!f[p.first][p.second]) cnt++;\n      v[p.first][p.second] = c;\n      f[p.first][p.second] = 1;\n      for (int i = 0; i < 6; i++) {\n        int xx = p.first  + dx[i];\n        int yy = p.second + dy[i];\n        if (xx >= 0 && xx < 61 && yy >= 0 && yy < 61 && c < t) {\n          q.push(mp(c+1,mp(xx, yy)));\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mLife;\n  int mX;\n  int mY;\n  State(int life,int x,int y) : mLife(life), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mLife < s.mLife;\n  }\n\n  bool operator >(const State& s) const{\n    return mLife > s.mLife;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State> > que;\n    que.push(State(t,sx,sy));\n    stage[P(sx,sy)] = t;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\tif(abs(dx) > 30 || abs(dy) > 30) continue;\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && stage[P(dx,dy)] <= s.mLife-1) continue;\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && s.mLife-1 < 0) continue;\n\n\tstage[P(dx,dy)] = s.mLife-1;\n\tque.push(State(s.mLife-1,dx,dy));\n      }\n    }\n\n    int res = CoundVisitedCell(stage);\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fo(n) for(int i = 0; i < n; i++)\n\nint mapa[300][300], sx,sy, t,counta;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n  queue <P> Q;\n  mapa[sx][sy]=1;\n  Q.push(P(sx,sy));\n  while(!Q.empty()){\n    P p = Q.front();Q.pop();\n    int x = p.first, y = p.second;\n    counta++;\n    if(mapa[x][y] == t) continue;\n    for(int i = -1; i <= 1; i++){\n      for(int j = -1; j <= 1; j++){\n\tif((i==-1&&j==1)||(i==1&&j==-1)||(i==0&&j==0))continue;\n\tint nx = x+i,ny = y+j;\n\tif(mapa[nx][ny] == 0){//cout<<nx<<\" \"<<ny<<endl;cout<<mapa[nx][ny]<<endl<<endl;\n\t  Q.push(P(nx,ny));\n\t  mapa[nx][ny] +=mapa[x][y]+1;\n\t}\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, x, y;\n  while(1){\n    cin>>t>>n;\n    if(!t&&!n)break;\n    t++;\n    for(int i = 0; i < 300; i++)for(int j = 0; j < 300; j++)mapa[i][j] = 0;\n    counta = 0;\n    for(int i = 0; i < n; i++){\n      cin>>x>>y;\n      mapa[100+x][100+y] = -1;\n    }\n    cin>>sx>>sy;\n    sx+=100; sy+=100;\n    bfs();\n    cout<<counta<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n;\n\tvvi field(61,vi(61,0));\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=30,y+=30;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=1;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nstruct pr{\n\tint nx,ny,cnt;\n};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pr>q;\n\t\tpr p;\n\t\tp.nx=sx;p.ny=sy;p.cnt=0;\n\t\tq.push(p);\n\t\twhile(!q.empty()){\n\t\t\tpr pi=q.front();q.pop();\n\t\t\tint x=pi.nx;\n\t\t\tint y=pi.ny;\n\t\t\tint tt=pi.cnt;\n\t\t\tif(tt>=t)continue;\n\t\t\tREP(j,6)if(!flag[x+dx[j]][y+dy[j]]&&!mp[x+dx[j]][y+dy[j]]){\n\t\t\t\tflag[x+dx[j]][y+dy[j]]=true;\n\t\t\t\tsum++;\n\t\t\t\tpr p2;p2.nx=x+dx[j];p2.ny=y+dy[j];p2.cnt=tt+1;\n\t\t\t\tq.push(p2);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y; if(x+30 > 61 || x+30 < 0 || y+30 > 61 || y+30 <0)break;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\n\nstruct Node\n{\n\tint x, y, turn;\n};\n\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<bool, 121>, 121> field;\n\t\tint dx[] = { 1, 0, -1, -1, 0, 1 };\n\t\tint dy[] = { 0, -1, -1, 0, 1, 1 };\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\tfield = { { 0 } };\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 60][x + 60] = true;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 60][startX + 60] = true;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX + 60, startY + 60, 0 });\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 120 || next.y < 0 || next.y > 120) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = true;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (next.turn >= t) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dx[6] = {-1,-1, 0, 1, 1, 0};\nint dy[6] = {-1, 0, 1, 1, 0,-1};\n\nint bfs(int sy, int sx, int st, vvi& board, vvi& used){\n\n  queue<piii> que;\n  que.push(piii(pii(sy,sx),st));\n  \n  int ans = 0;\n  while(que.size()){\n    int y = que.front().first.first;\n    int x = que.front().first.second;\n    int t = que.front().second;\n    que.pop();\n    if(y > 100 || y < 0 || x > 100 || x < 0) continue; // ?£????\n    if(used[y][x]  == 1) continue;  // ??¢?´¢?????? \n    if(board[y][x] == 1) continue;;  // ?????????\n    if(t < 0) continue; // ???????????°??????\n    \n    ans++;\n    used[y][x] = 1; \n    for(int i=0; i<6; i++){\n      int nx = x + dx[i]; int ny = y + dy[i];\n      que.push(piii(pii(ny,nx),t-1));\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(!t and !n)break;\n    \n    vvi board(100,vi(100,0));\n    vvi used(100,vi(100,0));\n    for(int i=0; i<n; i++){\n      int x,y; cin >> x >> y;\n      board[y+50][x+50] = 1; // ?????????\n    }\n    int sx,sy; cin >> sx >> sy;\n    cout << bfs(sy+50,sx+50,t,board,used) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint main(){\n\tint t,N;\n\tint dx[6]={1,1,0,-1,-1,0};\n\tint dy[6]={0,1,1,0,-1,-1};\n\twhile(cin>>t>>N && (t!=0||N!=0)){\n\t\tint visited[121][121]={0};\n\t\tint tx,ty,ans=1;\n\t\tqueue<pair<int,int>> q;\n\t\tREP(i,0,N){\n\t\t\tcin>>tx>>ty;\n\t\t\tvisited[ty+60][tx+60]=-1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tq.push({sx+60,sy+60});\n\t\tvisited[sy+60][sx+60]=1;\n\t\twhile(!q.empty()){\n\t\t\tint nowx=q.front().first,nowy=q.front().second;\n\t\t\tq.pop();\n\t\t\tREP(k,0,6){\n\t\t\t\tint nextx=nowx+dx[k],nexty=nowy+dy[k];\n\t\t\t\tif(visited[nexty][nextx]!=0) continue;\n\t\t\t\tvisited[nexty][nextx]=visited[nowy][nowx]+1;\n\t\t\t\tans++;\n\t\t\t\tif(visited[nexty][nextx]<=t)\tq.push({nextx,nexty});\n\t\t\t}\n\t\t}\n\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\n\nvoid bfs(int y,int x,int et){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(1);\n    u[y+35][x+35]=t;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t>et) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t+1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXY 128\n#define MAXX 128\ntypedef long long ll;\nconst int dx[] = {1, 1, 0, -1, -1, 0};\nconst int dy[] = {0, 1, 1, 0, -1, -1};\n\n//bool done[MAXY][MAXX];\nint d[MAXY][MAXX];\n\nint main(void) {\n    int t, n;\n    while (1) {\n        cin >> t >> n;\n        if (t == 0 && n == 0) break;\n        for (int i = 0; i < MAXY; i++) {\n            for (int j = 0; j < MAXX; j++) {\n                //done[i][j] = false;\n                d[i][j] = -1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            d[y+64][x+64] = -2;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 64; sy += 64;\n        queue<int> X;\n        queue<int> Y;\n        X.push(sx); Y.push(sy);\n        d[sy][sx] = 0;\n        while (!X.empty()) {\n            int x = X.front(); X.pop();\n            int y = Y.front(); Y.pop();\n            if (d[y][x] >= t) continue;\n            for (int i = 0; i < 6; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (d[ny][nx] == -1) {\n                    d[ny][nx] = d[y][x] + 1;\n                    X.push(nx); Y.push(ny);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < MAXY; i++) {\n            for (int j = 0; j < MAXX; j++) {\n                if (d[i][j] >= 0) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nbool isRange(int x,int y){\n\n    return -30<=x && x<=30 && -30<=y && y<=30;\n}\nint main(){\n    int t,n;\n    int dx[6]={1,1,0,-1,-1,0};\n    int dy[6]={1,0,-1,-1,0,1};\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+30][y+30]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first+30][s.second+30]=1;\n        int cnt=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        while(!q.empty()){\n            auto state=q.front();\n            q.pop();\n            auto p=state.first;\n            int turn=state.second;\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isRange(tox,toy) && !ob[tox+30][toy+30] && !been[tox+30][toy+30]){\n                    been[tox+30][toy+30]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n                }\n\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint x[100][100][2], n, m, c, d, i, j, k, sum;\n#define A(B,C) if(x[B][C][0]==0 && x[B][C][1]==0){x[B][C][0]=2;sum++;}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0) { break; }sum = 0; memset(x, 0, sizeof(x));\n\t\tfor (i = 0; i < m; i++) { cin >> c >> d; x[c + 50][d + 50][1] = 1; }x[50][50][0] = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 20; j < 81; j++) {\n\t\t\t\tfor (k = 20; k < 81; k++) {\n\t\t\t\t\tif (x[j][k][0] == 1) {\n\t\t\t\t\t\tA(j - 1, k - 1);\n\t\t\t\t\t\tA(j - 1, k);\n\t\t\t\t\t\tA(j, k - 1);\n\t\t\t\t\t\tA(j, k + 1);\n\t\t\t\t\t\tA(j + 1, k);\n\t\t\t\t\t\tA(j + 1, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 20; j < 81; j++) { for (k = 20; k < 81; k++) { if (x[j][k][0] == 2) { x[j][k][0] = 1; } } }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dx[] = { 1, 0, -1, -1, 0, 1 };\nconst int dy[] = { 0, -1, -1, 0, 1, 1 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint t, n;\n\t\tcin >> t >> n;\n\n\t\tif ( !( t | n ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<PII> objects;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobjects.PB( MP( x, y ) );\n\t\t}\n\t\tsort( ALL( objects ) );\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<PII> que;\n\t\tque.push( MP( sx, sy ) );\n\t\tmap<PII,int> distance;\n\t\tdistance[ MP( sx, sy ) ] = 0;\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tauto cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( distance[ cur ] == t )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( d, 0, 6 )\n\t\t\t{\n\t\t\t\tauto next( cur );\n\t\t\t\tnext.fst += dx[d];\n\t\t\t\tnext.snd += dy[d];\n\n\t\t\t\tif ( abs( next.fst ) <= 30 && abs( next.snd ) <= 30 &&\n\t\t\t\t\t !binary_search( ALL( objects ), next ) && !EXIST( distance, next ) )\n\t\t\t\t{\n\t\t\t\t\tque.push( next );\n\t\t\t\t\tdistance[ next ] = distance[ cur ] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << distance.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nusing namespace std;\n   \n#define INF 1000000\n#define WALL -1\n\nstruct S{\n\tint x,y,t;\n};\n\nint main(void){\n      \n    int fi[63][63]; ///-30~30 -> 1~61 //\n\tint t,n;\n\tint x,y;\n\tint dy[]={ 1, 1, 0,-1,-1, 0};\n\tint dx[]={ 0, 1, 1, 0,-1,-1};\n\tint cnt;\n\tstack<S> s;\n\tS s1,s2;\n\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=0;i<63;i++){\n\t\t\tfor(int j=0;j<63;j++){\n\t\t\t\tfi[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<63;i++){\n\t\t\tfi[0][i]=WALL;\n\t\t\tfi[62][i]=WALL;\n\t\t\tfi[i][0]=WALL;\n\t\t\tfi[i][62]=WALL;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tfi[y+31][x+31]=WALL;\n\t\t}\n\t\tcin>>x>>y;\n\t\ts1.x=x+31,s1.y=y+31,s1.t=0;\n\t\tfi[y+31][x+31]=0;\n\t\tcnt=1;\n\t\ts.push(s1);\n\t\twhile(!s.empty()){\n\t\t\ts1=s.top();\n\t\t\ts.pop();\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(fi[s1.y][s1.x]+1<fi[s1.y+dy[i]][s1.x+dx[i]]){\n\t\t\t\t\tif(fi[s1.y+dy[i]][s1.x+dx[i]]==INF) cnt++;\n\t\t\t\t\tfi[s1.y+dy[i]][s1.x+dx[i]]=fi[s1.y][s1.x]+1;\n\t\t\t\t\ts2.x=s1.x+dx[i],s2.y=s1.y+dy[i],s2.t=fi[s1.y][s1.x]+1;\n\t\t\t\t\tif(s2.t!=t) s.push(s2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int turn, n;\n        cin >> turn >> n;\n        if (turn == 0)break;\n        vector<vector<bool>> can(300, vector<bool>(300, true));\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            can[x + 100][y + 100] = false;\n        }\n        int fx, fy;\n        cin >> fx >> fy;\n        can[fx + 100][fy + 100] = false;\n\n        queue<vector<int>> que;\n        que.push({fx + 100, fy + 100});\n        que.push({-1, -1});\n        int depth = 1;\n\n        vector<vector<int>> moves = {{1,  1},\n                                     {1,  0},\n                                     {0,  1},\n                                     {0,  -1},\n                                     {-1, 0},\n                                     {-1, -1}};\n        int ret = 0;\n        while (depth <= turn) {\n            vector<int> now = que.front();\n            que.pop();\n            if (now[0] < 0) {\n                depth++;\n                que.push({-1, -1});\n            } else {\n                for (auto move:moves) {\n                    if (can[now[0] + move[0]][now[1] + move[1]]) {\n                        ret++;\n                        que.push({now[0] + move[0], now[1] + move[1]});\n                        can[now[0] + move[0]][now[1] + move[1]] = false;\n                    }\n                }\n            }\n        }\n        cout << ret + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint t,n;\nint board[200][200];\n\nint di[6]={1,1,0,0,-1,-1};\nint dj[6]={0,1,-1,1,-1,0};\n\n/*\nvoid dfs(int i,int j,int turn){\n\tif(turn==t+1)return;\n\tboard[i][j]=2;\n\tcnt++;\n\trep(d,6){\n\t\tint ni=i+di[d],nj=j+dj[d];\n\t\tif(ni<0||nj<0||ni>=200||nj>=200||board[ni][nj]!=0)continue;\n\t\tdfs(ni,nj,turn+1);\n\t}\n}*/\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0)break;\n\t\tmemset(board,0,sizeof(board));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=100; y+=100;\n\t\t\tboard[y][x]=1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=100; sy+=100;\n\t\tint res=0;\n\t\tqueue<PPI> que;\n\t\tque.push(PPI(P(sy,sx),0));\n\t\tboard[sy][sx]=2;\n\t\twhile(!que.empty()){\n\t\t\tint i=que.front().fi.fi,j=que.front().fi.se,turn=que.front().se; que.pop();\n\t\t\tres++;\n\t\t\trep(d,6){\n\t\t\t\tint ni=i+di[d],nj=j+dj[d];\n\t\t\t\tif(ni<0||nj<0||ni>=200||nj>=200||board[ni][nj]!=0)continue;\n\t\t\t\tif(turn<t){\n\t\t\t\t\tboard[ni][nj]=2;\n\t\t\t\t\tque.push(PPI(P(ni,nj),turn+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <stack>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\nint g[200][200];\nint used[200][200];\nint ans=0;\n\nvoid dfs(int i, int j, int times){\n    if(times<0 or used[i][j]>=times or g[i][j]==1) return;\n    if(used[i][j]==-1) ans++;\n    used[i][j]=times;\n    dfs(i+1, j,times-1);\n    dfs(i-1, j,times-1);\n    dfs(i, j+1,times-1);\n    dfs(i, j-1,times-1);\n    dfs(i+1, j+1,times-1);\n    dfs(i-1, j-1,times-1);\n}\n\nint main(){\n    for (;;) {\n        int t,n;\n        cin >> t >> n;\n        if(!t and !n)break;\n        memset(g, 0, sizeof(g));\n        memset(used, -1, sizeof(used));\n        ans = 0;\n        for (int i=0; i<n; i++) {\n            int x,y;\n            cin >> x >> y;\n            g[x+100][y+100]=1;\n        }\n        int xx,yy;\n        cin >> xx >> yy;\n        dfs(xx+100,yy+100,t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nint n,t;\nmap<pii,int> mp;\nset<pii> s;\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\nint solve(){\n    mp.clear(); s.clear();\n    int res = 0;\n    for(int i = 0; i < n;i++){\n        int x,y; cin >> x >> y;\n        s.insert(make_pair(x,y));\n    }\n    int x,y; cin >> x >> y;\n    using piii = pair<pii,int>;\n    queue<piii> q; q.push({{x,y},1});\n//    mp[make_pair(x,y)] = 1;\n    while(q.size()){\n        int T,X,Y; auto P = q.front(); q.pop();\n        T = P.second; tie(X,Y) = P.first;\n        if(mp[{X,Y}] == 0 || mp[{X,Y}] > T){\n            mp[{X,Y}] = T;\n        }else{\n            continue;\n        }\n        if(T > t) continue;\n        for(int k = 0; k < 6;k++){\n            int nX = X + dx[k],nY = Y + dy[k];\n            if(s.find({nX,nY}) != s.end()) continue;\n            q.push({{nX,nY},T+1});\n        }\n    }\n    res = (int)mp.size();\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> t >> n,t){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, k, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k;\n\t\tif (n == 0 && k == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\ty[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (x[j][k] == 0 && y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (x[dx[l] + j][dy[l] + k] == 0) {\n\t\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= n) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tP p_(x,y);\n\t\tint cnt = f[p_] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << cnt << endl;\n\t\tif( cnt > t+1 )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p] == -1 ) continue;\n\t\t\t\n\t\t\tif( f[p] == 0 ){\n\t\t\t\tf[p] = cnt;\n\t\t\t\tque.push( p );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -1;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 1;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tsolve( t , f , que );\n\t\tint ans = 0;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] > 0 ) ans++;\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int x,y;\n  int dx[] = {1,0,1,-1,0,-1};\n  int dy[] = {0,1,1,0,-1,-1};\n  int map[200][200];\n  int t,n,ans;\n  queue<int> qx,qy;\n\n  while(1){\n    cin >> t >> n;\n    if(!t && !n)break;\n\n    memset(map,0,sizeof(map));\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      map[100+y][100+x] = -1;\n    }\n\n    cin >> x >> y;\n    map[100+y][100+x] = 1;\n    qx.push(x);\n    qy.push(y);\n\n    ans = 1;\n    while(qx.size()){\n      x = qx.front();\n      y = qy.front();\n      qx.pop();\n      qy.pop();\n\n      if(map[100+y][100+x]<=t){\n\tfor(int i=0;i<6;i++){\n\t  if(map[100+y+dy[i]][100+x+dx[i]] == 0){\n\t    qx.push(x+dx[i]);\n\t    qy.push(y+dy[i]);\n\t    map[100+y+dy[i]][100+x+dx[i]] = map[100+y][100+x] + 1;\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > t) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            REP(i, 6){\n                if(cur.first + dy[i] >= 0 && cur.first + dy[i] <= 64 && cur.second + dx[i] >= 0 && cur.second + dx[i] <= 64){\n                    if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                        que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                        close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                        graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                    }\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 65) REP(j, 65) if(abs(graph[i][j]) != INF){\n        cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 65){\n            REP(j, 65){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[1100][1100], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] >= t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[1100][1100] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 30;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE)+abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE)+abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30,s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto p=q.front().first;\n            int turn=q.front().second;\n            q.pop();\n            if(turn==t)\n                break;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nint _(int x) {\n  return x + 500;\n}\n\nstruct point {\n  int x;\n  int y;\n  int d;\n  point(int x, int y, int d)\n    : x(x), y(y), d(d) {\n  }\n};\n\nvoid solve() {\n  int t, n;\n  while (cin >> t >> n, t) {\n    vvi m(1000, vi(1000, false));\n    while (n--) {\n      int x, y;\n      cin >> x >> y;\n      m[_(x)][_(y)] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    queue<point> q;\n    q.push(point(sx, sy, 0));\n    int c = 0;\n    while (q.size()) {\n      point p = q.front();\n      q.pop();\n      if (p.d > t || m[_(p.x)][_(p.y)]) continue;\n      c++;\n      m[_(p.x)][_(p.y)] = true;\n      int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, 0, 1};\n      rep(i, 6) q.push(point(p.x + dx[i], p.y + dy[i], p.d + 1));\n    }\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,n,x,y,ans,sx,sy;\n  int mp[61][61];\n  while(1){\n    cin>>t>>n;\n    for(int i=0;i<61;i++){\n      for(int j=0;j<61;j++){\n\tmp[i][j]=0;\n      }\n    }\n    ans=0;\n    if(t==0 && n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      mp[y+30][x+30]=-1;\n    }\n    cin>>sx>>sy;\n    mp[sy+30][sx+30]=1;\n    for(int i=1;i<=t;i++){\n      for(int j=0;j<61;j++){\n\tfor(int k=0;k<61;k++){\n\t  if(mp[j][k]==i){\n\t    for(int l=-1;l<2;l++){\n\t      if(mp[j+l][k]==0){\n\t\tmp[j+l][k]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j][k+l]==0){\n\t\tmp[j][k+l]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j+l][k+l]==0){\n\t\tmp[j+l][k+l]=i+1;\n\t\tans++;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int, int> P;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t, n;\n  bool cango[100][100];\n  int vy[6] = {1,0,-1,-1,0,1};\n  int vx[6] = {1,1,0,-1,-1,0};\n  while(cin>>t>>n,t||n) {\n    FOR(i,0,100) FOR(j,0,100) cango[i][j] = true;\n    FOR(i,0,n) {\n      int x, y; cin >> x >> y;\n      cango[y+50][x+50] = false;\n    }\n    int sx, sy; cin >> sx >> sy;\n    int ans = 1;\n    queue<P> Q;\n    Q.push(P(sx+50, sy+50));\n    FOR(i,0,t) {\n      queue<P> tmp;\n      while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        int y = p.first;\n        int x = p.second;\n        FOR(j,0,6) {\n          int ny = y + vy[j];\n          int nx = x + vx[j];\n          if(!cango[ny][nx]) continue;\n          ans++;\n          tmp.push(P(ny, nx));\n          cango[ny][nx] = false;\n        }\n      }\n      while(!tmp.empty()) {\n        Q.push(tmp.front());\n        tmp.pop();\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int n,t;\n  while(cin>>t>>n,n+t){\n    bool Map[200][200]={};\n    bool Map2[200][200]={};\n\n    for(int i=0;i<n;i++){\n      int a,b;cin>>a>>b;\n      Map2[a+100][b+100]=true;\n    }\n    int aa,bb;cin>>aa>>bb;\n    Map[aa+100][bb+100]=true;\n    int ans=0;\n    int vx[6]={1,0,-1,0,1,-1};\n    int vy[6]={0,-1,0,1,1,-1};\n    queue<pair<pair<int,int>,int> >que;\n    que.push(mp(mp(aa+100,bb+100),0));\n    while(!que.empty()){\n      pair<pair<int,int>,int >now=que.front();\n      que.pop();\n      //cout<<now.F.F<<\" \"<<now.F.S<<endl;\n      if(now.S>=t)break;;\n      for(int i=0;i<6;i++){\n\tint x=now.F.F+vx[i],y=now.F.S+vy[i];\n\tif(Map[x][y]==false&&Map2[x][y]==false){\n\t  Map[x][y]=true;\n\t  que.push(mp(mp(x,y),now.S+1));\n\t}\n      }\n    }\n    for(int i=0;i<200;i++)\n      for(int j=0;j<200;j++)\n\tif(Map[i][j])\n\t  ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {1,0,-1,-1,0,1};\nconst int dx[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      if(d == t) break;\n      ++d;\n      auto S = q.size();\n      rep(j,S){\n        auto Q = q.front();q.pop();\n        rep(i,6){\n          ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n          if(value(nx,ny,61,61) && v[nx][ny] == inf){\n            q.push(mp(nx,ny));\n            v[nx][ny] = d;\n            ++cnt;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\n\nint d[6][2]={{1,1},{0,1},{-1,0},{-1,-1},{0,-1},{1,0}};\n\nint main(){\n  int t,n;\n  while(cin>>t>>n,t){\n    bool map[100][100]={false};\n    int x=0,y=0;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      map[y+50][x+50]=true;\n    }\n    cin>>x>>y;\n    x+=50;\n    y+=50;\n    int cnt=0;\n    queue<pair<int,int> > q;\n    q.push(make_pair(y*1000+x,0));\n    map[y][x]=true;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      if(p.second>t) break;\n      //  cout<<\" t = \"<<t<<\" p.second=\"<<p.second<<endl;\n      y=p.first/1000;\n      x=p.first%1000;\n      cnt++;\n      q.pop();\n      for(int i=0;i<6;i++){\n\tint xx=x+d[i][0];\n\tint yy=y+d[i][1];\n\tif(!map[yy][xx]){\n\t  map[yy][xx]=true;\n\t  q.push(make_pair(yy*1000+xx,p.second+1));\n\t}\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std ;\n\nint map[100][100] = {} ;\nint dx[] = { 0,1,1,0,-1,-1 } ;\nint dy[] = { 1,1,0,-1,-1,0 } ;\n\nint main(){\n\t\n\tint t , n , count ;\n\tint nx , ny , nc ;\n\tint sx , sy ;\n\t\n\twhile(1){\n\t\tqueue<int> x ;\n\t\tqueue<int> y ;\n\t\tqueue<int> c ;\n\t\t\n\t\tcin >> t >> n ;\n\t\tif( t==0 && n==0 ) break ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> nx >> ny ;\n\t\t\tmap[ny+50][nx+50] = -1 ;\n\t\t}\n\t\tcin >> sx >> sy ;\n\t\t\n\t\tcount = 1 ;\n\t\tc.push(1) ;\n\t\tx.push( sx+50 ) ;\n\t\ty.push( sy+50 ) ;\n\t\tmap[sy+50][sx+50] = 1 ;\n\t\t\n\t\twhile(1){\n\t\t\tif( c.empty() ) break ;\n\t\t\tif( c.front() == t+1 ) break ;\n\t\t\t\n\t\t\tnx = x.front() ;\n\t\t\tny = y.front() ;\n\t\t\tnc = c.front() ;\n\t\t\t\n\t\t\tfor( int i=0 ; i<6 ; i++ ){\n\t\t\t\tif( map[ ny+dy[i] ][ nx+dx[i] ] == 0 ){\n\t\t\t\t\tmap[ ny+dy[i] ][ nx+dx[i] ] = nc ;\n\t\t\t\t\tcount++ ;\n\t\t\t\t\tx.push( nx+dx[i] ) ;\n\t\t\t\t\ty.push( ny+dy[i] ) ;\n\t\t\t\t\tc.push( nc+1 ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tx.pop() ;\n\t\t\ty.pop() ;\n\t\t\tc.pop() ;\n\t\t}\n\t\t\n\t\tcout << count << endl ;\n\t\t\n\t\tfor( int i=0 ; i<100 ; i++ ){\n\t\t\tfor( int j=0 ; j<100 ; j++ ){\n\t\t\t\tmap[i][j] = 0 ;\n\t\t\t}\n\t\t}\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tint cnt = f[p] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << f[p_] << endl;\n\t\tif( cnt > t )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p_(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p_] == -2 ) continue;\n\t\t\t\n\t\t\tif( f[p_] == -1 ){\n\t\t\t\tf[p_] = cnt;\n\t\t\t\tque.push( p_ );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\tf.clear();\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -2;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 0;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tsolve( t , f , que );\n\t\tint ans = 1;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] > 0 ) ans++;\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <string.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a;i < b;i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n) memset(n,0,sizeof(n))\n\nconst int dx[6] = { 0, -1, -1, 0, 1, 1 }, dy[6] = { 1, 0, -1, -1, 0, 1 };\nbool cheak(int x, int y, int mx, int my){ return x >= 0 && y >= 0 && x < mx && y < my; }\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint main(){\n\n\tint t, n;\n\n\twhile (cin >> t >> n && t){\n\t\tconst int M = 100;\n\t\tbool d[M * 3][M * 3]; clr(d);\n\t\tbool f[M * 3][M * 3]; clr(f);\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\td[y + M][x + M] = true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tsx += M, sy += M;\n\t\tqueue<T> q;\n\t\tq.push(T(sy, sx, 0));\n\t\tf[sy][sx] = true;\n\t\twhile (q.size()){\n\t\t\tT nx = q.front(); q.pop();\n\t\t\trep(i, 6){\n\t\t\t\tint ty = get<0>(nx) + dy[i], tx = get<1>(nx) + dx[i];\n\t\t\t\tif (!d[ty][tx] && !f[ty][tx] && get<2>(nx) < t){\n\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\tq.push(T(ty, tx, get<2>(nx)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, M * 3)rep(j, M * 3){\n\t\t\tif (f[i][j])ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n\nint data[200][200]={};\nint t,n;\n\n\nint main(){\n    while(cin>>t>>n){\n        if(t==0 && n==0)break;\n        \n        rep(i,200)rep(j,200)data[i][j]=100;\n        \n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            x+=100;y+=100;\n            data[y][x]=-1;\n        }\n        int a,b;\n        cin>>a>>b;\n        a+=100;b+=100;\n        data[b][a]=0;\n        \n        int dx[]={0,1,1,0,-1,-1};\n        int dy[]={1,1,0,-1,-1,0};\n        \n        for(int time=1;time<=t;time++){\n            rep(i,200){\n                rep(j,200){\n                    if(data[i][j]==time-1){\n                        rep(k,6){\n                            if(data[i+dy[k]][j+dx[k]]!=-1) data[i+dy[k]][j+dx[k]]=min(data[i+dy[k]][j+dx[k]],time);\n                        }\n                    }\n                    \n                }\n            }\n        }\n        int c=0;\n        rep(i,200){\n            rep(j,200){\n                if(data[i][j]!=-1 && data[i][j]!=100)c++;\n            }\n        }\n        \n        cout<<c<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[100][101]={};\nbool vis[100][100]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.push({x,y,t});\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&0<=na&&0<=nb&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.push({na,nb,c-1});\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,100)rep(j,100)cnt+=vis[i][j];\n  return cnt;\n}\n\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=30;y+=30;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=30;sy+=30;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint t,n,x,y,T;\nbool mp[61][61];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nint bfs(){\n  queue<P> Q;\n  int cnt=0;\n  Q.push(P(0,(x+30)*61+y+30));\n  while(!Q.empty()){\n    P p=Q.front();\n    T=p.first;\n    x=p.second/61,y=p.second%61;\n    if(T==t+1)return cnt;\n    mp[x][y]=1;\n    Q.pop();\n    cnt++;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(0<=nx&&nx<61&&0<=ny&&ny<61&&!mp[nx][ny])\n\tmp[nx][ny]=1,Q.push(P(T+1,nx*61+ny));\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while(cin>>t>>n&&(t||n)){\n    memset(mp,0,sizeof(mp));\n    while(n--){\n      cin>>x>>y;\n      mp[x+30][y+30]=1;\n    }\n    cin>>x>>y;\n    cout<<bfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint t,n;\nbool field[200][200];\nint check[200][200];\nint sx,sy;\ntypedef struct point{int x;int y;int d;} p;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nint main(){\n\tvector<int> ans;\n\twhile(true){\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\tmemset(field,1,sizeof(field));\n\t\t\n\t\tfor(int i = 0;i < 200;i++){\n\t\t\tfor(int j = 0;j < 200;j++){\n\t\t\t\tcheck[i][j] = 1e9;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[y + 100][x + 100] = false;\n\t\t}\n\t\t\n\t\tcin >> sx >> sy;\n\t\t\n\t\tqueue <p> q;\n\t\tp start = {sx+100,sy+100,0};\n\t\tcheck[start.y][start.x] = 0;\n\t\tq.push(start);\n\t\t\n\t\twhile(q.size()){\n\t\t\tp now = q.front(); q.pop();\n\t\t\t//cout << now.x << \" \" << now.y << \" \" << now.d << endl;\n\t\t\tfor(int i = 0;i < 6;i++){\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tint nd = now.d + 1;\n\t\t\t\tif(nd <= t && check[ny][nx] > nd&& field[ny][nx]){\n\t\t\t\t\tp next = {nx,ny,nd};\n\t\t\t\t\tq.push(next);\n\t\t\t\t\tcheck[ny][nx] = nd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tans = 0;\n\t\tfor(int i = 0;i < 200;i++){\n\t\t\tfor(int j = 0;j < 200;j++){\n\t\t\t\tif(check[i][j] <= t){\n\t\t\t\t\ttans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(tans);\n\t}\n\t\n\tfor(int i = 0;i < ans.size();i++){\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define ORIGIN 50\n\nint vx[6] ={1, 1, 0, 0, -1, -1};\nint vy[6] ={1, 0, 1, -1, 0, -1};\nint cell[ORIGIN*2][ORIGIN*2];\n\nint func(int x, int y, int turn){\n\tint ans=0;\n\n\tif(cell[y][x] >= turn || turn <= 0) return 0;\n\tif(cell[y][x] == 0)ans++;\n\tcell[y][x]=turn;\n\n\tfor(int i=0; i<6; i++){\n\t\tans += func(x+vx[i], y+vy[i], turn-1);\n\t}\n\treturn ans;\n}\n\n\nint main(void){\n\tint turn, n, x, y, tmp_x, tmp_y, ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\", &turn, &n);\n\t\tif(turn == 0 && n == 0) break;\n\n\t\tmemset(cell, 0, sizeof(cell));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d %d\", &tmp_x, &tmp_y);\n\t\t\tcell[tmp_y+ORIGIN][tmp_x+ORIGIN] =500;\n\t\t}\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tans = func(x+ORIGIN, y+ORIGIN, turn+1);\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint t;\nint dy[]={0,1,-1};\nint dx[]={0,1,-1};\nint ans=0;\npii p;\nmap<pii,int>mp;\nvoid dfs(pii now,int cnt){\n    if(cnt>t)return;\n    if(mp[now]!=0&&mp[now]<cnt)return;\n    if(mp[now]==0)ans++;\n    mp[now]=cnt;\n    if(now==p)mp[now]=-INF;\n    //if(abs(now.first)>30||abs(now.second)>30)return;\n    //cout<<now.first<<\" \"<<now.second<<endl;\n    rep(i,3)\n    rep(j,3){\n        if(dx[i]+dy[j])dfs(pii(now.first+dx[i],now.second+dy[j]),cnt+1);\n    }\n}\nint main(){\n    int n;\n    while(cin>>t>>n,t+n){\n        mp.clear();\n        ans=0;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>p.first>>p.second;\n        dfs(p,0);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[70][70], d[70][70];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60 ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+30][b+30]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=30;\n\t\tstart.y+=30;\n\t\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\twhile(!que.empty()){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\tif(d[v.x][v.y]>=turn+1) continue;\n\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx; tmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\t//x, y\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {1, 0, -1, -1, 0, 1};\n\nint t, n;\nint x[300], y[300];\nint sx, sy;\nbool isOk[150][150];\nint cost[150][150];\n\nvoid bfs() {\n\tqueue<P> que;\n\tque.push(P(sx, sy));\n\tcost[sx][sy] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.front(); que.pop();\n\t\tint x = now.first;\n\t\tint y = now.second;\n\t\tif (cost[x][y] == t) continue;\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (isOk[nx][ny] && cost[nx][ny] > cost[x][y] + 1) {\n\t\t\t\tcost[nx][ny] = cost[x][y] + 1;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> t >> n) {\n\t\tif (!t) break;\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tfor (int j = 0; j < 150; j++) {\n\t\t\t\tcost[i][j] = 114514;\n\t\t\t\tisOk[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\tcin >> sx >> sy;\n\t\t\n\t\t//?????¢\n\t\tfor (int i = 0; i < n; i++) { x[i] += 70; }\n\t\tfor (int i = 0; i < n; i++) { y[i] += 70; }\n\t\tsx += 70;\n\t\tsy += 70;\n\t\tfor (int i = 0; i < n; i++) { isOk[x[i]][y[i]] = false; }\n\t\t\n\t\tbfs();\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tfor (int j = 0; j < 150; j++) {\n\t\t\t\tif (cost[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,-1}, dy[] = {0,1,0,-1,1,-1};\n\nstruct P {\n    int x, y, depth;\n};\n\nint main() {\n    int turn, block_n;\n    while (cin >> turn >> block_n, turn|block_n) {\n        bool field[60][60] = {};\n        REP(i, block_n) {\n            int x, y;\n            cin >> x >> y;\n            x += 30;\n            y += 30;\n            field[y][x] = true;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        start_x += 30;\n        start_y += 30;\n\n        int cnt = 1;\n\n        queue<P> que;\n        que.push({start_x, start_y, 0});\n        field[start_y][start_x] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.depth == turn) continue;\n            REP(i, 6) {\n                int sx = p.x + dx[i];\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx < 60 && 0 <= sy && sy < 60) {\n                    if (!field[sy][sx]) {\n                        field[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy, p.depth+1});\n                    }\n                }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1, 1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool syougai[300][300] = {};\nbool ok[300][300] = {};\n\n\nvoid solve(int x, int y, int turn, bool visited[300][300]){\n\n  if(turn == 0) return;\n\n  REP(i,6){\n    int nx = x + dx[i], ny = y + dy[i];\n    //cout << ny << \" \" << nx << endl;\n    \n    if(!visited[ny][nx] && !syougai[ny][nx]){\n      visited[ny][nx] = true;\n      ok[ny][nx] = true; \n      solve(nx, ny, turn - 1, visited);\n      visited[ny][nx] = false;\n    }\n  }\n}\n\nint main(){\n\n  llong n, t;\n  while(true){\n    scanf(\"%lld %lld\", &t, &n);\n    if(n == 0 && t == 0) break;\n\n    bool visited[300][300] = {};\n    REP(i,300){\n      REP(j,300){\n        visited[i][j] = false;\n        syougai[i][j] = false;\n        ok[i][j] = false;\n      }\n    }\n\n    REP(i,n){\n      llong x, y;\n      scanf(\"%lld %lld\", &x, &y);\n      x += 150; y += 150;\n      syougai[y][x] = true;\n    }\n\n    llong sx, sy;\n    scanf(\"%lld %lld\", &sx, &sy);\n    sx += 150; sy += 150;\n    visited[sy][sx] = true;\n    ok[sy][sx] = true;\n\n    llong ans = 0;\n    solve(sx, sy, t, visited);\n    REP(i,300){\n      REP(j,300){\n        if(ok[i][j]) ans++;\n      }\n    }\n    \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define ADD 100\n\nint map[200][200];\nint dx[]={0,1,-1,1,-1,0};\nint dy[]={1,1,0,0,-1,-1};\nvoid check(int x,int y,int t)\n{\n  if(map[x][y]==-1)\n    return;\n  map[x][y]=1;\n  if(t<=0)\n    return;\n  for(int i=0;i<6;i++)\n    check(x+dx[i],y+dy[i],t-1);\n}\n\nint main()\n{\n  int t,n;\n  for(;cin>>t>>n,t;)\n    {\n      memset(map,0,sizeof(map));\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin>>x>>y;\n\t  map[x+ADD][y+ADD]=-1;\n\t}\n      int x,y;\n      cin>>x>>y;\n      queue<pair<pair<int,int>,int> >qu;\n      qu.push(make_pair(make_pair(x+ADD,y+ADD),t));\n      while(!qu.empty())\n\t{\n\t  pair<int,int>pos=qu.front().first;\n\t  int tt=qu.front().second;\n\t  qu.pop();\n\t  //\t  if(map[pos.first][pos.second]!=0)\n\t  //  continue;\n\t  map[pos.first][pos.second]=1;\n\t  if(tt<=0)\n\t    continue;\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      //  if(map[pos.first+dx[i]][pos.second+dy[i]]==0)\n\t\tcheck(pos.first+dx[i],pos.second+dy[i],tt-1);\n\t    }\n\t}\n      int ans=0;\n      for(int i=0;i<200;i++)\n\tfor(int j=0;j<200;j++)\n\t  if(map[i][j]==1)\n\t    {\n\t      ans++;\n\t    }\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \n#define BLANK 0\n#define BLOCK 1\n#define POSSIBLE 2\n#define CENTER 30\n#define MAX 30+30+30+1\n \nstruct point{int x,y,d;};\n \nint main()\n{\n  int t,n,cnt;\n  int i,j,a,b;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  int field[MAX][MAX];\n  queue<point> q;\n  point p,p2;\n  while(cin>>t>>n,t||n){\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)field[i][j]=BLANK;\n    for(i=0;i<n;i++){\n      cin>>a>>b;\n      field[a+CENTER][b+CENTER]=BLOCK;\n    }\n \n    while(!q.empty())q.pop();\n    cin>>a>>b;\n    p.x=a+CENTER;\n    p.y=b+CENTER;\n    p.d=0;\n    q.push(p);\n    while(!q.empty()){\n      p=q.front();\n      q.pop();\n      field[p.x][p.y]=POSSIBLE;\n      if(p.d>=t)continue;\n      for(i=0;i<6;i++){\n        p2.x=p.x+dx[i];\n        p2.y=p.y+dy[i];\n        p2.d=p.d+1;\n        if(field[p2.x][p2.y]==BLANK){\nfield[p2.x][p2.y]=POSSIBLE;\nq.push(p2);\n}\n      }\n    }\n    cnt=0;\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)if(field[i][j]==POSSIBLE)cnt++;\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\n#define SZ 60\n\nbool visited[SZ*2+5][SZ*2+5];\n\nbool isin(int x, int y){\n    if((x-SZ)*(y-SZ)>=0) return x>=0 && x<=SZ*2 && y>=0 && y<=SZ*2;\n    else return abs(x-SZ)+abs(y-SZ)<=SZ;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[SZ*2+5], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+SZ][y+SZ]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+SZ, sy+SZ), 0));\n        visited[sx+SZ][sy+SZ]=true;\n        int res=1;\n        while (!q.empty()){\n            const int dx[] = {1,1,0,-1,-1,0};\n            const int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second==t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 121\n#define CONT 60\n\nint T,N;\n\nvoid dfs(int x, int y, int turn, vector< vector<int> > &field)\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\tif(x < 0 || x >= MAX || y < 0 || y >= MAX){ return; } //範囲外\n\n\tif(turn > T){ return; } //ターン数オーバー\n\n\tif(field[x][y] <= turn && field[x][y]){ return; } //到達修正\n\tif(field[x][y] == -1){ return; } //障害物\n\n\tfield[x][y] = turn;\n\t\n\trep(i,6){\n\t\tdfs(x+dx[i], y+dy[i], turn+1, field);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> T >> N )\n\t{\n\t\tif(T == 0 && N == 0){ break; }\n\n\t\tvector< vector<int> > field(MAX,vector<int>(MAX,0));\n\t\n\t\tint X,Y;\n\t\trep(nth,N)\n\t\t{\n\t\t\tcin >> X >> Y;\n\t\t\tfield[X+CONT][Y+CONT] = -1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\n\t\tint ans = 0;\n\t\tdfs(sx+CONT,sy+CONT,0,field);\n\t\tfield[sx+CONT][sy+CONT] = 1;\n\t\t\n\t\trep(y,MAX){\n\t\t\trep(x,MAX){\n\t\t\t\tif(field[x][y] > 0){ ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nbool pass[100][100];\nbool used[100][100];\nint t,n;\nvoid dfs(int x,int y,int cnt)\n{\n\tif(cnt>t||pass[y][x]) return;\n\n\tused[y][x]=true;\n\tfor (int i = 0; i < 6; i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<100&&0<=ny&&ny<100) dfs(nx,ny,cnt+1);\n\t}\n\treturn;\n}\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(pass,0,sizeof(pass));\n\t\tmemset(used,0,sizeof(used));\n\t\tint x,y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>x>>y;\n\t\t\tpass[y+30][x+30]=true;\t\n\t\t}\n\t\tcin>>x>>y;\n\t\tdfs(x+30,y+30,0);\n\t\tint ans=0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n-1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}cin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\n\nint mas[300][300];\nint dx[] = { 1, 1, 0, -1, -1, 0 }, dy[] = { 1, 0, -1, -1, 0, 1 };\n\ntypedef pair< int, int > iP;\ntypedef pair< int, iP > iiP;\n\nint bfs(int t, int sx, int sy) {\n    int ret = 0;\n    int used[300][300] = {{0}};\n    queue< iiP > q;\n    q.push(iiP(t, iP(sx, sy)));\n    while(!q.empty()) {\n        iiP p = q.front(); q.pop();\n        if(p.first < 0 || used[p.second.first][p.second.second]++) continue;\n        ret++;\n        int x = p.second.first, y = p.second.second;\n        for(int i = 0; i < 6; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if(!mas[ny][nx]) {\n                q.push(iiP(p.first - 1, iP(nx, ny)));\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, t;\n    while(cin >> t >> n, t) {\n        memset(mas, 0, sizeof(mas));\n        for(int i = 0; i < n; i++) {\n            int x, y; cin >> x >> y;\n            mas[y + 150][x + 150] = 1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        cout << bfs(t, sx + 150, sy + 150) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(61, vi(61, 0));\n\t\tqueue<state> Q;\n\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx, sy, 0));\n\t\tfield[sx+30][sy+30] = 1;\n\t\tint count = 1;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tREP(d, 6) {\n\t\t\t\tif(abs(st.x+dx[d]) <= 30 && abs(st.y+dy[d]) <= 30) {\n\t\t\t\t\tif(field[st.x+dx[d]+30][st.y+dy[d]+30] == 0) {\n\t\t\t\t\t\tfield[st.x+dx[d]+30][st.y+dy[d]+30] = 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(st.t+1 < t) {\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main() {\n\tint d1[6] = { 1,0,-1,0,1,-1 };\n\tint d2[6] = { 0,1,0,-1,1,-1 };\n\tint t, n;\n\twhile (cin >> t>>n, t) {\n\t\tint p[200][200] = {};\n\t\tint x, y, sta, las;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[x + 100][y + 100] = 1;\n\t\t}\n\t\tcin >> sta >> las; sta += 100; las += 100;\n\t\tint used[200][200] = {};\n\t\tused[sta][las] = 1;\n\t\tvector<P> v;\n\t\tv.push_back({ sta,las });\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint len = v.size();\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tint nx = v[0].first; int ny = v[0].second; v.erase(v.begin());\n\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\tif (p[nx + d1[k]][ny + d2[k]] == 0 && used[nx + d1[k]][ny + d2[k]]==0) {\n\t\t\t\t\t\tused[nx + d1[k]][ny + d2[k]] = 1;\n\t\t\t\t\t\tv.push_back({ nx + d1[k],ny + d2[k] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (used[i][j] == 1)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nbool out(int x,int y){\n\tif(10<=x&&x<=70&&10<=y&&y<=70){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint dx[6]={1,0,-1,-1,0,1};\n\tint dy[6]={0,-1,-1,0,1,1};\n\tint n,t;\n\twhile(cin>>t>>n&&t){\n\t\tint board[200][200]; rep(i,200)rep(j,200) board[i][j]=INF;\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tboard[x+100][y+100]=-1;\n\t\t}\n\t\tint sx,sy; cin>>sx>>sy;\n\t\tboard[sx+100][sy+100]=0;\n\t\tqueue<pair<int,int>> q;\n\t\tq.push(make_pair(sx+100,sy+100));\n\n\t\tint cnt=1;\n\t\twhile(q.size()){\n\t\t\tpair<int,int> p=q.front();\n\t\t\tq.pop();\n\t\t\tint nowx=p.first,nowy=p.second;\n\t\t\tif(board[nowx][nowy]==t) continue;\n\t\t\trep(i,6){\n\t\t\t\tint nex=nowx+dx[i],ney=nowy+dy[i];\n\t\t\t\tif(board[nex][ney]==INF){\n\t\t\t\t\tboard[nex][ney]=board[nowx][nowy]+1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tq.push(make_pair(nex,ney));\n\t\t\t\t\t// cout<<nex<<\" \"<<ney<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {1,0,-1,-1,0,1};\nconst int dy[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      if(d == t) break;\n      ++d;\n      auto S = q.size();\n      rep(j,S){\n        auto Q = q.front();q.pop();\n        rep(i,6){\n          ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n          if(value(nx,ny,61,61) && v[nx][ny] > d){\n            q.push(mp(nx,ny));\n            v[nx][ny] = d;\n            ++cnt;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n\nint t,n;\nint fie[70][70];\nbool used[70][70];\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\nint sx,sy;\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int ix,int iy,int it){\n\t\tx=ix;\n\t\ty=iy;\n\t\tt=it;\n\t}\n};\n\nint bfs(){\n\tstd::queue<data> que;\n\tmemset(used,false,sizeof(used));\n\tque.push(data(sx,sy,0));\n\tused[sx][sy]=true;\n\tint res=1;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tif(d.t==t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx=d.x+dx[i],ny=d.y+dy[i];\n\t\t\tif(nx<5 || nx>=66 || ny<5 || ny>=66)continue;\n\t\t\tif(!used[nx][ny] && fie[nx][ny]==0){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tres++;\n\t\t\t\tque.push(data(nx,ny,d.t+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&t,&n);\n\t\tif(t+n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint bx,by;\n\t\t\tscanf(\"%d %d\",&bx,&by);\n\t\t\tbx+=35;\n\t\t\tby+=35;\n\t\t\tfie[bx][by]=-1;\n\t\t}\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx+=35,sy+=35;\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\nstruct Node\n{\n\tint x, y, turn;\n};\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<int, 61>, 61> field;\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tfield = { {0} };\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 30][x + 30] = 1;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 30][startX + 30] = 1;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX+30, startY+30, 0 });\n\t\t\tint dx[] = {1, 0, -1, -1, 0, 1};\n\t\t\tint dy[] = {0, -1, -1, 0, 1, 1};\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\n\t\t\t\t//turn is over\n\t\t\t\tif (now.turn >= t) continue;\n\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 60 || next.y < 0 || next.y > 60) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = 2;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t\t\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint cnt;\nint t;\nint field[121][121];\n\nvoid dfs(int x,int y,int turn){\n  int dx[6] = {0, 1, 1, 0, -1, -1};\n  int dy[6] = {1, 1, 0, -1, -1, 0};\n\n  if(x<0 || x>120 || y<0 || y>120) return;\n\n  if(turn>t) return;\n\n  /*if(field[x][y]==0){\n    field[x][y] = turn;\n    if(turn==0) field[x][y]=100;\n    //cnt++;\n  }\n  else return;\n  */\n\n  if(field[x][y] <= turn && field[x][y] > 0) return;\n  if(field[x][y] == -1) return;\n\n  field[x][y] = turn;\n\n  for(int i=0;i<6;++i){\n    dfs(x+dx[i],y+dy[i],turn+1);\n  }\n  //cout << turn << \" \" << x-30 << \" \" << y-30 << endl;\n  return;\n}\n\nint main(){\n\n  for(int n;cin>>t>>n,t;){\n    cnt = 0;\n\n    // initialize\n    for(int i=0;i<121;++i){\n      for(int j=0;j<121;++j){\n        field[i][j] = 0;\n      }\n    }\n\n    // syougaibutsu\n    for(int i=0;i<n;++i){\n      int x,y;\n      cin>>x>>y;\n      field[x+60][y+60] = -1;\n    }\n\n /*   for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n       cout << field[i][j] << \" \";\n      }\n      cout << endl;\n    }\n*/\n    int sx,sy;\n    cin>>sx>>sy;\n\n    dfs(sx+60,sy+60,0);\n    field[sx+60][sy+60]=1;\n\n    for(int i=0;i<121;++i){\n      for(int j=0;j<121;++j){\n        if(field[i][j]>0) cnt++;\n     }\n    }\n\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\nint const inf=1<<28;\nint const size=500;\nint g[size][size];\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nvoid move(int sx, int sy, int t){\n    queue<int> qx,qy;\n    qx.push(sx), qy.push(sy);\n    g[sy][sx]=0;\n    while(qx.size()){\n        int x=qx.front(); qx.pop();\n        int y=qy.front(); qy.pop();\n        if(g[y][x]>t) continue;\n        rep(d,6){\n            int nx=x+dx[d];\n            int ny=y+dy[d];\n            // cout << nx << \" \" << ny << endl;\n            if(g[ny][nx]>g[y][x]+1){\n                if(g[ny][nx]==-1) continue;\n                g[ny][nx]=g[y][x]+1;\n                qx.push(nx);\n                qy.push(ny);\n            }\n        }\n    }\n}\n\nint main(){\n    int t,n;\n    while(cin>>t>>n && t|n){\n        rep(i,size)rep(j,size)g[i][j]=inf;\n        rep(i,n){\n            int x,y; cin>>x>>y;\n            x+=size/2; y+=size/2;\n            g[y][x]=-1;\n        }\n        int sx,sy; cin>>sx>>sy;\n        sx+=size/2; sy+=size/2;\n        move(sx,sy,t);\n        int c=0;\n        rep(i,size)rep(j,size){\n            if(g[i][j]!=-1 && g[i][j]<=t)c++;\n        }\n        cout << c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n)  for(int i = 0; i < (n); i++)\nusing vi = vector<int>;\nusing vii = vector<vi>;\nusing ll = long long;\n#define MP make_pair\n\nint main(){\n    using pii=pair<int,int>;\n    while(1){\n        int n,t;\n        cin>>t>>n;\n        if(t==0&&n==0)break;\n        vii b(266,vi(266,0));\n        vii used(266,vi(266,0));\n        int cnt=0,sx=0,sy=0;\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            b[x+100][y+100]=1;\n\n        }\n        cin>>sx>>sy;\n        queue<array<int,3>> q;\n        q.push({sx,sy,0});\n        b[sx+100][sy+100]=1;\n        used[sx+100][sy+100]=1;\n        cnt=1;\n        int dx[6]={1,1,0,-1,-1,0};\n        int dy[6]={1,0,-1,-1,0,1};\n        while(q.size()){\n            auto pr=q.front();\n            q.pop();\n            int x=pr[0];\n            int y=pr[1];\n            int tt=pr[2];\n            //cerr<<x<<\" \"<<y<<endl;\n            if(tt>=t)continue;\n            rep(d,6){\n                int nx=x+dx[d];\n                int ny=y+dy[d];\n                if(used[nx+100][ny+100]==0&&b[nx+100][ny+100]==0){\n                    q.push({nx,ny,tt+1});\n                    used[nx+100][ny+100]=1;\n                    cnt++;\n                }\n            }\n        }\n        cout<<cnt<<endl;     \n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n#include <cstdio>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[64][64] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    //cin >> tt >> nn;\n    scanf(\"%d%d\",&tt, &nn);\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      //cin >> x >> y;\n      scanf(\"%d%d\",&x, &y);\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    //cin >> x >> y;\n    scanf(\"%d%d\",&x, &y);\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<64;j++){\n      for(k=0;k<64;k++){\n        visited[j][k]=0;\n      }\n    }\n    //cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  //if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  if(t==1){\n    if(visited[x][y]==1) return ans;\n    else {visited[x][y]=1;return ans+1;}\n  }\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\nint mp[610][610], t;\nvoid dfs(int x, int y, int n) {\n  if (mp[y][x] == 9 || n == 0)\n    return;\n  mp[y][x] = 7;\n  dfs(x + 1, y, n - 1);\n  dfs(x, y + 1, n - 1);\n  dfs(x - 1, y, n - 1);\n  dfs(x, y - 1, n - 1);\n  dfs(x + 1, y + 1, n - 1);\n  dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    memset(mp, 0, sizeof(mp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,n,x,y,ans,sx,sy;\n  int mp[121][121];\n  while(1){\n    cin>>t>>n;\n    for(int i=0;i<121;i++){\n      for(int j=0;j<121;j++){\n\tmp[i][j]=0;\n      }\n    }\n    ans=0;\n    if(t==0 && n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      mp[y+60][x+60]=-1;\n    }\n    cin>>sx>>sy;\n    mp[sy+60][sx+60]=1;\n    for(int i=1;i<=t;i++){\n      for(int j=0;j<121;j++){\n\tfor(int k=0;k<121;k++){\n\t  if(mp[j][k]==i){\n\t    for(int l=-1;l<2;l++){\n\t      if(mp[j+l][k]==0 ){\n\t\tmp[j+l][k]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j][k+l]==0 ){\n\t\tmp[j][k+l]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j+l][k+l]==0 ){\n\t\tmp[j+l][k+l]=i+1;\n\t\tans++;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\t//for(int i=0;i<jama.size();i++)\n\t//\t\tcout<<jama[i].first<<\"\\t\"<<jama[i].second<<endl;\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=t){\n\t\t\tpiii fr=q.front();\n\t\t\tpii p=fr.first;\n\t\t\tint x=fr.first.first;\n\t\t\tint y=fr.first.second;\n\t\t\tint c=fr.second;\n\t\t\tq.pop();\n\t\t\tif(visited.find(p)!=visited.end())continue;\n\t\t\tvisited.insert(p);\n\t\t//\tcerr<<\"data:\\t\"<<x<<\"\\t\"<<y<<\"\\t\"<<c<<\"\\t\"<<endl;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(x+dx[i],y+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end()){\n\t\t\t\t\tq.push(piii(cur,c+1));\n\t\t\t//\t\tcerr<<\"\\t\\t\\t\\tpush:\\t\"<<cur.first<<\"\\t\"<<cur.second<<\"\\t\"<<c+1<<\"\\t\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011Í[à\\I B. uCuEtH[XEXg[[\n\n#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {1, 0, -1, -1, 0, 1};\n\nint main(){\n\tint t, n;\n\tint visit[200][200];\n\twhile(cin >> t >> n, t){\n\t\tint x, y;\n\t\tmemset(visit, -1, sizeof(visit));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tvisit[x+100][y+100] = 1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tint res = 0;\n\t\tqueue< pair<int, int> > qu; qu.push(make_pair(x+100,y+100));\n\t\tvisit[x+100][y+100] = 0;\n\t\twhile(!qu.empty()){\n\t\t\tpair<int,int> pr = qu.front(); qu.pop();\n\t\t\tint cx = pr.first, cy = pr.second;\n\t\t\tres++;\n\t\t\tif(visit[cx][cy] == t) continue;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\t\tif(visit[nx][ny]!=-1) continue;\n\t\t\t\tvisit[nx][ny] = visit[cx][cy]+1;\n\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\n/*bool operator<(const data &d)const{\n\treturn hoge;\n}*/\n \nconst int dx[]={0,1,1,-1,-1,0};\nconst int dy[]={1,1,0,0,-1,-1};\n\n \nsigned main(){\n\tIOS();\n\tint t,n;\n\tvector<int>ans;\n\twhile(cin>>t>>n,t||n){\n\t\tset<pair<int,int>>used,ng;\n\t\trep(i,0,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tng.insert({x,y});\n\t\t}\n\t\tqueue<pair<pair<int,int>,int>>que;\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tque.push({{sx,sy},0});\n\t\twhile(!que.empty()){\n\t\t\tint i = que.front().fi.fi;\n\t\t\tint j = que.front().fi.se;\n\t\t\tint turn = que.front().se;\n\t\t\tque.pop();\n\t\t\tif(turn>t)continue;\n\t\t\tif(ng.count({i,j}))continue;\n\t\t\tif(used.count({i,j}))continue;\n\t\t\tused.insert({i,j});\n\t\t\trep(k,0,6){\n\t\t\t\tque.push({{i+dx[k],j+dy[k]},turn+1});\n\t\t\t}\n\t\t}\n\t\tans.push_back(used.size());\n\t}\n\tfor(auto e:ans){\n\t\tcout<<e<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> pii;\nint mp[610][610], t;\nvoid dfs(int x, int y, int n) {\n  if (n == 0)\n    return;\n  mp[y][x] = 7;\n  if (mp[y][x + 1] != 9)\n    dfs(x + 1, y, n - 1);\n  if (mp[y + 1][x] != 9)\n    dfs(x, y + 1, n - 1);\n  if (mp[y][x - 1] != 9)\n    dfs(x - 1, y, n - 1);\n  if (mp[y - 1][x] != 9)\n    dfs(x, y - 1, n - 1);\n  if (mp[y + 1][x + 1] != 9)\n    dfs(x + 1, y + 1, n - 1);\n  if (mp[y - 1][x - 1] != 9)\n    dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    memset(mp, 0, sizeof(mp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\nusing namespace std;\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nbool state[100][100];\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[nx][ny] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[nx][ny]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[nx][ny] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[nx + dx[i]][ny + dy[i]]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\t\tfor (int i = 0; i < 500; ++i){\n\t\t\tfor (int j = 0; j < 500; ++j){\n\t\t\t\tstate[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[x+50][y+50] = true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tcout << f(sx+50, sy+50,0) << endl;\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define S 60\n\nusing namespace std;\n\nint main(void){\n\tint i, j, x, y, sx, sy, t, n, f[S * 2 + 1][S * 2 + 1], ans, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<pair<int,int> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(!t && !n) break;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tf[x + S][y + S] = -1;\n\t\t}\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tque.push(pair<int,int>(sx + S,sy + S));\n\t\twhile(que.size()){\n\t\t\tx = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(f[x][y] >= t) continue;\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(0 <= x + dx[i] && x + dx[i] <= S * 2 && 0 <= y + dy[i] && y + dy[i] <= S * 2 && f[x + dx[i]][y + dy[i]] == 0){\n\t\t\t\t\tf[x + dx[i]][y + dy[i]] = f[x][y] + 1;\n\t\t\t\t\tque.push(pair<int,int>(x + dx[i],y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[sx + S][sy + S] = 0;\n\t\tans = 1;\n\t\tfor(i = 0;i <= S * 2;i++)\n\t\t\tfor(j = 0;j <= S * 2;j++) if(f[i][j] > 0) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i<n;i++)\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> p;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] == 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0);\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {1,1,0,-1,-1,0}; const int dy[] = {1,0,-1,-1,0,1};\n\nbool table[61][61];\n\nint main() {\n    int t, n;\n\n    while(cin >> t >> n, t|n){\n        fill_n((bool *)table, 61 * 61, false);\n\n        pii s;\n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            table[y + 30][x + 30] = true;\n        }\n        int xx, yy;\n        cin >> s.first >> s.second;\n        s.first += 30;\n        s.second += 30;\n\n        queue<pii> que;\n        que.push(s);\n        que.push({100,100});\n\n        int cnt = 1;\n        while(!que.empty()){\n            pii p = que.front(); que.pop();\n            if(p.first == 100){\n                if(--t == 0){\n                    cout << cnt << endl;\n                    break;\n                }\n                que.push(p);\n                continue;\n            }\n            table[p.second][p.first] = true;\n\n            REP(i, 6){\n                int sx = p.first + dx[i];\n                int sy = p.second + dy[i];\n                if(0<=sx && sx <= 60 && 0<=sy && sy<=60){\n                    if(table[sy][sx] == false){\n                        table[sy][sx] = true;\n//                        LOG(\"%d %d <- %d %d %d\\n\",sx-30, sy-30 ,p.first-30,p.second-30, t);\n                        cnt ++;\n                        que.push({sx, sy});\n                    }\n                }\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nconst int N = 100;\n\nstruct point{ int x, y; };\nstatic const int dy[6] = {0,1,1,0,-1,-1};\nstatic const int dx[6] = {1,1,0,-1,-1,0};\n\nint bfs(bool *M, int x, int y, int t){\n    int temp[N * N];\n    int *dis = temp + 5050;\n\n    queue<point> q;\n    rep(i, N * N) temp[i] = INF;\n    point start_coordinate = {x, y};\n\n    dis[start_coordinate.y * N + start_coordinate.x] = 0;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,6){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= N || next.y <= -1 * N ||next.x >= N || next.x <= -1 * N) continue;\n            if(dis[next.y * N + next.x] == INF && M[next.y * N + next.x] == 0){\n                dis[next.y * N + next.x] = dis[u.y * N + u.x] + 1;\n                //cout << next.x <<' '<<next.y<< endl;\n                q.push(next);\n            }\n        }\n    }\n\n    int cnt = 0;\n    rep(i, N * N){\n        if(temp[i] <= t) cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    int t, n, sx, sy;\n    while(cin >> t >> n, t||n){\n        bool M[N * N] = {0};\n        bool *atl = M + 5050;\n        rep(i,n){\n            int x, y;\n            cin >> x >> y;\n            atl[y * N + x] = 1;\n        }\n        cin >> sx >> sy;\n        cout << bfs(atl, sx, sy, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nconst int dx[6] = {-1, 0, 1, 1, 0, -1};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nbool obs[1000][1000];\nbool visited[1000][1000];\n\nconst int OFFS = 100;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    vector<int> ans;\n    while(1){\n        int t, n; cin >> t >> n;\n        if(n == 0 && t == 0) break;\n\n        memset(obs, false, sizeof obs);\n        memset(visited, false, sizeof visited);\n\n        for(int i=0;i<n;i++){\n            int ox, oy; cin >> ox >> oy;\n            obs[ox + OFFS][oy + OFFS] = true;\n        }\n\n        int sx, sy; cin >> sx >> sy;\n        sx += OFFS;\n        sy += OFFS;\n\n        int cnt = 0;\n        // BFS\n        queue<pair<pair<int, int>, int> > Q; // (x, y) and step\n        visited[sx][sy] = true;\n        Q.push(make_pair(make_pair(sx, sy), 0));\n        while(!Q.empty()){\n            cnt++;\n            auto p = Q.front();\n            Q.pop();\n            int px = p.first.first, py = p.first.second, cstep = p.second;\n            for(int k=0;k<6;k++){\n                int nx = px + dx[k], ny = py + dy[k];\n                if(!visited[nx][ny] && !obs[nx][ny] && cstep + 1 <= t){\n                    visited[nx][ny] = true;\n                    // cout << nx - OFFS << \" \" << ny - OFFS << endl;\n                    Q.push(make_pair(make_pair(nx, ny), cstep + 1));\n                }\n            }\n        }\n        ans.push_back(cnt);\n    }\n    for(ll a: ans) cout << a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\nnamespace utils{\n  template <typename T> void print(vector<vector<T>> mat) {\n    rep (i, mat.size()) {\n      rep (j, mat[0].size()) cout << mat[i][j] << ' ';\n      cout << endl;\n    }\n  }\n\n  template <typename T> void print(vector<T> v) {\n    rep (i, v.size()) cout << v[i] << ' ';\n    cout << endl;\n  }\n\n  template <typename T> pair<T, T> shape(vector<vector<T>> mat) {\n    int d1, d2;\n\n    d1 = mat.size();\n    if (d1 > 0) d2 = mat[0].size();\n    else int d2 = 0;\n    cout << \"(\" << d1 << \", \" << d2 << \")\" << endl;\n    return make_pair(0, 0);\n  }\n\n  template <typename T> vector<vector<T>> empty(int n, int m) {\n    vector<vector<T>> mat(n, vector<T>(m));\n    return mat;\n  }\n}\n\n\nconst int OFFSET = 50;\n\nint main() {\n  int t, n;\n  int cx, cy;\n  int sx, sy;\n\n  vector<int> dx = {1, 1, 0, -1, -1, 0};\n  vector<int> dy = {1, 0, -1, -1, 0, 1};\n\n  queue<pair<pair<int, int>, int>> s;\n\n  while (cin >> t >> n && (t || n)) {\n    cin >> sx >> sy;\n    sx += OFFSET;\n    sy += OFFSET;\n\n    vector<vector<bool>> visited = utils::empty<bool>(80, 80);\n    rep (i, 80) fill(visited[i].begin(), visited[i].end(), false);\n\n    rep (i, n) {\n      cin >> cx >> cy;\n      cx += OFFSET; cy += OFFSET;\n      visited[cx][cy] = true;\n    }\n\n    //initialize\n    s.push(make_pair(make_pair(sx, sy), 0));\n    int ans = 0;\n\n    while (!s.empty()) {\n      pair<pair<int, int>, int> q = s.front(); s.pop();\n      int cx = q.first.first;\n      int cy = q.first.second;\n      int turn = q.second;\n\n      if (cx < 0 || cy < 0 || cx >= (int)visited.size() || cy >= (int)visited[0].size() || visited[cx][cy]) continue;\n\n      visited[cx][cy] = true;\n      ans++;\n\n      rep (i, 6) {\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n\n        if (turn < t) {\n          s.push(make_pair(make_pair(nx, ny), turn+1));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define MOD 100000\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct A{int x,y,c;};\nint dx[6]={-1,-1,0,0,1,1};\nint dy[6]={-1,0,1,-1,1,0};\nint main(){\n      int t,n,x,y,sx,sy;\n      while(cin>>t>>n&&(t!=0||n!=0)){\n            bool used[121][121];\n            memset(used,true,sizeof(used));\n            REP(i,n){cin>>x>>y;used[x+60][y+60]=false;}\n            cin>>sx>>sy;\n            int cnt=1;used[sx+60][sy+60]=false;\n            queue<A> Q;\n            Q.push((A){sx+60,sy+60,0});\n            while(!Q.empty()){\n                  //cout<<Q.size()<<endl;\n                  A a=Q.front();Q.pop();\n                  if(a.c>=t)continue;\n                  REP(i,6){\n                        int nx=a.x+dx[i],ny=a.y+dy[i];\n                        //cout<<nx<<\" \"<<ny<<endl;\n                        if(used[nx][ny]){\n                              //cout<<nx<<\" \"<<ny<<endl;\n                              used[nx][ny]=false;\n                              Q.push((A){nx,ny,a.c+1});\n                              cnt++;\n                        }\n                  }\n            }\n            cout<<cnt<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int t,n;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0)break;\n    vector<vi> v(65,vi(65,INF));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      v[x+30][y+30]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<pii> q;\n    q.push(pii(sx+30,sy+30));\n    v[sx+30][sy+30]=0;\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      if(v[x][y]>=t)continue;\n      rep(i,6){\n\tint nx=x+dx[i];\n\tint ny=y+dy[i];\n\tif(nx>=0 && nx<=60 && ny>=0 && ny<=60 && v[nx][ny]>=0 && v[nx][ny]>v[x][y]+1){\n\t  v[nx][ny]=v[x][y]+1;\n\t  q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    int ans=0;\n    rep(i,61)rep(j,61)\n      if(v[i][j]>=0 && v[i][j]<INF)ans++;\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define S 30\n\nusing namespace std;\n\nint main(void){\n\tint i, j, x, y, sx, sy, t, n, f[S * 2 + 1][S * 2 + 1], ans, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<pair<int,int> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(!t && !n) break;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tf[x + S][y + S] = -1;\n\t\t}\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tque.push(pair<int,int>(sx + S,sy + S));\n\t\twhile(que.size()){\n\t\t\tx = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(f[x][y] >= t) continue;\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(0 <= x + dx[i] && x + dx[i] <= S * 2 && 0 <= y + dy[i] && y + dy[i] <= S * 2 && f[x + dx[i]][y + dy[i]] == 0){\n\t\t\t\t\tf[x + dx[i]][y + dy[i]] = f[x][y] + 1;\n\t\t\t\t\tque.push(pair<int,int>(x + dx[i],y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[sx + S][sy + S] = 0;\n\t\tans = 1;\n\t\tfor(i = 0;i <= S * 2;i++)\n\t\t\tfor(j = 0;j <= S * 2;j++) if(f[i][j] > 0) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 100\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\nint mass[80][80];\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nvoid dfs(int x, int y, int turn){\n  if(turn == 1) return;\n  REP(i, 6){\n    int nx = x + dx[i]; int ny = y + dy[i];\n    if(nx < 0 or nx >= 80 or ny < 0 or ny >= 80) continue;\n    if(mass[nx][ny] < turn and mass[nx][ny] >= 0) { mass[nx][ny] = turn-1; dfs(nx, ny, turn-1); }\n  }\n}\n\nint main(){\n  int t, n;\n  while(cin >> t >> n and t + n){\n    memset(mass, 0, sizeof(mass));\n    REP(i, n){\n      int x, y; cin >> x >> y;\n      mass[x+40][y+40] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    mass[sx+40][sy+40] = t+1;\n    dfs(sx+40, sy+40, t+1);\n    int res = 0;\n    REP(i, 80) REP(j, 80) if(mass[i][j] > 0) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits>\n\nusing namespace std;\ntypedef struct d\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MIN && map[i][j] != INT_MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define N 200\n#define INF 10000000\nusing namespace std;\n\nint n,m[N][N],t;\nqueue<pair<int,int> > q;\n\nint bfs(){\n  int cnt=1,cntt=0,d[N][N]={};\n  int x[6]={1,1,0,-1,-1,0},y[6]={1,0,-1,-1,0,1};\n  pair<int,int> map,mapa;\n   while(!q.empty()){\n        map=q.front(),q.pop();\n\tcout<<\"map=\"<<map.first<<\" \"<<map.second<<endl;\n    for(int i=0;i<6;i++){\n        mapa=make_pair(map.first+x[i],map.second+y[i]);\n\tif(m[mapa.first][mapa.second]==INF) d[mapa.first][mapa.second]=d[map.first][map.second]+1;\n      if(m[mapa.first][mapa.second]!=INF|| m[mapa.first][mapa.second]==-1 || d[mapa.first][mapa.second]>t)continue;\n\t\tq.push(mapa),m[mapa.first][mapa.second]=1,cnt++;\n    }\n    cntt++;\n  }\n  return cnt;\n}\n \nint main(){\n  pair<int,int>  map;\n  int x,y,ans;\n  while(1){\n   for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) m[i][j]=INF;\n      cin>>t>>n;\n      if(t+n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      m[100+x][100+y]=-1;\n    }\n    cin>>x>>y;\n    m[100+x][100+y]=1;\n      map=make_pair(100+x,100+y);\n     q.push(map);\n     ans=bfs();\n     cout<<ans<<endl;\n  }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1, 1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool syougai[300][300] = {};\nint ok[300][300] = {};\n\nvoid solve(int x, int y, int turn, bool visited[300][300]){\n\n  if(turn == 0) return;\n\n  REP(i,6){\n    int nx = x + dx[i], ny = y + dy[i];\n    \n    if(!visited[ny][nx] && !syougai[ny][nx] && ok[ny][nx] <= turn){\n      ok[ny][nx] = turn;\n      visited[ny][nx] = true; \n      solve(nx, ny, turn - 1, visited);\n      visited[ny][nx] = false;\n    }\n  }\n}\n\nint main(){\n\n  llong n, t;\n  while(true){\n    scanf(\"%lld %lld\", &t, &n);\n    if(n == 0 && t == 0) break;\n\n    bool visited[300][300] = {};\n    REP(i,300){\n      REP(j,300){\n        visited[i][j] = false;\n        syougai[i][j] = false;\n        ok[i][j] = false;\n      }\n    }\n\n    REP(i,n){\n      llong x, y;\n      scanf(\"%lld %lld\", &x, &y);\n      x += 150; y += 150;\n      syougai[y][x] = true;\n    }\n\n    llong sx, sy;\n    scanf(\"%lld %lld\", &sx, &sy);\n    sx += 150; sy += 150;\n    visited[sy][sx] = true;\n    ok[sy][sx] = t + 1;\n\n    llong ans = 0;\n    solve(sx, sy, t, visited);\n    REP(i,300){\n      REP(j,300){\n        if(ok[i][j] > 0) ans++;\n      }\n    }\n    \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] < INF) res++;\n      }\n    }\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) memo[i][j] = 0;\n      }\n    }\n    //print begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          cout << memo[30-i+j][60-i] << \" \";\n        }\n        cout << memo[60][30-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          cout << memo[i-30+j][i] << \" \";\n        }\n        cout << memo[60][i-30];\n      }\n      cout << el;\n    }\n    */\n    //print end\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n/** Problem2253 : Brave Force Story **/\nint T;\nconst int dx0[6]={0, 1, 1, 0, -1, -1};\nconst int dy0[6]={1, 1, 0, -1, -1, 0};\nint ans;\nset<P> vis;\ntypedef struct {\n\tP pos; int cost;\n} S;\n\nint main()\n{\n\tint n, sx, sy;\n\twhile (cin>>T>>n, T||n) {\n\t\tvis.clear();\n\t\tans=0;\n\t\t\n\t\trep(k, n) {\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\tvis.insert(P(x, y));\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tS s = {P(sx, sy), 0};\n\t\tqueue<S> Q;\n\t\tQ.push(s);\n\t\tvis.insert(s.pos);\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tS t = Q.front(); Q.pop();\n\t\t\t//cout << t.pos.first << \" \" << t.pos.second << endl;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx=t.pos.first+dx0[i], ny=t.pos.second+dy0[i];\n\t\t\t\tif (vis.find(P(nx, ny)) == vis.end() && t.cost+1<=T) {\n\t\t\t\t\tS ns = {P(nx, ny), t.cost+1};\n\t\t\t\t\tQ.push(ns);\n\t\t\t\t\tvis.insert(ns.pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << vis.size()-n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntemplate<class T1,class T2>\nusing Hash = unordered_map<T1, T2>;\n\nint dx[]{ 0,1,1,0,-1,-1 }, dy[]{ 1,1,0,-1,-1,0 };\nint main() {\n\tint t, n;\n\twhile (scanf(\"%d%d\", &t, &n), t) {\n\t\tHash<int, Hash<int, int>>mp, d;\n\t\trep(i, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tmp[x][y] = 1;\n\t\t}\n\t\tint sx, sy; scanf(\"%d%d\", &sx, &sy);\n\t\tqueue<P>que;\n\t\tint cnt = 1;\n\t\tque.push(P(sx, sy));\n\t\td[sx][sy] = 1;\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (d[p.first][p.second] > t)continue;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (!mp[nx][ny] && !d[nx][ny]) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[200][200];\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int t,int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty()){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n    if(cnt == t)continue;\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tgrid[ny][nx]=-1;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0 && n==0)break;\n    memset(grid,0,sizeof(grid));\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      grid[y+30][x+30]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    grid[sy+30][sx+30]=-1;\n    cout <<  bfs(t,sx+30,sy+30) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int offset=100;\n\nint memo[200][200];\n\nconst int dx[]={1,1,0,-1,-1,0};\nconst int dy[]={1,0,-1,-1,0,1};\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n,t||n){\n\t\tint sx,sy;\n\t\tint ans=1;\n\t\tqueue<pair<int,int> > q;\n\n\t\tfill((int *)memo,(int *)(memo+200),-1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmemo[y+offset][x+offset]=0;\n\t\t}\n\n\t\tcin>>sx>>sy;\n\n\t\tq.push(make_pair(sx,sy));\n\t\tmemo[sy+offset][sx+offset]=0;\n\n\t\twhile(!q.empty()){\n\t\t\tint x=q.front().first;\n\t\t\tint y=q.front().second;\n\t\t\tint turn=memo[y+offset][x+offset];\n\n\t\t\tq.pop();\n\n\t\t\tif(turn==t){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint xx=x+dx[i];\n\t\t\t\tint yy=y+dy[i];\n\n\t\t\t\tif(memo[yy+offset][xx+offset]==-1){\n\t\t\t\t\tmemo[yy+offset][xx+offset]=turn+1;\n\t\t\t\t\tq.push(make_pair(xx,yy));\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint dx[6] = {1,1,0,-1,-1,0}, dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n\tint t,n;\n\twhile(scanf(\"%d%d\", &t, &n),t||n){\n\t\tint deta[200][200];\n\t\tint cost[200][200];\n\t\trep(i,200) rep(j,200) deta[i][j] = 0;\n\t\trep(i,200) rep(j,200) cost[i][j] = INF;\n\t\trep(i,n){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tx += 100; y += 100;\n\t\t\tdeta[x][y] = 1;\n\t\t}\n\t\tif(t == 0){\n\t\t\tcout << \"1\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint sx, sy;\n\t\tscanf(\"%d%d\", &sx, &sy);\n\t\tsx += 100; sy += 100;\n\t\tdeta[sx][sy] = 2;\n\t\tcost[sx][sy] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(sx,sy));\n\t\twhile(que.size() != 0){\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(i,6){\n\t\t\t\tP tmp = p;\n\t\t\t\ttmp.fi += dx[i];\n\t\t\t\ttmp.sec += dy[i];\n\t\t\t\tif(deta[tmp.fi][tmp.sec] == 0 && cost[tmp.fi][tmp.sec] > cost[p.fi][p.sec]+1){\n\t\t\t\t\tdeta[tmp.fi][tmp.sec] = 2;\n\t\t\t\t\tcost[tmp.fi][tmp.sec] = cost[p.fi][p.sec]+1;\n\t\t\t\t\tif(cost[tmp.fi][tmp.sec] != t) que.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i,200) rep(j,200){\n\t\t\tif(deta[i][j] == 2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tvisited.insert(fr.first);\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(fr.first.first+dx[i],fr.first.second+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end())q.push(piii(cur,fr.second+1));\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int t, n; cin >> t >> n;\n        if (t == 0) break;\n        const int MAX = 61;\n        int used[MAX * 2 + 1][MAX * 2 + 1];\n        memset(used, 0, sizeof(used));\n        REP(i, n) {\n            int x, y; cin >> x >> y;\n            used[y + MAX][x + MAX] = -1;\n        }\n        int sx, sy; cin >> sx >> sy;\n\n        const int dy[] = {0, 1, 1, 0, -1, -1};\n        const int dx[] = {1, 1, 0, -1, -1, 0};\n\n        queue<tuple<int,int,int>> que;\n        que.emplace(sy, sx, 0);\n        used[sy + MAX][sx + MAX] = 1;\n        while (!que.empty()) {\n            int y, x, d; tie(y, x, d) = que.front();\n            que.pop();\n            if (d == t) continue;\n            REP(k, 6) {\n                int ny = y + dy[k], nx = x + dx[k];\n                if (used[ny + MAX][nx + MAX] == 0) {\n                    used[ny + MAX][nx + MAX] = 1;\n                    que.emplace(ny, nx, d + 1);\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(i, MAX * 2 + 1) {\n            REP(j, MAX * 2 + 1) {\n                if (used[i][j] == 1) ++ans;\n            }\n        }\n        cout << ans << endl;\n   }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PI 4*atan(1)\n#define INF 1e8\n\ntypedef long long ll;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint ans = 0;\nint t, n;\n\nvoid bfs(int N, int y, int x, vector<vector<int>> &m){\n  if(N == t + 1)return;\n  m[y][x] = N;\n  // ans++;\n  \n  for(int i = 0; i < 4; i++){\n    for(int j = 0; j < 4; j++){\n      int nx = x + dx[i], ny = y + dy[j];\n      if(dx[i] * dy[j] != -1){\n        if(0 <= nx && nx <= 2*30 && 0 <= ny && ny <= 2*30 && N + 1 < m[ny][nx])bfs(N + 1, ny, nx, m);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> t >> n, t||n){\n    ans = 0;\n    vector<vector<int>> m(30*2 + 1, vector<int>(30*2 + 1, INF));\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      x += 30; y += 30;\n      m[y][x] = -1;\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    start_x += 30; start_y += 30;\n\n    bfs(0, start_y, start_x, m);\n    for(int i = 0; i <= 30*2; i++){\n      for(int j = 0; j <= 30*2; j++){\n        if(m[i][j] >= 1 && m[i][j] != INF)ans++;\n      }\n    }\n    cout << ans + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1, 1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\n\nint main(){\n\n  llong n, t;\n  while(true){\n    scanf(\"%lld %lld\", &t, &n);\n    if(n == 0 && t == 0) break;\n\n    bool visited[300][300] = {}; \n    bool syougai[300][300] = {};\n\n    REP(i,n){\n      llong x, y;\n      scanf(\"%lld %lld\", &x, &y);\n      x += 150; y += 150;\n      syougai[y][x] = true;\n    }\n\n    llong sx, sy;\n    scanf(\"%lld %lld\", &sx, &sy);\n    sx += 150; sy += 150;\n    visited[sy][sx] = true;\n\n    queue<pair<int, pair<int, int>>> que;\n    que.push(MP(sx, MP(sy, t)));\n    while(!que.empty()){\n      pair<int, pair<int, int>> tp = que.front();\n      que.pop();\n      \n      if(tp.second.second == 0) continue;\n\n      REP(i,6){\n        int nx = tp.first + dx[i], ny = tp.second.first + dy[i];\n    \n        if(!visited[ny][nx] && !syougai[ny][nx]){\n          visited[ny][nx] = true; \n          que.push(MP(nx, MP(ny, tp.second.second-1)));\n        }\n      }\n    }\n\n    llong ans = 0;\n    REP(i,300){\n      REP(j,300){\n        if(visited[i][j]) ans++;\n      }\n    }\n    \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n\n#define N 150\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nusing namespace std;\n\nint main(void)\n{\n\n\tint t,n;\n\tint xx,yy;\n\tint x,y;\n\tint start_x,start_y;\n\t\n\tint i1,i2;\n\n\tint f[N][N];\n\n\tint num;\n\tint count;\n\n\n\n\twhile(1){\n\n\t\tfor(i1=0;i1<N;i1++){\n\t\t\tfor(i2=0;i2<N;i2++){\n\t\t\t\tf[i1][i2] = 100;\n\t\t\t}\n\t\t}\n\n\t\tcin >> t;\n\t\tcin >> n;\n\t\tif(t == 0 && n == 0) break;\n\n\n\t\tfor(i1=0;i1<n;i1++){\n\t\t\tcin >> xx;\n\t\t\tcin >> yy;\n\n\n\t\t\tf[yy+50][xx+50] = 500;\n\t\t}\n\n\t\tcount = 1;\n\t\tnum = 0;\n\n\n\t\tcin >> start_x;\n\t\tcin >> start_y;\n\n\t\tstart_x += 50;\n\t\tstart_y += 50;\n\n\n\t\tqueue<pair<int, int> > q;\n\n\t\tf[start_y][start_x] = 0;\n\t\tq.push(make_pair(start_x,start_y));\n\n\n\t\twhile(!q.empty()) {\n\n\t\t\tx = q.front().first;\n\t\t\ty = q.front().second;\n\t\t\tq.pop();\n\n//\t\t\t\tcout << x << \" \" << y << \" \" << num << endl;\n\t\t\tif ( f[y][x] < t){\n\t\t\t\tnum = f[y][x];\n\n\t\t\t\tfor(i1=0;i1<6;i1++){\n\n\t\t\t\t\tif (f[y+dy[i1]][x+dx[i1]]==100){\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]] = num + 1;\n\t\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\tcout << count << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define ADD 100\n\nint map[200][200];\nint dx[]={0,1,-1,1,-1,0};\nint dy[]={1,1,0,0,-1,-1};\n\nint main()\n{\n  int t,n;\n  for(;cin>>t>>n,t;)\n    {\n      memset(map,0,sizeof(map));\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin>>x>>y;\n\t  map[x+ADD][y+ADD]=-1;\n\t}\n      int x,y;\n      cin>>x>>y;\n      queue<pair<pair<int,int>,int> >qu;\n      qu.push(make_pair(make_pair(x+ADD,y+ADD),t));\n      while(!qu.empty())\n\t{\n\t  pair<int,int>pos=qu.front().first;\n\t  int tt=qu.front().second;\n\t  qu.pop();\n\t  if(map[pos.first][pos.second]!=0)\n\t    continue;\n\t  map[pos.first][pos.second]=1;\n\t  if(tt<=0)\n\t    continue;\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      if(map[pos.first+dx[i]][pos.second+dy[i]]==0)\n\t\tqu.push(make_pair(make_pair(pos.first+dx[i],pos.second+dy[i]),tt-1));\n\t    }\n\t}\n      int ans=0;\n      for(int i=0;i<200;i++)\n\tfor(int j=0;j<200;j++)\n\t  if(map[i][j]==1)\n\t    {\n\t      ans++;\n\t    }\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <deque>\nusing namespace std;\nusing T = tuple<int,int,int>;\n\nbool ob[140][140];//x,y\nbool visited[140][140];\n\nint main(){\n    int t,n;\n    while(cin>>t>>n,t){\n        fill(ob[0],ob[140],false);\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+70][y+70]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n        sx+=70; sy+=70;\n        fill(visited[0],visited[140],false);\n        deque<T> Q;\n        Q.emplace_back(sx,sy,0);\n        while(!Q.empty()){\n            int x,y,turn;\n            tie(x,y,turn) = Q.front(); Q.pop_front();\n            if(visited[x][y]||turn>t) continue;\n            visited[x][y]=true;\n            int nx,ny;\n            if(++turn<=t){\n                nx=x+1; ny=y;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n                nx=x+1; ny=y+1;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n                nx=x; ny=y+1;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n                nx=x-1; ny=y;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n                nx=x-1; ny=y-1;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n                nx=x; ny=y-1;\n                if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            }\n        }\n        int ans = 0;\n        for(int i=0;i<140;i++){\n            for(int j=0;j<140;j++) ans+=visited[i][j];\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint data[100][100]={0};\n\nbool inrange(int x,int y){\n  if(x<-30||x>30||y<-30||y>30) return false;\n  else return true;\n}\n\nll int solve(int px,int py,int turn){\n  int res = 0;\n  if(turn==0) return res;\n  REP(i,6){\n    //cout << i << endl;\n    int nx = px + dx[i];\n    int ny = py + dy[i];\n    //cout << nx << \" : \" << ny << endl;\n    if(!inrange(nx,ny)) continue;\n    if(data[nx+30][ny+30]==0) res++;\n    if(data[nx+30][ny+30]!=-1){\n      data[nx+30][ny+30]=1;\n      res+=solve(nx,ny,turn-1);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int t,n;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    REP(i,100){\n      REP(j,100) data[i][j] = 0;\n    } \n    REP(i,n){\n      int tx,ty;\n      cin >> tx >> ty;\n      data[tx+30][ty+30] = -1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    data[sx+30][sy+30] = 1;\n    cout << solve(sx,sy,t)+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\n#define SIZE 130\nbool table[SIZE][SIZE];\nint standed[SIZE][SIZE];\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + SIZE/2;\n}\n\n// 正直幅優先のほうが良い\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"sample.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tmemset(table, false, sizeof(table));\n\t\tmemset(standed, -1, sizeof(standed));\n\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef struct{\n\tint x;\n\tint y;\n}POS;\nqueue <POS> q;\nPOS start,flag;\nint map[65][65];//32?????????0??¨??????\nint x,y,t,n,count,turn;\n\nvoid check(){\n\tPOS pos,next;\n\tflag.x=flag.y=100;\n\tq.push(start);\n\tq.push(flag);\n\twhile(1){\n\t\tif(turn==t+1)return;\n\t\tpos=q.front();\n\t\tq.pop();\n\n\t\tif(pos.x==100){\n\t\t\tturn++;\n\t\t\tq.push(flag);\n\t\t}else{\n\t\t\tcount++;\n\t\t\tif(pos.x>2&&pos.y>2&&map[pos.x-1][pos.y-1]==0){\n\t\t\t\tnext.x=pos.x-1;\n\t\t\t\tnext.y=pos.y-1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x<62&&pos.y<62&&map[pos.x+1][pos.y+1]==0){\n\t\t\t\tnext.x=pos.x+1;\n\t\t\t\tnext.y=pos.y+1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x>0&&map[pos.x-1][pos.y]==0){\n\t\t\t\tnext.x=pos.x-1;\n\t\t\t\tnext.y=pos.y;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.y>0&&map[pos.x][pos.y-1]==0){\n\t\t\t\tnext.x=pos.x;\n\t\t\t\tnext.y=pos.y-1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x<62&&map[pos.x+1][pos.y]==0){\n\t\t\t\tnext.x=pos.x+1;\n\t\t\t\tnext.y=pos.y;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.y<62&&map[pos.x][pos.y+1]==0){\n\t\t\t\tnext.x=pos.x;\n\t\t\t\tnext.y=pos.y+1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >>t >>n;\n\t\tif(!(t||n))break;\n\t\tfor(int i=0;i<65;i++){\n\t\t\tfor(int j=0;j<65;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[x+32][y+32]=1;\n\t\t}\n\t\tcin >>start.x>>start.y;\n\t\tstart.x+=32;\n\t\tstart.y+=32;\n\t\tturn=0;\n\t\tcount=0;\n\t\tmap[start.x][start.y]=1;\n\t\tcheck();\n\t\tcout <<count <<endl;\n\t\twhile(!q.empty())q.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<utility>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<sstream>\n#include<queue>\nconst int INF=1000000;\n#define mp make_pair\nusing namespace std;\ntypedef pair<pair<int,int>,int> P;\nint t,n;\nint b[61][61];\nint sx,sy;\nint ans;\nint tt;\nbool bb;\nint dx[]={-1,0,1,1,0,-1,0};\nint dy[]={0,1,1,0,-1,-1,0};\nvoid bfs(int tt)\n{\n    queue<P> que;\n    que.push(mp(mp(sy,sx),tt));\n    b[sy][sx]=2;\n    while(que.size())\n    {\n        P p=que.front();\n        que.pop();\n        if(p.second==t)break;\n        for(int i=0;i<7;i++)\n        {\n            int ny=p.first.first+dy[i];\n            int nx=p.first.second+dx[i];\n            if(0<=ny&&0<=nx&&nx<61&&ny<61&&(b[ny][nx]==0))\n            {\n                b[ny][nx]=2;\n                que.push(mp(mp(ny,nx),p.second+1));\n                  \n            }\n\n        }\n\n    }\n}\nint main()\n{\n    while(cin>>t>>n)\n    {\n        if(t==0&&n==0)break;\n        for(int i=0;i<61;i++)\n        {\n            for(int j=0;j<61;j++)\n            {\n                b[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            b[y][x]=1;\n        }\n        cin>>sx>>sy;\n        sx+=30;\n        sy+=30;\n        tt=0;\n        ans=0;\n        bfs(0);\n\n        for(int i=0;i<61;i++)\n        {\n            for(int j=0;j<61;j++)\n            {\n                if(b[i][j]==2)ans++;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n    int t, n;\n    int dx[]={1, 1, 0, -1, -1, 0};\n    int dy[]={0, 1, 1, 0, -1, -1};\n    while(cin>>t>>n, t){\n        bool field[62][62];\n        for(int i=0; i<=60; i++){\n            for(int j=0; j<=60; j++){\n                field[i][j]=true;\n            }\n        }\n        while(n--){\n            int x, y;\n            cin >> x >> y;\n            field[x+30][y+30]=false;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        queue<pair<pair<int, int>,int>> q;\n        bool visited[62][62];\n        for(int i=0; i<=60; i++){\n            for(int j=0; j<=60; j++){\n                visited[i][j]=false;\n            }\n        }\n        visited[sx+30][sy+30]=true;\n        q.push(make_pair(make_pair(sx+30, sy+30),0));\n        int count=0;\n        while(!q.empty()){\n            int nx=q.front().first.first, ny=q.front().first.second, now=q.front().second;\n            if(now>t) break;\n            count++;\n            for(int i=0; i<6; i++){\n                if(field[nx+dx[i]][ny+dy[i]]&&!visited[nx+dx[i]][ny+dy[i]]){\n                    visited[nx+dx[i]][ny+dy[i]]=true;\n                    q.push(make_pair(make_pair(nx+dx[i], ny+dy[i]),now+1));\n                }\n            }\n            q.pop();\n        }\n        cout << count << \"\\n\";\n        \n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nconst int six_dx[]={1,1,0,-1,-1,0};\nconst int six_dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t!=0 || n!=0){\n        vector<int> x(n),y(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n        \n        int x0,y0;\n        cin>>x0>>y0;\n        \n        queue<pair<int,int> > q;\n        map<pair<int,int>,int> vis;\n        q.push(make_pair(x0,y0));\n        vis[make_pair(x0,y0)]=0;\n        long long res=1;\n        \n        while(!q.empty()){\n            pair<int,int> pos=q.front();\n            q.pop();\n            \n            if(vis[pos]==t) continue;\n            \n            for(int j=0;j<6;j++){\n                int nx=pos.first+six_dx[j];\n                int ny=pos.second+six_dy[j];\n                \n                bool ok=true;\n                for(int k=0;k<n && ok;k++) ok=!(nx==x[k] && ny==y[k]);\n            \n                if(vis.find(make_pair(nx,ny))==vis.end() && ok){\n                    vis[make_pair(nx,ny)]=vis[pos]+1;\n                    res++;\n                    q.push(make_pair(nx,ny));\n                }\n            }\n        }\n        cout<<res<<endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> pii;\nint mp[610][610], t;\nvoid dfs(int x, int y, int n) {\n  if (n == 0)\n    return;\n  mp[y][x] = 7;\n  if (mp[y][x + 1] != 9)\n    dfs(x + 1, y, n - 1);\n\n  if (mp[y + 1][x] != 9)\n    dfs(x, y + 1, n - 1);\n  if (mp[y][x - 1] != 9)\n    dfs(x - 1, y, n - 1);\n  if (mp[y - 1][x] != 9)\n    dfs(x, y - 1, n - 1);\n  if (mp[y + 1][x + 1] != 9)\n    dfs(x + 1, y + 1, n - 1);\n  if (mp[y - 1][x - 1] != 9)\n    dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    memset(mp, 0, sizeof(mp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int t,n;cin>>t>>n,t|n;){\n\t\tint grid[121][121]={}; // -1:block,0:empty,1:visitable\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tgrid[60+y][60+x]=-1;\n\t\t}\n\t\tint x0,y0; cin>>x0>>y0;\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(x0,y0,0);\n\t\twhile(!q.empty()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint cx=get<0>(c),cy=get<1>(c),ct=get<2>(c);\n\t\t\tif(abs(cx)>60 || abs(cy)>60 || grid[60+cy][60+cx] || ct>t)\n\t\t\t\tcontinue;\n\t\t\tgrid[60+cy][60+cx]=1;\n\t\t\tint dx[]={1,1,0,-1,-1,0},dy[]={0,1,1,0,-1,-1};\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t\tq.emplace(cx+dx[i],cy+dy[i],ct+1);\n\t\t}\n\t\t\n\t\tint res=0;\n\t\tfor(int i=0;i<121;i++)\n\t\t\tfor(int j=0;j<121;j++)\n\t\t\t\tres+=grid[i][j]==1;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main()\n{\n\tint t, n, sx, sy;\n\twhile (cin >> t >> n, t || n) {\n\t\tvector< vector<int> > masu(122, vector<int>(122, 0));\n\t\tfor (int i = 0, x, y; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx += 61; y += 61;\n\t\t\tmasu[x][y] = 1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 61; sy += 61;\n\t\tqueue< pii > q;\n\t\tmasu[sx][sy] = t + 1;\n\t\tq.push(pii(sx,sy));\n\t\tint res = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint X = q.front().first, Y = q.front().second;\n\t\t\tres++;\n\t\t\tq.pop();\n\t\t\tif (masu[X][Y] == 1)\n\t\t\t\tcontinue;\n\t\t\tif (!masu[X - 1][Y]) {\n\t\t\t\tq.push(pii(X - 1, Y));\n\t\t\t\tmasu[X - 1][Y] = masu[X][Y] - 1;\n\t\t\t}\n\t\t\tif (!masu[X][Y - 1]) {\n\t\t\t\tq.push(pii(X, Y - 1));\n\t\t\t\tmasu[X][Y - 1] = masu[X][Y] - 1;\n\t\t\t}\n\t\t\tif (!masu[X - 1][Y - 1]) {\n\t\t\t\tq.push(pii(X - 1, Y - 1));\n\t\t\t\tmasu[X - 1][Y - 1] = masu[X][Y] - 1;\n\t\t\t}\n\t\t\tif (!masu[X + 1][Y]) {\n\t\t\t\tq.push(pii(X + 1, Y));\n\t\t\t\tmasu[X + 1][Y] = masu[X][Y] - 1;\n\t\t\t}\n\t\t\tif (!masu[X][Y + 1]) {\n\t\t\t\tq.push(pii(X, Y + 1));\n\t\t\t\tmasu[X][Y + 1] = masu[X][Y] - 1;\n\t\t\t}\n\t\t\tif (!masu[X + 1][Y + 1]) {\n\t\t\t\tq.push(pii(X + 1, Y + 1));\n\t\t\t\tmasu[X + 1][Y + 1] = masu[X][Y] - 1;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 30;\n\nint t, n;\nint field[90][90];\n\nvoid dfs(int x, int y, int c){\n\tif(c == t) return;\n\tfield[x][y] = c;\n\tint dx[6] = {-1, 0, 1, 1, 0, -1};\n\tint dy[6] = {0, 1, 1, 0, -1, -1};\n\trep(i, 6){\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif(abs(nx-d) <= 30 && abs(ny-d) <= 30 && field[nx][ny] != -1 && (c < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\tdfs(nx, ny, c+1);\n\t\t}\n\t}\n}\n\nint main(){\n    while(cin >> t >> n, t+n){\n\t\tt += 2;\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 90)rep(j, 90) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tdfs(sx, sy, 1);\n\n\t\tint count = 0;\n\t\trep(i, 90)rep(j, 90) if(0 < field[i][j]) count++;\n\t\tcout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pxyi;\n\nvector<pii> N;\nset <pii> s;\nconst int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {0, 1, 1, 0, -1, -1};\n  \nvoid bfs(int sx, int sy, int st)\n{\n  vector<pxyi> v;\n  queue<pxyi> q;\n  q.push(pxyi(pii(sx,sy),st));\n  while(!q.empty()){\n    int x, y, t;\n    x = q.front().first.first;\n    y = q.front().first.second;\n    t = q.front().second;\n    q.pop();\n    bool flag = false;\n    for(int i = 0; i < (int)v.size(); i++){\n      if(v[i].first.first == x && v[i].first.second == y && v[i].second)\n        flag = true;\n    }\n    if(flag){\n      if(q.empty()) break;\n      else continue;\n    }else{\n      s.insert(pii(x,y));\n      v.push_back(pxyi(pii(x,y),t));\n    }\n    if(t == 0){\n      if(q.empty()) break;\n      else continue;\n    }\n    for(int i = 0; i < 6; i++){\n      flag = false;\n      int next_x = x + dx[i], next_y = y + dy[i];\n      for(int j = 0; j < (int)N.size(); j++){\n        if(N[j].first == next_x && N[j].second == next_y)\n          flag = true;\n      }\n      if(flag) continue;\n      q.push(pxyi(pii(next_x,next_y),t-1));\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    s.clear();\n    N.clear();\n    int t, n;\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      N.push_back(pii(x,y));\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    bfs(start_x,start_y,t);\n    cout << s.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int> P;\ntypedef tuple<int,int,int> Tr;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1};\n\nconst int NMAX = 100;\nint field[NMAX][NMAX];\n#define MAP(x, y) field[x + 50][y + 50]\n\nint main() {\n  cout << fixed << setprecision(10);\n  int T, N;\n  while (cin >> T >> N and T) {\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      MAP(x, y) = INF;\n    }\n    REP(i, N) {\n      int x, y;\n      cin >> x >> y;\n      MAP(x, y) = -1;\n    }\n\n    int sx,sy;\n    cin >> sx >> sy;\n    priority_queue<Tr,vector<Tr>,greater<Tr>> que;\n    que.push(Tr(1,sx,sy));\n\n    while (!que.empty()) {\n      int turn, x, y;\n      tie(turn, x, y) = que.top(); que.pop();\n      if (turn >= MAP(x, y)) continue;\n      MAP(x, y) = turn;\n      REP(j, 6) {\n        int nx = x + dx[j], ny = y + dy[j];\n        if (MAP(nx, ny) >= 0 and turn <= T)\n          que.push(Tr(turn + 1, x + dx[j], y + dy[j]));\n      }\n    }\n\n    int sum = 0;\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      if (MAP(x, y) > 0 and MAP(x, y) < 100) sum++;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n//[-30,30] -> [0,60]\nint f[61][61];\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n    int t,n;\n    \n    while(cin >> t >> n){\n        if((t|n) == 0) break;\n        memset(f,0,sizeof(f));\n        int x,y;\n        vector<pair<int,int> > diff;\n\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            f[x+30][y+30] = -1;\n        }\n\n        cin >> x >> y;\n        x += 30;\n        y += 30;\n        f[x][y] = 1;\n        \n        for(int i=0;i<t;i++){\n            for(int p=0;p<61;p++){\n                for(int q=0;q<61;q++){\n                    if(f[p][q] == 1){\n                        for(int k=0;k<6;k++){\n                            x = p + dx[k];\n                            y = q + dy[k];\n\n                            if(0 <= x && x < 61 &&\n                               0 <= y && y < 61 &&\n                                f[x][y] == 0){\n                                diff.push_back(make_pair(x,y));\n                            }\n                        }\n                    }\n                }\n            }\n            for(int j=0;j<diff.size();j++){\n                f[diff[j].first][diff[j].second] = 1;\n            }\n            diff.clear();\n        }\n        int ret = 0;\n\n        for(int i=0;i<61;i++){\n            for(int j=0;j<61;j++){\n                if(f[i][j] == 1) ret++;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define FIELDSIZE 200\n#define INF 10000\n\nint field[FIELDSIZE][FIELDSIZE];\nint offset = 100;\n\nstruct tile{\n    int x, y;\n    int turn;\n    tile(int x, int y, int turn) : x(x), y(y), turn(turn) {};\n};\n\nvoid init() {\n    for (int i = 0; i < FIELDSIZE; i++) {\n        for (int j = 0; j < FIELDSIZE; j++) {\n            field[i][j] = -1;\n        }\n    }\n//    field[0+offset][0+offset] = 0;\n//    field[-31+offset][0+offset] = INF;\n//    field[31+offset][0+offset] = INF;\n//    field[0+offset][31+offset] = INF;\n//    field[0+offset][-31+offset] = INF;\n//    field[31+offset][31+offset] = INF;\n//    field[-31+offset][-31+offset] = INF;\n}\n\n//int count = 0;\n//void visit(int x, int y, int turn) {\n//    if (field[x+offset][y+offset] == INF) {\n//        return;\n//    }\n//    if (field[x+offset][y+offset] == -1) {\n//        field[x+offset][y+offset] = turn;\n//        count++;\n//    }\n//\n//    visit(x+1, y, turn+1);\n//    visit(x-1, y, turn+1);\n//    visit(x, y+1, turn+1);\n//    visit(x, y-1, turn+1);\n//    visit(x+1, y+1, turn+1);\n//    visit(x-1, y-1, turn+1);\n//}\n\n\nint main() {\n    int last_t, n;\n\n    while (cin >> last_t >> n) {\n        if (last_t == 0 && n == 0) break;\n        init();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            field[x+offset][y+offset] = INF;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        queue<tile> q;\n        q.push(tile(start_x, start_y, 0));\n        field[start_x+offset][start_y+offset] = 0;\n        while (!q.empty()) {\n            tile t = q.front(); q.pop();\n//            cout << q.size() << endl;\n//            field[t.x+offset][t.y+offset] = t.turn;\n            //cout << t.x << endl;\n\n            if (t.turn == last_t) {\n                continue;\n            }\n\n            if (field[t.x+1+offset][t.y+offset] == -1) {\n                field[t.x+1+offset][t.y+offset] = t.turn+1;\n                q.push(tile(t.x+1, t.y, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y+offset] == -1) {\n                field[t.x-1+offset][t.y+offset] = t.turn+1;\n                q.push(tile(t.x-1, t.y, t.turn+1));\n            }\n            if (field[t.x+offset][t.y+1+offset] == -1) {\n                field[t.x+offset][t.y+1+offset] = t.turn+1;\n                q.push(tile(t.x, t.y+1, t.turn+1));\n            }\n            if (field[t.x+offset][t.y-1+offset] == -1) {\n                field[t.x+offset][t.y-1+offset] = t.turn+1;\n                q.push(tile(t.x, t.y-1, t.turn+1));\n            } \n            if (field[t.x+1+offset][t.y+1+offset] == -1) {\n                field[t.x+1+offset][t.y+1+offset] = t.turn+1;\n                q.push(tile(t.x+1, t.y+1, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y-1+offset] == -1) {\n                field[t.x-1+offset][t.y-1+offset] = t.turn+1;\n                q.push(tile(t.x-1, t.y-1, t.turn+1));\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < FIELDSIZE; i++) {\n            for (int j = 0; j < FIELDSIZE; j++) {\n                if (field[i][j] != -1 && field[i][j] != INF) {\n                    count++;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAX_RANGE 100\n\nstruct POS\n{\n\tint X,Y,far;\n};\n\nPOS move(POS &now, POS &power)\n{\n\tPOS ans = {now.X+power.X, now.Y+power.Y, now.far+1};\n\treturn ans;\n}\nbool eq(POS &a, POS &b){return a.X == b.Y && a.Y == b.Y;}\n\nPOS mpow[6]={{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\nbool list[MAX_RANGE][MAX_RANGE];\n\nint movenum(POS &start, int t, int n);\n\nint main()\n{\n\tint t,n,x,y;\n\tPOS start;\n\twhile(true){\n\t\tstd::cin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0; i<MAX_RANGE; i++)\n\t\t\tfor(int j=0; j<MAX_RANGE; j++) list[i][j] = false;\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tstd::cin >> x >> y;\n\t\t\tlist[x+MAX_RANGE/2][y+MAX_RANGE/2] = true;\n\t\t}\n\t\tstart.X = x;\n\t\tstart.Y = y;\n\t\tstart.far = 0;\n\t\tstd::cout << movenum(start, t, n) << std::endl;\n\t}\n\treturn 0;\n}\n\nint movenum(POS &start, int t, int num)\n{\n\tint n = num, mnum=1;\n\tPOS now = start;\n\tstd::queue<POS> q;\n\tfor(;;){\n\t\tif(now.far != t){\n\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\tPOS s = move(now, mpow[j]);\n\t\t\t\tif(!list[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2]){\n\t\t\t\t\tmnum++;\n\t\t\t\t\tlist[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2] = true;\n\t\t\t\t\tq.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.empty()) break;\n\t\tnow = q.front();\n\t\tq.pop();\n\t}\n\treturn mnum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000\n#define MAX_HALF 500\nusing namespace std;\n\nstruct P{\n    int x;\n    int y;\n    int cnt;\n    P(int x, int y, int cnt){\n        this->x = x;\n        this->y = y;\n        this->cnt = cnt;\n    }\n};\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[MAX][MAX];\nbool used[MAX][MAX];\n\nint t, n;\n\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < MAX; i++) for(int j = 0; j < MAX; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += MAX_HALF; y += MAX_HALF;\n            g[y][x] = 1;\n        }\n        int x, y, cnt = 0;\n        cin >> x >> y;\n        x += MAX_HALF; y += MAX_HALF;\n\n        int ans = 0;\n        queue< P > que;\n        que.push( P(x, y, 0) );\n\n        while(!que.empty()){\n            P q = que.front(); que.pop();\n            x = q.x; y = q.y; cnt = q.cnt;\n            if(cnt > t) break;\n            ans++;\n\n            used[y][x] = true;\n            for(int d = 0; d < 6; d++){\n                int nx = x + dx[d], ny = y + dy[d];\n                if(used[ny][nx] == true || g[ny][nx] == 1) continue;\n                used[ny][nx] = true;\n                que.push(P(nx, ny, cnt+1));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\nint dfs(int x, int y, int turn){\n    if(used[y][x] || g[y][x] == 1 || turn > t ) return 0;\n    used[y][x] = true;\n\n    int res = 0;\n    for(int d = 0; d < 6; d++){\n        int nx = x + dx[d], ny = y + dy[d];\n        res += dfs(nx, ny, turn+1);\n    }\n    used[y][x] = false;\n    return res + 1;\n}\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y;\n        cin >> x >> y;\n        x += 50; y += 50;\n        cout << dfs(x, y, 0) << endl;\n    }\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >>  y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\nint t,n,sx,sy;\nbool used[1111][1111];\nint dx[] = {1,-1,0,0,1,-1};\nint dy[] = {0,0,1,-1,1,-1};\nint main(void){\n  while(cin >> t >> n && t){\n    memset(used,false,sizeof(used));\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      used[x+300][y+300] = true;;\n    }\n    cin >> sx >> sy;\n\n    queue<pair<int,pair<int,int> > > que;\n    que.push(make_pair(0,make_pair(sx+30,sy+30)));\n    used[sx+300][sy+300] = true;\n    int res = 0;\n    while(!que.empty()){\n      int nt = que.front().first;\n      int x = que.front().second.first;\n      int y = que.front().second.second;\n      que.pop();\n      if(nt > t) continue;\n      res++;\n      for(int i = 0; i < 6; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(used[nx][ny]) continue;\n\tused[nx][ny] = true;\n\tque.push(make_pair(nt+1,make_pair(nx,ny)));\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\n;\nint dx[]={-1,-1,0,1,1,0};\nint dy[]={0,-1,-1,0,1,1};\nbool block[205][205];\nint mincost[205][205];\nint n,t,sx,sy;\n\nstruct Loc\n{\n  int x,y,turn;\n  Loc(int _y,int _x,int _turn)\n  {\n    x=_x,y=_y,turn=_turn;\n  }\n};\n\nint main(int argc,char const* argv[])\n{\n  while(1)\n    {\n      memset(block,false,sizeof(block));\n      cin >> t >> n;\n      if(!t) break;\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin >> x >> y;\n\t  x+=100;\n\t  y+=100;\n\t  block[y][x]=true;\n\t}\n      cin >> sx >> sy;\n      sx+=100;\n      sy+=100;\n      for(int i=0;i<=200;i++)\n\t{\n\t  for(int j=0;j<=200;j++)\n\t    {\n\t      mincost[i][j]=1000000;\n\t    }\n\t}\n      mincost[sy][sx]=0;\n      queue<Loc> q;\n      q.push(Loc(sy,sx,0));\n      while(!q.empty())\n\t{\n\t  Loc now=q.front();\n\t  q.pop();\n\t  now.turn++;\n\t  if(now.turn > t) continue;\n\t  for(int k=0;k<6;k++)\n\t    {\n\t      int nx=now.x+dx[k];\n\t      int ny=now.y+dy[k];\n\t      if(0<=nx && nx<=200 && 0<=ny && ny<=200)\n\t\t{\n\t\t  if(mincost[ny][nx]<=now.turn) continue;\n\t\t  if(block[ny][nx]) continue;\n\t\t  mincost[ny][nx]=now.turn;\n\t\t  q.push(Loc(ny,nx,now.turn));\n\t\t}\n\t    }\n\t}\n      int ans=0;\n      for(int i=0;i<=200;i++)\n\t{\n\t  for(int j=0;j<=200;j++)\n\t    {\n\t      if(mincost[i][j]!=1000000) ans++;\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint t, n;\n\tint DX[6] = { 0,1,1,0,-1,-1 }, DY[6] = { 1,1,0,-1,-1,0 };\n\twhile (cin >> t >> n&&t)\n\t{\n\t\tint z = 10;\n\t\tint a[200][200];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ta[x+z][y+z] = -2;\n\t\t}\n\t\tpii st;\n\t\tcin >> st.first >> st.second;\n\t\tst.first += z;\n\t\tst.second += z;\n\t\ta[st.first][st.second] = t;\n\t\tqueue<pii> que;\n\t\tque.push(st);\n\t\tint ans = 1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front();\n\t\t\tque.pop();\n\t\t\tif (a[now.first][now.second] == 0)continue;\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += DX[i];\n\t\t\t\tnext.second += DY[i];\n\t\t\t\tif (a[next.first][next.second] == -1)\n\t\t\t\t{\n\t\t\t\t\ta[next.first][next.second] = a[now.first][now.second] - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF int(1e9)\n\nint t, n, x, y, sx, sy, ans;\nbool used[500][500];\nint used_min[500][500]; // minimum turn\n\nint vx[6] = {0, 1, 1, 0, -1, -1},\n    vy[6] = {1, 1, 0, -1, -1, 0};\n\nint dfs(int x, int y, int turn) {\n    //cout << \"now : \" << x-250 << \" \" << y-250 << endl;\n    used[x][y] = true;\n    used_min[x][y] = (used_min[x][y] > turn) ? turn : used_min[x][y];\n\n    if (turn == t) return 0;\n\n    int ret = 0;\n\n    for (int i = 0; i < 6; ++i) {\n        int nx = x + vx[i], ny = y + vy[i];\n        if (!used[nx][ny]) {\n            ret += dfs(nx, ny, turn + 1);\n            ret++;\n        }\n        else if (used[nx][ny] && used_min[nx][ny] >= turn) {\n            ret += dfs(nx, ny, turn + 1);\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> t >> n, t | n) {\n        for (int i = 0; i < 500; ++i) {\n            for (int j = 0; j < 500; ++j) {\n                used[i][j] = false;\n                used_min[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y;\n            x += 250; y += 250;\n            used[x][y] = true;\n            used_min[x][y] = -INF;\n        }\n        cin >> sx >> sy;\n\n        ans = dfs(sx + 250, sy + 250, 0);\n\n        cout << ans + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dx[6]={-1,-1, 0, 0, 1, 1};\nint dy[6]={-1, 0,-1, 1, 0, 1};\n\nstruct info{\n    int x,y,t;\n    info(int x, int y, int t):x(x),y(y),t(t){}\n};\n\n                              \nint main(){\n    while(1){\n        int t,n;\n        cin >> t >> n;\n        if(t==0) break;\n\n        vector<vector<bool> > map(121, vector<bool>(121,true));\n        for(int i=0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            map[x+60][y+60]=false;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=60; sy+=60;\n\n        queue<info> q;\n        q.push(info(sx,sy,t));\n        map[sx][sy] = false;\n        int count = 1;\n        while(!q.empty()){\n            info now = q.front();\n            q.pop();\n            if(now.t<=0) continue;\n            for(int i=0; i<6; i++){\n                if(map[now.x+dx[i]][now.y+dy[i]]){\n                    map[now.x+dx[i]][now.y+dy[i]] = false;\n                    q.push(info(now.x+dx[i], now.y+dy[i], now.t-1));\n                    count++;\n                }\n            }       \n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\tdo{i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}while(i<n-1);\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \n#define BLANK 0\n#define BLOCK 1\n#define POSSIBLE 2\n#define CENTER 30\n#define MAX 90+1\n \nstruct point{int x,y,d;};\n \nint main()\n{\n  int t,n,cnt;\n  int i,j,a,b;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  int field[MAX][MAX];\n  queue<point> q;\n  point p,p2;\n  while(cin>>t>>n,t||n){\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)field[i][j]=BLANK;\n    for(i=0;i<n;i++){\n      cin>>a>>b;\n      field[a+CENTER][b+CENTER]=BLOCK;\n    }\n \n    cnt=1;\n    while(!q.empty())q.pop();\n    cin>>a>>b;\n    p.x=a+CENTER;\n    p.y=b+CENTER;\n    p.d=0;\n    q.push(p);\nfield[p.x][p.y]=POSSIBLE;\n    while(!q.empty()){\n      p=q.front();\n      q.pop();\n      if(p.d>=t)continue;\n      for(i=0;i<6;i++){\n        p2.x=p.x+dx[i];\n        p2.y=p.y+dy[i];\n        p2.d=p.d+1;\n        if(field[p2.x][p2.y]==BLANK){\ncnt++;\nq.push(p2);\nfield[p2.x][p2.y]=POSSIBLE;\n}\n      }\n    }\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\ntemplate<typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {0, 1, 1, 0, -1, -1};\n\nint main(void) {\n  int t, n;\n  while (cin >> t >> n, t) {\n    map<pii, int> mp;\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      mp[pii(x, y)] = -1;\n    }\n\n    int sx, sy;\n    cin >> sx >> sy;\n\n    queue<pii> que;\n    que.push(pii(sx, sy));\n    while (!que.empty()) {\n      pii v = que.front(); que.pop();\n      if (mp[v] == t) continue;\n      for (int i = 0; i < 6; i++) {\n        int nx = v.first + dx[i], ny = v.second + dy[i];\n        if ((nx == sx && ny == sy) || mp[pii(nx, ny)] != 0) continue;\n        mp[pii(nx, ny)] = mp[v] + 1;\n        que.push(pii(nx, ny));\n      }\n    }\n\n    int ans = 1;\n    for (int i = -100; i <= 100; i++) {\n      for (int j = -100; j <= 100; j++) {\n        ans += mp[pii(i, j)] > 0;\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n && (t || n)) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[a][b] = 2;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[a][b]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[x][y] == 1) {\n\t\t\t\t\tg[x][y]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[nx][ny] == 0) {\n\t\t\t\t\t\t\t//debug2(nx, ny);\n\t\t\t\t\t\t\ts.insert(Pii(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 0, 1,-1};\nconst int dy[] = {1, 0,-1,-1, 1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[66][66];\n        for (int i = 0; i < 66; i++) for (int j = 0; j < 66; j++) d[i][j] = INF;\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 30][t2 + 30] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 30][y + 30] = 0;\n        queue<P> q;\n        q.push(P(x + 30, y + 30));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (0 <= nx && nx <= 60 && 0 <= ny && ny <= 60) {\n                    if (d[nx][ny] != -1 && d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                        if (d[nx][ny] == INF) count++;\n                        q.push(P(nx,ny));\n                        d[nx][ny] = d[p.first][p.second] + 1;\n                    }\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nint fi[130][130];\nint d[130][130];\nint xx,yy;\n\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tint t,n; cin >> t >> n;\n\t\tif(t==0&&n==0)break;\n\t\tfor(int i=0;i<130;i++){\n\t\t\tfor(int j=0;j<130;j++){\n\t\t\t\tfi[i][j]=1;\n\t\t\t\td[i][j]=1e9;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y; cin >> x >> y;\n\t\t\tx+=60; y+=60;\n\t\t\tfi[x][y]=0;\n\t\t}\n\t\tcin >> xx >> yy;\n\t\txx+=60; yy+=60;\n\t\td[xx][yy]=0;\n\t\tqueue<pair<int,int>> q;\n\t\tq.push(make_pair(xx,yy));\n\t\twhile(q.size()){\n\t\t\tauto p=q.front(); q.pop();\n\t\t\tint x=p.first,y=p.second;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\tif(0<=nx&&nx<130&&0<=ny&&ny<130){\n\t\t\t\t\tif(fi[nx][ny]==0)continue;\n\t\t\t\t\tif(d[nx][ny]>d[x][y]+1){\n\t\t\t\t\t\td[nx][ny]=d[x][y]+1;\n\t\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<130;i++){\n\t\t\tfor(int j=0;j<130;j++){\n\t\t\t\tif(d[i][j]<=t)res++;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#ifdef __GNUC__\n#include <bits/stdc++.h>\n#else\n#define _CRT_SECURE_NO_WARNINGS\n#include <__msvc_all_public_headers.hpp>\n#undef min\n#undef max\n#endif\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c == '1'; }\ninline void InputF(string& v) {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define ind input(ld)\n#define input2(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) input2(int, __VA_ARGS__)\n#define LL(...) input2(ll, __VA_ARGS__)\n#define STR(...) input2(string, __VA_ARGS__)\n#define DOUBLE(...) input2(ld, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(ll v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tOutput& operator()() { printf(\"%s\", D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; return *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() { cout.flush(); return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\ttemplate<class T>inline int pop_count(T n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T{ 1 } << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Point {\n\tstatic int H, W;\n\tstatic const vector<Point> d;\n\tstatic void set_range(int _H, int _W) { H = _H; W = _W; }\n\tstatic constexpr Point zero() { return { 0,0 }; }\n\tstatic constexpr Point one() { return { 1,1 }; }\n\tint x, y;\n\tconstexpr Point() :x(0), y(0) {}\n\tconstexpr Point(int _x, int _y) : x(_x), y(_y) {}\n\tconstexpr Point(const pair<int, int>& xy) : x(xy.first), y(xy.second) {}\n\tPoint(int n) :x(n% W), y(n / W) {}\n\tconstexpr Point operator+()const { return *this; }\n\tconstexpr Point operator-()const { return { -x,-y }; }\n\tconstexpr Point operator+(const Point& p)const { return Point(*this) += p; }\n\tconstexpr Point operator-(const Point& p)const { return Point(*this) -= p; }\n\tconstexpr Point operator*(const Point& p)const { return Point(*this) *= p; }\n\tconstexpr Point operator/(const Point& p)const { return Point(*this) /= p; }\n\tconstexpr Point operator+(int n)const { return Point(*this) += Point(n, n); }\n\tconstexpr Point operator-(int n)const { return Point(*this) -= Point(n, n); }\n\tconstexpr Point operator*(int n)const { return Point(*this) *= Point(n, n); }\n\tconstexpr Point operator/(int n)const { return Point(*this) /= Point(n, n); }\n\tconstexpr Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tconstexpr Point& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tconstexpr Point& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tconstexpr Point& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tconstexpr Point& operator+=(int n) { x += n; x += n; return *this; }\n\tconstexpr Point& operator-=(int n) { x -= n; x -= n; return *this; }\n\tconstexpr Point& operator*=(int n) { x *= n; x *= n; return *this; }\n\tconstexpr Point& operator/=(int n) { x /= n; x /= n; return *this; }\n\tbool operator==(const Point& p)const { return to_i() == p.to_i(); }\n\tbool operator!=(const Point& p)const { return to_i() != p.to_i(); }\n\tbool operator<(const Point& p)const { return to_i() < p.to_i(); }\n\tbool operator<=(const Point& p)const { return to_i() <= p.to_i(); }\n\tbool operator>(const Point& p)const { return to_i() > p.to_i(); }\n\tbool operator>=(const Point& p)const { return to_i() >= p.to_i(); }\n\tconstexpr int operator[](int i)const { return i == 0 ? x : i == 1 ? y : 0; }\n\tbool in_range()const { return 0 <= x && x < W && 0 <= y && y < H; }\n\tint to_i()const { return x + y * W; }\n\tconstexpr pair<int, int> to_pair()const { return { x,y }; }\n\tint dist(const Point& p)const { return std::abs(x - p.x) + std::abs(y - p.y); }\n\tPoint abs(const Point& p)const { return { std::abs(x - p.x),std::abs(y - p.y) }; }\n\tPoint& swap() { std::swap(x, y); return *this; }\n\tvector<Point> adjacent4()const {\n\t\tvector<Point> v(4); for (int i = 0; i < 4; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent8()const {\n\t\tvector<Point> v(8); for (int i = 0; i < 8; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent6()const {\n\t\tvector<Point> v(6); for (int i = 0; i < 6; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adj4_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent4())if (P.in_range())v.push_back(P); return v;\n\t}\n\tvector<Point> adj8_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent8())if (P.in_range())v.push_back(P); return v;\n\t}\n\tconstexpr Point left()const { return { x - 1,y }; }\n\tconstexpr Point right()const { return { x + 1,y }; }\n\tconstexpr Point up()const { return { x,y - 1 }; }\n\tconstexpr Point down()const { return { x,y + 1 }; }\n\tconstexpr Point moved(char c)const { return Point(*this).move(c); }\n\tconstexpr Point& move(char c) {\n\t\tswitch (c) {\n\t\tcase 'L':case 'l':x--; break;\n\t\tcase 'R':case 'r':x++; break;\n\t\tcase 'U':case 'u':y--; break;\n\t\tcase 'D':case 'd':y++; break;\n\t\t}\n\t\treturn *this;\n\t}\n};\nint Point::H, Point::W;\nconst vector<Point> Point::d{ {-1,0},{0,1},{1,0},{0,-1},{-1,-1},{ 1,1 },{-1,1},{1,-1} };\ninline ostream& operator<<(ostream& os, const Point& p) { return os << '(' << p.x << \", \" << p.y << ')'; }\ninline istream& operator>>(istream& is, Point& p) { return is >> p.y >> p.x; }\n\nint main() {\n\tfor (int t = in, n = in; t + n; in(t, n)) {\n\t\tset<PII> flag;\n\t\trep(i, n) {\n\t\t\tINT(x, y);\n\t\t\tflag.emplace(x, y);\n\t\t}\n\t\tINT(x, y);\n\n\t\tqueue<PII> q; q.emplace(x, y);\n\t\tmap<PII, int> dist; dist[q.front()] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tauto f = q.front(); q.pop();\n\t\t\tif (dist[f] == t)continue;\n\t\t\tfor (auto P : Point(f).adjacent6()) {\n\t\t\t\tauto p = P.to_pair();\n\t\t\t\tif (!flag.count(p) && !dist.count(p)) {\n\t\t\t\t\tdist[p] = dist[f] + 1;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout(sz(dist));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \n#define BLANK 0\n#define BLOCK 1\n#define POSSIBLE 2\n#define CENTER 30\n#define MAX 60+60+1\n \nstruct point{int x,y,d;};\n \nint main()\n{\n  int t,n,cnt;\n  int i,j,a,b;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  int field[MAX][MAX];\n  queue<point> q;\n  point p,p2;\n  while(cin>>t>>n,t||n){\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)field[i][j]=BLANK;\n    for(i=0;i<n;i++){\n      cin>>a>>b;\n      field[a+CENTER][b+CENTER]=BLOCK;\n    }\n \n    while(!q.empty())q.pop();\n    cin>>a>>b;\n    p.x=a+CENTER;\n    p.y=b+CENTER;\n    p.d=0;\n    q.push(p);\n    while(!q.empty()){\n      p=q.front();\n      q.pop();\n      field[p.x][p.y]=POSSIBLE;\n      if(p.d>=t)continue;\n      for(i=0;i<6;i++){\n        p2.x=p.x+dx[i];\n        p2.y=p.y+dy[i];\n        p2.d=p.d+1;\n        if(field[p2.x][p2.y]==BLANK)q.push(p2);\n      }\n    }\n    cnt=0;\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)if(field[i][j]==POSSIBLE)cnt++;\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\nint bfs(int sx , int sy , int t ,map<P,int> s ,map<P,bool> b ){\n\ts[P(sx,sy)] = 0;\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tint cnt = s[P(x,y)];\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( b[P(mx,my)] ) continue;\n\n\t\t\tif( cnt + 1 <= t && s[P(mx,my)] == INF ){\n\t\t\t\ts[P(mx,my)] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint result = 0;\n\tfor(int y=-50 ; y <= 50 ; y++ ){\n\t\tfor(int x = -50 ; x <= 50 ; x++ ){\n\t\t\tif( s[P(x,y)] != INF ){\n\t\t\t\tresult++;\n\t\t\t} \n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\t// s[P(x,y)] := ツ鳴「ツ探ツ催オツづ個づ?つォINF, ツ探ツ催オツ催渉づ敖づ個づ?つォツタツーツδ督青板つェツ禿シツづゥ\n\t\tmap<P,int> s;\n\t\t// b[P(x,y)] := ツ津環づェツづ按つ「ツづ?つォtrue\n\t\tmap<P,bool> b;\n\n\t\tfor(int y=-50 ; y <= 50 ; y++ ){\n\t\t\tfor(int x = -50 ; x <= 50 ; x++ ){\n\t\t\t\ts[P(x,y)] = INF;\n\t\t\t\tb[P(x,y)] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tb[P(x,y)] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = bfs( sx , sy , t , s , b );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n) {\n\t\tif (!t && !n) break;\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[a][b] = 2;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[a][b]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[x][y] == 1) {\n\t\t\t\t\tg[x][y]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[nx][ny] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> point;\n\n// up right down left\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nconst double EPS = 1e-9;\nconst int days[]     = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int ddx[] = {0,-1,-1,0,1,1};\nconst int ddy[] = {1,0,-1,-1,0,1};\n\ntypedef pair<pair<int,int>,int>  qp;\n\nint &qy(qp &q){\n    return q.first.first;\n}\nint &qx(qp &q){\n    return q.first.second;\n}\nint &qd(qp &q){\n    return q.second;\n}\n\nqp make_qp(int y,int x,int depth){\n    return mp(mp(y,x),depth);\n}\n\nint main(){\n    while(true){\n        const int width = 200;\n        const int height = 200;\n        const char got = 'o',emp = '.',obj = 'x';\n        vector<vector<char> > F(height,vector<char>(width,emp));\n        int t,n;\n        cin >> t >> n;\n        if(t==0) break;\n        rep(i,n){\n            int x,y;\n            cin >> x >> y;\n            x+=width/2;y+=height/2;\n            F[y][x] = obj;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=width/2;sy+=height/2;\n\n        queue<qp> Q;\n        F[sy][sx] = got;\n        Q.push(make_qp(sy,sx,0));\n\n        while(!Q.empty()){\n            qp q = Q.front();\n            Q.pop();\n            if(qd(q) == t) continue;\n            rep(i,6){\n                int ny = qy(q) + ddy[i];\n                int nx = qx(q) + ddx[i];\n                if(F[ny][nx] == emp){\n                    F[ny][nx] = got;\n                    Q.push(make_qp(ny,nx,qd(q)+1));\n                }\n            }\n        }\n        int cnt = 0;\n        rep(i,height) rep(j,width){\n            if(F[i][j] == got){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dx[] = { 1, 0, -1, -1, 0, 1 };\nconst int dy[] = { 0, -1, -1, 0, 1, 1 };\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint t, n;\n\t\tcin >> t >> n;\n\n\t\tif ( !( t | n ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<PII> objects;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobjects.PB( MP( x, y ) );\n\t\t}\n\t\tsort( ALL( objects ) );\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<PII> que;\n\t\tque.push( MP( sx, sy ) );\n\t\tmap<PII,int> distance;\n\t\tdistance[ MP( sx, sy ) ] = 0;\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tauto cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( distance[ cur ] == t )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( d, 0, 6 )\n\t\t\t{\n\t\t\t\tauto next( cur );\n\t\t\t\tnext.fst += dx[d];\n\t\t\t\tnext.snd += dy[d];\n\n\t\t\t\tif ( !binary_search( ALL( objects ), next ) && !EXIST( distance, next ) )\n\t\t\t\t{\n\t\t\t\t\tque.push( next );\n\t\t\t\t\tdistance[ next ] = distance[ cur ] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << distance.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nvector<string> feeld;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint add, id;\nvoid rec(int x, int y) {\n\tif (feeld[y][x] == 'B') {\n\t\tid |= 1;\n\t\treturn;\n\t}\n\t\n\tif (feeld[y][x] == 'W') {\n\t\tid |= 2;\n\t\treturn;\n\t}\n\t\n\tfeeld[y][x] = '-';\n\tadd++;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n\t\tif (feeld[ny][nx] == '-') continue;\n\t\trec(nx, ny);\n\t}\n}\n\nvoid solve() {\n\tint ansb = 0, answ = 0;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (feeld[i][j] == '.') {\n\t\t\t\tadd = 0; id = 0;\n\t\t\t\trec(j, i);\n\t\t\t\tif (id == 1) ansb += add;\n\t\t\t\tif (id == 2) answ += add;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ansb << \" \" << answ << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h; if (w == 0 && h == 0) break;\n\t\tfeeld.assign(h, \"\");\n\t\tfor (int i = 0; i < h; i++) cin >> feeld[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nvoid solve(int t, int n) {\n    int a[301], b[301];\n    //cout << 1 << endl;\n    rep(i, n) {\n        cin >> a[i] >> b[i];\n    }\n    //cout << 2 << endl;\n    int stx, sty;\n    cin >> stx >> sty;\n    //cout << 3 << endl;\n    rep(i, n) {\n        a[i] -= stx; b[i] -= sty;\n    }\n    queue<pair<pii, int> > q;\n    q.push({{0, 0}, 0});\n    set<pii> s;\n    s.insert({0, 0});\n    while (!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        int step = q.front().second;\n        //cout << x << \" \" << y << \" \" << step << endl;\n        q.pop();\n        if (step == t) continue;\n        rep(i, 6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 31 || ny >= 31) continue;\n            auto it = s.find({nx, ny});\n            if (it != s.end()) continue;\n            int flg = 0;\n            rep(j, n) {\n                if (nx == a[j] && ny == b[j]) {\n                    flg = 1;\n                    break;\n                }\n            }\n            if (flg) continue;\n            q.push({{nx, ny}, step + 1});\n            s.insert({nx, ny});\n        }\n    }\n    cout << s.size() << endl;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    while (cin >> t >> n && (t || n)) {\n        solve(t, n);\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define WH 100\n\nint dx[6]={ 1, 1, 0,-1,-1, 0};\nint dy[6]={ 1, 0,-1,-1, 0, 1};\n\nint main(int argc, char const *argv[])\n{\n\tint t,n;\n\tint x,y;\n\tint sx,sy;\n\n\tint f[WH][WH];\n\tint cnt;\n\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t+n==0) break;\n\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tf[i1][i2]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i1=0;i1<n;i1++){\n\t\t\tcin>>x>>y;\n\t\t\tf[y+50][x+50]=-1;\n\t\t}\n\n\t\tcin>>sx>>sy;\n\n\t\tqueue<pair<int,int> > q;\n\t\tq.push(make_pair(sx+50,sy+50));\n\n\t\twhile(!q.empty()){\n\t\t\tx=q.front().first;\n\t\t\ty=q.front().second;\n\t\t\tq.pop();\n\n\t\t\tfor(int i1=0;i1<6;i1++){\n\t\t\t\tif(f[y+dy[i1]][x+dx[i1]]==0 && f[y][x]<t){\n\t\t\t\t\tif(x+dx[i1]==sx+50 && y+dy[i1]==sy+50){}\n\t\t\t\t\telse {\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]]=f[y][x]+1;\n\t\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt=1;\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tif(f[i1][i2]>0)cnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;++i)\n#define M(a,b) make_pair(a,b)\n#define f first\n#define s second\nusing namespace std;\nint dx[]={0,0,1,1,-1,-1,},dy[]={1,-1,1,0,-1,0};\nint v[200][200],a,b,t,n;\nint main(){\n  while(cin>>t>>n,t){\n    r(i,200)r(j,200)v[i][j]=0;\n    while(n--){\n      cin>>b>>a;\n      v[a+100][b+100]=2;\n    }cin>>a>>b;int c=0;\n    queue<pair<pair<int,int>,int> >q;\n    q.push(M(M(b+100,a+100),1));\n    while(!q.empty()){\n      pair<pair<int,int>,int > p=q.front();q.pop();\n      if(p.s==t+2)continue;\n      c++;\n      v[p.f.f][p.f.s]=1;\n      r(i,6)if(!v[p.f.f+dy[i]][p.f.s+dx[i]])q.push(M(M(p.f.f+dy[i],p.f.s+dx[i]),p.s+1));\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int> P;\ntypedef tuple<int,int,int> Tr;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1};\n\nint field[100][100];\n#define MAP(x, y) field[x + 50][y + 50]\n\nint main() {\n  cout << fixed << setprecision(10);\n  int T, N;\n  while (cin >> T >> N and T) {\n    REP(i,100) REP(j,100) {\n      field[i][j] = 100;\n    }\n    REP(i, N) {\n      int x, y;\n      cin >> x >> y;\n      MAP(x, y) = -1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    priority_queue<Tr,vector<Tr>,greater<Tr>> que;\n    que.push(Tr(1,sx,sy));\n    while (!que.empty()) {\n      int turn, x, y;\n      tie(turn, x, y) = que.top(); que.pop();\n      if (turn >= MAP(x, y) || MAP(x, y) < 0) continue;\n      MAP(x, y) = turn;\n      if (turn > T) continue;\n      REP(j, 6) {\n        que.push(Tr(turn + 1, x + dx[j], y + dy[j]));\n      }\n    }\n    int sum = 0;\n    REP(i, 100) REP(j, 100) {\n      if (field[i][j] > 0 and field[i][j] < 100) sum++;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\t//stage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t,n;\nset<pair<int,int> > point;\ntypedef pair<int,int> P;\nconst int C = 50;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[103][103];\n    rep(i,103) rep(j,103) dist[i][j]=INF;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        \n        point.insert(make_pair(x,y));\n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(x,y));\n    dist[x][y]=0;\n\n    int ans = 0;\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first;\n        int y = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(point.find(P(nx,ny)) == point.end() && dist[nx][ny] == INF) {\n                dist[nx][ny] = dist[x][y]+1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n    rep(i,103) rep(j,103) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n    point.clear();\n    \n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nstruct S{int x,y,n;S(int x,int y,int n):x(x),y(y),n(n){}};\nint dx[]={1,1,0,0,-1,-1},\n\tdy[]={1,0,1,-1,0,-1};\nint main()\n{\n\tint x,y,n,t,r,i;\n\twhile(scanf(\"%d%d\",&t,&n),t)\n\t{\n\t\tint\tm[136][136]={0};\n\t\twhile(n--)\n\t\t\tscanf(\"%d%d\",&x,&y),m[y+70][x+70]=1;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tstd::queue<S>q;\n\t\tq.push(S(x+70,y+70,r=0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tS s(q.front());q.pop();\n\t\t\tif(s.n>t||m[s.y][s.x]++)continue;\n\t\t\t++r;\n\t\t\tfor(i=0;i<6;++i)q.push(S(s.x+dx[i],s.y+dy[i],s.n+1));\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={1,0,1,-1,0,-1};\nint ban[200][200];\nint bfs[200][200];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<200;i++)for(int j=0;j<200;j++)ban[i][j]=bfs[i][j]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint c,d;\n\t\t\tscanf(\"%d%d\",&c,&d);\n\t\t\tc+=100;\n\t\t\td+=100;\n\t\t\tban[c][d]=1;\n\t\t}\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tp+=100;\n\t\tq+=100;\n\t\tqueue<pair<int,int> > Q;\n\t\tQ.push(make_pair(p,q));\n\t\tbfs[p][q]=a+1;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif(bfs[row][col]==1)break;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(!bfs[row+dx[i]][col+dy[i]]&&!ban[row+dx[i]][col+dy[i]]){\n\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]-1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<200;i++)for(int j=0;j<200;j++)if(bfs[i][j])ret++;printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x,y,cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[100][100];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 50;\n      Y += 50;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mLife;\n  int mX;\n  int mY;\n  State(int life,int x,int y) : mLife(life), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mLife < s.mLife;\n  }\n\n  bool operator >(const State& s) const{\n    return mLife > s.mLife;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State> > que;\n    que.push(State(t,sx,sy));\n    stage[P(sx,sy)] = t;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\tif(abs(dx) > 40 || abs(dy) > 40) continue;\n\n\t//obstacle\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\n\t//\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && stage[P(dx,dy)] <= s.mLife-1) continue;\n\n\t//having much life is better\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && s.mLife-1 < 0) continue;\n\n\tstage[P(dx,dy)] = s.mLife-1;\n\tque.push(State(s.mLife-1,dx,dy));\n      }\n    }\n\n    int res = CoundVisitedCell(stage);\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint64 dy[6] = {0, 1, 1, 0, -1, -1};\nint64 dx[6] = {1, 1, 0, -1, -1, 0};\n\nint main(void) {\n  int64 t, n;\n  while (cin >> t >> n && t+n) {\n    vector<vector<int>> obj(200, vector<int>(200, 0));\n    REP(i, n) {\n      int64 x, y;\n      cin >> x >> y; y += 100; x += 100;\n      obj[y][x] = 1;\n    }\n    vector<vector<int>> d(200, vector<int>(200, INF));\n    queue<PII> q;\n    int64 sy, sx;\n    cin >> sx >> sy;\n    int64 res = 0;\n    q.emplace(100+sy, 100+sx);\n    d[sy+100][sx+100] = 0;\n    while (q.size()) {\n      int64 y, x;\n      tie(y, x) = q.front(); q.pop();\n      if (obj[y][x]) continue;\n      res++;\n      obj[y][x] = 1;\n      if (d[y][x] >= t) continue;\n      REP(k, 6) {\n        int64 yy = y + dy[k], xx = x + dx[k];\n//        cout << yy << \" \" << xx << \" \" << obj[yy][xx] << endl;\n        if (obj[yy][xx]) continue;\n        chmin(d[yy][xx], d[y][x] + 1);\n        q.emplace(yy, xx);\n      }\n    }\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pair<PII,int> >q;\n\t\tq.push(MP(MP(sx,sy),t));\n\t\twhile(!q.empty()){\n\t\t\tpair< PII,int> pi=q.front();q.pop();\n\t\t\tint x=pi.first.first;\n\t\t\tint y=pi.first.second;\n\t\t\tint tt=pi.second;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(MP(x+dx[i],y+dy[i]),tt-1));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nint dx[6]={-1,-1, 0, 0, 1, 1};\nint dy[6]={-1, 0,-1, 1, 0, 1};\n\nstruct info{\n    int x;\n    int y;\n    int t;\n    info(int x, int y, int t):x(x),y(y),t(t){}\n};\n\nint main(){\n    while(1){\n        int t,n;\n        cin >> t >> n;\n        if(t==0) break;\n\n        vector<vector<bool> > map(63, vector<bool>(63,true));\n        for(int i=0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            map[x+31][y+31]=false;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=31; sy+=31;\n\n        int count = 1;\n        map[sx][sy]=false;   \n        queue<info> q;\n        q.push(info(sx,sy,t));\n        while(!q.empty()){\n            info now = q.front();\n            q.pop();\n            if(now.t<=0) continue;\n            for(int i=0; i<6; i++){\n                if(map[now.x+dx[i]][now.y+dy[i]]){\n                    count++;\n                    map[now.x+dx[i]][now.y+dy[i]] = false;\n                    q.push(info(now.x+dx[i], now.y+dy[i], now.t-1));\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[6] = {1,0,-1,-1,0,1};\nconst int dy[6] = {0,-1,-1,0,1,1};\n\nint main() {\n  for(int t, n; cin >> t >> n && (t|n); ) {\n    map<pair<int,int>, int> cost;\n    for(int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      cost[make_pair(x, y)] = 0;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    int res = 1;\n    queue<pair<int,int> > que;\n    cost[make_pair(sx, sy)] = 0;\n    que.push(make_pair(sx, sy));\n    while(que.size()) {\n      int x = que.front().first;\n      int y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 6; ++k) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if(cost.count(make_pair(nx, ny))) continue;\n        res += 1;\n        cost[make_pair(nx, ny)] = cost[make_pair(x, y)] + 1;\n        if(cost[make_pair(nx, ny)] == t) continue;\n        que.push(make_pair(nx, ny));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n-1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}//cin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nint field[140][140];\nvoid setf(int x, int y, int val) {\n\tfield[x+70][y+70] = val;\n}\nint getf(int x, int y) {\n\treturn field[x+70][y+70];\n}\n\nstruct t_node {\n\tint x, y, t;\n\tt_node( int tx, int ty, int tt ) {\n\t\tx = tx;\n\t\ty = ty;\n\t\tt = tt;\n\t}\n};\nbool operator<( const t_node &lhs, const t_node &rhs ) {\n\treturn lhs.t < rhs.t;\n}\n\nconst int INF = 1<<30;\n\nint main() {\n\tint t, n;\n\twhile( cin >> t >> n, t||n ) {\n\t\tmemset( field, -1, sizeof(field) );\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tsetf(x, y, INF);\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(sx, sy, t) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n\t\t\tif( getf(tn.x, tn.y) > 0 ) continue;\n\t\t\tsetf( tn.x, tn.y, tn.t );\n\t\t\tif( tn.t == 0 ) continue;\n\t\t\tint dx[6] = {0, 1, 1,  0, -1, -1};\n\t\t\tint dy[6] = {1, 1, 0, -1, -1,  0};\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = tn.x + dx[i];\n\t\t\t\tint ny = tn.y + dy[i];\n\t\t\t\tif( getf(nx, ny) < tn.t-1 ) {\n\t\t\t\t\tque.push( t_node(nx, ny, tn.t-1) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int y=0; y<140; y++) {\n\t\t\tfor(int x=0; x<140; x++) {\n\t\t\t\tif( 0<=field[x][y] && field[x][y]<INF ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** Brave Force Story***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define CX 60  // Center of x\n#define CY 60  // Center of y\n\nint main(){\n\tint t, n;\n\tint dx[6]={1, 1, 0, -1, -1, 0};\n\tint dy[6]={0, 1, 1, 0, -1, -1};\n\t\n\twhile(cin>>t>>n, t||n){\n\t\tint sx, sy;\n\t\tint hist[121][121];\n\t\tbool obs[121][121];\n\t\tmemset(hist, -1, sizeof hist);\n\t\tmemset(obs, false, sizeof obs);\n\t\t\n\t\tREP(i, 0, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobs[y+CY][x+CX]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tqueue<pair<int, int>> qu;\n\t\tqu.push(make_pair(sy+CY, sx+CX));\n\t\thist[sy+CY][sx+CX]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\tpair<int, int> q=qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tint y=q.first, x=q.second;\n\t\t\tREP(k, 0, 6){\n\t\t\t\tint yy=y+dy[k], xx=x+dx[k];\n\t\t\t\tif(hist[yy][xx]!=-1 || obs[yy][xx]) continue;\n\t\t\t\thist[yy][xx]=hist[y][x]+1;\n\t\t\t\tif(hist[yy][xx]<t) qu.push(make_pair(yy, xx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tREP(i, 0, 121){\n\t\t\tREP(j, 0, 121){\n\t\t\t\tif(hist[i][j]!=-1) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nbool pass[100][100];\nbool used[100][100];\nint t,n;\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(pass,0,sizeof(pass));\n\t\tmemset(used,0,sizeof(used));\n\t\tint X,Y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tpass[Y+30][X+30]=true;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\tqueue<int> xs,ys,cnts;\n\t\txs.push(X+30); ys.push(Y+30); cnts.push(0);\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front(),cnt=cnts.front();\n\t\t\txs.pop(); ys.pop(); cnts.pop();\n\t\t\tused[y][x]=true;\n\t\t\tif(cnt<t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<61&&0<=ny&&ny<61&&!pass[ny][nx]&&!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny); cnts.push(cnt+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n/** Problem2253 : Brave Force Story **/\nint T;\nconst int dx0[6]={0, 1, 1, 0, -1, -1};\nconst int dy0[6]={1, 1, 0, -1, -1, 0};\nset<P> vis;\ntypedef struct {\n  P pos; int cost;\n} S;\n\nint main()\n{\n  int n, sx, sy;\n  while (cin>>T>>n, T||n) {\n    vis.clear();\n\n    rep(k, n) {\n      int x, y;\n      cin>>x>>y;\n      vis.insert(P(x, y));\n    }\n    cin >> sx >> sy;\n    S s = {P(sx, sy), 0};\n    queue<S> Q;\n    Q.push(s);\n    vis.insert(s.pos);\n    int ans = 1;\n    while (Q.size()) {\n      S t = Q.front(); Q.pop();\n      rep(i, 6) {\n        int nx=t.pos.first+dx0[i], ny=t.pos.second+dy0[i];\n        if (-30<=nx&&nx<=30 && -30<=ny&&ny<=30) {\n          if (vis.count(P(nx, ny)) == 0 && t.cost+1<=T) {\n            S ns = {P(nx, ny), t.cost+1};\n            Q.push(ns);\n            vis.insert(ns.pos);\n            ans++;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int MID = 35;\nconst int INF = 1 << 28;\nint dx[] = { 0, 1, 1, 0, -1, -1 }, dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid dfs ( int x, int y, int t, VVI& m )\n{\n\tif ( !t || m[y][x] == -1 ) {\n\t\treturn;\n\t}\n\tfor ( int d = 0; d < 6 ; ++d ) {\n\t\tint nx = x + dx[d],\n\t\t\tny = y + dy[d];\n\t\tif ( m[ny][nx] > m[y][x] + 1 ) {\n\t\t\tm[ny][nx] = m[y][x] + 1;\n\t\t\tdfs( nx, ny, t - 1, m );\n\t\t}\n\t}\n}\n\nint main() {\n\tint t, n;\n\twhile ( cin >> t >> n, t | n ) {\n\t\tVVI m( 2 * MID, VI( 2 * MID, INF ) );\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tm[y + MID][x + MID] = -1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\t\n\t\tm[sy + MID][sx + MID] = 0;\n\t\tdfs( sx + MID, sy + MID, t, m );\n\t\t\n\t\tint ans = 0;\n\t\tfor ( int y = 0; y < 2 * MID; ++y ) {\n\t\t\tfor ( int x = 0; x < 2 * MID; ++x ) {\n\t\t\t\tint val = m[y][x];\n\t\t\t\tans += 0 <= val && val < INF;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 1000000\n#define MAX 300\n#define SF 100\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n\tint n,t,sx,sy,dx[]={0,1,1,0,-1,-1},dy[]={-1,0,1,1,0,-1};\n\tint d[MAX][MAX],x,y;\n\twhile(cin>>t>>n,t||n){\n\t\tfor(int i=0;i<MAX;i++)\n\t\tfor(int j=0;j<MAX;j++)\n\t\td[i][j]=INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\td[x+SF][y+SF]=1;\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tsx+=SF;\n\t\tsy+=SF;\n\t\tqueue<P> que;\n\t\tque.push(P(sx,sy));\n\t\tint ans=0;\n\t\td[sx][sy]=0;\n\t\twhile(!que.empty()){\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tif(d[p.first][p.second]==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx=p.first+dx[i];\n\t\t\t\tint ny=p.second+dy[i];\n\t\t\t\tif(d[nx][ny]==INF){\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\td[nx][ny]=d[p.first][p.second]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<1;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 99999;\n\n\nqueue<pair<int, int> > que;\nint maze[101][101];\nint d[101][101];\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\n//今回 arr[y][x] で設計する\nvoid bfs(int sx, int sy){\n\tque.push(make_pair(sy, sx));\n\td[sy][sx] = 0;\n\n\n\twhile(que.size()){\n\t\tint y = que.front().first;\n\t\tint x = que.front().second;\n\t\tque.pop();\n\n\t\t//seach around\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(0 <= ny and ny < 101 and 0 <= nx and nx < 101 and d[ny][nx] == INF and maze[ny][nx]){\n\t\t\t\tque.push(make_pair(ny, nx));\n\t\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\nwhile(1){//start\n\tint t, n;\n\tcin >> t >> n;\n\tif(t == 0 and n == 0) break;\n\n\t//init\n\tfor(int i = 0; i < 101; i++){\n\t\tfor(int j = 0; j < 101; j++){\n\t\t\td[i][j] = INF;\n\t\t\tmaze[i][j] = 1;\n\t\t}\n\t}\n\n\t//0なら移動不可　1なら移動可能\n\tfor(int i = 0; i < n; i++){\n\t\tint tx, ty;\n\t\tcin >> tx >> ty;\n\t\tmaze[ty + 66][tx + 66] = 0;\n\t}\n\tint sx, sy;\n\tcin >> sx >> sy;\n\n\tbfs(sx + 66, sy + 66);\n\n\tint cnt = 0;\n\tfor(int i = 0; i < 101; i++){\n\t\tfor(int j = 0; j < 101; j++){\n\t\t\tif(d[i][j] <= t) cnt++;\n\t\t}\n\t}\n\n\tcout << cnt << endl;\n\t/*\n\tfor(int i = 60; i < 70; i ++){\n\t\tfor(int j = 60; j < 70; j++) cout << d[i][j] << \" \";\n\t\tcout << endl;\n\t}*/\n}//end\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\n\nvoid bfs(int y,int x,int et){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    int t = 1;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=t;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t>et) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t+1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n \n#define NMAX 50\n\ntypedef map<int,bool>::value_type VT;\n\nstruct data{\n\tint x,y,turn;\n};\n\nint main(void){\n\t\n\tint t,n;\n\tint x,y;\n\tmap<int,bool> road;\n\tqueue<data> no;\n\tdata tm,da;\n\tint dx[]={1,1,0,-1,-1,0};\n\tint dy[]={0,1,1,0,-1,-1};\n\tint cnt;\n\n\tfor(int i=-31;i<=31;i++){\n\t\tfor(int j=-31;j<=31;j++){\n\t\troad.insert(VT(i+j*100,true));\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=-30;i<=30;i++){\n\t\t\tfor(int j=-30;j<=30;j++){\n\t\t\t\troad[i+j*100]=true;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-31;i<=31;i++){\n\t\t\troad[-31+i*100]=false;\n\t\t\troad[31+i*100]=false;\n\t\t\troad[i+31*100]=false;\n\t\t\troad[i-31*100]=false;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\troad[y+x*100]=false;\n\t\t}\n\t\tcin>>x>>y;\n\t\ttm.x=x,tm.y=y,tm.turn=0;\n\t\tno.push(tm);\n\t\troad[y+x*100]=false;\n\t\tcnt=1;\n\t\twhile(!no.empty()){\n\t\t\ttm=no.front();\n\t\t\tno.pop();\n\t\t\tif(tm.turn==t){\n\t\t\t\tif(road[(tm.y)+(tm.x)*100]==true){\n\t\t\t\t\troad[(tm.y)+(tm.x)*100]=false;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n\t\t\t\t\tda.x=tm.x+dx[i];\n\t\t\t\t\tda.y=tm.y+dy[i];\n\t\t\t\t\tda.turn=tm.turn+1;\n\t\t\t\t\tno.push(da);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 30;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) <= 30 && abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE) <= 30 && abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nconst int N = 100;\n\nstruct point{ int x, y; };\nstatic const int dy[6] = {0,1,1,0,-1,-1};\nstatic const int dx[6] = {1,1,0,-1,-1,0};\n\nint bfs(bool *M, int x, int y, int t){\n    int temp[N * N];\n    int *dis = temp + 5050;\n\n    queue<point> q;\n    rep(i, N * N) temp[i] = INF;\n    point start_coordinate = {x, y};\n\n    dis[start_coordinate.y * N + start_coordinate.x] = 0;\n    q.push(start_coordinate);\n\n    int cnt = 1;\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,6){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= N || next.y < 0 ||next.x >= N || next.x < 0) continue;\n            if(dis[next.y * N + next.x] == INF && M[next.y * N + next.x] == 0){\n                dis[next.y * N + next.x] = dis[u.y * N + u.x] + 1;\n                if(t < dis[next.y * N + next.x]) continue;\n                //cout << next.x <<' '<<next.y<< endl;\n                cnt++;\n                q.push(next);\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int t, n, sx, sy;\n    while(cin >> t >> n, t||n){\n        bool M[N * N] = {0};\n        bool *atl = M + 5050;\n        rep(i,n){\n            int x, y;\n            cin >> x >> y;\n            atl[y * N + x] = 1;\n        }\n        cin >> sx >> sy;\n        cout << bfs(atl, sx, sy, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint a[1000][1000];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nmain()\n{\n\tint n,t;\n\twhile(cin>>t>>n,t)\n\t{\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)a[i][j]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;cin>>x>>y;a[x+500][y+500]=-1;\n\t\t}\n\t\tint x,y;cin>>x>>y;\n\t\tqueue<pair<pair<int,int>,int> >P;\n\t\tP.push(make_pair(make_pair(x+500,y+500),t));\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first.first,y=P.front().first.second,T=P.front().second;\n\t\t\tP.pop();\n\t\t\tif(T<0)continue;\n\t\t\ta[x][y]=1;\n\t\t\tfor(int r=0;r<6;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(a[tx][ty]==0)P.push(make_pair(make_pair(tx,ty),T-1));\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)cnt+=a[i][j]==1;\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n}\n\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\nint main(){\n    int n,t;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        queue<tuple<int,int,int>> q;\n        q.push(make_tuple(x+30,y+30,0));\n        while(!q.empty()){\n            auto now=q.front();\n            q.pop();\n            int x=get<0>(now);\n            int y=get<1>(now);\n            int turn=get<2>(now);\n            iscan[x][y]=1;\n            if(turn>=t)\n                continue;\n            REP(i,6){\n             int nx=x+dx[i];\n             int ny=y+dy[i];\n             if(isRange(nx,ny))\n 　　　　　if(!ob[nx][ny]&&!iscan[nx][ny])\n                q.push(make_tuple(nx,ny,turn+1));\n            }\n        }\n      int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\n\n\n                   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n\n#define N 100\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nusing namespace std;\n\nint main(void)\n{\n\n\tint t,n;\n\tint xx,yy;\n\tint x,y;\n\tint start_x,start_y;\n\t\n\tint i1,i2;\n\n\tint f[N][N];\n\n\tint num;\n\tint count;\n\n\tqueue<int> q;\n\n\n\twhile(1){\n\n\t\tfor(i1=0;i1<N;i1++){\n\t\t\tfor(i2=0;i2<N;i2++){\n\t\t\t\tf[i1][i2] = 100;\n\t\t\t}\n\t\t}\n\n\t\tcin >> t;\n\t\tcin >> n;\n\t\tif(t == 0 && n == 0) break;\n\n\n\t\tfor(i1=0;i1<n;i1++){\n\t\t\tcin >> xx;\n\t\t\tcin >> yy;\n\n\n\t\t\tf[yy+50][xx+50] = 500;\n\t\t}\n\n\t\tcount = 1;\n\t\tnum = 0;\n\n\n\t\tcin >> start_x;\n\t\tcin >> start_y;\n\n\t\tstart_x += 50;\n\t\tstart_y += 50;\n\n\t\tf[start_y][start_x] = 0;\n\t\tq.push(start_x);\n\t\tq.push(start_y);\n\n\n\t\twhile(!q.empty()) {\n\n\t\t\t\tx = q.front();\n\t\t\t\tq.pop();\n\t\t\t\ty = q.front();\n\t\t\t\tq.pop();\n\n//\t\t\t\tcout << x << \" \" << y << \" \" << num << endl;\n\n\t\t\tfor(i1=0;i1<6;i1++){\n\n\n\t\t\t\tif ( f[y][x] < t){\n\t\t\t\t\t\tnum = f[y][x];\n\n\t\t\t\t\tif (f[y+dy[i1]][x+dx[i1]]==100){\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]] = num + 1;\n\t\t\t\t\t\tq.push(x+dx[i1]);\n\t\t\t\t\t\tq.push(y+dy[i1]);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\tcout << count << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nll t, n, d[200][200];\nbool s[200][200];\n\n\nvoid bfs(ll x, ll y, ll k){\n    if(k == 0)return;\n    \n    if(d[x + 1][y] < k && !s[x + 1][y]){\n        d[x + 1][y] = k - 1;\n        bfs(x + 1, y, k - 1);\n    }\n    if(d[x - 1][y] < k && !s[x - 1][y]){\n        d[x - 1][y] = k - 1;\n        bfs(x - 1, y, k - 1);\n    }\n    if(d[x + 1][y + 1] < k && !s[x + 1][y + 1]){\n        d[x + 1][y + 1] = k - 1;\n        bfs(x + 1, y + 1, k - 1);\n    }\n    if(d[x - 1][y - 1] < k && !s[x - 1][y - 1]){\n        d[x - 1][y - 1] = k - 1;\n        bfs(x - 1, y - 1, k - 1);\n    }\n    if(d[x][y + 1] < k && !s[x][y + 1]){\n        d[x][y + 1] = k - 1;\n        bfs(x, y + 1, k - 1);\n    }\n    if(d[x][y - 1] < k && !s[x][y - 1]){\n        d[x][y - 1] = k - 1;\n        bfs(x, y - 1, k - 1);\n    }\n}\n\nint main() {\n    ll sx, sy;\n    \n    cin >> t >> n;\n    \n    while(t != 0 || n != 0){\n        REP(i, 200){\n            REP(j, 200){\n                d[i][j] = -INF;\n                s[i][j] = false;\n            }\n        }\n        \n        REP(i, n){\n            ll x, y;\n            cin >> x >> y;\n            s[x + 100][y + 100] = true;\n        }\n        \n        cin >> sx >> sy;\n        \n        d[sx + 100][sy + 100] = t;\n        bfs(sx + 100, sy + 100, t);\n        \n        ll ans = 0;\n        REP(i, 200){\n            REP(j, 200){\n                if(d[i][j] != -INF)ans++;\n            }\n        }\n        \n        cout << ans << endl;\n        \n        cin >> t >> n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nclass state{\npublic:\n\tint x;\n\tint y;\n\tint turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tif(field[s.x+1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y+1, s.turn+1));\n\t\t\t\t\tfield[s.x][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x-1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y-1, s.turn+1));\t\n\t\t\t\t\tfield[s.x][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x+1][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y+1, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y-1, s.turn+1));\n\t\t\t\t\tfield[s.x-1][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=t+1;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]<t){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\nclass Integer {\n\tint value;\npublic:\n\tInteger() : value(0) {}\n\tInteger(int x) : value(x) {}\n\toperator int() const {return value;}\n};\nconst int dx[] = {1, 0, -1, -1, 0, 1};\nconst int dy[] = {0, -1, -1, 0, 1, 1};\n\nint main () {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tmap<int, map<int, Integer> > blocks;\n\t\tmap<int, map<int, Integer> > visited;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tblocks[x][y] = 1;\n\t\t}\n\t\tint count = 0;\n\t\tqueue<pair<int, pair<int, int> > > que;\n\t\tpair<int, int> pos;\n\t\tcin >> pos.first >> pos.second;\n\t\tque.push(make_pair(0, pos));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, pair<int, int> > current = que.front();\n\t\t\tconst int s = current.first;\n\t\t\tconst int x = current.second.first;\n\t\t\tconst int y = current.second.second;\n\t\t\tque.pop();\n\t\t\tif (visited[x][y]) continue;\n\t\t\tvisited[x][y] = 1;\n\t\t\tcount++;\n\t\t\tif (s == t) continue;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tconst int nx = x + dx[i];\n\t\t\t\tconst int ny = y + dy[i];\n\t\t\t\tif (abs(nx) <= 60 && abs(ny) <= 30 && !blocks[nx][ny]) {\n\t\t\t\t\tque.push(make_pair(s + 1, make_pair(nx, ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) loop(i,0,n)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint n,m;\nint dx[]={-1,-1,0,0,1,1};\nint dy[]={0,-1,1,-1,1,0};\nconst int inf=1000000010;\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tvvi used(200,vi(200,inf));\n\t\trep(i,m){\n\t\t\tint a,b;cin>>a>>b;\n\t\t\ta+=100;b+=100;\n\t\t\tused[a][b]=-1;\n\t\t}\n\t\tint a,b;cin>>a>>b;\n\t\ta+=100;b+=100;\n\t\tqueue<pii>q;\n\t\tq.push({a,b});\n\t\tused[a][b]=0;\n\t\twhile(!q.empty()){\n\t\t\tpii t=q.front();\n\t\t\tq.pop();\n\t\t\trep(i,6){\n\t\t\t\tint x=t.first+dx[i];\n\t\t\t\tint y=t.second+dy[i];\n\t\t\t\tint c=used[t.first][t.second]+1;\n\t\t\t\tif(used[x][y]==-1)continue;\n\t\t\t\tif(c<used[x][y]&&c<=n){\n\t\t\t\t\tused[x][y]=c;\n\t\t\t\t\tq.push({x,y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint co=0;\n\t\trep(i,200)rep(j,200)if(used[i][j]!=-1&&used[i][j]<inf)co++;\n\t\t\n\t\tcout<<co<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconstexpr int dx[] = {1, 0, -1, -1, 0, 1};\nconstexpr int dy[] = {0, -1, -1, 0, 1, 1};\n\nbool solve(){\n    int t, n;\n    cin >> t >> n;\n    if(t == 0) return true;\n    set<P> ng, visited;\n    for(int i=0;i<n;i++){\n        int x, y;\n        cin >> x >> y;\n        ng.insert(P(x,y));\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    queue<P> que;\n    map<P,int> dist;\n    que.push(P(sx,sy));\n    visited.insert(P(sx,sy));\n    dist[P(sx,sy)] = t;\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        if(dist[p] == 0) continue;\n        int x = p.first, y = p.second;\n        for(int k=0;k<6;k++){\n            int nx = x+dx[k], ny = y+dy[k];\n            if(ng.count(P(nx,ny)) || visited.count(P(nx,ny))) continue;\n            visited.insert(P(nx,ny));\n            que.push(P(nx,ny));\n            dist[P(nx,ny)] = dist[p]-1;\n        }\n    }\n    cout << visited.size() << endl;\n    return false;\n}\n\nint main(){\n    while(!solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 100;\nconst int BASE = 35;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n\n  // cout << x << \" \"  << y << endl;\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(!wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1,1,-1};\nint dy[]={1,0,-1,0,1,-1};\nint t,n,x,y,co;\nvvi field;\nvoid dfs(int a,int b,int c){\n\tif(c==t)return;\n\trep(i,6){\n\t\tint nx=a+dx[i];\n\t\tint ny=b+dy[i];\n\t\tif(field[nx][ny]>c+1){\n\t\t\tfield[nx][ny]=c+1;\n\t\t\tdfs(nx,ny,c+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>t>>n,t|n){\n\t\tfield=vvi(200,vi(200,inf));\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tfield[100+a][100+b]=-1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tfield[100+x][100+y]=0;\n\t\tdfs(100+x,100+y,0);\n//\t\trep(i,10){rep(j,10)cout<<\" \"<<(field[45+i][45+j]==inf?0:field[45+i][45+j]);cout<<endl;}\n\t\tco=0;\n\t\trep(i,200)rep(j,200)if(field[i][j]<=t&&field[i][j]+1)co++;\n\t\tcout<<co<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nint field[100][100];\nvoid setf(int x, int y, int val) {\n    field[x+50][y+50] = val;\n}\nint getf(int x, int y) {\n    return field[x+50][y+50];\n}\n\nstruct t_node {\n    int x, y, t;\n    t_node( int tx, int ty, int tt ) {\n        x = tx;\n        y = ty;\n        t = tt;\n    }\n};\nbool operator<( const t_node &lhs, const t_node &rhs ) {\n    return lhs.t < rhs.t;\n}\n\nconst int INF = 1<<30;\n\nint main() {\n    int t, n;\n    while( cin >> t >> n, t||n ) {\n        memset( field, -1, sizeof(field) );\n        rep(i, n) {\n            int x, y;\n            cin >> x >> y;\n            setf(x, y, INF);\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        priority_queue<t_node> que;\n        que.push( t_node(sx, sy, t) );\n        while( !que.empty() ) {\n            t_node tn = que.top();\n            que.pop();\n            if( getf(tn.x, tn.y) > 0 ) continue;\n            setf( tn.x, tn.y, tn.t );\n            if( tn.t == 0 ) continue;\n            int dx[6] = {0, 1, 1,  0, -1, -1};\n            int dy[6] = {1, 1, 0, -1, -1,  0};\n            rep(i, 6) {\n                int nx = tn.x + dx[i];\n                int ny = tn.y + dy[i];\n                if( -30<=nx && nx<=30 &&\n                    -30<=ny && ny<=30 &&\n                    getf(nx, ny) <= tn.t-1 ) {\n                    que.push( t_node(nx, ny, tn.t-1) );\n                }\n            }\n        }\n        int cnt = 0;\n        for(int y=-30; y<=30; y++) {\n            for(int x=-30; x<=30; x++) {\n                int f = getf(x, y);\n                if( 0<=f && f<INF ) {\n                   cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int,P> Pii;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\nint dx[6] = {1,0,0,-1,1,-1};\nint dy[6] = {0,1,-1,0,1,-1};\n#define INF 1000000007\n#define MOD 1000000007\n#define ARRAY_MAX 300\n\nbool obstacle[ARRAY_MAX][ARRAY_MAX];\nbool used[ARRAY_MAX][ARRAY_MAX];\n\n\nint main(){\n\n    int t,n;\n    while(cin >> t >> n,t||n){\n\n        REP(i,ARRAY_MAX){\n            REP(j,ARRAY_MAX){\n                obstacle[i][j] = false;\n                used[i][j] = false;\n            }\n        }\n        int x,y;\n        REP(i,n){//障害物\n            cin >> x >> y;\n            obstacle[y+100][x+100] = true;\n        }\n        int sx,sy;//始点\n        cin >> sx >> sy;\n        int ans = 0;\n        queue<Pii> que;\n        que.push(Pii(0,P(sy+100,sx+100)));\n        while(!que.empty()){\n            Pii now = que.front();\n            que.pop();\n            if(now.first > t || used[now.second.first][now.second.second]++){\n                //ターン数を超えたor\n                continue;\n            }\n            ans++;//1箇所行けた\n            for(int i = 0;i < 6;i++){\n                int ny = now.second.first + dy[i];\n                int nx = now.second.second + dx[i];\n                if(!obstacle[ny][nx]){\n                    //障害物ではない(この時点で行けることが確定)\n                    que.push(Pii(now.first+1,P(ny,nx)));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// AOJ 2253\n\n#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <int, int> P;\n\nint field[128][128];\nint wall[128][128];\nint num[128][128];\nint dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, 0, 1};\nint t;\n\nint main(void)\n{\n\tint n;\n\twhile (cin >> t >> n){\n\t\tif (t == 0 && n == 0) break;\n\t\tint y, x;\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tnum[i][j] = 0;\n\t\t\t\twall[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\ty += 50;\n\t\t\tx += 50;\n\t\t\twall[y][x] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\t\tfield[sy][sx] = t + 1;\n\n\t\tint ret = 0;\n\t\tqueue <P> q;\n\t\tq.push(P(sy, sx));\n\t\twhile (q.size()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\tint y = p.first, x = p.second;\n\t\t\t// cout << \"DEBUG : \" << y-50 << \" \" << x-50 << \" \" << field[y][x] << endl;\n\t\t\t// field[p.first][p.second] |= 1;\n\t\t\t// さいごのたーん\n\t\t\tif (field[y][x] <= 1) break;\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif (ny < 0 || nx < 0 || 128 <= ny || 128 <= nx) continue;\n\t\t\t\tif (field[ny][nx] == 0 && wall[ny][nx] == 0){\n\t\t\t\t\tfield[ny][nx] = (field[y][x] - 1);\n\t\t\t\t\tq.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (0 < field[i][j]) {\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 50\n#define NN 2*N\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = 1000; // 何ステップで行けるのかわからない\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[x][y] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;    q.push( S(x,y,0) );\n    d[x][y] = 0;\n\n    int dx[6] = {1,1,0,-1,-1,0};\n    int dy[6] = {1,0,-1,-1,0,1};\n\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n\n      int nt = s.t+1;\n      if( nt>t ) continue;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( nx<0 || nx>=NN ) continue;\n\tif( ny<0 || ny>=NN ) continue;\n\tif( nt>=d[nx][ny] ) continue;\n\td[nx][ny]=nt; ans++;\n\tq.push( S(nx,ny,nt) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define MAX 200\n#define OFFSET 100\n\nint brd[MAX][MAX];\nint done[MAX][MAX];\n\nint t, n;\nint sx, sy;\n\nint dx[] = { 1, 1, 0, -1, -1, 0 };\nint dy[] = { 1, 0, -1, -1, 0, 1 };\n\nint ans;\n\nvoid solve(int depth, int y, int x)\n{\n\tif (depth > t) return;\n\tif (brd[y][x]) return;\n\tif (done[y][x] != -1 &&\n\t\tdepth >= done[y][x]) return;\n\tdone[y][x] = depth;\n\n\trep(i, 6)\n\t\tsolve(depth+1, y+dy[i], x+dx[i]);\n}\n\nint calc()\n{\n\tsolve(0, sy+OFFSET, sx+OFFSET);\n\tint ans = 0;\n\trep(j, MAX) rep(i, MAX)\n\t\tif (done[j][i] != -1)\n\t\t\tans++;\n\treturn ans;\n}\n\nint main(void)\n{\n\twhile (cin >> t >> n, t|n) {\n\t\tmemset(brd, 0, sizeof(brd));\n\t\tmemset(done, -1, sizeof(done));\n\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tbrd[y+OFFSET][x+OFFSET] = 1;\n\t\t}\n\n\t\tcin >> sx >> sy;\n\t\tcout << calc() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\nconst int dy[]={-1,-1,0,0,1,1};\nconst int dx[]={-1,0,-1,1,0,1};\nint main(){\n\n\tint n,t;\n\tconst int base=100;\n\twhile(cin>>t>>n&&!(t==0&&n==0)){\n\t\tbool passed[201][201];\n\t\tint isArrival[2][201][201];\n\t\tbool obj[201][201];\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tmemset(obj,0,sizeof(obj));\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tobj[y+base][x+base]=true;\n\t\t}\n\t\tint sy,sx;\n\t\tcin>>sx>>sy;\n\t\tisArrival[0][sy+base][sx+base]=1;\n\t\tpassed[sy+base][sx+base]=true;\n\t\tfor(int l = 0; l < t; l++){\n\t\t\tfor(int i = 0; i < 201; i++){\n\t\t\t\tfor(int j = 0; j < 201; j++){\n\t\t\t\t\tif(isArrival[l%2][i][j]){\n\t\t\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tif(!obj[ny][nx]){\n\t\t\t\t\t\t\t\tisArrival[(l+1)%2][ny][nx]=true;\n\t\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisArrival[l%2][i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < 201; i++){\n\t\t\tfor(int j = 0; j < 201; j++){\n\t\t\t\tif(passed[i][j])\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nstruct S{int x,y,n;S(int x,int y,int n):x(x),y(y),n(n){}};\nint dx[]={1,1,0,0,-1,-1},\n\tdy[]={1,0,1,-1,0,-1};\nint main()\n{\n\tint x,y,n,t,r,i;\n\twhile(scanf(\"%d%d\",&t,&n),t)\n\t{\n\t\tint\tm[130][130]={0};\n\t\twhile(n--)\n\t\t\tscanf(\"%d%d\",&x,&y),m[y+70][x+70]=1;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tstd::queue<S>q;\n\t\tq.push(S(x+70,y+70,r=0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tS s(q.front());q.pop();\n\t\t\tif(s.n>t||m[s.y][s.x]++)continue;\n\t\t\t++r;\n\t\t\tfor(i=0;i<6;++i)q.push(S(s.x+dx[i],s.y+dy[i],s.n+1));\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nbool isrange(int x,int y)\n{\n\treturn (-30<=x && x<=30 && -30<=y && y<=30);\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tvector<vector<int> > ob(61,vector<int>(61,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tob[x+30][y+30]=1;\n\t\t}\n\t\tpair<int,int> s;\n\t\tcin>>s.first>>s.second;\n\n\t\tqueue<pair<pair<int,int>, int> > q;\n\t\tvector<vector<int> > been(61,vector<int>(61,0));\n\t\tbeen[s.first+30][s.second+30]=1;\n\t\tq.push(make_pair(s,0));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front().first;\n\t\t\tint turn=(q.front()).second;\n\t\t\tq.pop();\n\t\t\tif(turn==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint tx=p.first+dx[i];\n\t\t\t\tint ty=p.second+dy[i];\n\t\t\t\tif(isrange(tx,ty) && (!ob[tx+30][ty+30]) && (!been[tx+30][ty+30])){\n\t\t\t\t\tbeen[tx+30][ty+30]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(tx,ty),turn+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint cnt=0;\t\t\n\t\tfor(int i=0;i<61;i++){\n\t\t\tfor(int j=0;j<61;j++)\n\t\t\t\tif(been[i][j])\n\t\t\t\t\tcnt++;\n\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 0;\n    while(!que.empty()){\n        if(cnt > n) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            if(graph[cur.first][cur.second] > cnt){\n                graph[cur.first][cur.second] = cnt;\n            }\n            REP(i, 6){\n                if(graph[cur.first + dy[i]][cur.second + dx[i]] > i){\n                    que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 61){\n            REP(j, 61){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            graph[31 + y[i]][31 + x[i]] = -INF;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define MAX 121\n#define MAR 60\n#define INF 128\n\nint main()\n{\n\tconst int dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\twhile(1) {\n\t\tbool is_wall[MAX][MAX] = {false};\n\t\tint d[MAX][MAX] = {0};\n\t\tqueue<P> que;\n\t\tint t, n;\n\t\tint px, py;\n\t\tint ans = 0;\n\t\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &t, &n);\n\t\tif(!t && !n) break;\n\t\twhile(n--) {\n\t\t\tint wx, wy;\n\t\t\tscanf(\"%d %d\", &wx, &wy);\n\t\t\tis_wall[wx+MAR][wy+MAR] = true;\n\t\t}\n\t\tscanf(\"%d %d\", &px, &py);\n\t\tque.push(P(px, py));\n\t\td[px+30][py+MAR] = 0;\n\t\twhile(!que.empty()) {\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(d[x+MAR][y+MAR] == t) continue;\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif(-30 <= xx && xx <= 30 && -30 <= yy && yy <= 30 && !is_wall[xx+MAR][yy+MAR] ) {\n\t\t\t\t\tif(d[xx+MAR][yy+MAR] > d[x+MAR][y+MAR] + 1) {\n\t\t\t\t\t\td[xx+MAR][yy+MAR] = d[x+MAR][y+MAR] + 1;\n\t\t\t\t\t\tque.push(P(xx, yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(d[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nbool isrange(int x,int y)\n{\n\treturn -30<=x && x<=30 && -30<=y && y<=30;\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tvector<vector<int> > ob(61,vector<int>(61,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tob[x+30][y+30]=1;\n\t\t}\n\t\tpair<int,int> s;\n\t\tcin>>s.first>>s.second;\n\t\tqueue<pair<pair<int,int>, int> > q;\n\t\tvector<vector<int> > been(61,vector<int>(61,0));\n\t\tq.push(make_pair(s,0));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front().first;\n\t\t\tint turn=q.front().second;\n            q.pop();\n\t\t\tbeen[p.first+30][p.second+30]=1;\n\t\t\tif(turn==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n\t\t\t\tif(isrange(tox,toy) && !ob[tox+30][toy+30] && !been[tox+30][toy+30]){\n\t\t\t\t\tbeen[tox+30][toy+30]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(tox,toy),turn+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint cnt=0;\t\t\n\t\tfor(int i=0;i<61;i++){\n\t\t\tfor(int j=0;j<61;j++)\n                cnt+=been[i][j];\n\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<tuple>\n#include<climits>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\nconst int INF = INT_MAX / 3 - 1;\nconst double EPS = 1e-9;\nconst int dx4[] = { 1,0,-1,0 };\nconst int dy4[] = { 0,1,0,-1 };\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x, int y) {\n\treturn 0 <= x && x <= 60 && 0 <= y && y <= 60;\n\n}\n\nint dx[6] = { 0,0,1,1,-1,-1 };\nint dy[6] = { 1,-1,0,1,0,-1 };\n\nint main() {\n\tint n, t;\n\twhile (cin >> t >> n, t) {\n\t\tvvi ob(61, vi(61, 0));\n\t\tvvi iscan(61, vi(61, 0));\n\t\tint x, y;\n\t\tREP(i, n) cin >> x >> y, ob[x + 30][y + 30] = 1;\n\t\tcin >> x >> y;\n\t\tqueue<tuple<int, int, int>> q;\n\t\tq.push(make_tuple(x + 30, y + 30, 0));\n\t\twhile (!q.empty()) {\n\t\t\tauto now = q.front();\n\t\t\tq.pop();\n\t\t\tint x = get<0>(now);\n\t\t\tint y = get<1>(now);\n\t\t\tint turn = get<2>(now);\n\t\t\tiscan[x][y] = 1;\n\t\t\tif (turn >= t)\n\t\t\t\tcontinue;\n\t\t\tREP(i, 6) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (isRange(nx, ny))\n\t\t\t\t\tif (!ob[nx][ny] && !iscan[nx][ny])\n\t\t\t\t\t\tq.push(make_tuple(nx, ny, turn + 1));\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 61)\n\t\t\tREP(j, 61)\n\t\t\tif (iscan[i][j])\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\n\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n, block[100][100];\nbool used[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, false, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = 1;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,pair<int,int> > > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      //if (tx < 0 || ty < 0 || tx >= 60 || ty >= 60) continue;\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint d[]={0,1,-1};\n#define piii pair<pii,int>\npiii _pi(pii t,int h) {piii hoge; hoge.first=t; hoge.second=h; return hoge;}\nint main(){\n    int t,n;\n    while(cin>>t>>n, t+n){\n        map<pii,int>mp;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            temp=pii(temp.first+300,temp.second+300);\n            mp[temp]++;\n        }\n        pii s; cin>>s.first>>s.second;\n        s=pii(s.first+300,s.second+300);\n        vvi visit(1001,vi(1001,INF));\n        queue<piii>que;\n        que.push(_pi(s, 0));\n        int ans=0;\n        while(!que.empty()){\n            piii now=que.front(); que.pop();\n            if(mp[now.first])continue;\n            if(now.second>t)continue;\n            if(visit[now.first.first][now.first.second]==INF)ans++;\n            if(visit[now.first.first][now.first.second]<now.second)continue;\n            visit[now.first.first][now.first.second]=now.second;\n            rep(i,3)rep(j,3){\n                if(d[i]+d[j]==0)continue;\n                pii hoge=pii(now.first.first+d[i],now.first.second+d[j]);\n                if(visit[hoge.first][hoge.second]<now.second+1)continue;\n                que.push(_pi(hoge,now.second+1));\n            }\n        }\n       // int ans=0;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 0;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tint field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = 1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tsum++;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>20){if(!field[x-1][y]){field[x-1][y] = 1;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>20){if(!field[x][y-1]){field[x][y-1] = 1;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<80){if(!field[x+1][y]){field[x+1][y] = 1;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<80){if(!field[x][y+1]){field[x][y+1] = 1;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>20 && y>20){if(!field[x-1][y-1]){field[x-1][y-1] = 1;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<80 && y<80){if(!field[x+1][y+1]){field[x+1][y+1] = 1;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 70;\nconst int D = 31;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint main(void){\n    for(int t, n, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vector< vector<bool> > trap(N, vector<bool>(N));\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            trap[y + D][x + D] = true;\n        }\n        rep(i, N) trap[0][i] = trap[D * 2][i] = trap[i][0] = trap[i][D * 2] = true;\n\n        pii s; cin >> s.X >> s.Y;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(mp(s.X + D, s.Y + D), 0));\n\n        while(!q.empty()){\n            pii p = q.front().first;\n            int turn = q.front().second;\n            q.pop();\n\n            if(turn == t + 1) continue;\n            if(trap[p.Y][p.X]) continue;\n\n            res++;\n            trap[p.Y][p.X] = true;\n\n            rep(i, 6){\n                q.push(mp(mp(p.X + dx[i], p.Y + dy[i]), turn + 1));\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define K (50)\n#define INF (1145141919)\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, 1, 0, -1, -1};\nconst int dy[] = {0, 1, 1, 0, -1, -1, 0};\n\nbool map[100][100];\nbool dp[100][100][100];\n\nint main()\n{\n\tint t, n;\n\twhile (scanf(\"%d %d\", &t, &n), t + n){\n\t\tmemset(map, false, sizeof(map));\n\t\tmemset(dp, false, sizeof(dp));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\n\t\t\tmap[x + K][y + K] = true;\n\t\t}\n\t\t\n\t\tint X, Y;\n\t\tscanf(\"%d %d\", &X, &Y);\n\t\tdp[0][X + K][Y + K] = true;\n\t\t\n\t\tfor (int i = 0; i < t; i++){\n\t\t\tfor (int x = 0; x < 100; x++){\n\t\t\t\tfor (int y = 0; y < 100; y++){\n\t\t\t\t\tif (dp[i][x][y] && !map[x][y]){\n\t\t\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\t\t\tif (!map[x + dx[j]][y + dy[j]]){\n\t\t\t\t\t\t\t\tdp[i + 1][x + dx[j]][y + dy[j]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tcnt += dp[t][i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nconst int INF = 1000000000;\n#define SF 40\n\n\nint visit[130][130],ans;\nint dx[]={1,1,0,-1,-1,0},dy[]={1,0,-1,-1,0,1};\n\nint t,n;\n\nvoid func(int x,int y,int rem){\n\tif (visit[y][x] >= rem) {\n\t\treturn;\n\t}\n\tif (visit[y][x] == -1) ans++;\n\tvisit[y][x] = rem;\n\t\n\tif (rem == 0) return;\n\tint nx,ny;\n\tfor(int i=0;i<6;i++){\n\t\tnx=dx[i]+x;\n\t\tny=dy[i]+y;\n\t\tfunc(nx,ny,rem-1);\n\t}\n\t\n}\n\nint main(){\n\twhile(cin>>t>>n,n||t){\n\t\tans=0;\n\t\tint x,y,sx,sy;\n\t\tfor(int i=0;i<130;i++)\n\t\tfor(int j=0;j<130;j++){\n\t\t\tvisit[i][j]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tvisit[y+SF][x+SF]=10000;\n\t\t}\n\t\tcin>>sx>>sy;\n\t\t\n\t\t\tfunc(sx+SF,sy+SF,t);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool mem[150][150];\nint T, N, d[150][150], dx[] = {0, 0, 1, -1, 1, -1}, dy[] = {1, -1, 1, -1, 0, 0};\nint bfs(int sx, int sy)\n{\n  queue<int> q;\n  d[sx][sy] = 1;\n  q.push(sx);\n  q.push(sy);\n  while(!q.empty())\n  {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    for(int i = 0; i < 6; i++)\n    {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      if(!mem[tx][ty] && d[x][y] <= T && !d[tx][ty])\n      {\n        d[tx][ty] = d[x][y] + 1;\n        q.push(tx);\n        q.push(ty);\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i < 150; i++)\n    for(int j = 0; j < 150; j++)\n      ans += d[i][j] != 0;\n  return ans;\n}\n\nint main()\n{\nloop:\n  for(int i = 0; i < 150; i++)\n    for(int j = 0; j < 150; j++)\n      mem[i][j] = d[i][j] = 0;\n  cin >> T >> N;\n  if(!T)\n    return 0;\n  for(int i = 0; i < N; i++)\n  {\n    int a, b;\n    cin >> a >> b;\n    mem[a + 75][b + 75] = 1;\n  }\n\n  int sx, sy;\n  cin >> sx >> sy;\n  cout << bfs(sx + 75, sy + 75) << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint field[100][100];\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tqueue<int> point_x;\n\t\tqueue<int> point_y;\n\t\tqueue<int> cost;\n\t\tpoint_x.push(s_x+50);\n\t\tpoint_y.push(s_y+50);\n\t\tcost.push(t);\n\t\tint sum = 0;\n\t\twhile(!point_x.empty()){\n\t\t\tint p_x = point_x.front(), p_y = point_y.front(), log = cost.front();\n\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\tsum++;\n\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t}\n\t\t\tif(log>0){\n\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] != -1){point_x.push(p_x-1);point_y.push(p_y);cost.push(log-1);}}\n\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] != -1){point_x.push(p_x);point_y.push(p_y-1);cost.push(log-1);}}\n\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] != -1){point_x.push(p_x+1);point_y.push(p_y);cost.push(log-1);}}\n\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] != -1){point_x.push(p_x);point_y.push(p_y+1);cost.push(log-1);}}\n\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] != -1){point_x.push(p_x-1);point_y.push(p_y-1);cost.push(log-1);}}\n\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] != -1){point_x.push(p_x+1);point_y.push(p_y+1);cost.push(log-1);}}\n\t\t\t}\n\t\t\tpoint_x.pop();\n\t\t\tpoint_y.pop();\n\t\t\tcost.pop();\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {1, 0, -1, -1, 0, 1};\nconst int MAX = 121, OFFSET = 60;\nbool used[MAX][MAX];\n\nstruct state {\n\tint x, y, t;\n\tstate(int x, int y, int t):x(x), y(y), t(t){}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int t, n; cin >> t >> n, t;) {\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tused[y + OFFSET][x + OFFSET] = true;\n\t\t}\n\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tqueue<state> que;\n\t\tque.push(state(x + OFFSET, y + OFFSET, 0));\n\t\tused[y + OFFSET][x + OFFSET] = true;\n\t\tint ans = 0;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst state& s = que.front();\n\t\t\t++ans;\n\n\t\t\tif(s.t < t) {\n\t\t\t\tconst int nt = s.t + 1;\n\t\t\t\tfor(int i = 0; i < 6; ++i) {\n\t\t\t\t\tconst int nx = s.x + dx[i], ny = s.y + dy[i];\n\t\t\t\t\tif(!used[ny][nx]) {\n\t\t\t\t\t\tque.push(state(nx, ny, nt));\n\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tque.pop();\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n\nusing namespace std;\n \n#define NMAX 50\n\ntypedef map<int,bool>::value_type VT;\n\nstruct data{\n\tint x,y,turn;\n};\n\nint main(void){\n\t\n\tint t,n;\n\tint x,y;\n\tmap<int,bool> road,ok;\n\tstack<data> no;\n\tdata tm,da;\n\tint dx[]={1,1,0,-1,-1,0};\n\tint dy[]={0,1,1,0,-1,-1};\n\tint cnt;\n\n\tfor(int i=-31;i<=31;i++){\n\t\tfor(int j=-31;j<=31;j++){\n\t\troad.insert(VT(i+j*100,true));\n\t\tok.insert(VT(i+j*100,true));\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=-30;i<=30;i++){\n\t\t\tfor(int j=-30;j<=30;j++){\n\t\t\t\troad[i+j*100]=true;\n\t\t\t\tok[i+j*100]=true;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-31;i<=31;i++){\n\t\t\troad[-31+i*100]=false;\n\t\t\troad[31+i*100]=false;\n\t\t\troad[i+31*100]=false;\n\t\t\troad[i-31*100]=false;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\troad[y+x*100]=false;\n\t\t}\n\t\tcin>>x>>y;\n\t\ttm.x=x,tm.y=y,tm.turn=0;\n\t\tno.push(tm);\n\t\troad[y+x*100]=false;\n\t\tcnt=1;\n\t\twhile(!no.empty()){\n\t\t\ttm=no.top();\n\t\t\tno.pop();\n\t\t\tif(tm.turn==t){\n\t\t\t\tif(ok[tm.y+tm.x*100]==true){\n\t\t\t\t\tok[tm.y+tm.x*100]=false;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n\t\t\t\t\tda.x=tm.x+dx[i];\n\t\t\t\t\tda.y=tm.y+dy[i];\n\t\t\t\t\tda.turn=tm.turn+1;\n\t\t\t\t\tno.push(da);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint a[1000][1000];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nmain()\n{\n\tint n,t;\n\twhile(cin>>t>>n,t)\n\t{\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)a[i][j]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;cin>>x>>y;a[x+500][y+500]=-1;\n\t\t}\n\t\tint x,y;cin>>x>>y;\n\t\tqueue<pair<pair<int,int>,int> >P;\n\t\tP.push(make_pair(make_pair(x+500,y+500),t));\n\t\ta[x+500][y+500]=1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first.first,y=P.front().first.second,T=P.front().second;\n\t\t\tP.pop();\n\t\t\tif(T<=0)continue;\n\t\t\tfor(int r=0;r<6;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(a[tx][ty]==0)\n\t\t\t\t{\n\t\t\t\t\ta[tx][ty]=1;\n\t\t\t\t\tP.push(make_pair(make_pair(tx,ty),T-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)cnt+=a[i][j]==1;\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\n\n#define TEST 0\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./ans.txt\", \"w\", stdout);\n#endif\n\nusing namespace std;\n\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nmap<pair<int, int>, bool> state;\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[make_pair(nx,ny)] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[make_pair(nx, ny)]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[make_pair(nx + dx[i],ny + dy[i])]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[make_pair(x,y)]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\tcout << f(sx, sy, 0) << endl;\n\n\t\tstate.clear();\n\n\t}\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1,1,-1};\nint dy[]={1,0,-1,0,1,-1};\nint t,n,x,y,co;\nvvi field;\nvoid dfs(int a,int b,int c){\n\tif(c==t)return;\n\trep(i,6){\n\t\tint nx=a+dx[i];\n\t\tint ny=b+dy[i];\n\t\tif(field[nx][ny]>c+1){\n\t\t\tfield[nx][ny]=c+1;\n\t\t\tdfs(nx,ny,c+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>t>>n,t|n){\n\t\tfield=vvi(100,vi(100,inf));\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tfield[50+a][50+b]=-1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tfield[50+x][50+y]=0;\n\t\tdfs(50+x,50+y,0);\n\t\tco=0;\n\t\trep(i,100)rep(j,100)if(field[i][j]<=t&&field[i][j]+1)co++;\n\t\tcout<<co<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint tile[140][140];\nusing vpii = vector<pair<int,int>>;\nint dx[] = {1,-1,0,0,-1,1};\nint dy[] = {1,-1,1,-1,0,0};\n\n\nint main()\n{\n  int t,n;\n  while(cin >> t >> n,t+n){\n    REP(i,140){\n      REP(j,140){\n        tile[i][j] = 0;\n      }\n    }\n    vpii pii;\n    REP(i,n){\n      int c,k;\n      cin >> c >> k;\n      pii.push_back({k,c});\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    tile[70][70] = 1;\n    for(auto x : pii){\n      tile[x.first-sy+70][x.second-sx+70] = 2;\n    }\n    REP(_t,t){\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j] == 1){\n           REP(k,6){\n            auto ny = max(0,min(139,i + dy[k]));\n            auto nx = max(0,min(139,j+dx[k]));\n            if(tile[ny][nx]==0){\n              tile[ny][nx] = -1;\n            }\n           }\n          }\n        }\n      }\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j]==-1){\n            tile[i][j] = 1;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i,140){\n      REP(j,140){\n        if(tile[i][j]==1){\n          ans++;\n        }\n      }\n    }\n    cout << ans<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define MAX 61\n#define INF 1e9\n\nstruct P{\n  int x, y, d;\n  P(int x, int y, int d){\n    this->x = x;\n    this->y = y;\n    this->d = d;\n  }\n};\n\nint t, sx, sy;\nbool impossible[MAX][MAX];\nint dist[MAX][MAX];\nconst int dx[] = {-1,0,0,-1,1,1};\nconst int dy[] = {-1,-1,1,0,0,1};\n\nbool check(int x, int y){\n  if(0 <= x && x <= 60 && \n     0 <= y && y <= 60){\n    return true;\n  }\n  return false;\n}\n\nint bfs(int x, int y){\n  fill(dist[0],dist[MAX],INF);\n\n  queue<P> que;\n  que.push(P(x,y,0));\n  dist[x][y] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n\n    if(impossible[p.x][p.y] || p.d >= t){\n      continue;\n    }\n\n    for(int i = 0 ; i < 6 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      \n      if(!check(nx,ny) || impossible[nx][ny] ||\n         dist[nx][ny] != INF){\n        continue;\n      }\n\n      dist[nx][ny] = dist[p.x][p.y] + 1;\n      que.push(P(nx,ny,dist[nx][ny]));\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dist[i][j] != INF){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, x, y;\n\n  while(cin >> t >> n , (t | n)){\n    memset(impossible,false,sizeof(impossible));\n    for(int i = 0 ; i < n ; i++){\n      cin >> x >> y;\n      x += 30, y += 30;\n      impossible[x][y] = true;\n    }\n    cin >> sx >> sy;\n    cout << bfs(sx+30, sy+30) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_N 50\n#define MAX_M 100\n#define MAX_K 100\n\nint dx[] = { 1, 1, 0, -1, -1, 0 };\nint dy[] = { 0, 1, 1, 0, -1, -1 };\n\n\nvector<int> ans_list;\n\n\nint main(){\n\n\twhile (true){\n\n\t\tint t, n;\n\t\tcin >> t >> n;\n\n\t\tif (t == 0 && n == 0)\n\t\t\tbreak;\n\n\t\tmap<P, bool> obj;\n\t\tmap<P, bool> maze;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobj[P(x, y)] = true;\n\t\t}\n\t\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<P> que;\n\t\tqueue<int> turn;\n\t\tque.push(P(sx, sy));\n\t\tturn.push(t);\n\t\t\n\t\tmaze[P(sx, sy)] = true;\n\n\t\tint ans = 1;\n\n\t\twhile (que.size()){\n\t\t\tP p = que.front();\n\t\t\tint count = turn.front();\n\t\t\tque.pop();\n\t\t\tturn.pop();\n\t\t\tif (count == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif (!obj[P(nx, ny)] && !maze[P(nx, ny)] /*&& nx >= -30 && nx <= 30 && -30 <= ny && ny <= 30*/){\n\t\t\t\t\tans++;\n\t\t\t\t\tmaze[P(nx, ny)] = true;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tturn.push(count - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans_list.push_back(ans);\n\n\t}\n\n\n\t\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 1, 0, -1, -1, 0};\nvector<int> dx = {0, 1, 1, 0, -1, -1};\nint INF = 100;\nint main(){\n  while (1){\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0){\n      break;\n    }\n    vector<vector<bool>> ok(200, vector<bool>(200, true));\n    for (int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      x += 100;\n      y += 100;\n      ok[y][x] = false;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += 100;\n    sy += 100;\n    vector<vector<int>> d(200, vector<int>(200, INF));\n    d[sy][sx] = 0;\n    queue<pair<int, int>> Q;\n    Q.push(make_pair(sy, sx));\n    int ans = 0;\n    while (!Q.empty()){\n      int y = Q.front().first;\n      int x = Q.front().second;\n      Q.pop();\n      ans++;\n      if (d[y][x] < t){\n        for (int i = 0; i < 6; i++){\n          int y2 = y + dy[i];\n          int x2 = x + dx[i];\n          if (ok[y2][x2] && d[y2][x2] == INF){\n            d[y2][x2] = d[y][x] + 1;\n            Q.push(make_pair(y2, x2));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int, int> P;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t, n;\n  bool cango[200][200];\n  int vy[6] = {1,0,-1,-1,0,1};\n  int vx[6] = {1,1,0,-1,-1,0};\n  while(cin>>t>>n,t||n) {\n    FOR(i,0,200) FOR(j,0,200) cango[i][j] = true;\n    FOR(i,0,n) {\n      int x, y; cin >> x >> y;\n      cango[y+100][x+100] = false;\n    }\n    int sx, sy; cin >> sx >> sy;\n    int ans = 1;\n    queue<P> Q;\n    Q.push(P(sy+100, sx+100));\n    cango[sy+100][sx+100] = false;\n    FOR(i,0,t) {\n      vector<P> tmp;\n      while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        int y = p.first;\n        int x = p.second;\n        FOR(j,0,6) {\n          int ny = y + vy[j];\n          int nx = x + vx[j];\n          if(!cango[ny][nx]) continue;\n          ans++;\n          tmp.push_back(P(ny, nx));\n          cango[ny][nx] = false;\n        }\n      }\n      FOR(j,0,tmp.size()) {\n        Q.push(tmp[j]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tbool obstacle[100][100];\n\t\tmemset(obstacle, false, sizeof(obstacle));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\t\tint ans = 1;\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (obstacle[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tif (map[cy][cx] + 1> t)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tans++;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint x[100][100][2], n, m, c, d, i, j, k, sum;\n#define A(B,C) if(x[B][C][0]==0 && x[B][C][1]==0){x[B][C][0]=2;sum++;}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0) { break; }sum = 0; memset(x, 0, sizeof(x));\n\t\tfor (i = 0; i < m; i++) { cin >> c >> d; x[c + 50][d + 50][1] = 1; }cin >> c >> d; x[c][d][0] = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tfor (k = 0; k < 100; k++) {\n\t\t\t\t\tif (x[j][k][0] == 1) {\n\t\t\t\t\t\tA(j - 1, k - 1);\n\t\t\t\t\t\tA(j - 1, k);\n\t\t\t\t\t\tA(j, k - 1);\n\t\t\t\t\t\tA(j, k + 1);\n\t\t\t\t\t\tA(j + 1, k);\n\t\t\t\t\t\tA(j + 1, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < 100; j++) { for (k = 0; k < 100; k++) { if (x[j][k][0] == 2) { x[j][k][0] = 1; } } }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\nint t, n;\nint dy[] = {1, 1, 0, -1, -1, 0}, dx[] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n  while(scanf(\"%d%d\", &t, &n) && t+n){\n    int board[200][200] = {};\n    rep(i, 200) rep(j, 200) board[i][j] = INF;\n    int x, y;\n    rep(i, n){\n      scanf(\"%d%d\", &x, &y); \n      board[y+100][x+100] = -1;\n    }\n\n    scanf(\"%d%d\", &x, &y); \n    board[y+100][x+100] = 0;\n    //    printf(\"%d %d\\n\", y+100, x+100);\n    queue<pair<int,int> >q;\n    q.push(make_pair(y+100, x+100));\n    for(int k = 1; k <= t; k++){\n      //      printf(\"%d\\n\", k);\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpair<int, int>p = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", p.Y, p.X);\n\trep(j, 6){\n\t  int nx = p.X + dx[j], ny = p.Y + dy[j];\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(board[ny][nx] < k) continue;\n\t  board[ny][nx] = k;\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n\n      /*      REP(i, 90, 110){\n\tREP(j, 90, 110) printf(board[i][j] != INF?\"%2d\":\" N\", board[i][j]);\n\tputs(\"\");\n\t} */\n    }\n    int res = 0;\n    rep(i, 200) rep(j, 200) if(board[i][j] >= 0 && board[i][j] < INF) res++;\n\n\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1);\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\n\nint tx[]={1,0,-1,-1,0,1},ty[]={1,1,0,-1,-1,0};\n\nmain(){\n  int t,n;\n  while(cin>>t>>n,t|n){\n    set<PI> syo;\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      syo.insert(mp(x,y));\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<pair<PI,int> >q;\n    q.push(mp(mp(sx,sy),0));\n    set<PI> vis;\n    while(!q.empty()){\n      int c=q.front().S,cx=q.front().F.F,cy=q.front().F.S;\n      q.pop();\n      if(vis.count(mp(cx,cy)))continue;\n      vis.insert(mp(cx,cy));\n      if(c==t)continue;\n      rep(i,6){\n\tint nx=cx+tx[i],ny=cy+ty[i];\n\tif(vis.count(mp(nx,ny)) || syo.count(mp(nx,ny)))continue;\n\tq.push(mp(mp(nx,ny),c+1));\n      }\n    }\n    cout<<SZ(vis)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n/** Problem2253 : Brave Force Story **/\nint T;\nconst int dx0[6]={0, 1, 1, 0, -1, -1};\nconst int dy0[6]={1, 1, 0, -1, -1, 0};\nint ans;\nset<P> vis;\ntypedef struct {\n\tP pos; int cost;\n} S;\n\nint main()\n{\n\tint n, sx, sy;\n\twhile (cin>>T>>n, T||n) {\n\t\tvis.clear();\n\t\tans=0;\n\t\t\n\t\trep(k, n) {\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\tvis.insert(P(x, y));\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tS s = {P(sx, sy), 0};\n\t\tqueue<S> Q;\n\t\tQ.push(s);\n\t\tvis.insert(s.pos);\n\t\twhile (Q.size()) {\n\t\t\tS t = Q.front(); Q.pop();\n\t\t\t\t\t\t\t\t\t\n\t\t\trep(i, 6) {\n\t\t\t\tint nx=t.pos.first+dx0[i], ny=t.pos.second+dy0[i];\n\t\t\t\tif (-30<=nx&&nx<=30 && -30<=ny&&ny<=30) {\n\t\t\t\t\tif (vis.find(P(nx, ny)) == vis.end() && t.cost+1<=T) {\n\t\t\t\t\t\tS ns = {P(nx, ny), t.cost+1};\n\t\t\t\t\t\tQ.push(ns);\n\t\t\t\t\t\tvis.insert(ns.pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << vis.size()-n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {-1, -1, 0, 0, 1, 1}, dy[] = {-1, 0, -1, 1, 0, 1}, b[70][70], t;\n\nint dfs(int y, int x, int num) {\n  //cout << \"y:\" << y << \" x:\" << x << \" num:\" << num << endl;\n  b[y+30][x+30] = num;\n  if (num == t) {\n    return 0;\n  }\n\n  REP(i, 6) {\n    int nx = x + dx[i], ny = y + dy[i];\n    //cout << ny << \" \" << nx << \" \" << b[ny+30][nx+30] << endl;\n    if (abs(nx) <= 30 && abs(ny) <= 30 && b[ny + 30][nx + 30] > num) {\n      //cout << ny << \":\" << nx << endl;\n      dfs(ny, nx, num + 1);\n    }\n  }\n\n  return 0;\n}\n/*\n2 2\n-2 1\n2 0\n2 2\n\n2 0\n-1 1\n\n4 4\n-2 1\n1 -2\n1 2\n3 -3\n-2 0\n*/\n\nsigned main(void) {\n  while (true) {\n    int n, x[305], y[305], sx, sy;\n    cin >> t >> n;\n    if(!t && !n) break;\n    REP(i, 70) REP(j, 70) b[i][j] = INF;\n    REP(i, n) {\n      cin >> x[i] >> y[i];\n      b[y[i] + 30][x[i] + 30] = -1;\n    }\n    cin >> sx >> sy;\n\n    dfs(sy, sx, 0);\n\n    int ret = 0;\n    REP(i, 65) REP(j, 65) {\n      if (b[i][j] != INF && b[i][j] != -1) {\n        ret++;\n        //cout << i-30 << \" \" << j-30 << endl;\n      }\n    }\n\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nconst int N=150;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[N+1][N+1], d[N+1][N+1];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=N; ++i){\n\t\t\tfor(int j=0; j<=N ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+70][b+70]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=70;\n\t\tstart.y+=70;\n\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\t\n\t\twhile( !que.empty() ){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\t//printf(\" pop\\n\");\n\t\t\t\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(nx>=0 && nx<=N && ny>=0 && ny<=N && f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx;\n\t\t\t\t\ttmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t//printf(\"push\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=N; ++i){\n\t\t\tfor(int j=0; j<=N; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t\t//else printf(\"%d %d\\n\", i, j);\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 30;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] > t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE)+abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE)+abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\n\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(vector<vector<int>>& m, int Y,int X,int T){\n\tvector<vector<int>> vis(300, vector<int>(300, 0));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(Y,X,T);\n\twhile(!q.empty()){\n\t\tint y, x, t;\n\t\ttie(y,x,t)=q.front(); q.pop();\n\n\t\tif(t == 0)  continue;\n\t\tvis[y][x] = true;\n\n\t\trep(i,6){\n\t\t\tint ny=y+dy[i];\n\t\t\tint nx=x+dx[i];\n\t\t\tif(ny < 20 || ny > 80 || nx < 20 || nx > 80) continue;\n\t\t\tif(m[ny][nx] or vis[ny][nx]) continue;\n\t\t\tvis[ny][nx]=true;\n\t\t\tq.emplace(ny,nx,t-1);\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,200)rep(j,200)cnt+=vis[i][j];\n\treturn cnt;\n}\n\nsigned main(){\n\tint t,n;\n\twhile (cin>>t>>n,t) {\n\t\tvector<vector<int>> m(300, vector<int>(300, 0));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=50;y+=50;\n\t\t\tm[y][x]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tcout<<bfs(m,sy,sx,t)<<endl;\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n \n#define mp(a,b) make_pair(a, b)\n \nusing namespace std;\n \ntypedef pair<int, int> xy;\n \nint main() {\n \n    const int SIZE = 100;\n    const int OFFSET = 50;\n    const int   mx[] = {0, 1, 1, 0, -1, -1},\n                my[] = {1, 1, 0, -1, -1, 0};\n \n    int t, n;\n \n    while(cin >> t >> n,t||n) {\n        vector< vector<bool> > f(SIZE, vector<bool>(SIZE, true));\n        queue< pair< pair<int, int>, int> > open;\n \n        while (n--) {\n            int x, y;\n            cin >>x >>y;\n \n            f[y+OFFSET][x+OFFSET] = false;\n        }\n \n        int x, y, cnt = 0;\n        cin >>x >>y;\n        x += OFFSET; y += OFFSET;\n        f[y][x] = false;\n        open.push(mp(mp(x, y), 0) );\n \n        while(!open.empty()) {\n            pair<xy, int> tmp = open.front(); open.pop();\n            xy tmp2 = tmp.first;\n            int x = tmp2.first,\n                y = tmp2.second,\n                c = tmp.second;\n \n            cnt++;\n            if (c >= t) continue;\n \n            for( int i = 0; i < 6; i++) {\n                int nx = x + mx[i],\n                    ny = y + my[i];\n \n                if ( !(0 <= nx && 0 <= ny && nx < SIZE && ny < SIZE) ) continue;\n                if ( f[ny][nx] != true ) continue;\n \n                f[ny][nx] = false;\n                open.push( mp(mp(nx,ny), c+1));\n            }\n        }\n        cout <<cnt <<endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,-1}, dy[] = {0,1,0,-1,1,-1};\n\nstruct P {\n    int x, y, depth;\n};\n\nint main() {\n    int turn, block_n;\n    while (cin >> turn >> block_n, turn|block_n) {\n        bool field[62][62] = {};\n        REP(i, block_n) {\n            int x, y;\n            cin >> x >> y;\n            x += 30;\n            y += 30;\n            field[y][x] = true;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        start_x += 30;\n        start_y += 30;\n\n        int cnt = 1;\n\n        queue<P> que;\n        que.push({start_x, start_y, 0});\n        field[start_y][start_x] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.depth == turn) continue;\n            REP(i, 6) {\n                int sx = p.x + dx[i];\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx < 60 && 0 <= sy && sy < 60) {\n                    if (!field[sy][sx]) {\n                        field[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy, p.depth+1});\n                    }\n                }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint field[120][120];\n\nint main(){\n\tint t, n;\n\twhile(cin >> t>> n, t+n){\n\t\trep(i, 120)rep(j, 120) field[i][j] = inf;\n\t\tfor(int i=0; i< n; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfield[x+60][y+60] = -1;\n\t\t}\n\t\tint mx, my; cin >> mx >> my;\n\t\tmx += 60; my += 60;\n\t\tfield[mx][my] = 1;\n\t\tqueue<pair<int, int> > q;\n\t\tq.push(make_pair(mx, my));\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y]-1 == t) continue;\n\n\t\t\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\t\t\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\t\t\tfor(int i=0; i< 6; i++){\n\t\t\t\tint nx = dx[i]+x, ny = dy[i]+y;\n\t\t\t\tif(field[nx][ny] != -1 && field[x][y]+1 < field[nx][ny]){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = -30; i <= 30; i++)for(int j=-30; j <= 30; j++) if(0 < field[i+60][j+60] && field[i+60][j+60] != inf) ret++;\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[200][200], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] >= t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[200][200] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n}\n\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\nint main(){\n    int n,t;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        queue<tuple<int,int,int>> q;\n        q.push(make_tuple(x+30,y+30,0));\n        while(!q.empty()){\n            auto now=q.front();\n            q.pop();\n            int x=get<0>(now);\n            int y=get<1>(now);\n            int turn=get<2>(now);\n            iscan[x][y]=1;\n            if(turn>=t)\n                continue;\n            REP(i,6){\n             int nx=x+dx[i];\n             int ny=y+dy[i];\n             if(isRange(nx,ny))\n 　　　　if(!ob[nx][ny]&&!iscan[nx][ny])\n                q.push(make_tuple(nx,ny,turn+1));\n            }\n        }\n      int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\n\n\n                   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n-1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <complex>\n\nusing namespace std;\n\n//define\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\n#define INF (INT_MAX/3)\n#define PI (2*acos(0.0))\n#define EPS (1e-8)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int cx = 31, cy = 31;\n\nint board[62][62];\nint visited[62][62];\nint turn, obs;\nint memo[62][62][31];\n\nvoid solve(int x, int y, int t){\n  if(x > 61 || y > 61 || t > turn || memo[x][y][t] == 1) return;\n  if(x < 0 || y < 0 || board[x][y] == 1) return;\n  visited[x][y] = memo[x][y][t] = 1;\n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if((i == 0 && j == 0) || i * j == -1) continue;\n      solve(x + i, y + j, t + 1);\n    }\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  while(cin >> turn >> obs, turn || obs){\n    for(int i = 0; i <= 61; i++){\n      for(int j = 0; j <= 61; j++) board[i][j] = visited[i][j] = 0;\n    }\n    for(int i = 0; i <= 61; i++){\n      for(int j = 0; j <= 61; j++){\n        for(int k = 0; k <= 30; k++) memo[i][j][k] = 0;\n      }\n    }\n    int x, y;\n    for(int i = 0; i < obs; i++){\n      cin >> x >> y;\n      board[x+cx][y+cy] = 1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    solve(cx + sx, cx + sy, 0);\n    int ans = 0;\n    for(int i = 0; i <= 61; i++){\n      for(int j = 0; j <= 61; j++){\n        if(visited[i][j] != 0) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n;\nbool used[100][100], block[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = true;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 0, 1,-1};\nconst int dy[] = {1, 0,-1,-1, 1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[66][66];\n        for (int i = 0; i < 66; i++) for (int j = 0; j < 66; j++) d[i][j] = INF;\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 30][t2 + 30] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 30][y + 30] = 0;\n        queue<P> q;\n        q.push(P(x + 30, y + 30));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (d[nx][ny] != -1 && d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                    if (d[nx][ny] == INF) count++;\n                    q.push(P(nx,ny));\n                    d[nx][ny] = d[p.first][p.second] + 1;\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\nint mp[610][610], t;\nvoid dfs(int x, int y, int n) {\n  if (mp[y][x] == 9 || n == 0)\n    return;\n  mp[y][x] = 7;\n  dfs(x + 1, y, n - 1);\n  dfs(x, y + 1, n - 1);\n  dfs(x - 1, y, n - 1);\n  dfs(x, y - 1, n - 1);\n  dfs(x + 1, y + 1, n - 1);\n  dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    memset(mp, 0, sizeof(mp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstruct State {\n  int x, y, t;\n  State(int x, int y, int t): x(x), y(y), t(t) {;};\n};\n\nconst int OFFSET = 200;\nconst int dx[6] = {0, 1, 1, 0, -1, -1},\n          dy[6] = {1, 1, 0, -1, -1, 0};\n\nint field[1000][1000];\nint T, N;\n\nvoid Solve(int sx, int sy)\n{\n  bool visit[1000][1000];\n  memset(visit, false, sizeof(visit));\n  \n  queue<State> que;\n  que.push(State(sx, sy, T)); \n  int res = 0;\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    int x = s.x, y = s.y, t = s.t;\n    if (t < 0 || field[y + OFFSET][x + OFFSET] == 1 || visit[y + OFFSET][x + OFFSET])\n      continue;\n    \n    visit[y + OFFSET][x + OFFSET] = true;\n    res++;\n    for (int k = 0; k < 6; k++) \n      que.push(State(x + dx[k], y + dy[k], t - 1));\n  }\n  cout << res << endl;\n}\n\nint main()\n{\n  while (cin >> T >> N && !(T == 0 && N == 0)) {\n    memset(field, 0, sizeof(field));\n    int x, y, sx, sy;\n    for (int i = 0; i < N; i++) {\n      cin >> x >> y;\n      field[y + OFFSET][x + OFFSET] = 1;\n    }\n    cin >> sx >> sy;\n    Solve(sx, sy);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <utility>\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define REG(i, a, b) for (int (i) = ((int)(a)); (i) < ((int)(b)); i++)\n#define ALL(V) (V).begin(), (V).end()\n#define PRINT(STR) cout << (STR) << endl\n#define ROUNDED(N) fixed << setprecision(N)\n#define SPACE \" \"\n\ntypedef long long ll;\nusing namespace std;\n\nint nextInt() { int n; cin >> n; return n; }\ndouble nextDouble() { double d; cin >> d; return d; }\nstring nextString() { string str; cin >> str; return str; }\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {1,0,-1,-1,0,1};\nstruct points{int x,y,turn;};\nconst int def = 50;\nint main() {\n\tcin.tie(0); //?????±?????????????????????\n\tios::sync_with_stdio(false); //printf??¨??±??????????????????\n\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\tvector<vector<int>> mp(150,vector<int>(150,0));\n\t\tREP(i,n){\n\t\t\tint a = nextInt()+def;\n\t\t\tint b = nextInt()+def;\n\t\t\tmp[a][b] = 1;\n\t\t}\n\t\tqueue<points> que;\n\t\tpoints start;\n\t\tstart.x=nextInt()+def;start.y=nextInt()+def;start.turn=t;\n\t\tque.push(start);\n\t\tint ct = 0;\n\t\twhile(que.size()){\n\t\t\tint x = que.front().x;\n\t\t\tint y = que.front().y;\n\t\t\tint nowturn = que.front().turn;\n\t\t\tque.pop();\n\t\t\tif(mp[x][y]==0){\n\t\t\t\tct++;\n\t\t\t\tmp[x][y] = 1;\n\t\t\t}\n\t\t\tif(nowturn==0)continue;\n\t\t\tREP(i,6){\n\t\t\t\tpoints ne;\n\t\t\t\tne.x = x + dx[i];\n\t\t\t\tne.y = y + dy[i];\n\t\t\t\tif(mp[ne.x][ne.y]==0){\n\t\t\t\t\tne.turn = nowturn - 1;\n\t\t\t\t\tque.push(ne);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint t, n;\n\t\tint p, q;\n\t\tint dp[121][121] = {};//dp[60][60]=(0,0) not,bari,yes (x,y)\n\t\tint deep[121][121] = {};\n\t\tint count = 0;\n\t\tpair< int, int> now;\n\t\tqueue< pair<int, int> > que;\n\n\t\tcin >> t >> n;\n\t\tif (t == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tcin >> p >> q;\n\t\t\tdp[p + 60][q + 60] = 1;\n\t\t}\n\t\tcin >> p >> q;\n\t\tque.push(make_pair(p + 60, q + 60));\n\t\tdp[p + 60][q + 60] = 2;\n\t\tdeep[p + 60][q + 60] = 0;\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\tque.pop();\n\n\t\t\tif (deep[now.first][now.second] >= t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFOR(i, -1, 1) {\n\t\t\t\tFOR(j, -1, 1) {\n\t\t\t\t\tif ((i == 1 && j == -1)|| (i == 0 && j == 0) || (i == -1 && j == 1)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dp[now.first + i][now.second+j] == 0) {\n\t\t\t\t\t\tif (deep[now.first + i][now.second+j] == 0) {\n\t\t\t\t\t\t\tdp[now.first + i][now.second + j] = 2;\n\t\t\t\t\t\t\tdeep[now.first + i][now.second + j] = deep[now.first][now.second] + 1;\n\t\t\t\t\t\t\tque.push(make_pair(now.first + i, now.second + j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tFOR(i, 0, 120) {\n\t\t\tFOR(j, 0, 120) {\n\t\t\t\tif (dp[i][j] == 2) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint depth;\nbool field[70][70];\nll d[70][70];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    REP(i,62){\n        REP(j,62) d[i][j] = INF;\n    }\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx < 0 || 60 < nx || ny < 0 || 60 < ny || d[nx][ny] != INF || field[nx][ny] || d[p.first][p.second]+1 > depth) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        memset(field, false, sizeof(field));\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            field[x+30][y+30] = true;\n        }\n        cin >> x >> y;\n        int res = bfs(x+30,y+30);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n//bool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { 0, 1, -1, 1, -1, 0 };\nint dy[] = { 1, 1, 0, 0, -1, -1 };\n\nbool fld[200][200];\nint cnt[200][200];\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n, t)\n\t{ \n\t\tMS(fld, false);\n\t\tREP(i, 200)REP(j, 200)\n\t\t{\n\t\t\tcnt[i][j] = INF;\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 100; y += 100;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100, sy += 100;\n\t\tcnt[sx][sy] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\twhile (que.size())\n\t\t{\n\t\t\tP now = que.front();\n\t\t\tint tx = now.first;\n\t\t\tint ty = now.second;\n\t\t\tque.pop();\n\t\t\tif (cnt[tx][ty] == t) break;\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i];\n\t\t\t\tint ny = ty + dy[i];\n\t\t\t\tif (fld[nx][ny]||cnt[nx][ny]!=INF) continue;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tcnt[nx][ny] = cnt[tx][ty] + 1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 200)REP(j, 200)\n\t\t{\n\t\t\tif (cnt[i][j] < INF) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int t,n;\n  while(cin>>t>>n,t||n){\n    int a[63][63];\n    memset(a,-1,sizeof(a));\n    for(i=1;i<62;i++)\n      for(j=1;j<62;j++)\n\ta[i][j]=0;\n    for(i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      x+=31;\n      y+=31;\n      a[y][x]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=31;\n    sy+=31;\n    int b[63][63];\n    memset(b,-1,sizeof(b));\n    queue<pair<pair<int,int>,int> > c;\n    c.push(make_pair(make_pair(sx,sy),0));\n    int ct=0;\n    while(c.empty()==0){\n      int x,y,z;\n      x=c.front().first.first;\n      y=c.front().first.second;\n      z=c.front().second;\n      c.pop();\n      if(z>t)\n\tbreak;\n      if(b[y][x]){\n\tb[y][x]=0;\n\tct++;\n\tif(a[y+1][x+1]==0&&b[y+1][x+1])\n\t  c.push(make_pair(make_pair(x+1,y+1),z+1));\n\tif(a[y][x+1]==0&&b[y][x+1])\n\t  c.push(make_pair(make_pair(x+1,y),z+1));\n\tif(a[y-1][x]==0&&b[y-1][x])\n\t  c.push(make_pair(make_pair(x,y-1),z+1));\n\tif(a[y-1][x-1]==0&&b[y-1][x-1])\n\t  c.push(make_pair(make_pair(x-1,y-1),z+1));\n\tif(a[y][x-1]==0&&b[y][x-1])\n\t  c.push(make_pair(make_pair(x-1,y),z+1));\n\tif(a[y+1][x]==0&&b[y+1][x])\n\t  c.push(make_pair(make_pair(x,y+1),z+1));\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 200;\nconst int D = 50;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint main(void){\n    for(int t, n, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vector< vector<bool> > trap(N, vector<bool>(N));\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            trap[y + D][x + D] = true;\n        }\n\n        pii s; cin >> s.X >> s.Y;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(mp(s.X + D, s.Y + D), 0));\n\n        while(!q.empty()){\n            pii p = q.front().first;\n            int turn = q.front().second;\n            q.pop();\n\n            if(turn == t + 1) continue;\n            if(trap[p.Y][p.X]) continue;\n\n            res++;\n            trap[p.Y][p.X] = true;\n\n            rep(i, 6){\n                q.push(mp(mp(p.X + dx[i], p.Y + dy[i]), turn + 1));\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint data[100][100]={0};\n\nbool inrange(int x,int y){\n  if(x<-30||x>30||y<-30||y>30) return false;\n  else return true;\n}\n\nint dp[100][100][30];\n\nll int solve(int px,int py,int turn){\n  int res = 0;\n  if(turn==0) return res;\n  REP(i,6){\n    //cout << i << endl;\n    int nx = px + dx[i];\n    int ny = py + dy[i];\n    //cout << nx << \" : \" << ny << endl;\n    if(!inrange(nx,ny)) continue;\n    if(data[nx+30][ny+30]==0) res++;\n    if(data[nx+30][ny+30]!=-1){\n      data[nx+30][ny+30]=1;\n      if(dp[nx][ny][turn-1]!=-1) res+=dp[nx+30][ny+30][turn-1];\n      else{\n        int tmp = solve(nx,ny,turn-1);\n        dp[nx+30][ny+30][turn-1] = tmp;\n        res += tmp;\n      }\n\n    }\n  }\n  return res;\n}\n\nint main(){\n  int t,n;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    REP(i,100){\n      REP(j,100) data[i][j] = 0;\n    }\n    REP(i,100) REP(j,100) REP(k,30) dp[i][j][k] = -1;\n    REP(i,n){\n      int tx,ty;\n      cin >> tx >> ty;\n      data[tx+30][ty+30] = -1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    data[sx+30][sy+30] = 1;\n    cout << solve(sx,sy,t)+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n#define  OFF 45\nbool dump[90][90];\nbool visited[90][90];\nbool visited2[90][90];\n\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\n\nint main(void){\n\tint t,n;\n\twhile(cin >> t >> n,t|n){\n\t\tfor(int y=0;y<90;y++)\n\t\t\tfor(int x=0;x<90;x++)\n\t\t\t\tdump[x][y]=visited[x][y]=false;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tdump[OFF+x][OFF+y]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\n\t\tvisited[OFF+sx][OFF+sy]=true;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tvisited2[OFF+x][OFF+y]=visited[OFF+x][OFF+y];\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tfor(int j=0;j<6;j++)\n\t\t\t\t\t\tif(visited[OFF+x][OFF+y]&&!dump[OFF+x+dx[j]][OFF+y+dy[j]])\n\t\t\t\t\t\t\tvisited2[OFF+x+dx[j]][OFF+y+dy[j]]=true;\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tvisited[OFF+x][OFF+y]=visited2[OFF+x][OFF+y];\n\t\t}\n\t\tint num=0;\n\t\tfor(int y=-30;y<=30;y++)\n\t\t\t\tfor(int x=-30;x<=30;x++)\n\t\t\t\t\tif(visited2[OFF+x][OFF+y])\n\t\t\t\t\t\tnum++;\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define FIELDSIZE 200\n#define INF 10000\n\nint field[FIELDSIZE][FIELDSIZE];\nint offset = 100;\n\nstruct tile{\n    int x, y;\n    int turn;\n    tile(int x, int y, int turn) : x(x), y(y), turn(turn) {};\n};\n\nvoid init() {\n    for (int i = 0; i < FIELDSIZE; i++) {\n        for (int j = 0; j < FIELDSIZE; j++) {\n            field[i][j] = -1;\n        }\n    }\n//    field[0+offset][0+offset] = 0;\n    field[-31+offset][0+offset] = INF;\n    field[31+offset][0+offset] = INF;\n    field[0+offset][31+offset] = INF;\n    field[0+offset][-31+offset] = INF;\n    field[31+offset][31+offset] = INF;\n    field[-31+offset][-31+offset] = INF;\n}\n\n//int count = 0;\n//void visit(int x, int y, int turn) {\n//    if (field[x+offset][y+offset] == INF) {\n//        return;\n//    }\n//    if (field[x+offset][y+offset] == -1) {\n//        field[x+offset][y+offset] = turn;\n//        count++;\n//    }\n//\n//    visit(x+1, y, turn+1);\n//    visit(x-1, y, turn+1);\n//    visit(x, y+1, turn+1);\n//    visit(x, y-1, turn+1);\n//    visit(x+1, y+1, turn+1);\n//    visit(x-1, y-1, turn+1);\n//}\n\n\nint main() {\n    int last_t, n;\n\n    while (cin >> last_t >> n) {\n        if (last_t == 0 && n == 0) break;\n        init();\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            field[x+offset][y+offset] = INF;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        queue<tile> q;\n        q.push(tile(start_x, start_y, 0));\n        while (!q.empty()) {\n            tile t = q.front(); q.pop();\n            //cout << t.turn << endl;\n            field[t.x+offset][t.y+offset] = t.turn;\n            //cout << t.x << endl;\n\n            if (t.turn == last_t) {\n                continue;\n            }\n\n            if (field[t.x+1+offset][t.y+offset] == -1) {\n                q.push(tile(t.x+1, t.y, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y+offset] == -1) {\n                q.push(tile(t.x-1, t.y, t.turn+1));\n            }\n            if (field[t.x+offset][t.y+1+offset] == -1) {\n                q.push(tile(t.x, t.y+1, t.turn+1));\n            }\n            if (field[t.x+offset][t.y-1+offset] == -1) {\n                q.push(tile(t.x, t.y-1, t.turn+1));\n            } \n            if (field[t.x+1+offset][t.y+1+offset] == -1) {\n                q.push(tile(t.x+1, t.y+1, t.turn+1));\n            }\n            if (field[t.x-1+offset][t.y-1+offset] == -1) {\n                q.push(tile(t.x-1, t.y-1, t.turn+1));\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < FIELDSIZE; i++) {\n            for (int j = 0; j < FIELDSIZE; j++) {\n                if (field[i][j] != -1 && field[i][j] != INF) {\n                    count++;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n-1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}cin >> x >> y;\n\t\t\t//stage[x+30][y+30] = 1;\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\n\nint a[160][160]={0};\nint ans;\nint ddx[6]={1,0,-1,-1,0,1};\nint ddy[6]={1,1,0,-1,-1,0};\nqueue<ppap> qu;\nvoid dfs(int x,int y,int zan){\n\tqu.push(mp(0,mp(x,y)));\n\t\n\twhile(qu.size()){\n\t\tppap r=qu.front();\n\t\tqu.pop();\n\t\tpa z=r.second;\n\t\tif(a[z.first][z.second]>0) continue;\n\t\ta[z.first][z.second]=1;\n\t\tans++;\n\t\tif(r.first<zan)for(int i=0;i<6;i++)qu.push(mp(r.first+1,mp(z.first+ddx[i],z.second+ddy[i])));\n\t}\n}\n\n     signed main(){\nint n,t;\n     \t\n     \n     \twhile(1){\n     \tcin>>t>>n;\n     \t\tif(t==0 && n==0) return 0;\n     \t\tfor(int i=0;i<160;i++)for(int j=0;j<160;j++)a[i][j]=0;     \t\t\n     \t\tfor(int i=0;i<n;i++){\n     \t\t\tint r,rr;\n     \t\t\tcin>>r>>rr;\n     \t\t\ta[100+r][100+rr]=2;\n     \t\t}\n     \tans=0;\n     \t\tint x,y;\n     \t\tcin>>x>>y;\n     \t\tdfs(100+x,100+y,t);\n     \t\tcout<<ans<<endl;\n     \t}\n     \t\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nint N = 170;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\tint ans(1);\n\tvector<int> dx{ 1,1,0,-1,-1,0 }, dy{ 0, 1, 1, 0, -1, -1 };\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (field[a.first][a.second] == 1)continue;\n\n\t\trep(i, 0, dx.size()) {\n\t\t\tint ax = a.first + dx[i], ay = a.second + dy[i];\n\t\t\tif (0 <= ax&&ax < N && 0 <= ay&&ay < N&&field[ax][ay] == -1) {\n\t\t\t\tfield[ax][ay] = max(0, field[a.first][a.second] - 1);\n\t\t\t\tQ.push(make_pair(ax, ay));\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\trep(i, 0, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += N / 2; y += N / 2;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += N / 2; sy += N / 2;\n\t\tfield[sx][sy] = t + 1;\n\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n#define  OFF 45\nbool dump[90][90];\nbool visited[90][90];\nbool visited2[90][90];\n\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\n\nint main(void){\n\tint t,n;\n\twhile(cin >> t >> n,t|n){\n\t\tfor(int y=0;y<90;y++)\n\t\t\tfor(int x=0;x<90;x++)\n\t\t\t\tdump[x][y]=visited[x][y]=visited2[x][y]=false;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tdump[OFF+x][OFF+y]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\n\t\tvisited[OFF+sx][OFF+sy]=true;\n\t\tvisited2[OFF+sx][OFF+sy]=true;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tfor(int j=0;j<6;j++)\n\t\t\t\t\t\tif(visited[OFF+x][OFF+y]&&!dump[OFF+x+dx[j]][OFF+y+dy[j]])\n\t\t\t\t\t\t\tvisited2[OFF+x+dx[j]][OFF+y+dy[j]]=true;\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tvisited[OFF+x][OFF+y]=visited2[OFF+x][OFF+y];\n\t\t}\n\t\tint num=0;\n\t\tfor(int y=-30;y<=30;y++)\n\t\t\t\tfor(int x=-30;x<=30;x++)\n\t\t\t\t\tif(visited2[OFF+x][OFF+y])\n\t\t\t\t\t\tnum++;\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n#include \"list\"\n#include \"climits\"\n\nusing namespace std;\n\n\nint main() {\n\t\n\tint dir_y[] = { 1,1,0,-1,-1,0 };\n\tint dir_x[] = { 0,1,1,0,-1,-1 };\n\tint N, K;\n\tlist<int>ret;\n\tcin >> N >> K;\n\twhile (N) {\n\t\tvector<vector<int>>v(1000, vector<int>(1000, INT_MAX));\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tint y, x;\n\t\t\tcin >> y >> x;\n\t\t\ty += 500;\n\t\t\tx += 500;\n\t\t\tv[y][x] = -1;\n\t\t}\n\t\tint sy, sx;\n\t\tcin >> sy >> sx;\n\t\tsy += 500;\n\t\tsx += 500;\n\t\tqueue<pair<int,int>>Q;\n\t\tQ.push({ sy,sx });\n\t\tv[sy][sx] = 0;\n\t\tint cnt = 0;\n\t\twhile (cnt<=N&&!Q.empty()) {\n\t\t\tint cy = Q.front().first;\n\t\t\tint cx = Q.front().second;\n\t\t\tcnt = max(cnt, v[cy][cx] + 1);\n\t\t\tQ.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint ny = cy + dir_y[i];\n\t\t\t\tint nx = cx + dir_x[i];\n\t\t\t\tif (v[ny][nx]>cnt) {\n\t\t\t\t\tv[ny][nx] = cnt;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (auto i : v) {\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j >= 0 && j <= N) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret.push_back(ans);\n\t\tcin >> N >> K;\n\t}\n\tfor (auto i : ret) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define MAX 200\n#define OFFSET 100\n\nint brd[MAX][MAX];\nint cnt[MAX][MAX];\n\nint t, n;\nint sx, sy;\n\nint dx[] = { 1, 1, 0, -1, -1, 0 };\nint dy[] = { 1, 0, -1, -1, 0, 1 };\n\nvoid solve(int depth, int y, int x)\n{\n\tif (depth > t) return;\n\tif (brd[y][x]) return;\n\tcnt[y][x] = 1;\n\n\trep(i, 6)\n\t\tsolve(depth+1, y+dy[i], x+dx[i]);\n}\n\nint calc()\n{\n\tsolve(0, sy+OFFSET, sx+OFFSET);\n\tint ans = 0;\n\trep(j, MAX) rep(i, MAX) ans += cnt[j][i];\n\treturn ans;\n}\n\nint main(void)\n{\n\twhile (cin >> t >> n, t|n) {\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tmemset(brd, 0, sizeof(brd));\n\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tbrd[y+OFFSET][x+OFFSET] = 1;\n\t\t}\n\n\t\tcin >> sx >> sy;\n\t\tcout << calc() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\nbool visited[65][65];\n\nbool isin(int x, int y){\n    if(x*y>=0) return x>=0 && x<=60 && y>=0 && y<=60;\n    else return x>=0 && y>=0 && abs(x-30)+abs(y-30)<=30;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[65], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+30][y+30]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+30, sy+30), 0));\n        visited[sx+30][sy+30]=true;\n        int res=1;\n        while (!q.empty()){\n            const int dx[] = {1,1,0,-1,-1,0};\n            const int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second==t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nbool mem[61][61];\nint T, N, d[61][61], dx[] = {0, 0, 1, -1, 1, -1}, dy[] = {1, -1, 1, -1, 0, 0};\nint bfs(int sx, int sy)\n{\n  queue<int> q;\n  d[sx][sy] = 1;\n  q.push(sx);\n  q.push(sy);\n  while(!q.empty())\n  {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    for(int i = 0; i < 6; i++)\n    {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      if(tx >= 0 && tx <= 60 && ty >= 0 && ty <= 60 && !mem[tx][ty] && d[x][y] <= T && !d[tx][ty])\n      {\n        d[tx][ty] = d[x][y] + 1;\n        q.push(tx);\n        q.push(ty);\n      }\n    }\n  }\n  int ans = 0;\n  for(int i = 0; i <= 61; i++)\n    for(int j = 0; j < 61; j++)\n      ans += d[i][j] != 0;\n  return ans;\n}\n\nint main()\n{\nloop:\n  for(int i = 0; i < 61; i++)\n    for(int j = 0; j < 61; j++)\n      mem[i][j] = d[i][j] = 0;\n  cin >> T >> N;\n  if(!T)\n    return 0;\n  for(int i = 0; i < N; i++)\n  {\n    int a, b;\n    cin >> a >> b;\n    mem[a + 30][b + 30] = 1;\n  }\n\n  int sx, sy;\n  cin >> sx >> sy;\n  cout << bfs(sx + 30, sy + 30) << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef pair<pair<int,int>,int> triple;\n#define trpl(i,j,k) make_pair(make_pair((i),(j)),(k))\n#define X first.first\n#define Y first.second\n#define T second\nconst int OFFSET=50;\nconst int MAX_X=OFFSET*2+1;\n\nbool obstacle[MAX_X][MAX_X];\nbool checked[MAX_X][MAX_X];\nint t,n,x,y;\n\nint bfs(){\n  int result=0;\n  queue<triple> q;\n  q.push(trpl(x,y,t));\n  while(!q.empty()){\n    triple tr=q.front();\n    q.pop();\n    if(obstacle[tr.X][tr.Y]||checked[tr.X][tr.Y])continue;\n    checked[tr.X][tr.Y]=true;\n    result++;\n    if(tr.T>0){\n      int d=tr.T-1;\n      q.push(trpl(tr.X+1,tr.Y,d));\n      q.push(trpl(tr.X+1,tr.Y+1,d));\n      q.push(trpl(tr.X,tr.Y+1,d));\n      q.push(trpl(tr.X-1,tr.Y,d));\n      q.push(trpl(tr.X-1,tr.Y-1,d));\n      q.push(trpl(tr.X,tr.Y-1,d));\n    }\n  }\n  return result;\n}\n\nint main(){ _;\n  int tx,ty;\n  while(cin>>t>>n,(t|n)!=0){\n    REP(i,MAX_X)REP(j,MAX_X)obstacle[i][j]=checked[i][j]=false;\n    REP(i,n){\n      cin>>tx>>ty;\n      tx+=OFFSET;\n      ty+=OFFSET;\n      obstacle[tx][ty]=true;\n    }\n    cin>>x>>y;\n    x+=OFFSET;\n    y+=OFFSET;\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n# define rep(i, n) for (int i = 0; i < (int)(n); i++)\n \nusing namespace std;\n \nnamespace utils{\n  template <typename T> void print(vector<vector<T>> mat) {\n    rep (i, mat.size()) {\n      rep (j, mat[0].size()) cout << mat[i][j] << ' ';\n      cout << endl;\n    }\n  }\n \n  template <typename T> void print(vector<T> v) {\n    rep (i, v.size()) cout << v[i] << ' ';\n    cout << endl;\n  }\n \n  template <typename T> pair<T, T> shape(vector<vector<T>> mat) {\n    int d1, d2;\n \n    d1 = mat.size();\n    if (d1 > 0) d2 = mat[0].size();\n    else int d2 = 0;\n    cout << \"(\" << d1 << \", \" << d2 << \")\" << endl;\n    return make_pair(0, 0);\n  }\n \n  template <typename T> vector<vector<T>> empty(int n, int m) {\n    vector<vector<T>> mat(n, vector<T>(m));\n    return mat;\n  }\n}\n \n \nconst int OFFSET = 300;\n \nint main() {\n  int t, n;\n  int cx, cy;\n  int sx, sy;\n \n  vector<int> dx = {1, 1, 0, -1, -1, 0};\n  vector<int> dy = {1, 0, -1, -1, 0, 1};\n \n  queue<pair<pair<int, int>, int>> s;\n \n  while (cin >> t >> n && (t || n)) {\n    vector<vector<bool>> visited = utils::empty<bool>(1000, 1000);\n    rep (i, 1000) fill(visited[i].begin(), visited[i].end(), false);\n \n    rep (i, n) {\n      cin >> cx >> cy;\n      cx += OFFSET; cy += OFFSET;\n      visited[cx][cy] = true;\n    }\n\n    cin >> sx >> sy;\n    sx += OFFSET;\n    sy += OFFSET;\n\n    //initialize\n    s.push(make_pair(make_pair(sx, sy), 0));\n    int ans = 0;\n \n    while (!s.empty()) {\n      pair<pair<int, int>, int> q = s.front(); s.pop();\n      int cx = q.first.first;\n      int cy = q.first.second;\n      int turn = q.second;\n\n\n      // if (cx < 0 || cy < 0 || cx >= 60 || cy >= 60 || visited[cx][cy]) continue;\n      if (visited[cx][cy]) continue;\n      ans++;\n      visited[cx][cy] = true;\n \n      rep (i, 6) {\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n \n        if (turn < t) {\n          s.push(make_pair(make_pair(nx, ny), turn+1));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint visited[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  visited[x][y] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && i < visited[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[x][y-1] && i < visited[x][y-1]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i < visited[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[x+1][y] && i < visited[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[x][y+1] && i < visited[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i < visited[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        visited[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (visited[i][j] < INF) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define MAXINT 40\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,-1,0,0,1,-1};\nint dy[6]={0,0,1,-1,1,-1};\nbool used[MAXINT][MAXINT];\nbool rock[MAXINT][MAXINT];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,MAXINT){\n\t\t\tfill(used[i],used[i]+MAXINT,false);\n\t\t\tfill(rock[i],rock[i]+MAXINT,false);\n\t\t}\n\t\tint x,y;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trock[y+MAXINT/2][x+MAXINT/2]=true;\n\t\t}\n\t\tcin>>x>>y;\n\t\tused[y+MAXINT/2][x+MAXINT/2]=true;\n\t\tqueue<piii> que;\n\t\tque.push(piii(0,pii(x+MAXINT/2,y+MAXINT/2)));\n\t\twhile(!que.empty()){\n\t\t\tpiii now=que.front();\n\t\t\tused[now.second.second][now.second.first]=true;\n\t\t\tque.pop();\n\t\t\trep(i,6){\n\t\t\t\tif(used[now.second.second+dy[i]][now.second.first+dx[i]]||rock[now.second.second+dy[i]][now.second.first+dx[i]])continue;\n\t\t\t\tif(now.first+1>t)continue;\n\t\t\t\tque.push(piii(now.first+1,pii(now.second.first+dx[i],now.second.second+dy[i])));\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\trep(i,MAXINT){\n\t\t\trep(j,MAXINT){\n\t\t\t\tif(used[i][j])cnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 100\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+40][y+40] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+40,sY+40)); \n\t\td[sX+40][sY+40] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\nconst int dy[] = { -1, -1, 0, 1, 1, 0 }, dx[] = { -1, 0, 1, 1, 0, -1 };\nbool mas[256][256], used[256][256];\n\nint main(){\n  int n, t;\n  while(cin >> t >> n , t || n){\n    fill_n( *mas, 256 * 256, false);\n    fill_n( *used, 256 * 256, false);\n    for(int i = 0 ; i < n ; i++ ){\n      int y, x;\n      cin >> x >> y;\n      mas[100 + y][100 + x] = true;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    int ret = 0;\n    queue< Pii > que;\n    que.push(Pii( t, Pi(sy + 100, sx + 100)));\n    while(!que.empty()){\n      Pii p = que.front();\n      que.pop();\n      if(p.fr < 0 || used[p.sc.fr][p.sc.sc]++) continue;\n      ret++;\n      for(int i = 0 ; i < 6 ; i++ ){\n        int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n        if(!mas[ny][nx]) que.push(Pii( p.fr - 1, Pi( ny, nx)));\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 151\n#define INF 1e9\n\nstruct P{\n  int x, y, d;\n  P(int x, int y, int d){\n    this->x = x;\n    this->y = y;\n    this->d = d;\n  }\n};\n\nint t, sx, sy;\nbool impossible[MAX][MAX];\nint dist[MAX][MAX];\nconst int dx[] = {-1,0,0,-1,1,1};\nconst int dy[] = {-1,-1,1,0,0,1};\n\nint bfs(int x, int y){\n  bool visited[MAX][MAX];\n  memset(visited,false,sizeof(visited));\n  fill(dist[0],dist[MAX],INF);\n\n  queue<P> que;\n  que.push(P(x,y,0));\n  dist[x][y] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n\n    if(impossible[p.x][p.y] || p.d > t || \n       visited[p.x][p.y]){\n      continue;\n    }\n    visited[p.x][p.y] = true;\n\n    for(int i = 0 ; i < 6 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      \n      if(impossible[nx][ny] || dist[nx][ny] != INF){\n        continue;\n      }\n\n      dist[nx][ny] = dist[p.x][p.y] + 1;\n      que.push(P(nx,ny,dist[nx][ny]));\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dist[i][j] <= t){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, x, y;\n\n  while(cin >> t >> n , (t | n)){\n    memset(impossible,false,sizeof(impossible));\n    for(int i = 0 ; i < n ; i++){\n      cin >> x >> y;\n      x += 75, y += 75;\n      impossible[x][y] = true;\n    }\n    cin >> sx >> sy;\n    cout << bfs(sx+75, sy+75) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <complex>\n\nusing namespace std;\n\n//define\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\n#define INF (INT_MAX/3)\n#define PI (2*acos(0.0))\n#define EPS (1e-8)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int cx = 31, cy = 31;\n\nint board[62][62];\nint visited[62][62];\nint turn, obs;\n\nvoid solve(int x, int y, int t){\n  if(x > 61 || y > 61 || t > turn) return;\n  if(x < 0 || y < 0 || board[x][y] == 1) return;\n  visited[x][y] = 1;\n  for(int i = -1; i <= 1; i++){\n    for(int j = -1; j <= 1; j++){\n      if((i == 0 && j == 0) || i * j == -1) continue;\n      solve(x + i, y + j, t + 1);\n    }\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  while(cin >> turn >> obs, turn || obs){\n    for(int i = 0; i <= 61; i++){\n      for(int j = 0; j <= 61; j++) board[i][j] = visited[i][j] = 0;\n    }\n    int x, y;\n    for(int i = 0; i < obs; i++){\n      cin >> x >> y;\n      board[x+cx][y+cy] = 1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    solve(cx + sx, cx + sy, 0);\n    int ans = 0;\n    for(int i = 0; i <= 61; i++){\n      for(int j = 0; j <= 61; j++){\n        if(visited[i][j] != 0) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint data[61][61],result;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nint check(int m,int i,int j){\n\tint ans = 0;\n\tfor(int k = 0;k < 6;k++){\n\t\tif(i+dx[k] < 61 && i+dx[k] >= 0 && j+dy[k] < 61 && j+dy[k] >= 0){\n\t\t\tif(data[i+dx[k]][j+dy[k]] == 0){\n\t\t\t\tdata[i+dx[k]][j+dy[k]] = m + 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint t,n,x,y,a;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t == 0)break;\n\t\tresult = 0;\n\t\tfor(int i = 0;i < 61;i++){\n\t\t\tfor(int j = 0;j < 61;j++){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tdata[x+30][y+30] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tdata[x+30][y+30] = 1;\n\t\tresult++;\n\t\tfor(int m = 1;m <= t;m++){\n\t\t\ta = 0;\n\t\t\tfor(int i = 0;i < 61;i++){\n\t\t\t\tfor(int j = 0;j < 61;j++){\n\t\t\t\t\tif(data[i][j] == m){\n\t\t\t\t\t\ta += check(m,i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a == 0)break;\n\t\t\tresult += a;\n\t\t}\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int base=35;\n\nvoid solve(int t,int n){\n  int x,y;\n  bool d[75][75],used[75][75];\n  int dx[6]={1,1,0,-1,-1,0};\n  int dy[6]={1,0,-1,-1,-0,1};\n\n  rep(i,75)rep(j,75){\n    d[i][j]=true;\n    used[i][j]=false;\n  }\n  \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    d[a+base][b+base]=false;\n  }\n  cin>>x>>y;\n  \n  queue<pi> que;\n  que.push(mp(x,y));\n  used[x+base][y+base]=true;\n  for(int i=0;i<t;i++){\n    int size=que.size();\n    for(int j=0;j<size;j++){\n      pi dir=que.front();que.pop();\n      for(int k=0;k<6;k++){\n\tpi tmp=mp(dir.first+dx[k],dir.second+dy[k]);\n\t//cout<<tmp.first<<\" \"<<tmp.second<<endl;\n\tif(!used[tmp.first+base][tmp.second+base]&&d[tmp.first+base][tmp.second+base]&&abs(tmp.first)<=30&&abs(tmp.second)<=30){\n\t  //cout<<tmp.first<<\" \"<<tmp.second<<endl;\n\t  que.push(tmp);\n\t  used[tmp.first+base][tmp.second+base]=true;\n\t}\n      }\n    }\n  }\n  int ans=0;\n  rep(i,75)rep(j,75)ans+=used[i][j];\n  cout<<ans<<endl;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0&&n==0)break;\n    solve(t,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\n\nint d[6][2]={{1,1},{0,1},{-1,0},{-1,-1},{0,-1},{1,0}};\n\nint main(){\n  int t,n;\n  while(cin>>t>>n,t){\n    bool map[200][200]={false};\n    int x=0,y=0;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      map[y+100][x+100]=true;\n    }\n    cin>>x>>y;\n    //  cout<<\" t = \"<<t<<\" , n = \"<<n<<endl;\n    x+=100;\n    y+=100;\n    int cnt=0;\n    queue<pair<int,int> > q;\n    q.push(make_pair(y*1000+x,0));\n    map[y][x]=true;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      if(p.second>t) break;\n      //  cout<<\" t = \"<<t<<\" p.second=\"<<p.second<<endl;\n      y=p.first/1000;\n      x=p.first%1000;\n      cnt++;\n      q.pop();\n      //      cout<<\" x = \"<<x<<\" y = \"<<y<<\" p.first =\"<<p.first<<\" p.second = \"<<p.second<<endl;\n      for(int i=0;i<6;i++){\n\tint xx=x+d[i][0];\n\tint yy=y+d[i][1];\n\tif(!map[yy][xx]){\n\t  map[yy][xx]=true;\n\t  q.push(make_pair(yy*1000+xx,p.second+1));\n\t}\n      }\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#pragma warning(disable : 4996)\nusing namespace std;\nint t, n, x, y, a, b, v[123][123]; bool s[123][123];\nint main() {\n\twhile (~scanf(\"%d%d\", &t, &n)) {\n\t\tif (t == 0) break;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\ts[i][j] = true, v[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y); s[y + 61][x + 61] = true;\n\t\t}\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tqueue<pair<int, int> > que; que.push(make_pair(a + 61, b + 61)); v[b + 61][a + 61] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint x = que.front().first;\n\t\t\tint y = que.front().second; que.pop();\n\t\t\tif (v[y][x] == t) continue;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (i + j && v[y + i][x + j] == -1 && !s[y + i][x + j]) {\n\t\t\t\t\t\tv[y + i][x + j] = v[y][x] + 1;\n\t\t\t\t\t\tque.push(make_pair(x + j, y + i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\tif (v[i][j] != -1) ret++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <utility>\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define REG(i, a, b) for (int (i) = ((int)(a)); (i) < ((int)(b)); i++)\n#define ALL(V) (V).begin(), (V).end()\n#define PRINT(STR) cout << (STR) << endl\n#define ROUNDED(N) fixed << setprecision(N)\n#define SPACE \" \"\n\ntypedef long long ll;\nusing namespace std;\n\nint nextInt() { int n; cin >> n; return n; }\ndouble nextDouble() { double d; cin >> d; return d; }\nstring nextString() { string str; cin >> str; return str; }\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {1,0,-1,-1,0,1};\nstruct points{int x,y,turn;};\nconst int def = 50;\nint main() {\n\tcin.tie(0); //?????±?????????????????????\n\tios::sync_with_stdio(false); //printf??¨??±??????????????????\n\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\tvector<vector<int>> mp(150,vector<int>(150,0));\n\t\tREP(i,n){\n\t\t\tint a = nextInt()+def;\n\t\t\tint b = nextInt()+def;\n\t\t\tmp[a][b] = 1;\n\t\t}\n\t\tqueue<points> que;\n\t\tpoints start;\n\t\tstart.x=nextInt()+def;start.y=nextInt()+def;start.turn=t;\n\t\tque.push(start);\n\t\tint ct = 0;\n\t\twhile(que.size()){\n\t\t\tint x = que.front().x;\n\t\t\tint y = que.front().y;\n\t\t\tint nowturn = que.front().turn;\n\t\t\tque.pop();\n\t\t\tif(mp[x][y]==0){\n\t\t\t\tct++;\n\t\t\t\tmp[x][y] = 1;\n\t\t\t}else continue;\n\t\t\tif(nowturn==0)continue;\n\t\t\tREP(i,6){\n\t\t\t\tpoints ne;\n\t\t\t\tne.x = x + dx[i];\n\t\t\t\tne.y = y + dy[i];\n\t\t\t\tif(mp[ne.x][ne.y]==0){\n\t\t\t\t\tne.turn = nowturn - 1;\n\t\t\t\t\tque.push(ne);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct info{\n    int y, x, t;\n};\n\nint di[] = {0, 1, 0, -1, 1, -1};\nint dj[] = {1, 0, -1, 0, 1, -1};\n\nint main() {\n    int t, n;\n    while (cin >> t >> n, t | n) {\n        vector<vector<bool> > used(200, vector<bool>(200, false));\n        vector<vector<int> > w(200, vector<int>(200, 0));\n        for (int i = 0; i < n; i++) {\n            int y, x;\n            cin >> y >> x;\n            w[y + 100][x + 100] = -1;\n        }\n        int si, sj;\n        cin >> si >> sj;\n        queue<info> que;\n        que.push((info){si + 100, sj + 100, 0});\n        used[si + 100][sj + 100] = true;\n        int ans = 1;\n        while (!que.empty()) {\n            info cur = que.front();\n            que.pop();\n            if(cur.t == t) continue;\n            for (int i = 0; i < 6; i++) {\n                int ni = cur.y + di[i];\n                int nj = cur.x + dj[i];\n                if(used[ni][nj] == false && w[ni][nj] != -1){\n                    used[ni][nj] = true;\n                    ans++;\n                    que.push((info){ni, nj, cur.t + 1});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0, 1, -1};\nint dy[] = {0, 0, 1, -1, 1, -1};\n\nint T, N;\nint maze[500][500];\n\nstruct State{\n\tint x, y, t;\n\tState(int _x, int _y, int _t){\n\t\tx = _x;\n\t\ty = _y;\n\t\tt = _t;\n\t}\n};\n\nbool check(int x, int y){\n\treturn x >= 0 && x < 500 && y >= 0 && y < 500 && maze[x][y] != 2;\n}\n\nint main() {\n\twhile(cin >> T >> N && (T || N)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tint a, b;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> a >> b;\n\t\t\tmaze[a + 250][b + 250] = 2;\n\t\t}\n\t\tint sx, sy, count = 0;\n\t\tcin >> sx >> sy;\n\t\tqueue<State> q;\n\t\tq.push(State(sx + 250, sy + 250, 0));\n\t\twhile(!q.empty()){\n\t\t\tState st = q.front(); q.pop();\n\t\t\tif(st.t > T || maze[st.x][st.y] == -1)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tmaze[st.x][st.y] = -1;\n\t\t\tcount++;\n\t\t\tfor(int i = 0; i < 6; ++i){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tif(check(nx, ny))\n\t\t\t\t\tq.push(State(nx, ny, st.t + 1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << count << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n  \nusing namespace std;\n   \n#define NMAX 50\n#define INF 1000000\n#define WALL -1\ntypedef map<int,int>::value_type VT;\n  \nstruct data{\n    int x,y,turn;\n};\n  \nint main(void){\n      \n    int t,n;\n    int x,y;\n    map<int,int> road;\n    stack<data> no;\n    data tm,da;\n    int dx[]={1,1,0,-1,-1,0};\n    int dy[]={0,1,1,0,-1,-1};\n    int cnt;\n  \n    for(int i=-31;i<=31;i++){\n        for(int j=-31;j<=31;j++){\n        road.insert(VT(i+j*1000,INF));\n        }\n    }\n    while(1){\n        cin>>t>>n;\n        if(t==0&&n==0) break;\n        for(int i=-30;i<=30;i++){\n            for(int j=-30;j<=30;j++){\n                road[i+j*1000]=INF;\n            }\n        }\n        for(int i=-31;i<=31;i++){\n            road[-31+i*1000]=WALL;\n            road[31+i*1000]=WALL;\n            road[i+31*1000]=WALL;\n            road[i-31*1000]=WALL;\n        }\n  \n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            road[y+x*1000]=WALL;\n        }\n        cin>>x>>y;\n        tm.x=x,tm.y=y,tm.turn=0;\n        no.push(tm);\n        road[y+x*1000]=0;\n        cnt=1;\n        while(!no.empty()){\n            tm=no.top();\n            no.pop();\n            if(tm.turn==t) continue;\n            for(int i=0;i<6;i++){\n                if(road[(tm.y+dy[i])+(tm.x+dx[i])*1000]>road[(tm.y)+(tm.x)*1000]+1){\n                    if(road[(tm.y+dy[i])+(tm.x+dx[i])*1000]==INF) cnt++;\n                    road[(tm.y+dy[i])+(tm.x+dx[i])*1000]=road[(tm.y)+(tm.x)*1000]+1;\n                    da.x=tm.x+dx[i];\n                    da.y=tm.y+dy[i];\n                    da.turn=tm.turn+1;\n                    no.push(da);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 200;\nconst int D = 100;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint main(void){\n    for(int t, n, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vector< vector<bool> > trap(N, vector<bool>(N, false));\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            trap[y + D][x + D] = true;\n        }\n\n        pii s; cin >> s.X >> s.Y;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(mp(s.X + D, s.Y + D), 0));\n\n        while(!q.empty()){\n            pii p = q.front().first;\n            int turn = q.front().second;\n            q.pop();\n\n            if(turn == t + 1) continue;\n            if(trap[p.Y][p.X]) continue;\n\n            res++;\n            trap[p.Y][p.X] = true;\n\n            rep(i, 6){\n                q.push(mp(mp(p.X + dx[i], p.Y + dy[i]), turn + 1));\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n && (t || n)) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[a][b] = 2;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[a][b]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[x][y] == 1) {\n\t\t\t\t\tg[x][y]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[nx][ny] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll>P;\n\nll dx[6] = {0, 1, -1, 1, -1, 0};\nll dy[6] = {1, 1, 0, 0, -1, -1};\n\nint main(){\n    for(ll t, n; cin >> t >> n, t;){\n        map<P, ll>flg;\n        for(ll i = 0; i < n; i++){\n            ll x, y;\n            cin >> x >> y;\n            flg[P(x, y)] = 100;\n        }\n        ll ans = 0;\n        ll X, Y;\n        cin >> X >> Y;\n        queue<P>Q;\n        Q.push(P(X, Y));\n        flg[P(X, Y)] = 1;\n        while(!Q.empty()){\n            ll x = Q.front().first;\n            ll y = Q.front().second;\n            Q.pop();\n            if(flg[P(x, y)] > t + 1)continue;\n            ans++;\n            for(ll i = 0; i < 6; i++){\n                ll nx = x + dx[i];\n                ll ny = y + dy[i];\n                if(flg[P(nx, ny)])continue;\n                Q.push(P(nx, ny));\n                flg[P(nx, ny)] = flg[P(x, y)] + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pxyi;\n\nvector<pii> N;\nset <pii> s;\nconst int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {0, 1, 1, 0, -1, -1};\n  \nvoid bfs(int sx, int sy, int st)\n{\n  queue<pxyi> q;\n  q.push(pxyi(pii(sx,sy),st));\n  while(!q.empty()){\n    int x, y, t;\n    x = q.front().first.first;\n    y = q.front().first.second;\n    t = q.front().second;\n    q.pop();\n    s.insert(pii(x,y));\n    if(t == 0){\n      if(q.empty()) break;\n      else continue;\n    }\n    bool flag;\n    for(int i = 0; i < 6; i++){\n      flag = false;\n      int next_x = x + dx[i], next_y = y + dy[i];\n      for(int j = 0; j < (int)N.size(); j++){\n        if(N[j].first == next_x && N[j].second == next_y)\n          flag = true;\n      }\n      if(flag) continue;\n      q.push(pxyi(pii(next_x,next_y),t-1));\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    s.clear();\n    N.clear();\n    int t, n;\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      N.push_back(pii(x,y));\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    bfs(start_x,start_y,t);\n    cout << s.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[1500][1500];\nbool used[1500][1500];\nbool come[1500][1500];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<1500;i++)for(int j=0;j<1500;j++)ta[i][j]=0,used[i][j]=0,come[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=50,ty+=50;\n\tta[ty][tx]=1;\n\t}\n\tint nx,ny;\n\tcin>>nx>>ny;\n\tused[ny+50][nx+50]=1;\n\tmasu start;\n\tstart.x=nx+50,start.y=ny+50,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\t//cout<<nx<<\" \"<<ny<<endl;\n\tif(come[ny][nx]==1)continue;\n\tcome[ny][nx]=1;\n\tused[ny][nx]=1;\n\tif(ntn+1>t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]==0&&used[nexty][nextx]==0){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<150;i++){\n\tfor(int j=0;j<150;j++){\n\tif(come[i][j]){ans++;}\n\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm> \n#include <queue>\n\nusing namespace std;\n\n#define max 126\n\nstruct square{\n\tint x, y;\n\tbool flg;\t//到達フラグ\n\tbool sflg;\t//障害物フラグ\n\tint dist;\t//距離\n};\n\nvoid push_q( queue<square> *q, int x, int y, int d, int t,  vector< vector< square > > *s ){\n\tif( ( x < 0 ) || ( x > max ) ) return;\n\tif( ( y < 0 ) || ( y > max ) ) return;\n\tif( s -> at(x).at(y).flg == true ) return;\n\tif( s -> at(x).at(y).sflg == true ) return;\n\tif( d > t ) return;\n\t//if( s->at(x).at(y).dist > 0 && s->at(x).at(y).dist < d ) return;\n\n\tsquare sq;\n\tsq.x = x;\n\tsq.y = y;\n\tsq.dist = d;\n\tsq.flg = true;\n\n\ts->at(x).at(y) = sq;\n\n\tq -> push( sq );\n\n}\n\nvoid search_bfs( queue<square> *q, vector< vector< square > > *sq, int t){\n\twhile( q -> empty() == false ) {\n\t\tsquare s;\n\t\ts = q -> front();\n\t\tq -> pop();\n\n\t\tpush_q( q, s.x + 1, s.y, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x - 1, s.y, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x + 1, s.y + 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x - 1, s.y - 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x, s.y + 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x, s.y - 1, s.dist + 1, t, sq);\n\t}\n}\n\nint main(void){\n  // FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile(1){\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif( t == 0 && n == 0 ) break;\n\n\t\tvector< vector< square > > sq;\n\t\tfor(int i = 0; i < max + 1; i++) {\n\t\t\tvector< square > sqr;\n\t\t\tfor(int j = 0; j < max + 1; j++) {\n\t\t\t\tsquare s;\n\t\t\t\ts.flg = false;\n\t\t\t\ts.dist = 0;\n\t\t\t\ts.sflg = false;\n\t\t\t\ts.x = i;\n\t\t\t\ts.y = j;\n\t\t\t\tsqr.push_back(s);\n\t\t\t}\n\t\t\tsq.push_back( sqr );\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint xpos, ypos;\n\t\t\tcin >> xpos >> ypos;\n\t\t\txpos += max / 2;\n\t\t\typos += max / 2;\n\t\t\tsq[xpos][ypos].sflg = true;\n\t\t}\n\n\t\tqueue< square > q;\n\t\tsquare squr;\n\t\tcin >> squr.x >> squr.y;\n\t\tsqur.x += max / 2;\n\t\tsqur.y += max / 2;\n\t\tsqur.dist = 0;\n\t\tsqur.flg = true;\n\t\tsqur.sflg = false;\n\t\tsq[squr.x][squr.y] = squr;\n\t\tq.push( squr );\n\n\t\tsearch_bfs( &q, &sq, t );\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < max + 1; i++) {\n\t\t\tfor(int j = 0; j < max + 1; j++) {\n\t\t\t\tif( sq[j][i].flg == true ) ans ++;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\t//while(1){}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAXX 120\n#define MAXY 120\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\nint solve(int x,int y,int depth){\n\tfor(int i=0;i<MAXX;i++)\n\t\tfor(int j=0;j<MAXY;j++)\n\t\t\tflg[i][j]=false;\n\n\tint cnt=0;\n\tqueue<pair<int,pair<int,int> > > q;\n\tq.push(pair<int,pair<int,int> >(x,pair<int,int>(y,depth)));\n\twhile(!q.empty()){\n\t\tint cx,cy,cd;\n\t\tpair<int,pair<int,int> > frt = q.front();\n\t\tq.pop();\n\t\tcx=frt.first;\n\t\tcy=frt.second.first;\n\t\tcd=frt.second.second;\n\t\tif(!flg[cx][cy]){\n\t\t\tcnt++;\n\t\t\tflg[cx][cy]=true;\n\t\t\tif(cd>0){\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tint nnx = (cx+xd[i])%MAXX;\n\t\t\t\t\tint nny = (cy+yd[i])%MAXY;\n\t\t\t\t\tint nnd = cd-1;\n\t\t\t\t\tif(mp[nnx][nny] && !flg[nnx][nny])\n\t\t\t\t\t\tq.push(pair<int,pair<int,int> >(nnx,pair<int,int>(nny,nnd)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tfor(int i=0;i<100000;i++){\n\t\t\tsolve((cX+x)%MAXX,(cX+y)%MAXY,t);\n\t\t}\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Brave Force Story\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair< pair<int, int>, int> Q;\n#define INF 10000\nint dx[6]={1, 1, 0, -1, -1, 0}, dy[6]={1, 0, -1, -1, 0, 1};\nint mp[61][61];//+30????????????\nint d[61][61];\n\nQ make_Q(int x, int y, int z){\n  Q ret;\n  ret.first.first=x;\n  ret.first.second=y;\n  ret.second=z;\n  return ret;\n}\n\nint main(){\n  int t, n;\n  while(cin>>t>>n, !(t==0&&n==0)){\n    memset(mp, 0, sizeof(mp));\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\td[i][j]=INF;\n    while(n--){\n      int tmp_x, tmp_y;\n      cin>>tmp_x>>tmp_y;\n      mp[tmp_x+30][tmp_y+30]=-1;\n    }\n    int sx, sy;\n    cin>>sx>>sy;\n    d[sx+30][sy+30]=0;\n    queue<Q> q;\n    q.push(make_Q(sx+30, sy+30, t));\n    while(!q.empty()){\n      Q now=q.front(); q.pop();\n      if(now.second==0)break;\n      for(int i=0; i<6; i++){\n\tint nx=now.first.first+dx[i], ny=now.first.second+dy[i];\n\tif(0<=nx && nx<61 && 0<=ny && ny<61 && mp[nx][ny]!=-1 && d[nx][ny]==INF){\n\t  q.push(make_Q(nx, ny, now.second-1));\n\t  d[nx][ny]=d[now.first.first][now.first.second]+1;\n\t}\n      }\n    }\n    int cnt=0;\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\tif(d[i][j]!=INF)cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n;\nbool used[100][100], block[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = 1;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      //if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\nint mass[120][120];\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nvoid dfs(int x, int y, int turn){\n  if(turn == 1) return;\n  REP(i, 6){\n    int nx = x + dx[i]; int ny = y + dy[i];\n    if(mass[nx][ny] < turn-1 and mass[nx][ny] >= 0) { mass[nx][ny] = turn-1; dfs(nx, ny, turn-1); }\n  }\n}\n\nint main(){\n  int t, n;\n  while(cin >> t >> n and t + n){\n    memset(mass, 0, sizeof(mass));\n    REP(i, n){\n      int x, y; cin >> x >> y;\n      mass[x+40][y+40] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    mass[sx+40][sy+40] = t+1;\n    dfs(sx+40, sy+40, t+1);\n    int res = 0;\n    REP(i, 80) { REP(j, 80) cout << mass[79-j][i] << \" \"; cout << endl; }\n    REP(i, 80) REP(j, 80) if(mass[i][j] > 0) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 100;\n\nclass S{\npublic:\n  int y, x, c;\n  S() : y(0), x(0), c(0) {}\n  S(int y, int x, int c) : y(y), x(x), c(c) {}\n};\n\nint t, n, sy, sx;\nbool mapData[N][N];\nbool visited[N][N];\nint dy[] = {1, 0, -1, -1, 0, 1};\nint dx[] = {1, 1, 0, -1, -1, 0};\n\nvoid bfs(){\n  fill(visited[0], visited[N], false);\n  S u;\n  queue<S> q;\n  q.push(S(sy, sx, 0));\n  visited[sy][sx] = true;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(!mapData[ny][nx]) continue;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = true;\n      if(u.c+1 < t) q.push(S(ny, nx, u.c+1));\n    }\n  }\n}\n\n\nmain(){\n  while(cin >> t >> n && (t|n)){\n    fill(mapData[0], mapData[N], true);\n    for(int i=0;i<n;i++){\n      int y, x;\n      cin >> x >> y; \n      mapData[y+N/2][x+N/2] = false;\n    }\n    cin >> sx >> sy;\n    sx += N/2;\n    sy += N/2;\n    bfs();\n    int ans = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(visited[i][j]) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int t,n;\n    cin>>t>>n;\n    if(!t)break;\n    vector<vector<int>> m(61,vector<int>(61));\n    vector<vector<int>::iterator> vitr(61);\n    REP(i,61) vitr[i] = begin(m[i]) + 30;\n    auto grid = begin(vitr) + 30;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      grid[x][y] = 1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    set<tuple<int,int>> vis;\n    vis.insert(make_tuple(sx,sy));\n    queue<tuple<int,int,int>> q;\n    q.push(make_tuple(0,sx,sy));\n    while(!q.empty()){\n      int i,j,d;\n      tie(d,i,j) = q.front();q.pop();\n      if(d==t)continue;\n      int di[] = {1,1,0,-1,-1,0};\n      int dj[] = {1,0,-1,-1,0,1};\n      REP(k,6){\n        int ni=i+di[k];\n        int nj=j+dj[k];\n        if(abs(ni)>30||abs(nj)>30)continue;\n        if(grid[ni][nj] == 1) continue;\n        if(vis.find(make_tuple(ni,nj)) != end(vis))continue;\n        vis.insert(make_tuple(ni,nj));\n        q.push(make_tuple(d+1,ni,nj));\n      }\n    }\n    cout << vis.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define mp(a, b) make_pair(a, b)\nconst int dx[] = {0, -1, -1, 0, 1, 1}, dy[] = {1, 0, -1, -1, 0, 1};\n\nvoid solve(set<pair<int, int> >& vis, int x, int y, int t){\n    const int sep = 1 << 16;\n    queue<pair<int, int> > q;\n    q.emplace(x, y);\n    q.emplace(sep, 0);\n    while(!q.empty()){\n        x = q.front().first; y = q.front().second; q.pop();\n        if(x == sep){\n            q.emplace(sep, 0);\n            if(--t == 0)break; else continue;\n        }\n        rep(k, 6){\n            int nx = x + dx[k], ny = y + dy[k];\n            if(/*!vis.emplace(nx, ny)*/!vis.insert(mp(nx, ny)).second)continue;\n            q.emplace(nx, ny);\n        }\n    }\n}\n\nint main(){\n    int t, n;\n    while(cin >> t >> n, t|n){\n        set<pair<int, int> > vis;\n        int x, y;\n        rep(i, n+1){\n            cin >> x >> y;\n            vis.insert(mp(x, y)); // vis.emplace(x, y);\n        }\n        solve(vis, x, y, t);\n        cout << (int)vis.size() - n << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct point {\n  int x;\n  int y;\n  int t;\n} POINT;\n\nint t, n, sx, sy, cnt;\nbool d[140][140];\nbool f[140][140];\nqueue<POINT> que;\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &t, &n);\n  if (!t && !n) return false;\n  fill(d[0], d[0] + 140 * 140, true);\n  fill(f[0], f[0] + 140 * 140, true);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &sx, &sy);\n    d[sy + 70][sx + 70] = false;\n  }\n  scanf(\"%d %d\", &sx, &sy);\n\n  while (!que.empty()) que.pop();\n\n  return true;\n}\n\nint main() {\n  POINT a, b;\n\n  while (input()) {\n    a.x = sx + 70;\n    a.y = sy + 70;\n    a.t = t + 1;\n    cnt = 0;\n    que.push(a);\n    while (!que.empty()) {\n      a = que.front();\n      que.pop();\n      //printf(\"%d %d %d\\n\", a.x, a.y, a.t);\n      if (!a.t) break;\n      //if (a.y < 0 || 63 <= a.y || a.x < 0 || 63 <= a.x) continue;\n      if (!d[a.y][a.x] || !f[a.y][a.x]) continue;\n      f[a.y][a.x] = false;\n      cnt++;\n      \n      b.x = a.x + 1;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n    }\n    printf(\"%d\\n\", cnt);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\t\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n#define pb push_back\n#define PB push_back\n#define lb lower_bound\n#define LB lower_bound\n#define ub upper_bound\n#define UB upper_bound\n\n\n//constant\nconst int MOD = 1000000007;\nconst int INF = INT_MAX / 2-1;\nconst double EPS = 1e-9;\nconst int dx4[4] = { 1,0,-1,0 };\nconst int dy4[4] = { 0,1,0,-1 };\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\n\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n, t) {\n\t\tvvi ob(121, vi(121, 0));\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tob[x+60][y+60] = 1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tvvi able(121, vi(121, 0));\n\t\tqueue<tuple<int, int,int>> q;\n\t\tq.push(make_tuple(x + 60, y + 60, 0));\n\t\ttuple<int, int, int> now;\n\t\tfor (;!q.empty();) {\n\t\t\tnow = q.front();\n\t\t\tq.pop();\n\t\t\tx = get<0>(now);\n\t\t\ty = get<1>(now);\n\t\t\tint turn = get<2>(now);\n\t\t\tif (turn> t || ob[x][y]||able[x][y])\n\t\t\t\tcontinue;\n\t\t\table[x][y] = 1;\n\t\t\tREP(i, 3)\n\t\t\t\tREP(j, 3)\n\t\t\t\tif((i-1)*(j-1)>=0)\n\t\t\t\t\tq.push(make_tuple(x + i-1, y + j-1, turn + 1));\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 120)\n\t\t\tREP(j, 120)\n\t\t\t\tcnt += able[i][j];\n\n\t\tcout << cnt << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\nint dx[6] = {0, 1, 1, 0, -1, -1}, dy[6] = {1, 1, 0, -1, -1, 0};\n\nsigned main() {\n  int t, n;\n  while ( cin >> t >> n, t | n ) {\n    int mas[200][200] = {{0}};\n    int sx, sy;\n    Rep(i, n) {\n      int x, y;\n      cin >> x >> y;\n      x += 100; y += 100;\n      mas[y][x] = 1;\n    }\n    cin >> sx >> sy;\n    sx += 100; sy += 100;\n\n    int ans = 0;\n    bool used[200][200] = {{0}};\n    queue<Pip> q;\n    q.push(Pip(t, Pii(sy, sx)));\n    while ( !q.empty() ) {\n      Pip p = q.front(); q.pop();\n      int nt = p.fr, y = p.sc.fr, x = p.sc.sc;\n\n      if ( used[y][x] ) continue;\n      ans++;\n      used[y][x] = true;\n      if ( nt == 0 ) continue;\n\n      Rep(i, 6) {\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif ( mas[ny][nx] == 1 ) continue;\n\tq.push(Pip(nt-1, Pii(ny, nx)));\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[150][150];\nbool used[150][150];\nbool come[150][150];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)ta[i][j]=0,used[i][j]=0,come[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=50,ty+=50;\n\tta[ty][tx]=1;\n\t}\n\tint ttt;cin>>ttt>>ttt;\n\tused[50][50]=1;\n\tmasu start;\n\tstart.x=50,start.y=50,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\t//cout<<nx<<\" \"<<ny<<endl;\n\tif(come[ny][nx]==1)continue;\n\tcome[ny][nx]=1;\n\tused[ny][nx]=1;\n\tif(ntn>=t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]==0&&used[nexty][nextx]==0){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<150;i++){\n\tfor(int j=0;j<150;j++){\n\tif(come[i][j]){ans++;}\n\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint dx[6]={0,1,-1,1,-1,0},dy[6]{1,1,0,0,-1,-1};\nbool a[500][500];\nint mincost[500][500];\nsigned main(){\n    int b,c;\n    while(cin>>b>>c,b|c){\n\tmemset(a,true,sizeof(a));\n\tmemset(mincost,-1,sizeof(mincost));\n\tfor(int d=0;d<c;d++){\n\t    int e,f;scanf(\"%d%d\",&e,&f);\n\t    e+=250;f+=250;\n\t    a[e][f]=false;\n\t    }\n\tint sum=1;\n\tint n,m;scanf(\"%d%d\",&n,&m);n+=250;m+=250;\n\tmincost[n][m]=0;\n\tqueue<P>Q;\n\tQ.push(P(n,m));\n\twhile(Q.size()){\n\t    P t=Q.front();Q.pop();\n\t    if(mincost[t.first][t.second]==b)continue;\n\t    for(int i=0;i<6;i++){\n\t\tint x=t.first+dx[i],y=t.second+dy[i];\n\t\tif(mincost[x][y]==-1&&a[x][y]){\n\t\t    mincost[x][y]=mincost[t.first][t.second]+1;\n\t\t    Q.push(P(x,y));\n\t\t    sum++;\n\t\t    }\n\t\t}\n\t    }\n\t    cout<<sum<<endl;\n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1 << 30;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main () {\n  cin.tie(0);\n  cout << setprecision(10);\n\n  vi dx = {0, 1, 1, 0, -1, -1};\n  vi dy = {1, 1, 0, -1, -1, 0};\n\n  while(1) {\n    int t, n; cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    map<P, bool> obst;\n    REP(i, n) {\n      int tmpx, tmpy; cin >> tmpx >> tmpy;\n      obst[make_pair(tmpx, tmpy)] = true;\n    }\n    int sx, sy; cin >> sx >> sy;\n    map<P, bool> sel;\n    queue<pair<P, int>> q;\n    sel[make_pair(sx, sy)] = true;\n    q.push(make_pair(P(sx, sy), 0));\n\n    int cnt = 1;\n    while(!q.empty()) {\n      pair<P, int> now = q.front(); q.pop();\n      REP(i, 6) {\n        pair<P, int> next = make_pair(P(now.first.first + dx[i], now.first.second + dy[i]), now.second+1);\n        if(!sel[next.first] && !obst[next.first] && next.second <= t) {\n          cnt++;\n          sel[next.first] = true;\n          q.push(next);\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\n\nclass State\n{\npublic:\n        int x,y,c;\n        State(int x, int y, int c)\n        :x(x),y(y),c(c)\n        {}\n};\n\nbool f[1000][1000];\nbool v[1000][1000];\n\nint main()\n{\n        int T,N;\n        while(cin >> T >> N, (T||N))\n        {\n                memset(f,0,sizeof(f));\n                memset(v,0,sizeof(v));\n\n                for(int i=0; i<N; i++)\n                {\n                        int x,y;\n                        cin >> x >> y;\n                        f[x+500][y+500]=1;\n                }\n\n                int ret=0;\n\n                int sx,sy;\n                cin >> sx >> sy;\n                queue<State> q;\n                q.push(State(sx+500,sy+500,0));\n\n                while(!q.empty())\n                {\n                        State s=q.front(); q.pop();\n                        if(v[s.x][s.y]) continue;\n                        if(s.c > T) continue;\n                        v[s.x][s.y]=1;\n                        ret++;\n\n                        for(int i=0; i<6; i++)\n                        {\n                                int tx=s.x+dx[i], ty=s.y+dy[i];\n                                if(v[tx][ty]) continue;\n                                if(f[tx][ty]) continue;\n\n                                q.push(State(tx,ty,s.c+1));\n                        }\n                }\n\n                cout << ret << endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,j) for (int (i)=0;(i)<(int)(j);++(i))\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nbool used[61][61];\nint board[101][101];\nint dr[] = { 1, 1, 0, -1, -1, 0 };\nint dc[] = { 0, 1, 1, 0, -1, -1 };\n\n\nint main() {\n    int t, n;\n    while (cin >> t >> n, t) {\n        fill(board[0], board[101], 1e8);\n        fill(used[0], used[61], false);\n        int x[301], y[301];\n        rep(i, n) {\n            cin >> x[i] >> y[i];\n            x[i] += 30, y[i] += 30;\n            board[y[i]][x[i]] = -1;\n        }\n        int r, c;\n        cin >> c >> r;\n        c += 30, r += 30;\n        used[r][c] = true;\n        queue<P> que;\n        que.push(make_pair(r, c));\n        board[r][c] = 0;\n        while (que.size()) {\n            P p = que.front(); que.pop();\n            rep(d, 6) {\n                int nr = p.first + dr[d], nc = p.second + dc[d];\n                if (nr < 0 or nc < 0 or nr > 60 or nc > 60 or board[nr][nc] == -1 or used[nr][nc]) continue;\n                used[nr][nc] = true;\n                que.push(make_pair(nr, nc));\n                board[nr][nc] = min(board[nr][nc], board[p.first][p.second] + 1);\n            }\n        }\n        int ans = 0;\n        rep(r, 100) rep(c, 100) {\n            if (board[r][c] >= 0 and board[r][c] <= t) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint d[]={0,1,-1};\n#define piii pair<pii,int>\npiii _pi(pii t,int h) {piii hoge; hoge.first=t; hoge.second=h; return hoge;}\nint main(){\n    int t,n;\n    while(cin>>t>>n, t+n){\n        map<pii,int>mp;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            temp=pii(temp.first+100,temp.second+100);\n            mp[temp]++;\n        }\n        pii s; cin>>s.first>>s.second;\n        s=pii(s.first+100,s.second+100);\n        vvi visit(1001,vi(1001,INF));\n        queue<piii>que;\n        que.push(_pi(s, 0));\n        int ans=0;\n        while(!que.empty()){\n            piii now=que.front(); que.pop();\n            if(mp[now.first])continue;\n            if(now.second>t)continue;\n            if(visit[now.first.first][now.first.second]==INF)ans++;\n            if(visit[now.first.first][now.first.second]<now.second)continue;\n            visit[now.first.first][now.first.second]=now.second;\n            rep(i,3)rep(j,3){\n                if(d[i]+d[j]==0)continue;\n                pii hoge=pii(now.first.first+d[i],now.first.second+d[j]);\n                que.push(_pi(hoge,now.second+1));\n            }\n        }\n       // int ans=0;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n\ntypedef tuple<int,int,int> Tr;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1};\n\nconst int NMAX = 100;\nint field[NMAX][NMAX];\n#define MAP(x, y) field[x + 50][y + 50]\n\nint main() {\n  int T, N;\n  while (cin >> T >> N and T) {\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      MAP(x, y) = INF;\n    }\n    REP(i, N) {\n      int x, y;\n      cin >> x >> y;\n      MAP(x, y) = -1;\n    }\n\n    int sx,sy;\n    cin >> sx >> sy;\n    priority_queue<Tr,vector<Tr>,greater<Tr>> que;\n    que.push(Tr(1,sx,sy));\n\n    while (!que.empty()) {\n      int turn, x, y;\n      tie(turn, x, y) = que.top(); que.pop();\n      if (turn >= MAP(x, y)) continue;\n      MAP(x, y) = turn;\n      REP(j, 6) {\n        const int nx = x + dx[j], ny = y + dy[j];\n        if (MAP(nx, ny) >= 0 and turn <= T)\n          que.push(Tr(turn + 1, x + dx[j], y + dy[j]));\n      }\n    }\n\n    int sum = 0;\n    FOR(x, -40, 40) FOR(y, -40, 40) {\n      if (MAP(x, y) >= 0 and MAP(x, y) < 100) sum++;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] < INF) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define mp(a, b) make_pair(a, b)\ntypedef pair<pair<int, int>, int> State;\n\nstatic const int MAX = 60;\nstatic const int N =  2*MAX+1;\nstatic const int dx[6] = {1, 1, 0, -1, -1, 0};\nstatic const int dy[6] = {0, 1, 1, 0, -1, -1};\nmain(){\n  bool O[N][N];\n  int t, n, x, y, sx, sy;\n  while(1){\n    cin >> t >> n;\n    assert( t <= 30 );\n\n    if ( t == 0 && n == 0 ) break;\n    rep(i, N) rep(j, N) O[i][j] = false;\n    rep(i, n){\n      cin >> x >> y;\n      O[x+MAX][y+MAX] = true;\n      assert( abs(x) <= 30 );\n      assert( abs(y) <= 30 );\n    }\n    cin >> sx >> sy;\n    sx += MAX;\n    sy += MAX;\n    queue<State> Q;\n    State u;\n    Q.push(mp(mp(sx, sy), 0));\n    O[sx][sy] = true;\n    int cnt = 0;\n    while(!Q.empty()){\n      u = Q.front(); Q.pop();\n\n      cnt++;\n      for ( int r = 0; r < 6; r++ ){\n\tint nx = u.first.first + dx[r];\n\tint ny = u.first.second + dy[r];\n\tif ( O[nx][ny] || u.second+1 > t) continue;\n\tO[nx][ny] = true;\n\tQ.push(mp(mp(nx, ny), u.second+1));\n      }\n    }\n    cout << cnt << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct P{\n\tint t,x,y;\n\tP(){}\n\tP(int t,int x,int y):t(t),x(x),y(y){}\n};\nbool wall[128][128];\nbool visited[128][128];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\tint x,y;\n\t\tmemset(wall,false,sizeof(wall));\n\t\tmemset(visited,false,sizeof(visited));\n\t\twhile(n--){\n\t\t\tcin>>x>>y;\n\t\t\twall[x+60][y+60]=true;\n\t\t}\n\t\tcin>>x>>y;\n\t\tqueue<P> q;\n\t\tq.push(P(0,x+60,y+60));\n\t\tvisited[x+60][y+60]=true;\n\t\tP a,b;\n\t\tint ans=1;\n\t\twhile(!q.empty()){\n\t\t\ta=q.front();q.pop();\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(i==-j)continue;\n\t\t\t\t\tb=P(a.t+1,a.x+i,a.y+j);\n\t\t\t\t\tif(!wall[b.x][b.y] && !visited[b.x][b.y]){\n\t\t\t\t\t\tvisited[b.x][b.y]=true;\n\t\t\t\t\t\tif(b.t<t)q.push(b);\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint x[150][150][2], n, m, c, d, i, j, k, sum;\n#define A(B,C) if(x[B][C][0]==0 && x[B][C][1]==0){x[B][C][0]=2;sum++;}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0) { break; }sum = 0; memset(x, 0, sizeof(x));\n\t\tfor (i = 0; i < m; i++) { cin >> c >> d; x[c + 70][d + 70][1] = 1; }cin >> c >> d; x[c + 70][d + 70][0] = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 141; j++) {\n\t\t\t\tfor (k = 0; k < 141; k++) {\n\t\t\t\t\tif (x[j][k][0] == 1) {\n\t\t\t\t\t\tA(j - 1, k - 1);\n\t\t\t\t\t\tA(j - 1, k);\n\t\t\t\t\t\tA(j, k - 1);\n\t\t\t\t\t\tA(j, k + 1);\n\t\t\t\t\t\tA(j + 1, k);\n\t\t\t\t\t\tA(j + 1, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < 141; j++) { for (k = 0; k < 141; k++) { if (x[j][k][0] == 2) { x[j][k][0] = 1; } } }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nint main(){\n\tint turn,n;\n\twhile(cin>>turn>>n&&turn){\n\t\t//初期化\n\t\tqueue<pair<int,int>> q;\n\t\tint d[70][70]; rep(i,70)rep(j,70) d[i][j]=INF;\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\td[y+30][x+30]=-1;\n\t\t\t// cout<<y+30<<\" \"<<x+30<<endl;\n\t\t}\n\t\tint sx,sy; cin>>sx>>sy;\n\t\tsy+=30; sx+=30;\n\t\td[sy][sx]=0;\n\t\tq.push(make_pair(sy,sx));\n\t    int dx[6]={0,1,0,-1,1,-1};\n\t    int dy[6]={1,0,-1,0,1,-1};\n\n\t    //実行\n\t\tint cnt=1;\n\t    while(q.size()){\n\t        pair<int,int> p=q.front(); //キューの先頭を取り出す\n\t\t\t// cout<<p.first<<\" \"<<p.second<<endl;\n\t        q.pop(); //取り出したら削除\n\t        int prev=d[p.first][p.second]; //一手前の手数prev\n\t\t\tif(prev==turn) continue;\n\t        rep(i,6){ //4方向探索\n\t            int cy=p.first+dy[i];\n\t            int cx=p.second+dx[i];\n\t            if(0<=cy&&cy<=60&&0<=cx&&cx<=60){ //範囲外取得キケン\n\t                if(d[cy][cx]==INF){ //通行可能かつ未到達\n\t                    d[cy][cx]=prev+1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t// cout<<cy<<\" \"<<cx<<endl;\n\t                    q.push(make_pair(cy,cx));\n\t                }\n\t            }\n\t        }\n\t    }\n\t    cout<<cnt<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(121, vi(121, 0));\n\t\tqueue<state> Q;\n\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+60][y+60] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx, sy, 0));\n\t\tfield[sx+60][sy+60] = 1;\n\t\tint count = 1;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tREP(d, 6) {\n\n\t\t\t\t\tif(field[st.x+dx[d]+60][st.y+dy[d]+60] == 0) {\n\t\t\t\t\t\tfield[st.x+dx[d]+60][st.y+dy[d]+60] = 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(st.t+1 < t) {\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dx[]{ 0,1,1,0,-1,-1 }, dy[]{ 1,1,0,-1,-1,0 };\nint main() {\n\tint t, n;\n\twhile (scanf(\"%d%d\", &t, &n), t) {\n\t\tmap<int, map<int, int>>mp, d;\n\t\trep(i, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tmp[x][y] = 1;\n\t\t}\n\t\tfor (int i = -30; i <= 30; i++)for (int j = -30; j <= 30; j++) {\n\t\t\td[i][j] = INT_MAX;\n\t\t}\n\t\tint sx, sy; scanf(\"%d%d\", &sx, &sy);\n\t\tqueue<P>que;\n\t\tint cnt = 1;\n\t\tque.push(P(sx, sy));\n\t\td[sx][sy] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (d[p.first][p.second] >= t)continue;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (!mp[nx][ny] && d[nx][ny] == INT_MAX) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAX_RANGE 60\n\nstruct POS\n{\n\tint X,Y,far;\n};\n\nPOS move(POS &now, POS &power)\n{\n\tPOS ans = {now.X+power.X, now.Y+power.Y, now.far+1};\n\treturn ans;\n}\nbool eq(POS &a, POS &b){return a.X == b.Y && a.Y == b.Y;}\n\nPOS mpow[6]={{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\nbool list[MAX_RANGE][MAX_RANGE];\n\nint movenum(POS &start, int t, int n);\n\nint main()\n{\n\tint t,n,x,y;\n\tPOS start;\n\twhile(true){\n\t\tstd::cin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0; i<MAX_RANGE; i++)\n\t\t\tfor(int j=0; j<MAX_RANGE; j++) list[i][j] = false;\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tstd::cin >> x >> y;\n\t\t\tlist[x+MAX_RANGE/2][y+MAX_RANGE/2] = true;\n\t\t}\n\t\tstart.X = x;\n\t\tstart.Y = y;\n\t\tstart.far = 0;\n\t\tstd::cout << movenum(start, t, n) << std::endl;\n\t}\n\treturn 0;\n}\n\nint movenum(POS &start, int t, int num)\n{\n\tint n = num, mnum=1;\n\tPOS now = start;\n\tstd::queue<POS> q;\n\tfor(;;){\n\t\tif(now.far != t){\n\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\tPOS s = move(now, mpow[j]);\n\t\t\t\tif(!list[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2]){\n\t\t\t\t\tmnum++;\n\t\t\t\t\tlist[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2] = true;\n\t\t\t\t\tq.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.empty()) break;\n\t\tnow = q.front();\n\t\tq.pop();\n\t}\n\treturn mnum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n//#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint field[120][120];\n\nint main(){\n\tint t, n;\n\twhile(cin >> t>> n, t+n){\n\t\trep(i, 120)rep(j, 120) field[i][j] = inf;\n\t\tfor(int i=0; i< n; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfield[x+60][y+60] = -1;\n\t\t}\n\t\tint mx, my; cin >> mx >> my;\n\t\tmx += 60; my += 60;\n\t\tfield[mx][my] = 1;\n\t\tqueue<pair<int, int> > q;\n\t\tq.push(make_pair(mx, my));\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y]-1 == t) continue;\n\n\t\t\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\t\t\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\t\t\tfor(int i=0; i< 6; i++){\n\t\t\t\tint nx = dx[i]+x, ny = dy[i]+y;\n\t\t\t\tif(field[nx][ny] != -1 && field[x][y]+1 < field[nx][ny]){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i=0; i< 120; i++)for(int j=0; j< 120; j++) if(0 < field[i][j] && field[i][j] != inf) ret++;\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n/*\nstruct vector2{\n  int x, y;\n  vector2(int a,int b){\n    x=a;\n    y=b;\n  }\n};\n*/\n\nvoid solve(int t,int n){\n  int x,y;\n  set<pi> d;\n  int dx[6]={1,1,0,-1,-1,0};\n  int dy[6]={1,0,-1,-1,-0,1};\n  \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    d.insert(mp(a,b));\n  }\n  cin>>x>>y;\n\n  set<pi> ans;\n  queue<pi> next;\n  ans.insert(mp(x,y));\n  next.push(mp(x,y));\n  for(int i=0;i<t;i++){\n    int size=next.size();\n    for(int j=0;j<size;j++){\n      pi dir=next.front();next.pop();\n      for(int k=0;k<6;k++){\n\tpi tmp=mp(dir.first+dx[k],dir.second+dy[k]);\n\tif(d.find(tmp)==d.end()&&abs(tmp.first)<=30&&abs(tmp.second)<=30){\n\t \n\t  //cout<<\"debug: \"<<tmp.first<<\" \"<<tmp.second<<endl;\n\t  next.push(tmp);\n\t  ans.insert(tmp);\n\t}//else{cout<<\"false...\"<<endl;}\n      }\n    }\n  }\n  cout<<ans.size()<<endl;\n  \n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0&&n==0)break;\n    solve(t,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {0, -1, -1, 0, 1, 1}, dy[] = {1, 0, -1, -1, 0, 1};\n\nvoid solve(set<pair<int, int> >& vis, int x, int y, int t){\n    const int sep = 1 << 16;\n    queue<pair<int, int> > q;\n    q.emplace(x, y);\n    q.emplace(sep, 0);\n    while(!q.empty()){\n        x = q.front().first; y = q.front().second; q.pop();\n        if(x == sep){\n            q.emplace(sep, 0);\n            if(--t == 0)break; else continue;\n        }\n        rep(k, 6){\n            int nx = x + dx[k], ny = y + dy[k];\n            if(!vis.emplace(nx, ny).second)continue;\n            q.emplace(nx, ny);\n        }\n    }\n}\n\nint main(){\n    int t, n;\n    while(cin >> t >> n, t|n){\n        set<pair<int, int> > vis;\n        int x, y;\n        rep(i, n+1){\n            cin >> x >> y;\n            vis.emplace(x, y);\n        }\n        solve(vis, x, y, t);\n        cout << (int)vis.size() - n << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct G{\n    int x,y;\n    int c;\n};\n\nint visited[200][200] = {0};\n\nvoid bfs(int x,int y,int n){\n    int cnt = 0;\n    queue<G> q;\n    G gtmp;\n    G gin;\n    gin.x = x;\n    gin.y = y;\n    gin.c = 0;\n    visited[x][y] = 1;\n    q.push(gin);\n    while(!q.empty()){\n        gtmp = q.front();\n        // cout << gtmp.x << \" \" << gtmp.y << \" \" << visited[gtmp.x][gtmp.y]<< endl;\n        q.pop();\n        if(gtmp.c==n) break;\n            if(visited[gtmp.x+1][gtmp.y]==0){\n                gin.x = gtmp.x+1;\n                gin.y = gtmp.y;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }\n            if(visited[gtmp.x][gtmp.y+1]==0){\n                gin.x = gtmp.x;\n                gin.y = gtmp.y+1;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }\n            if(visited[gtmp.x+1][gtmp.y+1]==0){\n                gin.x = gtmp.x+1;\n                gin.y = gtmp.y+1;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }            \n            if(visited[gtmp.x-1][gtmp.y]==0){\n                gin.x = gtmp.x-1;\n                gin.y = gtmp.y;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }\n            if(visited[gtmp.x][gtmp.y-1]==0){\n                gin.x = gtmp.x;\n                gin.y = gtmp.y-1;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }\n            if(visited[gtmp.x-1][gtmp.y-1]==0){\n                gin.x = gtmp.x-1;\n                gin.y = gtmp.y-1;\n                gin.c = gtmp.c + 1;\n                visited[gin.x][gin.y] = 1;\n                // cout << gin.c <<  \" \" << gin.x << \" \" << gin.y << endl; \n                q.push(gin);\n            }\n\n    }\n}\n\nint main() {\n    // queueに入れる\n    while(1){\n        int turn,num;\n        int x,y;\n        int sx,sy;\n        int cnt=0;\n        cin >> turn >> num;\n        if(turn==0&&num==0) break;\n        for(int i=0;i<200;i++){\n            for(int j=0;j<200;j++){\n                visited[i][j] = 0;\n            }\n        }\n        for(int i=0;i<num;i++){\n            cin >> x >> y;\n            visited[x+100][y+100] = -1; \n        } \n        cin >> sx >> sy;       \n        bfs(sx+100,sy+100,turn);\n        int ans=0;\n        for(int i=0;i<200;i++){\n            for(int j=0;j<200;j++){\n                // cout << visited[i][j] <<\" \";\n                if(visited[i][j]==1) ans++;\n                // cout << i << \" \" << j << \" \" << ans << endl;\n            }\n            // cout << endl;\n        }\n        cout << ans << endl;\n\n    }\n   \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[900][900]={};\nbool vis[900][900]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.emplace(x,y,t);\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.emplace(na,nb,c-1);\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,900)rep(j,900)cnt+=vis[i][j];\n  return cnt;\n}\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=30;y+=30;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=100;sy+=100;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#define MAXX 500\n#define MAXY 500\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\n//深さ優先の再帰関数\nvoid solve2(int x,int y,int depth){\n\t//深さ0で終了\n\tif(depth==0) return;\n\t//x,y点周辺を探索済みにする\n\tfor(int i=0;i<6;i++)\n\t\tflg[(x+xd[i])%MAXX][(y+yd[i])%MAXY]=true;\n\t//x,y点周辺でかつ，障害物のない点を探索する\n\tfor(int i=0;i<6;i++)\n\t\tif(mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY])\n\t\t\tsolve2((x+xd[i])%MAXX,(y+yd[i])%MAXY,depth-1);\n}\n\n//再帰関数を呼び出し，数え上げるための関数\nint solve(int x,int y,int depth){\n\tint cnt=0;\n\t//始点を探索済みにする\n\tflg[x][y]=true;\n\t//始点より深さ優先\n\tsolve2(x,y,depth);\n\t//すべての点について\n\tfor(int i=0;i<MAXX;i++)\n\t\tfor(int j=0;j<MAXY;j++)\n\t\t\t//障害物がなく，探索済みな点の数を数え上げる\n\t\t\tif(mp[i][j]&&flg[i][j]) cnt++;\n\t//解を出力\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fi first\n#define se second\n#define rep(i, j, k) for (auto i = j; i < k; i++)\n#define rrep(i, j, k) for (auto i = j; i > k; i--)\nusing namespace std;\n\nmap<int, int> idx;\nint a[201][201], b[201][201];\nint dy[] = {0, 1, 1, 0, -1, -1, 0};\nint dx[] = {1, 1, 0, -1, -1, 0, 0};\n\nvoid solve(int &t, int &n) {\n  rep(i, 0, n) {\n    int x, y; cin >> x >> y;\n    a[idx[y]][idx[x]] = -1;\n  }\n  int sx, sy; cin >> sx >> sy;\n  a[idx[sy]][idx[sx]] = 1;\n  rep(cnt, 0, t) {\n    rep(i, 0, 201) {\n      rep(j, 0, 201) {\n        if (a[i][j] == 0) continue;\n        if (a[i][j] == -1) {b[i][j] = -1; continue;}\n        rep(d, 0, 7) {\n          if (a[i + dy[d]][j + dx[d]] != -1) b[i + dy[d]][j + dx[d]] = 1;\n        }\n      }\n    }\n    rep(i, 0, 201) rep(j, 0, 201) {\n      a[i][j] = b[i][j];\n      b[i][j] = 0;\n    }\n  }\n  int ans = 0;\n  rep(i, 0, 201) rep(j, 0, 201) if (a[i][j] == 1) ans++;\n  cout << ans << endl;\n}\nint main() {\n  rep(i, -100, 101) idx[i] = i + 100;\n  int n, t;\n  while (true) {\n    cin >> t >> n;\n    if (n == 0 && t == 0) break;\n    rep(i, 0, 201) rep(j, 0, 201) {a[i][j] = 0; b[i][j] = 0;}\n    solve(t, n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\n// int n_dir = 4;\n// int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; [> CSS order <]\n// enum direction {\n\t// UP, RIGHT, DOWN, LEFT\n// };\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint t, n;\n\twhile (cin >> t >> n, t | n) {\n\t\tset<PII> objects;\n\t\tset<PII> visited;\n\t\tREP (_, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tobjects.insert(MP(y, x));\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue< pair<PII, int> > q;\n\t\tq.push(MP(MP(sy, sx), 0));\n\t\tint dy[] = { 1, 0, -1, -1, 0, 1 };\n\t\tint dx[] = { 1, 1, 0, -1, -1, 0 };\n\t\tint ans = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpair<PII, int> tmp = q.front(); q.pop();\n\t\t\tPII p = tmp.F; int turn = tmp.S;\n\t\t\tif (turn > t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (EXIST(visited, p) || EXIST(objects, p)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ans;\n\t\t\tvisited.insert(p);\n\t\t\tREP (d, 6) {\n\t\t\t\tint ny = p.F + dy[d], nx = p.S + dx[d];\n\t\t\t\tPII np = MP(ny, nx);\n\t\t\t\tq.push(MP(np, turn + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\nusing namespace std;\nint t, n, x, y, a, b, v[121][121]; bool s[121][121];\nint main() {\n\twhile (~scanf(\"%d%d\", &t, &n)) {\n\t\tif (t == 0) break;\n\t\tfor (int i = 0; i <= 120; i++) {\n\t\t\tfor (int j = 0; j <= 120; j++) {\n\t\t\t\ts[i][j] = true, v[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y); s[y + 60][x + 60] = true;\n\t\t}\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tqueue<pair<int, int> > que; que.push(make_pair(a, b)); v[b][a] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint x = que.front().first;\n\t\t\tint y = que.front().second; que.pop();\n\t\t\tif (v[y][x] == t) continue;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (i + j && v[y + i][x + j] == -1) {\n\t\t\t\t\t\tv[y + i][x + j] = v[y][x] + 1;\n\t\t\t\t\t\tque.push(make_pair(x + j, y + i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i <= 120; i++) {\n\t\t\tfor (int j = 0; j <= 120; j++) {\n\t\t\t\tif (v[i][j] != -1) ret++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef tuple<int, int, int> tp;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nbool obstacle[120][120];\nbool visited[120][120];\n\nint main() {\n    int t, n;\n    while(cin>>t>>n, t+n) {\n        rep(i, 120) rep(j, 120) obstacle[i][j] = false;\n        rep(i, 120) rep(j, 120) visited[i][j] = false;\n\n        rep(_, n) {\n            int x, y;\n            cin >> x >> y;\n            obstacle[x+60][y+60] = true;\n        }\n\n        int cx, cy, cnt;\n        cin >> cx >> cy;\n        cx += 60;\n        cy += 60;\n\n        queue< tp > que;\n        que.push(make_tuple(cx, cy, 0));\n        visited[cx][cy] = true;\n        while(!que.empty()) {\n            tie(cx, cy, cnt) = que.front(); que.pop();\n            if(cnt == t) break;\n            REP(i, -1, 2) REP(j, -1, 2) {\n                if(i*j < 0) continue;\n                if(visited[cx+i][cy+j]) continue;\n                if(obstacle[cx+i][cy+j]) continue;\n                que.push(make_tuple(cx+i, cy+j, cnt+1));\n                visited[cx+i][cy+j] = true;\n            }\n        }\n        int ans = 0;\n        rep(i, 120) rep(j, 120) ans += visited[i][j];\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 50;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[100][100]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\ntypedef pair<pii,int>piii;\nint dx[]={0,-1,1};\nint dy[]={0,-1,1}\n;int main(){\n    int t,n;\n    while(cin>>t>>n){\n        int ans=0;\n        if(t+n==0)break;\n        map<pii,int>mp;\n        pii s;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>s.first>>s.second;\n        queue<piii>que;\n        que.push(make_pair(s,0));\n        while(!que.empty()){\n            piii now=que.front();que.pop();\n            if(now.second>t)continue;\n            if(now.second>mp[now.first]&&mp[now.first]!=0)continue;\n            if(mp[now.first]==0)ans++;\n            mp[now.first]=now.second;\n            if(now.first==s)mp[s]=INF;\n            rep(i,3)rep(j,3){\n                if(dx[i]+dy[j]==0)continue;\n                pii next=pii(now.first.first+dx[i],now.first.second+dy[j]);\n                if(mp[next]==-INF)continue;\n                piii hoge;\n                hoge.first=next;\n                hoge.second=now.second+1;\n                que.push(hoge);\n                \n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef unsigned int ui;\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nconst int VISITED = -1;\nconst int OBJ = 1;\nconst int SPACE = 0;\n\nint x0 = 50;\nint y0 = 50;\nint map[100][100];\nint t,n;\nint x,y,sx,sy;\n\nint mv(int x,int y,int t){\n  int ret = 0;\n  if(map[x+x0][y+y0] == OBJ)return 0;\n  if(map[x+x0][y+y0] != VISITED)ret += 1;\n  map[x+x0][y+y0] = VISITED;\n  if(t == 0)return ret;\n  for(ui i = 0;i < 6;i++){\n    ret += mv(x+dx[i],y+dy[i],t-1);\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> t >> n && !(n == 0 && t == 0)){\n    for(int i = 0;i < 100;i++){\n      for(int j = 0;j < 100;j++){\n\tmap[i][j] = SPACE;\n      }\n    }\n    for(int i = 0;i < n;i++){\n      cin >> x >> y;\n      map[x+x0][y+y0] = OBJ;\n    }\n    cin >> sx >> sy;\n    cout << mv(sx,sy,t) <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \n#define BLANK -1\n#define BLOCK -2\n#define CENTER 30\n#define MAX 30+30+30+1\n \nint t,n;\nint dx[6]={0,1,1,0,-1,-1};\nint dy[6]={1,1,0,-1,-1,0};\nint field[MAX][MAX];\n \nvoid rec(int x, int y,int d)\n{\n if(d>=t)return;\n for(int i=0;i<6;i++){\n  int xx=x+dx[i];\n  int yy=y+dy[i];\n  if(field[xx][yy]==BLOCK)continue;\n  if(field[xx][yy]!=BLANK&&field[xx][yy]<d)continue;\n  field[xx][yy]=d;\n  rec(xx,yy,d+1);\n }\n}\n \nint main()\n{\n  int i,j,cnt,a,b;\n  while(cin>>t>>n,t||n){\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)field[i][j]=BLANK;\n    for(i=0;i<n;i++){\n      cin>>a>>b;\n      field[a+CENTER][b+CENTER]=BLOCK;\n    }\n    cin>>a>>b;\n    field[a+CENTER][b+CENTER]=0;\n    rec(a+CENTER,b+CENTER,0);\n    cnt=0;\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)if(field[i][j]>=0)cnt++;\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[62][62];\nbool flag[62][62];\nint sum;\nvoid dfs(int cnt,int nx,int ny){\n\tif(cnt==0)return;\n\tREP(i,6)if(!mp[nx+dx[i]][ny+dy[i]]){\n\t\tif(!flag[nx+dx[i]][ny+dy[i]]){\n\t\t\tflag[nx+dx[i]][ny+dy[i]]=true;\n\t\t\tsum++;\n\t\t}\n\t\tdfs(cnt-1,nx+dx[i],ny+dy[i]);\n\t}\n}\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\tmp[tx+30][ty+30]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsum=1;\n\t\tflag[sx+30][sy+30]=true;\n\t\tdfs(t,sx+30,sy+30);\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <utility>\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define REG(i, a, b) for (int (i) = ((int)(a)); (i) < ((int)(b)); i++)\n#define ALL(V) (V).begin(), (V).end()\n#define PRINT(STR) cout << (STR) << endl\n#define ROUNDED(N) fixed << setprecision(N)\n#define SPACE \" \"\n\ntypedef long long ll;\nusing namespace std;\n\nint nextInt() { int n; cin >> n; return n; }\ndouble nextDouble() { double d; cin >> d; return d; }\nstring nextString() { string str; cin >> str; return str; }\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {1,0,-1,-1,0,1};\nstruct points{int x,y,turn;};\nconst int def = 30;\nint main() {\n\tcin.tie(0); //?????±?????????????????????\n\tios::sync_with_stdio(false); //printf??¨??±??????????????????\n\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\tvector<vector<int>> mp(61,vector<int>(61,0));\n\t\tREP(i,n){\n\t\t\tint a = nextInt()+def;\n\t\t\tint b = nextInt()+def;\n\t\t\tmp[a][b] = 1;\n\t\t}\n\t\tqueue<points> que;\n\t\tpoints start;\n\t\tstart.x=nextInt()+def;start.y=nextInt()+def;start.turn=t;\n\t\tque.push(start);\n\t\tint ct = 0;\n\t\twhile(que.size()){\n\t\t\tint x = que.front().x;\n\t\t\tint y = que.front().y;\n\t\t\tint nowturn = que.front().turn;\n\t\t\tque.pop();\n\t\t\tif(mp[x][y]==0){\n\t\t\t\tct++;\n\t\t\t\tmp[x][y] = 1;\n\t\t\t}else continue;\n\t\t\tif(nowturn==0)continue;\n\t\t\tREP(i,6){\n\t\t\t\tpoints ne;\n\t\t\t\tne.x = x + dx[i];\n\t\t\t\tne.y = y + dy[i];\n\t\t\t\tif(ne.x<0||ne.x>def*2||ne.y<0||ne.y>def*2||ne.x*ne.x+ne.y*ne.y>900)continue;\n\t\t\t\tif(mp[ne.x][ne.y]==0){\n\t\t\t\t\tne.turn = nowturn - 1;\n\t\t\t\t\tque.push(ne);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n            cin >>  y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        que.pop();\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\nusing namespace std;\n\nint d[175][175];\nint xx[6] = {1,1,-1,-1,0,0};\nint yy[6] = {1,0,-1,0,1,-1};\n\n\nint main(){\n\n  int t, n;\n  while(cin >> t >> n && (t||n)){\n    memset(d,0,sizeof(d));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      d[y+75][x+75] = 1;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    d[y+75][x+75] = 1;\n    int cnt = 1;\n\n    queue<pair<int, pair<int, int> > > q;\n    q.push(make_pair(t, make_pair(x+75, y+75)));\n    int ttc = 0;\n\n    while(!q.empty()){\n      pair<int, pair<int, int> > cq = q.front();\n      q.pop();\n      if(cq.first == 0) continue;\n      int tc = cq.first;\n     for(int i = 0; i < 6; i++){\n       int nx = xx[i] + cq.second.first, ny = yy[i] + cq.second.second;\n       if(d[ny][nx] != 1){\n         d[ny][nx] = 1;\n         cnt++;\n         q.push(make_pair(tc-1,make_pair(nx,ny)));\n       }\n     }\n    }\n\n    cout << cnt << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n/** Problem2253 : Brave Force Story **/\nint T;\nconst int dx0[6]={0, 1, 1, 0, -1, -1};\nconst int dy0[6]={1, 1, 0, -1, -1, 0};\nint ans;\nset<P> vis;\ntypedef struct {\n\tP pos; int cost;\n} S;\n\nint main()\n{\n\tint n, sx, sy;\n\twhile (cin>>T>>n, T||n) {\n\t\tvis.clear();\n\t\tans=0;\n\t\t\n\t\trep(k, n) {\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\tvis.insert(P(x, y));\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tS s = {P(sx, sy), 0};\n\t\tqueue<S> Q;\n\t\tQ.push(s);\n\t\tvis.insert(s.pos);\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tS t = Q.front(); Q.pop();\n\t\t\tcout << t.pos.first << \" \" << t.pos.second << endl;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx=t.pos.first+dx0[i], ny=t.pos.second+dy0[i];\n\t\t\t\t//if (-30<=nx&&nx<=30 && -30<=ny&&ny<=30) {\n\t\t\t\t\tif (vis.find(P(nx, ny)) == vis.end() && t.cost+1<=T) {\n\t\t\t\t\t\tS ns = {P(nx, ny), t.cost+1};\n\t\t\t\t\t\tQ.push(ns);\n\t\t\t\t\t\tvis.insert(ns.pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t\tcout << vis.size()-n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[70][70], d[70][70];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60 ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+30][b+30]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=30;\n\t\tstart.y+=30;\n\t\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\twhile(!que.empty()){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\tif(d[v.x][v.y]>=turn) continue;\n\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx; tmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[61][61];\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int t,int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty()){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n    if(cnt == t)continue;\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tgrid[ny][nx]=-1;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0 && n==0)break;\n    memset(grid,0,sizeof(grid));\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      grid[y+30][x+30]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    grid[sy+30][sx+30]=-1;\n    cout <<  bfs(t,sx+30,sy+30) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\t/* ?????? */\n\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\n\t//???????????¢\n\tint d[MAX_X][MAX_Y];\n\tmemset(d, 0x3f, sizeof(d));\n\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\t//??´??????????????¢?´¢????????????\n\t\tif (u == pii(gx, gy))break;\n\t\t//?§????4???????????¢?´¢\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\t\t//??¢?´¢???????£???°???\n\t\t\t\tif (d[nx][ny] != INF)continue;\n\t\t\t\td[nx][ny] = d[sx][sy] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[gx][gy];\n}\n\n#define MAX 200\n#define O 100\n\nint main() {\n\tbool m[MAX][MAX]; //?????????\n\tint d[MAX][MAX];\n\tfor (int t, n; cin >> t >> n&&t;) {\n\t\tmemset(m, false, sizeof(m));\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += O; y += O;\n\t\t\tm[x][y] = true;\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += O; sy += O;\n\n\t\tqueue<pii> Q;\n\t\tQ.push(pii(sx, sy));\n\t\td[sx][sy] = 0;\n\n\t\t//?§????6?????????????????????\n\t\tint dx[6] = { 1,1,0,-1,-1,0 };\n\t\tint dy[6] = { 0,1,1,0,-1,-1 };\n\t\tfor (pii u; !Q.empty();) {\n\t\t\tu = Q.front(); Q.pop();\n\t\t\tif (d[u.first][u.second] == t)continue;\n\t\t\t//?§????6???????????¢?´¢\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < MAX && 0 <= ny&&ny < MAX) {\n\t\t\t\t\t//?????????????£???°???\n\t\t\t\t\tif (m[nx][ny])continue;\n\t\t\t\t\t//??¢?´¢???????£???°???\n\t\t\t\t\tif (d[nx][ny] != INF)continue;\n\t\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int x = 0; x < MAX; x++) {\n\t\t\tfor (int y = 0; y < MAX; y++) {\n\t\t\t\tif (d[x][y] <= t)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 0;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tint field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tsum++;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>21){if(!field[x-1][y]){field[x-1][y] = 1;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>21){if(!field[x][y-1]){field[x][y-1] = 1;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<81){if(!field[x+1][y]){field[x+1][y] = 1;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<81){if(!field[x][y+1]){field[x][y+1] = 1;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>21 && y>21){if(!field[x-1][y-1]){field[x-1][y-1] = 1;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<81 && y<81){if(!field[x+1][y+1]){field[x+1][y+1] = 1;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[200][200]={};//(0,0)=100,100\nint n,t;\nvoid dfs(int x,int y,int i){\n  a[x][y]=i;\n  i++;\n  if(t>=i-1){\n    if(a[x-1][y-1]==0 || a[x-1][y-1]>i) dfs(x-1,y-1,i);\n    if(a[x-1][y]==0 || a[x-1][y]>i) dfs(x-1,y,i);\n    if(a[x][y-1]==0 || a[x][y-1]>i) dfs(x,y-1,i);\n    if(a[x+1][y+1]==0 || a[x+1][y+1]>i) dfs(x+1,y+1,i);\n    if(a[x+1][y]==0 || a[x+1][y]>i) dfs(x+1,y,i);\n    if(a[x][y+1]==0 || a[x][y+1]>i) dfs(x,y+1,i);\n  }\n  else return;\n}\n\n\nint main(){\n  int i,j,c,co;\n  int x,y,cx,cy;\n  while(1){\n    //syoki\n    for(i=0;i<200;i++){\n      for(j=0;j<200;j++){\n\ta[i][j]=0;\n      }\n    }\n    co=0;\n    scanf(\"%d%d\",&t,&n);\n    if(t==0&&n==0)break;\n    //printf(\"point 1\\n\");///\n    for(i=0;i<n;i++){\n      scanf(\"%d%d\",&x,&y);\n      // printf(\"\\n\");\n      a[x+100][y+100]=-1;\n    }\n    //printf(\"point 2\\n\");///\n    scanf(\"%d%d\",&cx,&cy);\n    cx+=100;\n    cy+=100;\n    dfs(cx,cy,1);\n    //printf(\"point 3\\n\");///\n    for(i=0;i<200;i++){\n      for(j=0;j<200;j++){\n\tif(a[i][j]>0)co++;\n      }\n    }\n    printf(\"%d\\n\",co);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nconst int INF = 1000000000;\n#define SF 61\n\n\nint visit[130][130],ans;\nint dx[]={1,1,0,-1,-1,0},dy[]={1,0,-1,-1,0,1};\n\nint t,n;\n\nvoid func(int x,int y,int rem){\n\tif (visit[y][x] >= rem) {\n\t\treturn;\n\t}\n\tif (visit[y][x] == -1) ans++;\n\tvisit[y][x] = rem;\n\t\n\tif (rem == 0) return;\n\tint nx,ny;\n\tfor(int i=0;i<6;i++){\n\t\tnx=dx[i]+x;\n\t\tny=dy[i]+y;\n\t\tfunc(nx,ny,rem-1);\n\t}\n\t\n}\n\nint main(){\n\twhile(cin>>t>>n,n||t){\n\t\tans=0;\n\t\tint x,y,sx,sy;\n\t\tfor(int i=0;i<130;i++)\n\t\tfor(int j=0;j<130;j++){\n\t\t\tvisit[i][j]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tvisit[y+SF][x+SF]=10000;\n\t\t}\n\t\tcin>>sx>>sy;\n\t\t\n\t\tfunc(sx+SF,sy+SF,t);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint mas[222][222];\n\nint dx[] = {-1, -1, 0, 0, 1, 1};\nint dy[] = {-1, 0, 1, -1, 0, 1};\n\nint cnt;\n\nvoid bfs(int sx, int sy, int st)\n{\n  queue<PP> que;\n  que.push(PP(P(sx, sy), st));\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.first.first, y = p.first.second, t = p.second;\n    if(t < 0 || mas[x][y]++) continue;\n    cnt++;\n    for(int i = 0; i < 6; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      que.push(PP(P(nx, ny), t-1));\n    }\n  }\n}\n\nint main()\n{\n  int t, n;\n  while(cin >> t >> n, t || n){\n    memset(mas, 0, sizeof(mas));\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      x += 111; y += 111;\n      mas[x][y] = 1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += 111; sy += 111;\n    cnt = 0;\n    bfs(sx, sy, t);\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dy[6] = {1, 1, 0, 0, -1, -1};\nint dx[6] = {0, 1, -1, 1, -1, 0};\n\nint main()\n{\n    int t, n;\n    \n    while (scanf(\"%d %d\", &t, &n) && t){\n        bool done[256][256] = {0};\n        \n        for (int i = 0; i < n; i++){\n            int y, x;\n            scanf(\"%d %d\", &x, &y);\n            done[y + 128][x + 128] = 1;\n        }\n        \n        int x, y;\n        \n        queue<pair<int, pair<int, int> > > q;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        int ct = 1;\n        done[y + 128][x + 128] = true;\n        for (q.push(make_pair(t, make_pair(y + 128, x + 128))); q.size(); q.pop()){\n            pair<int, pair<int, int> > stat = q.front();\n            \n            int l = stat.first;\n            int ny = stat.second.first, nx = stat.second.second;\n            \n            if (l == 0) continue;\n            \n            for (int i = 0; i < 6; i++){\n                int ty = ny + dy[i], tx = nx + dx[i];\n                if (!done[ty][tx]){\n                    done[ty][tx] = 1;\n                    ct++;\n                    q.push(make_pair(l - 1, make_pair(ty, tx)));\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ct);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool cango(int y,int x,map<pii,int> &S){\n  return S.find(make_pair(y,x)) == S.end();\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint solve(int sy,int sx,map<pii,int> &M,int t){\n  int ini=M.size();\n  queue<pii> Q;\n  Q.push(make_pair(sy,sx));\n  M[make_pair(sy,sx)]=0;\n  while(!Q.empty()){\n    pii now = Q.front();Q.pop();\n    int tc=M[make_pair(now.first,now.second)];\n    for(int i=0;i<6;i++){\n      int nex=now.second+dx[i],ney=now.first+dy[i];\n\n      if (cango(ney,nex,M) && tc+1 <= t)\n\tQ.push(make_pair(ney,nex)),\n\t  M[make_pair(ney,nex)]=tc+1;\n    }\n  }\n  return M.size()-ini;\n}\n\nmain(){\n  int n,t;\n  while(cin>>t>>n){\n    if (n == 0 && t == 0)break;\n    map<pii,int> M;\n    for(int i=0;i<n;i++){\n      int ty,tx;cin>>tx>>ty;M[make_pair(ty,tx)]=-1;\n    }\n    int sy,sx;cin>>sx>>sy;\n    cout << solve(sy,sx,M,t) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[200][200];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 100;\n      Y += 100;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 100;\n    sy += 100;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n\nstruct xyt{\n\tint x, y, ti;\n};\n\nbool map[123][123], check[123][123];\nqueue <xyt> q;\nint ans;\n\nvoid search(int x,int y, int n, int t){\n\tint d[6][2] = {{1,1},{1,0},{0,1},{-1,0},{0,-1},{-1,-1}};\n\txyt s;\n\t//cout << x-61 << \" \" << y-61;\n\tans++;\n\tif(n<t){\n\t\tfor(int k=0;k<6;k++){\n\t\t\tif(map[x+d[k][0]][y+d[k][1]]==0 && check[x+d[k][0]][y+d[k][1]]==0){\n\t\t\t\tcheck[x+d[k][0]][y+d[k][1]]=1;\n\t\t\t\ts.x = x+d[k][0];\n\t\t\t\ts.y = y+d[k][1];\n\t\t\t\ts.ti = n+1;\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n\tq.pop();\n\tif(!q.empty())search(q.front().x, q.front().y, q.front().ti, t);\n}\n\nint main(){\n\tint i, j, t, n, x, y;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(i=-61;i<=61;i++){\n\t\t\tfor(j=-61;j<=61;j++){\n\t\t\t\tcheck[i+61][j+61] = 0;\n\t\t\t\tif(i==-61||i==61) map[i+61][j+61] = 1;\n\t\t\t\telse if(j==-61||j==61) map[i+61][j+61] = 1;\n\t\t\t\telse map[i+61][j+61] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x+61][y+61] = 1;\n\t\t}\n\t\tans = 0;\n\t\tcin >> x >> y;\n\t\tcheck[x+61][y+61] = 1;\n\t\txyt a;\n\t\ta.x = x + 61;\n\t\ta.y = y +61;\n\t\ta.ti = 0;\n\t\tq.push(a);\n\t\tsearch(q.front().x, q.front().y, q.front().ti, t);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint mas[66][66];\n\nint dx[] = {-1, -1, 0, 0, 1, 1};\nint dy[] = {-1, 0, 1, -1, 0, 1};\n\nint cnt;\n\nvoid bfs(int sx, int sy, int st)\n{\n  queue<PP> que;\n  que.push(PP(P(sx, sy), st));\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.first.first, y = p.first.second, t = p.second;\n    if(t < 0 || mas[x][y]++) continue;\n    cnt++;\n    for(int i = 0; i < 6; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      que.push(PP(P(nx, ny), t-1));\n    }\n  }\n}\n\nint main()\n{\n  int t, n;\n  while(cin >> t >> n, t || n){\n    memset(mas, 0, sizeof(mas));\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      x += 33; y += 33;\n      mas[x][y] = 1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += 33; sy += 33;\n    cnt = 0;\n    bfs(sx, sy, t);\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\n\nint solve(set<int> field,map<int,int> &visited,int turn,int x,int y){\n\tif(field.find(100*x+y) != field.end()) return 0;\n\tfield.insert(100*x+y);\n\tint sum = 1;\n\tif(visited.find(100*x+y) != visited.end()){\n\t\tif(visited[100*x+y] < turn) sum = 0;\n\t\telse return 0;\n\t}\n\tvisited.insert(map<int,int>::value_type(100*x+y,turn));\n\tif(turn) for(int i=-1;i<=1;++i){\n\t\tfor(int j=-1;j<=1;++j){\n\t\t\tif(i+j==0) continue;\n\t\t\tsum += solve(field, visited, turn-1, x+i, y+j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,!(t==0&&n==0)){\n\t\tset<int> field;\n\t\tmap<int,int> visited;\n\t\tfor(int i=0,x,y;i<n;++i){\n\t\t\tcin>>x>>y;\n\t\t\tfield.insert(100*x+y);\n\t\t}\n\t\tint st_x,st_y;\n\t\tcin>>st_x>>st_y;\n\t\tcout<<solve(field,visited,t,st_x,st_y)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nint dx[6] = { -1,-1,0,1,1,0 };\nint dy[6] = { 0,-1,-1,0,1,1 };\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tint T, N; cin >> T >> N;\n\t\tif (!T)break;\n\t\tset<pair<int, int>>mp;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tmp.emplace(x, y);\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue<aa>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tmp.emplace(sx, sy);\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tif (atop.turn == T)continue;\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\tint nx = atop.x + dx[i];\n\t\t\t\t\tint ny = atop.y + dy[i];\n\t\t\t\t\tif (mp.find(make_pair(nx, ny)) == mp.end()) {\n\t\t\t\t\t\tmp.emplace(nx, ny);\n\t\t\t\t\t\tque.push(aa{ nx,ny,atop.turn + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = mp.size() - N;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PI 4*atan(1)\n#define INF 1e8\n\ntypedef long long ll;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint ans = 0;\nint t, n;\n\nvoid bfs(int N, int y, int x, vector<vector<int>> &m){\n  if(N == t + 1)return;\n  m[y][x] = 1;\n  // ans++;\n  \n  for(int i = 0; i < 4; i++){\n    for(int j = 0; j < 4; j++){\n      int nx = x + dx[i], ny = y + dy[j];\n      if(dx[i] * dy[j] != -1){\n        if(0 <= nx && nx <= 2*30 && 0 <= ny && ny <= 2*30 && m[ny][nx] != -1)bfs(N + 1, ny, nx, m);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> t >> n, t||n){\n    ans = 0;\n    vector<vector<int>> m(30*2 + 1, vector<int>(30*2 + 1, 0));\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      x += 30; y += 30;\n      m[y][x] = -1;\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    start_x += 30; start_y += 30;\n\n    bfs(0, start_y, start_x, m);\n    for(int i = 0; i <= 30*2; i++){\n      for(int j = 0; j <= 30*2; j++){\n        if(m[i][j] == 1)ans++;\n      }\n    }\n    cout << ans << endl;\n    // cerr << \"t:\" << t << endl;\n    // cerr << \"start_x = \" << start_x << \" start_y = \" << start_y << endl;\n    // for(auto y : m){\n    //   for(auto x : y){\n    //     cerr << x;\n    //   }\n    //   cerr << endl;\n    // }\n    // cerr << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(long int i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[100][100];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif((k<0) || (a[p.real()+50][p.imag()+50] == 1)) return 0;\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == 0) res++;\n\ta[p.real()+50][p.imag()+50] = 2;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tmemset(a, 0, sizeof(a));\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = 1;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n//\tfor(int j=5;j>=-1;j--){ for(int i=-1;i<=5;i++){ cout<< \" \"<< a[i+50][j+50]; } cout<< endl; }\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto ele=q.front();\n            q.pop();\n            auto p=ele.first;\n            int turn=ele.second;\n            if(turn==t)\n                continue;\n            if(turn>t)\n                for(;;){}\n\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    if(turn==t)\n                    continue;\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\nnamespace utils{\n  template <typename T> void print(vector<vector<T>> mat) {\n    rep (i, mat.size()) {\n      rep (j, mat[0].size()) cout << mat[i][j] << ' ';\n      cout << endl;\n    }\n  }\n\n  template <typename T> void print(vector<T> v) {\n    rep (i, v.size()) cout << v[i] << ' ';\n    cout << endl;\n  }\n\n  template <typename T> pair<T, T> shape(vector<vector<T>> mat) {\n    int d1, d2;\n\n    d1 = mat.size();\n    if (d1 > 0) d2 = mat[0].size();\n    else int d2 = 0;\n    cout << \"(\" << d1 << \", \" << d2 << \")\" << endl;\n    return make_pair(0, 0);\n  }\n\n  template <typename T> vector<vector<T>> empty(int n, int m) {\n    vector<vector<T>> mat(n, vector<T>(m));\n    return mat;\n  }\n}\n\n\nconst int OFFSET = 50;\n\nint main() {\n  int t, n;\n  int cx, cy;\n  int sx, sy;\n\n  vector<int> dx = {1, 1, 0, -1, -1, 0};\n  vector<int> dy = {1, 0, -1, -1, 0, 1};\n\n  queue<pair<pair<int, int>, int>> s;\n\n  while (cin >> t >> n && (t || n)) {\n    cin >> sx >> sy;\n    sx += OFFSET;\n    sy += OFFSET;\n\n    vector<vector<bool>> visited = utils::empty<bool>(80, 80);\n    rep (i, 80) fill(visited[i].begin(), visited[i].end(), false);\n\n    rep (i, n) {\n      cin >> cx >> cy;\n      cx += OFFSET; cy += OFFSET;\n      visited[cx][cy] = true;\n    }\n\n    //initialize\n    s.push(make_pair(make_pair(sx, sy), 0));\n    int ans = 0;\n\n    while (!s.empty()) {\n      pair<pair<int, int>, int> q = s.front(); s.pop();\n      int cx = q.first.first;\n      int cy = q.first.second;\n      int turn = q.second;\n\n      if (cx < 0 || cy < 0 || cx >= (int)visited.size() || cy >= (int)visited[0].size() || visited[cx][cy]) continue;\n\n      visited[cx][cy] = true;\n      ans++;\n\n      rep (i, 6) {\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n\n        if (turn < t) {\n          s.push(make_pair(make_pair(nx, ny), turn+1));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint depth;\nint d[70][70];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    memset(d, -1, sizeof(d));\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(!que.empty()){\n        P p = que.front(); que.pop();\n        if(d[p.first][p.second]==depth) continue;\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(d[nx][ny] != -1) continue;\n            cout << nx << ' ' << ny << endl;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n   return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            d[x+30][y+30] = 0;\n        }\n        cin >> x >> y;\n        int res = bfs(x+30,y+30);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\nbool closed[500][500];\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  int count = 0;\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n/*\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n  */\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n  memset(closed,0,sizeof(closed));\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      closed[Y][X] = true;\n      //ox.push_back(X);\n      //oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\nconst int OBSTACLE = -1;\nconst int DIFF = 50;\nint field[100][100];\n\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1};\n\nbool in_field(int x, int y){\n    return 0<=x && x<100 & 0<=y && y<100;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T, N;\n    while(cin>>T>>N, T|N){\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                field[i][j] = INF;\n        int x, y;\n        while(N--){\n            cin >> x >> y;\n            field[y+DIFF][x+DIFF] = OBSTACLE;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        \n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> que;\n        field[sx+DIFF][sy+DIFF] = 0;\n        que.push(make_pair(field[sx+DIFF][sy+DIFF], make_pair(sx+DIFF, DIFF)));\n        \n        while(!que.empty()){\n            auto top = que.top(); que.pop();\n            int d = top.first;\n            int x = top.second.first, y = top.second.second;\n            \n            if(d > field[x][y])\n                continue;\n            \n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(in_field(nx, ny)){\n                    if(field[x][y] + 1 < field[nx][ny]){\n                        field[nx][ny] = field[x][y] + 1;\n                        que.push(make_pair(field[nx][ny], make_pair(nx, ny)));\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                ans += (0<=field[i][j] && field[i][j]<=T);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nbool isrange(int x,int y)\n{\n\treturn -30<=x && x<=30 && -30<=y && y<=30;\n}\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tvector<vector<int> > ob(61,vector<int>(61,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tob[x+30][y+30]=1;\n\t\t}\n\t\tpair<int,int> s;\n\t\tcin>>s.first>>s.second;\n\t\tqueue<pair<pair<int,int>, int> > q;\n\t\tvector<vector<int> > been(61,vector<int>(61,0));\n\t\tq.push(make_pair(s,0));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front().first;\n\t\t\tint turn=q.front().second;\n            q.pop();\n\t\t\tbeen[p.first+30][p.second+30]=1;\n\t\t\tif(turn==t)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(isrange(p.first+dx[i],p.second+dy[i]) && !ob[p.first+dx[i]+30][p.second+dy[i]+30] && !been[p.first+dx[i]+30][p.second+dy[i]+30]){\n\t\t\t\t\tbeen[p.first+dx[i]+30][p.second+dy[i]+30]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(p.first+dx[i],p.second+dy[i]),turn+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tint cnt=0;\t\t\n\t\tfor(int i=0;i<61;i++){\n\t\t\tfor(int j=0;j<61;j++)\n                cnt+=been[i][j];\n\n\t\t}\n\t\tcout<<cnt<<endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint main() {\n  int t, n;\n  while(cin >> t >> n && (t|n)) {\n    int M[61][61] = {};\n    int const BX = 30, BY = 30;\n    for(int i=0; i<n; i++) {\n      int x, y;\n      cin >> x >> y;\n      M[y+BY][x+BX] = 1;\n    }\n    \n    int const dx[] = {-1,1,0,0,1,-1};\n    int const dy[] = {0,0,-1,1,1,-1};\n    \n    typedef pair<int, int> Pii;\n    typedef pair<Pii, int> P;\n    \n    bool used[61][61] = {};\n    int ans = 0;\n    \n    int sx, sy;\n    cin >> sx >> sy; sx += BX, sy += BY;\n    \n    queue<P> Q;\n    Q.push(P(Pii(sx, sy), t));\n    used[sy][sx] = true;\n    \n    while(!Q.empty()) {\n      P const p = Q.front(); Q.pop();\n      ans ++;\n      \n      if(p.snd <= 0) continue;\n      \n      for(int i=0; i<6; i++) {\n\tint nx = p.fst.fst + dx[i], ny = p.fst.snd + dy[i];\n\tif(!used[ny][nx] && M[ny][nx] == 0) {\n\t  Q.push( P(Pii(nx, ny), p.snd-1) );\n\t  used[ny][nx] = true;\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\ncin >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\nconst int OBSTACLE = -1;\nconst int DIFF = 50;\nint field[100][100];\n\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1};\n\nbool in_field(int x, int y){\n    return 0<=x && x<100 & 0<=y && y<100;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T, N;\n    while(cin>>T>>N, T|N){\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                field[i][j] = INF;\n        int x, y;\n        while(N--){\n            cin >> x >> y;\n            field[x+DIFF][y+DIFF] = OBSTACLE;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        \n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> que;\n        field[sx+DIFF][sy+DIFF] = 0;\n        que.push(make_pair(field[sx+DIFF][sy+DIFF], make_pair(sx+DIFF, sy+DIFF)));\n        \n        while(!que.empty()){\n            auto top = que.top(); que.pop();\n            int d = top.first;\n            int x = top.second.first, y = top.second.second;\n            \n            if(d > field[x][y])\n                continue;\n            \n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(in_field(nx, ny)){\n                    if(field[x][y] + 1 < field[nx][ny]){\n                        field[nx][ny] = field[x][y] + 1;\n                        que.push(make_pair(field[nx][ny], make_pair(nx, ny)));\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                ans += (0<=field[i][j] && field[i][j]<=T);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >>  y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n\nint t,n;\nint fie[70][70];\nbool used[70][70];\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\nint sx,sy;\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int ix,int iy,int it){\n\t\tx=ix;\n\t\ty=iy;\n\t\tt=it;\n\t}\n};\n\nint bfs(){\n\tstd::queue<data> que;\n\tmemset(used,false,sizeof(used));\n\tque.push(data(sx,sy,0));\n\tused[sx][sy]=true;\n\tint res=1;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tif(d.t==t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx=d.x+dx[i],ny=d.y+dy[i];\n\t\t\tif(nx<5 || nx>=65 || ny<5 || ny>=65)continue;\n\t\t\tif(!used[nx][ny] && fie[nx][ny]==0){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tres++;\n\t\t\t\tque.push(data(nx,ny,d.t+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&t,&n);\n\t\tif(t+n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint bx,by;\n\t\t\tscanf(\"%d %d\",&bx,&by);\n\t\t\tbx+=35;\n\t\t\tby+=35;\n\t\t\tfie[bx][by]=-1;\n\t\t}\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx+=35,sy+=35;\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nll SUM(VI& V){\n  return accumulate(ALL(V), 0LL);\n}\n\nvoid print_vector(VI& V){\n  ll n = V.size();\n  rep(i, n){\n    if(i) cout << ' ';\n    cout << V[i];\n  }\n  cout << endl;\n}\n\nll gcd(ll a,ll b){\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n    ll g = gcd(a,b);\n    return a / g * b;\n}\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nconst int W=1000;\nll M[W][W]; // obstacle\nll d[W][W]; // distance\nvoid reset(){\n  rep(i,W){\n    rep(j,W){\n      M[i][j]=0;\n      d[i][j]=-1;\n    }\n  }\n}\n\nint dx[6] = {1, 0,-1,-1,0,1};\nint dy[6] = {0,-1,-1, 0,1,1};\n\nll manhattan_dist(ll x0, ll y0, ll x1, ll y1){\n  ll xdiff = abs(x0-x1);\n  ll ydiff = abs(y0-y1);\n  return xdiff + ydiff;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll T,N;\n\n    while(cin>>T>>N){\n      if(N==0 && T==0) return 0;\n      reset();\n      VI X(N);\n      VI Y(N);\n      rep(i,N){\n        cin>>X[i]>>Y[i];\n      }\n\n      ll sx,sy;cin>>sx>>sy;\n\n      // sx, syからの相対距離で考える\n      rep(i, N){\n        X[i] -= sx;\n        Y[i] -= sy;\n      }\n      sx=0;\n      sy=0;\n\n      sx+=W/2;\n      sy+=W/2;\n\n      debug(sx,sy);\n\n      rep(i,N){\n        ll x = X[i] + W/2;\n        ll y = Y[i] + W/2;\n        if(manhattan_dist(sx, sy, x, y)>100){\n          continue;\n        }else{\n          M[y][x] = 1;\n        }\n      }\n\n      queue<PII> que;\n      que.push(MP(sy,sx));\n      d[sy][sx] = 0;\n      while(!que.empty()){\n        auto pa = que.front(); que.pop();\n        ll y = pa.first;\n        ll x = pa.second;\n        if(d[y][x]>=30) continue;\n\n        rep(i,6){\n          ll ty = y + dy[i];\n          ll tx = x + dx[i];\n          if(d[ty][tx]==-1 && M[ty][tx]==0){\n            // まだ行ってなくて障害物もない\n            d[ty][tx] = d[y][x] + 1;\n            que.push(MP(ty,tx));\n          }\n        }\n      }\n\n      ll cnt=0;\n      rep(i, W){\n        rep(j, W){\n          if(d[i][j]!=-1 && d[i][j]<=T) cnt++;\n        }\n      }\n      p(cnt);\n    }    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[6] = { 1,1,0,-1,-1,0};\nconst int dy[6] = { 0,1,1,0,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif (!t)break;\n\t\tvvi v(121, vi(121, 0));\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv[y + 60][x + 60] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tvvi depth(121, vi(121, INF));\n\t\tdepth[sy +60][sx + 60] = 0;\n\t\tqueue<pii> q;\n\t\tq.push(make_pair(sx, sy));\n\t\twhile (!q.empty()) {\n\t\t\tpii a = q.front(); q.pop();\n\t\t\tint x = a.first, y = a.second;\n\t\t\tREP(i, 6) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (ny <= 60 && nx <= 60 && nx >= -60 && ny >= -60 && v[ny + 60][nx + 60] == 0&&depth[ny+60][nx+60]==INF) {\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\tdepth[ny + 60][nx + 60] = depth[y + 60][x + 60] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 121) {\n\t\t\tREP(j, 121) {\n\t\t\t\tif (depth[i][j] <= t)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x_;\n    int y_;\n    int t_;\n\n    State(int x, int y, int t) {\n        x_ = x;\n        y_ = y;\n        t_ = t;\n    }\n};\n\nint main (int argc, char *argv[]) {\n    int n, t;\n    int dx[6] = {1, 1, 0, -1, -1, 0};\n    int dy[6] = {0, 1, 1, 0, -1, -1};\n    while (cin>>t>>n, t||n) {\n        int sx, sy;\n        bool ob[200][200] = {false};\n        bool visited[200][200] = {false};\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin>>x>>y;\n            ob[x+100][y+100] = true;\n        }\n        cin>>sx>>sy;\n        queue<State> que;\n        que.push(State(sx, sy, 0));\n        visited[sx+100][sy+100] = true;\n        while (!que.empty()) {\n            State s = que.front();\n            que.pop();\n            for (int i = 0; i < 6; ++i) {\n                int nx = s.x_ + dx[i];\n                int ny = s.y_ + dy[i];\n                if (!visited[nx+100][ny+100] && !ob[nx+100][ny+100] && s.t_ < t) {\n                    que.push(State(nx, ny, s.t_ + 1));\n                    // printf(\"(%d, %d)\\n\", nx, ny);\n                    visited[nx+100][ny+100] = true;\n                    ans++;\n                }\n            }\n        }\n        cout<<ans + 1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef std::array<bool, 130> Line;\ntypedef std::array<Line, 130> Table;\n\nTable table; // [X][Y]\nstd::array< std::array<int, 130>, 130> standed; // [X][Y]\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + 65;\n}\n\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (true) {\n\t\tfor_each(table.begin(), table.end(), [](Line & line) {\n\t\t\tline.fill(false);\n\t\t});\n\t\tfor_each(standed.begin(), standed.end(), [](std::array<int, 130> & line) {\n\t\t\tline.fill(-1);\n\t\t});\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint t;\nint dy[]={0,1,-1};\nint dx[]={0,1,-1};\nint ans=0;\npii p;\nmap<pii,int>mp;\nvoid dfs(pii now,int cnt){\n    if(cnt>t)return;\n    if(mp[now]!=0&&mp[now]<cnt)return;\n    if(mp[now]==0)ans++;\n    mp[now]=cnt;\n    if(now==p)mp[now]=-INF;\n    if(abs(now.first)>30||abs(now.second)>30)return;\n    //cout<<now.first<<\" \"<<now.second<<endl;\n    rep(i,3)\n    rep(j,3){\n        if(dx[i]+dy[j])dfs(pii(now.first+dx[i],now.second+dy[j]),cnt+1);\n    }\n}\nint main(){\n    int n;\n    while(cin>>t>>n,t+n){\n        mp.clear();\n        ans=0;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>p.first>>p.second;\n        dfs(p,0);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nint check[62][62];\nbool jama_grid[62][62];\n\nvoid move_dfs(int y, int x, int cnt) {\n    //cout<<\"x:\"<<x-30<<\" y:\"<<y-30<<endl;\n    check[y][x] = cnt;\n    int dx[6] = {-1, 0, 1, 0, -1, 1};\n    int dy[6] = {0, -1, 0, 1, -1, 1};\n\n    for (int i = 0; i < 6; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx > 60 || ny > 60 || nx < 0 || ny < 0 || jama_grid[ny][nx]){\n            //cout<<\"check\"<<endl;\n            continue;\n        }else if (check[ny][nx] < cnt &&cnt >0) {\n            move_dfs(ny, nx, cnt-1);\n        }\n    }\n    return;\n}\n\nint main(){\n    int t, n;\n    int x, y;\n    int origin_x, origin_y;\n    int ans;\n    \n    while(1){\n        //初期化\n        ans = 0;\n        for(int i = 0; i < 62; i++){\n            for(int j = 0; j <62; j++){\n                check[i][j] = -1;\n                jama_grid[i][j] = false;\n            }\n        }\n\n        cin>>t>>n;\n        if(n == 0 && t == 0)break;\n        for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            jama_grid[y+30][x+30] = true;\n        }\n        cin >> origin_x >> origin_y;\n\n        move_dfs(origin_y+30, origin_x+30, t);\n\n        //行った場所のカウント\n        for(int i = 0; i < 62; i++){\n            for(int j = 0; j < 62; j++){\n                if(i == origin_y+30 && j == origin_x+30 ){\n                    //cout<<\"#\"<<\" \";\n                }else if(jama_grid[i][j]){\n                    //cout<<\"$\"<<\" \";\n                }else{\n                    //cout<<check[i][j]<<\" \";\n                }\n                if(check[i][j] != -1){\n                    //cout << \"x:\" << j << \"y:\" << i;\n                    ans++;\n                }\n            }\n            //cout<<endl;\n        }\n        //cout<<endl;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool o[200][200];\nbool reached[200][200];\nint count;\nint t;\nint sx, sy;\n\nvoid search(int x, int y, int t);\n\nint main(void){\n\tint n;\n\tint sx, sy;\n\twhile(1){\n\t\tfor(int i=0; i<200; i++){\n\t\t\tfor(int j=0; j<200; j++){\n\t\t\t\to[i][j]=false;\n\t\t\t\treached[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tcin >> t >> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int k=0; k<n; k++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\to[x+100][y+100]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tsearch(sx, sy, t);\n\t\tcout << count << endl;\n\t}\n\t\n\treturn 0;\n}\n\nvoid search(int x, int y, int t){\n\tif(x<sx-t || x>sx+t || y<sy-t || y>sy+t || o[x+100][y+100]) return;\n\tif(reached[x+100][y+100]) return;\n\tif((x-sx)*(y-sy)<0 && abs(x-sx)+abs(y-sy)>t) return;\n\t\n\treached[x+100][y+100] = true;\n\tcount++;\n\t\n\tsearch(x+1, y+1, t);\n\tsearch(x+1, y, t);\n\tsearch(x, y+1, t);\n\tsearch(x, y-1, t);\n\tsearch(x-1, y, t);\n\tsearch(x-1, y-1, t);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,-1,0,0,1,-1};\nint dy[6]={0,0,1,-1,1,-1};\nbool used[200][200];\nbool rock[200][200];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,200){\n\t\t\tfill(used[i],used[i]+200,false);\n\t\t\tfill(rock[i],rock[i]+200,false);\n\t\t}\n\t\tint x,y;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trock[y+100][x+100]=true;\n\t\t}\n\t\tcin>>x>>y;\n\t\tused[y+100][x+100]=true;\n\t\tqueue<piii> que;\n\t\tque.push(piii(0,pii(x+100,y+100)));\n\t\twhile(!que.empty()){\n\t\t\tpiii now=que.front();\n\t\t\tused[now.second.second][now.second.first]=true;\n\t\t\tque.pop();\n\t\t\trep(i,6){\n\t\t\t\tif(used[now.second.second+dy[i]][now.second.first+dx[i]]||rock[now.second.second+dy[i]][now.second.first+dx[i]])continue;\n\t\t\t\tif(now.first+1>t)continue;\n\t\t\t\tque.push(piii(now.first+1,pii(now.second.first+dx[i],now.second.second+dy[i])));\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\trep(i,200){\n\t\t\trep(j,200){\n\t\t\t\tif(used[i][j])cnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > n) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            REP(i, 6){\n                if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                    que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                    close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                    graph[cur.first + dy[i]][cur.second + dx[i]] = cnt+1;\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        //cout << i -31 << \" \" << j-31 << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 61){\n            REP(j, 61){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n    int x, y, turn;\n};\n\nint dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    int t, n;\n    while(cin >> t >> n, t != 0){\n        set<pair<int, int> > obstacle;\n        for(int i=0;i<n;++i){\n            int x, y;\n            cin >> x >> y;\n            obstacle.insert(make_pair(x, y));\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n\n        set<pair<int, int> > visited;\n        visited.insert(make_pair(sx, sy));\n        queue<Point> que;\n        que.push((Point){sx, sy, 0});\n        while(!que.empty()){\n            auto curr = que.front(); que.pop();\n            for(int i=0;i<6;++i){\n                auto next = make_pair(curr.x+dx[i], curr.y+dy[i]);\n                if(visited.count(next) || obstacle.count(next) || curr.turn >= t)continue;\n                visited.insert(next);\n                que.push((Point){next.first, next.second, curr.turn+1});\n            }\n        }\n\n        cout << visited.size() << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nint field[100][100];\nvoid setf(int x, int y, int val) {\n\tfield[x+50][y+50] = val;\n}\nint getf(int x, int y) {\n\treturn field[x+50][y+50];\n}\n\nstruct t_node {\n\tint x, y, t;\n\tt_node( int tx, int ty, int tt ) {\n\t\tx = tx;\n\t\ty = ty;\n\t\tt = tt;\n\t}\n};\nbool operator<( const t_node &lhs, const t_node &rhs ) {\n\treturn lhs.t < rhs.t;\n}\n\nconst int INF = 1<<30;\n\nint main() {\n\tint t, n;\n\twhile( cin >> t >> n, t||n ) {\n\t\tmemset( field, -1, sizeof(field) );\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tsetf(x, y, INF);\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(sx, sy, t) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n\t\t\tif( getf(tn.x, tn.y) > 0 ) continue;\n\t\t\tsetf( tn.x, tn.y, tn.t );\n\t\t\tif( tn.t == 0 ) continue;\n\t\t\tint dx[6] = {0, 1, 1,  0, -1, -1};\n\t\t\tint dy[6] = {1, 1, 0, -1, -1,  0};\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = tn.x + dx[i];\n\t\t\t\tint ny = tn.y + dy[i];\n\t\t\t\tif( -30<=nx && nx<=30 &&\n\t\t\t\t\t-30<=ny && ny<=30 &&\n\t\t\t\t\tgetf(nx, ny) < tn.t-1 ) {\n\t\t\t\t\tque.push( t_node(nx, ny, tn.t-1) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int y=-30; y<=30; y++) {\n\t\t\tfor(int x=-30; x<=30; x++) {\n\t\t\t\tint f = getf(x, y);\n\t\t\t\tif( 0<=f && f<INF ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\nclass Integer {\n\tint value;\npublic:\n\tInteger() : value(0) {}\n\tInteger(int x) : value(x) {}\n\toperator int() const {return value;}\n};\nconst int dx[] = {1, 0, -1, -1, 0, 1};\nconst int dy[] = {0, -1, -1, 0, 1, 1};\n\nint main () {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tmap<int, map<int, Integer> > blocks;\n\t\tmap<int, map<int, Integer> > visited;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tblocks[x][y] = 1;\n\t\t}\n\t\tint count = 0;\n\t\tqueue<pair<int, pair<int, int> > > que;\n\t\tpair<int, int> pos;\n\t\tcin >> pos.first >> pos.second;\n\t\tque.push(make_pair(0, pos));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, pair<int, int> > current = que.front();\n\t\t\tconst int s = current.first;\n\t\t\tconst int x = current.second.first;\n\t\t\tconst int y = current.second.second;\n\t\t\tque.pop();\n\t\t\tif (visited[x][y]) continue;\n\t\t\tvisited[x][y] = 1;\n\t\t\tcount++;\n\t\t\tif (s == t) continue;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tconst int nx = x + dx[i];\n\t\t\t\tconst int ny = y + dy[i];\n\t\t\t\tif (!blocks[nx][ny]) {\n\t\t\t\t\tque.push(make_pair(s + 1, make_pair(nx, ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst long long MOD = 1000000007;\nconst long long INF = MOD + 1;\nconst long double PI = 3.1415926;\n#define FOR(i, r, n) for(int i=(ll)(r); i<(ll)(n); i++) \n#define REP(i, n) FOR(i, (0), n)\n#define ALL(r) r.begin(), r.end()\n#define ll long long int\nusing namespace std;\nstring s;\nvector<ll> v;\nvector<pair<ll, ll>> vp;\nvector<vector<ll>> vv(110, vector<ll>(110, INF));\nvector<tuple<ll, ll, ll>> vt;\nset<ll> st;\nmap<char, ll> mp;\n\nll n, m;\nset<pair<ll, ll>> done, imp;\nmap<pair<int, int>, int> inque;\ntypedef tuple<ll, ll, ll> TP;\npriority_queue <TP,vector<TP>,greater<TP>> que;\n\nvoid solve(int dep, int x, int y)\n{\n\tif (dep <= n)\n\t{\n\t\tdone.emplace(x, y);\n\t\tif (dep < n)\n\t\t{\n\t\t\tif (!done.count(make_pair(x + 1, y + 1))) {\n\t\t\t\tinque[make_pair(x + 1, y + 1)] = min(inque[make_pair(x + 1, y + 1)], dep);\n\t\t\t\tque.emplace(dep + 1, x + 1, y + 1);\n\t\t\t}\n\t\t\tif (!done.count(make_pair(x + 1, y))) {\n\t\t\t\tinque[make_pair(x + 1, y)] = min(inque[make_pair(x + 1, y)], dep);\n\t\t\t\tque.emplace(dep + 1, x + 1, y);\n\t\t\t}\n\t\t\tif (!done.count(make_pair(x, y + 1))) {\n\t\t\t\tinque[make_pair(x, y + 1)] = min(inque[make_pair(x, y + 1)], dep);\n\t\t\t\tque.emplace(dep + 1, x, y + 1);\n\t\t\t}\n\t\t\tif (!done.count(make_pair(x, y - 1))) {\n\t\t\t\tinque[make_pair(x, y - 1)] = min(inque[make_pair(x, y - 1)], dep);\n\t\t\t\tque.emplace(dep + 1, x , y - 1);\n\t\t\t}\n\t\t\tif (!done.count(make_pair(x - 1, y))) {\n\t\t\t\tinque[make_pair(x - 1, y)] = min(inque[make_pair(x - 1, y)], dep);\n\t\t\t\tque.emplace(dep + 1, x - 1, y);\n\t\t\t}\n\t\t\tif (!done.count(make_pair(x - 1, y - 1))) {\n\t\t\t\tinque[make_pair(x - 1, y - 1)] = min(inque[make_pair(x - 1, y - 1)], dep);\n\t\t\t\tque.emplace(dep + 1, x - 1, y - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tdone.clear(); imp.clear();\n\t\tcin >> n >> m;\n\t\tif (!n && !m) break;\n\t\tFOR(i, -32, 32)\n\t\t\tFOR(j, -32, 32)\n\t\t{\n\t\t\tinque[make_pair(i, j)] = INF;\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\timp.emplace(a, b);\n\t\t}\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tque.emplace(0, x, y);\n\t\tinque[make_pair(x, y)] = 0;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tll dep;\n\t\t\ttie(dep, x, y) = que.top();\n\t\t\tque.pop();\n\t\t\tif (!done.count(make_pair(x, y)) && !imp.count(make_pair(x, y))) solve(dep, x, y);\n\t\t}\n\t\tcout << done.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\t\n\twhile(cin >> t >> n, t) {\n\t\tqueue<state> Q;\n\t\tvvi field(61, vi(61, 0));\n\t\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = 1;\n\t\tint count = 1;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(st.t < t) {\n\t\t\t\tREP(d, 6) {\n\t\t\t\t\tif(abs(st.x+dx[d]-30)<= 30 && abs(st.y+dy[d]-30)<=30) {\n\t\t\t\t\t\tif(field[st.x+dx[d]][st.y+dy[d]] == 0) {\n\t\t\t\t\t\t\tfield[st.x+dx[d]][st.y+dy[d]] = 1;\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tP p_(x,y);\n\t\tint cnt = f[p_] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << f[p_] << endl;\n\t\tif( cnt > t )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p] == -2 ) continue;\n\t\t\t\n\t\t\tif( f[p] == -1 ){\n\t\t\t\tf[p] = cnt;\n\t\t\t\tque.push( p );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\tf.clear();\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -2;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 0;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tsolve( t , f , que );\n\t\tint ans = 1;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] > 0 ) ans++;\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\t\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n#define pb push_back\n#define PB push_back\n#define lb lower_bound\n#define LB lower_bound\n#define ub upper_bound\n#define UB upper_bound\n\n\n//constant\nconst int MOD = 1000000007;\nconst int INF = INT_MAX / 2-1;\nconst double EPS = 1e-9;\nconst int dx4[4] = { 1,0,-1,0 };\nconst int dy4[4] = { 0,1,0,-1 };\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\n\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n, t) {\n\t\tvvi ob(100, vi(100, 0));\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tob[x+50][y+50] = 1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tvvi able(100, vi(100, 0));\n\t\tqueue<tuple<int, int,int>> q;\n\t\tq.push(make_tuple(x + 50, y + 50, 0));\n\t\ttuple<int, int, int> now;\n\t\tfor (;!q.empty();) {\n\t\t\tnow = q.front();\n\t\t\tq.pop();\n\t\t\tx = get<0>(now);\n\t\t\ty = get<1>(now);\n\t\t\tint turn = get<2>(now);\n\t\t\tif (turn> t || ob[x][y]||able[x][y])\n\t\t\t\tcontinue;\n\t\t\table[x][y] = 1;\n\t\t\tREP(i, 3)\n\t\t\t\tREP(j, 3)\n\t\t\t\tif((i-1)*(j-1)>=0)\n\t\t\t\t\tif(20<=x+i-1 && x+i-1<=80 && 20<=y+j-1 &&y+j-1<=80)\n\t\t\t\t\tq.push(make_tuple(x + i-1, y + j-1, turn + 1));\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, 100)\n\t\t\tREP(j, 100)\n\t\t\tif (able[i][j]) { /*debug(i - 50); debug(j - 50);*/ cnt++; }\n\n\t\tcout << cnt << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 1, 0, -1, -1, 0};\nconst int dy[] = {0, 1, 1, 0, -1, -1};\n\nint main()\n{\n\tint t, n;\n\twhile (scanf(\"%d %d\", &t, &n) != EOF) {\n\t\tif (t == 0 && n == 0)\n\t\t\tbreak;\n\n\t\tset<pair<int, int> > block;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tblock.insert(pair<int, int>(x, y));\n\t\t}\n\n\t\tpair<int, int> s;\n\t\tscanf(\"%d %d\", &s.first, &s.second);\n\n\t\tset<pair<int, int> > ans;\n\t\tqueue<pair<int, int> > que, next;\n\t\tans.insert(s);\n\t\tque.push(s);\n\n\t\tfor (int i = 0; i < t; ++i) {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpair<int, int> f = que.front();\n\t\t\t\tque.pop();\n\n\t\t\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\t\t\tpair<int, int> p = f;\n\t\t\t\t\tp.first += dx[j];\n\t\t\t\t\tp.second += dy[j];\n\n\t\t\t\t\tif (block.find(p) != block.end() || ans.find(p) != ans.end())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tans.insert(p);\n\t\t\t\t\tnext.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(que, next);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define MOD 100000\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct A{int x,y,c;};\nint dx[6]={-1,-1,0,0,1,1};\nint dy[6]={-1,0,1,-1,1,0};\nint main(){\n      int t,n,x,y,sx,sy;\n      while(cin>>t>>n&&(t!=0||n!=0)){\n            bool trbl[61][61];\n            bool used[61][61];\n            memset(used,true,sizeof(used));\n            memset(trbl,true,sizeof(trbl));\n            REP(i,n){cin>>x>>y;trbl[x+30][y+30]=false;}\n            cin>>sx>>sy;\n            int cnt=1;used[sx+30][sy+30]=false;\n            queue<A> Q;\n            Q.push((A){sx+30,sy+30,0});\n            while(!Q.empty()){\n                  //cout<<Q.size()<<endl;\n                  A a=Q.front();Q.pop();\n                  if(a.c>=t)continue;\n                  REP(i,6){\n                        int nx=a.x+dx[i],ny=a.y+dy[i];\n                        //cout<<nx<<\" \"<<ny<<endl;\n                        if(nx>60||nx<0||ny>60||nx<0)continue;\n                        if(used[nx][ny]&&trbl[nx][ny]){\n                              //cout<<nx<<\" \"<<ny<<endl;\n                              used[nx][ny]=false;\n                              Q.push((A){nx,ny,a.c+1});\n                              cnt++;\n                        }\n                  }\n            }\n            cout<<cnt<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define For(i,a,b) for(int i = a;i < b;i++)\n#define all(n) n.begin(),n.end()\n\nconst int dx[6] = { 0,1,1,0,-1,-1 }, dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n && t) {\n\t\tmap<int, map<int, int>> m;\n\t\tmap<int, map<int, int>> a;\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tm[x][y] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push(P(sx, sy));\n\t\ta[sx][sy] = 1;\n\n\t\twhile (q.size()) {\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(i, 6) {\n\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\tif (m[tx][ty] == 0 && a[tx][ty] == 0) {\n\t\t\t\t\tif (a[x][y] <= t) {\n\t\t\t\t\t\ta[tx][ty] = a[x][y] + 1;\n\t\t\t\t\t\tq.push(P(tx, ty));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (auto vp : a) {\n\t\t\tfor (auto p : vp.second) {\n\t\t\t\tif (p.second) {\n\t\t\t\t\tans += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nconst int basex = 100;\nconst int basey = 100;\n\nint depth;\nint d[200][200];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(!que.empty()){\n        P p = que.front(); que.pop();\n        if(d[p.first][p.second]==depth) continue;\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(d[nx][ny] != -1) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n   return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        memset(d, -1, sizeof(d));\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            d[x+basex][y+basey] = 0;\n        }\n        cin >> x >> y;\n        int res = bfs(x+basex,y+basey);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n, block[61][61];\nbool used[61][61];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, false, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 30; ty += 30;\n    block[ty][tx] = 1;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 30; sy += 30;\n  \n  int res = 0;\n  queue<pair<int,pair<int,int> > > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      //if (tx < 0 || ty < 0 || tx >= 60 || ty >= 60) continue;\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint T,N;\nint sx,sy;\n\nvoid solve(){\n    set<pair<int,int>> obs;\n    for(int i=0;i<N;i++){\n        int x,y;\n        cin >> x >> y;\n        obs.insert(make_pair(x,y));\n    }\n    cin >> sx >> sy;\n    obs.insert(make_pair(sx,sy));\n\n    using Node = tuple<int,int,int>;\n    using P = pair<int,int>;\n\n    map<P,int> vis;\n    queue<Node> que;\n    vis[P(sx,sy)] = 0;\n    que.push(Node(sx,sy,0));\n    while(!que.empty()){\n        int x,y,t;\n        tie(x,y,t) = que.front();\n        que.pop();\n        if(t == T) continue;\n\n        for(int dx=-1;dx<=1;dx++){\n            for(int dy=-1;dy<=1;dy++){\n                if(dx*dy==-1 or (dx==0 and dy==0)) continue;\n                int nx = x + dx;\n                int ny = y + dy;\n                if(abs(nx) > 30 or abs(ny) > 30) continue;\n                if(obs.count(make_pair(nx,ny))) continue;\n\n                if(vis.count(P(nx,ny)) and vis[P(nx,ny)] <= t+1) continue;\n                vis[P(nx,ny)] = t+1;\n                que.push(Node(nx,ny,t+1));\n            }\n        }\n    }\n    int cnt = 0;\n    for(auto p : vis){\n        cnt++;\n        //cout << p.first << endl;\n    }\n    cout << cnt << endl;\n}\n\nint main(){\n    while(1){\n        cin >> T >> N;\n        if(T==0 and N==0) break;\n        //cout << \"OK\" << endl;\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing P = pair<int, int>;\n\nconst int T = 60;\nconst int INF = 1e9;\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n  int t, n;\n  while (cin >> t >> n, t) {\n    vector<vector<int>> g(2 * T + 1, vector<int>(2 * T + 1, INF));\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      g[T + x][T + y] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    int ans = 0;\n    queue<P> q({{T + sx, T + sy}});\n    g[T + sx][T + sy] = 0;\n    while (!q.empty()) {\n      int x = q.front().first;\n      int y = q.front().second;\n      q.pop();\n      if (g[x][y] > t) continue;\n      ans++;\n      REP(i, 6) {\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if (g[tx][ty] == -1) continue;\n        if (g[tx][ty] <= g[x][y] + 1) continue;\n        g[tx][ty] = g[x][y] + 1;\n        q.push({tx, ty});\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n#include \"list\"\n#include \"climits\"\n\nusing namespace std;\n\n\nint main() {\n\t\n\tint dir_y[6] = { 1,1,0,-1,-1,0 };\n\tint dir_x[6] = { 0,1,1,0,-1,-1 };\n\tint N, K;\n\tlist<int>ret;\n\tcin >> N >> K;\n\twhile (N) {\n\t\tvector<vector<int>>v(100, vector<int>(100, INT_MAX));\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tint y, x;\n\t\t\tcin >> y >> x;\n\t\t\ty += 50;\n\t\t\tx += 50;\n\t\t\tv[y][x] = -1;\n\t\t}\n\t\tint sy, sx;\n\t\tcin >> sy >> sx;\n\t\tsy += 50;\n\t\tsx += 50;\n\t\tqueue<pair<int,int>>Q;\n\t\tQ.push({ sy,sx });\n\t\tv[sy][sx] = 0;\n\t\tint cnt = 0;\n\t\twhile (cnt<=N&&!Q.empty()) {\n\t\t\tint cy = Q.front().first;\n\t\t\tint cx = Q.front().second;\n\t\t\tcnt = max(cnt, v[cy][cx] + 1);\n\t\t\tQ.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint ny = cy + dir_y[i];\n\t\t\t\tint nx = cx + dir_x[i];\n\t\t\t\tif (v[ny][nx]>cnt) {\n\t\t\t\t\tv[ny][nx] = cnt;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (auto i : v) {\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j >= 0 && j <= N) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret.push_back(ans);\n\t\tcin >> N >> K;\n\t}\n\tfor (auto i : ret) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define MAXSIZE 10000000;\n\nbool comp(const pair<string,int> a, const pair<string,int> b) {\n  if (a.first != b.first)\n    return a.first < b.first; // 高い順に並べたいので演算子を逆に\n  else{\n      return a.second > b.second;\n  }\n}\n\nint Dx[6] = { 0, 0, 1, 1,-1,-1};\nint Dy[6] = { 1,-1, 1, 0, 0,-1};\n\n//priority_queue<long long int,vector<long long int>, greater<long long int>> PQ;\n//priority_queue<long long int> PQ1;\nint main(){\n\n    int t,n;\n    vector<int> ansList;\n\n    cin >>t>>n;\n\n    while(!(t == 0 && n == 0)){\n        int map[200][200] = {0};\n        int boolmap[200][200] = {0};\n        queue<pair<int,int> > BFSQ;\n        queue<int> Turn;\n        int ans = 0;\n\n        for(int i = 0;i<n;i++){\n            int x,y;\n            cin >>x>>y;\n            boolmap[x + 100][y + 100] = 1;\n        }\n\n        int sx,sy;\n        cin >>sx>>sy;\n        BFSQ.push(make_pair(sx+100,sy+100));\n        Turn.push(0);\n\n        while(!BFSQ.empty()){\n            pair<int,int> pos;\n            long int turnNum = Turn.front();\n            Turn.pop();\n            pos = BFSQ.front();\n            BFSQ.pop();\n\n            if(turnNum > t || map[pos.first][pos.second] == -1 || boolmap[pos.first][pos.second] == 1 )continue;\n            ans++;\n\n            for(int i = 0;i<6;i++){\n                /*if(pos.first + Dx[i] > 60 || pos.second + Dy[i] > 60 || pos.second + Dy[i] < 0 || pos.first + Dx[i] < 0 )continue;*/\n                /*if(boolmap[pos.first + Dx[i]][pos.second + Dy[i]] == 0){*/\n                    BFSQ.push(make_pair(pos.first + Dx[i],pos.second + Dy[i]));\n                    Turn.push(turnNum+1);\n                /*}*/\n            }\n            map[pos.first][pos.second] = -1;\n        }\n        ansList.push_back(ans);\n        cin >>t>>n;\n    }\n\n    for(int i = 0;i<(int)ansList.size();i++){\n        cout <<ansList[i]<<endl;\n    }\n    return 0;\n}\n\n/*Syakutori\nwhile(cin >>b && b)){\n      ll t = 1;\n      long long int ansS = 1,ansT=0;\n      long long int sum = 0;\n\n      for(ll s = 1;s < 50000000;s++){\n\n        while(t <  50000000 && sum+Rsum[t] < b){\n          sum += Rsum[t];\n          t++;\n        }\n        if(b == sum+Rsum[t]){\n          if(ansT - ansS < t-s){\n            ansS = s;\n            ansT = t;\n          }\n          cout <<ansS<<\" \"<<ansT-ansS + 1<<endl;\n          break;\n        }\n        if(t == s)++t;\n        else sum -= Rsum[s];\n        }\n    }\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\nconst int WMAX = 80, HMAX = 80;\n#define MAP(y, x) field[y + 40][x + 40]\nlli t, n;\nint field[HMAX][WMAX];\n\nvoid dfs(int y, int x, int turn) {\n  int nor = y * y + x * x;\n  if (nor > 900 || turn <= 0 || MAP(y, x) >= turn) return;\n  MAP(y, x) = turn;\n  REP(i, 6) {\n    dfs(y + dy[i], x + dx[i], turn - 1);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n\n  while (cin >> t >> n and t) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = 0;\n    }\n    REP(i, n) {\n      int y, x;\n      cin >> x >> y;\n      MAP(y, x) = INF;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    dfs(sy, sx, t + 1);\n    int sum = 0;\n    FOR(y, -32, 32) FOR(x, -32, 32) {\n      if (MAP(y, x) > 0 and MAP(y, x) != INF) sum ++;\n    }\n    cout << sum << endl;\n/*    FOR(y, -10, 10) {\n      REP(i, 10 - y) cout << ' ';\n      FOR(x, -10, 10) {\n        if (MAP(y, x) == INF) cout << 'x';\n        else if (MAP(y, x) == 0)   cout << '.';\n        else if (y == sy and x == sx) cout << 'S';\n        else cout << 'o';\n        cout << ' ';\n      }\n      cout << endl;\n    }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint depth;\nint d[70][70];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    memset(d, -1, sizeof(d));\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(!que.empty()){\n        P p = que.front(); que.pop();\n        if(d[p.first][p.second]==depth) continue;\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(d[nx][ny] != -1) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n   return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            d[x+30][y+30] = 0;\n        }\n        cin >> x >> y;\n        int res = bfs(x+30,y+30);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nll t, n, d[70][70];\nbool s[70][70];\n\n\nvoid bfs(ll x, ll y, ll k){\n    if(k == 0)return;\n    \n    if(d[x + 1][y] < k && !s[x + 1][y]){\n        d[x + 1][y] = k - 1;\n        bfs(x + 1, y, k - 1);\n    }\n    if(d[x - 1][y] < k && !s[x - 1][y]){\n        d[x - 1][y] = k - 1;\n        bfs(x - 1, y, k - 1);\n    }\n    if(d[x + 1][y + 1] < k && !s[x + 1][y + 1]){\n        d[x + 1][y + 1] = k - 1;\n        bfs(x + 1, y + 1, k - 1);\n    }\n    if(d[x - 1][y - 1] < k && !s[x - 1][y - 1]){\n        d[x - 1][y - 1] = k - 1;\n        bfs(x - 1, y - 1, k - 1);\n    }\n    if(d[x][y + 1] < k && !s[x][y + 1]){\n        d[x][y + 1] = k - 1;\n        bfs(x, y + 1, k - 1);\n    }\n    if(d[x][y - 1] < k && !s[x][y - 1]){\n        d[x][y - 1] = k - 1;\n        bfs(x, y - 1, k - 1);\n    }\n}\n\nint main() {\n    ll sx, sy;\n    \n    cin >> t >> n;\n    \n    while(t != 0 || n != 0){\n        REP(i, 70){\n            REP(j, 70){\n                d[i][j] = -INF;\n                s[i][j] = false;\n            }\n        }\n        \n        REP(i, n){\n            ll x, y;\n            cin >> x >> y;\n            s[x + 35][y + 35] = true;\n        }\n        \n        cin >> sx >> sy;\n        \n        d[sx + 35][sy + 35] = t;\n        bfs(sx + 35, sy + 35, t);\n        \n        ll ans = 0;\n        REP(i, 70){\n            REP(j, 70){\n                if(d[i][j] != -INF)ans++;\n            }\n        }\n        \n        cout << ans << endl;\n        \n        cin >> t >> n;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dx[6] = { 1,0,-1,-1,0,1 };\nint dy[6] = { 0,-1,-1,0,1,1 };\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tll t, n; scanf(\"%lld %lld\", &t, &n); if (t == 0 && n == 0) break;\n\t\tvector<ll> x(n), y(n);\n\t\tset<pair<ll, ll>> sp;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lld %lld\", &x[i], &y[i]);\n\t\t\tsp.emplace(x[i], y[i]);\n\t\t}\n\t\tll sx, sy; scanf(\"%lld %lld\", &sx, &sy);\n\t\tmap<ll, map<ll, ll>> d;\n\t\td[sx][sy] = 0;\n\t\tqueue<pair<int, int>> q;\n\t\tq.emplace(sx, sy);\n\t\tll res = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint cx, cy; tie(cx, cy) = q.front();\n\t\t\tq.pop();\n\t\t\tif (d[cx][cy] <= t) res++;\n\t\t\telse continue;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (sp.find(make_pair(nx,ny)) != sp.end()) continue;\n\t\t\t\tif (d[nx][ny] != 0 || (nx == sx && ny == sy)) continue;\n\t\t\t\td[nx][ny] = d[cx][cy] + 1;\n\t\t\t\tq.emplace(nx, ny);\n\t\t\t}\n\t\t}\n\t\tcout << res << \"\\n\";\n\t}\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, k, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k;\n\t\tif (n == 0 && k == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tx[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (x[j][k] == 0 && y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= t) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {1,0,-1,-1,0,1};\n\nint t, n, sx, sy, ans;\nbool visited[61][61];  //(a, b) -> visited[a+30][b+30]\nbool obj[61][61];\n\nint main() {\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0) break;\n    REP(i,0,61)REP(j,0,61) obj[i][j] = false;\n    REP(i, 0, n){\n      int x, y;\n      cin>>x>>y;\n      obj[y+30][x+30] = true;\n    }\n    cin>>sx>>sy;\n\n    REP(i,0,61)REP(j,0,61) visited[i][j] = false;\n    ans = 0;\n\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n\n    qx.push(sx);\n    qy.push(sy);\n    qt.push(0);\n\n    while(!qx.empty()){\n      int x = qx.front();\n      int y = qy.front();\n      int turn = qt.front();\n      qx.pop(); qy.pop(); qt.pop();\n\n      if(turn > t || visited[y+30][x+30])continue;\n      visited[y+30][x+30] = true;\n      ans++;\n\n      REP(k,0,6){\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if(!CH(ny+30, 0, 61) || !CH(nx+30, 0, 61)) continue;\n        if(obj[ny+30][nx+30]) continue;\n        qx.push(nx); qy.push(ny); qt.push(turn+1);\n      }\n    }\n\n    cout<<ans<<endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 50;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[100][100] = {};\nbool u[100][100] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        u[y+50][x+50]=true;\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+50][nx+50]==false && u[ny+50][nx+50]==false){\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,100)rep(x,100){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+50][x+50] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,100)rep(x,100)if(u[y][x])a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;++i)\n#define M(a,b) make_pair(a,b)\n#define f first\n#define s second\nusing namespace std;\nint dx[]={0,0,1,1,-1,-1,},dy[]={1,-1,1,0,-1,0};\nbool v[200][200];\nint a,b,t,n;\nint main(){\n  while(cin>>t>>n,t){\n    r(i,200)r(j,200)v[i][j]=0;\n    while(n--){\n      scanf(\"%d%d\",&a,&b);\n      v[a+100][b+100]=1;\n    }cin>>a>>b;int c=0;\n    queue<pair<pair<int,int>,int> >q;\n    q.push(M(M(b+100,a+100),0));\n    v[b+100][a+100]=1;\n    while(!q.empty()){\n      pair<pair<int,int>,int > p=q.front();q.pop();\n      if(p.s==t+2)continue;\n      c++;\n      r(i,6)if(!v[p.f.f+dy[i]][p.f.s+dx[i]]&&p.s+1<=t){\n        q.push(M(M(p.f.f+dy[i],p.f.s+dx[i]),p.s+1));\n        v[p.f.f+dy[i]][p.f.s+dx[i]]=1;\n      }\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;++i)\n#define M(a,b) make_pair(a,b)\n#define f first\n#define s second\nusing namespace std;\nint dx[]={0,0,1,1,-1,-1,},dy[]={1,-1,1,0,-1,0};\nbool v[200][200];\nint a,b,t,n;\nint main(){\n  while(cin>>t>>n,t){\n    r(i,200)r(j,200)v[i][j]=0;\n    while(n--){\n      scanf(\"%d%d\",&b,&a);\n      v[a+100][b+100]=1;\n    }cin>>a>>b;int c=0;\n    queue<pair<pair<int,int>,int> >q;\n    q.push(M(M(b+100,a+100),0));\n    v[b+100][a+100]=1;\n    while(!q.empty()){\n      pair<pair<int,int>,int > p=q.front();q.pop();\n      if(p.s==t+2)continue;\n      c++;\n      r(i,6)if(!v[p.f.f+dy[i]][p.f.s+dx[i]]&&p.s+1<=t){\n        q.push(M(M(p.f.f+dy[i],p.f.s+dx[i]),p.s+1));\n        v[p.f.f+dy[i]][p.f.s+dx[i]]=1;\n      }\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\ntypedef pair<ll,mp> mmp;\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {1,0,-1,-1,0,1};\n\nint main(){\n while(1){\n  ll t,n;\n  cin>>t>>n;\n  set<mp> go,stop;\n  if(t==0)break;\n  for(ll i=0;i<n;i++){\n   mp d;\n   cin>>d.first>>d.second;\n   stop.insert( d );\n  }\n  mp s;\n  cin>>s.first>>s.second;\n  queue<mmp> q;\n  q.push( mmp( t , s ) );\n  while( !q.empty() ){\n   mmp now = q.front();\n   q.pop();\n   ll cnt = now.first;\n   mp z = now.second;\n   ll x = z.first;\n   ll y = z.second;\n   if( go.find(z) != go.end() ) continue;\n   go.insert( z );\n   if( cnt == 0 ) continue;\n   \n   for(ll i=0;i<6;i++){\n    ll nx = x + dx[i];\n    ll ny = y + dy[i];\n    mp nz = mp(nx,ny);\n    if( go.find( nz ) != go.end() ) continue;\n    if( stop.find(nz ) != stop.end() ) continue;\n    q.push( mmp(cnt-1,nz) );\n   }\n\n  }\n\n  cout<<go.size()<<endl;\n }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int INF=INT_MAX,MOD=1e9+7;\n\nint main(){\n\tint turn,n;\n\twhile(cin>>turn>>n&&turn){\n\t\t//初期化\n\t\tqueue<pair<int,int>> q;\n\t\tint d[70][70]; rep(i,70)rep(j,70) d[i][j]=INF;\n\t\trep(i,n){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\td[y+30][x+30]=-1;\n\t\t\t// cout<<y+30<<\" \"<<x+30<<endl;\n\t\t}\n\t\tint sx,sy; cin>>sx>>sy;\n\t\tsy+=30; sx+=30;\n\t\td[sy][sx]=0;\n\t\tq.push(make_pair(sy,sx));\n\t    int dx[6]={0,1,0,-1,1,-1};\n\t    int dy[6]={1,0,-1,0,1,-1};\n\n\t    //実行\n\t\tint cnt=1;\n\t    while(q.size()){\n\t        pair<int,int> p=q.front(); //キューの先頭を取り出す\n\t\t\t// cout<<p.first<<\" \"<<p.second<<endl;\n\t        q.pop(); //取り出したら削除\n\t        int prev=d[p.first][p.second]; //一手前の手数prev\n\t\t\tif(prev==turn) continue;\n\t        rep(i,6){ //4方向探索\n\t            int cy=p.first+dy[i];\n\t            int cx=p.second+dx[i];\n\t            if(0<=cy&&cy<=60&&0<=cx&&cx<=60){ //範囲外取得キケン\n\t                if(d[cy][cx]==INF){ //通行可能かつ未到達\n\t                    d[cy][cx]=prev+1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t// cout<<cy<<\" \"<<cx<<endl;\n\t                    q.push(make_pair(cy,cx));\n\t                }\n\t            }\n\t        }\n\t    }\n\t    cout<<cnt<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[62][62];\n//complex<int> p;\t\t//テ」ツ?づ」ツつ古」ツ??、ツスツソテ」ツつ湘」ツ?ェテ」ツ??\n\nint dx[] = {0,1,0,-1,1,-1};\nint dy[] = {1,0,-1,0,1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n//\tcout<< x-30-2<< \" \"<< y-30-2<< \" \"<< t<< \" \"<< ans<< endl;\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = 1;\n\tif(hoge[x][y] > t) return;\t//\tif(t<=0) return;\tテ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツつ?\n\thoge[x][y] = t+1;\n\tfor(int i=0;i<6;i++){\n\t\tif(hoge[x+dx[i]][y+dy[i]] != -1){\t\t//テ」ツδ淌」ツつケ : hoge[][]==1テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ッテ・ツ按・テ」ツ?ォテ・ツ閉湘ゥツ。ツ古」ツ?ェテ」ツ??\n\t\t\tf(x+dx[i],y+dy[i],t-1,ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<62;i++){\n\t\t\tfor(int j=0;j<62;j++){\n\t\t\t\thoge[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 30;\n\t\ty += 30;\n\t\t\n\t\tint ans = 0;\n\t\tf(x,y,t,ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <stack>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\nint g[100][100];\nint used[100][100];\nint ans=0;\n\nvoid dfs(int i, int j, int times){\n    if(times<0 or used[i][j]>times or g[i][j]==1) return;\n    if(used[i][j]==-1) ans++;\n    used[i][j]=times;\n    dfs(i+1, j,times-1);\n    dfs(i-1, j,times-1);\n    dfs(i, j+1,times-1);\n    dfs(i, j-1,times-1);\n    dfs(i+1, j+1,times-1);\n    dfs(i-1, j-1,times-1);\n}\n\nint main(){\n    for (;;) {\n        int t,n;\n        cin >> t >> n;\n        if(!t and !n)break;\n        memset(g, 0, sizeof(g));\n        memset(used, -1, sizeof(used));\n        ans = 0;\n        for (int i=0; i<n; i++) {\n            int x,y;\n            cin >> x >> y;\n            g[x+50][y+50]=1;\n        }\n        int xx,yy;\n        cin >> xx >> yy;\n        dfs(xx+50,yy+50,t);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint b[200][200], d[200][200], t, n, sx, sy,\n    dx[] = {-1, -1, 0, 0, 1, 1}, dy[] = {0, -1, 1, -1, 0, 1};\n\nsigned main(void) {\n  while (true) {\n    cin >> t >> n;\n    if(!t && !n) break;\n    REP(i, 200) REP(j, 200) {\n      b[i][j] = 0;\n      d[i][j] = INF;\n    }\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      b[y + 100][x + 100] = -1;\n    }\n    cin >> sx >> sy;\n\n    queue<VI> que;\n    que.push({sx, sy, 0});\n    d[sy + 100][sx + 100] = 0;\n\n    while (que.size()) {\n      VI p = que.front();\n      que.pop();\n      if (p[2] == t)\n        continue;\n      REP(i, 6) {\n        int nx = p[0] + dx[i], ny = p[1] + dy[i];\n        if (abs(nx) <= 100 && abs(ny) <= 100 && !b[ny + 100][nx + 100] &&\n            d[ny + 100][nx + 100] == INF) {\n          que.push({nx, ny, p[2] + 1});\n          d[ny + 100][nx + 100] = d[p[1] + 100][p[0] + 100] + 1;\n        }\n      }\n    }\n\n    int ret = 0;\n    REP(i, 200) REP(j, 200) {\n      if (d[i][j] <= t)\n        ret++;\n    }\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#define range(x,y,h1,h2) x >= 0 && x < h1 && y >= 0 && y < h2\n\nusing namespace std;\n\nint main(void){\n\tint t, n, i, j, field[151][151], ix, iy, count;\n\tconst int standard = 75, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<int> x, y;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t == 0 && n == 0)\n\t\t\tbreak;\n\t\tmemset(field,-1,sizeof(field));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&ix,&iy);\n\t\t\tfield[iy + standard][ix + standard] = 0;\n\t\t}\n\t\tscanf(\"%d%d\",&ix,&iy);\n\t\tx.push(standard + ix),y.push(standard + iy);\n\t\tfield[standard + iy][standard + ix] = 0;\n\t\twhile(x.size()){\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif( field[y.front() + dy[i]][x.front() + dx[i]] == -1 && field[y.front()][x.front()] < t){\n\t\t\t\t\tx.push(x.front() + dx[i]),y.push(y.front() + dy[i]);\n\t\t\t\t\tfield[y.front() + dy[i]][x.front() + dx[i]] = field[y.front()][x.front()] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.pop(), y.pop();\n\t\t}\n\t\tcount = 1;\n\t\tfor(i = 0;i < 151;i++){\n\t\t\tfor(j = 0;j < 151;j++){\n\t\t\t\tif(field[i][j] > 0){\n\t\t\t\t\tcount++;\n\t\t\t\t\tprintf(\"(%d,%d)\\n\",j - standard,i - standard);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 30;\n\nint dx[6] = {-1, 0, 1, 1, 0, -1};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\tint t, n;\n\tint field[90][90];\n\twhile(cin >> t >> n, t+n){\n\t\tt += 2;\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 90)rep(j, 90) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tfield[sx][sy] = 1;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(sx, sy));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y]+1 == t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(abs(nx-d) <= 30 && abs(ny-d) <= 30 && field[nx][ny] != -1 && (field[x][y]+1 < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\trep(i, 90)rep(j, 90) if(0 < field[i][j]) count++;\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;++i)\n#define M(a,b) make_pair(a,b)\n#define f first\n#define s second\nusing namespace std;\nint dx[]={0,0,1,1,-1,-1,},dy[]={1,-1,1,0,-1,0};\nbool v[200][200];\nint a,b,t,n;\nint main(){\n  while(cin>>t>>n,t){\n    r(i,200)r(j,200)v[i][j]=0;\n    while(n--){\n      scanf(\"%d%d\",&a,&b);\n      v[a+100][b+100]=1;\n    }cin>>a>>b;int c=0;\n    queue<pair<pair<int,int>,int> >q;\n    q.push(M(M(b+100,a+100),0));\n    v[b+100][a+100]=1;\n    while(!q.empty()){\n      pair<pair<int,int>,int > p=q.front();q.pop();\n      if(p.s==t+2)continue;\n      c++;\n      r(i,6)if(!v[p.f.f+dy[i]][p.f.s+dx[i]]&&p.s+1<=t){\n        q.push(M(M(p.f.f+dy[i],p.f.s+dx[i]),p.s+1));\n        v[p.f.f+dy[i]][p.f.s+dx[i]]=1;\n      }\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint mp[500][500];\nstruct ima{\n  int x,y;\n};\nint n,tu;\nqueue <ima> Q;\nint dis[500][500];\n\nvoid reset() {\n\n  for(int i=0;i<300;i++)\n    for(int j=0;j<300;j++) {\n      mp[i][j] = 0;\n      dis[i][j] = 100000;\n    }\n}\n\n\nint visit() {\n  ima t;\n  int dx[6] = {1,1,0,-1,-1,0};\n  int dy[6] = {1,0,-1,-1,0,1};\n  int count =0;\n\n  while(!Q.empty()){\n\n    t = Q.front();\n    Q.pop();\n    count++;\n    if(dis[t.y][t.x]+1 >tu) continue;\n    for(int i=0;i<6;i++) {\n      if(t.y+dy[i] >=0 && t.x+dx[i] >=0) \n      if(mp[t.y+dy[i]][t.x+dx[i]] == 0 && dis[t.y+dy[i]][t.x+dx[i]] > dis[t.y][t.x]+1){\n\tQ.push((ima){t.x+dx[i],t.y+dy[i]});\n\tdis[t.y+dy[i]][t.x+dx[i]] = dis[t.y][t.x]+1;\n      }\n    }\n  }\n    return count;\n}\n\n\nint main() {\n\n  while(1) {\n  cin >> tu >> n;\n  if(tu == 0 && n == 0) break;\n  \n  int a,b;\n  reset();\n  for(int i=0;i<n;i++) {\n    cin >> a >>b;\n\n    mp[100+b][100+a] =1;\n\n  }\n  \n  int tx,ty;\n  cin >> tx >>ty;\n\n  Q.push((ima){100+tx,100+ty});\n  dis[100+ty][100+tx] = 0;\n  \n  int ans = visit();\n\n  cout << ans <<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n\nusing namespace std;\n \n#define NMAX 50\n\ntypedef map<int,bool>::value_type VT;\n\nstruct data{\n\tint x,y,turn;\n};\n\nint main(void){\n\t\n\tint t,n;\n\tint x,y;\n\tmap<int,bool> road,ok;\n\tstack<data> no;\n\tdata tm,da;\n\tint dx[]={1,1,0,-1,-1,0};\n\tint dy[]={0,1,1,0,-1,-1};\n\tint cnt;\n\n\tfor(int i=-31;i<=31;i++){\n\t\tfor(int j=-31;j<=31;j++){\n\t\troad.insert(VT(i+j*100,true));\n\t\tok.insert(VT(i+j*100,true));\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=-30;i<=30;i++){\n\t\t\tfor(int j=-30;j<=30;j++){\n\t\t\t\troad[i+j*100]=true;\n\t\t\t\tok[i+j*100]=true;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-31;i<=31;i++){\n\t\t\troad[-31+i*100]=false;\n\t\t\troad[31+i*100]=false;\n\t\t\troad[i+31*100]=false;\n\t\t\troad[i-31*100]=false;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\troad[y+x*100]=false;\n\t\t}\n\t\tcin>>x>>y;\n\t\ttm.x=x,tm.y=y,tm.turn=0;\n\t\tno.push(tm);\n\t\troad[y+x*100]=false;\n\t\tcnt=1;\n\t\twhile(!no.empty()){\n\t\t\ttm=no.top();\n\t\t\tno.pop();\n\t\t\tif(tm.turn==t){\n\t\t\t\tif(ok[tm.y+tm.x*100]==true){\n\t\t\t\t\tok[tm.y+tm.x*100]=false;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n\t\t\t\t\tda.x=tm.x+dx[i];\n\t\t\t\t\tda.y=tm.y+dy[i];\n\t\t\t\t\tda.turn=tm.turn+1;\n\t\t\t\t\tno.push(da);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    int dx[] = { 1, 1, 0, -1, -1, 0 };\n    int dy[] = { 1, 0, -1, -1, 0, 1 };\n\n    int t, n;\n    while (cin >> t >> n, t)\n    {\n        set<pint> obs;\n        while (n--)\n        {\n            int x, y;\n            cin >> x >> y;\n            obs.insert(pint(x, y));\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n\n        map<pint, int> d;\n        queue<pint> q;\n        d[pint(sx, sy)] = 0;\n        q.push(pint(sx, sy));\n        while (!q.empty())\n        {\n            pint cur = q.front();\n            q.pop();\n\n            int c = d[cur];\n            rep(i, 6)\n            {\n                pint next = pint(cur.first + dx[i], cur.second + dy[i]);\n                if (!obs.count(next) && !d.count(next)&& c < t)\n                {\n                    d[next] = c + 1;\n                    q.push(next);\n                }\n            }\n        }\n        cout << d.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nint t,n;\nint stx,sty;\n\ntypedef pair<int,int> pii;\nset<pii> block;\n\n\nbool input(){\n\tcin>>t>>n;\n\tif(t==0 && n==0)return false;\n\t\n\tblock.clear();\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tblock.insert(pii(a,b));\n\t}\n\t\n\tcin>>stx>>sty;\n\treturn true;\n}\n\nclass P{\n\tpublic:\n\tint x,y,t;\n\tP(int x,int y,int t):x(x),y(y),t(t){}\n};\n\nvoid solve(){\n\tset<pii> visit;\n\tqueue<P> que;\n\t\n\tque.push(P(stx,sty,0));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP u = que.front();\n\t\tque.pop();\n\t\t\n\t\tif(block.find(pii(u.x,u.y)) != block.end())continue;\n\t\t\n\t\tif(visit.find(pii(u.x,u.y)) != visit.end())continue;\n\t\t\n\t\tvisit.insert(pii(u.x,u.y));\n\t\t\n\t\tif(u.t==t)continue;\n\t\t\n\t\t\n\t\tint dx[]={1,1,0,-1,-1,0};\n\t\tint dy[]={0,1,1,0,-1,-1};\n\t\t\n\t\trep(i,6){\n\t\t\tque.push(P(u.x+dx[i], u.y+dy[i], u.t+1));\n\t\t}\n\t}\n\t\n\tcout<<visit.size()<<endl;\n}\n\nint main(){\n\twhile(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define N 100\n#define G 50\n#define KABE -1\n#define NON  0\n\nint map[N][N];\n\nint ans;\nvoid dfs(int x, int y, int t ){\n  if( t==0 )\n    return;\n  if( map[x][y] == KABE )\n    return;\n\n  if( map[x][y] >= t )\n    return;\n\n  if( map[x][y] == NON )\n    ans++;\n  map[x][y] = t;\n\n\n  t--;\n  int dx[] = {1,1,0,-1,-1, 0};\n  int dy[] = {0,1,1, 0,-1,-1};\n  for( int d=0;d<6;d++ )\n    dfs(x+dx[d], y+dy[d], t );\n}\n\nint main(){\nint t,n;\n  while( cin>>t>>n && (t|n) ){\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\tmap[i][j] = NON;\n\n    int y,x;\n    while( n-- ){\n      cin >> x >> y;\n      map[x+G][y+G] = KABE;\n    }\n    cin >> x >> y;\n\n    x+=G; y+=G;\n    ans = 0;\n    dfs(x, y, t+1 );\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {1,0,-1,-1,0,1};\n\nint t, n, sx, sy, ans;\nbool visited[61][61][31];  //(a, b) -> visited[a+30][b+30]\nbool obj[61][61];\n\nvoid dfs(int y, int x, int turn){\n  if(visited[y+30][x+30][turn]) return;\n  if(turn > t) return;\n\n  bool flag = true;\n  REP(i,0,31){\n    if(visited[y+30][x+30][i]) flag = false;\n  }\n  if(flag) ans++;\n\n  visited[y+30][x+30][turn] = true;\n\n  REP(k,0,6){\n    int nx = x + dx[k], ny = y + dy[k];\n    if(!CH(nx+30, 0, 61) || !CH(ny+30, 0, 61)) continue;\n    if(obj[ny+30][nx+30]) continue;\n    dfs(ny, nx, turn + 1);\n  }\n  return;\n}\n\nint main() {\n\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0) break;\n    REP(i,0,61)REP(j,0,61) obj[i][j] = false;\n    REP(i, 0, n){\n      int x, y;\n      cin>>x>>y;\n      obj[y+30][x+30] = true;\n    }\n    cin>>sx>>sy;\n\n    REP(i,0,61)REP(j,0,61)REP(k,0,31) visited[i][j][k] = false;\n    ans = 0;\n\n    dfs(sy, sx, 0);\n\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nbool isWall[300][300];\nint isVisited[300][300];\n\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {0, 1, 1, 0, -1, -1};\n\nint solve(int cx, int cy, int ct){\n    int ret = 0;\n\n    if(isVisited[cx][cy] >= ct || ct == -1 || isWall[cx][cy]){\n        return 0;\n    }\n\n    if(isVisited[cx][cy] == -1){\n        ret++;\n    }\n    isVisited[cx][cy] = ct;\n\n    for(int i=0;i<6;i++){\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n        ret += solve(nx, ny, ct-1);\n    }\n\n    return ret;\n}\n\nint main(){\n    while(true){\n        int t, n;\n        int sx, sy;\n        cin >> t >> n;\n        if(t == 0 && n == 0){\n            break;\n        }\n\n        // init\n        for(int i=0;i<300;i++){\n            for(int j=0;j<300;j++){\n                isWall[i][j] = false;\n                isVisited[i][j] = -1;\n            }\n        }\n\n        // input\n        for(int i=0;i<n;i++){\n            int x, y;\n            cin >> x >> y;\n            isWall[x+100][y+100] = true;\n        }\n        cin >> sx >> sy;\n\n        // output\n        cout << solve(100+sx, 100+sy, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef std::array<bool, 100> Line;\ntypedef std::array<Line, 100> Table;\n\nTable table; // [X][Y]\nstd::array< std::array<int, 100>, 100> standed; // [X][Y]\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + 50;\n}\n\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"sample.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tfor_each(table.begin(), table.end(), [](Line & line) {\n\t\t\tline.fill(false);\n\t\t});\n\t\tfor_each(standed.begin(), standed.end(), [](std::array<int, 100> & line) {\n\t\t\tline.fill(-1);\n\t\t});\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\nusing namespace std;\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nbool state[100][100];\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[nx][ny] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[nx][ny]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[nx][ny] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[nx + dx[i]][ny + dy[i]]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\t\tfor (int i = 0; i < 100; ++i){\n\t\t\tfor (int j = 0; j < 100; ++j){\n\t\t\t\tstate[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[x+50][y+50] = true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tcout << f(sx+50, sy+50,0) << endl;\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint main(){\n\tint t,N;\n\tint dx[6]={1,1,0,-1,-1,0};\n\tint dy[6]={0,1,1,0,-1,-1};\n\twhile(cin>>t>>N && (t!=0||N!=0)){\n\t\tbool obs[121][121]={false};\n\t\tint visited[121][121]={0};\n\t\tint tx,ty,ans=0;\n\t\tqueue<pair<int,int>> q;\n\t\tREP(i,0,N){\n\t\t\tcin>>tx>>ty;\n\t\t\tobs[ty+60][tx+60]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tq.push({sx+60,sy+60});\n\t\tvisited[sy+60][sx+60]=1;\n\t\twhile(!q.empty()){\n\t\t\tint nowx=q.front().first,nowy=q.front().second;\n\t\t\tq.pop();\n\t\t\tREP(k,0,6){\n\t\t\t\tint nextx=nowx+dx[k],nexty=nowy+dy[k];\n\t\t\t\tif(obs[nexty][nextx]||visited[nexty][nextx]!=0) continue;\n\t\t\t\tvisited[nexty][nextx]=visited[nowy][nowx]+1;\n\t\t\t\tif(visited[nexty][nextx]<=t)\t\tq.push({nextx,nexty});\n\t\t\t}\n\t\t}\n\t\tREP(i,0,121)\tREP(j,0,121)\tif(visited[i][j]!=0)\tans++;\n\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint t, n, sx, sy;\nint field[100][100];\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid solve(){\n\tfield[sy][sx] = 0;\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\t//cout << \"!\" << p.first - 50 << \" \" << p.second - 50 << endl;\n\n\t\tREP(i, 6){\n\t\t\tint ny = p.first + dy[i], nx = p.second + dx[i];\n\t\t\tif (ny >= 20 && ny <= 80 && nx >= 20 && nx <= 80){\n\t\t\t\tif (field[p.first][p.second] >= 0 && field[p.first][p.second] < t){\n\t\t\t\t\tif (field[ny][nx] == INF){\n\t\t\t\t\t\t//cout << ny - 50 << \" \" << nx - 50 << endl;\n\t\t\t\t\t\tfield[ny][nx] = field[p.first][p.second] + 1;\n\t\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nint main(){\n\twhile (cin >> t >> n&&t + n){\n\t\tint ans = 0;\n\t\tREP(i, 100)REP(j, 100)field[i][j] = INF;\n\t\tREP(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 50;\n\t\t\ty += 50;\n\t\t\tfield[y][x] = -1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\t\tsolve();\n\t\tREP(i, 100){\n\t\t\tREP(j, 100){\n\t\t\t\tif (field[i][j] >= 0 && field[i][j] <= t){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nbool u[70][70] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        u[y+35][x+35]=true;\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]==false){\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x])a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nstruct Calculator {\n  bool operator() (int x) {\n    return x > 0;\n  }\n};\n\nusing namespace std;\n\nvoid move(int m[61][61], int x, int y, int t) {\n  x += 30, y += 30;\n  if (x + 1 <= 60 && m[x + 1][y] == 0)\n    m[x + 1][y] = t;\n  if (x + 1 <= 60 && y + 1 <= 60 && m[x + 1][y + 1] == 0)\n    m[x + 1][y + 1] = t;\n  if (y + 1 <= 60 && m[x][y + 1] == 0)\n    m[x][y + 1] = t;\n  if (x - 1 >= 0 && m[x - 1][y] == 0)\n    m[x - 1][y] = t;\n  if (x - 1 >= 0 && y - 1 >= 0 && m[x - 1][y - 1] == 0)\n    m[x - 1][y - 1] = t;\n  if (y - 1 >= 0 && m[x][y - 1] == 0)\n    m[x][y - 1] = t;\n}\n\nint main(int argc, char *argv[]) {\n  int masu[61][61];\n  int t, n, x, y;\n  struct Calculator calc;\n  while (true) {\n    cin >> t >> n;\n    if (t == 0 && n == 0)\n      break;\n    else\n      memset(masu, 0, sizeof(int) * 61 * 61);\n    for (int i = 0; i < n; i++) {\n      cin >> x >> y;\n      masu[30 + x][30 + y] = -1;\n    }\n\n    cin >> x >> y;\n    masu[30 + x][30 + y] = 1;\n    move(masu, x, y, 1);\n    for (int i = 2; i <= t; i++)\n      for (int j = 0; j < 61; j++)\n        for (int k = 0; k < 61; k++)\n          if (masu[j][k] == i - 1)\n            move(masu, j - 30, k - 30, i);\n\n    cout << count_if(masu[0], masu[61], calc) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<utility>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nbool check[62][62];\nbool jama_grid[62][62];\n\nvoid solve(int t, int n) {\n    int ans = 0, origin_x, origin_y, x, y;\n    for(int i = 0; i < 62; i++){\n        for(int j = 0; j <62; j++){\n            check[i][j] = false;\n            jama_grid[i][j] = false;\n        }\n    }\n    for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            jama_grid[y+30][x+30] = true;\n    }\n    cin >> origin_x >> origin_y;\n\n    // BFSの処理\n    queue<PP> Q;\n    PP start = mp(mp(origin_y + 30, origin_x + 30), t);\n    Q.push(start);\n    check[origin_y + 30][origin_x + 30] = true;\n\n    while (!Q.empty()) {\n        PP now = Q.front();\n        Q.pop();\n        int dx[6] = {-1, 0, 1, 0, -1, 1}, dy[6] = {0, -1, 0, 1, -1, 1};\n        for (int i = 0; i < 6; i++) {\n            int nx = now.first.second + dy[i], ny = now.first.first + dx[i];\n            if (nx >= 0 && nx <= 60 && ny >= 0 && ny <= 60 && now.second > 0 && !jama_grid[ny][nx] && !check[ny][nx]) {\n                check[ny][nx] = true;\n                Q.push(mp(mp(ny, nx), now.second - 1));\n                // cout << nx << \" \" << ny << \" \" << \"count : \" << now.second << endl;\n            }\n        }\n    }\n\n    for (int i = 0; i < 62; i++) for (int j = 0; j < 62; j++) {\n        if (check[i][j]) ans++;\n    }\n\n    cout << ans << endl;\n    return;\n}\n\nint main(){\n    int t, n;\n    \n    while(1){\n        cin>>t>>n;\n        if(n == 0 && t == 0)break;\n        else solve(t, n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint t, n;\n\tint DX[6] = { 0,1,1,0,-1,-1 }, DY[6] = { 1,1,0,-1,-1,0 };\n\twhile (cin >> t >> n&&t)\n\t{\n\t\tint z = 50;\n\t\tint a[100][100];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ta[x+z][y+z] = -2;\n\t\t}\n\t\tpii st;\n\t\tcin >> st.first >> st.second;\n\t\tst.first += z;\n\t\tst.second += z;\n\t\ta[st.first][st.second] = t;\n\t\tqueue<pii> que;\n\t\tque.push(st);\n\t\tint ans = 1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front();\n\t\t\tque.pop();\n\t\t\tif (a[now.first][now.second] == 0)continue;\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += DX[i];\n\t\t\t\tnext.second += DY[i];\n\t\t\t\tif (a[next.first][next.second] != -2&&a[next.first][next.second]<a[now.first][now.second]-1)\n\t\t\t\t{\n\t\t\t\t\ta[next.first][next.second] = a[now.first][now.second] - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nint dx[6] = {-1, -1, 0, 1, 1, 0};\nint dy[6] = {0, -1, -1, 0, 1, 1};\nbool issearched[70][70];\n\nint t, n;\nint islandmap[70][70];\nint tesu[70][70];\nint start_x, start_y;\n\nvoid search(int a, int b);\n\nint main()\n{\n    while(1){\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 70; i++){\n            for(int j = 0; j < 70; j++){\n                islandmap[i][j] = 0;\n                issearched[i][j] = false;\n                tesu[i][j] = 0;\n            }\n        }\n        int obstacle_x, obstacle_y;\n        for(int i = 0; i < n; i++){\n            cin >> obstacle_x >> obstacle_y;\n            islandmap[obstacle_x + 35][obstacle_y + 35] = -1;\n        }\n        cin >> start_x >> start_y;\n        issearched[start_x + 35][start_y + 35] = true;\n        search(start_x + 35, start_y + 35);\n        int ans = 1;\n        for(int i = start_x + 35 - t; i < start_x + 36 + t; i++){\n            for(int j = start_y + 35 - t; j < start_y + 36 + t; j++){\n                if(tesu[i][j] < t + 1 && tesu[i][j] > 0) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nvoid search(int a, int b)\n{\n    int x, y, nx, ny;\n    queue<pair < int, int> > qu;\n    qu.push(make_pair<int, int>(a, b));\n    while(!qu.empty()){\n        x = (qu.front()).first;\n        y = (qu.front()).second;\n        for(int i = 0; i < 6; i++){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if(nx < start_x + 35 - t|| ny < start_y + 35 - t|| nx > start_x + 36 + t|| ny > start_y + 36 + t) continue;\n            if(islandmap[nx][ny] != -1 && issearched[nx][ny] == false){\n                tesu[nx][ny] = tesu[x][y] + 1;\n                qu.push(make_pair<int, int>(nx, ny));\n                issearched[nx][ny] = true;\n            }\n        }\n        qu.pop();\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint main() {\n\tfor (int t, n; cin >> t >> n, (t | n) != 0; ) {\n\t\tint m[300][300];\n\t\tmemset(m, 0, sizeof(m));\n\t\trep(i, n) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tm[y + 100][x + 100] = -1;\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue<pair<int, pii> > q;\n\t\tq.push(mp(1, mp(sx + 100, sy + 100)));\n\t\tint ans = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint turn = q.front().fst;\n\t\t\tint x = q.front().snd.fst;\n\t\t\tint y = q.front().snd.snd;\n\t\t\tq.pop();\n\t\t\tif ( turn - 1 > t) continue;\n\t\t\tif (m[y][x] != 0) continue;\n\t\t\tans++;\n\t\t\tm[y][x] = turn;\n\t\t\t\n\t\t\tint dx[] = {0, 1, -1, 1, -1, 0};\n\t\t\tint dy[] = {1, 1, 0, 0, -1, -1};\n\t\t\trep(i, 6) {\n\t\t\t\tint tx = x + dx[i];\n\t\t\t\tint ty = y + dy[i];\n\t\t\t\tq.push(mp(turn + 1, mp(tx, ty)));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\nstruct Node\n{\n\tint x, y, turn;\n};\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<bool, 121>, 121> field;\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tfield = { {0} };\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 60][x + 60] = true;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 60][startX + 60] = true;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX+60, startY+60, 0 });\n\t\t\tint dx[] = {1, 0, -1, -1, 0, 1};\n\t\t\tint dy[] = {0, -1, -1, 0, 1, 1};\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 120 || next.y < 0 || next.y > 120) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = true;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (next.turn >= t) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[1500][1500];\nbool used[1500][1500];\nbool come[1500][1500];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nconst int mar=700;\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<1500;i++)for(int j=0;j<1500;j++)ta[i][j]=0,used[i][j]=0,come[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=mar,ty+=mar;\n\tta[ty][tx]=1;\n\t}\n\tint nx,ny;\n\tcin>>nx>>ny;\n\tused[ny+mar][nx+mar]=1;\n\tmasu start;\n\tstart.x=nx+mar,start.y=ny+mar,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\tif(come[ny][nx]==1)continue;\n\tcome[ny][nx]=1;\n\tused[ny][nx]=1;\n\tif(ntn+1>t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]==0&&used[nexty][nextx]==0){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<1500;i++){\n\tfor(int j=0;j<1500;j++){\n\tif(come[i][j]){ans++;}\n\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[63][63];\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = t+1;\n\tif(t==0) return;\n\tfor(int i=0;i<6;i++){\n\t\tint x2 = x+dx[i];\n\t\tint y2 = y+dy[i];\n\t\tif(hoge[x2][y2] != -1 && hoge[x2][y2] < t){\n\t\t\tf(x2, y2, t-1, ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<63;i++){\n\t\t\tfor(int j=0;j<63;j++){\n\t\t\t\tif(i==0 || j==0 || i==62 || j==62){\n\t\t\t\t\thoge[i][j] = 1;\n\t\t\t\t}else{\n\t\t\t\t\thoge[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 31;\n\t\t\ty += 31;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 31;\n\t\ty += 31;\n\t\t\n\t\tint ans = 0;\n\t\tf(x, y, t, ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = { 1,1,0,-1,-1,0 };\nconst int dy[] = { 0,1,1,0,-1,-1 };\nconst int geta = 30;\n\nint main()\n{\n\twhile (true) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\t\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint map[61][61];\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tmap[y + geta][x + geta] = 1;\n\t\t}\n\n\t\tint startx, starty;\n\t\tcin >> startx >> starty;\n\n\t\tint ans = 1;\n\t\tint now = 0;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push({ starty + geta,startx + geta });\n\t\tmap[starty + geta][startx + geta] = 1;\n\n\t\twhile (q.empty() == false && now < t) {\n\t\t\tunsigned int count = q.size();\n\n\t\t\twhile (count > 0) {\n\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tcount--;\n\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint ny = temp.first + dy[i];\n\t\t\t\t\tint nx = temp.second + dx[i];\n\n\t\t\t\t\tif (ny >= 0 && ny < 61 && nx >= 0 && nx < 61 && (ny - geta)*(ny - geta) + (nx - geta)*(nx - geta) <= 900 && map[ny][nx] == 0) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tmap[ny][nx] = 1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint main() {\n  int t, n;\n  while(cin >> t >> n && (t|n)) {\n    int M[200][200] = {};\n    int const BX = 100, BY = 100;\n    for(int i=0; i<n; i++) {\n      int x, y;\n      cin >> x >> y;\n      M[y+BY][x+BX] = 1;\n    }\n    \n    int const dx[] = {-1,1,0,0,1,-1};\n    int const dy[] = {0,0,-1,1,1,-1};\n    \n    typedef pair<int, int> Pii;\n    typedef pair<Pii, int> P;\n    \n    bool used[200][200] = {};\n    int ans = 0;\n    \n    int sx, sy;\n    cin >> sx >> sy; sx += BX, sy += BY;\n    \n    queue<P> Q;\n    Q.push(P(Pii(sx, sy), t));\n    used[sy][sx] = true;\n    \n    while(!Q.empty()) {\n      P const p = Q.front(); Q.pop();\n      ans ++;\n      \n      if(p.snd <= 0) continue;\n      \n      for(int i=0; i<6; i++) {\n\tint nx = p.fst.fst + dx[i], ny = p.fst.snd + dy[i];\n\tif(!used[ny][nx] && M[ny][nx] == 0) {\n\t  Q.push( P(Pii(nx, ny), p.snd-1) );\n\t  used[ny][nx] = true;\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int>P;\n#define X first\n#define Y second\nint dx[6]={1,0,-1,0,1,-1};\nint dy[6]={0,1,0,-1,1,-1};\n\nint main(){\n\t\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tint mp[200][200];\n\t\t/*\n\t\t-2:到達不可\n\t\t-1:未到達\n\t\t0>=:到達コスト\n\t\t*/\n\t\tmemset(mp,-1,sizeof(mp));\n\t\tint ans=0;\n\t\tint sx,sy;\n\t\tqueue<P>Q;\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmp[x+100][y+100]=-2;\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tsx+=100;\n\t\tsy+=100;\n\t\tmp[sx][sy]=0;\n\t\tans++;\n\t\tQ.push(P(sx,sy));\n\t\twhile(!Q.empty()){\n\t\t\tP p=Q.front();\n\t\t\tQ.pop();\n\t\t\tif(mp[p.X][p.Y]>t)break;\n\t\t\t//cout<<p.X-100<<\" \"<<p.Y-100<<endl;\n\t\t\tfor(int i=0;i<6&&mp[p.X][p.Y]<t;i++){\n\t\t\t\tif(mp[p.X+dx[i]][p.Y+dy[i]]==-1){\n\t\t\t\t\tmp[p.X+dx[i]][p.Y+dy[i]]=mp[p.X][p.Y]+1;\n\t\t\t\t\tQ.push(P(p.X+dx[i],p.Y+dy[i]));\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint t;\nint dx[]={-1,0,1,1,0,-1}, dy[]={0,1,1,0,-1,-1};\n\nint map[1000][1000];\n\nvoid dfs(int x, int y, int d, int &res) {\n    if(d>t+1) return;\n    if(map[x][y] && map[x][y] <= d) return;\n    if(!map[x][y]) res++;\n    map[x][y] = d;\n\n    for(int dir=0; dir<6; dir++)\n        dfs(x+dx[dir], y+dy[dir], d+1, res);\n}\n\nint main(void) {\n    while(1) {\n        int n;\n        scanf(\"%d%d\",&t,&n);\n        if(!t) break;\n\n        memset(map, 0, sizeof(map));\n\n        for(int i=0; i<n; i++) {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            x+=300; y+=300;\n            map[x][y] = -1;\n        }\n        int x,y,res=0;\n        scanf(\"%d%d\",&x,&y);\n        dfs(x+300,y+300,1,res);\n\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint t, n;\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\nstruct node{\n    int x;\n    int y;\n    int step;\n};\nbool inrange(int x, int y){\n    return x >= 0 && y >= 0 && x <= 60 && y <= 60;\n}\nbool jam[101][101];\nint main(){\n    while(cin >> t >> n, t||n){\n        memset(jam, 0, sizeof(jam));\n        rep(i, n){\n            int bx, by;\n            cin >> bx >> by;\n            bx += 30;\n            by += 30;\n            jam[bx][by] = true;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 30;\n        sy += 30;\n        queue<node> q;\n        set<pair<int, int> > st;\n        q.push((node){sx, sy, 0});\n        while(!q.empty()){\n            int x = q.front().x;\n            int y = q.front().y;\n            int step = q.front().step;\n            q.pop();\n            //      cout << x << \" \" << y << \" \" << step << endl;\n            if(step >= t+1) break;\n            st.insert(mp(x, y));\n            rep(i, 6){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(inrange(nx, ny) && !jam[nx][ny]){\n                    q.push((node){nx, ny, step+1});\n                }\n            }\n            \n        }\n        cout << st.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nint dx[] = {-1, -1, 0, 0, 1, 1};\nint dy[] = {0, -1, 1, -1, 1, 0};\n\nint main(){\t\n\tint t, n;\n\twhile(cin >> t >> n, t|n){\n\t\tmap<P, int> visit;\n\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvisit[MP(x, y)] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<pair<P, int> > q;\n\t\tq.push(MP(MP(sx, sy), 0));\n\n\t\tint ans = 0;\n\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front().first;\n\t\t\tint turn = q.front().second;\n\t\t\tq.pop();\n\n\t\t\tif(visit[p]) continue;\n\t\t\tvisit[p] = 1;\n\t\t\tans++;\n\n\t\t\tif(turn == t) continue;\n\n\t\t\trep(i, 6){\n\t\t\t\tint x = p.first + dx[i];\n\t\t\t\tint y = p.second + dy[i];\n\t\t\t\tq.push(MP(MP(x, y), turn+1));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int FIRST = 30;\nconst int dx[6] = {0,1,-1,1,-1,0};\nconst int dy[6] = {1,1,0,0,-1,-1};\n\nvoid bfs(vector<vector<int> > &map,int x1,int y1,int t){\n  queue<pair<int,int> > que;\n  que.push(pair<int,int>(x1,y1));\n  map[x1][y1] = 1;\n  while(!que.empty()){\n    int x,y;\n    pair<int,int> tmp = que.front();que.pop();\n    x = tmp.first;y = tmp.second;\n    if(map[x][y] > t) continue;\n    for(int i = 0;i < 6;i++){\n      if(x+dx[i] >= 0 && x+dx[i] < 61 && y+dy[i] >= 0&& y+dy[i] < 61 ){\n\tif(map[x+dx[i]][y+dy[i]] ==  0 ){\n\t  map[x+dx[i]][y+dy[i]] = map[x][y]+1;\n\t  que.push(pair<int,int>(x+dx[i],y+dy[i]));\n\t}\n      }\n    }\n  }\n  \n}\nint solve(vector<vector<int> > &map){\n  int ans = 0;\n  for(int i = 0;i < 61;i++){\n    for(int j = 0;j < 61;j++){\n      if(map[i][j] > 0){\n\tans++;\n      }\n    }\n  }\n  return ans;\n}\nvoid fun(vector<vector<int> > map){\n  for(int i = 20;i < 41;i++){\n    for(int j = 20;j < i;j++){\n      cout << \" \" ;\n    }\n    for(int j = 20;j < 41;j++){\n      if(map[j][i] == -1){\n\tcout << 9;\n      }else{\n\tcout << map[j][i];\n      }\n    }\n    cout << endl;\n  }\n\n}\nint main(){\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(t == 0 && n == 0)break;\n    vector<vector<int > > map(61,vector<int>(61,0));\n    for(int i = 0;i < n;i++){\n      int x,y;\n      cin >> x >> y;\n      map[FIRST+x][FIRST+y] = -1;\n    }\n    int f_x,f_y;\n    cin >> f_x >> f_y;\n    \n    bfs(map,FIRST+f_x,FIRST+f_y,t);\n    //    fun(map);\n    cout << solve(map) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, -1, 0, 1};\nint dy[]={0, -1, -1, 0, 1, 1};\n\nint main(){\n    while(1){\n        int t, n; cin>>t>>n;\n        if(t == 0) return 0;\n\n        vector<vector<bool>> visited(200, vector<bool>(200, false));\n        for(int i=0; i<n; i++){\n            int a, b; cin>>a>>b;\n            visited[b + 100][a + 100] = true;\n        }\n\n        int sx, sy; cin>>sx>>sy;\n\n        int ans = 1;\n        queue<T> que;\n        que.push(T(sy + 100, sx + 100, 0));\n        visited[sy + 100][sx + 100] = true;\n        while(que.size()){\n            int cy, cx, cnt;\n            tie(cy, cx, cnt) = que.front();\n            que.pop();\n\n            for(int i=0; i<6; i++){\n                int ny = cy + dy[i];\n                int nx = cx + dx[i];\n\n                if(cnt < t && !visited[ny][nx]){\n                    ans++;\n                    visited[ny][nx] = true;\n                    que.push(T(ny, nx, cnt + 1));\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <memory.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\nint o[500][500];\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[500][500];\n  int count = 0;\n\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n\n  for(int i = 0; i < n; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    //cout << closed[st.x][st.y] << endl;\n    if(closed[st.x][st.y] || st.cost > t) {\n      //cout << 'a'  << ' ' << count << endl;\n      continue;\n    }\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      //cout << nx << ' ' << ny << endl;\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    memset(o,0,sizeof(o));\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      //o[Y][X] = true;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1e9\n#define LINF 1e18\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\n#define int long long\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\nint dx[]={0,1,0,-1,1,-1};\nint dy[]={1,0,-1,0,1,-1};\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n\nbool isupper(char c){if('A'<=c&&c<='Z')return 1;return 0;}\nbool islower(char c){if('a'<=c&&c<='z')return 1;return 0;}\nbool isPrime(int x){if(x==1)return 0;if(x==2)return 1;if(x%2==0)return 0;for(int i=3;i*i<=x;i++)if(x%i==0)return 0;return 1;}\nbool iskaibun(string s){for(int i=0;i<s.size()/2;i++)if(s[i]!=s[s.size()-i-1])return 0;return 1;}\nbool isnumber(char c){return ('0'<=c&&c<='9');}\nbool isalpha(char c){return (isupper(c)&&islower(c));}\nvoid printvi(vector<int> v){rep(i,0,v.size()){if(i)cout<<\" \";cout<<v[i];}cout<<endl;}\nvoid printvil(vector<int> v){rep(i,0,v.size()){cout<<v[i]<<endl;}}\nvoid printvvi(vector<vector<int>> v){\n    rep(i,0,v.size()){\n        rep(j,0,v[i].size())cout<<v[i][j];\n        cout<<endl;\n    }\n}\nvoid printvstr(vector<string> v){\n    rep(i,0,v.size()){\n        cout<<v[i]<<endl;\n    }\n}\n\nstruct S{\n    int x,y;\n    int count;\n};\nsigned main (){\n    int t,n;\n    while(1){\n        cin>>t>>n;\n        if(t==n and n==0)break;\n        queue<S> que;\n        vector<vector<int>> obs(200,vector<int>(200,0));\n        vector<vector<int>> visited(200,vector<int>(200,0));\n        rep(i,0,n){\n            int x,y;\n            cin>>x>>y;\n            x+=100; y+=100;\n            obs[y][x]=1;//障害物がある\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n        sx+=100;sy+=100;\n        que.push(S{sx,sy,1});\n        visited[sy][sx]=1;\n        while(!que.empty()){\n            S now=que.front();\n            que.pop();\n            rep(i,0,6){\n                int nx=now.x+dx[i];\n                int ny=now.y+dy[i];\n                if(obs[ny][nx]==1)continue;\n                if(visited[ny][nx]==0 and now.count<=t){\n                    que.push(S{nx,ny,now.count+1});\n                    visited[ny][nx]=1;\n                }\n            }\n        }\n        int ans=0;\n        rep(i,0,200){\n            rep(j,0,200){\n                if(visited[i][j]>0)ans++;\n            }\n        }\n        cout<<ans<<endl;\n\n    }\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 70>, 70> hex, array<array<int32_t, 70>, 70> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 1;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {0, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t i = iter->first;\n      int32_t j = iter->second;\n      if (0 <= x + i && x + i < 70 && 0 <= y + j && y + j < 70 && !hex[x + i][y + j] && dists[x + i][y + j] == 0) {\n        dists[x + i][y + j] = dists[x][y] + 1;\n        q.push({x + i, y + j});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 70>, 70> hex;\n    array<array<int32_t, 70>, 70> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = 0;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 30][y + 30] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 30, y + 30);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (1 <= *i && *i <= t + 1) {\n          count++;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 70>, 70> hex, array<array<int32_t, 70>, 70> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 1;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {0, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t i = iter->first;\n      int32_t j = iter->second;\n      if (0 <= x + i && x + i < 70 && 0 <= y + j && y + j < 70 && !hex[x + i][y + j] && dists[x + i][y + j] == 0) {\n        dists[x + i][y + j] = dists[x][y] + 1;\n        q.push({x + i, y + j});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 70>, 70> hex;\n    array<array<int32_t, 70>, 70> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = 0;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 35][y + 35] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 35, y + 35);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (1 <= *i && *i <= t + 1) {\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nstruct point{\n\tint x,y,cost;\n};\ntypedef struct point P;\n\nP setP(int x_,int y_,int cost_){\n\tP p; p.x = x_; p.y = y_; p.cost = cost_;\n\treturn p;\n}\n\nint main(){\n\tint t,n,sx,sy,ans;\n\tint dx[] = {0,1,1,0,-1,-1};\n\tint dy[] = {1,1,0,-1,-1,0};\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tint f[200][200] = {0};\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tf[y+100][x+100] = -1;\n\t\t}\n\t\t\n\t\tcin >> sx >> sy;\n\t\tP sp = setP( sx+100 , sy+100 , 0 );\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tf[ sp.y ][ sp.x ] = 1;\n\t\tans = 1;\n\t\twhile( !que.empty() ){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tif( p.cost+1 > t )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\t\tint mx = p.x + dx[i];\n\t\t\t\tint my = p.y + dy[i];\n\t\t\t\tif( /*abs(mx-100) > 30 || abs(my-100) > 30 ||*/ f[my][mx] != 0 ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tP p_ = setP( mx , my , p.cost+1 );\n\t\t\t\t\tf[my][mx] = 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push( p_ );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {0,1,1,0,-1,-1};\nconst int    DY[] = {1,1,0,-1,-1,0};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nconst int M = 61;\nconst int OFFSET = 30;\nint T, N;\n\nVVB done;\nVVB bads;\n\nint solve() {\n    bads = VVB(M, VB(M));\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        bads[OFFSET + y][OFFSET + x] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    done = VVB(M, VB(M));\n\n    queue<pair<int, PII>> q;\n    q.push(MP(T, MP(OFFSET + sy, OFFSET + sx)));\n    while (q.size()) {\n        int t = q.front().fst;\n        int y = q.front().snd.fst;\n        int x = q.front().snd.snd;\n        q.pop();\n\n        if (done[y][x]) continue;\n        done[y][x] = true;\n        if (!t) continue;\n\n        rep(i, 6) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if (!RANGEBOX(ny, nx, M, M)) continue;\n            if (bads[ny][nx]) continue;\n            q.push(MP(t - 1, MP(ny, nx)));\n        }\n    }\n\n    int cnt = 0;\n    rep(i, M) cnt += count(ALL(done[i]), true);\n\n    return cnt;\n}\n\nint main(void) {\n    while (cin >> T >> N, T) cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n \n#define NMAX 50\n\ntypedef map<int,bool>::value_type VT;\n\nstruct data{\n\tint x,y,turn;\n};\n\nint main(void){\n\t\n\tint t,n;\n\tint x,y;\n\tmap<int,bool> road[31];\n\tqueue<data> no;\n\tdata tm,da;\n\tint dx[]={1,1,0,-1,-1,0};\n\tint dy[]={0,1,1,0,-1,-1};\n\tint cnt;\n\n\tfor(int i=-31;i<=31;i++){\n\t\tfor(int j=-31;j<=31;j++){\n\t\t\tfor(int k=0;k<31;k++){\n\t\t\t\troad[k].insert(VT(i+j*100,true));\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=-30;i<=30;i++){\n\t\t\tfor(int j=-30;j<=30;j++){\n\t\t\t\tfor(int k=0;k<31;k++){\n\t\t\t\t\troad[k][i+j*100]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-31;i<=31;i++){\n\t\t\tfor(int k=0;k<31;k++){\n\t\t\troad[k][-31+i*100]=false;\n\t\t\troad[k][31+i*100]=false;\n\t\t\troad[k][i+31*100]=false;\n\t\t\troad[k][i-31*100]=false;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tfor(int k=0;k<31;k++){\n\t\t\t\troad[k][y+x*100]=false;\n\t\t\t}\n\t\t}\n\t\tcin>>x>>y;\n\t\ttm.x=x,tm.y=y,tm.turn=0;\n\t\tno.push(tm);\n\t\tcnt=0;\n\t\twhile(!no.empty()){\n\t\t\ttm=no.front();\n\t\t\tno.pop();\n\t\t\tif(tm.turn==t){\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(road[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n\t\t\t\t\troad[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]=false;\n\t\t\t\t\tda.x=tm.x+dx[i];\n\t\t\t\t\tda.y=tm.y+dy[i];\n\t\t\t\t\tda.turn=tm.turn+1;\n\t\t\t\t\tno.push(da);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(road[t-1][y+x*100]==true) cnt++;\n\t\tcout<<cnt<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 600;\n\nclass S{\npublic:\n  int y, x, c;\n  S() : y(0), x(0), c(0) {}\n  S(int y, int x, int c) : y(y), x(x), c(c) {}\n};\n\nint t, n, sy, sx;\nbool mapData[N][N];\nbool visited[N][N];\nint dy[] = {1, 0, -1, -1, 0, 1};\nint dx[] = {1, 1, 0, -1, -1, 0};\n\nvoid bfs(){\n  fill(visited[0], visited[N], false);\n  S u;\n  queue<S> q;\n  q.push(S(sy, sx, 0));\n  visited[sy][sx] = true;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(!mapData[ny][nx]) continue;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = true;\n      if(u.c+1 < t) q.push(S(ny, nx, u.c+1));\n    }\n  }\n}\n\n\nmain(){\n  while(cin >> t >> n && (t|n)){\n    fill(mapData[0], mapData[N], true);\n    for(int i=0;i<n;i++){\n      int y, x;\n      cin >> x >> y; \n      mapData[y+N/2][x+N/2] = false;\n    }\n    cin >> sx >> sy;\n    sx += N/2;\n    sy += N/2;\n    bfs();\n    int ans = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(visited[i][j]) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define all(v) v.begin(), v.end()\n\nint t, n;\nvector<pii> obj;\n\nint sx, sy;\nset<pii> reach;\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {1, 0, -1, -1, 0, 1};\n\nstruct State {\n\tpii p; int turn;\n\tState (pii _p, int _t) : p(_p), turn(_t) {}\n};\n\nvoid solve() {\n\tqueue<State> q;\n\tq.push(State(make_pair(sx, sy), 0));\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tif (reach.find(s.p) != reach.end()) continue;\n\t\tif (binary_search(all(obj), s.p)) continue;\n\t\tif (s.turn > t) continue;\n\t\t\n\t\treach.insert(s.p);\n\t\t\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint x = s.p.first + dx[i], y = s.p.second + dy[i];\n\t\t\tq.push(State(make_pair(x, y), s.turn + 1));\n\t\t}\n\t}\n\t\n\tcout << (int)reach.size() << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> t >> n; if (t == 0 && n == 0) break;\n\t\t\n\t\tobj.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tobj.push_back(make_pair(x, y));\n\t\t}\n\t\tsort(all(obj));\n\t\t\n\t\treach.clear();\n\t\tcin >> sx >> sy;\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\n\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=t+1;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            // if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]<t){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*cout <<\"Debug\"\ncout <<x-30<<' '<<y-30<<endl;*/\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[200][200];\nint cnt = 0;\nint d_x[] = {1, 1, 0, -1, -1, 0};\nint d_y[] = {1, 0, -1, -1, 0, 1};\nint t;\n/*\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cout <<\"Debug \";\n  cout <<x-30<<' '<<y-30<<endl;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  int used[6] = {0};\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(watasi < t)&&(mp[nx][ny] == 0)){\n        dfs(nx,ny,watasi);\n        used[dx] = 1;\n    }\n    for(int i = 0;i<6;i++){\n      if(used[i]){\n        if((nx == x + d_x[i])&&(ny == y + d_y[i])){\n          dfs(nx,ny,watasi);\n        }\n      }\n    }\n    }\n}\n*/\nint main(){\n  int n,t;\n\n  cin >>t>>n;\n  while(!((t == 0)&&(n == 0))){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<200;i++){\n      for(int j = 0;j<200;j++){\n        mp[i][j]=-1;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+100][y+100] = 1;\n    }\n    cin >>fx>>fy;\n\n    cnt = 0;\n\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(fx+100,fy+100));\n    mp[fx+100][fy+100] = 0;\n    while (!qu.empty()) {\n      pair<int ,int> pr = qu.front();\n      qu.pop();\n      int nx = pr.first,ny= pr.second;\n      cnt++;\n      if(mp[nx][ny] == t)continue;\n      for(int i = 0;i<6;i++){\n        int cx = nx+d_x[i],cy = ny+d_y[i];\n        if(mp[cx][cy] != -1)continue;\n        mp[cx][cy] = mp[nx][ny] + 1;\n        qu.push(make_pair(cx,cy));\n      }\n    }\n\n    cout <<cnt<<endl;\n    cin >>t>>n;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nconst int dx[6]={-1,0,1,0,1,-1},dy[6]={0,-1,0,1,1,-1};\n\nconst int h=200,w=200;\nconst int M=100000;\n\nvvi a;\n\nint main(){\n\twhile(1){\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\ta=vvi(h,vi(w));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta[x+100][y+100]++;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tqueue<pip> q;\n\t\tq.push({0,{x+100,y+100}});\n\t\ta[x+100][y+100]++;\n\t\tint res=1;\n\t\twhile(!q.empty()){\n\t\t\tauto pp=q.front();\n\t\t\tq.pop();\n\t\t\tif(pp.first==m) continue;\n\t\t\tP p=pp.second;\n\t\t\tx=p.first,y=p.second;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint cx=x+dx[i],cy=y+dy[i];\n\t\t\t\tif(!a[cx][cy]){\n\t\t\t\t\ta[cx][cy]=1;\n\t\t\t\t\tres++;\n\t\t\t\t\tq.push({pp.first+1,{cx,cy}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nclass State{\npublic:\n  int x,y,cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint n,m;\nint sx,sy;\nbool t[1000][1000];\nbool closed[1000][1000];\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  int ans = 0;\n\n  while(!open.empty()){\n    State st = open.front(); open.pop();\n    if(closed[st.x][st.y] || st.cost>n || t[st.y][st.x]) continue;\n    closed[st.x][st.y] = true;\n\n    ans++;\n\n    for(int i = 0; i < 6; i++){\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx,ny,st.cost+1));\n    }\n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(cin>>n>>m,n||m){\n    memset(t,0,sizeof(t));\n    for(i = 0; i < m; i++){\n      int x,y;\n      cin>>x>>y;\n      x += 300;\n      y += 300;\n      t[y][x] = true;\n    }\n\n    cin>>sx>>sy;\n    sx += 300;\n    sy += 300;\n\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \n#define BLANK 0\n#define BLOCK 1\n#define POSSIBLE 2\n#define CENTER 100\n#define MAX 200+1\n \nstruct point{int x,y,d;};\n \nint main()\n{\n  int t,n,cnt;\n  int i,j,a,b;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  int field[MAX][MAX];\n  queue<point> q;\n  point p,p2;\n  while(cin>>t>>n,t||n){\n    for(i=0;i<MAX;i++)for(j=0;j<MAX;j++)field[i][j]=BLANK;\n    for(i=0;i<n;i++){\n      cin>>a>>b;\n      field[a+CENTER][b+CENTER]=BLOCK;\n    }\n \n    cnt=1;\n    while(!q.empty())q.pop();\n    cin>>a>>b;\n    p.x=a+CENTER;\n    p.y=b+CENTER;\n    p.d=0;\nfield[p.x][p.y]=POSSIBLE;\n    q.push(p);\n    while(!q.empty()){\n      p=q.front();\n      q.pop();\n      if(p.d>=t)continue;\n      for(i=0;i<6;i++){\n        p2.x=p.x+dx[i];\n        p2.y=p.y+dy[i];\n        p2.d=p.d+1;\n        if(field[p2.x][p2.y]!=BLANK)continue;\nfield[p2.x][p2.y]=POSSIBLE;\nq.push(p2);\ncnt++;\n      }\n    }\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    while(true){\n        int field[110][110];\n        int cfield[110][110];\n        int t, n;\n        scanf(\"%d%d\", &t, &n);\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                field[i][j] = cfield[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            x += 50; y += 50;\n            field[x][y] = -1;\n            cfield[x][y] = -1;\n        }\n        int cx, cy;\n        scanf(\"%d%d\", &cx, &cy);\n        cx += 50; cy += 50;\n        field[cx][cy] = cfield[cx][cy] = 1;\n        for(int _ = 0; _ < t; _++){\n            for(int i = 1; i < 100; i++){\n                for(int j = 1; j < 100; j++){\n                    if(field[i][j] > 0){\n                        for(int d = 0; d < 6; d++){\n                            if(cfield[i + dx[d]][j + dy[d]] >= 0){\n                                cfield[i + dx[d]][j + dy[d]] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            for(int i = 0; i < 100; i++){\n                for(int j = 0; j < 100; j++){\n                    field[i][j] = cfield[i][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                if(field[i][j] > 0){\n                    ++ans;\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {1,0,-1,-1,0,1};\nconst int dy[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      auto Q = q.front();q.pop();\n      d = v[Q.fi][Q.se];\n      if(d >= t) continue ;\n      rep(i,6){\n        ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n        if(value(nx,ny,61,61) && v[nx][ny] > d+1){\n          q.push(mp(nx,ny));\n          if(v[nx][ny] == inf)\n            ++cnt;\n          v[nx][ny] = d+1;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {1,0,-1,-1,0,1};\nconst int dx[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      if(d == t) break;\n      ++d;\n      auto S = q.size();\n      rep(j,S){\n        auto Q = q.front();q.pop();\n        rep(i,6){\n          ll nx = Q.fi + dy[i],ny = Q.se + dx[i];\n          if(value(nx,ny,62,62) && v[nx][ny] == inf){\n            q.push(mp(nx,ny));\n            v[nx][ny] = d;\n            ++cnt;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\n\nint board[128][128];\nint geta = 64;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  while (1) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    memset(board, 0, sizeof(board));\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      board[y+geta][x+geta] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    queue<T> que;\n    que.push(T(sx, sy, t));\n\n    while (!que.empty()) {\n      int x, y, rest;\n      tie(x, y, rest) = que.front();\n      que.pop();\n\n      if (rest < 0 || board[y+geta][x+geta] != 0) continue;\n\n      board[y+geta][x+geta] = 1;\n      REP(i, 6) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\t  que.push(T(nx, ny, rest - 1));\n      }\n    }      \n      \n    int ans = 0;\n    REP(i, 128) REP(j, 128) ans += board[i][j] > 0;\n    cout << ans << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint mas[61][61];\nint used[61][61];\n\nint dx[] = { 1, 1, 0, -1, -1, 0 }, dy[] = { 1, 0, -1, -1, 0, 1 };\nint maxi[61][61];\n\nint rec(int t, int x, int y) {\n    if(t == 0) {\n        int ret = !used[y][x];\n        used[y][x]++;\n        return ret;\n    }\n\n    if(maxi[y][x] > t) return 0;\n    maxi[y][x] = t;\n\n    int ret = !used[y][x];\n    used[y][x]++;\n    for(int i = 0; i < 6; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(!mas[ny][nx]) {\n            ret += rec(t - 1, nx, ny);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, t;\n    while(cin >> t >> n, t) {\n        memset(mas, 0, sizeof(mas));\n        memset(used, 0, sizeof(used));\n        memset(maxi, 0, sizeof(maxi));\n        for(int i = 0; i < n; i++) {\n            int x, y; cin >> x >> y;\n            mas[y + 30][x + 30] = 1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        cout << rec(t, sx + 30, sy + 30) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,t,y,x;\nint g[200][200];\nint d[200][200];\nint dy[] = {1,1,0,-1,-1,0}, dx[] = {0,1,1,0,-1,-1};\nconst int B = 100;\n\nint main(){\n  while(cin >> t >> n, t||n){\n    memset(g,0,sizeof(g));\n    memset(d,-1,sizeof(d));\n  \n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      g[y+B][x+B] = 1;\n    }\n\n    cin >> x >> y;\n    queue<P> q; q.push(P(y+B,x+B));\n    d[y+B][x+B] = 0;\n\n    int res = 1;\n    while(q.size()){\n      P p = q.front(); q.pop();\n      y = p.first; x = p.second;\n      \n      for(int i=0;i<6;i++){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(g[ny][nx])continue;\n\n\tif(d[ny][nx]<0 && d[y][x]<t){\n\t  d[ny][nx] = d[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t  res++;\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint t,x,y,T;\nbool mp[201][201];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nint bfs(){\n  queue<P> Q;\n  int cnt=0;\n  Q.push(P(0,(x+100)*N+y+100));\n  while(!Q.empty()){\n    P p=Q.front();\n    Q.pop();\n    T=p.first;\n    x=p.second/N,y=p.second%N;\n    if(T>t)return cnt;\n    if(mp[x][y])continue;\n    mp[x][y]=1;\n    cnt++;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      Q.push(P(T+1,nx*N+ny));\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  int n;\n  while(cin>>t>>n&&(t||n)){\n    memset(mp,0,sizeof(mp));\n    while(n--){\n      cin>>x>>y;\n      mp[x+100][y+100]=1;\n    }\n    cin>>x>>y;\n    cout<<bfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n\ntypedef tuple<int,int,int> Tr;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1};\n\nconst int NMAX = 230;\nint field[NMAX][NMAX];\n#define MAP(x, y) field[x + 100][y + 100]\n\nint main() {\n  int T, N;\n  while (cin >> T >> N and T) {\n    FOR(x, -100, 100) FOR(y, -100, 100) {\n      MAP(x, y) = INF;\n    }\n    REP(i, N) {\n      int x, y;\n      cin >> x >> y;\n      MAP(x, y) = -1;\n    }\n\n    int sx,sy;\n    cin >> sx >> sy;\n    priority_queue<Tr,vector<Tr>,greater<Tr>> que;\n    que.push(Tr(1,sx,sy));\n\n    while (!que.empty()) {\n      int turn, x, y;\n      tie(turn, x, y) = que.top(); que.pop();\n      if (turn >= MAP(x, y)) continue;\n      MAP(x, y) = turn;\n      REP(j, 6) {\n        const int nx = x + dx[j], ny = y + dy[j];\n        if (MAP(nx, ny) >= 0 and turn <= T)\n          que.push(Tr(turn + 1, nx, ny));\n      }\n    }\n\n    int sum = 0;\n    FOR(x, -100, 100) FOR(y, -100, 100) {\n      if (MAP(x, y) >= 0 and MAP(x, y) < 100) sum++;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t,n;\nset<pair<int,int> > point;\ntypedef pair<int,int> P;\nconst int C = 40;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[103][103];\n    rep(i,103) rep(j,103) dist[i][j]=INF;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        \n        point.insert(make_pair(x,y));\n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(x,y));\n    dist[x][y]=0;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first;\n        int y = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(0<=nx && 0<=ny && dist[nx][ny] == INF && point.find(P(nx,ny)) == point.end()) {\n                dist[nx][ny] = dist[x][y]+1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,102) rep(j,102) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n    point.clear();\n    \n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\nconst int dy[]={-1,-1,0,0,1,1};\nconst int dx[]={-1,0,-1,1,0,1};\nint main(){\n\n\tint n,t;\n\tconst int base=100;\n\tconst int MAX_P=201;\n\twhile(cin>>t>>n&&!(t==0&&n==0)){\n\t\tbool passed[MAX_P][MAX_P];\n\t\tbool isArrival[2][MAX_P][MAX_P];\n\t\tbool obj[MAX_P][MAX_P];\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tmemset(obj,0,sizeof(obj));\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tobj[y+base][x+base]=true;\n\t\t}\n\t\tint sy,sx;\n\t\tcin>>sx>>sy;\n\t\tisArrival[0][sy+base][sx+base]=true;\n\t\tpassed[sy+base][sx+base]=true;\n\t\tint cnt=1;\n\t\tfor(int l = 0; l < t; l++){\n\t\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\t\tif(isArrival[l%2][i][j]){\n\t\t\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tif(!obj[ny][nx]){\n\t\t\t\t\t\t\t\tisArrival[(l+1)%2][ny][nx]=true;\n\t\t\t\t\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisArrival[l%2][i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define INF int(1e9)\n\nint t, n, x, y, sx, sy, ans;\nbool used[500][500];\nint used_min[500][500]; // minimum turn\n\nint vx[6] = {0, 1, 1, 0, -1, -1},\n    vy[6] = {1, 1, 0, -1, -1, 0};\n/*\nint dfs(int x, int y, int turn) {\n    //cout << \"now : \" << x-250 << \" \" << y-250 << endl;\n    used[x][y] = true;\n    used_min[x][y] = (used_min[x][y] > turn) ? turn : used_min[x][y];\n\n    if (turn == t) return 0;\n\n    int ret = 0;\n\n    for (int i = 0; i < 6; ++i) {\n        int nx = x + vx[i], ny = y + vy[i];\n        if (!used[nx][ny]) {\n            ret += dfs(nx, ny, turn + 1);\n            ret++;\n        }\n        else if (used[nx][ny] && used_min[nx][ny] >= turn) {\n            ret += dfs(nx, ny, turn + 1);\n        }\n    }\n\n    return ret;\n}\n*/\n\nstruct Tuple {\n    int f, s, t;\n    Tuple(int f, int s, int t) : f(f), s(s), t(t) {}\n};\n\nint bfs() {\n    int ret = 0;\n    queue<Tuple> que;\n    que.push(Tuple(sx + 250, sy + 250, 0));\n    used[sx + 250][sy + 250] = true;\n    used_min[sx + 250][sy + 250] = 0;\n\n    while (!que.empty()) {\n        Tuple tpl = que.front();\n        que.pop();\n\n        //cout << \"pos : \" << tpl.f-250 << \" \" << tpl.s-250 << \", used is \" << used[tpl.f][tpl.s] << endl;\n\n        if (tpl.t > used_min[tpl.f][tpl.s]) continue;\n\n        if (tpl.t == t) continue;\n\n        for (int i = 0; i < 6; ++i) {\n            int nx = tpl.f + vx[i], ny = tpl.s + vy[i];\n\n            if (!used[nx][ny]) {\n                ret++;\n                que.push(Tuple(nx, ny, tpl.t + 1));\n                used[nx][ny] = true;\n                used_min[nx][ny] = tpl.t + 1;  \n                //cout << \"next : \" << nx-250 << \" \" << ny-250 << endl;\n            }\n            else if (used[nx][ny] && used_min[nx][ny] > tpl.t + 1) {\n                que.push(Tuple(nx, ny, tpl.t + 1));\n                used_min[nx][ny] = tpl.t + 1;                \n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> t >> n, t | n) {\n        for (int i = 0; i < 500; ++i) {\n            for (int j = 0; j < 500; ++j) {\n                used[i][j] = false;\n                used_min[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y;\n            x += 250; y += 250;\n            used[x][y] = true;\n            used_min[x][y] = -INF;\n        }\n        cin >> sx >> sy;\n\n        //ans = dfs(sx + 250, sy + 250, 0);\n        ans = bfs();\n\n        cout << ans + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(fr.first.first+dx[i],fr.first.second+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&jama.find(cur)==jama.end())q.push(piii(cur,fr.second+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nvoid wfs(array<array<int32_t, 200>, 200> &hex, int32_t x, int32_t y) {\n  queue<pair<int32_t, int32_t>> q;\n\n  hex[x][y] = 0;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> p = q.front();\n    int32_t x = p.first;\n    int32_t y = p.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vecs{{0, 1}, {1, 1},   {-1, 0},\n                                        {1, 0}, {-1, -1}, {0, -1}};\n    for (uint32_t i = 0; i < vecs.size(); i++) {\n      int32_t posx = x + vecs[i].first;\n      int32_t posy = y + vecs[i].second;\n      if (0 <= posx && posx < 200 && 0 <= posy && posy < 200 &&\n          hex[posx][posy] == INT32_MAX) {\n        hex[posx][posy] = hex[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main() {\n  while (true) {\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    array<array<int32_t, 200>, 200> hex;\n    for (uint32_t i = 0; i < hex.size(); i++) {\n      for (uint32_t j = 0; j < hex[0].size(); j++) {\n        hex[i][j] = INT32_MAX;\n      }\n    }\n\n    for (uint32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 100][y + 100] = -1;\n    }\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, x + 100, y + 100);\n\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < hex.size(); i++) {\n      for (uint32_t j = 0; j < hex[0].size(); j++) {\n        if (0 <= hex[i][j] && hex[i][j] <= t) {\n          count++;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int t,n;cin>>t>>n,t|n;){\n\t\tint grid[61][61]={}; // -1:block,0:empty,1:visitable\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y; cin>>x>>y;\n\t\t\tgrid[30+y][30+x]=-1;\n\t\t}\n\t\tint x0,y0; cin>>x0>>y0;\n\t\t\n\t\tqueue<tuple<int,int,int>> q;\n\t\tq.emplace(x0,y0,0);\n\t\twhile(!q.empty()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint cx=get<0>(c),cy=get<1>(c),ct=get<2>(c);\n\t\t\tif(cy-cx>30 || cx-cy>30 || grid[30+cy][30+cx] || ct>t)\n\t\t\t\tcontinue;\n\t\t\tgrid[30+cy][30+cx]=1;\n\t\t\tint dx[]={1,1,0,-1,-1,0},dy[]={0,1,1,0,-1,-1};\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t\tq.emplace(cx+dx[i],cy+dy[i],ct+1);\n\t\t}\n\t\t\n\t\tint res=0;\n\t\tfor(int i=0;i<61;i++)\n\t\t\tfor(int j=0;j<61;j++)\n\t\t\t\tres+=grid[i][j]==1;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[100][100];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sx-data[1][i])>t+3){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (50-sx);\n\t\t\ttmpY += (50-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=50;\n\t\tsy=50;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 100;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[200][200]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n \nconst int dx[6] = { 1,1,0,-1,-1,0};\nconst int dy[6] = { 0,1,1,0,-1,-1 };\n \n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)///\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int t, n;\n        cin >> t >> n;\n        if (!t)break;\n        vvi v(61, vi(61, 0));\n        REP(i, n) {\n            int x, y;\n            cin >> x >> y;\n            v[y + 30][x + 30] = 1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        vvi depth(61, vi(61, INF));\n        depth[sy + 30][sx + 30] = 0;\n        queue<pii> q;\n        q.push(make_pair(sx, sy));\n        while (!q.empty()) {\n            pii a = q.front(); q.pop();\n            int x = a.first, y = a.second;\n            REP(i, 6) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (ny <= 30 && nx <= 30 && nx >= -30 && ny >= -30 && v[ny + 30][nx + 30] == 0&&depth[ny+30][nx+30]==INF) {\n                    q.push(make_pair(nx, ny));\n                    depth[ny + 30][nx + 30] = depth[y + 30][x + 30] + 1;\n                }\n            }\n        }\n        int cnt = 0;\n        REP(i, 61) {\n            REP(j, 61) {\n \n                if (depth[i][j] <= t)cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 62;\n\nclass S{\npublic:\n  int y, x, c;\n  S() : y(0), x(0), c(0) {}\n  S(int y, int x, int c) : y(y), x(x), c(c) {}\n};\n\nint t, n, sy, sx;\nbool mapData[N][N];\nbool visited[N][N];\nint dy[] = {1, 0, -1, -1, 0, 1};\nint dx[] = {1, 1, 0, -1, -1, 0};\n\nvoid bfs(){\n  fill(visited[0], visited[N], false);\n  S u, v;\n  queue<S> q;\n  q.push(S(sy, sx, 0));\n  visited[sy][sx] = true;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    if(u.c >= t) continue;\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny<0 || ny>=N) continue;\n      if(nx<0 || nx>=N) continue;\n      if(!mapData[ny][nx]) continue;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = true;\n      v = S(ny, nx, u.c+1);\n      q.push(v);\n    }\n  }\n}\n\n\nmain(){\n  while(cin >> t >> n && (t|n)){\n    fill(mapData[0], mapData[N], true);\n    for(int i=0;i<n;i++){\n      int y, x;\n      cin >> x >> y; \n      mapData[y+N/2][x+N/2] = false;\n    }\n    cin >> sx >> sy;\n    sx += N/2;\n    sy += N/2;\n    bfs();\n    int ans = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(visited[i][j]) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint map[100][100];\nint mapcnt[100][100];\nint t, n;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid search(int x, int y, int t){\n\tqueue<pair<pair<int, int>, int> > q;\n\tq.push(make_pair(make_pair(x,y),t));\n\twhile(!q.empty()){\n\t\tpair<pair<int, int>, int> p = q.front();\n\t\tq.pop();\n\t\tpair<int , int> id = p.first;\n\t\tif(map[id.first][id.second] != 0) continue;\n\t\tif(!p.second) continue;\n\t\tmap[id.first][id.second] = 1;\n\t\tfor(int i = 0; i < 6; i++){\n//printf(\"push : %d %d %d\\n\", id.first+dx[i], id.second+dy[i], p.second);\n\t\t\tif(map[id.first+dx[i]][id.second+dy[i]] != 0) continue;\n\t\t\tq.push(make_pair(make_pair(id.first+dx[i],id.second+dy[i]),p.second-1));\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x, y;\n\twhile(cin >> t >> n, t || n){\n\t\tfor(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){ mapcnt[i][j] = 0; map[i][j] = 0;}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x + 50][y + 50] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tsearch(x+50, y+50, t+1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\tif(map[i][j] == 1) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i<n;i++)\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> q1;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] == 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0);\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define rd(a) cin>>(a)\n#define RD(a,b) cin>>(a)>>(b)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[6]={-1,-1,0,0,1,1},dy[6]={0,-1,1,-1,1,0};\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && (n||m)) {\n    P a[m];\n    rep(i,m) cin >> a[i].F >> a[i].S;\n    int sx,sy;\n    cin >> sx >> sy;\n    int d[200][200];\n    memset(d,0,sizeof(d));\n    d[100][100]=1;\n    rep(i,m) {\n      int x=a[i].F+(100-sx),y=a[i].S+(100-sy);\n      d[x][y]=MAX;\n    }\n    queue<P> que;\n    que.push(P(100,100));\n    while(!que.empty()) {\n      int nx=que.front().F,ny=que.front().S;que.pop();\n      if(d[nx][ny]-1==n) continue;\n      for(int i=0; i<6; i++) {\n\tint x=nx+dx[i],y=ny+dy[i];\n\tif(check(200,200,x,y) && !d[x][y]) {\n\t  d[x][y]=d[nx][ny]+1;\n\t  que.push(P(x,y));\n\t}\n      }\n    }\n    int ans=0;\n    rep(i,200) {\n      rep(j,200) {\n\tif(d[i][j] && d[i][j]!=MAX) ans++;\n      }\n    }\n    pr(ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[62][62];\n//complex<int> p;\t\t//テ」ツ?づ」ツつ古」ツ??、ツスツソテ」ツつ湘」ツ?ェテ」ツ??\n\nint dx[] = {0,1,0,-1,1,-1};\nint dy[] = {1,0,-1,0,1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n//\tcout<< x-30-2<< \" \"<< y-30-2<< \" \"<< t<< \" \"<< ans<< endl;\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = 1;\n\tif(hoge[x][y] > t) return;\t//\tif(t<=0) return;\tテ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツつ?\n\thoge[x][y] = t+1;\n\tfor(int i=0;i<6;i++){\n\t\tif(hoge[x+dx[i]][y+dy[i]] != -1){\t\t//テ」ツδ淌」ツつケ : hoge[][]==1テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ッテ・ツ按・テ」ツ?ォテ・ツ閉湘ゥツ。ツ古」ツ?ェテ」ツ??\n\t\t\tf(x+dx[i],y+dy[i],t-1,ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<62;i++){\n\t\t\tfor(int j=0;j<62;j++){\n\t\t\t\thoge[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 30;\n\t\ty += 30;\n\t\t\n\t\tint ans = 0;\n\t\tf(x,y,t,ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[61][61], d[61][61];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60 ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+30][b+30]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=30;\n\t\tstart.y+=30;\n\t\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\twhile(!que.empty()){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\tif(d[v.x][v.y]>=turn) continue;\n\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx; tmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mLife;\n  int mX;\n  int mY;\n  State(int life,int x,int y) : mLife(life), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mLife < s.mLife;\n  }\n\n  bool operator >(const State& s) const{\n    return mLife > s.mLife;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //0:unvisited\n      //1:obstacle\n      //2:visited\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State> > que;\n    que.push(State(t,sx,sy));\n    stage[P(sx,sy)] = t;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.mLife <= 0) continue;\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\tif(abs(dx) > 30 || abs(dy) > 30) continue;\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && stage[P(dx,dy)] <= s.mLife-1) continue;\n\n\tstage[P(dx,dy)] = s.mLife-1;\n\tque.push(State(s.mLife-1,dx,dy));\n      }\n    }\n\n    int res = CoundVisitedCell(stage);\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[1000][1000];\n  int count = 0;\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 300;\n      Y += 300;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 300;\n    sy += 300;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\n\nint mas[61][61];\nint dx[] = { 1, 1, 0, -1, -1, 0 }, dy[] = { 1, 0, -1, -1, 0, 1 };\n\ntypedef pair< int, int > iP;\ntypedef pair< int, iP > iiP;\n\nint bfs(int t, int sx, int sy) {\n    int ret = 0;\n    int used[61][61] = {{0}};\n    queue< iiP > q;\n    q.push(iiP(t, iP(sx, sy)));\n    while(!q.empty()) {\n        iiP p = q.front(); q.pop();\n        if(p.first < 0 || used[p.second.first][p.second.second]++) continue;\n        ret++;\n        int x = p.second.first, y = p.second.second;\n        for(int i = 0; i < 6; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if(!mas[ny][nx]) {\n                q.push(iiP(p.first - 1, iP(nx, ny)));\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, t;\n    while(cin >> t >> n, t) {\n        memset(mas, 0, sizeof(mas));\n        for(int i = 0; i < n; i++) {\n            int x, y; cin >> x >> y;\n            mas[y + 30][x + 30] = 1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        cout << bfs(t, sx + 30, sy + 30) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[] = {-1, -1,  0, 0, 1, 1};\nint dy[] = {-1,  0, -1, 1, 0, 1};\nbool Field[1000][1000];\n\nvoid solve()\n{\n\tint t, n;\n\twhile(cin >> t >> n, t || n)\n\t{\n\t\tmemset(Field, 0, sizeof(Field));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x ,y;\n\t\t\tcin >> x >> y;\n\t\t\tField[y + 500][x + 500] = true;\n\t\t}\n\t\tint count = 1;\n\t\tP p;\n\t\tcin >> p.first >> p.second;\n\t\tp.first += 500;\n\t\tp.second += 500;\n\t\tqueue<P> Que;\n\t\tQue.push(p);\n\t\tField[p.second][p.first] = true;\n\t\tqueue<P> NextQue;\n\t\tfor(int a = 0; a < t; ++a)\n\t\t{\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tP p1 = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor(int i = 0; i < 6; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = p1.first + dx[i];\n\t\t\t\t\tnext.second = p1.second + dy[i];\n\t\t\t\t\tif(Field[next.second][next.first] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tField[next.second][next.first] = true;\n\t\t\t\t\t\tNextQue.push(next);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n\nint data[100][100]={};\nint t,n;\n\n\nint main(){\n    while(cin>>t>>n){\n        if(t==0 && n==0)break;\n        \n        rep(i,100)rep(j,100)data[i][j]=100;\n        \n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            x+=50;y+=50;\n            data[y][x]=-1;\n        }\n        int a,b;\n        cin>>a>>b;\n        a+=50;b+=50;\n        data[b][a]=0;\n        \n        int dx[]={0,1,1,0,-1,-1};\n        int dy[]={1,1,0,-1,-1,0};\n        \n        for(int time=1;time<=t;time++){\n            rep(i,100){\n                rep(j,100){\n                    if(data[i][j]==time-1){\n                        rep(k,6){\n                            if(data[i+dy[k]][j+dx[k]]!=-1) data[i+dy[k]][j+dx[k]]=min(data[i+dy[k]][j+dx[k]],time);\n                        }\n                    }\n                    \n                }\n            }\n        }\n        int c=0;\n        rep(i,100){\n            rep(j,100){\n                if(data[i][j]!=-1 && data[i][j]!=100)c++;\n            }\n        }\n        \n        cout<<c<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n-1;i++){\n            cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 35;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) + abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst int offset = 30;\nconst int SIZE = 2 * offset + 1;\nconst int INF = 1e9;\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, 1, 0, -1, 1, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < SIZE && 0 <= y && y < SIZE;\n}\n\nint bfs(int t, int n) {\n    set<P> blocks;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        blocks.insert(P(x + offset, y + offset));\n    }\n\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += offset;\n    sy += offset;\n\n    queue<P> que;\n    que.push(P(sx, sy));\n    VV d(SIZE, V(SIZE, INF));\n    d[sx][sy] = 0;\n\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        rep(k, 6) {\n            int nx = p.first + dx[k], ny = p.second + dy[k];\n            if (inside(nx, ny) && blocks.count(P(nx, ny)) == 0 && d[nx][ny] == INF) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, SIZE) {\n        rep(j, SIZE) {\n            if (d[i][j] <= t) {\n                ans++;\n            }\n        }\n    }\n\n    return ans;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int t, n;\n    while (cin >> t >> n, t) {\n        cout << bfs(t, n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int MID = 50;\nconst int INF = 1 << 28;\nint dx[] = { 0, 1, 1, 0, -1, -1 }, dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid dfs ( int x, int y, int t, VVI& m )\n{\n\tif ( !t || m[y][x] == -1 ) {\n\t\treturn;\n\t}\n\tfor ( int d = 0; d < 6 ; ++d ) {\n\t\tint nx = x + dx[d],\n\t\t\tny = y + dy[d];\n\t\tif ( m[ny][nx] > m[y][x] + 1 ) {\n\t\t\tm[ny][nx] = m[y][x] + 1;\n\t\t\tdfs( nx, ny, t - 1, m );\n\t\t}\n\t}\n}\n\nint main() {\n\tint t, n;\n\twhile ( cin >> t >> n, t | n ) {\n\t\tVVI m( 2 * MID, VI( 2 * MID, INF ) );\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tm[y + MID][x + MID] = -1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\t\n\t\tm[sy + MID][sx + MID] = 0;\n\t\tdfs( sx + MID, sy + MID, t, m );\n\t\t\n\t\tint ans = 0;\n\t\tfor ( int y = 0; y < 2 * MID; ++y ) {\n\t\t\tfor ( int x = 0; x < 2 * MID; ++x ) {\n\t\t\t\tint val = m[y][x];\n\t\t\t\tans += 0 <= val && val <= t;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint dx[] = { 0,1,1,0,-1,-1 };\nint dy[] = { 1,1,0,-1,-1,0 };\n\nbool table[1000][1000];\nbool k[1000][1000];\n\nint t, n;\n\nvoid solve(int sy, int sx) {\n\tqueue<pair<P, int>> que;\n\ttable[sy][sx] = 1;\n\tque.push({ {sy,sx},0 });\n\twhile (que.size()) {\n\t\tpair<P, int> p = que.front();\n\t\tque.pop();\n\t\tif (p.second == t)continue;\n\t\trep(i, 6) {\n\t\t\tint ny = p.first.first + dy[i], nx = p.first.second + dx[i];\n\t\t\tif (!k[ny][nx] && !table[ny][nx]) {\n\t\t\t\tque.push({ { ny,nx }, p.second + 1 });\n\t\t\t\ttable[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> t >> n&&t + n) {\n\t\trep(i, 1000)rep(j, 1000) {\n\t\t\ttable[i][j] = 0;\n\t\t\tk[i][j] = 0;\n\t\t}\n\t\trep(i, n) {\n\t\t\tint y, x;\n\t\t\tcin >> x >> y;\n\t\t\tk[500 + y][500 + x] = 1;\n\t\t}\n\t\tint sy, sx;\n\t\tcin >> sx >> sy;\n\t\tsolve(sy + 500, sx + 500);\n\t\tint ans = 0;\n\t\trep(i, 1000)rep(j, 1000)ans += (table[i][j] && !k[i][j]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\n\n#define TEST 0\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./ans.txt\", \"w\", stdout);\n#endif\n\nusing namespace std;\n\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nmap<pair<int, int>, bool> state;\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 0;\n\tstate[make_pair(nx,ny)] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\t\tans++;\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[make_pair(nx + dx[i],ny + dy[i])]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\t\t\t\t\tstate[make_pair(nx+dx[i], ny+dy[i])] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[make_pair(x,y)]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\tcout << f(sx, sy, 0) << endl;\n\n\t\tstate.clear();\n\n\t}\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint field[100][100];\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tqueue< pair<int,int> > point;\n\t\tpoint.push(make_pair(s_x+50,s_y+50));\n\t\tint sum = 0;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tint p_x = point.front().first, p_y = point.front().second;\n\t\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] != -1){point.push(make_pair(p_x-1,p_y));}}\n\t\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] != -1){point.push(make_pair(p_x,p_y-1));}}\n\t\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] != -1){point.push(make_pair(p_x+1,p_y));}}\n\t\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] != -1){point.push(make_pair(p_x,p_y+1));}}\n\t\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] != -1){point.push(make_pair(p_x-1,p_y-1));}}\n\t\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] != -1){point.push(make_pair(p_x+1,p_y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <utility>\n \n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define REG(i, a, b) for (int (i) = ((int)(a)); (i) < ((int)(b)); i++)\n#define ALL(V) (V).begin(), (V).end()\n#define PRINT(STR) cout << (STR) << endl\n#define ROUNDED(N) fixed << setprecision(N)\n#define SPACE \" \"\n \ntypedef long long ll;\nusing namespace std;\n \nint nextInt() { int n; cin >> n; return n; }\ndouble nextDouble() { double d; cin >> d; return d; }\nstring nextString() { string str; cin >> str; return str; }\n \nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {1,0,-1,-1,0,1};\nstruct points{int x,y,turn;};\nconst int def = 60;\nint main() {\n    cin.tie(0); //??????±?????????????????????\n    ios::sync_with_stdio(false); //printf???¨???±??????????????????\n \n    int t,n;\n    while(cin>>t>>n,t||n){\n        vector<vector<int>> mp(def*2+1,vector<int>(def*2+1,0));\n\tvector<vector<int>> memp(def*2+1,vector<int>(def*2+1,0));\n        REP(i,n){\n            int a = nextInt()+def;\n            int b = nextInt()+def;\n            mp[a][b] = 1;\n        }\n        queue<points> que;\n        points start;\n        start.x=nextInt()+def;start.y=nextInt()+def;start.turn=t;\n        que.push(start);\n        int ct = 0;\n        while(que.size()){\n            int x = que.front().x;\n            int y = que.front().y;\n            int nowturn = que.front().turn;\n            que.pop();\n\t     \n            if(mp[x][y]==0){\n                ct++;\n                mp[x][y] = 1;\n            }\n\t    if(nowturn>memp[x][y])\n\t      memp[x][y] = nowturn;\n\t    else continue;\n            if(nowturn==0)continue;\n            REP(i,6){\n                points ne;\n                ne.x = x + dx[i];\n                ne.y = y + dy[i];\n                if(ne.x<0||ne.x>def*2||ne.y<0||ne.y>def*2)continue;\n                if(mp[ne.x][ne.y]==0){//||ne.x*ne.x+ne.y*ne.y>900\n                    ne.turn = nowturn - 1;\n                    que.push(ne);\n                }\n            }\n        }\n        cout << ct << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n\n//???????????????\nint di[6] = {1, 1, 0, -1, -1, 0};\nint dj[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\n    while(1){\n\n        int n, t; cin >> t >> n;\n        if(n == 0 && t == 0) break;\n        vector<vector<bool> > canGo(100, vector<bool> (100, true));\n        for(int k = 0; k < n; k++){\n            int i, j; cin >> i >> j;\n\n            //??§?¨???????\n            i += 40;\n            j += 40;\n            canGo[i][j] = false;\n        }\n        int si, sj; cin >> si >> sj;\n        si += 40;\n        sj += 40;\n\n        //???????????????s????????±????????\\??????????????????????????¢????????????\n        queue<pair<int, pair<int, int> > > wait;\n        wait.push(make_pair(0, make_pair(si, sj)));\n        canGo[si][sj] = false;\n\n        //??\\???????????????\n        int counter = 1;\n        while(!wait.empty()){    //?????\\???????????????????????§\n            //?????\\????????????????´????????????????\n            int nowcost = wait.front().first;\n            int nowi = wait.front().second.first;\n            int nowj = wait.front().second.second;\n\n            wait.pop();\n\n            //???????????°??????????????????????????¢?´¢?????????\n            if(nowcost == t){\n                continue;\n            }\n\n            //??????????????¢?´¢\n            for(int k = 0; k < 6; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //??????????????????????????????\n                if(canGo[nexti][nextj]){\n                    //????????????????????\\???????????????\n                    //??????????´¢???????????¨????????????????£???§?????????\n                    wait.push(make_pair(nowcost + 1, make_pair(nexti, nextj)));\n                    canGo[nexti][nextj] = false;\n                    counter++;\n                }\n            }\n        }\n\n        cout << counter << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 30;\n\nint dx[6] = {-1, 0, 1, 1, 0, -1};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\tint t, n;\n\tint field[90][90];\n\twhile(cin >> t >> n, t+n){\n\t\tt += 2;\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 90)rep(j, 90) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tfield[sx][sy] = 1;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(sx, sy));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y] == t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(abs(nx-d) <= 30 && abs(ny-d) <= 30 && field[nx][ny] != -1 && (field[x][y]+1 < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\trep(i, 90)rep(j, 90) if(0 < field[i][j]) count++;\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<set>\nusing namespace std;\n\nint dx[]={1,1,0,-1,-1,0};\nint dy[]={1,0,-1,-1,0,1};\n\nint ans;\nset<pair<int,int> > OB;\nset<pair<int,int> > D;\nint t,n;\n\nvoid dfs(int x,int y,int turn){\t\n\tif(OB.count(make_pair(x,y))) return;\n\tif(D.count(make_pair(x,y))) return;\n\tD.insert(make_pair(x,y));\n\tans++;\n\tif(turn==t) return;\n\tfor(int r=0;r<6;r++)\n\t\tdfs(x+dx[r],y+dy[r],turn+1);\n}\n\nint main()\n{\n\twhile(cin>>t>>n && t!=0){\n\t\tans=0;\n\t\tOB.clear();\n\t\tD.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tOB.insert(make_pair(x,y));\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tdfs(x,y,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+30, x.back()+30));\n    int cnt = 0;\n    while(!que.empty()){\n        if(cnt > n) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            if(graph[cur.first][cur.second] > cnt){\n                graph[cur.first][cur.second] = cnt;\n            }\n            REP(i, 6){\n                if(graph[cur.first + dy[i]][cur.second + dx[i]] > i){\n                    que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 61) REP(j, 61) if(abs(graph[i][j]) != INF){\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 61){\n            REP(j, 61){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            graph[30 + y[i]][30 + x[i]] = -INF;\n        }\n        graph[30 + y.back()][30 + x.back()] = 0;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nbool isRange(int x,int y){\n\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main(){\n    int t,n;\n    int dx[6]={1,1,0,-1,-1,0};\n    int dy[6]={1,0,-1,-1,0,1};\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        int cnt=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        while(!q.empty()){\n            auto state=q.front();\n            q.pop();\n            auto p=state.first;\n            int turn=state.second;\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isRange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n                }\n\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[62][62];\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = t+1;\n\tif(t==0) return;\n\tfor(int i=0;i<6;i++){\n\t\tint x2 = x+dx[i];\n\t\tint y2 = y+dy[i];\n\t\tif(x2<0 || 61<x2 || y2<0 || 61<y2) continue;\n\t\tif(hoge[x2][y2] != -1 && hoge[x2][y2] <= t-1){\n\t\t\tf(x2, y2, t-1, ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<62;i++){\n\t\t\tfor(int j=0;j<62;j++){\n\t\t\t\thoge[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 30;\n\t\ty += 30;\n\t\t\n\t\tint ans = 0;\n\t\tf(x, y, t, ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 30;\n\nint dx[6] = {-1, 0, 1, 1, 0, -1};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\tint t, n;\n\tint field[90][90];\n\twhile(cin >> t >> n, t+n){\n\t\tt += 2;\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 90)rep(j, 90) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tfield[sx][sy] = 1;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(sx, sy));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y]+1 == t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(abs(nx-d) <= 30 && abs(ny-d) <= 30 && field[nx][ny] != -1 && (field[x][y]+1 < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\trep(i, 90)rep(j, 90) if(0 < field[i][j]) count++;\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#include <queue>\n#define MAXX 60\n#define MAXY 60\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\nint ccc;\n\nqueue<pair<int,pair<int,int> > > q;\n\n\nint solve(int x,int y,int depth){\n\tccc=0;\n\tq.push(pair<int,pair<int,int> >(x,pair<int,int>(y,depth)));\n\twhile(!q.empty()){\n\t\tint cx,cy,cd;\n\t\tpair<int,pair<int,int> > frt = q.front();\n\t\tq.pop();\n\t\tcx=frt.first;\n\t\tcy=frt.second.first;\n\t\tcd=frt.second.second;\n\t\tif(!flg[cx][cy]) ccc++;\n\t\tflg[cx][cy]=true;\n\t\tif(cd>0){\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nnx = (cx+xd[i])%MAXX;\n\t\t\t\tint nny = (cy+yd[i])%MAXY;\n\t\t\t\tint nnd = cd-1;\n\t\t\t\tif(mp[nnx][nny] && !flg[nnx][nny])\n\t\t\t\t\tq.push(pair<int,pair<int,int> >(nnx,pair<int,int>(nny,nnd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn ccc;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\nint mtx[601][601]={0};\n\nint main(){\n    int t,n,x,y;\n    while(1){\n        queue< pair<int,pair<int,int> > > que;\n        fill(mtx[0],mtx[600],0);\n        scanf(\"%d %d\",&t,&n);\n        if(!t && !n){break;}\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&x,&y);\n            mtx[x+300][y+300]=-1;\n        }\n        scanf(\"%d %d\",&x,&y);\n        mtx[x+300][y+300]=1;\n        que.push(make_pair(0,make_pair(x+300,y+300)));\n        int cnt=0;\n        while(!que.empty()){\n            pair< int,pair<int,int> > p=que.front();\n            que.pop();\n            if(p.first>t){break;}\n            for(int j=0;j<6;j++){\n                int tx=p.second.first+dx[j];\n                int ty=p.second.second+dy[j];\n                int tu=p.first+1;\n                if(mtx[tx][ty]==0){\n                    mtx[tx][ty]=1;\n                    que.push(make_pair(tu,make_pair(tx,ty)));\n                }\n            }\n            cnt++;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ma[200][200],ans;\n \nvoid dfs(int x,int y,int t){\n  if(t==0)return;\n  if(ma[x-1][y]<t)ma[x-1][y]?:ans++,ma[x-1][y]=t,dfs(x-1,y,t-1);\n  if(ma[x+1][y]<t)ma[x+1][y]?:ans++,ma[x+1][y]=t,dfs(x+1,y,t-1);\n  if(ma[x][y-1]<t)ma[x][y-1]?:ans++,ma[x][y-1]=t,dfs(x,y-1,t-1);\n  if(ma[x][y+1]<t)ma[x][y+1]?:ans++,ma[x][y+1]=t,dfs(x,y+1,t-1);\n  if(ma[x-1][y-1]<t)ma[x-1][y-1]?:ans++,ma[x-1][y-1]=t,dfs(x-1,y-1,t-1);\n  if(ma[x+1][y+1]<t)ma[x+1][y+1]?:ans++,ma[x+1][y+1]=t,dfs(x+1,y+1,t-1);\n}\n \nint main(){\n  int n,t,x,y;\n  while(cin>>t>>n,t+n){\n    ans=1;\n    for(int i=0;i<200;i++)for(int j=0;j<200;j++)ma[i][j]=0;\n    for(int i=0;i<n+1;i++)cin>>x>>y,ma[x+100][y+100]=100;\n    dfs(x+100,y+100,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int, int> P;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t, n;\n  bool cango[100][100];\n  int vy[6] = {1,0,-1,-1,0,1};\n  int vx[6] = {1,1,0,-1,-1,0};\n  while(cin>>t>>n,t||n) {\n    FOR(i,0,100) FOR(j,0,100) cango[i][j] = true;\n    FOR(i,0,n) {\n      int x, y; cin >> x >> y;\n      cango[y+50][x+50] = false;\n    }\n    int sx, sy; cin >> sx >> sy;\n    int ans = 1;\n    queue<P> Q;\n    Q.push(P(sx+50, sy+50));\n    FOR(i,0,t) {\n      queue<P> tmp;\n      while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        int y = p.first;\n        int x = p.second;\n        FOR(j,0,6) {\n          int ny = y + vy[j];\n          int nx = x + vx[j];\n          if(!cango[ny][nx]) continue;\n          ans++;\n          tmp.push(P(ny, nx));\n          cango[ny][nx] = false;\n        }\n      }\n      while(!tmp.empty()) {\n        Q.push(tmp.front());\n        tmp.pop();\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_N 50\n#define MAX_M 100\n#define MAX_K 100\n\nint dx[] = { 1, 1, 0, -1, -1, 0 };\nint dy[] = { 0, 1, 1, 0, -1, -1 };\n\n\nvector<int> ans_list;\n\n\nint main(){\n\n\twhile (true){\n\n\t\tint t, n;\n\t\tcin >> t >> n;\n\n\t\tif (t == 0 && n == 0)\n\t\t\tbreak;\n\n\t\tmap<P, bool> obj;\n\t\tmap<P, bool> maze;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobj[P(x, y)] = true;\n\t\t}\n\t\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<P> que;\n\t\tqueue<int> turn;\n\t\tque.push(P(sx, sy));\n\t\tturn.push(t);\n\t\t\n\t\tmaze[P(sx, sy)] = true;\n\n\t\tint ans = 1;\n\n\t\twhile (que.size()){\n\t\t\tP p = que.front();\n\t\t\tint count = turn.front();\n\t\t\tque.pop();\n\t\t\tturn.pop();\n\t\t\tif (count == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif (!obj[P(nx, ny)] && !maze[P(nx, ny)] && nx >= -30 && nx <= 30 && -30 <= ny && ny <= 30){\n\t\t\t\t\tans++;\n\t\t\t\t\tmaze[P(nx, ny)] = true;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tturn.push(count - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans_list.push_back(ans);\n\n\t}\n\n\n\t\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct d\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MIN && map[i][j] != INT_MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define DIFF 30\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nbool point[61][61];\nbool searched[61][61];\nint recturn[61][61];\nP start;\n\nint dx[6] = {1, 0, -1, 0, 1, -1}, dy[6] = {0, 1, 0, -1, 1, -1};\n\nint bfs(int t, int n) {\n  queue<P> q1;\n  P temp;\n  int count = 0;\n  int turn = 0;\n  temp.first = start.first;\n  temp.second = start.second;\n  searched[temp.first + DIFF][temp.second + DIFF] = true;\n  recturn[temp.first + DIFF][temp.second + DIFF] = 0;\n  q1.push(temp);\n  count++;\n  while (q1.empty() == false) {\n    temp = q1.front();\n    q1.pop();\n    if (recturn[temp.first + DIFF][temp.second + DIFF] == t) break;\n    for (int i = 0; i < 6; i++) {\n      P s;\n      s.first = temp.first + dx[i];\n      s.second = temp.second + dy[i];\n      if (-30 <= s.first && s.first <= 30 && -30 <= s.second && s.second <= 30\n\t  && point[s.first + DIFF][s.second + DIFF]\n\t  && !searched[s.first + DIFF][s.second + DIFF]) {\n\tq1.push(s);\n\tsearched[s.first + DIFF][s.second + DIFF] = true;\n\trecturn[s.first + DIFF][s.second + DIFF]\n\t  = recturn[temp.first + DIFF][temp.second + DIFF] + 1;\n\tcount++;\n      }\n    }\n  }\n  return count;\n}\n\nint main() {\n  while (true) {\n    int t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) return 0;\n\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n\tpoint[i][j] = true;\n\tsearched[i][j] = false;\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x  >> y;\n      point[x + DIFF][y + DIFF] = false;\n    }\n\n    cin >> start.first >> start.second;\n\n    int ans = bfs(t, n);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int t, n;\n  int dx[] = {0,1,1,0,-1,-1};\n  int dy[] = {1,1,0,-1,-1,0};\n  \n  while(cin>>t>>n, t||n) {\n    bool ba[200][200];\n    memset(ba,0,sizeof(ba));\n    REP(i,n) {\n      int x, y;\n      cin >>x>>y;\n      ba[x+100][y+100] = 1;\n    }\n    int sx, sy;\n    cin >> sx>>sy;\n    typedef pair<int,int> pii;\n    typedef pair<int, pii> piii;\n    queue<piii> Q;\n    Q.push(piii(0,pii(sx+100,sy+100)));\n\n    bool visited[200][200] = {};\n    int res = 0;\n    while(!Q.empty()) {\n      int x = Q.front().second.first;\n      int y = Q.front().second.second;\n      int d = Q.front().first;\n\n//      cout << x << \" \" <<y<< endl;\n\n      Q.pop();\n      \n      if (d > t) break;\n      if (visited[x][y]) {\n        continue;\n      }\n\n      visited[x][y] = 1;\n      res++;\n      REP(k,6){\n        int xx =x+dx[k];\n        int yy = y+dy[k];\n        \n        if (ba[xx][yy]||visited[xx][yy]) continue;\n        Q.push(piii(d+1,pii(xx,yy)));\n        //   cout << xx << \" \" <<yy << endl;\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define MOD 100000\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct A{int x,y,c;};\nint dx[6]={-1,-1,0,0,1,1};\nint dy[6]={-1,0,1,-1,1,0};\nint main(){\n      int t,n,x,y,sx,sy;\n      while(cin>>t>>n&&(t!=0||n!=0)){\n            bool used[61][61];\n            memset(used,true,sizeof(used));\n            REP(i,n){cin>>x>>y;used[x+30][y+30]=false;}\n            cin>>sx>>sy;\n            int cnt=1;used[sx+30][sy+30]=false;\n            queue<A> Q;\n            Q.push((A){sx+30,sy+30,0});\n            while(!Q.empty()){\n                  //cout<<Q.size()<<endl;\n                  A a=Q.front();Q.pop();\n                  if(a.c>=t)continue;\n                  REP(i,6){\n                        int nx=a.x+dx[i],ny=a.y+dy[i];\n                        //cout<<nx<<\" \"<<ny<<endl;\n                        if(nx>60||nx<0||ny>60||ny<0)continue;\n                        if(used[nx][ny]){\n                              //cout<<nx<<\" \"<<ny<<endl;\n                              used[nx][ny]=false;\n                              Q.push((A){nx,ny,a.c+1});\n                              cnt++;\n                        }\n                  }\n            }\n            cout<<cnt<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n, block[100][100];\nbool used[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, false, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = 1;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,pair<int,int> > > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a;i < b;i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n) memset(n,0,sizeof(n))\n\nint dx[6] = { 0, -1, -1, 0, 1, 1 }, dy[6] = { 1, 0, -1, -1, 0, 1 };\nbool cheak(int x, int y, int mx, int my){ return x >= 0 && y >= 0 && x < mx && y < my; }\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint main(){\n\n\tint t, n;\n\n\twhile (cin >> t >> n && t){\n\n\t\tconst int M = 50;\n\t\tint d[M * 3][M * 3]; clr(d);\n\t\tbool f[M * 3][M * 3]; clr(f);\n\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\td[y + M][x + M] = 1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tsx += M, sy += M;\n\n\t\tqueue<T> q;\n\t\tq.push(T(sy, sx, 0));\n\t\tf[sy][sx] = true;\n\n\t\twhile (q.size()){\n\n\t\t\tT nx = q.front(); q.pop();\n\n\t\t\trep(i, 6){\n\t\t\t\tint ty = get<0>(nx) + dy[i], tx = get<1>(nx) + dx[i];\n\n\t\t\t\tif (!d[ty][tx] && !f[ty][tx] && get<2>(nx) < t){\n\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\tq.push(T(ty, tx, get<2>(nx)+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, M * 3)rep(j, M * 3){\n\t\t\tif (f[i][j])ans++;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*cout <<\"Debug\"\ncout <<x-30<<' '<<y-30<<endl;*/\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[61][61];\nint cnt = 0;\nint d_x[] = {1,1,0,-1,0,-1};\nint d_y[] = {1,0,1,0,-1,-1};\nint t;\n/*\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cout <<\"Debug \";\n  cout <<x-30<<' '<<y-30<<endl;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  int used[6] = {0};\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(watasi < t)&&(mp[nx][ny] == 0)){\n        dfs(nx,ny,watasi);\n        used[dx] = 1;\n    }\n    for(int i = 0;i<6;i++){\n      if(used[i]){\n        if((nx == x + d_x[i])&&(ny == y + d_y[i])){\n          dfs(nx,ny,watasi);\n        }\n      }\n    }\n    }\n}\n*/\nint main(){\n  int n,t;\n\n  cin >>t>>n;\n  while(!((t == 0)&&(n == 0))){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<61;i++){\n      for(int j = 0;j<61;j++){\n        mp[i][j]=-1;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+30][y+30] = 1;\n    }\n    cin >>fx>>fy;\n\n    cnt = 0;\n\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(fx+30,fy+30));\n    mp[fx+30][fy+30] = 0;\n    while (!qu.empty()) {\n      pair<int ,int> pr = qu.front();\n      qu.pop();\n      int nx = pr.first,ny= pr.second;\n      cnt++;\n      if(mp[nx][ny] == t)continue;\n      for(int i = 0;i<6;i++){\n        int cx = nx+d_x[i],cy = ny+d_y[i];\n        if(mp[cx][cy] != -1)continue;\n        mp[cx][cy] = mp[nx][ny] + 1;\n        qu.push(make_pair(cx,cy));\n      }\n    }\n\n    ansl.push_back(cnt);\n    cin >>t>>n;\n  }\n\n  for(int i = 0;i<(int)ansl.size();i++){\n    cout <<ansl[i]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nint ans;\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nstruct point{\n\tint x,y,cost;\n};\ntypedef struct point P;\n\nvoid solve(int f[200][200] , int t , queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << f[p_] << endl;\n\t\tif( p.cost+1 > t )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = p.x + dx[i];\n\t\t\tint my = p.y + dy[i];\n\t\t\tif( abs(mx-100) > 30 || abs(my-100) > 30 || f[my][mx] != 0 ) continue;\n\t\t\t\n\t\t\tP p_;\n\t\t\tp_.x = mx;\n\t\t\tp_.y = my;\n\t\t\tp_.cost = p.cost + 1;\n\t\t\tf[my][mx] = 1;\n\t\t\tans++;\n\t\t\tque.push( p_ );\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tint f[200][200] = {0};\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 100;\n\t\t\ty += 100;\n\t\t\tf[y][x] = -1;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100;\n\t\tsy += 100;\n\t\tP sp;\n\t\tsp.x = sx;\n\t\tsp.y = sy;\n\t\tsp.cost = 0;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tf[sy][sx] = 1;\n\t\tans = 1;\n\t\tsolve( f , t , que );\n\t\t\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define N 100\n#define G 50\n#define KABE -1\n#define NON  0\n\nint map[N][N];\n\nint ans;\nvoid dfs(int x, int y, int t ){\n  if( t==0 )\n    return;\n  if( map[x][y] == KABE )\n    return;\n\n  if( abs(x-G) > 30 ||  abs(y-G) > 30 )\n    return;\n\n  if( map[x][y] >= t )\n    return;\n\n  if( map[x][y] == NON )\n    ans++;\n  map[x][y] = t;\n\n\n  t--;\n  int dx[] = {1,1,0,-1,-1, 0};\n  int dy[] = {0,1,1, 0,-1,-1};\n  for( int d=0;d<6;d++ )\n    dfs(x+dx[d], y+dy[d], t );\n}\n\nint main(){\n  int t,n;\n  while( cin>>t>>n && (t|n) ){\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\tmap[i][j] = NON;\n\n    int y,x;\n    while( n-- ){\n      cin >> x >> y;\n      map[x+G][y+G] = KABE;\n    }\n    cin >> x >> y;\n\n    x+=G; y+=G;\n    ans = 0;\n    dfs(x, y, t+1 );\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\n\n// s[y][x] := ツ鳴「ツ探ツ催オツづ個づ?つォINF, ツ探ツ催オツ催渉づ敖づ個づ?つォツタツーツδ督青板つェツ禿シツづゥ\nint s[100][100];\n// b[P(x,y)] := ツ津環づェツづ按つ「ツづ?つォtrue\nint b[100][100];\n\nint bfs(int sx , int sy , int t ){\n\ts[sy][sx] = 0;\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tint cnt = s[y][x];\n\t\tq.pop();\n\t\t\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx > 60 || my > 60 ) continue;\n\t\t\tif( b[my][mx] ) continue;\n\t\t\t \n\t\t\tif( cnt + 1 <= t && s[my][mx] == INF ){\n\t\t\t\ts[my][mx] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint result = 0;\n\tfor(int y=0 ; y <= 60 ; y++ ){\n\t\tfor(int x = 0 ; x <= 60 ; x++ ){\n\t\t\tif( s[y][x] != INF ){\n\t\t\t\tresult++;\n\t\t\t} \n\t\t}\n\t}\n\tif( result == 0 ) result = 1;\n\treturn result;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\t\n\t\tfor(int y = 0 ; y < 100 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 100 ; x++ ){\n\t\t\t\ts[y][x] = INF;\n\t\t\t\tb[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\tb[y][x] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = bfs( sx+30 , sy+30 , t );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nbool visited[61][61];\n\nvoid visit(int t, int x, int y) {\n  visited[x][y] = true;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y]) visit(t-1, x-1, y);\n  if (y > 0 && !map[x][y-1]) visit(t-1, x, y-1);\n  if (x > 0 && y > 0 && !map[x-1][y-1]) visit(t-1, x-1, y-1);\n  if (x < 60 && !map[x+1][y]) visit(t-1, x+1, y);\n  if (y < 60 && !map[x][y+1]) visit(t-1, x, y+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1]) visit(t-1, x+1, y+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = visited[i][j] = false;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (visited[i][j]) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 1, 0,-1};\nconst int dy[] = {1, 0,-1, 1,-1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[66][66];\n        bool w[66][66];\n        for (int i = 0; i < 66; i++) {\n            for (int j = 0; j < 66; j++) {\n                d[i][j] = INF;\n                w[i][j] = true;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 30][t2 + 30] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 30][y + 30] = 0;\n        w[x + 30][y + 30] = false;\n        queue<P> q;\n        q.push(P(x + 30, y + 30));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (0 <= nx && nx <= 60 && 0 <= ny && ny <= 60 && d[nx][ny] != -1) {\n                    if (d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                        if (w[nx][ny]) count++, w[nx][ny] = false;\n                        q.push(P(nx,ny));\n                        d[nx][ny] = d[p.first][p.second] + 1;\n                    }\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n\nbool mapAc(map<int,map<int,bool> > &mp, int x,int y){\n\tif(mp.find(x)!=mp.end()){\n\t\tif(mp[x].find(y)!=mp[x].end()){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint solve(int x,int y,int depth,map<int,map<int,bool> > &mp){\n\n\tmap<int,map<int,bool> > flgg;\n\n\tint cnt=0;\n\tqueue<pair<int,pair<int,int> > > q;\n\tq.push(pair<int,pair<int,int> >(x,pair<int,int>(y,depth)));\n\n\twhile(!q.empty()){\n\t\tint cx,cy,cd;\n\t\tpair<int,pair<int,int> > frt = q.front();\n\t\tq.pop();\n\t\tcx=frt.first;\n\t\tcy=frt.second.first;\n\t\tcd=frt.second.second;\n\t\tif(!mapAc(flgg,cx,cy)){\n\t\t\tif(cd>0){\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tint nnx = cx+xd[i];\n\t\t\t\t\tint nny = cy+yd[i];\n\t\t\t\t\tint nnd = cd-1;\n\t\t\t\t\tif(!mapAc(mp,nnx,nny) && !mapAc(flgg,nnx,nny))\n\t\t\t\t\t\tq.push(pair<int,pair<int,int> >(nnx,pair<int,int>(nny,nnd)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tflgg[cx][cy]=true;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\n\t\tmap<int,map<int,bool> > mpp;\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmpp[x][y]=true;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve(x,y,t,mpp) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nvoid solve(int t, int n) {\n    int cnt = 0;\n    vector<vector<bool>> used(1000, vector<bool>(1000, false));\n    int dx[] = {0, 0, -1, -1, 1, 1};\n    int dy[] = {-1, 1, -1, 0, 0, 1};\n    set<PII> block;\n    PII start;\n    REP(_, n) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        used[x + 500][y + 500] = true;\n    }\n    int x, y; scanf(\"%d%d\", &x, &y);\n    start = MP(x + 500, y + 500);\n    queue<pair<PII, int>> q;\n    q.push(MP(start, 0));\n    while (!q.empty()) {\n        auto buf = q.front(); q.pop();\n        PII now = buf.first;\n        if (buf.second > t) continue;\n        if (used[now.first][now.second]) continue;\n        used[now.first][now.second] = true;\n        cnt++;\n        REP(i, 6) {\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n            //if (!inside(MP(nx, ny))) continue;\n            q.push(MP(MP(nx, ny), buf.second + 1));\n        }\n    }\n    cout << cnt << endl;\n    return;\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    while (cin >> n >> m, n) {\n        solve(n, m);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define ini 100\nusing namespace std ;\n\ntypedef pair<int,int> P ;\n\nqueue<P> q ;\nint dx[] = {0,1,1,0,-1,-1} ;\nint dy[] = {1,1,0,-1,-1,0} ;\n\nint main(){\n\t\n\tint t , n ;\n\tint x , y ;\n\tint ans ;\n\tint field[200][200] ;\n\t/*\n\t1:コスト(1インデックス)\n\t0:空き地\n\t-1:障害物\n\t*/\n\t\n\twhile( cin >> t >> n , t ){\n\t\t\n\t\t\n\t\tfor( int i=0 ; i<200 ; i++ ){\n\t\t\tfor( int j=0 ; j<200 ; j++ ){\n\t\t\t\tfield[i][j] = 0 ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 1 ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> x >> y ;\n\t\t\tfield[y+ini][x+ini]  = -1 ;\n\t\t}\n\t\t\n\t\tcin >> x >> y ;\n\t\t\n\t\tq.push( P(x+ini,y+ini) ) ;\n\t\tfield[y+ini][x+ini] = 1 ;\n\t\t\n\t\tint j=0 , k=0 ;\n\t\twhile( !q.empty() ){\n\t\t\tx = q.front().first ;\n\t\t\ty = q.front().second ;\n\t\t\t//cout << \"OK\" << endl ;//--------------------\n\t\t\t//if( field[y][x] > t+1 ) break ;\n\t\t\t//                 ↑ここ+1したら通ってしまった\n\t\t\tfor( int i=0 ; i<6 && field[y][x] <= t ; i++ ){\n\t\t\t\tif( field[y+dy[i]][x+dx[i]] == 0 ){\n\t\t\t\t\tfield[y+dy[i]][x+dx[i]] = field[y][x]+1 ;\n\t\t\t\t\tq.push( P(x+dx[i],y+dy[i]) ) ;\n\t\t\t\t\t//cout<<\"# \"<<x-ini<<\" \"<<y-ini<<endl;\n\t\t\t\t\tans++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop() ;\n\t\t}\n\t\t\n\t\tcout << ans << endl ;\n\t\t\n\t\twhile( !q.empty()  ){\n\t\t\tq.pop() ;\n\t\t}\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define WH 300\n\nint dx[6]={ 1, 1, 0,-1,-1, 0};\nint dy[6]={ 1, 0,-1,-1, 0, 1};\n\nint main(int argc, char const *argv[])\n{\n\tint t,n;\n\tint x,y;\n\tint sx,sy;\n\n\tint f[WH][WH];\n\tint cnt;\n\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t+n==0) break;\n\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tf[i1][i2]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i1=0;i1<n;i1++){\n\t\t\tcin>>x>>y;\n\t\t\tf[y+150][x+150]=-1;\n\t\t}\n\n\t\tcin>>sx>>sy;\n\n\t\tqueue<pair<int,int> > q;\n\t\tq.push(make_pair(sx+150,sy+150));\n\n\t\twhile(!q.empty()){\n\t\t\tx=q.front().first;\n\t\t\ty=q.front().second;\n\t\t\tq.pop();\n\n\t\t\tfor(int i1=0;i1<6;i1++){\n\t\t\t\tif(f[y+dy[i1]][x+dx[i1]]==0 && f[y][x]<t){\n\t\t\t\t\tif(x+dx[i1]==sx+150 && y+dy[i1]==sy+150){}\n\t\t\t\t\telse {\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]]=f[y][x]+1;\n\t\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt=1;\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tif(f[i1][i2]>0)cnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\nstruct enter{\n  int x,y,cost;\n};\n\nint main()\n{\n  int use[200][200],wall[200][200];\n  int t,n,x,y,sx,sy;\n  int dx[] = { 0, 1, 1, 0, -1, -1 };\n  int dy[] = { 1, 1, 0, -1, -1, 0 };\n\n\n  while(cin>>t>>n)\n    {\n      if(t==0&&n==0)\n\tbreak;\n\n      memset(use,0,sizeof(use));\n      memset(wall,0,sizeof(wall));\n\n      for(int i=0;i<n;i++)\n\t{\n\tcin>>x>>y;\n\twall[x+100][y+100]=1;\n\t}\n\n      cin>>sx>>sy;\n\n      queue<enter> q;\n      enter f;\n      f.x=sx+100;f.y=sy+100;f.cost=0;\n      q.push(f);\n      use[f.x][f.y]=1;\n      int ans=1;\n\n      while(!q.empty())\n\t{\n\t  enter now=q.front();\n\t  q.pop();\n\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      int x=now.x+dx[i],y=now.y+dy[i];\n\t    if(!use[x][y]&&!wall[x][y]&&(t>now.cost))\n\t      {\n\t\t//cout<<x<<' '<<y<<endl;\n\t\tans++;\n\t\tenter p__;\n\t\tp__.x=x;p__.y=y;p__.cost=now.cost+1;\n\t\tq.push( p__ );\n\t\tuse[x][y]=1;\n\t      }\n\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define ORIGIN 50\n\nint vx[6] ={1, 1, 0, 0, -1, -1};\nint vy[6] ={1, 0, 1, -1, 0, -1};\nint cell[100][100];\n\nint func(int x, int y, int turn){\n\tint ans=0;\n\n\tif(cell[y][x] >= turn || turn <= 0) return 0;\n\tif(cell[y][x] == 0)ans++;\n\tcell[y][x]=turn;\n\n\tfor(int i=0; i<6; i++){\n\t\tans += func(x+vx[i], y+vy[i], turn-1);\n\t}\n\treturn ans;\n}\n\n\nint main(void){\n\tint turn, n, x, y, tmp_x, tmp_y, ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\", &turn, &n);\n\t\tif(turn == 0 && n == 0) break;\n\n\t\tmemset(cell, 0, sizeof(cell));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d %d\", &tmp_x, &tmp_y);\n\t\t\tcell[tmp_y+ORIGIN][tmp_x+ORIGIN] =500;\n\t\t}\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tans = func(x+ORIGIN, y+ORIGIN, turn+1);\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nint map[500][500];\nint mapcnt[500][500];\nint t, n;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid search(int x, int y, int t){\n\tqueue<pair<pair<int, int>, int> > q;\n\tq.push(make_pair(make_pair(x,y),t));\n\twhile(!q.empty()){\n\t\tpair<pair<int, int>, int> p = q.front();\n\t\tq.pop();\n\t\tpair<int , int> id = p.first;\n\t\tif(map[id.first][id.second] != 0) continue;\n\t\tif(!p.second) continue;\n\t\tmap[id.first][id.second] = 1;\n\t\tfor(int i = 0; i < 6; i++){\n//printf(\"push : %d %d %d\\n\", id.first+dx[i], id.second+dy[i], p.second);\n\t\t\tif(map[id.first+dx[i]][id.second+dy[i]] != 0) continue;\n\t\t\tq.push(make_pair(make_pair(id.first+dx[i],id.second+dy[i]),p.second-1));\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x, y;\n\twhile(cin >> t >> n, t || n){\n\t\tfor(int i = 0; i < 500; i++) for(int j = 0; j < 500; j++){ mapcnt[i][j] = 0; map[i][j] = 0;}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x + 250][y + 250] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tsearch(x+250, y+250, t+1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 500; i++){\n\t\t\tfor(int j = 0; j < 500; j++){\n\t\t\t\tif(map[i][j] == 1) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MIN -1000\n#define MAX 10000\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint cd;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tfirst.cd = 0;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tint cd = d.cd;\n\t\t\tif (t <= cd)continue;\n\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (t <= cd)continue;\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == MIN)continue;\n\t\t\t\tif (map[ny][nx] != MAX)continue;\n\t\t\t\tmap[ny][nx] = cd + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.cd = cd + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != MIN && map[i][j] != MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\nint a[100][100];\nint vis[100][100];\nint dx[]={0,-1,-1,0,1,1};\nint dy[]={1,0,-1,-1,0,1};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,100){\n\t\t\trep(j,100){\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta[x+50][y+50]=1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint ans=0;\n\t\tsx+=50;\n\t\tsy+=50;\n\t\tqueue<pii> q;\n\t\tq.push(mkp(sx,sy));\n\t\ta[sx][sy]=1;\n\t\tans++;\n\t\trep(i,t){\n\t\t\tint qs=q.size();\n\t\t\trep(j,qs){\n\t\t\t\tpii top=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(l,6){\n\t\t\t\t\tint xx=top.F+dx[l];\n\t\t\t\t\tint yy=top.S+dy[l];\n\t\t\t\t\tif(a[xx][yy]==0){\n\t\t\t\t\t\tq.push(mkp(xx,yy));\n\t\t\t\t\t\ta[xx][yy]=1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\nint mass[150][150];\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nvoid dfs(int x, int y, int turn){\n  if(turn == 1) return;\n  REP(i, 6){\n    int nx = x + dx[i]; int ny = y + dy[i];\n    if(mass[nx][ny] < turn-1 and mass[nx][ny] >= 0) { mass[nx][ny] = turn-1; dfs(nx, ny, turn-1); }\n  }\n}\n\nint main(){\n  int t, n;\n  while(cin >> t >> n and t + n){\n    memset(mass, 0, sizeof(mass));\n    REP(i, n){\n      int x, y; cin >> x >> y;\n      mass[x+75][y+75] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    mass[sx+75][sy+75] = t+1;\n    dfs(sx+75, sy+75, t+1);\n    int res = 0;\n    REP(i, 150) REP(j, 150) if(mass[i][j] > 0) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\nconst int dy[] = { -1, -1, 0, 1, 1, 0 }, dx[] = { -1, 0, 1, 1, 0, -1 };\nbool mas[256][256], used[256][256];\n \nint main(){\n  int n, t;\n  while(cin >> t >> n , t || n){\n    fill_n( *mas, 256 * 256, false);\n    fill_n( *used, 256 * 256, false);\n    for(int i = 0 ; i < n ; i++ ){\n      int y, x;\n      cin >> x >> y;\n      mas[100 + y][100 + x] = true;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    int ret = 0;\n    queue< Pii > que;\n    que.push(Pii( t, Pi(sy + 100, sx + 100)));\n    while(!que.empty()){\n      Pii p = que.front();\n      que.pop();\n      if(p.fr < 0 || used[p.sc.fr][p.sc.sc]++) continue;\n      ret++;\n      for(int i = 0 ; i < 6 ; i++ ){\n        int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n        if(!mas[ny][nx]) que.push(Pii( p.fr - 1, Pi( ny, nx)));\n      }\n    }\n    cout << ret << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[] = {-1, -1,  0, 0, 1, 1};\nint dy[] = {-1,  0, -1, 1, 0, 1};\nbool Field[100][100];\n\nvoid solve()\n{\n\tint t, n;\n\twhile(cin >> t >> n, t || n)\n\t{\n\t\tmemset(Field, 0, sizeof(Field));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x ,y;\n\t\t\tcin >> x >> y;\n\t\t\tField[y + 50][x + 50] = true;\n\t\t}\n\t\tint count = 1;\n\t\tP p;\n\t\tcin >> p.first >> p.second;\n\t\tp.first += 50;\n\t\tp.second += 50;\n\t\tqueue<P> Que;\n\t\tQue.push(p);\n\t\tField[p.second][p.first] = true;\n\t\tqueue<P> NextQue;\n\t\tfor(int a = 0; a < t; ++a)\n\t\t{\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tP p1 = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor(int i = 0; i < 6; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = p1.first + dx[i];\n\t\t\t\t\tnext.second = p1.second + dy[i];\n\t\t\t\t\tif(Field[next.second][next.first] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tField[next.second][next.first] = true;\n\t\t\t\t\t\tNextQue.push(next);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nusing namespace std;\nint main(){\n\tint n,t;\n\twhile(cin>>t>>n,n||t){\n\t\tint in[200][200]={0};\n\t\tint a,b;\n\t\trep(i,n){\n\t\t\tcin>>a>>b;\n\t\t\tin[a+100][b+100]=-1;\n\t\t}\n\t\tcin>>a>>b;\n\t\ta+=100;b+=100;\n\t\tvi x(1,a),y(1,b);\n\t\tint dx[]={0,0,1,-1,1,-1};\n\t\tint dy[]={-1,1,0,0,1,-1};\n\t\tin[a][b]=1;\n\t\twhile(t--){\n\t\t\tvi tx,ty;\n\t\t\trep(i,x.size())rep(j,6){\n\t\t\t\tint xx=x[i]+dx[j],yy=y[i]+dy[j];\n\t\t\t\tif(!in[xx][yy]){\n\t\t\t\t\tin[xx][yy]=1;\n\t\t\t\t\ttx.pb(xx);\n\t\t\t\t\tty.pb(yy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx=tx;y=ty;\n\t\t}\n\t\tint co=0;\n\t\trep(i,200)rep(j,200)if(in[i][j]==1)co++;\n\t\tcout<<co<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dx[6] = {-1,-1, 0, 1, 1, 0};\nint dy[6] = {-1, 0, 1, 1, 0,-1};\n\nint bfs(int sy, int sx, int st, vvi& board, vvi& used){\n\n  queue<piii> que;\n  que.push(piii(pii(sy,sx),st));\n  \n  int ans = 0;\n  while(que.size()){\n    int y = que.front().first.first;\n    int x = que.front().first.second;\n    int t = que.front().second;\n    que.pop();\n    //    if(y > 60 || y < 0 || x > 60 || x < 0) continue; // ?£????\n    if(used[y][x]  == 1) continue;  // ??¢?´¢?????? \n    if(board[y][x] == 1) continue;;  // ?????????\n    if(t < 0) continue; // ???????????°??????\n    \n    ans++;\n    used[y][x] = 1; \n    for(int i=0; i<6; i++){\n      int nx = x + dx[i]; int ny = y + dy[i];\n      que.push(piii(pii(ny,nx),t-1));\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(!t and !n)break;\n    \n    vvi board(200,vi(200,0));\n    vvi used(200,vi(200,0));\n    for(int i=0; i<n; i++){\n      int x,y; cin >> x >> y;\n      board[y+100][x+100] = 1; // ?????????\n    }\n    int sx,sy; cin >> sx >> sy;\n    cout << bfs(sy+100,sx+100,t,board,used) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define repi(i, a, b) for( int i = a; i < b; i++ )\n#define m_t 30\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nvoid dfs( int x, int y, int a ){\n    //if( a >= t ) return;\n    rep(i, 6){\n        int nx = x + dx[i];\n        int ny = (y + dy[i]) * (m_t*2 + m_t*2+1-abs(y+dy[i])) / 2;\n        if( field[zero+nx+ny] != -1 ){\n            //cout << nx << ' ' << y+dy[i] << endl;\n            field[zero+nx+ny] = 1;\n            if( a+1 < t ) dfs(nx, y+dy[i], a+1);\n        }\n    }\n}\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 0 );\n        int x, y;\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = -1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 1;\n        dfs(sx, sy, 0);\n        cnt = 0;\n        /*queue<pair<int, int> > que;\n        que.push(mp(sx, sy));\n        while( !que.empty() ){\n            int cx = que.front().first;\n            int cy = que.front().second;\n            que.pop();\n            rep(i, 6){\n                int nx = cx + dx[i];\n                int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                if( field[zero+nx+ny] != -1 ){\n                    //cout << nx << ' ' << y+dy[i] << endl;\n                    field[zero+nx+ny] = field[zero+cx+cy]+1;\n                    //cnt++;\n                    if( field[zero+nx+ny] < t ) que.push(mp(nx, cy+dy[i]));\n                }\n            }\n        }*/\n        //cout << cx << ' ' << cy << endl;\n\n        rep(i, max){\n            if( field[i] == 1 ) cnt++;\n        }\n        cout << cnt << endl;\n        /*int l = 0;\n        rep(i, m_t*2+1){\n            rep(j, m_t*2+1-abs(m_t-i)){\n                cout << field[l++];\n            }\n            cout << endl;\n        }*/\n    }\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n;\n\tvvi field(63,vi(63,0));\n\tfor(auto y:{0,62})rep(x,63)field[y][x]=field[x][y]=1;\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=31,y+=31;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=1;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(i=0;i<n;i++){\n\t\t\t/*cin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;*/\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int FIRST = 60;\nconst int dx[6] = {0,1,-1,1,-1,0};\nconst int dy[6] = {1,1,0,0,-1,-1};\nconst int FIELD = 121;\nvoid bfs(vector<vector<int> > &map,int x1,int y1,int t){\n  queue<pair<int,int> > que;\n  que.push(pair<int,int>(x1,y1));\n  map[x1][y1] = 1;\n  while(!que.empty()){\n    int x,y;\n    pair<int,int> tmp = que.front();que.pop();\n    x = tmp.first;y = tmp.second;\n    if(map[x][y] > t) continue;\n    for(int i = 0;i < 6;i++){\n      if(x+dx[i] >= 0 && x+dx[i] < FIELD && y+dy[i] >= 0&& y+dy[i] < FIELD ){\n\tif(map[x+dx[i]][y+dy[i]] ==  0 ){\n\t  map[x+dx[i]][y+dy[i]] = map[x][y]+1;\n\t  que.push(pair<int,int>(x+dx[i],y+dy[i]));\n\t}\n      }\n    }\n  }\n  \n}\nint solve(vector<vector<int> > &map){\n  int ans = 0;\n  for(int i = 0;i < FIELD;i++){\n    for(int j = 0;j < FIELD;j++){\n      if(map[i][j] > 0){\n\tans++;\n      }\n    }\n  }\n  return ans;\n}\nvoid fun(vector<vector<int> > map){\n  for(int i = 20;i < 41;i++){\n    for(int j = 20;j < i;j++){\n      cout << \" \" ;\n    }\n    for(int j = 20;j < 41;j++){\n      if(map[j][i] == -1){\n\tcout << 9;\n      }else{\n\tcout << map[j][i];\n      }\n    }\n    cout << endl;\n  }\n\n}\nint main(){\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(t == 0 && n == 0)break;\n    vector<vector<int > > map(FIELD,vector<int>(FIELD,0));\n    for(int i = 0;i < n;i++){\n      int x,y;\n      cin >> x >> y;\n      map[FIRST+x][FIRST+y] = -1;\n    }\n    int f_x,f_y;\n    cin >> f_x >> f_y;\n    \n    bfs(map,FIRST+f_x,FIRST+f_y,t);\n    //    fun(map);\n    cout << solve(map) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto ele=q.front();\n            q.pop();\n            auto p=ele.first;\n            int turn=ele.second;\n            if(turn==t)\n                continue;\n            if(turn>t)\n                for(;;){}\n\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    if(turn==t)\n                    continue;\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint block[120][120];\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nint bfs(int step, int x, int y) {\n\tint ans = 1;\n\tint flag[120][120] = {};\n\tflag[x][y] = 1;\n\tvector<int> st{ step,x,y };\n\tqueue<vector<int> > stk;\n\tstk.push(st);\n\twhile(stk.size()) {\n\t\tvector<int> pos = stk.front();\n\t\tstk.pop();\n\t\tif(pos[0] > 0) {\n\t\t\tfor(int i = 0;i < 6;i++) {\n\t\t\t\tif(flag[pos[1] + dx[i]][pos[2] + dy[i]] == 0 && block[pos[1] + dx[i]][pos[2] + dy[i]] == 0) {\n\t\t\t\t\tflag[pos[1] + dx[i]][pos[2] + dy[i]] = 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tstk.push(vector<int>{pos[0] - 1, pos[1] + dx[i], pos[2] + dy[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint n, t;\n\tfor(cin >> t >> n;t != 0 || n != 0;cin >> t >> n) {\n\t\tfor(int i = 0;i < 120*120;i++) {\n\t\t\tblock[i % 120][i / 120] = 0;\n\t\t}\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tblock[x + 60][y + 60] = 1;\n\t\t}\n\t\tint xx, yy;\n\t\tcin >> xx >> yy;\n\t\tcout << bfs(t,xx+60,yy+60) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define MAX 129\n#define MAR (MAX-1) / 2\n#define INF 128\n\nint main()\n{\n\tconst int dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\twhile(1) {\n\t\tbool is_wall[MAX][MAX] = {false};\n\t\tint d[MAX][MAX] = {0};\n\t\tqueue<P> que;\n\t\tint t, n;\n\t\tint px, py;\n\t\tint ans = 0;\n\t\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &t, &n);\n\t\tif(!t && !n) break;\n\t\twhile(n--) {\n\t\t\tint wx, wy;\n\t\t\tscanf(\"%d %d\", &wx, &wy);\n\t\t\tis_wall[wx+MAR][wy+MAR] = true;\n\t\t}\n\t\tscanf(\"%d %d\", &px, &py);\n\t\tque.push(P(px, py));\n\t\td[px+MAR][py+MAR] = 0;\n\t\twhile(!que.empty()) {\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(d[x+MAR][y+MAR] == t) continue;\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif(-30 <= xx && xx <= 30 && -30 <= yy && yy <= 30 && !is_wall[xx+MAR][yy+MAR] ) {\n\t\t\t\t\tif(d[xx+MAR][yy+MAR] > d[x+MAR][y+MAR] + 1) {\n\t\t\t\t\t\td[xx+MAR][yy+MAR] = d[x+MAR][y+MAR] + 1;\n\t\t\t\t\t\tque.push(P(xx, yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(d[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint flag[70][70],a[70][70],dp[70][70],t,r,cnt;\n\nvoid bfs(int x,int y, int how){\n  if(how>t) return;\n  if(x<0||x>60 || y<0||y>60) return;\n  if(flag[y][x]&&dp[y][x]<=how) return;\n  if(a[y][x]) return;\n  cnt++;\n  dp[y][x]=how;\n  flag[y][x]=1;\n  bfs(x+1,y,how+1);\n  bfs(x,y+1,how+1);\n  bfs(x+1,y+1,how+1);\n  bfs(x-1,y,how+1);\n  bfs(x,y-1,how+1);\n  bfs(x-1,y-1,how+1);\n\n}\n\nint main(){\n  for(;;){\n  int q;\n  cin>>t>>q;\n  if(t==0&&q==0) break;\n  for(int i=0;i<70;i++) for(int j=0;j<70;j++){\n      flag[i][j]=a[i][j]=0;\n      dp[i][j]=-1;\n    }\n  r=cnt=0;\n  for(int i=0,t1,t2;i<q;i++){\n    cin>>t1>>t2;\n    a[t2+30][t1+30]=1;\n  }\n  int y0,x0;\n  cin>>x0>>y0;\n  x0+=30;\n  y0+=30;\n  bfs(x0,y0,0);\n  for(int i=0;i<61;i++)\tfor(int\tj=0;j<61;j++) if(dp[i][j]+1) r++;\n  /*  for(int i=0;i<61;i++){                                                                                                                                                                   \n    for(int j=0;j<61;j++) cout<<(flag[j][i]?\"1\":\" \")<<\" \";                                                                                                                                     \n    cout<<endl;                                                                                                                                                                                \n    } */\n  cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n\nbool mapAc(map<int,map<int,bool> > &mp, int x,int y){\n\tif(mp.find(x)!=mp.end()){\n\t\tif(mp[x].find(y)!=mp[x].end()){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint solve(int x,int y,int depth,map<int,map<int,bool> > &mp){\n\n\tmap<int,map<int,bool> > flgg;\n\n\tint cnt=0;\n\tqueue<pair<int,pair<int,int> > > q;\n\tq.push(pair<int,pair<int,int> >(x,pair<int,int>(y,depth)));\n\n\twhile(!q.empty()){\n\t\tint cx,cy,cd;\n\t\tpair<int,pair<int,int> > frt = q.front();\n\t\tq.pop();\n\t\tcx=frt.first;\n\t\tcy=frt.second.first;\n\t\tcd=frt.second.second;\n\t\tif(!mapAc(flgg,cx,cy)){\n\t\t\tif(cd>0){\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tint nnx = cx+xd[i];\n\t\t\t\t\tint nny = cy+yd[i];\n\t\t\t\t\tint nnd = cd-1;\n\t\t\t\t\tif(!mapAc(mp,nnx,nny) && !mapAc(flgg,nnx,nny))\n\t\t\t\t\t\tq.push(pair<int,pair<int,int> >(nnx,pair<int,int>(nny,nnd)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tflgg[cx][cy]=true;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\n\t\tmap<int,map<int,bool> > mpp;\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmpp[x][y]=true;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tfor(int i=0;i<100000;i++){\n\t\t\tsolve(x,y,t,mpp);\n\t\t}\n\t\tcout << solve(x,y,t,mpp) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nconst int N = 80;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (a.first < 0 || N <= a.first || a.second < 0 || N <= a.second)continue;\n\n\t\tint b = a.first + 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first + 1, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t}\n\n\tint ans(0);\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (0 < field[i][j] && field[i][j] < INF)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\tint x, y;\n\t\trep(i, 0, n) {\n\t\t\tcin >> x >> y;\n\t\t\tx += 40; y += 40;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += 40; sy += 40;\n\t\tfield[sx][sy] = t+1;\n\t\tcout << 1 << endl;\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** Brave Force Story***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define CX 35  // Center of x\n#define CY 35  // Center of y\n\nint main(){\n\tint t, n;\n\tint dx[6]={1, 1, 0, -1, -1, 0};\n\tint dy[6]={0, 1, 1, 0, -1, -1};\n\t\n\twhile(cin>>t>>n, t||n){\n\t\tint sx, sy;\n\t\tint hist[71][71];\n\t\tbool obs[71][71]={};\n\t\tmemset(hist, -1, sizeof hist);\n\t\t\n\t\tREP(i, 0, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobs[y+CY][x+CX]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tqueue<pair<int, int>> qu;\n\t\tqu.push(make_pair(sy+CY, sx+CX));\n\t\thist[sy+CY][sx+CX]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\tpair<int, int> q=qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tint y=q.first, x=q.second;\n\t\t\tREP(k, 0, 6){\n\t\t\t\tint yy=y+dy[k], xx=x+dx[k];\n\t\t\t\tif(hist[yy][xx]!=-1 || obs[yy][xx]) continue;\n\t\t\t\thist[yy][xx]=hist[y][x]+1;\n\t\t\t\tif(hist[yy][xx]<t) qu.push(make_pair(yy, xx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tREP(i, 0, 71){\n\t\t\tREP(j, 0, 71){\n\t\t\t\tif(hist[i][j]!=-1) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define ini 50\nusing namespace std ;\n\ntypedef pair<int,int> P ;\n\nqueue<P> q ;\nint dx[] = {0,1,1,0,-1,-1} ;\nint dy[] = {1,1,0,-1,-1,0} ;\n\nint main(){\n\t\n\tint t , n ;\n\tint x , y ;\n\tint ans ;\n\tint field[100][100] ;\n\t\n\twhile( cin >> t >> n , t ){\n\t\tfor( int i=0 ; i<100 ; i++ ){\n\t\t\tfor( int j=0 ; j<100 ; j++ ){\n\t\t\t\tfield[i][j] = 0 ;\n\t\t\t}\n\t\t}ans = 1 ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> x >> y ;\n\t\t\tfield[y+ini][x+ini]  = -1 ;\n\t\t}cin >> x >> y ;\n\t\t\n\t\tq.push( P(x+ini,y+ini) ) ;\n\t\tfield[y+ini][x+ini] = 1 ;\n\t\t\n\t\tint j=0 , k=0 ;\n\t\twhile( !q.empty() ){\n\t\t\tx = q.front().first ;\n\t\t\ty = q.front().second ;\n\t\t\t//cout << \"OK\" << endl ;//--------------------\n\t\t\tif( field[y][x] > t ) break ;\n\t\t\tfor( int i=0 ; i<6 && field[y][x] <= t ; i++ ){\n\t\t\t\tif( field[y+dy[i]][x+dx[i]] == 0 ){\n\t\t\t\t\tfield[y+dy[i]][x+dx[i]] = field[y][x]+1 ;\n\t\t\t\t\tq.push( P(x+dx[i],y+dy[i]) ) ;\n\t\t\t\t\t//cout<<\"# \"<<x-ini<<\" \"<<y-ini<<endl;\n\t\t\t\t\tans++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop() ;\n\t\t}\n\t\t\n\t\tcout << ans << endl ;\n\t\t\n\t\twhile( !q.empty()  ){\n\t\t\tq.pop() ;\n\t\t}\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int dx[] = { 1, 1, 0,-1,-1, 0 };\nconst int dy[] = { 1, 0,-1,-1, 0, 1 };\nconst int offset=100;\nint board[200][200];\nint cnt,m_turn;\n\nvoid dfs(int x,int y,int t){\n\tboard[y][x]=t;\n\tif(t==m_turn){\n\t\treturn ;\n\t}\n\t\n\tfor(int i=0;i<6;i++){\n\t\tint nx=dx[i]+x,ny=dy[i]+y;\n\t\tif(board[ny][nx]==0){\n\t\t\tcontinue;\t\t\t\n\t\t}\n\t\tif(board[ny][nx]==-1){\n\t\t\tcnt++;\n\t\t}\n\t\tdfs(nx,ny,t+1);\n\t}\n}\n\nint main(){\n\tint n;\n\tint sx,sy;\n\twhile(cin>>m_turn>>n,m_turn||n){\n\t\tcnt=1;\n\t\tfill((char*)board,(char*)(board+200),-1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tboard[y+offset][x+offset]=0;\n\t\t}\n\t\tcin>>sx>>sy;\t\n\t\tdfs(sx+offset,sy+offset,0);\n\t\t\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,j) for (int (i)=0;(i)<(int)(j);++(i))\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nbool used[310][310];\nint board[310][310];\nint dr[] = { 1, 1, 0, -1, -1, 0 };\nint dc[] = { 0, 1, 1, 0, -1, -1 };\n\n\nint main() {\n    int t, n;\n    while (cin >> t >> n, t) {\n        fill(board[0], board[310], 1e8);\n        fill(used[0], used[310], false);\n        int x[301], y[301];\n        rep(i, n) {\n            cin >> x[i] >> y[i];\n            x[i] += 150, y[i] += 150;\n            board[y[i]][x[i]] = -1;\n        }\n        int r, c;\n        cin >> c >> r;\n        c += 150, r += 150;\n        used[r][c] = true;\n        queue<P> que;\n        que.push(make_pair(r, c));\n        board[r][c] = 0;\n        while (que.size()) {\n            P p = que.front(); que.pop();\n            rep(d, 6) {\n                int nr = p.first + dr[d], nc = p.second + dc[d];\n                if (nr < 0 or nc < 0 or nr > 300 or nc > 300 or board[nr][nc] == -1 or used[nr][nc]) continue;\n                used[nr][nc] = true;\n                que.push(make_pair(nr, nc));\n                board[nr][nc] = min(board[nr][nc], board[p.first][p.second] + 1);\n            }\n        }\n        int ans = 0;\n        rep(r, 300) rep(c, 300) {\n            if (board[r][c] >= 0 and board[r][c] <= t) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint zz[61][61]={0};\n\tfor(int x=0;x<=60;x++){\n\t\tfor(int y=0;y<=60;y++){\n\t\t\tif(pow((x-30-(y-30)/2)*(x-30-(y-30)/2)+(y-30)*(y-30)*3/4,0.5)>30){\n\t\t\t\tzz[x][y]=2;\n\t\t\t}\n\t\t}\n\t}\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tint z[61][61],ka[61][61];\n\t\tfor(int x=0;x<=60;x++){\n\t\t\tfor(int y=0;y<=60;y++){\n\t\t\t\tz[x][y]=zz[x][y];\n\t\t\t\tka[x][y]=zz[x][y];\n\t\t\t}\n\t\t}\n\t\tif(t==0&&n==0) break;\n\t\tint x,y,ct=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tz[x+30][y+30]=2;\n\t\t\tka[x+30][y+30]=2;\n\t\t}\n\t\tcin>>x>>y;\n\t\tz[x+30][y+30]=1;\n\t\tka[x+30][y+30]=1;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tfor(int j=0;j<=60;j++){\n\t\t\t\tfor(int k=0;k<=60;k++){\n\t\t\t\t\tif(z[j][k]==1){\n\t\t\t\t\t\tif(z[j-1][k]==0){\n\t\t\t\t\t\t\tka[j-1][k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j+1][k]==0){\n\t\t\t\t\t\t\tka[j+1][k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j][k-1]==0){\n\t\t\t\t\t\t\tka[j][k-1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j][k+1]==0){\n\t\t\t\t\t\t\tka[j][k+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j+1][k+1]==0){\n\t\t\t\t\t\t\tka[j+1][k+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(z[j-1][k-1]==0){\n\t\t\t\t\t\t\tka[j-1][k-1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=60;j++){\n\t\t\t\tfor(int k=0;k<=60;k++){\n\t\t\t\t\tz[j][k]=ka[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=60;k++){\n\t\t\t\tif(z[j][k]==1) ct++;\n\t\t\t}\n\t\t}\n\t\tcout<<ct<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t,n;\nset<pair<int,int> > point;\ntypedef pair<int,int> P;\nconst int C = 50;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[103][103];\n    rep(i,103) rep(j,103) dist[i][j]=INF;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        \n        point.insert(make_pair(y,x));\n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(y,x));\n    dist[y][x]=0;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(0<=nx && 0<=ny && dist[ny][nx] == INF && point.find(P(ny,nx)) == point.end()) {\n                dist[ny][nx] = dist[y][x]+1;\n                que.push(P(ny,nx));\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,102) rep(j,102) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n    point.clear();\n    \n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {0, 1, -1, 1, -1, 0};\nconst int dy[] = {1, 1, 0, 0, -1, -1};\nint t, n;\nint d[222][222];\nint can[222][222];\nint x, y;\nint N = 35;\n\nint main()\n{\n  while(cin >> t >> n, t){\n    rep(i, 222) rep(j, 222) d[i][j] = 0;\n    rep(i, 222) rep(j, 222) can[i][j] = INF;\n    rep(i, n){\n      cin >> x >> y;\n      can[x+N][y+N] = -INF;\n    }\n    cin >> x >> y;\n\n   queue<pair<pii, int> > que;\n   can[x+N][y+N] = false;\n   d[x+N][y+N] = 1;\n   que.push(mp(mp(x, y), 0));\n   while(!que.empty()){\n     pair<pii, int> here = que.front();  que.pop();\n     int hx = here.first.first;\n     int hy = here.first.second;\n     int cnt = here.second;\n     if(cnt >= t) continue;\n     rep(k, 6){\n       int nx = hx + dx[k];\n       int ny = hy + dy[k];\n       if(minup(can[nx+N][ny+N], cnt + 1)){\n         d[nx+N][ny+N] = 1;\n         que.push(mp(mp(nx, ny), cnt + 1));\n       }\n     }\n   }\n\n   int res = 0;\n   rep(i, 222) rep(j, 222) res += d[i][j];\n\n   cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAX_RANGE 60\n\nstruct POS\n{\n\tint X,Y,far;\n};\n\nPOS move(POS &now, POS &power)\n{\n\tPOS ans = {now.X+power.X, now.Y+power.Y, now.far+1};\n\treturn ans;\n}\nbool eq(POS &a, POS &b){return a.X == b.Y && a.Y == b.Y;}\n\nPOS mpow[6]={{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\nbool list[MAX_RANGE][MAX_RANGE];\n\nint movenum(POS &start, int t, int n);\n\nint main()\n{\n\tint t,n,x,y;\n\tPOS start;\n\twhile(true){\n\t\tstd::cin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0; i<MAX_RANGE; i++)\n\t\t\tfor(int j=0; j<MAX_RANGE; j++) list[i][j] = false;\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tstd::cin >> x >> y;\n\t\t\tlist[x+MAX_RANGE/2][y+MAX_RANGE/2] = true;\n\t\t}\n\t\tstart.X = x;\n\t\tstart.Y = y;\n\t\tstart.far = 0;\n\t\tstd::cout << movenum(start, t, n) << std::endl;\n\t}\n\treturn EXIT_SUCCESS;\n}\n\nint movenum(POS &start, int t, int num)\n{\n\tint n = num, mnum=1;\n\tPOS now = start;\n\tstd::queue<POS> q;\n\tfor(;;){\n\t\tif(now.far != t){\n\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\tPOS s = move(now, mpow[j]);\n\t\t\t\tif(!list[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2]){\n\t\t\t\t\tmnum++;\n\t\t\t\t\tlist[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2] = true;\n\t\t\t\t\tq.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.empty()) break;\n\t\tnow = q.front();\n\t\tq.pop();\n\t}\n\treturn mnum;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"ctime\"\n#include \"chrono\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n#include \"list\"\n\nusing namespace std;\n\n\nint main() {\n\t\n\tint dir_y[] = { 1,1,0,-1,-1,0 };\n\tint dir_x[] = { 0,1,1,0,-1,-1 };\n\tint N, K;\n\tlist<int>ret;\n\tcin >> N >> K;\n\twhile (N) {\n\t\tvector<vector<int>>v(100, vector<int>(100, INT_MAX));\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tint y, x;\n\t\t\tcin >> y >> x;\n\t\t\ty += 50;\n\t\t\tx += 50;\n\t\t\tv[y][x] = -1;\n\t\t}\n\t\tint sy, sx;\n\t\tcin >> sy >> sx;\n\t\tsy += 50;\n\t\tsx += 50;\n\t\tqueue<pair<int,int>>Q;\n\t\tQ.push({ sy,sx });\n\t\tv[sy][sx] = 0;\n\t\tint cnt = 0;\n\t\twhile (cnt<=N&&!Q.empty()) {\n\t\t\tint cy = Q.front().first;\n\t\t\tint cx = Q.front().second;\n\t\t\tcnt = max(cnt, v[cy][cx] + 1);\n\t\t\tQ.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint ny = cy + dir_y[i];\n\t\t\t\tint nx = cx + dir_x[i];\n\t\t\t\tif (v[ny][nx]>cnt) {\n\t\t\t\t\tv[ny][nx] = cnt;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (auto i : v) {\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j >= 0 && j <= N) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret.push_back(ans);\n\t\tcin >> N >> K;\n\t}\n\tfor (auto i : ret) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nvoid run(){\n    int t,n;\n    cin>>t>>n;\n    if(!t)return;\n    bool map[300][300]={};\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        x+=100,y+=100;\n        map[x][y]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=100,sy+=100;\n    queue<pair<pi,int>> q;\n    q.push({{sx,sy},t});\n    int ans=0;\n    int dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\n    bool visited[300][300]={};\n    while(!q.empty()){\n        auto p=q.front();\n        q.pop();\n        int x=p.fi.fi,y=p.fi.se;\n        int l=p.se;\n        if(l<0||visited[x][y])continue;\n        visited[x][y]=true;\n        ans++;\n        rep(i,6){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(!map[nx][ny]){\n                q.push({{nx,ny},l-1});\n            }\n        }\n    }\n    cout<<ans<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\t\tint ans = 1;\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\t//if (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tif (map[cy][cx] + 1 > t)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tans++;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int dx[] = { 1, 1, 0,-1,-1, 0 };\nconst int dy[] = { 1, 0,-1,-1, 0, 1 };\nconst int offset=100;\nint board[200][200];\nint cnt,m_turn;\n\nvoid dfs(int x,int y,int t){\n\tboard[y][x]=t;\n\tif(t==m_turn){\n\t\treturn ;\n\t}\n\t\n\tfor(int i=0;i<6;i++){\n\t\tint nx=dx[i]+x,ny=dy[i]+y;\n\t\tif(board[ny][nx]==-1){\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tif(board[ny][nx]!=0){\n\t\t\tdfs(nx,ny,t+1);\t\t\t\n\t\t}\n\t\telse{\n\t\t\tdfs(x,y,t+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tint sx,sy;\n\twhile(cin>>m_turn>>n,m_turn||n){\n\t\tcnt=1;\n\t\tfill((char*)board,(char*)(board+200),-1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tboard[y+offset][x+offset]=0;\n\t\t}\n\t\tcin>>sx>>sy;\t\n\t\tdfs(sx+offset,sy+offset,0);\n\t\t\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nstatic bool used[100][100];\nint t,n;\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(used,0,sizeof(used));\n\t\tint X,Y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tused[Y+40][X+40]=true;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\tqueue<int> xs,ys,cnts;\n\t\txs.push(X+40); ys.push(Y+40); cnts.push(0);\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front(),cnt=cnts.front();\n\t\t\txs.pop(); ys.pop(); cnts.pop();\n\t\t\tused[y][x]=true;\n\t\t\tif(cnt<t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<61&&0<=ny&&ny<61&&!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny); cnts.push(cnt+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=-n;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define RREP(i,n) for(int i=(n)-1;i>=0;i--)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n#define INF (1<<28)\n#define int(n) int n; cin >> n;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){if(n < m) return 0;\n    unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\nint quadratic(int a, int b, int c){return (int)(-b + sqrt(b*b - 4*a*c)) / 2*a;}\n\nvoid cp(int from[], int to[], int l){REP(i, l) to[i] = from[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double x1, double y1, double x2, double y2, double x3, double y3, double res[3]){\n    double xp1 = (y1-y3)*(y1*y1-y2*y2+x1*x1-x2*x2) - (y1-y2)*(y1*y1-y3*y3+x1*x1-x3*x3);\n    double xp2 = 2*(y1-y3)*(x1-x2)-2*(y1-y2)*(x1-x3);\n    res[0] = xp1/xp2;\n    double yp1 = (x1-x3)*(x1*x1-x2*x2+y1*y1-y2*y2) - (x1-x2)*(x1*x1-x3*x3+y1*y1-y3*y3);\n    double yp2 = 2*(x1-x3)*(y1-y2)-2*(x1-x2)*(y1-y3);\n    res[1] = yp1/yp2;\n    double r = (x3-res[0])*(x3-res[0])+(y3-res[1])*(y3-res[1]);\n    res[2] = sqrt(r);\n}\n\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\n\n\nint table[150][150], forbidden[150][150], visited[150][150];\n\nint vy[6] = {-1, 1, 0, 0, 1, -1}, vx[6] = {0, 0, -1, 1, 1, -1};\nint main(int argc, const char * argv[]){\n    while (true) {\n        REP(i, 150) REP(j, 150){\n            table[i][j] = 0;\n            forbidden[i][j] = 0;\n            visited[i][j] = 0;\n        }\n        \n        int t, n;\n        cin >> t >> n;\n        if(!t) break;\n        \n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            x+=75; y+=75;\n            forbidden[y][x] = 1;\n        }\n    \n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 75, sy += 75;\n        \n        queue<int> qy, qx, qcnt;\n        visited[sy][sx] = 1;\n        int ans = 1;\n        qy.push(sy);\n        qx.push(sx);\n        qcnt.push(0);\n        while(!qy.empty()){\n            int y = qy.front(); qy.pop();\n            int x = qx.front(); qx.pop();\n            int cnt = qcnt.front(); qcnt.pop();\n            \n            if(cnt >= t) continue;\n            \n            REP(k, 6){\n                int ny = y + vy[k];\n                int nx = x + vx[k];\n                if(!visited[ny][nx] && !forbidden[ny][nx]){\n                    // cout << ny  << \" \" << nx << endl;\n                    qy.push(ny);\n                    qx.push(nx);\n                    qcnt.push(cnt + 1);\n                    visited[ny][nx] = 1;\n                    ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint tile[140][140];\nusing vpii = vector<pair<int,int>>;\nint dx[] = {1,-1,0,0,-1,1};\nint dy[] = {1,-1,1,-1,0,0};\n\n\nint main()\n{\n  int t,n;\n  while(cin >> t >> n,t+n){\n    REP(i,140){\n      REP(j,140){\n        tile[i][j] = 0;\n      }\n    }\n    vpii pii;\n    REP(i,n){\n      int c,k;\n      cin >> c >> k;\n      pii.push_back({k,c});\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    tile[70][70] = 1;\n    for(auto x : pii){\n      tile[x.first-sy+70][x.second-sx+70] = 2;\n    }\n    REP(_t,t){\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j] == 1){\n           REP(k,6){\n            auto ny = max(0,min(139,i + dy[k]));\n            auto nx = max(0,min(139,j+dx[k]));\n            if(tile[ny][nx]==0){\n              tile[ny][nx] = -1;\n            }\n           }\n          }\n        }\n      }\n      REP(i,140){\n        REP(j,140){\n          if(tile[i][j]==-1){\n            tile[i][j] = 1;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i,140){\n      REP(j,140){\n        if(tile[i][j]==1){\n          ans++;\n        }\n      }\n    }\n    cout << ans<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\t\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tif(t==0){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pair<int,PII > >q;\n\t\tq.push(MP(t,MP(sx,sy)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tint tt=pi.first;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(tt-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) > i) continue;\n                        if (i % 2 == 0) {\n                            if (a[k] == i / 2 && b[k] == -i / 2) ans--;\n                            if (a[k] == -i / 2 && b[k] == i / 2) ans--;\n                        }\n                        ans--;\n                    }\n                    \n                    \n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) > t) continue;\n            if (t % 2 == 0) {\n                if (a[i] == t / 2 && b[i] == -t / 2) ans--;\n                if (a[i] == -t / 2 && b[i] == t / 2) ans--;\n            }\n            ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 35;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(!wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nconst int N = 80;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (a.first < 0 || N <= a.first || a.second < 0 || N <= a.second)continue;\n\n\t\tint b = a.first + 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first + 1, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t}\n\n\tint ans(0);\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (0 < field[i][j] && field[i][j] < INF)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\tint x, y;\n\t\trep(i, 0, n) {\n\t\t\tcin >> x >> y;\n\t\t\tx += 40; y += 40;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += 40; sy += 40;\n\t\tfield[sx][sy] = t+1;\n\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[1024][1024] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    cin >> tt >> nn;\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      cin >> x >> y;\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    cin >> x >> y;\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<1024;j++){\n      for(k=0;k<1024;k++){\n        visited[j][k]=0;\n      }\n    }\n    cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\nint mp[610][610];\nvoid dfs(int x, int y, int n) {\n  if (n == 0 || mp[y][x] == 9 || mp[y][x] == 7)\n    return;\n  mp[y][x] = 7;\n  dfs(x + 1, y, n - 1);\n  dfs(x, y + 1, n - 1);\n  dfs(x - 1, y, n - 1);\n  dfs(x, y - 1, n - 1);\n  dfs(x + 1, y + 1, n - 1);\n  dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n, t;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    rep(i, 600) rep(j, 600) mp[i][j] = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Brave Force Story\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair< pair<int, int>, int> Q;\n#define INF 9\nint dx[6]={1, 1, 0, -1, -1, 0}, dy[6]={1, 0, -1, -1, 0, 1};\nint mp[61][61];//+30????????????\nint d[61][61];\n\nvoid print(){\n  for(int i=0; i<61; i++){\n    for(int j=0; j<61; j++)\n      printf(\"%2d\", d[i][j]);\n    cout<<endl;\n  }\n}\n\nQ make_Q(int x, int y, int z){\n  Q ret;\n  ret.first.first=x;\n  ret.first.second=y;\n  ret.second=z;\n  return ret;\n}\n\nint main(){\n  int t, n;\n  while(cin>>t>>n, !(t==0&&n==0)){\n    memset(mp, 0, sizeof(mp));\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\td[i][j]=INF;\n    while(n--){\n      int tmp_x, tmp_y;\n      cin>>tmp_x>>tmp_y;\n      mp[tmp_x+30][tmp_y+30]=-1;\n    }\n    int sx, sy;\n    cin>>sx>>sy;\n    d[sx+30][sy+30]=0;\n    queue<Q> q;\n    q.push(make_Q(sx+30, sy+30, t));\n    while(!q.empty()){\n      Q now=q.front(); q.pop();\n      //      printf(\"pop : (%d, %d, %d)\\n\", now.first.first, now.first.second, now.second);\n      if(now.second==0)break;\n      for(int i=0; i<6; i++){\n\tint nx=now.first.first+dx[i], ny=now.first.second+dy[i];\n\tif(0<=nx && nx<61 && 0<=ny && ny<61 && mp[nx][ny]!=-1 && d[nx][ny]==INF){\n\t  q.push(make_Q(nx, ny, now.second-1));\n\t  d[nx][ny]=d[now.first.first][now.first.second]+1;\n\t}\n      }\n    }\n    int cnt=0;\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\tif(d[i][j]!=INF)cnt++;\n    cout<<cnt<<endl;\n    //        print();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nint main() {\n  while(true) {\n    int T, N;\n    cin >> T >> N;\n\n    if (T == 0 && N == 0) break;\n    // x, y\n    set<P> obj;\n\n    for(int i = 0; i < N; i++) {\n      int x, y;\n      cin >> x >> y;\n      obj.insert(make_pair(x, y));\n    }\n\n    P start;\n    cin >> start.first >> start.second;\n\n    queue<P> Q;\n    queue<P> Next;\n    set<P> vis;\n    Q.push(start);\n\n    vis.insert(start);\n\n    int cnt = 1;\n\n    while(T--) {\n      while(!Next.empty()) Next.pop();\n\n      while(!Q.empty()) {\n        P cur = Q.front(); Q.pop();\n        //cerr << \"(\" << cur.first << \",\" << cur.second << \")\" << endl;\n        for(int i = 0; i < 6; i++) {\n          P p;\n          p.first = cur.first + dx[i];\n          p.second = cur.second + dy[i];\n          if(obj.count(p)) continue;\n          if(vis.count(p)) continue;\n          vis.insert(p);\n          Next.push(p);\n\n          cnt++;\n        }\n      }\n\n      Q = Next;\n    }\n\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint map[100][100];\nint mapcnt[100][100];\nint t, n;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid search(int x, int y, int t){\n\tif(!t) return;\n\tif(map[x][y] == -1) return;\n\tif(map[x][y] == 1 && mapcnt[x][y] > t) return;\n//cout << x-50 << \":\" << y-50 << endl;\n\tmap[x][y] = 1;\n\tmapcnt[x][y] = t;\n\tfor(int i = 0; i < 6; i++){\n\t\tsearch(x+dx[i], y+dy[i], t-1);\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x, y;\n\twhile(cin >> t >> n, t || n){\n\t\tfor(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++) mapcnt[i][j] = 0, map[i][j] = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x + 50][y + 50] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tsearch(x+50, y+50, t+1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\tif(map[i][j] == 1) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(const T a, const T b){return a>=0 ? a/b : (a+1)/b-1;}\ntemplate<class T> T div_ceil(const T a, const T b){return a>=0 ? (a-1)/b+1 : a/b;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {1, 0, -1, -1, 0, 1};\n\nint main(){\n    int t, n;\n    while(scanf(\"%d%d\", &t, &n) && t){\n        set<pii> S, used;\n        rep(i, n){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            S.emplace(x, y);\n        }\n        int sx, sy;\n        scanf(\"%d%d\", &sx, &sy);\n        queue<pair<pii, int>> que;\n        que.push({{sx, sy}, 0});\n        used.emplace(sx, sy);\n        while(!que.empty()){\n            int x, y, td;\n            tie(x, y) = que.front().fi;\n            td = que.front().se;\n            que.pop();\n            if(td == t) continue;\n            rep(i, 6){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(S.find({nx, ny}) == S.end() && used.find({nx, ny}) == used.end()){\n                    used.emplace(nx, ny);\n                    que.push({{nx, ny}, td+1});\n                }\n            }\n        }\n        printf(\"%d\\n\", used.size());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {1,-1,0, 0,1,-1};\nint dy[] = {0, 0,1,-1,1,-1};\nint pos[70][70];\n\nint dfs(int x, int y, int t){\n  if(pos[y][x] == -1) return 0;\n  int res = 1 - pos[y][x];\n  pos[y][x] = 1;\n  if(t == 0) return res;\n\n  REP(i,6){\n\tint tx = x + dx[i], ty = y + dy[i];\n\tres += dfs(tx,ty,t-1);\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int T, N;\n  while(cin >> T >> N, T){\n\tfill((int*)pos, (int*)pos+70*70, 0);\n\tREP(i,N){\n\t  int x, y; cin >> x >> y;\n\t  pos[y+35][x+35] = -1;\n\t}\n\tint sx, sy; cin >> sx >> sy;\n\tcout << dfs(sx+35,sy+35,T) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\n\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(vector<vector<int>>& m, int Y,int X,int T){\n\tvector<vector<int>> vis(500, vector<int>(500, 0));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(Y,X,T);\n\twhile(!q.empty()){\n\t\tint y, x, t;\n\t\ttie(y,x,t)=q.front(); q.pop();\n\n\t\tif(t == 0)  continue;\n\t\tvis[y][x] = true;\n\n\t\trep(i,6){\n\t\t\tint ny=y+dy[i];\n\t\t\tint nx=x+dx[i];\n\t\t\tif(m[ny][nx] or vis[ny][nx]) continue;\n\t\t\tvis[ny][nx]=true;\n\t\t\tq.emplace(ny,nx,t-1);\n\t\t}\n\t}\n\tint cnt=0;\n\trep(i,500)rep(j,500)cnt+=vis[i][j];\n\treturn cnt;\n}\n\nsigned main(){\n\tint t,n;\n\twhile (cin>>t>>n,t) {\n\t\tvector<vector<int>> m(500, vector<int>(500, 0));\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=200;y+=200;\n\t\t\tm[y][x]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=200;sy+=200;\n\t\tcout<<bfs(m,sy,sx,t)<<endl;\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> p;\n\nint d[121][121],obs[121][121],dx[]={1,0,-1,0,1,-1},dy[]={0,1,0,-1,1,-1},t,n;\n\nvoid bfs(int x,int y){\n\tqueue<p> q;\n\trep(i,121)rep(j,121)d[i][j]=INF;\n\tq.push(p(x,y));\n\td[x][y]=0;\n\twhile(!q.empty()){\n\t\tp c=q.front();q.pop();\n\t\tif(d[c.first][c.second]==t)return;\n\t\trep(i,6){\n\t\t\tint nx=c.first+dx[i],ny=c.second+dy[i];\n\t\t\tif(nx>=0&&nx<121&&ny>=0&&ny<121&&!obs[nx][ny]&&d[nx][ny]==INF){\n\t\t\t\tq.push(p(nx,ny));\n\t\t\t\td[nx][ny]=d[c.first][c.second]+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>t>>n&&(t||n)){\n\t\trep(i,121)fill(obs[i],obs[i]+121,0);\n\t\tint x,y,ans=0;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\tobs[x+60][y+60]=1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tbfs(x+60,y+60);\n\t\trep(i,121)rep(j,121)ans+=d[i][j]<=t;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nbool u[70][70] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=true;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]==false){\n                u[ny+35][nx+35] = true;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x])a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef tuple<int,int,int> T;\nbool vis[121][121];\nbool ob[121][121];\nint dx[6]={-1,0,1,1,0,-1};\nint dy[6]={0,1,1,0,-1,-1};\nint main() {\n\tint t,n;\n\twhile(scanf(\"%d %d\",&t,&n),t) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(ob,0,sizeof(ob));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tob[x+60][y+60]=1;\n\t\t}\n\t\tint sx,sy;\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tqueue<T> Q;\n\t\tQ.push(make_tuple(sx+60,sy+60,0));\n\t\tvis[sx+60][sy+60]=1;\n\t\twhile(!Q.empty()) {\n\t\t\tT tp=Q.front();Q.pop();\n\t\t\tint x=get<0>(tp),y=get<1>(tp),d=get<2>(tp);\n\t\t\tif(d==t) break;\n\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\tif(vis[nx][ny]||ob[nx][ny]) continue;\n\t\t\t\tvis[nx][ny]=1;\n\t\t\t\tQ.push(make_tuple(nx,ny,d+1));\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<=120;i++) {\n\t\t\tfor(int j=0;j<=120;j++) ans+=vis[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <memory.h>  \nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[500][500];\n  int count = 0;\n  \n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\ntypedef pair<int,int> P;\n\n//-----------------------------------------------------------------------\n\nint dy[]={0,-1,-1,0,1,1};\nint dx[]={1,0,-1,-1,0,1};\nconst int SZ=200;\nconst int off=100;\n\nint t,n;\nbool isEntry[SZ][SZ];\nbool isVisited[SZ][SZ];\n\nint bfs(int sy,int sx)\n{\n    queue<P> que;\n    isVisited[sy][sx]=true;\n    que.push(P(sy,sx));\n\n    int cnt=1;\n    REP(i,t){\n\tint sz=que.size();\n\twhile(sz--){\n\t    int y=que.front().first;\n\t    int x=que.front().second;\n\t    que.pop();\n\t    REP(j,6){\n\t\tint ny=y+dy[j],nx=x+dx[j];\n\t\tif(isEntry[ny][nx] && !isVisited[ny][nx])\n\t\t{\n\t\t    isVisited[ny][nx]=true;\n\t\t    que.push(P(ny,nx));\n\t\t    cnt++;\n\t\t}\n\t    }\n\t}\n    }\n    return cnt;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>t>>n,t)\n    {\n\tREP(i,SZ) REP(j,SZ){\n\t    isEntry[i][j]=true,isVisited[i][j]=false;\n\t}\n\tREP(i,n){\n\t    int x,y; cin>>x>>y;\n\t    x+=off; y+=off;\n\t    isEntry[y][x]=false;\n\t}\n\tint sx,sy; cin>>sx>>sy;\n\tsx+=off; sy+=off;\n\tcout<<bfs(sy,sx)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\nconst int dy[]={-1,-1,0,0,1,1};\nconst int dx[]={-1,0,-1,1,0,1};\nint main(){\n\n\tint n,t;\n\tconst int base=150;\n\tconst int MAX_P=301;\n\twhile(cin>>t>>n&&!(t==0&&n==0)){\n\t\tbool passed[MAX_P][MAX_P];\n\t\tbool isArrival[2][MAX_P][MAX_P];\n\t\tbool obj[MAX_P][MAX_P];\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tmemset(obj,0,sizeof(obj));\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tobj[y+base][x+base]=true;\n\t\t}\n\t\tint sy,sx;\n\t\tcin>>sx>>sy;\n\t\tisArrival[0][sy+base][sx+base]=true;\n\t\tpassed[sy+base][sx+base]=true;\n\t\tfor(int l = 0; l < t; l++){\n\t\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\t\tif(isArrival[l%2][i][j]){\n\t\t\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tif(!obj[ny][nx]){\n\t\t\t\t\t\t\t\tisArrival[(l+1)%2][ny][nx]=true;\n\t\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisArrival[l%2][i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\tif(passed[i][j])\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 0;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tbool field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = 1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tif(field[x][y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[x][y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>20){if(!field[x-1][y]){point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>20){if(!field[x][y-1]){point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<80){if(!field[x+1][y]){point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<80){if(!field[x][y+1]){point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>20 && y>20){if(!field[x-1][y-1]){point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<80 && y<80){if(!field[x+1][y+1]){point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint x[150][150][2], n, m, c, d, i, j, k, sum;\n#define A(B,C) if(x[B][C][0]==0 && x[B][C][1]==1){x[B][C][0]=2;sum++;}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0) { break; }sum = 1; memset(x, 0, sizeof(x));\n\t\tfor (j = 40; j < 101; j++) { for (k = 40; k < 101; k++) { x[j][k][1] = 1; } }\n\t\tfor (i = 0; i < m; i++) { cin >> c >> d; x[c + 70][d + 70][1] = 0; }cin >> c >> d; x[c + 70][d + 70][0] = 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 141; j++) {\n\t\t\t\tfor (k = 0; k < 141; k++) {\n\t\t\t\t\tif (x[j][k][0] == 1) {\n\t\t\t\t\t\tA(j - 1, k - 1);\n\t\t\t\t\t\tA(j - 1, k);\n\t\t\t\t\t\tA(j, k - 1);\n\t\t\t\t\t\tA(j, k + 1);\n\t\t\t\t\t\tA(j + 1, k);\n\t\t\t\t\t\tA(j + 1, k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < 141; j++) { for (k = 0; k < 141; k++) { if (x[j][k][0] == 2) { x[j][k][0] = 0; } } }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst vector<int> vx={1,0,-1,0,1,-1};\nconst vector<int> vy={0,1,0,-1,1,-1};\n\nbool solve() {\n    int time,n;\n    cin>>time>>n;\n    if(time==0)return false;\n\n    set<pair<int,int>> st;\n    for(int i = 0;i < n;++i) {\n        int x,y;\n        cin>>x>>y;\n        st.emplace(x,y);\n    }\n\n    int sx,sy;\n    cin>>sx>>sy;\n\n    set<pair<int,int>> ans;\n\n    ans.emplace(sx,sy);\n\n    queue<pair<pair<int,int>,int>> q;\n    q.emplace(make_pair(sx,sy),0);\n    while(!q.empty()) {\n        auto t=q.front();\n        q.pop();\n        if(t.second==time)continue;\n        for(int d = 0;d < 6;++d) {\n            int nx=t.first.first+vx[d];\n            int ny=t.first.second+vy[d];\n            if(st.find(make_pair(nx,ny))!=st.end())continue;\n            if(ans.find(make_pair(nx,ny))!=ans.end())continue;\n            q.emplace(make_pair(nx,ny),t.second+1);\n            ans.insert(make_pair(nx,ny));\n        }\n    }\n\n    cout<<ans.size()<<endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Step;\n\nset<P> obstacles;\n\nbool Map[150][150];\n\nvoid init() {\n  REP(i, 150) REP(j, 150) {\n    Map[i][j] = false;\n  }\n}\n\nvoid setM(P p) {\n  Map[75 + p.first][75 + p.second] = true;\n}\n\nbool getM(P p) {\n  return Map[75 + p.first][75 + p.second];\n}\n\nint countM() {\n  int ans = 0;\n  REP(i, 150) REP(j, 150) {\n    if (Map[i][j]) ans++;\n  }\n  return ans;\n}\n\nP input() {\n  int x, y;\n  cin >> x >> y;\n  return P(x, y);\n}\n\nbool canEnter(P p) {\n  return obstacles.find(p) == obstacles.end();\n}\n\nvector<P> move(P p) {\n  int x = p.first, y = p.second;\n\n  vector<P> ans = {P(x+1,y), P(x+1,y+1), P(x,y+1), \n    P(x-1,y), P(x-1,y-1), P(x,y-1)};\n\n  return ans;\n}\n\nint move(P origin, int limit) {\n  queue<Step> que;\n\n  que.push(Step(origin, 0));\n  setM(origin);\n  \n  while (! que.empty()) {\n    Step elem = que.front(); que.pop();\n    P p = elem.first;\n    int step = elem.second;\n\n    if (step == limit) continue;\n\n    vector<P> v = move(p);\n    REP(i, 6) {\n      if (canEnter(v[i])) {\n        if (not getM(v[i])) {\n          que.push(Step(v[i], step + 1));\n        }\n        setM(v[i]);\n      }\n    }\n  }\n  return countM();\n}\n\nint main() {\n  int t, n;\n  while (cin >> t >> n and t) {\n    obstacles.clear();\n    init();\n    REP(i, n) {\n      obstacles.insert(input());\n    }\n\n    P start = input();\n\n    cout << move(start, t) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 35;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[80][80]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint cnt;\nint t;\nint field[61][61];\n\nvoid dfs(int x,int y,int turn){\n  int dx[6] = {0, 1, 1, 0, -1, -1};\n  int dy[6] = {1, 1, 0, -1, -1, 0};\n\n  if(x<0 || x>60 || y<0 || y>60) return;\n\n  if(turn>t) return;\n\n  /*if(field[x][y]==0){\n    field[x][y] = turn;\n    if(turn==0) field[x][y]=100;\n    //cnt++;\n  }\n  else return;\n  */\n\n  if(field[x][y] <= turn && field[x][y] > 0) return;\n  if(field[x][y] == -1) return;\n\n  field[x][y] = turn;\n\n  for(int i=0;i<6;++i){\n    dfs(x+dx[i],y+dy[i],turn+1);\n  }\n  //cout << turn << \" \" << x-30 << \" \" << y-30 << endl;\n  return;\n}\n\nint main(){\n\n  for(int n;cin>>t>>n,t;){\n    cnt = 0;\n\n    // initialize\n    for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n        field[i][j] = 0;\n      }\n    }\n\n    // syougaibutsu\n    for(int i=0;i<n;++i){\n      int x,y;\n      cin>>x>>y;\n      field[x+30][y+30] = -1;\n    }\n\n /*   for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n       cout << field[i][j] << \" \";\n      }\n      cout << endl;\n    }\n*/\n    int sx,sy;\n    cin>>sx>>sy;\n\n    dfs(sx+30,sy+30,0);\n    field[sx+30][sy+30]=1;\n\n    for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n        if(field[i][j]>0) cnt++;\n     }\n    }\n\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint dx[6]={0,1,-1,1,-1,0},dy[6]{1,1,0,0,-1,-1};\nbool a[500][500];\nint mincost[500][500];\nsigned main(){\n    int b,c;\n    while(cin>>b>>c,b|c){\n\tmemset(a,true,sizeof(a));\n\tmemset(mincost,-1,sizeof(mincost));\n\tfor(int d=0;d<c;d++){\n\t    int e,f;scanf(\"%d%d\",&e,&f);\n\t    e+=250;f+=250;\n\t    a[e][f]=false;\n\t    }\n\tint sum=1;\n\tint n,m;scanf(\"%d%d\",&n,&m);n+=250;m+=250;\n\tmincost[n][m]=0;\n\tqueue<P>Q;\n\tQ.push(P(n,m));\n\twhile(Q.size()){\n\t    P t=Q.front();Q.pop();\n\t    if(mincost[t.first][t.second]==c)continue;\n\t    for(int i=0;i<6;i++){\n\t\tint x=t.first+dx[i],y=t.second+dy[i];\n\t\tif(mincost[x][y]==-1&&a[x][y]){\n\t\t    mincost[x][y]=mincost[t.first][t.second]+1;\n\t\t    Q.push(P(x,y));\n\t\t    sum++;\n\t\t    }\n\t\t}\n\t    }\n\t    cout<<sum<<endl;\n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\t\n\twhile(cin >> t >> n, t) {\n\t\tqueue<state> Q;\n\t\tvvi field(61, vi(61, 0));\n\t\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = 1;\n\t\tint count = 1;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tif(st.t < t) {\n\t\t\t\tREP(d, 6) {\n\t\t\t\t\tif(abs(st.x+dx[d]-30)<= 30 && abs(st.y+dy[d]-30)<=30) {\n\t\t\t\t\t\tif(field[st.x+dx[d]][st.y+dy[d]] == 0) {\n\t\t\t\t\t\t\tfield[st.x+dx[d]][st.y+dy[d]] = 1;\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,a,n) for(int i=a;i<n;i++)\nint dy[]={1,1,0,0,-1,-1};\nint dx[]={1,0,1,-1,0,-1};\nint a[200][200];\nint main(){\n\tint n,t,b[300][2],x,y,ch[31];\n\tch[0]=1;\n\tr(i,1,32)ch[i]=ch[i-1]+6*i;\n\twhile(cin>>t>>n,t){\n\t\tr(i,0,200)r(j,0,200)a[i][j]=-1;\n\t\tr(i,0,n){\n\t\t\tcin>>x>>y;\n\t\t\ta[y+100][x+100]=1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tint s=0,p=0;\n\t\tqueue<int>q1,q2;\n\t\tq1.push(x+100);\n\t\tq2.push(y+100);\n\t\ta[y+100][x+100];\n\t\twhile(!q1.empty()){\n\t\t\tint x2=q1.front();q1.pop();\n\t\t\tint y2=q2.front();q2.pop();\n\t\t\tif(a[y2][x2]==1){p++;continue;}\n\t\t\tif(a[y2][x2]==2)continue;\n\t\t\tif(ch[t]<=p)break;\n\t\t\tp++;\n\t\t\ts++;\n\t\t\ta[y2][x2]=2;\n\t\t\tr(i,0,6){\n\t\t\t\tint x3=x2+dx[i];\n\t\t\t\tint y3=y2+dy[i];\n\t\t\t\tq1.push(x3);\n\t\t\t\tq2.push(y3);\n\t\t\t}\n\t\t}\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mLife;\n  int mX;\n  int mY;\n  State(int life,int x,int y) : mLife(life), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mLife < s.mLife;\n  }\n\n  bool operator >(const State& s) const{\n    return mLife > s.mLife;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //0:unvisited\n      //1:obstacle\n      //2:visited\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State> > que;\n    if(stage.find(P(sx,sy)) != stage.end()\n       && stage[P(sx,sy)] == -1) goto last;\n\n    que.push(State(t,sx,sy));\n    stage[P(sx,sy)] = t;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.mLife <= 0) continue;\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\tif(abs(dx) > 30 || abs(dy) > 30) continue;\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && stage[P(dx,dy)] <= s.mLife-1) continue;\n\n\tstage[P(dx,dy)] = s.mLife-1;\n\tque.push(State(s.mLife-1,dx,dy));\n      }\n    }\n\n  last:;\n    int res = CoundVisitedCell(stage);\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 50;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[100][100]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {0, 1, -1, 1, -1, 0};\nconst int dy[] = {1, 1, 0, 0, -1, -1};\nint t, n;\nint d[222][222];\nbool can[222][222];\nint x, y;\nint N = 35;\n\nint main()\n{\n  while(cin >> t >> n, t){\n    rep(i, 222) rep(j, 222) d[i][j] = 0;\n    rep(i, 222) rep(j, 222) can[i][j] = true;\n   rep(i, n){\n      cin >> x >> y;\n      can[x+N][y+N] = false;\n    }\n   cin >> x >> y;\n\n   queue<pair<pii, int> > que;\n   can[x+N][y+N] = false;\n   d[x+N][y+N] = 1;\n   que.push(mp(mp(x, y), 0));\n   while(!que.empty()){\n     pair<pii, int> here = que.front();  que.pop();\n     int hx = here.first.first;\n     int hy = here.first.second;\n     int cnt = here.second;\n     if(cnt < t) rep(k, 6){\n       int nx = hx + dx[k];\n       int ny = hy + dy[k];\n       if(!can[nx+N][ny+N]) continue;\n       d[nx+N][ny+N] = 1;\n       can[nx+N][ny+N] = false;\n       que.push(mp(mp(nx, ny), cnt + 1));\n     }\n   }\n\n   int res = 0;\n   rep(i, 222) rep(j, 222) res += d[i][j];\n\n   cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nvoid solve(int t, int n) {\n    int a[n], b[n];\n    rep(i, n) {\n        cin >> a[i] >> b[i];\n    }\n    int stx, sty;\n    cin >> stx >> sty;\n    rep(i, n) {\n        a[i] -= stx; b[i] -= sty;\n    }\n    queue<pair<pii, int> > q;\n    q.push({{0, 0}, 0});\n    set<pii> s;\n    s.insert({0, 0});\n    while (!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        int step = q.front().second;\n        q.pop();\n        if (step == t) continue;\n        rep(i, 6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            int flg = 0;\n            rep(j, n) {\n                if (nx == a[j] && ny == b[j]) {\n                    flg = 1;\n                    break;\n                }\n            }\n            if (flg) continue;\n            q.push({{nx, ny}, step + 1});\n            s.insert({nx, ny});\n        }\n    }\n    cout << s.size() << endl;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    while (cin >> t >> n && (t || n)) {\n        solve(t, n);\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <string.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a;i < b;i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n) memset(n,0,sizeof(n))\n\nint dx[6] = { 0, -1, -1, 0, 1, 1 }, dy[6] = { 1, 0, -1, -1, 0, 1 };\nbool cheak(int x, int y, int mx, int my){ return x >= 0 && y >= 0 && x < mx && y < my; }\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint main(){\n\n\tint t, n;\n\n\twhile (cin >> t >> n && t){\n\n\t\tconst int M = 50;\n\t\tint d[M * 3][M * 3]; clr(d);\n\t\tbool f[M * 3][M * 3]; clr(f);\n\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\td[y + M][x + M] = 1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tsx += M, sy += M;\n\n\t\tqueue<T> q;\n\t\tq.push(T(sy, sx, 0));\n\t\tf[sy][sx] = true;\n\n\t\twhile (q.size()){\n\n\t\t\tT nx = q.front(); q.pop();\n\n\t\t\trep(i, 6){\n\t\t\t\tint ty = get<0>(nx) + dy[i], tx = get<1>(nx) + dx[i];\n\n\t\t\t\tif (!d[ty][tx] && !f[ty][tx] && get<2>(nx) < t){\n\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\tq.push(T(ty, tx, get<2>(nx)+1));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, M * 3)rep(j, M * 3){\n\t\t\tif (f[i][j])ans++;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nbool used[100][100];\nint t,n;\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(used,0,sizeof(used));\n\t\tint X,Y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tused[Y+40][X+40]=true;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\tqueue<int> xs,ys,cnts;\n\t\txs.push(X+40); ys.push(Y+40); cnts.push(0);\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front(),cnt=cnts.front();\n\t\t\txs.pop(); ys.pop(); cnts.pop();\n\t\t\tused[y][x]=true;\n\t\t\tif(cnt<t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<61&&0<=ny&&ny<61&&!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny); cnts.push(cnt+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=-n;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n) {\n\t\tif (!t && !n) break;\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[b][a] = 3;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[b][a]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[y][x] == 1) {\n\t\t\t\t\tg[y][x]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[ny][nx] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[100][100];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 50;\n      Y += 50;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct point {\n  int x;\n  int y;\n  int t;\n} POINT;\n\nint t, n, sx, sy, cnt;\nbool d[63][63];\nbool f[63][63];\nqueue<POINT> que;\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &t, &n);\n  if (!t && !n) return false;\n  fill(d[0], d[0] + 63 * 63, true);\n  fill(f[0], f[0] + 63 * 63, true);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &sx, &sy);\n    d[sy + 31][sx + 31] = false;\n  }\n  scanf(\"%d %d\", &sx, &sy);\n\n  while (!que.empty()) que.pop();\n\n  return true;\n}\n\nint main() {\n  POINT a, b;\n\n  while (input()) {\n    a.x = sx + 31;\n    a.y = sy + 31;\n    a.t = t + 1;\n    cnt = 0;\n    que.push(a);\n    while (!que.empty()) {\n      a = que.front();\n      que.pop();\n      //printf(\"%d %d %d\\n\", a.x, a.y, a.t);\n      if (!a.t) break;\n      if (a.y < 0 || 63 <= a.y || a.x < 0 || 63 <= a.x) continue;\n      if (!d[a.y][a.x] || !f[a.y][a.x]) continue;\n      f[a.y][a.x] = false;\n      cnt++;\n      \n      b.x = a.x + 1;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n    }\n    printf(\"%d\\n\", cnt);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nstatic const int INFTY = (1 << 21);\n\nint main() {\n  int t, n;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0) {\n      break;\n    }\n    int d[110][110];\n    for (int i = 0; i < 110; i++) {\n      for (int j = 0; j < 110; j++) {\n        d[i][j] = INFTY;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      x += 50;\n      y += 50;\n      d[x][y] = -1000;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n    int dx[6] = {-1, 0, 1, 0, -1, 1};\n    int dy[6] = {0, 1, 0, -1, -1, 1};\n    queue<pair<int, int> > q;\n    q.push(make_pair(sy, sx));\n    d[sy][sx] = 0;\n    while (!q.empty()) {\n      pair<int, int> u = q.front();\n      q.pop();\n      for (int i = 0; i < 6; i++) {\n        if (d[u.first + dx[i]][u.second + dy[i]] == -1000) continue;\n        if (d[u.first + dx[i]][u.second + dy[i]] != INFTY) continue;\n        d[u.first + dx[i]][u.second + dy[i]] = d[u.first][u.second] + 1;\n        q.push(make_pair(u.first + dx[i], u.second + dy[i]));\n      }\n    }\n    int ans = 0;\n    for (int i = 0; i <= 100; i++) {\n      for (int j = 0; j <= 100; j++) {\n        if (d[i][j] <= t && d[i][j] >= 0) {\n          ans++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst double EPS = 1e-10;\nvector<vector<int>>field;\nconst int N = 80;\nvoid print_field() {\n\tif (DBG) {\n\t\trep(i, 0, N) {\n\t\t\trep(j, 0, N) {\n\t\t\t\tcout << field[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int x, int y, vector<vector<int>> &field) {\n\tqueue<pair<int, int>>Q;\n\tQ.push(make_pair(x, y));\n\twhile (!Q.empty()) {\n\t\tauto a = Q.front(); Q.pop();\n\t\tif (a.first < 0 || N <= a.first || a.second < 0 || N <= a.second)continue;\n\n\t\tint b = a.first + 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first + 1, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second + 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first - 1, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t\tb = a.first, c = a.second - 1;\n\t\tif (0 <= b&&b < N && 0 <= c&&c < N&&field[b][c] == -1) {\n\t\t\tfield[b][c] = max(0, field[a.first][a.second] - 1);\n\t\t\tQ.push(make_pair(b, c));\n\t\t}\n\t}\n\n\tint ans(0);\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (0 < field[i][j] && field[i][j] < INF)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tfield = vector<vector<int>>(N, vector<int>(N, -1));\n\n\t\tint x, y;\n\t\trep(i, 0, n) {\n\t\t\tcin >> x >> y;\n\t\t\tx += 40; y += 40;\n\t\t\tfield[x][y] = INF;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += 40; sy += 40;\n\t\tfield[sx][sy] = t+1;\n\t\tcout << solve(sx, sy, field) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint map[200][200],H[6][2]={{-1,-1},{0,-1},{-1,0},{1,0},{0,1},{1,1}},sum;\n\nvoid move(int h,int w,int t)\n{\n  if(t==0)return;\n  for(int i=0;i<6;i++){\n    if(map[h+H[i][0]][w+H[i][1]]==0){\n      sum++;\n      map[h+H[i][0]][w+H[i][1]]=2;\n    }\n  }for(int i=0;i<6;i++){\n    if(map[h+H[i][0]][w+H[i][1]]==2){\n      move(h+H[i][0],w+H[i][1],t-1);\n    }\n  }\n}\nint main()\n{\n  int x,y,t,n;\n\n  while(1){\n    cin>>t>>n;\n    if(t==0&&n==0)break;\n    sum=0;\n    for(int i=0;i<200;i++){\n      for(int j=0;j<200;j++)map[i][j]=0;\n    }\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      map[100+x][100+y]=1;\n    }\n    cin>>x>>y;\n    x+=100;\n    y+=100;\n    map[x][y]=2;\n    sum++;\n    move(x,y,t);\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[62][62];\n//complex<int> p;\t\t//テ」ツ?づ」ツつ古」ツ??、ツスツソテ」ツつ湘」ツ?ェテ」ツ??\n\nint dx[] = {0,1,0,-1,1,-1};\nint dy[] = {1,0,-1,0,1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n//\tcout<< x-30-2<< \" \"<< y-30-2<< \" \"<< t<< \" \"<< ans<< endl;\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = 1;\n\tif(t<=0) return;\n\t\n\tfor(int i=0;i<6;i++){\n\t\tif(hoge[x+dx[i]][y+dy[i]] != -1){\t\t//テ」ツδ淌」ツつケ : hoge[][]==1テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ッテ・ツ按・テ」ツ?ォテ・ツ閉湘ゥツ。ツ古」ツ?ェテ」ツ??\n\t\t\tf(x+dx[i],y+dy[i],t-1,ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<62;i++){\n\t\t\tfor(int j=0;j<62;j++){\n\t\t\t\thoge[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 30;\n\t\ty += 30;\n\t\t\n\t\tint ans = 0;\n\t\tf(x,y,t,ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<pair<int, int>, int> P;\n\nint main()\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\twhile (1)\n\t{\n\t\tint n, t;\n\t\tint ans = 0;\n\t\tcin >> t >> n;\n\t\tif (t == 0 && n == 0)\n\t\t\tbreak;\n\n\t\tint ban[150][150];\n\t\tfill(ban[0], ban[150], 1e8 - 1);\n\t\t//(75,75)が(0,0)に相当\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tban[x + 75][y + 75] = -1; //到達不可\n\t\t}\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx += 75;\n\t\ty += 75;\n\t\tban[x][y] = 0; //スタート\n\t\tdeque<P> que;\n\t\tque.push_back(P(make_pair(x, y), 0));\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP p = que.back();\n\t\t\tpair<int, int> za = p.first;\n\t\t\tque.pop_back();\n\t\t\tif (p.second > ban[za.first][za.second])\n\t\t\t\tcontinue;\n\t\t\t//隣接マスを探す\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tif (ban[za.first + dx[i]][za.second + dy[i]] == -1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p.second + 1 < ban[za.first + dx[i]][za.second + dy[i]])\n\t\t\t\t{\n\t\t\t\t\tban[za.first + dx[i]][za.second + dy[i]] = p.second + 1;\n\t\t\t\t\tif (p.second + 1 < t)\n\t\t\t\t\t\tque.push_back(P(make_pair(za.first + dx[i], za.second + dy[i]), p.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 150; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 150; j++)\n\t\t\t{\n\t\t\t\tif (ban[i][j] != 1e8 - 1 && ban[i][j] > -1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 60>, 60> hex, array<array<int32_t, 60>, 60> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 1;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {0, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t i = iter->first;\n      int32_t j = iter->second;\n      if (0 <= x + i && x + i < 60 && 0 <= y + j && y + j < 60 && !hex[x + i][y + j] && dists[x + i][y + j] == 0) {\n        dists[x + i][y + j] = dists[x][y] + 1;\n        q.push({x + i, y + j});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 60>, 60> hex;\n    array<array<int32_t, 60>, 60> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = 0;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 30][y + 30] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 30, y + 30);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (1 <= *i && *i <= t + 1) {\n          count++;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        vector<pii> v[31];\n        int ans = 0;\n        rep(i, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -1) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) <= t) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) <= t) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\n#define INF 999999999\nusing namespace std;\nint mp[610][610];\nvoid dfs(int x, int y, int n) {\n  if (n == 0 || mp[y][x] == 9)\n    return;\n  mp[y][x] = 7;\n  dfs(x + 1, y, n - 1);\n  dfs(x, y + 1, n - 1);\n  dfs(x - 1, y, n - 1);\n  dfs(x, y - 1, n - 1);\n  dfs(x + 1, y + 1, n - 1);\n  dfs(x - 1, y - 1, n - 1);\n}\nint main() {\n  int n, t;\n  while (cin >> t >> n) {\n    if (t == 0 && n == 0)\n      break;\n    int jx, jy, ans = 0;\n    rep(i, n) {\n      cin >> jx >> jy;\n      mp[jy + 300][jx + 300] = 9;\n    }\n    cin >> jx >> jy;\n    dfs(jx + 300, jy + 300, t + 1);\n    rep(i, 600) rep(j, 600) if (mp[i][j] == 7) ans++;\n    cout << ans << endl;\n    rep(i, 600) rep(j, 600) mp[i][j] = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,y,t;\n};\n\nint main(){\n  for(int t,n;cin>>t>>n,t|n;){\n    bool p[128][128]={{}};\n    bool o[128][128]={{}};\n    while(n--){\n      int x,y;\n      cin>>x>>y;\n      o[y+64][x+64]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<S> que;\n    S is={sx+64,sy+64,t};\n    que.push(is);\n    while(!que.empty()){\n      S c=que.front();\n      que.pop();\n      if(p[c.y][c.x]++)continue;\n      if(c.t){\n\tfor(int i=0;i<6;i++){\n\t  int dy[]={1,1,0,-1,-1,0};\n\t  int dx[]={0,1,1,0,-1,-1};\n\t  int x=c.x+dx[i];\n\t  int y=c.y+dy[i];\n\t  if(x<0||128<x||y<0||128<y||o[y][x]){\n\t    continue;\n\t  }else{\n\t    S ns={x,y,c.t-1};\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    cout<<count(p[0],p[128],true)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    while(true){\n        int field[100][100];\n        int cfield[100][100];\n        int t, n;\n        scanf(\"%d%d\", &t, &n);\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                field[i][j] = cfield[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            x += 50; y += 50;\n            field[x][y] = -1;\n            cfield[x][y] = -1;\n        }\n        int cx, cy;\n        scanf(\"%d%d\", &cx, &cy);\n        cx += 50; cy += 50;\n        field[cx][cy] = cfield[cx][cy] = 1;\n        for(int _ = 0; _ < t; _++){\n            for(int i = 5; i < 95; i++){\n                for(int j = 5; j < 95; j++){\n                    if(field[i][j] > 0){\n                        for(int d = 0; d < 6; d++){\n                            int ni = i + dx[d];\n                            int nj = j + dy[d];\n                            if(cfield[ni][nj] >= 0){\n                                cfield[ni][nj] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            for(int i = 0; i < 100; i++){\n                for(int j = 0; j < 100; j++){\n                    field[i][j] = cfield[i][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 100; i++){\n            for(int j = 0; j < 100; j++){\n                if(field[i][j] > 0){\n                    ++ans;\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 35\n#define NN 70\n#define UNKNOWN 0\nusing namespace std;\n#define S pair<int,int>\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,0,1,-1,0,-1};\n  int dy[6] = {0,1,1,0,-1,-1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y;\n      d[y+N][x+N] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    queue<S> q; q.push( S(x+N,y+N) ); d[y+N][x+N]=1;\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      int nt = d[s.second][s.first] + 1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.first+dx[i], ny=s.second+dy[i];\n\tif( d[ny][nx]==UNKNOWN ){\n\t  d[ny][nx]=nt; ans++;\n\t  if( nt<=t ) q.push( S(nx,ny) );\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 30;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[70][70]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (nx < 0 || ny < 0 || nx >= 2 * base || ny >= 2 * base)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define TEST 0\n#if TEST\nFILE *in = freopen(\"./q.txt\", \"r\", stdin);\nFILE *out = freopen(\"./a.txt\", \"w\", stdout);\n#endif\n\nint dx[6] = { 0, 1, 1, 0,-1,-1};\nint dy[6] = { 1, 1, 0,-1,-1, 0};\n\ninline void pusuQueue(queue<int>& q, int x, int y, int t){\n\tq.push(x), q.push(y), q.push(t);\n}\ninline void popQueue(queue<int>& q, int& x, int& y, int& t){\n\tx = q.front(); q.pop();\n\ty = q.front(); q.pop();\n\tt = q.front(); q.pop();\n}\n\ninline bool isRegion(int x, int y){\n\treturn x >= -30 && x <= 30 && y >= -30 && y <= 30;\n}\n\nint main(){\n\twhile (1){\n\t\tint t, n; cin >> t >> n;\n\t\tif (!t && !n) break;\n\n\t\tmap<pair<int, int>, bool> isBar;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tisBar[make_pair(x, y)] = true;\n\t\t}\n\t\t\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tisBar[make_pair(sx, sy)] = true;\n\n\t\tint cnt = 0;\n\t\tqueue<int> q;\n\t\tpusuQueue(q, sx, sy, 0);\n\t\twhile (!q.empty()){\n\t\t\tint x, y, turn; popQueue(q, x, y, turn);\n\t\t\tcnt++;\n\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (turn < t && isRegion(nx, ny) && !isBar[make_pair(nx, ny)]){\n\t\t\t\t\tpusuQueue(q, nx, ny, turn+1);\n\t\t\t\t\tisBar[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\n\t}\n\n\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tvector< vector<int> > hyou(61, vector<int>(61, 0));\n\tint t, n, x, y;\n\twhile (cin >> t >> n) {\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\thyou[x+30][y+30] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tqueue<Q> q;\n\t\tQ qq;\n\t\tqq.first = 0;\n\t\t(qq.second).first = x+30;\n\t\t(qq.second).second = y+30;\n\t\tq.push(qq);\n\t\tint counter = 1;\n\t\thyou[x+30][y+30] = -1;\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tif (hyou[(p.second).first][(p.second).second+1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first][(p.second).second+1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).second++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hyou[(p.second).first+1][(p.second).second+1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first+1][(p.second).second+1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first++;\n\t\t\t\t(p2.second).second++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hyou[(p.second).first+1][(p.second).second] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first+1][(p.second).second] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first++;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hyou[(p.second).first][(p.second).second-1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first][(p.second).second-1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).second--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hyou[(p.second).first-1][(p.second).second-1] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first-1][(p.second).second-1] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first--;\n\t\t\t\t(p2.second).second--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hyou[(p.second).first-1][(p.second).second] == 0) {\n\t\t\t\tcounter++;\n\t\t\t\thyou[(p.second).first-1][(p.second).second] = -1;\n\t\t\t\tQ p2 = p;\n\t\t\t\tp2.first++;\n\t\t\t\t(p2.second).first--;\n\t\t\t\tif (p2.first < t) {\n\t\t\t\t\tq.push(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nint main() {\n\twhile(true) {\n\tint T, N;\n\tcin >> T >> N;\n\t\n\t\tif (T == 0 && N == 0) break;\n\t// x, y\n\tset<P> obj;\n\t\n\tfor(int i = 0; i < N; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tobj.insert(make_pair(x, y));\n\t}\n\t\n\tP start;\n\tcin >> start.first >> start.second;\n\t\n\tqueue<P> Q;\n\tqueue<P> Next;\n\tset<P> vis;\n\tQ.push(start);\n\t\n\t\tvis.insert(start);\n\t\t\n\tint cnt = 1;\n\t\n\twhile(T--) {\n\t\twhile(!Next.empty()) Next.pop();\n\t\t\n\t\twhile(!Q.empty()) {\n\t\t\tP cur = Q.front(); Q.pop();\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tP p;\n\t\t\t\tp.first = cur.first + dx[i];\n\t\t\t\tp.second = cur.second + dy[i];\n\t\t\t\tif(obj.count(p)) continue;\n\t\t\t\tif(vis.count(p)) continue;\n\t\t\t\tvis.insert(p);\n\t\t\t\tNext.push(p);\n\t\t\t\t\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ = Next;\n\t}\n\t\n\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n\n//???????????????\nint di[6] = {1, 1, 0, -1, -1, 0};\nint dj[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\n    while(1){\n\n        int n, t; cin >> t >> n;\n        if(n == 0 && t == 0) break;\n        vector<vector<bool> > canGo(1000, vector<bool> (1000, true));\n        for(int k = 0; k < n; k++){\n            int i, j; cin >> i >> j;\n\n            //??§?¨???????\n            i += 100;\n            j += 100;\n            canGo[i][j] = false;\n        }\n        int si, sj; cin >> si >> sj;\n        si += 100;\n        sj += 100;\n\n        //???????????????s????????±????????\\??????????????????????????¢????????????\n        queue<pair<int, pair<int, int> > > wait;\n        wait.push(make_pair(0, make_pair(si, sj)));\n        canGo[si][sj] = false;\n\n        //??\\???????????????\n        int counter = 1;\n        while(!wait.empty()){    //?????\\???????????????????????§\n            //?????\\????????????????´????????????????\n            int nowcost = wait.front().first;\n            int nowi = wait.front().second.first;\n            int nowj = wait.front().second.second;\n\n            wait.pop();\n\n            //???????????°??????????????????????????¢?´¢?????????\n            if(nowcost == t){\n                continue;\n            }\n\n            //??????????????¢?´¢\n            for(int k = 0; k < 6; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //??????????????????????????????\n                if(canGo[nexti][nextj]){\n                    //????????????????????\\???????????????\n                    //??????????´¢???????????¨????????????????£???§?????????\n                    wait.push(make_pair(nowcost + 1, make_pair(nexti, nextj)));\n                    canGo[nexti][nextj] = false;\n                    counter++;\n                }\n            }\n        }\n\n        cout << counter << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nbool pass[100][100];\nbool used[100][100];\nint t,n;\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(pass,0,sizeof(pass));\n\t\tmemset(used,0,sizeof(used));\n\t\tint X,Y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tpass[Y+40][X+40]=true;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\tqueue<int> xs,ys,cnts;\n\t\txs.push(X+40); ys.push(Y+40); cnts.push(0);\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front(),cnt=cnts.front();\n\t\t\txs.pop(); ys.pop(); cnts.pop();\n\t\t\tused[y][x]=true;\n\t\t\tif(cnt<t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx&&nx<61&&0<=ny&&ny<61&&!pass[ny][nx]&&!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny); cnts.push(cnt+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 0, 1,-1};\nconst int dy[] = {1, 0,-1,-1, 1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[66][66];\n        for (int i = 0; i < 66; i++) for (int j = 0; j < 66; j++) d[i][j] = INF;\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 31][t2 + 31] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 31][y + 31] = 0;\n        queue<P> q;\n        q.push(P(x + 31, y + 31));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (d[nx][ny] != -1 && d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                    if (d[nx][ny] == INF) count++;\n                    q.push(P(nx,ny));\n                    d[nx][ny] = d[p.first][p.second] + 1;\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint tile[70][70];\nusing vpii = vector<pair<int,int>>;\nint dx[] = {1,-1,0,0,-1,1};\nint dy[] = {1,-1,1,-1,0,0};\n\n\nint main()\n{\n  int t,n;\n  while(cin >> t >> n,t+n){\n    REP(i,70){\n      REP(j,70){\n        tile[i][j] = 0;\n      }\n    }\n    vpii pii;\n    REP(i,n){\n      int c,k;\n      cin >> c >> k;\n      pii.push_back({k,c});\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    tile[35][35] = 1;\n    for(auto x : pii){\n      tile[x.first-sy+35][x.second-sx+35] = 2;\n    }\n    REP(_t,t){\n      REP(i,70){\n        REP(j,70){\n          if(tile[i][j] == 1){\n           REP(k,6){\n            auto ny = max(0,min(69,i + dy[k]));\n            auto nx = max(0,min(69,j+dx[k]));\n            if(tile[ny][nx]==0){\n              tile[ny][nx] = -1;\n            }\n           }\n          }\n        }\n      }\n      REP(i,70){\n        REP(j,70){\n          if(tile[i][j]==-1){\n            tile[i][j] = 1;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i,70){\n      REP(j,70){\n        if(tile[i][j]==1){\n          ans++;\n        }\n      }\n    }\n    cout << ans<< endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[61][61];\nint t,n;\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty() && q.front().first < t){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\tcout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n\tgrid[ny][nx]=-1;\n      }\n    }\n  }\nreturn res;\n}\n\nint main(){\n    while(cin>>t>>n){\n      if(t==0 && n==0)break;\n      memset(grid,0,sizeof(grid));\n      for(int i=0;i<n;i++){\n\tint x,y;\n\tcin>>x>>y;\n\tgrid[y+30][x+30]=-1;\n      }\n      int sx,sy;\n      cin>>sx>>sy;\n      grid[sy+30][sx+30]=-1;\n      cout <<  bfs(sx+30,sy+30) << endl;\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\t//cin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define MOD 100000\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct A{int x,y,c;};\nint dx[6]={-1,-1,0,0,1,1};\nint dy[6]={-1,0,1,-1,1,0};\nint main(){\n      int t,n,x,y,sx,sy;\n      while(cin>>t>>n&&(t!=0||n!=0)){\n            bool used[61][61];\n            memset(used,true,sizeof(used));\n            REP(i,n){cin>>x>>y;used[x+30][y+30]=false;}\n            cin>>sx>>sy;\n            int cnt=1;used[sx+30][sy+30]=false;\n            queue<A> Q;\n            Q.push((A){sx+30,sy+30,0});\n            while(!Q.empty()){\n                  //cout<<Q.size()<<endl;\n                  A a=Q.front();Q.pop();\n                  if(a.c>=t)continue;\n                  REP(i,6){\n                        int nx=a.x+dx[i],ny=a.y+dy[i];\n                        //cout<<nx<<\" \"<<ny<<endl;\n                        if(nx>60||nx<0||ny>60||ny<0)continue;\n                        if(used[nx][ny]){\n                              //cout<<nx<<\" \"<<ny<<endl;\n                              used[nx][ny]=false;\n                              Q.push((A){nx,ny,a.c+1});\n                              cnt++;\n                        }\n                  }\n            }\n            cout<<cnt<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n); for(int i=0;i<(n);i++)\n\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> p;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] = 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0)\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\nint t,n,sx,sy;\nbool used[111][111];\nint dx[] = {1,-1,0,0,1,-1};\nint dy[] = {0,0,1,-1,1,-1};\nint main(void){\n  while(cin >> t >> n && t){\n    memset(used,false,sizeof(used));\n    for(int i = 0; i < n; i++){\n      int x,y;\n      cin >> x >> y;\n      used[x+30][y+30] = true;;\n    }\n    cin >> sx >> sy;\n\n    queue<pair<int,pair<int,int> > > que;\n    que.push(make_pair(0,make_pair(sx+30,sy+30)));\n    used[sx+30][sy+30] = true;\n    int res = 0;\n    while(!que.empty()){\n      int nt = que.front().first;\n      int x = que.front().second.first;\n      int y = que.front().second.second;\n      que.pop();\n      if(nt > t) continue;\n      res++;\n      for(int i = 0; i < 6; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(nx < 0 || ny < 0 || 60 < nx || 60 < ny || used[nx][ny]) continue;\n\tused[nx][ny] = true;\n\tque.push(make_pair(nt+1,make_pair(nx,ny)));\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int base = 30;\n\nclass state {\npublic:\n    int x, y, t;\n    state(int a, int b, int c) { x = a; y = b; t = c; }\n};\n\nint main()\n{\n    int t, n;\n\n    while (cin >> t >> n, t || n) {\n        int map[70][70]; // 0: 未到達   1: 敵    2: 到達済み\n        int t_x, t_y, s_x, s_y;\n        int ans = 0;\n        \n        memset(map, 0, sizeof(map));\n        for (int i = 0; i < n; i++) {\n            cin >> t_x >> t_y;\n            map[t_y + base][t_x + base] = 1;\n        }\n        cin >> s_x >> s_y;\n\n        queue<state> q;\n        q.push(state(s_x + base, s_y + base, 0));\n        map[s_y + base][s_x + base] = 2;\n        ans++;\n\n        while (!q.empty()) {\n            state now = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = now.x + dx[i];\n                int ny = now.y + dy[i];\n\n                if (map[ny][nx] == 1 || map[ny][nx] == 2)\n                    continue;\n                if (now.t + 1 > t)\n                    continue;\n                map[ny][nx] = 2;\n                ans++;\n                q.push(state(nx, ny, now.t + 1));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\nconst int OBSTACLE = -INF;\nconst int DIFF = 50;\nint field[100][100];\n\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1};\n\nbool in_field(int x, int y){\n    return 0<=x && x<100 & 0<=y && y<100;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T, N;\n    while(cin>>T>>N, T|N){\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                field[i][j] = INF;\n        int x, y;\n        while(N--){\n            cin >> x >> y;\n            field[x+DIFF][y+DIFF] = OBSTACLE;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        \n        queue<pair<int, int>> que;\n        field[sx+DIFF][sy+DIFF] = 0;\n        que.push(make_pair(sx+DIFF, sy+DIFF));\n        \n        while(!que.empty()){\n            auto p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            \n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(in_field(nx, ny) && field[nx][ny] == INF){\n                    field[nx][ny] = field[x][y] + 1;\n                    que.push(make_pair(nx, ny));\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                ans += (0<=field[i][j] && field[i][j]<=T);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <deque>\nusing namespace std;\nusing T = tuple<int,int,int>;\n\nbool ob[100][100];//x,y\nbool visited[100][100];\n\nint main(){\n    int t,n;\n    while(cin>>t>>n,t){\n        fill(ob[0],ob[100],false);\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+50][y+50]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n        sx+=50; sy+=50;\n        fill(visited[0],visited[100],false);\n        deque<T> Q;\n        Q.emplace_back(sx,sy,0);\n        while(!Q.empty()){\n            int x,y,turn;\n            tie(x,y,turn) = Q.front(); Q.pop_front();\n            if(visited[x][y]||turn>t) continue;\n            visited[x][y]=true;\n            int nx,ny;\n            turn++;\n\n            nx=x+1; ny=y;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            nx=x+1; ny=y+1;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            nx=x; ny=y+1;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            nx=x-1; ny=y;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            nx=x-1; ny=y-1;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n            nx=x; ny=y-1;\n            if(!visited[nx][ny]&&!ob[nx][ny]) Q.emplace_back(nx,ny,turn);\n        }\n        int ans = 0;\n        for(int i=0;i<100;i++){\n            for(int j=0;j<100;j++) ans+=visited[i][j];\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) > i || abs(b[k]) > i) continue;\n                        int flg = 0;\n                        if (i % 2 == 0) {\n                            if (a[k] == i / 2 && b[k] == -i / 2) {ans--; flg = 1;}\n                            if (a[k] == -i / 2 && b[k] == i / 2) {ans--; flg = 1;}\n                        }\n                        if (flg == 0) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) > t || abs(b[i]) > t) continue;\n            int flg = 0;\n            if (t % 2 == 0) {\n                if (a[i] == t / 2 && b[i] == -t / 2) {flg = 1; ans--;}\n                if (a[i] == -t / 2 && b[i] == t / 2) {flg = 1; ans--;}\n            }\n            if (flg == 0) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define ADD 100\n\nint map[200][200];\nint dx[]={0,1,-1,1,-1,0};\nint dy[]={1,1,0,0,-1,-1};\nvoid check(int x,int y,int t)\n{\n  if(map[x][y]==-1)\n    return;\n  map[x][y]=1;\n  if(t<=0)\n    return;\n  for(int i=0;i<6;i++)\n    check(x+dx[i],y+dy[i],t-1);\n}\n\nint main()\n{\n  int t,n;\n  for(;cin>>t>>n,t;)\n    {\n      memset(map,0,sizeof(map));\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin>>x>>y;\n\t  map[x+ADD][y+ADD]=-1;\n\t}\n      int x,y;\n      cin>>x>>y;\n      check(x+ADD,y+ADD,t);\n      int ans=0;\n      for(int i=0;i<200;i++)\n\tfor(int j=0;j<200;j++)\n\t  if(map[i][j]==1)\n\t    {\n\t      //\t      cout<<i-ADD<<\" \"<<j-ADD<<endl;\n\t      ans++;\n\t    }\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n\nvoid dfs(int x,int y,int turn,vvi &ob,vvi &iscan);\nint t;\n\nint main(){\n    int n;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        dfs(x+30,y+30,0,ob,iscan);\n        int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<\"///\"<<endl;\n        REP(i,61)\n        REP(j,61)\n            if(iscan[i][j])\n                cout<<i-30<<\" \"<<j-30<<endl;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n\n}\nvoid dfs(int x,int y,int turn,vvi &ob,vvi &iscan){\n    iscan[x][y]=1;\n    if(turn>=t)\n        return;\n    REP(i,6){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(isRange(nx,ny)&&!ob[nx][ny])\n            dfs(nx,ny,turn+1,ob,iscan);\n    }\n    return;\n\n\n\n}\n              "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n//[-60,60] -> [0,120]\nint f[121][121];\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n    int t,n;\n    \n    while(cin >> t >> n){\n        if((t|n) == 0) break;\n        memset(f,0,sizeof(f));\n        int x,y;\n        vector<pair<int,int> > diff;\n\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            f[x+60][y+60] = -1;\n        }\n\n        cin >> x >> y;\n        x += 60;\n        y += 60;\n        f[x][y] = 1;\n        \n        for(int i=0;i<t;i++){\n            for(int p=0;p<121;p++){\n                for(int q=0;q<121;q++){\n                    if(f[p][q] == 1){\n                        for(int k=0;k<6;k++){\n                            x = p + dx[k];\n                            y = q + dy[k];\n\n                            if(0 <= x && x < 121 &&\n                               0 <= y && y < 121 &&\n                                f[x][y] != -1){\n                                diff.push_back(make_pair(x,y));\n                            }\n                        }\n                    }\n                }\n            }\n            for(int j=0;j<diff.size();j++){\n                f[diff[j].first][diff[j].second] = 1;\n            }\n            diff.clear();\n        }\n        int ret = 0;\n\n        for(int i=0;i<121;i++){\n            for(int j=0;j<121;j++){\n                if(f[i][j] == 1) ret++;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\ntypedef struct p{int x,y,t;}p;\nint T,N,i,j,x,y,f[200][200]={0},l,r,t;\nint dbg[10000][2],D=0;\np tmp;\nqueue<p>q;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ttmp.x=x+70;\n\t\ttmp.y=y+70;\n\t\ttmp.t=T;\n\t\tq.push(tmp);\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\ttmp=q.front();\n\t\t\tq.pop();\n\t\t\tx=tmp.x;\n\t\t\ty=tmp.y;\n\t\t\tt=tmp.t;\n\t\t\t\n\n\t\t\tdbg[D][0]=x-70;\n\t\t\tdbg[D][1]=y-70;\n\t\t\tD++;\n\t\t\tfor(i=0;i<6;i++)\n\t\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t\t{\n\t\t\t\t\ttmp.x=x+mx[i];\n\t\t\t\t\ttmp.y=y+my[i];\n\t\t\t\t\ttmp.t=t-1;\n\t\t\t\t\tq.push(tmp);\n\t\t\t\t\tf[tmp.x][tmp.y]=-1;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<200;i++)\n\t\t\tfor(j=0;j<200;j++)\n\t\t\t\tif(f[i][j]==-1)\n\t\t\t\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint t,n;\n\tcin >> t >> n;\n\t\n\twhile ( t != 0 || n != 0 ) {\n\t\tstd::map< std::pair<int,int>, int> area;\n\t\tstd::pair<int,int> now,temp;\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tcin >> temp.first >> temp.second;\n\t\t\tarea[temp] = -1;\n\t\t}\n\n\t\tint count_area = 1;\n\t\tcin >> now.first >> now.second;\n\t\tstd::queue< std::pair<int,int> > search;\n\t\tstd::queue<int> d;\n\t\tsearch.push(now);\n\t\td.push(0);\n\t\tint turn = 0;\n\n\t\twhile ( turn < t ) {\n\t\t\tnow = search.front();\n\t\t\ttemp = now;\n\t\t\tarea[temp] = -1;\n\n\t\t\tturn = d.front();\n\t\t\tsearch.pop();\n\t\t\td.pop();\n\n\t\t\ttemp.first++;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\ttemp.second++;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\ttemp.first--;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\ttemp.first--;\n\t\t\ttemp.second--;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\ttemp.second--;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\ttemp.first++;\n\t\t\tif (area[temp] != -1) {\n\t\t\t\tsearch.push(temp);\n\t\t\t\td.push(turn+1);\n\t\t\t\tcount_area++;\n\t\t\t\tarea[temp] = -1;\n\t\t\t}\n\t\t\tturn = d.front();\n\t\t}\n\n\t\tcout << count_area << endl;\n\t\tcin >> t >> n;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tvector< vector<int> > hyou(201, vector<int>(201, 0));\n\tint t, n, x, y;\n\twhile (cin >> t >> n) {\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\thyou[x+100][y+100] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tqueue<Q> q;\n\t\tQ qq;\n\t\tqq.first = 0;\n\t\t(qq.second).first = x+100;\n\t\t(qq.second).second = y+100;\n\t\tq.push(qq);\n\t\tint counter = 1;\n\t\thyou[x+100][y+100] = -1;\n\t\tint dx[] = {0, 1, 1, 0, -1, -1};\n\t\tint dy[] = {1, 1, 0, -1, -1, 0};\n\t\twhile (!q.empty()) {\n\t\t\tQ p = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tif (hyou[(p.second).first+dx[i]][(p.second).second+dy[i]] == 0) {\n\t\t\t\t\tcounter++;\n\t\t\t\t\thyou[(p.second).first+dx[i]][(p.second).second+dy[i]] = -1;\n\t\t\t\t\tQ p2 = p;\n\t\t\t\t\tp2.first++;\n\t\t\t\t\t(p2.second).first += dx[i];\n\t\t\t\t\t(p2.second).second += dy[i];\n\t\t\t\t\tif (p2.first < t) {\n\t\t\t\t\t\tq.push(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[6] = {  0,  1,  1,  0, -1, -1 };\n  int dy[6] = {  1,  1,  0, -1, -1,  0 };\n\n  long long int t, n, inputx, inputy;\n\n  while( true ) {\n\n    cin >> t >> n;\n\n    if ( t == 0 ) break;\n\n    int map[200][200] = {};\n\n    for ( long long int i = 0; i < n; i++ ) {\n\n      cin >> inputx >> inputy;\n\n      map[ inputx + 100 ][ inputy + 100 ] = -1;\n\n    }\n\n    cin >> inputx >> inputy;\n\n    queue<int> qx, qy;\n\n    qx.push( inputx + 100 );\n    qy.push( inputy + 100 );\n\n    map[ qx.front() ][ qy.front() ] = 1;\n\n    long long int ans = 1;\n\n    while( qx.size() > 0 ) {\n\n      int x = qx.front();\n      int y = qy.front();\n      qx.pop();\n      qy.pop();\n\n      for ( int i = 0; i < 6; i++ ) {\n\n\tif ( map[ x + dx[i] ][ y + dy[i] ] == 0 ) {\n\n\t  map[ x + dx[i] ][ y + dy[i] ] = map[x][y] + 1;\n\t  ans++;\n\t  if ( map[x][y] < t ) {\n\t    qx.push( x + dx[i] );\n\t    qy.push( y + dy[i] );\n\t  }\n\n\t}\n\n      }\n\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[64][64] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    cin >> tt >> nn;\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      cin >> x >> y;\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    cin >> x >> y;\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<64;j++){\n      for(k=0;k<64;k++){\n        visited[j][k]=0;\n      }\n    }\n    cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  //if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  if(t==1){\n    if(visited[x][y]==1) return ans;\n    else {visited[x][y]=1;return ans+1;}\n  }\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n,s=1000;\n\tvvi field(s*2+3,vi(s*2+3,0));\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=s+1,y+=s+1;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t && !que.empty()){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=2;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {1,0,-1,-1,0,1};\nconst int dx[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      if(d == t) break;\n      ++d;\n      auto S = q.size();\n      rep(j,S){\n        auto Q = q.front();q.pop();\n        rep(i,6){\n          ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n          if(value(nx,ny,62,62) && v[nx][ny] == inf){\n            q.push(mp(nx,ny));\n            v[nx][ny] = d;\n            ++cnt;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 10000\n#define MAX_HALF 5000\nusing namespace std;\n\nstruct P{\n    int x;\n    int y;\n    int cnt;\n    P(int x, int y, int cnt){\n        this->x = x;\n        this->y = y;\n        this->cnt = cnt;\n    }\n};\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[MAX][MAX];\nbool used[MAX][MAX];\n\nint t, n;\n\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < MAX; i++) for(int j = 0; j < MAX; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += MAX_HALF; y += MAX_HALF;\n            g[y][x] = 1;\n        }\n        int x, y, cnt = 0;\n        cin >> x >> y;\n        x += MAX_HALF; y += MAX_HALF;\n\n        int ans = 0;\n        queue< P > que;\n        que.push( P(x, y, 0) );\n\n        while(!que.empty()){\n            P q = que.front(); que.pop();\n            x = q.x; y = q.y; cnt = q.cnt;\n            if(cnt > t) break;\n            ans++;\n\n            used[y][x] = true;\n            for(int d = 0; d < 6; d++){\n                int nx = x + dx[d], ny = y + dy[d];\n                if(used[ny][nx] == true || g[ny][nx] == 1) continue;\n                used[ny][nx] = true;\n                que.push(P(nx, ny, cnt+1));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\nint dfs(int x, int y, int turn){\n    if(used[y][x] || g[y][x] == 1 || turn > t ) return 0;\n    used[y][x] = true;\n\n    int res = 0;\n    for(int d = 0; d < 6; d++){\n        int nx = x + dx[d], ny = y + dy[d];\n        res += dfs(nx, ny, turn+1);\n    }\n    used[y][x] = false;\n    return res + 1;\n}\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y;\n        cin >> x >> y;\n        x += 50; y += 50;\n        cout << dfs(x, y, 0) << endl;\n    }\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { 1,1, 0, -1, -1,0 }; const int dy2[] = { 0, 1, 1,0,-1, -1 };\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n, t | n) {\n\t\tset<pii> jama;\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tjama.insert(pii(x, y));\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tqueue<pii> Q;\n\t\tQ.push(pii(sx, sy));\n\t\tset<pii> S;\n\t\tS.insert(pii(sx, sy));\n\t\tint ans = 1;\n\t\tREP(i, t) {\n\t\t\tqueue<pii> Q2;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tpii q = Q.front();Q.pop();\n\t\t\t\tREP(j, 6) {\n\t\t\t\t\tif (/*-30 <= q.first + dx2[j] && q.first + dx2[j] <= 30 && \n\t\t\t\t\t\t-30 <= q.second + dy2[j] && q.second + dy2[j] <= 30 &&*/\n\t\t\t\t\t\tS.find(pii(q.first + dx2[j], q.second + dy2[j])) == S.end() && \n\t\t\t\t\t\tjama.find(pii(q.first + dx2[j], q.second + dy2[j])) == jama.end()) {\n\n\t\t\t\t\t\tS.insert(pii(q.first + dx2[j], q.second + dy2[j]));\n\t\t\t\t\t\tQ2.push(pii(q.first + dx2[j], q.second + dy2[j]));\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ = Q2;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define MIN -1000\n#define MAX 10000\n\nusing namespace std;\ntypedef struct d\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != MAX && map[cy][cx] + 1 > t)continue;\n\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == MIN)continue;\n\t\t\t\tif (map[ny][nx] != MAX)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != MIN && map[i][j] != MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0, 1, -1};\nint dy[] = {0, 0, 1, -1, 1, -1};\n\nint T, N;\nint maze[61][61];\n\nbool check(int x, int y){\n\treturn x >= 0 && x < 61 && y >= 0 && y < 61 && maze[x][y] != 2;\n}\n\nvoid dfs(int t, int x, int y, int& count){\n\tif(t == T + 1)\n\t\treturn;\n\tif(maze[x][y] != -1)\n\t\tcount++;\n\tmaze[x][y] = -1;\n\tfor(int i = 0; i < 6; ++i){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(check(nx, ny))\n\t\t\tdfs(t + 1, nx, ny, count);\n\t}\n}\n\nint main() {\n\twhile(cin >> T >> N && (T || N)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tint a, b;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> a >> b;\n\t\t\tmaze[a + 30][b + 30] = 2;\n\t\t}\n\t\tint sx, sy, count = 0;\n\t\tcin >> sx >> sy;\n\t\tdfs(0, sx + 30, sy + 30, count);\n\t\tcout << count << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nint main(void){\n\tint t, n, i, j, field[151][151], ix, iy, count;\n\tconst int standard = 75, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<int> x, y;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t == 0 && n == 0)\n\t\t\tbreak;\n\t\tmemset(field,-1,sizeof(field));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&ix,&iy);\n\t\t\tfield[iy + standard][ix + standard] = 0;\n\t\t}\n\t\tscanf(\"%d%d\",&ix,&iy);\n\t\tx.push(standard + ix),y.push(standard + iy);\n\t\tfield[standard + iy][standard + ix] = 0;\n\t\twhile(x.size()){\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(field[y.front() + dy[i]][x.front() + dx[i]] == -1 && field[y.front()][x.front()] < t){\n\t\t\t\t\tx.push(x.front() + dx[i]),y.push(y.front() + dy[i]);\n\t\t\t\t\tfield[y.front() + dy[i]][x.front() + dx[i]] = field[y.front()][x.front()] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.pop(), y.pop();\n\t\t}\n\t\tcount = 1;\n\t\tfor(i = 0;i < 151;i++){\n\t\t\tfor(j = 0;j < 151;j++){\n\t\t\t\tif(field[i][j] > 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 70\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs(int,int);\nint dy[6]={-1,-1,0,1,1,0};\nint dx[6]={-1,0,1,1,0,-1};\nint t;\nint data[N][N];\nint main(){\n  int n,x,y,sx,sy;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0;\n    while(n--){\n      cin >> x >> y;\n      data[y+32][x+32]=-1;\n    }\n    cin >> sx >> sy;\n    data[sy+32][sx+32]=1;\n    bfs(sy+32,sx+32);\n    int cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(data[i][j]==1) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid bfs(int y,int x){\n  queue<P1> Q;\n  Q.push(P1(0,P(y,x)));\n  while(Q.empty()!=1){\n    P1 v=Q.front();\n    Q.pop();\n    int d=v.first,y1=v.second.first,x1=v.second.second;\n    for(int i=0;i<6;i++){\n      if(0<=y1+dy[i]&&y1+dy[i]<N&&0<=x1+dx[i]&&x1+dx[i]<N&&data[y1+dy[i]][x1+dx[i]]==0){\n\tdata[y1+dy[i]][x1+dx[i]]=1;\n\tif(d<=t-2) Q.push(P1(d+1,P(y1+dy[i],x1+dx[i])));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[200][200];\nint y[200][200];\nint n, m, a, b, X, Y;\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t\ty[i][j] = 1145141919;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[a + 100][b + 100] = 1;\n\t\t}\n\t\tcin >> X >> Y;\n\t\ty[X + 100][Y + 100] = 0;\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 1; j < 199; j++) {\n\t\t\t\tfor (int k = 1; k < 199; k++) {\n\t\t\t\t\tif (y[j][k] < 1145141919) {\n\t\t\t\t\t\tfor (int l = 0; l < 6; l++) {\n\t\t\t\t\t\t\tif (x[dx[l] + j][dy[l] + k] == 0) {\n\t\t\t\t\t\t\t\ty[dx[l] + j][dy[l] + k] = min(y[dx[l] + j][dy[l] + k], y[j][k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tif (y[i][j] <= n) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\n#define SZ 100\n\nbool visited[SZ*2+5][SZ*2+5];\n\nbool isin(int x, int y){\n    if((x-SZ)*(y-SZ)>=0) return x>=0 && x<=SZ*2 && y>=0 && y<=SZ*2;\n    else return abs(x-SZ)+abs(y-SZ)<=SZ;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[SZ*2+5], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+SZ][y+SZ]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+SZ, sy+SZ), 0));\n        visited[sx+SZ][sy+SZ]=true;\n        int res=1;\n        while (!q.empty()){\n            int dx[] = {1,1,0,-1,-1,0};\n            int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second>=t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n//                    cout<<nx-SZ<<\",\"<<ny-SZ<<endl;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define N 100\n#define G 50\n#define KABE -10\n#define NON  -1\n\nint map[N][N];\n\nint ans;\nvoid dfs(int x, int y, int t ){\n  if( t==0 )\n    return;\n  if( map[x][y] == KABE )\n    return;\n\n  if( abs(x-G) > 30 ||  abs(y-G) > 30 )\n    return;\n\n  if( map[x][y] >= t )    return;\n\n  if( map[x][y] == NON )\n    ans++;\n  map[x][y] = t;\n\n\n  t--;\n  int dx[] = {1,1,0,-1,-1, 0};\n  int dy[] = {0,1,1, 0,-1,-1};\n  for( int d=0;d<6;d++ )\n    dfs(x+dx[d], y+dy[d], t );\n}\n\nint main(){\n  int t,n;\n  while( cin>>t>>n && (t|n) ){\n\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\tmap[i][j] = NON;\n\n    int y,x;\n    while( n-- ){\n      cin >> x >> y;\n      map[x+G][y+G] = KABE;\n    }\n    cin >> x >> y;\n\n    x+=G; y+=G;\n    ans = 0;\n    dfs(x, y, t+1 );\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {0,1,1,0,-1,-1};\nconst int    DY[] = {1,1,0,-1,-1,0};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nconst int M = 100;\nconst int OFFSET = 50;\nint T, N;\n\nVVB done;\nVVB bads;\n\nint solve() {\n    bads = VVB(M, VB(M));\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        bads[OFFSET + y][OFFSET + x] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    done = VVB(M, VB(M));\n\n    queue<pair<int, PII>> q;\n    q.push(MP(T, MP(OFFSET + sy, OFFSET + sx)));\n    while (q.size()) {\n        int t = q.front().fst;\n        int y = q.front().snd.fst;\n        int x = q.front().snd.snd;\n        q.pop();\n\n        if (done[y][x]) continue;\n        done[y][x] = true;\n        if (!t) continue;\n\n        rep(i, 6) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if (!RANGEBOX(ny, nx, M, M)) continue;\n            if (bads[ny][nx]) continue;\n            q.push(MP(t - 1, MP(ny, nx)));\n        }\n    }\n\n    int cnt = 0;\n    rep(i, M) cnt += count(ALL(done[i]), true);\n\n    return cnt;\n}\n\nint main(void) {\n    while (cin >> T >> N, T) cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pxyi;\n\nvector<pii> N;\nset <pii> s;\nconst int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {0, 1, 1, 0, -1, -1};\n  \nvoid bfs(int sx, int sy, int st)\n{\n  queue<pxyi> q;\n  q.push(pxyi(pii(sx,sy),st));\n  while(!q.empty()){\n    int x, y, t;\n    x = q.front().first.first;\n    y = q.front().first.second;\n    t = q.front().second;\n    q.pop();\n    s.insert(pii(x,y));\n    if(t == 0){\n      if(q.empty()) break;\n      else continue;\n    }\n    bool flag;\n    for(int i = 0; i < 6; i++){\n      flag = false;\n      int next_x = x + dx[i], next_y = y + dy[i];\n      for(int j = 0; j < (int)N.size(); j++){\n        if(N[j].first == next_x && N[j].second == next_y)\n          flag = true;\n      }\n      if(flag) continue;\n      q.push(pxyi(pii(next_x,next_y),t-1));\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    s.clear();\n    N.clear();\n    int t, n;\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      N.push_back(pii(x,y));\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    bfs(start_x,start_y,t);\n    cout << s.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\n#define SIZE 130\nbool table[SIZE][SIZE];\nint standed[SIZE][SIZE];\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + SIZE/2;\n}\n\n// 正直幅優先のほうが良い\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(table, false, sizeof(table));\n\t\tmemset(standed, -1, sizeof(standed));\n\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<t;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int x,y,cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\ntypedef long long ll;\n\nint n,m;\nint sx,sy;\nbool t[1000][1000];\nbool closed[1000][1000];\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  int ans = 0;\n\n  while(!open.empty()){\n    State st = open.front(); open.pop();\n    if(closed[st.x][st.y] || st.cost>n || t[st.y][st.x]) continue;\n    closed[st.x][st.y] = true;\n\n    ans++;\n\n    rep(i,6){\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx,ny,st.cost+1));\n    }\n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(cin>>n>>m,n||m){\n    memset(t,0,sizeof(t));\n    rep(i,m){\n      int x,y;\n      cin>>x>>y;\n      x += 300;\n      y += 300;\n      t[y][x] = true;\n    }\n\n    cin>>sx>>sy;\n    sx += 300;\n    sy += 300;\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n,s=1000;\n\tvvi field(s*2+3,vi(s*2+3,0));\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=s+1,y+=s+1;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=2;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0,1,-1}, dy[] = {0,1,0,-1,1,-1};\n\nstruct P {\n    int x, y, depth;\n};\n\nint main() {\n    int turn, block_n;\n    while (cin >> turn >> block_n, turn|block_n) {\n        bool field[100][100] = {};\n        REP(i, block_n) {\n            int x, y;\n            cin >> x >> y;\n            x += 50;\n            y += 50;\n            field[y][x] = true;\n        }\n        int start_x, start_y;\n        cin >> start_x >> start_y;\n        start_x += 50;\n        start_y += 50;\n\n        int cnt = 1;\n\n        queue<P> que;\n        que.push({start_x, start_y, 0});\n        field[start_y][start_x] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.depth == turn) continue;\n            REP(i, 6) {\n                int sx = p.x + dx[i];\n                int sy = p.y + dy[i];\n                if (0 <= sx && sx < 100 && 0 <= sy && sy < 100) {\n                    if (!field[sy][sx]) {\n                        field[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy, p.depth+1});\n                    }\n                }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = { 1,1,0,-1,-1,0 };\nconst int dy[] = { 0,1,1,0,-1,-1 };\nconst int geta = 100;\n\nint main()\n{\n\twhile (true) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\t\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint map[geta * 2][geta * 2];\n\t\tfor (int i = 0; i < geta * 2; i++) {\n\t\t\tfor (int j = 0; j < geta * 2; j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tmap[y + geta][x + geta] = 1;\n\t\t}\n\n\t\tint startx, starty;\n\t\tcin >> startx >> starty;\n\n\t\tint ans = 1;\n\t\tint now = 0;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push({ starty + geta,startx + geta });\n\t\tmap[starty + geta][startx + geta] = 1;\n\n\t\twhile (q.empty() == false) {\n\t\t\tunsigned int count = q.size();\n\n\t\t\twhile (count > 0) {\n\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tcount--;\n\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint ny = temp.first + dy[i];\n\t\t\t\t\tint nx = temp.second + dx[i];\n\n\t\t\t\t\t/*\n\t\t\t\t\tif (ny >= 0 && ny < 61 && nx >= 0 && nx < 61 && map[ny][nx] == 0) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tmap[ny][nx] = 1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\n\t\t\t\t\tif (ny >= 0 && ny < geta * 2 && nx >= 0 && nx < geta * 2 && map[ny][nx] == 0) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tmap[ny][nx] = 1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow++;\n\t\t\tif (now == t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[1100][1100], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] > t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[1100][1100] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\ntypedef long long ll;\ntypedef pair<pair<int, int>, int> P;\n\n#define INF 1000000000\n\nbool visited[65][65];\n\nbool isin(int x, int y){\n    if((x-30)*(y-30)>=0) return x>=0 && x<=60 && y>=0 && y<=60;\n    else return x>=0 && y>=0 && abs(x-30)+abs(y-30)<=30;\n}\n\nint main(){\n    int n,t;\n    while(cin>>t>>n, t|n){\n        fill(visited[0], visited[65], false);\n        rep(i,n){\n            int x,y;\n            cin>>x>>y;\n            visited[x+30][y+30]=true;\n        }\n        int sx,sy;\n        cin>>sx>>sy;\n\n        queue<P> q; //<<x,y>, turn>\n        q.push(mp(mp(sx+30, sy+30), 0));\n        visited[sx+30][sy+30]=true;\n        int res=1;\n        while (!q.empty()){\n            const int dx[] = {1,1,0,-1,-1,0};\n            const int dy[] = {0,1,1,0,-1,-1};\n\n            P p = q.front(); q.pop();\n            if(p.second==t) continue;\n            int x = p.first.first, y=p.first.second;\n            rep(i,6){\n                int nx = x+dx[i], ny=y+dy[i];\n                if(isin(nx,ny) && visited[nx][ny]==false){\n                    visited[nx][ny]=true;\n                    q.push(mp(mp(nx,ny), p.second+1));\n                    res++;\n                }\n            }\n        }\n        cout<<res<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint main(){\n\tint n, t;\n\n\twhile(cin >> t >> n, !(t == 0 && n == 0)) {\n\t\tset<pii> wall;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\twall.insert(pii(x, y));\n\t\t}\n\n\t\tmap<pii, int> d;\n\t\tqueue<pii> q;\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\td[pii(sx, sy)] = 0;\n\t\tq.emplace(sx, sy);\n\n\t\tconst int dx[] = {0, 1, 1, 0, -1, -1};\n\t\tconst int dy[] = {-1, 0, 1, 1, 0, -1};\n\n\t\twhile(!q.empty()) {\n\t\t\tauto p = q.front(); q.pop();\n\n\t\t\tif(d[p] == t) {\n\t\t\t  continue;\n\t\t\t}\n\n\t\t\tfor(int k = 0; k < 6; ++k) {\n\t\t\t  int nx = p.first + dx[k];\n\t\t\t  int ny = p.second + dy[k];\n\n\t\t\t  pii np(nx, ny);\n\t\t\t  if(wall.count(np) || d.count(np)) {\n\t\t\t\tcontinue;\n\t\t\t  }\n\n\t\t\t  d[np] = d[p] + 1;\n\t\t\t  q.push(np);\n\t\t\t}\n\t\t}\n\n\t\tcout << d.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\nconst int OBSTACLE = -INF;\nconst int DIFF = 50;\nint field[100][100];\n\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1};\n\nbool in_field(int x, int y){\n    return 0<=x && x<100 & 0<=y && y<100;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T, N;\n    while(cin>>T>>N, T|N){\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                field[i][j] = INF;\n        int x, y;\n        while(N--){\n            cin >> x >> y;\n            field[x+DIFF][y+DIFF] = OBSTACLE;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        \n        queue<pair<int, int>> que;\n        field[sx+DIFF][sy+DIFF] = 0;\n        que.push(make_pair(sx+DIFF, sy+DIFF));\n        \n        while(!que.empty()){\n            auto p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            \n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(in_field(nx, ny)){\n                    if(field[x][y] + 1 < field[nx][ny]){\n                        field[nx][ny] = field[x][y] + 1;\n                        que.push(make_pair(nx, ny));\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<100; i++)\n            for(int j=0; j<100; j++)\n                ans += (0<=field[i][j] && field[i][j]<=T);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t,n;\nset<pair<int,int> > point;\ntypedef pair<int,int> P;\nconst int C = 40;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[103][103];\n    rep(i,103) rep(j,103) dist[i][j]=INF;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        \n        point.insert(make_pair(y,x));\n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(y,x));\n    dist[y][x]=0;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(0<=nx && 0<=ny && dist[ny][nx] == INF && point.find(P(ny,nx)) == point.end()) {\n                dist[ny][nx] = dist[y][x]+1;\n                que.push(P(ny,nx));\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,102) rep(j,102) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n    point.clear();\n    \n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n\nstruct xyt{\n\tint x, y, ti;\n};\n\nbool map[63][63], check[63][63];\nqueue <xyt> q;\nint ans;\n\nvoid search(int x,int y, int n, int t){\n\tint d[6][2] = {{1,1},{1,0},{0,1},{-1,0},{0,-1},{-1,-1}};\n\txyt s;\n\t//cout << x-31 << \" \" << y-31;\n\tans++;\n\tif(n<t){\n\t\tfor(int k=0;k<6;k++){\n\t\t\tif(map[x+d[k][0]][y+d[k][1]]==0 && check[x+d[k][0]][y+d[k][1]]==0){\n\t\t\t\tcheck[x+d[k][0]][y+d[k][1]]=1;\n\t\t\t\ts.x = x+d[k][0];\n\t\t\t\ts.y = y+d[k][1];\n\t\t\t\ts.ti = n+1;\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n\tq.pop();\n\tif(!q.empty())search(q.front().x, q.front().y, q.front().ti, t);\n}\n\nint main(){\n\tint i, j, t, n, x, y;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(!t) break;\n\t\tfor(i=-31;i<=31;i++){\n\t\t\tfor(j=-31;j<=31;j++){\n\t\t\t\tcheck[i+31][j+31] = 0;\n\t\t\t\tif(j>=0&&i==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i>=0&&j==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(j<=0&&i==-31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i<=0&&j==-31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i+j==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i+j==-31) map[i+31][j+31] = 1;\n\t\t\t\telse map[i+31][j+31] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x+31][y+31] = 1;\n\t\t}\n\t\tans = 0;\n\t\tcin >> x >> y;\n\t\tcheck[x+31][y+31] = 1;\n\t\txyt a;\n\t\ta.x = x + 31;\n\t\ta.y = y +31;\n\t\ta.ti = 0;\n\t\tq.push(a);\n\t\tsearch(q.front().x, q.front().y, q.front().ti, t);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n\n#define mp(a,b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef pair<int, int> xy;\n\nint main() {\n\n\tconst int SIZE = 60;\n\tconst int OFFSET = 30;\n\tconst int\tmx[] = {0, 1, 1, 0, -1, -1},\n\t\t\t\tmy[] = {1, 1, 0, -1, -1, 0};\n\n\tint t, n;\n\n\twhile(cin >> t >> n,t||n) {\n\t\tvector< vector<bool> > f(SIZE, vector<bool>(SIZE, true));\n\t\tqueue< pair< pair<int, int>, int> > open;\n\n\t\twhile (n--) {\n\t\t\tint x, y;\n\t\t\tcin >>x >>y;\n\n\t\t\tf[y+OFFSET][x+OFFSET] = false;\n\t\t}\n\n\t\tint x, y, cnt = 0;\n\t\tcin >>x >>y;\n\t\tx += OFFSET; y += OFFSET;\n\t\tf[y][x] = false;\n\t\topen.push(mp(mp(x, y), 0) );\n\n\t\twhile(!open.empty()) {\n\t\t\tpair<xy, int> tmp = open.front(); open.pop();\n\t\t\txy tmp2 = tmp.first;\n\t\t\tint x = tmp2.first,\n\t\t\t\ty = tmp2.second,\n\t\t\t\tc = tmp.second;\n\n\t\t\tcnt++;\n\t\t\tif (c >= t) continue;\n\n\t\t\tfor( int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + mx[i],\n\t\t\t\t\tny = y + my[i];\n\n\t\t\t\tif ( !(0 <= nx && 0 <= ny && nx < SIZE && ny < SIZE) ) continue;\n\t\t\t\tif ( f[ny][nx] != true ) continue;\n\n\t\t\t\tf[ny][nx] = false;\n\t\t\t\topen.push( mp(mp(nx,ny), c+1));\n\t\t\t}\n\t\t}\n\t\tcout <<cnt <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,j) for (int (i)=0;(i)<(int)(j);++(i))\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nint board[101][101];\nint dr[] = { 1, 1, 0, -1, -1, 0 };\nint dc[] = { 0, 1, 1, 0, -1, -1 };\n\n\nint main() {\n    int t, n;\n    while (cin >> t >> n, t) {\n        fill(board[0], board[101], 1e8);\n        bitset<101*101> used;\n        int x[301], y[301];\n        rep(i, n) {\n            cin >> x[i] >> y[i];\n            x[i] += 31, y[i] += 31;\n            board[y[i]][x[i]] = -1;\n        }\n        int r, c;\n        cin >> c >> r;\n        c += 31, r += 31;\n        used[r * 101 + c] = 1;\n        queue<P> que;\n        que.push(make_pair(r, c));\n        board[r][c] = 0;\n        while (que.size()) {\n            P p = que.front(); que.pop();\n            rep(d, 6) {\n                int nr = p.first + dr[d], nc = p.second + dc[d];\n                if (nr < 0 or nc < 0 or nr > 101 or nc > 101 or board[nr][nc] == -1 or used[nr*101+nc]) continue;\n                used[nr*101+nc] = 1;\n                que.push(make_pair(nr, nc));\n                board[nr][nc] = board[p.first][p.second] + 1;\n            }\n        }\n        int ans = 0;\n        rep(r, 100) rep(c, 100) {\n            if (board[r][c] >= 0 and board[r][c] <= t) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {1, 0, -1, -1, 0, 1};\n\nint main(){\n    int t, n;\n    int visit[200][200];\n    while(cin >> t >> n, t){\n        int x, y;\n        memset(visit, -1, sizeof(visit));\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            visit[x+100][y+100] = 1;\n        }\n        cin >> x >> y;\n        int res = 0;\n        queue< pair<int, int> > qu; qu.push(make_pair(x+100,y+100));\n        visit[x+100][y+100] = 0;\n        while(!qu.empty()){\n            pair<int,int> pr = qu.front(); qu.pop();\n            int cx = pr.first, cy = pr.second;\n            res++;\n            if(visit[cx][cy] == t) continue;\n            for(int i=0;i<6;i++){\n                int nx = cx+dx[i], ny = cy+dy[i];\n                if(visit[nx][ny]!=-1) continue;\n                visit[nx][ny] = visit[cx][cy]+1;\n                qu.push(make_pair(nx,ny));\n            }\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint data[100][100]={0};\n\nbool inrange(int x,int y){\n  if(x<-30||x>30||y<-30||y>30) return false;\n  else return true;\n}\n\nint dp[100][100][30];\n\nll int solve(int px,int py,int turn){\n  int res = 0;\n  if(turn==0) return res;\n  REP(i,6){\n    int nx = px + dx[i];\n    int ny = py + dy[i];\n    if(!inrange(nx,ny)) continue;\n    if(data[nx+30][ny+30]==0) res++;\n    if(data[nx+30][ny+30]!=-1){\n      data[nx+30][ny+30]=1;\n      if(dp[nx+30][ny+30][turn-1]!=-1) {\n        res+=dp[nx+30][ny+30][turn-1];\n      }else{\n        int tmp = solve(nx,ny,turn-1);\n        dp[nx+30][ny+30][turn-1] = tmp;\n        res += dp[nx+30][ny+30][turn-1];\n      }\n        /*int tmp = solve(nx,ny,turn-1);\n        res+= tmp;\n        if(tmp) cout << tmp << endl;*/ \n    }\n  }\n  return res;\n}\n\nint main(){\n  int t,n;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    REP(i,100){\n      REP(j,100) data[i][j] = 0;\n    }\n    REP(i,100) {\n      REP(j,100) {\n        REP(k,30) {\n          dp[i][j][k] = -1;\n        }\n      }\n    }\n    REP(i,n){\n      int tx,ty;\n      cin >> tx >> ty;\n      data[tx+30][ty+30] = -1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    data[sx+30][sy+30] = 1;\n    cout << solve(sx,sy,t)+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n#define  OFF 45\nbool dump[90][90];\nbool visited[90][90];\nbool visited2[90][90];\n\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\n\nint main(void){\n\tint t,n;\n\twhile(cin >> t >> n,t|n){\n\t\tfor(int y=0;y<90;y++)\n\t\t\tfor(int x=0;x<90;x++)\n\t\t\t\tdump[x][y]=visited[x][y]=false;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tdump[OFF+x][OFF+y]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\n\t\tvisited[OFF+sx][OFF+sy]=true;\n\t\tcout << visited[OFF][OFF] << endl;\n\n\t\tfor(int i=0;i<t;i++){\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tvisited2[OFF+x][OFF+y]=visited[OFF+x][OFF+y];\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tfor(int j=0;j<6;j++)\n\t\t\t\t\t\tif(visited[OFF+x][OFF+y]&&!dump[OFF+x+dx[j]][OFF+y+dy[j]])\n\t\t\t\t\t\t\tvisited2[OFF+x+dx[j]][OFF+y+dy[j]]=true;\n\t\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tvisited[OFF+x][OFF+y]=visited2[OFF+x][OFF+y];\n\t\t}\n\t\tint num=0;\n\t\tfor(int y=-40;y<40;y++)\n\t\t\t\tfor(int x=-40;x<40;x++)\n\t\t\t\t\tif(visited2[OFF+x][OFF+y])\n\t\t\t\t\t\tnum++;\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint t, n, sx, sy;\nint field[100][100];\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid solve(){\n\tfield[sy][sx] = 0;\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\tREP(i, 6){\n\t\t\tint ny = p.first + dy[i], nx = p.second + dx[i];\n\t\t\tif (ny >= 20 && ny <= 80 && nx >= 20 && nx <= 80){\n\t\t\t\tif (field[ny][nx] == INF&&field[p.first][p.second] < t){\n\t\t\t\t\tfield[ny][nx] = field[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\twhile (cin >> t >> n&&t + n){\n\t\tint ans = 0;\n\t\tREP(i, 100)REP(j, 100)field[i][j] = INF;\n\t\tREP(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 50;\n\t\t\ty += 50;\n\t\t\tfield[y][x] = -1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\t\tsolve();\n\t\tREP(i, 100){\n\t\t\tREP(j, 100){\n\t\t\t\tif (field[i][j] >= 0 && field[i][j] <= t){\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i;\n  int t,n;\n  while(cin>>t>>n,t||n){\n    int a[128][128]={};\n    for(i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      x+=64;\n      y+=64;\n      a[y][x]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=64;\n    sy+=64;\n    int b[128][128];\n    memset(b,-1,sizeof(b));\n    queue<pair<pair<int,int>,int> > c;\n    c.push(make_pair(make_pair(sx,sy),0));\n    int ct=0;\n    while(c.empty()==0){\n      int x,y,z;\n      x=c.front().first.first;\n      y=c.front().first.second;\n      z=c.front().second;\n      c.pop();\n      if(z>t)\n\tbreak;\n      if(b[y][x]){\n\tb[y][x]=0;\n\tct++;\n\tif(a[y+1][x+1]==0&&b[y+1][x+1])\n\t  c.push(make_pair(make_pair(x+1,y+1),z+1));\n\tif(a[y][x+1]==0&&b[y][x+1])\n\t  c.push(make_pair(make_pair(x+1,y),z+1));\n\tif(a[y-1][x]==0&&b[y-1][x])\n\t  c.push(make_pair(make_pair(x,y-1),z+1));\n\tif(a[y-1][x-1]==0&&b[y-1][x-1])\n\t  c.push(make_pair(make_pair(x-1,y-1),z+1));\n\tif(a[y][x-1]==0&&b[y][x-1])\n\t  c.push(make_pair(make_pair(x-1,y),z+1));\n\tif(a[y+1][x]==0&&b[y+1][x])\n\t  c.push(make_pair(make_pair(x,y+1),z+1));\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint mp[100][100];\nstruct ima{\n  int x,y;\n};\nint n,tu;\nqueue <ima> Q;\nint dis[100][100];\n\nvoid reset() {\n\n  for(int i=0;i<=60;i++)\n    for(int j=0;j<=60;j++) {\n      mp[i][j] = 0;\n      dis[i][j] = 10000;\n    }\n}\n\n\nint visit() {\n  ima t;\n  int dx[6] = {1,1,0,-1,-1,0};\n  int dy[6] = {1,0,-1,-1,0,1};\n  int count =1;\n\n  while(!Q.empty()){\n\n    t = Q.front();\n    Q.pop();\n    if(dis[t.y][t.x]+1 >tu) continue;\n    for(int i=0;i<6;i++) {\n      if(t.y+dy[i] >=0 && t.x+dx[i] >=0) \n      if(mp[t.y+dy[i]][t.x+dx[i]] == 0 && dis[t.y+dy[i]][t.x+dx[i]] > dis[t.y][t.x]+1){\n\tQ.push((ima){t.x+dx[i],t.y+dy[i]});\n\tdis[t.y+dy[i]][t.x+dx[i]] = dis[t.y][t.x]+1;\n\tcount++;\n      }\n    }\n  }\n    return count;\n}\n\n\nint main() {\n\n  while(1) {\n  cin >> tu >> n;\n  if(tu == 0 && n == 0) break;\n  \n  int a,b;\n  reset();\n  for(int i=0;i<n;i++) {\n    cin >> a >>b;\n\n    mp[31+b][31+a] =1;\n\n  }\n  \n  int tx,ty;\n  cin >> tx >>ty;\n\n  Q.push((ima){31+tx,31+ty});\n  dis[31+ty][31+tx] = 0;\n  \n  int ans = visit();\n\n  cout << ans <<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 70>, 70> hex, array<array<int32_t, 70>, 70> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 1;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t posx = x + iter->first;\n      int32_t posy = y + iter->second;\n      if (0 <= posx && posx < 70 && 0 <= posy && posy < 70 && !hex[posx][posy] && dists[posx][posy] == 0) {\n        dists[posx][posy] = dists[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 70>, 70> hex;\n    array<array<int32_t, 70>, 70> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = 0;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 35][y + 35] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 35, y + 35);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (1 <= *i && *i <= t + 1) {\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std ;\n\nint dx[] = { 0,1,1,0,-1,-1 } ;\nint dy[] = { 1,1,0,-1,-1,0 } ;\n\nint main(){\n\t\n\tint t , n , count ;\n\tint nx , ny , nc ;\n\tint sx , sy ;\n\t\n\twhile(1){\n\t\tint map[63][63] = {} ;\n\t\tqueue<int> x ;\n\t\tqueue<int> y ;\n\t\tqueue<int> c ;\n\t\t\n\t\tcin >> t >> n ;\n\t\tif( t==0 && n==0 ) break ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> nx >> ny ;\n\t\t\tmap[ny+30][nx+30] = -1 ;\n\t\t}\n\t\tcin >> sx >> sy ;\n\t\t\n\t\tcount = 1 ;\n\t\tc.push(1) ;\n\t\tx.push( sx+30 ) ;\n\t\ty.push( sy+30 ) ;\n\t\tmap[sy+30][sx+30] = 1 ;\n\t\t\n\t\twhile(1){\n\t\t\tif( c.empty() ) break ;\n\t\t\tif( c.front() == t+1 ) break ;\n\t\t\t\n\t\t\tnx = x.front() ;\n\t\t\tny = y.front() ;\n\t\t\tnc = c.front() ;\n\t\t\t\n\t\t\tfor( int i=0 ; i<6 ; i++ ){\n\t\t\t\tif( map[ ny+dy[i] ][ nx+dx[i] ] == 0 ){\n\t\t\t\t\tmap[ ny+dy[i] ][ nx+dx[i] ] = nc ;\n\t\t\t\t\tcount++ ;\n\t\t\t\t\tx.push( nx+dx[i] ) ;\n\t\t\t\t\ty.push( ny+dy[i] ) ;\n\t\t\t\t\tc.push( nc+1 ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tx.pop() ;\n\t\t\ty.pop() ;\n\t\t\tc.pop() ;\n\t\t}\n\t\t\n\t\tcout << count << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[]={0,1,1,-1,-1,0};\nconst int dy[]={1,1,0,0,-1,-1};\nstruct data{\n    int y,x;\n    data(int a,int b):y(a),x(b){}\n    data(){}\n    bool operator<(const data &d)const{\n        return y!=d.y?y<d.y:x<d.x;\n    }\n};\ntypedef pair<int,data>P;\n\nint main(){\n    int t,n;\n    while(cin>>t>>n,t||n){\n        set<data>S,M;\n        for(int i=0;i<n;i++){\n            int y,x;\n            cin>>x>>y;\n            S.insert(data(y,x));\n        }\n        int sy,sx;\n        cin>>sx>>sy;\n        queue<P>Q;\n        Q.push(P(0,data(sy,sx)));\n        while(Q.size()){\n            data d=(Q.front()).second;\n            int cnt=Q.front().first;\n            Q.pop();\n            if(cnt>t)continue;\n            if(S.find(d)!=S.end())continue;\n            if(M.find(d)!=M.end())continue;\n            M.insert(d);\n            for(int i=0;i<6;i++){\n                Q.push(P(cnt+1,data(d.y+dy[i],d.x+dx[i])));\n            }\n        }\n        cout<<M.size()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[150][150];\nbool used[150][150];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)ta[i][j]=0,used[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=50,ty+=50;\n\tta[ty][tx]=1;\n\t}\n\tused[50][50]=1;\n\tmasu start;\n\tstart.x=50,start.y=50,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\t//cout<<nx<<\" \"<<ny<<endl;\n\tused[ny][nx]=1;\n\tif(ntn>=t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]!=1&&used[nexty][nextx]!=1){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)if(used[i][j])ans++;\n\tint ttt;\n\tcin>>ttt>>ttt;\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\nconst int WMAX = 80, HMAX = 80;\n#define MAP(y, x) field[y + 40][x + 40]\nlli t, n;\nint field[HMAX][WMAX];\n\nvoid dfs(int y, int x, int turn) {\n  int nor = y * y + x * x;\n  if (nor > 900 || turn <= 0 || MAP(y, x) >= turn) return;\n  MAP(y, x) = turn;\n  REP(i, 6) {\n    dfs(y + dy[i], x + dx[i], turn - 1);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n\n  while (cin >> t >> n and t) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = 0;\n    }\n    REP(i, n) {\n      int y, x;\n      cin >> x >> y;\n      MAP(y, x) = INF;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    dfs(sy, sx, t + 1);\n    int sum = 0;\n    FOR(y, -32, 32) FOR(x, -32, 32) {\n      if (MAP(y, x) > 0 and MAP(y, x) != INF) sum ++;\n    }\n    cout << sum << endl;\n    FOR(y, -10, 10) {\n      REP(i, 10 - y) cout << ' ';\n      FOR(x, -10, 10) {\n        if (MAP(y, x) == INF) cout << 'x';\n        else if (MAP(y, x) == 0)   cout << '.';\n        else if (y == sy and x == sx) cout << 'S';\n        else cout << 'o';\n        cout << ' ';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 200\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs(int,int);\nint dy[6]={-1,-1,0,1,1,0};\nint dx[6]={-1,0,1,1,0,-1};\nint t;\nint data[N][N];\nint main(){\n  int n,x,y,sx,sy;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0;\n    while(n--){\n      cin >> x >> y;\n      data[y+100][x+100]=-1;\n    }\n    cin >> sx >> sy;\n    data[sy+100][sx+100]=1;\n    bfs(sy+100,sx+100);\n    int cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n    if(data[i][j]==1) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid bfs(int y,int x){\n  queue<P1> Q;\n  Q.push(P1(0,P(y,x)));\n  while(Q.empty()!=1){\n    P1 v=Q.front();\n    Q.pop();\n    int d=v.first,y1=v.second.first,x1=v.second.second;\n    for(int i=0;i<6;i++){\n      if(0<=y1+dy[i]&&y1+dy[i]<N&&0<=x1+dx[i]&&x1+dx[i]<N&&data[y1+dy[i]][x1+dx[i]]==0){\n    data[y1+dy[i]][x1+dx[i]]=1;\n    if(d<=t-2) Q.push(P1(d+1,P(y1+dy[i],x1+dx[i])));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <utility>\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); (i)++)\n#define REG(i, a, b) for (int (i) = ((int)(a)); (i) < ((int)(b)); i++)\n#define ALL(V) (V).begin(), (V).end()\n#define PRINT(STR) cout << (STR) << endl\n#define ROUNDED(N) fixed << setprecision(N)\n#define SPACE \" \"\n\ntypedef long long ll;\nusing namespace std;\n\nint nextInt() { int n; cin >> n; return n; }\ndouble nextDouble() { double d; cin >> d; return d; }\nstring nextString() { string str; cin >> str; return str; }\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {1,0,-1,-1,0,1};\nstruct points{int x,y,turn;};\nconst int def = 30;\nint main() {\n\tcin.tie(0); //?????±?????????????????????\n\tios::sync_with_stdio(false); //printf??¨??±??????????????????\n\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\tvector<vector<int>> mp(61,vector<int>(61,0));\n\t\tREP(i,n){\n\t\t\tint a = nextInt()+def;\n\t\t\tint b = nextInt()+def;\n\t\t\tmp[a][b] = 1;\n\t\t}\n\t\tqueue<points> que;\n\t\tpoints start;\n\t\tstart.x=nextInt()+def;start.y=nextInt()+def;start.turn=t;\n\t\tque.push(start);\n\t\tint ct = 0;\n\t\twhile(que.size()){\n\t\t\tint x = que.front().x;\n\t\t\tint y = que.front().y;\n\t\t\tint nowturn = que.front().turn;\n\t\t\tque.pop();\n\t\t\tif(mp[x][y]==0){\n\t\t\t\tct++;\n\t\t\t\tmp[x][y] = 1;\n\t\t\t}else continue;\n\t\t\tif(nowturn==0)continue;\n\t\t\tREP(i,6){\n\t\t\t\tpoints ne;\n\t\t\t\tne.x = x + dx[i];\n\t\t\t\tne.y = y + dy[i];\n\t\t\t\tif(ne.x<0||ne.x>def*2||ne.y<0||ne.y>def*2)continue;\n\t\t\t\tif(mp[ne.x][ne.y]==0){\n\t\t\t\t\tne.turn = nowturn - 1;\n\t\t\t\t\tque.push(ne);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ct << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\nstruct Node\n{\n\tint x, y, turn;\n};\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<int, 121>, 121> field;\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tfield = { {0} };\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 60][x + 60] = 1;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 60][startX + 60] = 1;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX+60, startY+60, 0 });\n\t\t\tint dx[] = {1, 0, -1, -1, 0, 1};\n\t\t\tint dy[] = {0, -1, -1, 0, 1, 1};\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 120 || next.y < 0 || next.y > 120) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = 1;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (next.turn >= t) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef pair<pair<int,int>,int> triple;\n#define trpl(i,j,k) make_pair(make_pair((i),(j)),(k))\n#define X first.first\n#define Y first.second\n#define T second\nconst int OFFSET=60;\nconst int MAX_X=OFFSET*2+1;\n\nbool obstacle[MAX_X][MAX_X];\nbool checked[MAX_X][MAX_X];\nint t,n,x,y;\n\nint bfs(){\n  int result=0;\n  queue<triple> q;\n  q.push(trpl(x,y,t));\n  while(!q.empty()){\n    triple tr=q.front();\n    q.pop();\n    if(obstacle[tr.X][tr.Y]||checked[tr.X][tr.Y])continue;\n    checked[tr.X][tr.Y]=true;\n    result++;\n    if(tr.T>0){\n      int d=tr.T-1;\n      q.push(trpl(tr.X+1,tr.Y,d));\n      q.push(trpl(tr.X+1,tr.Y+1,d));\n      q.push(trpl(tr.X,tr.Y+1,d));\n      q.push(trpl(tr.X-1,tr.Y,d));\n      q.push(trpl(tr.X-1,tr.Y-1,d));\n      q.push(trpl(tr.X,tr.Y-1,d));\n    }\n  }\n  return result;\n}\n\nint main(){ _;\n  int tx,ty;\n  while(cin>>t>>n,(t|n)!=0){\n    REP(i,MAX_X)REP(j,MAX_X)obstacle[i][j]=checked[i][j]=false;\n    REP(i,n){\n      cin>>tx>>ty;\n      tx+=OFFSET;\n      ty+=OFFSET;\n      obstacle[tx][ty]=true;\n    }\n    cin>>x>>y;\n    x+=OFFSET;\n    y+=OFFSET;\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nint map[100][100];\nint mapcnt[100][100];\nint t, n;\nint dx[6] = {0, 1, 1, 0, -1, -1};\nint dy[6] = {1, 1, 0, -1, -1, 0};\n\nvoid search(int x, int y, int t){\n/*\n\tif(!t) return;\n\tif(map[x][y] == -1) return;\n\tif(map[x][y] == 1 && mapcnt[x][y] > t) return;\n\tmap[x][y] = 1;\n\tmapcnt[x][y] = t;\n*/\t\n\tqueue<pair<pair<int, int>, int> > q;\n\tq.push(make_pair(make_pair(x,y),t));\n\twhile(!q.empty()){\n\t\tpair<pair<int, int>, int> p = q.front();\n\t\tq.pop();\n\t\tpair<int , int> id = p.first;\n//printf(\"%d %d %d\\n\", id.first, id.second, p.second);\n\t\tif(map[id.first][id.second] != 0) continue;\n\n\t\tif(!p.second) continue;\n\t\tmap[id.first][id.second] = 1;\n\t\tfor(int i = 0; i < 6; i++){\n//printf(\"push : %d %d %d\\n\", id.first+dx[i], id.second+dy[i], p.second);\n\t\t\tq.push(make_pair(make_pair(id.first+dx[i],id.second+dy[i]),p.second-1));\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x, y;\n\twhile(cin >> t >> n, t || n){\n\t\tfor(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++) mapcnt[i][j] = 0, map[i][j] = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x + 50][y + 50] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tsearch(x+50, y+50, t+1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tfor(int j = 0; j < 100; j++){\n\t\t\t\tif(map[i][j] == 1) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[70][70], d[70][70];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60 ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+30][b+30]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=30;\n\t\tstart.y+=30;\n\t\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\twhile(!que.empty()){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\t//if(d[v.x][v.y]>=turn+1) continue;\n\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx;\n\t\t\t\t\ttmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 121\n#define CONT 30\n\nint T,N;\n\nvoid dfs(int x, int y, int turn, vector< vector<int> > &field)\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\tif(x < 0 || x >= MAX || y < 0 || y >= MAX){ return; } //範囲外\n\n\tif(turn > T){ return; } //ターン数オーバー\n\n\tif(field[x][y] <= turn && field[x][y]){ return; } //到達修正\n\tif(field[x][y] == -1){ return; } //障害物\n\n\tfield[x][y] = turn;\n\t\n\trep(i,6){\n\t\tdfs(x+dx[i], y+dy[i], turn+1, field);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> T >> N )\n\t{\n\t\tif(T == 0 && N == 0){ break; }\n\n\t\tvector< vector<int> > field(MAX,vector<int>(MAX,0));\n\t\n\t\tint X,Y;\n\t\trep(nth,N)\n\t\t{\n\t\t\tcin >> X >> Y;\n\t\t\tfield[X+CONT][Y+CONT] = -1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\n\t\tint ans = 0;\n\t\tdfs(sx+CONT,sy+CONT,0,field);\n\t\tfield[sx+CONT][sy+CONT] = 1;\n\t\t\n\t\trep(y,MAX){\n\t\t\trep(x,MAX){\n\t\t\t\tif(field[x][y] > 0){ ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint b[70][70], d[70][70], t, n, sx, sy, dx[] = {-1, -1, 0, 0, 1, 1}, dy[] = {0, -1, 1, -1, 0, 1};\n\nsigned main(void) {\n  while (true) {\n    cin >> t >> n;\n    if(!t && !n) break;\n    REP(i, 70) REP(j, 70) {\n      b[i][j] = 0;\n      d[i][j] = INF;\n    }\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      b[y + 30][x + 30] = -1;\n    }\n    cin >> sx >> sy;\n\n    queue<VI> que;\n    que.push({sx, sy, 0});\n    d[sy + 30][sx + 30] = 0;\n\n    while (que.size()) {\n      VI p = que.front();\n      que.pop();\n      if (p[2] == t)\n        break;\n      REP(i, 6) {\n        int nx = p[0] + dx[i], ny = p[1] + dy[i];\n        if (abs(nx) <= 30 && abs(ny) <= 30 && !b[ny + 30][nx + 30] &&\n            d[ny + 30][nx + 30] == INF) {\n          que.push({nx, ny, p[2] + 1});\n          d[ny + 30][nx + 30] = d[p[1] + 30][p[0] + 30] + 1;\n        }\n      }\n    }\n\n    int ret = 0;\n    REP(i, 62) REP(j, 62) {\n      if (d[i][j] <= t)\n        ret++;\n    }\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {1, 1, 0, -1, -1, 0};\n    int dx[] = {1, 0, -1, -1, 0, 1};\n\n    for(;;){\n        int t, n;\n        cin >> t >> n;\n        if(t == 0)\n            return 0;\n\n        vector<int> y(n), x(n);\n        for(int i=0; i<n; ++i)\n            cin >> x[i] >> y[i];\n\n        int y0, x0;\n        cin >> x0 >> y0;\n        vector<vector<bool> > check(2*t+1, vector<bool>(2*t+1, false));\n        for(int i=0; i<n; ++i){\n            int y1 = y[i] - y0 + t;\n            int x1 = x[i] - x0 + t;\n            if(0 <= y1 && y1 < 2*t+1 && 0 <= x1 && x1 < 2*t+1)\n                check[y1][x1] = true;\n        }\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(t, t));\n        check[t][t] = true;\n        int ret = 1;\n        while(--t >= 0){\n            queue<pair<int, int> > q2;\n            while(!q.empty()){\n                int y, x;\n                y = q.front().first;\n                x = q.front().second;\n                q.pop();\n                for(int i=0; i<6; ++i){\n                    int y1 = y + dy[i];\n                    int x1 = x + dx[i];\n                    if(!check[y1][x1]){\n                        check[y1][x1] = true;\n                        q2.push(make_pair(y1, x1));\n                        ++ ret;\n                    }\n                }\n            }\n            q = q2;\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint depth;\nbool field[62][62];\nll d[62][62];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    queue<P> que;\n    REP(i,62){\n        REP(j,62) d[i][j] = INF;\n    }\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx < 0 || 60 < nx || ny < 0 || 60 < ny || d[nx][ny] != INF || field[nx][ny] || d[p.first][p.second]+1 > depth) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        memset(field, false, sizeof(field));\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            field[x+30][y+30] = true;\n        }\n        cin >> x >> y;\n        int res = bfs(x+30,y+30);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint main(void)\n{\n\tint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\n\tint used[200][200];\n\tint t,n;\n\tint X,Y;\n\tqueue<int> xs,ys;\n\twhile (cin>>t>>n,t) {\n\t\tmemset(used,0,sizeof(used));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>X>>Y;\n\t\t\tused[Y+100][X+100]=1;\t\n\t\t}\n\t\tcin>>X>>Y;\n\t\txs.push(X+100); ys.push(Y+100);\n\t\tused[Y+100][X+100]=1;\n\t\tint ans=1;\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front();\n\t\t\txs.pop(); ys.pop();\n\t\t\tif(used[y][x]<=t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\tused[ny][nx]=used[y][x]+1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,t;};\nint main(){\n  int t,n,i,j,k,x,y;\n  cin >> t >> n;\n  while(t!=0||n!=0){\n    \n    int m[80][80]={{}};\n    int dis[80][80]={{}};\n    queue <Point> ps;\n    Point p,b;\n    for(i=0;i<n;i++){\n      cin >> x >> y;\n      dis[40+x][40+y]=1;\n    }\n    cin >> p.x  >> p.y;\n    p.x+=40;p.y+=40;\n    m[p.x][p.y]=1;\n    p.t=0;\n    ps.push(p);\n    int o=0;\n    while(!ps.empty()){\n      o++;\n      p=ps.front();\n      ps.pop();\n      if(p.t<t){\n\tif(m[p.x+1][p.y]+dis[p.x+1][p.y]==0){\n\t  b.x=p.x+1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y+1]+dis[p.x][p.y+1]==0){\n\t  b.x=p.x;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x+1][p.y+1]+dis[p.x+1][p.y+1]==0){\n\t  b.x=p.x+1;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y]+dis[p.x-1][p.y]==0){\n\t  b.x=p.x-1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y-1]+dis[p.x][p.y-1]==0){\n\t  b.x=p.x;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y-1]+dis[p.x-1][p.y-1]==0){\n\t  b.x=p.x-1;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n      }\n    }\n    cout << o << endl;\n    cin >> t >> n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nvoid f(int n,int m){\n  int sx,sy;\n  int dd=150;\n\n  int d[300][300];\n  rep(i,300){\n    rep(j,300){\n      d[i][j]=INF;\n    }\n  }\n\n  d[dd][dd]=0;\n  vector<P> v;\n\n  while(m--){\n    int x,y;\n    cin>>x>>y;\n    v.PB(P(x,y));\n  }\n  \n  cin>>sx>>sy;\n\n  rep(i,v.size()){\n    d[v[i].S+dd-sy][v[i].F+dd-sx]=-INF;\n  }\n  \n\n  queue<P> q;\n  q.push(P(dd,dd));\n  int ans=0;\n  while(!q.empty()){\n    P p=q.front(); q.pop();\n    if(d[p.F][p.S]<=n)\n      ans++;\n    else\n      continue;\n    //cout<<p.F<<' '<<p.S<<endl;\n    if(abs(p.F-dd)>31||abs(p.S-dd)>31) continue;\n    FOR(i,-1,2){\n      FOR(j,-1,2){\n        if(i==0&&j==0||i*j<0) continue;\n        int x=p.S+i,y=p.F+j;\n        if(d[y][x]>d[p.F][p.S]+1){\n          d[y][x]=d[p.F][p.S]+1;\n          q.push(P(y,x));\n        }\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n}\n\n\n\n\nmain(){\n  int n,m;\n  while(true){\n    cin>>n>>m;\n    if(n==0) break;\n    f(n,m);\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nconst int N = 100;\n\nstruct point{ int x, y; };\nstatic const int dy[6] = {0,1,1,0,-1,-1};\nstatic const int dx[6] = {1,1,0,-1,-1,0};\n\nint bfs(bool *M, int x, int y, int t){\n    int temp[N * N];\n    int *dis = temp + 5050;\n\n    queue<point> q;\n    rep(i, N * N) temp[i] = INF;\n    point start_coordinate = {x, y};\n\n    dis[start_coordinate.y * N + start_coordinate.x] = 0;\n    q.push(start_coordinate);\n\n    int cnt = 1;\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,6){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(dis[next.y * N + next.x] == INF && M[next.y * N + next.x] == 0){\n                dis[next.y * N + next.x] = dis[u.y * N + u.x] + 1;\n                if(t < dis[next.y * N + next.x]) continue;\n                //cout << next.x <<' '<<next.y<< endl;\n                cnt++;\n                q.push(next);\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    int t, n, sx, sy;\n    while(cin >> t >> n, t||n){\n        bool M[N * N] = {0};\n        bool *atl = M + 5050;\n        rep(i,n){\n            int x, y;\n            cin >> x >> y;\n            atl[y * N + x] = 1;\n        }\n        cin >> sx >> sy;\n        cout << bfs(atl, sx, sy, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[100][100];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  //memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 50;\n      Y += 50;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\ntypedef vector<bool> VB;\ntypedef vector< VB > VVB;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nconst int dx[] = {0, 1, 1, 0, -1, -1};\nconst int dy[] = {1, 1, 0, -1, -1, 0};\nconst int D = 6;\nconst int offset = 150;\nconst int N = 300;\n\nint main(void) {\n\tint T, M;\n\twhile(cin >> T >> M, T || M) {\n\t\tVVI area(N, VI(N, -1));\n\t\tVVB wall(N, VB(N, false));\n\t\tPII S;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tPII p;\n\t\t\tcin >> p.X >> p.Y;\n\t\t\twall[p.Y + offset][p.X + offset] = true;\n\t\t}\n\t\tcin >> S.X >> S.Y;\n\t\tS.X += offset;\n\t\tS.Y += offset;\n\n\t\t// bfs\n\t\tqueue<PII> q;\n\t\tq.push(S);\n\t\tarea[S.Y][S.X] = T;\n\t\twhile (q.size()) {\n\t\t\tPII p = q.front();\n\t\t\tq.pop();\n\t\t\tint t = area[p.Y][p.X] - 1;\n\n\t\t\tif (t == -1) { // walk end\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < D; i++) {\n\t\t\t\tPII n(p);\n\t\t\t\tn.X += dx[i];\n\t\t\t\tn.Y += dy[i];\n\t\t\t\t\n\t\t\t\tif (!wall[n.Y][n.X] && t > area[n.Y][n.X]) {\n\t\t\t\t\tq.push(n);\n\t\t\t\t\tarea[n.Y][n.X] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// count walked area\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tint x = area[i][j];\n\t\t\t\tans += x >= 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (ll)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) {\n        ll d = euclid(b, a % b, y, x);\n        return y -= a / b * x, d;\n    }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1)\n            ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1);\n        return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e)\n            return Mod(1);\n        Mod r = *this ^ (e / 2);\n        r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nint isprime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0 && (i % 7 == 1 || i % 7 == 6) && (n / i % 7 == 1 || n / i % 7 == 6)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint toint(string s) {\n    string b;\n    copy_if(all(s), back_inserter(b), [](char c) { return c != ':'; });\n    return stoi(b);\n}\n\nstruct P { ll p, a, b, c, d, e, f, s, m; string nm; };\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    const int dir[6][2] = {{1, 1}, {1, 0}, {0, -1}, {-1, -1}, {-1, 0}, {0, 1}};\n\n    for (;;) {\n        int t, n; cin >> t >> n;\n        if (!t) break;\n\n        map<int, map<int, int>> dist;\n\n        rep(i, 0, n) {\n            int x, y; cin >> x >> y;\n            dist[x][y] = -1;\n        }\n\n        queue<pair<int, int>> q;\n        int sx, sy;\n        cin >> sx >> sy;\n\n        dist[sx][sy] = 1;\n        q.push({sx, sy});\n\n        int ans = 1;\n\n        while (!q.empty()) {\n            int x, y;\n            tie(x, y) = q.front(); q.pop();\n            if (dist[x][y] > t) break;\n            for (int i = 0; i < 6; i++) {\n                int nx = x + dir[i][0], ny = y + dir[i][1];\n                if (dist[nx][ny] == 0) {\n                    ans++;\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint mas[61][61];\nint used[61][61];\nint dp[31][61][61];\n\nint dx[] = { 1, 1, 0, -1, -1, 0 }, dy[] = { 1, 0, -1, -1, 0, 1 };\nint maxi[61][61];\n\nint rec(int t, int x, int y) {\n    if(t == 0) {\n        int ret = !used[y][x];\n        used[y][x]++;\n        return ret;\n    }\n\n    if(maxi[y][x] > t) return 0;\n\n    int ret = !used[y][x];\n    used[y][x]++;\n    for(int i = 0; i < 6; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(!mas[ny][nx]) {\n            ret += rec(t - 1, nx, ny);\n            maxi[y][x] = t;\n        }\n    }\n    return dp[t][x][y] = ret;\n}\n\nint main() {\n    int n, t;\n    while(cin >> t >> n, t) {\n        memset(mas, 0, sizeof(mas));\n        memset(used, 0, sizeof(used));\n        memset(dp, 0, sizeof(dp));\n        memset(maxi, 0, sizeof(maxi));\n        for(int i = 0; i < n; i++) {\n            int x, y; cin >> x >> y;\n            mas[y + 30][x + 30] = 1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        cout << rec(t, sx + 30, sy + 30) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\nconst int dx[] = {0, 1,-1, 1, 0,-1};\nconst int dy[] = {1, 0,-1, 1,-1, 0};\n\nint main ()\n{\n    int t, n;\n    while (cin >> t >> n, (n || t)) {\n        int d[222][222];\n        bool w[222][222];\n        for (int i = 0; i < 222; i++) {\n            for (int j = 0; j < 222; j++) {\n                d[i][j] = INF;\n                w[i][j] = true;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int t1, t2;\n            cin >> t1 >> t2;\n            d[t1 + 60][t2 + 60] = -1;\n        }\n\n        int x, y;\n        cin >> x >> y;\n        d[x + 60][y + 60] = 0;\n        w[x + 60][y + 60] = false;\n        queue<P> q;\n        q.push(P(x + 60, y + 60));\n\n        int count = 1;\n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n\n            for (int i = 0; i < 6; i++) {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (0 <= nx && nx < 222 && 0 <= ny && ny < 222 && d[nx][ny] != -1) {\n                    if (d[nx][ny] > d[p.first][p.second] + 1 && d[p.first][p.second] < t) {\n                        if (w[nx][ny]) count++, w[nx][ny] = false;\n                        q.push(P(nx,ny));\n                        d[nx][ny] = d[p.first][p.second] + 1;\n                    }\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint t,n,x,y,T;\nbool mp[61][61];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nint bfs(){\n  queue<P> Q;\n  int cnt=0;\n  Q.push(P(0,(x+30)*61+y+30));\n  while(!Q.empty()){\n    P p=Q.front();\n    T=p.first;\n    x=p.second/61,y=p.second%61;\n    if(mp[x][y]){Q.pop();continue;}\n    if(T==t+1)return cnt;\n    mp[x][y]=1;\n    Q.pop();\n    cnt++;\n    for(int i=0;i<6;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(0<=nx&&nx<61&&0<=ny&&ny<61&&!mp[nx][ny])\n\tQ.push(P(T+1,nx*61+ny));\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while(cin>>t>>n&&(t||n)){\n    memset(mp,0,sizeof(mp));\n    while(n--){\n      cin>>x>>y;\n      mp[x+30][y+30]=1;\n    }\n    cin>>x>>y;\n    cout<<bfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {1,-1,0, 0,1,-1};\nint dy[] = {0, 0,1,-1,1,-1};\nint pos[70][70];\n\nint bfs(int x, int y, int t){\n  int res = 1;\n  queue<PII> q;\n  q.push(MP(x,y));\n  pos[y][x] = t;\n\n  bool visit[70][70];\n  fill((bool*)visit, (bool*)visit+70*70, false);\n  visit[y][x] = true;\n  \n  while(!q.empty()){\n\tPII pii = q.front(); q.pop();\n\tx = pii.first, y = pii.second;\n\tif(pos[y][x] <= 0) continue;\n\tREP(i,6){\n\t  int tx = pii.first + dx[i], ty = pii.second + dy[i];\n\t  if(visit[ty][tx] || pos[ty][tx] == -1) continue;\n\t  visit[ty][tx] = true;\n\t  ++res;\n\t  pos[ty][tx] = pos[y][x] - 1;\n\t  q.push(MP(tx,ty));\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int T, N;\n  while(cin >> T >> N, T){\n\tfill((int*)pos, (int*)pos+70*70, 0);\n\tREP(i,N){\n\t  int x, y; cin >> x >> y;\n\t  pos[y+35][x+35] = -1;\n\t}\n\tint sx, sy; cin >> sx >> sy;\n\tcout << bfs(sx+35,sy+35,T) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 70;\nconst int D = 31;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint main(void){\n    for(int t, n, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vvi trap(N, vi(N));\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            trap[y + D][x + D] = true;\n        }\n        rep(i, D) trap[0][i] = trap[D * 2][i] = trap[i][0] = trap[i][D * 2] = true;\n\n        pii s; cin >> s.X >> s.Y;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(mp(s.X + D, s.Y + D), 0));\n\n        while(!q.empty()){\n            pii p = q.front().first;\n            int turn = q.front().second;\n            q.pop();\n\n            if(turn == t + 1) continue;\n            if(trap[p.Y][p.X]) continue;\n\n            res++;\n            trap[p.Y][p.X] = true;\n\n            rep(i, 6){\n                q.push(mp(mp(p.X + dx[i], p.Y + dy[i]), turn + 1));\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \n#define M_PI       3.14159265358979323846\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \nclass WeightedUnionFind{\npublic:\n    vector <int> par; \n    vector <int> siz;\n    vector <ll> diff_weight; /* 頂点間の重みの差 */\n\n    WeightedUnionFind(int sz_): par(sz_), siz(sz_, 1LL), diff_weight(sz_, 0LL){\n        for(int i=0; i<sz_; i++) par[i] = i;\n    }\n\n    void init(int sz_){\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        diff_weight.resize(sz_);\n        for(int i=0; i<sz_; i++) par[i] = i, diff_weight[i] = 0;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = r;\n        }\n    }\n\n    ll weight(ll x){\n        root(x);\n        return diff_weight[x];\n    }\n\n    bool issame(int x, int y){\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y, ll w){\n        w += weight(x); w -= weight(y);\n        x = root(x); y = root(y);\n        if(x == y) return false;\n\n        if (siz[x] < siz[y]) swap(x, y), w = -w;\n        siz[x] += siz[y];\n        par[y] = x;\n        diff_weight[y] = w;\n        return true;\n    }\n\n    ll diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n};\n \nll modPow(ll x, ll n, ll mod = MOD){\n    if(n <= 0) return 1;\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n \n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n\n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n\n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      data[k] %= MOD;\n    }\n  }\n\n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n\n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n\n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n\n\n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n\n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n\n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\n\n\n\nvector<vector<pair<int, ll>>> G(100010);\nint root = 0;\nint parent[25][100010];\nint depth[100010];\nll arr[100010];\n\nvoid dfs(int v, int prev, ll cost, int d){\n    arr[v] = cost;\n    parent[0][v] = prev;\n    depth[v] = d;\n    for(auto u: G[v]){\n        if(u.first == prev) continue;\n        dfs(u.first, v, (cost * u.second)%MOD, d+1);\n    }\n}\n\nvoid init(int N){\n    dfs(root, -1, 1, 0);\n\n    for(int k=0; k+1<25; k++){\n        for(int v=0; v<N; v++){\n            if(parent[k][v] < 0) parent[k+1][v] = -1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n\n    for(int k=0; k<25; k++){\n        if((depth[v]-depth[u]) >> k & 1) {\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k=24; k>=0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(15);\n\n    int t,n;\n    while(cin >> t >> n){\n        if(t == 0 && n == 0) break;\n\n        vector<vector<int>> reach(510, vector<int>(510,0));\n        REP(i,n){\n            int x, y; cin >> x >> y;\n            reach[y+200][x+200] = -1;\n        }\n        int sy, sx; cin >> sx >> sy;\n        reach[sy+200][sx+200] = 1;\n        queue<pair<int, pair<int, int>>> q;\n        q.push(make_pair(t, make_pair(sy+200, sx+200)));\n\n        while(q.size()){\n            pair<int, pair<int, int>> p = q.front();\n            q.pop();\n\n            int nokori = p.first;\n            int y = p.second.first, x = p.second.second;\n            //cout << y << \" \" << x << endl;\n            if(nokori == 0) continue;\n            int ny = y + 1, nx = x+1;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n\n            ny = y, nx = x+1;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n\n            ny = y-1, nx = x;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n            ny = y-1, nx = x-1;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n            ny = y, nx = x-1;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n            ny = y+1, nx = x;\n            if(reach[ny][nx] == 0){\n                reach[ny][nx] = 1;\n                q.push(make_pair(nokori-1, make_pair(ny, nx)));\n            }\n        }\n\n        int cnt = 0;\n        for(int i=0; i<510; i++){\n            for(int j=0; j<510; j++){\n                if(reach[i][j] == 1){\n                    cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint main(){\n  int t, n, x, y, c, sx, sy;\n  vector<int> dx = {1,1,0,0,-1,-1}, dy = {1,0,1,-1,0,-1};\n  while (cin >> t >> n, t){\n    vector< vector<int> > F(121, vector<int>(121,0));\n    for (int i = 0; i < n; ++i){\n      cin >> x >> y;\n      F[x+60][y+60] = -1;\n    }\n    cin >> sx >> sy;\n    F[sx+60][sy+60] = 1;\n    queue< vector<int> > que;\n    que.push({sx+60,sy+60,0});\n    int ans = 1;\n    while (!que.empty()){\n      x = que.front()[0];\n      y = que.front()[1];\n      c = que.front()[2];\n      que.pop();\n      if (c < t){\n\t++c;\n\tfor (int i = 0; i < 6; ++i){\n\t  if (!F[x+dx[i]][y+dy[i]]){\n\t    que.push({x+dx[i],y+dy[i],c});\n\t    F[x+dx[i]][y+dy[i]] = 1;\n\t    ++ans;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint turn;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tstatic int map[600][600];\n\t\tstatic bool object[600][600];\n\t\tmemset(object, false, sizeof(object));\n\t\tfor (int i = 0; i < 600; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 600; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobject[y + 300][x + 300] = true;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<data> q;\n\t\tdata f;\n\t\tf.cx = sx + 300;\n\t\tf.cy = sy + 300;\n\t\tf.turn = 0;\n\t\tmap[f.cy][f.cx] = 0;\n\t\tq.push(f);\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\td.turn++;\n\t\t\tif (d.turn > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = d.cx + dx[i];\n\t\t\t\tint ny = d.cy + dy[i];\n\t\t\t\t\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 600 || ny >= 600)continue;\n\t\t\t\tif (object[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] <= d.turn)continue;\n\t\t\t\tmap[ny][nx] = d.turn;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.turn = d.turn;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 600; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 600; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MAX)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n#define llong long long\n#define REP(i,n) for(auto i=0;i<n;++i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define FOR(i,a,b) for(auto i=a;i<b++i)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n\nusing namespace std;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nint main(){\n  while(true){\n    int t,n;cin >> t >> n;\n    if(t == 0 && n == 0)break;\n    vector<vector<int> > m(1024, vector<int>(1024,0));\n    int x0 = 512, y0 = 512;\n    for(int i = 0; i < n; i++){\n      int x,y; cin >>x >> y;\n      x += x0; y += y0;\n      m[x][y] = -1;\n    }\n    int sx,sy;cin >> sx >> sy;\n    sx += x0; sy += y0;\n    queue<pair<int, int> > q;\n    q.push(make_pair(sx,sy));\n    int ans = 1;\n    while(!q.empty()){\n      auto now = q.front();\n      int turn = m[now.first][now.second];\n      if(now == make_pair(sx,sy)){\n        m[sx][sy] = -1;\n      }\n      q.pop();\n      for(int i = 0;i < 6; i++){\n        int nextx = now.first + dx[i];\n        int nexty = now.second + dy[i];\n        if(m[nextx][nexty] == 0 && turn < t){\n          //if(abs(nextx-x0) > 30 || abs(nexty-y0) > 30)continue;\n          q.push(make_pair(nextx,nexty));\n          ans++;\n          m[nextx][nexty] = turn+1;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n          \n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {0, 1, -1, 1, -1, 0};\nconst int dy[] = {1, 1, 0, 0, -1, -1};\nint t, n;\nint d[222][222];\nint can[222][222];\nint x, y;\nint N = 70;\n\nint main()\n{\n  while(cin >> t >> n, t){\n    rep(i, 222) rep(j, 222) d[i][j] = 0;\n    rep(i, 222) rep(j, 222) can[i][j] = INF;\n    rep(i, n){\n      cin >> x >> y;\n      can[x+N][y+N] = -INF;\n    }\n    cin >> x >> y;\n\n   queue<pair<pii, int> > que;\n   can[x+N][y+N] = false;\n   d[x+N][y+N] = 1;\n   que.push(mp(mp(x, y), 0));\n   while(!que.empty()){\n     pair<pii, int> here = que.front();  que.pop();\n     int hx = here.first.first;\n     int hy = here.first.second;\n     int cnt = here.second;\n     if(cnt >= t) continue;\n     rep(k, 6){\n       int nx = hx + dx[k];\n       int ny = hy + dy[k];\n       if(minup(can[nx+N][ny+N], cnt + 1)){\n         d[nx+N][ny+N] = 1;\n         que.push(mp(mp(nx, ny), cnt + 1));\n       }\n     }\n   }\n\n   int res = 0;\n   rep(i, 222) rep(j, 222) res += d[i][j];\n\n   cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\nusing namespace std;\nint t, n, x, y, a, b, v[123][123]; bool s[123][123];\nint main() {\n\twhile (~scanf(\"%d%d\", &t, &n)) {\n\t\tif (t == 0) break;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\ts[i][j] = false, v[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y); s[y + 61][x + 61] = true;\n\t\t}\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tqueue<pair<int, int> > que; que.push(make_pair(a + 61, b + 61)); v[b + 61][a + 61] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint x = que.front().first;\n\t\t\tint y = que.front().second; que.pop();\n\t\t\tif (v[y][x] == t) continue;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (i + j != 0 && v[y + i][x + j] == -1 && !s[y + i][x + j]) {\n\t\t\t\t\t\tv[y + i][x + j] = v[y][x] + 1;\n\t\t\t\t\t\tque.push(make_pair(x + j, y + i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\tif (v[i][j] != -1) ret++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define mp(a, b) make_pair(a, b)\ntypedef pair<pair<int, int>, int> State;\n\nstatic const int MAX = 30;\nstatic const int N =  3*MAX+1;\nstatic const int dx[6] = {1, 1, 0, -1, -1, 0};\nstatic const int dy[6] = {0, 1, 1, 0, -1, -1};\nmain(){\n  bool O[N][N];\n  int t, n, x, y, sx, sy;\n  while(1){\n    cin >> t >> n;\n    if ( t == 0 && n == 0 ) break;\n    rep(i, N) rep(j, N) O[i][j] = false;\n    rep(i, n){\n      cin >> x >> y;\n      O[x+MAX][y+MAX] = true;\n    }\n    cin >> sx >> sy;\n    sx += MAX;\n    sy += MAX;\n    queue<State> Q;\n    State u;\n    Q.push(mp(mp(sx, sy), 0));\n    O[sx][sy] = true;\n    int cnt = 0;\n    while(!Q.empty()){\n      u = Q.front(); Q.pop();\n\n      cnt++;\n      for ( int r = 0; r < 6; r++ ){\n\tint nx = u.first.first + dx[r];\n\tint ny = u.first.second + dy[r];\n\tif ( O[nx][ny] || u.second+1 > t) continue;\n\tO[nx][ny] = true;\n\tQ.push(mp(mp(nx, ny), u.second+1));\n      }\n    }\n    cout << cnt << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint turn, n;\n\t\tint f[61][61], d[61][61];\n\t\tint dx[6]={1,1,0,-1,-1,0}, dy[6]={0,1,1,0,-1,-1};\n\t\t\n\t\t//初期化\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60 ;++j){\n\t\t\t\tf[i][j]=0;\n\t\t\t\td[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &turn, &n);\n\t\tif(turn==0) break;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint a, b;\n\t\t\tscanf(\" %d %d\", &a, &b);\t\n\t\t\tf[a+30][b+30]=1;\n\t\t}\n\t\t\n\t\tpoint start;\n\t\tscanf(\" %d %d\", &start.x, &start.y);\n\t\tstart.x+=30;\n\t\tstart.y+=30;\n\t\n\t\t//BFS\t\n\t\tqueue<point> que;\n\t\td[start.x][start.y]=0;\n\t\tque.push(start);\n\t\t\n\t\twhile( !que.empty() ){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\t\n\t\t\t//printf(\" pop\\n\");\n\t\t\t\t\t\t\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(nx>=0 && nx<=60 && ny>=0 && ny<=60 && f[nx][ny]!=1 && d[nx][ny]==-1){\n\t\t\t\t\td[nx][ny] = d[v.x][v.y]+1;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx;\n\t\t\t\t\ttmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t//printf(\"push\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=0; i<=60; ++i){\n\t\t\tfor(int j=0; j<=60; ++j){\n\t\t\t\tif(d[i][j]>=0 && d[i][j]<=turn) ++ans;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[100][100];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif(a[p.real()+50][p.imag()+50] == -2) return 0;\n\tif(k <= a[p.real()+50][p.imag()+50]) return 0;\n\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == -1) res++;\n\ta[p.real()+50][p.imag()+50] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tfor(int i=0;i<100;i++) for(int j=0;j<100;j++) a[i][j] = -1;\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\n#define pluska 60\nint data[300][300];\nint t,n;\n\nqueue<int> qx,qy,qturn;\n\nint search(){\n\tll int rst = 0;\n\twhile(!qx.empty()){\n\t\tint sx = qx.front(); int sy = qy.front(); int nturn = qturn.front();\n\t\tqx.pop(); qy.pop(); qturn.pop();\n\t\tREP(i,6){\n\t\t\tif(nturn == 0) i = 6;\n\t\t\tint nx = sx + dx[i]; int ny = sy + dy[i];\n\t\t\tif(data[nx][ny]==0){\n\t\t\t\trst++;\n\t\t\t\tqx.push(nx);\n\t\t\t\tqy.push(ny);\n\t\t\t\tqturn.push(nturn-1);\n\t\t\t\tdata[nx][ny] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn rst;\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t==0&&n==0) break;\n\t\tREP(i,300) REP(j,300) data[i][j] = 0;\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin >> tx >> ty;\n\t\t\tdata[tx+pluska][ty+pluska] = -1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tqx.push(sx+pluska);\n\t\tqy.push(sy+pluska);\n\t\tqturn.push(t);\n\t\tdata[sx+pluska][sy+pluska] = 1;\n\t\tcout << search()+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int t,n;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0)break;\n    vector<vi> v(300,vi(300,INF));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      v[x+100][y+100]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<pii> q;\n    q.push(pii(sx+100,sy+100));\n    v[sx+100][sy+100]=0;\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      if(v[x][y]>=t)continue;\n      rep(i,6){\n\tint nx=x+dx[i];\n\tint ny=y+dy[i];\n\tif(v[nx][ny]>=0 && v[nx][ny]>v[x][y]+1){\n\t  v[nx][ny]=v[x][y]+1;\n\t  q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    int ans=0;\n    rep(i,300)rep(j,300)\n      if(v[i][j]>=0 && v[i][j]<INF)ans++;\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(visited.find(fr.first.first+dx[i],fr.first.second+dy[i])==visited.end()&&jama.find(fr.first.first+dx[i],fr.first.second+dy[i])==jama.end())q.push(piii(pii(fr.first.first+dx[i],fr.first.second+dy[i]),fr.second+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define TEST 0\n#if TEST\nFILE *in = freopen(\"./q.txt\", \"r\", stdin);\nFILE *out = freopen(\"./a.txt\", \"w\", stdout);\n#endif\n\nint dx[6] = { 0, 1, 1, 0,-1,-1};\nint dy[6] = { 1, 1, 0,-1,-1, 0};\n\ninline void pusuQueue(queue<int>& q, int x, int y, int t){\n\tq.push(x), q.push(y), q.push(t);\n}\ninline void popQueue(queue<int>& q, int& x, int& y, int& t){\n\tx = q.front(); q.pop();\n\ty = q.front(); q.pop();\n\tt = q.front(); q.pop();\n}\n\ninline bool isRegion(int x, int y){\n\treturn x >= -30 && x <= 30 && y >= -30 && y <= 30;\n}\n\nint main(){\n\twhile (1){\n\t\tint t, n; cin >> t >> n;\n\t\tif (!t && !n) break;\n\n\t\tmap<pair<int, int>, bool> isBar;\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tisBar[make_pair(x, y)] = true;\n\t\t}\n\t\t\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tisBar[make_pair(sx, sy)] = true;\n\n\t\tint cnt = 0;\n\t\tqueue<int> q;\n\t\tpusuQueue(q, sx, sy, 0);\n\t\twhile (!q.empty()){\n\t\t\tint x, y, turn; popQueue(q, x, y, turn);\n\t\t\tcnt++;\n\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (turn < t && !isBar[make_pair(nx, ny)]){\n\t\t\t\t\tpusuQueue(q, nx, ny, turn+1);\n\t\t\t\t\tisBar[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\n\t}\n\n\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int t,n;\n    cin >> t >> n;\n    if(!t&&!n) return 0;\n    deque<pair<int,pair<int,int> > > bfs;\n    int steps[128][128];\n    REP(i,128){\n      REP(j,128){\n\tsteps[i][j]=0;\n      }\n    }\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      steps[x+64][y+64]=-1;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    for(bfs.PB(MP(t+1,MP(sx,sy)));SZ(bfs);bfs.pop_front()){\n      pair<int,int> xy = bfs.front().second;\n      int x = xy.first,y = xy.second;\n      int tmpstep = bfs.front().first;\n      if(steps[x+64][y+64]>=0)\n\tif(steps[x+64][y+64]<tmpstep){\n\t  steps[x+64][y+64]=tmpstep;\n\t  if(--tmpstep){\n\t    bfs.PB(MP(tmpstep,MP(x,y+1)));\n\t    bfs.PB(MP(tmpstep,MP(x+1,y)));\n\t    bfs.PB(MP(tmpstep,MP(x+1,y+1)));\n\t    bfs.PB(MP(tmpstep,MP(x,y-1)));\n\t    bfs.PB(MP(tmpstep,MP(x-1,y)));\n\t    bfs.PB(MP(tmpstep,MP(x-1,y-1)));\n\t  }\n\t}\n    }\n    int answer=0;\n    REP(i,128){\n      REP(j,128){\n\tif(steps[i][j]>0) answer++;\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<stdio.h>\n#include<math.h>\n#include<unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing lst = list<int>;\n\nint dx[6] = { 1,1, 0,0,-1,-1 };\nint dy[6] = { 0,1,-1,1,-1, 0 };\n\nbool solve()\n{\n\tint t, n;\n\tcin >> t >> n;\n\tif (t == 0 && n == 0)return false;\n\n\tmat cell(200, vec(200, 0));\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcell[x+100][y+100] = -1;\n\t}\n\n\tint bx, by; cin >> bx >> by;\n\n\tlist<pair<int, int>> Q;\n\tQ.push_back({ bx+100, by+100 });\n\tcell[bx + 100][by + 100] = 1;\n\tint ans = 1;\n\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front().first, y = Q.front().second;\n\t\tfor (int i = 0; i < 6; ++i)\n\t\t{\n\t\t\tif (cell[x + dx[i]][y + dy[i]] == 0)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tcell[x + dx[i]][y + dy[i]] = 1 + cell[x][y];\n\t\t\t\tif (cell[x + dx[i]][y + dy[i]] <= t)\n\t\t\t\t{\n\t\t\t\t\tQ.push_back({ x + dx[i],y + dy[i] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop_front();\n\t}\n\tcout << ans << endl;\n\n\treturn true;\n}\n\nint main()\n{\n\twhile (solve());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;\n\t\t\t//stage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n \nconst int dx[6] = { 1,1,0,-1,-1,0};\nconst int dy[6] = { 0,1,1,0,-1,-1 };\n \n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)///\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int t, n;\n        cin >> t >> n;\n        if (!n)break;\n        vvi v(61, vi(61, 0));\n        REP(i, n) {\n            int x, y;\n            cin >> x >> y;\n            v[y + 30][x + 30] = 1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        vvi depth(61, vi(61, INF));\n        depth[sy + 30][sx + 30] = 0;\n        queue<pii> q;\n        q.push(make_pair(sx, sy));\n        while (!q.empty()) {\n            pii a = q.front(); q.pop();\n            int x = a.first, y = a.second;\n            REP(i, 6) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (ny <= 30 && nx <= 30 && nx >= -30 && ny >= -30 && v[ny + 30][nx + 30] == 0&&depth[ny+30][nx+30]==INF) {\n                    q.push(make_pair(nx, ny));\n                    depth[ny + 30][nx + 30] = depth[y + 30][x + 30] + 1;\n                }\n            }\n        }\n        int cnt = 0;\n        REP(i, 61) {\n            REP(j, 61) {\n \n                if (depth[i][j] <= t)cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntemplate<class T1,class T2>\nusing Hash = unordered_map<T1, T2>;\n\nint dx[]{ 0,1,1,0,-1,-1 }, dy[]{ 1,1,0,-1,-1,0 };\nint main() {\n\tint t, n;\n\twhile (scanf(\"%d%d\", &t, &n), t) {\n\t\tHash<int, Hash<int, int>>mp, d;\n\t\trep(i, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tmp[x][y] = 1;\n\t\t}\n\t\tfor (int i = -30; i <= 30; i++)for (int j = -30; j <= 30; j++) {\n\t\t\td[i][j] = INT_MAX;\n\t\t}\n\t\tint sx, sy; scanf(\"%d%d\", &sx, &sy);\n\t\tqueue<P>que;\n\t\tint cnt = 1;\n\t\tque.push(P(sx, sy));\n\t\td[sx][sy] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif (d[p.first][p.second] >= t)continue;\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (!mp[nx][ny] && d[nx][ny] == INT_MAX) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\nconst int inf=1<<28;\n\nint dp[1<<16];\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n){\n\t\tint t[20][20];\n\t\trep(i,n)rep(j,n+1)cin>>t[i][j];\n\t\t\n\t\trep(i,1<<n)dp[i]=inf;\n\t\tdp[0]=0;\n\t\trep(i,1<<n){\n\t\t\trep(j,n)if(!(i&1<<j)){\n\t\t\t\trep(k,n)if(i&1<<k)dp[i|1<<j]=min(dp[i|1<<j],dp[i]+t[j][k+1]);\n\t\t\t\tdp[i|1<<j]=min(dp[i|1<<j],dp[i]+t[j][0]);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<n)-1]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define POS 1\n#define INPOS -1\n#define adj 100\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nconst int dx[] = {0, -1, -1, 0, 1, 1};\nconst int dy[] = {1, 0, -1, -1, 0, 1};\n\nint field[200][200];\nint t;\nint sx, sy;\n\nvoid dfs(int x, int y, int n){\n  if(n == 0) return;\n  rep(i, 6){\n    int nx = x+dx[i], ny = y+dy[i];\n    if(field[ny][nx] != INPOS){\n      field[ny][nx] = POS;\n      dfs(nx, ny, n-1);\n    }\n  }\n}\n    \nint main(){\n  int n;\n  int jx, jy;\n  while(cin >> t >> n, t|n){\n    memset(field, 0, sizeof(field));\n    while(n--){\n      cin >> jx >> jy;\n      jx += adj, jy += adj;\n      field[jy][jx] = INPOS;\n    }\n    cin >> sx >> sy;\n    sx += adj, sy += adj;\n    int ans = 0;\n    field[sy][sx] = POS;\n    dfs(sx, sy, t);\n    rep(i, 200){\n      rep(j, 200){\n\tif(field[i][j] == POS) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int dy[6] = {1, 1, 0, -1, -1, 0};\nconst int dx[6] = {0, 1, 1, 0, -1, -1};\nint t, n;\nbool used[100][100], block[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = 1;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      //if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint turn;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tint map[100][100];\n\t\tbool object[100][100];\n\t\tmemset(object, false, sizeof(object));\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobject[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<data> q;\n\t\tdata f;\n\t\tf.cx = sx + 50;\n\t\tf.cy = sy + 50;\n\t\tf.turn = 0;\n\t\tmap[f.cy][f.cx] = 0;\n\t\tq.push(f);\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tif (d.turn + 1> t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = d.cx + dx[i];\n\t\t\t\tint ny = d.cy + dy[i];\n\t\t\t\t\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 100 || ny >= 100)continue;\n\t\t\t\tif (object[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] <= map[d.cy][d.cx])continue;\n\n\t\t\t\tmap[ny][nx] = d.turn + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.turn = d.turn + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MAX)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,t;\nint map[100][100],fast[100][100];\nint dx[6]={0,1,0,-1,1,-1},dy[6]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n    map[y][x]=1;\n    if(len<t&&len<fast[y][x]){\n    fast[y][x]=len;\n    for(int i=0;i<6;i++){\n        if(map[y+dy[i]][x+dx[i]]!=-1)\n            DFS(y+dy[i],x+dx[i],len+1);\n    }\n    }\n}\nint main(){\n    while(true){\n    cin>>t>>n;\n    if(t==0&&n==0)\n        break;\n    for(int i=0;i<100;i++){\n        for(int j=0;j<100;j++){\n            map[i][j]=0;\n            fast[i][j]=50;\n        }\n    }\n    int x,y;\n    for(int i=0;i<n;i++){\n        cin>>x>>y;\n        map[50+y][50+x]=-1;\n    }\n    cin>>x>>y;\n    DFS(y+50,x+50,0);\n    int ans=0;\n    for(int i=0;i<100;i++){\n        for(int j=0;j<100;j++){\n            if(map[i][j]==1)\n                ans++;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tbool obstacle[100][100];\n\t\tmemset(obstacle, false, sizeof(obstacle));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\t\tint ans = 1;\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (obstacle[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tif (map[cy][cx] + 1> t)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tans++;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\n\nconst int MAX = 70;\nconst int BASE = 35;\nint map[MAX][MAX];\nbool wall[MAX][MAX];\nint dx[] = {0,0,1,-1,1,-1};\nint dy[] = {1,-1,0,0,1,-1};\nint T,n,ans;\n\nvoid init(){\n  memset(map,-1,sizeof(map));\n  memset(wall,false,sizeof(wall));\n  ans = 0;\n}\n\nvoid dfs(int x, int y, int t){\n  if(map[x][y] >= t) return;\n  map[x][y] = t;\n  if(t <= 0) return;\n\n  for(int i = 0; i < 6; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(abs(nx-BASE) + abs(ny-BASE) <= 30 && !wall[nx][ny]) dfs(nx,ny,t-1);\n  }\n}\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      if(map[i][j] >= 0 && abs(i-BASE)+ abs(j-BASE) <= 30) ans++;\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> T >> n && T+n){\n    init();\n    while(n--){\n      int x,y;\n      cin >> x >> y;\n      wall[x+BASE][y+BASE] = true;\n    }\n    int sx,sy;\n    cin >> sx >> sy;\n    dfs(BASE+sx,BASE+sy,T);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int t,n;\n  int dx[6]={0,1,1,0,-1,-1};\n  int dy[6]={1,1,0,-1,-1,0};\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0)break;\n    vector<vi> v(65,vi(65,INF));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      v[x+30][y+30]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<pii> q;\n    q.push(pii(sx+30,sy+30));\n    v[sx+30][sy+30]=0;\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      if(v[x][y]>=t)continue;\n      rep(i,6){\n\tint nx=x+dx[i];\n\tint ny=y+dy[i];\n\tif(nx>=0 && nx<=60 && ny>=0 && ny<=60 && v[nx][ny]>=0 && v[nx][ny]>v[x][y]+1){\n\t  v[nx][ny]=v[x][y]+1;\n\t  q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    int ans=0;\n    rep(i,61)rep(j,61)\n      if(v[i][j]>=0 && v[i][j]<INF)ans++;\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tmap[ny][nx] = min(map[ny][nx],map[cy][cx] + 1);\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint min = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] > INT_MIN && map[i][j] <= t)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ans = 100 * 100 - min - max;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\nusing namespace std;\nint m[61][61]={0};\n\nvoid proc(int x,int y,int turn,int end){\n    int i,j;\n    if(turn>end){return;}\n    for(i=-1;i<=1;i++){\n        for(j=-1;j<=1;j++){\n            if(abs(i+j)==0){continue;}\n            if(0<=y+i && y+i<=60 && 0<=x+j && x+j<=60 && m[y+i][x+j]!=2){\n                m[y+i][x+j]=1;\n                proc(x+j,y+i,turn+1,end);\n            }\n        }\n    }\n}\n\nint main(){\n    int t,n,x,y,cnt,i,j;\n    while(1){\n        cin>>t>>n;\n        cnt=0;\n        if(!t && !n){break;}\n        for(i=0;i<n;i++){\n            cin>>x>>y;\n            m[y+30][x+30]=2;\n        }\n        cin>>x>>y;\n        m[y+30][x+30]=1;\n        proc(x+30,y+30,1,t);\n        for(i=0;i<61;i++){\n            for(j=0;j<61;j++){\n                if(m[i][j]==1){cnt++;}\n                m[i][j]=0;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <typeinfo>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nvoid reach(int a[][121],int b)//b回目のリーチで行ける場所をb+1に塗りつぶす\n{\n\tint x[6]={-1,-1,0,1,0,1};\n\tint y[6]={-1,0,-1,0,1,1};\n\t\n\tfor(int i=0;i<121;i++)\n\t{\n\t\tfor(int j=0;j<121;j++)\n\t\t{\n\t\t\tif(a[i][j]==b)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<6;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i+x[k]>-1 && i+x[k]<121 && j+y[k]>-1 && j+y[k]<121)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+x[k]][j+y[k]]==0)a[i+x[k]][j+y[k]]=b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\tint t,n;\n\twhile(cin>>t>>n&&!(n==0&&t==0))\n\t{\n\t\tint a[121][121]={};//座標は0~60\n\t\tREP(i,n){int x,y;cin>>x>>y;a[x+60][y+60]=-1;} //a[x][y]=-1なら障害物あり\n\t\tint x,y;cin>>x>>y;a[x+60][y+60]=1;//便宜所スタート地点は1にする。nターン目に行ける場所をn+1で塗りつぶす\n\t\tREP(i,t) reach(a,i+1);\n\t\tint ans(0);\n\t\tREP(i,121)REP(j,121)if(a[i][j]!=0&&a[i][j]!=-1)ans++;\n\t\t//REP(i,61){REP(j,61){cout << a[j][60-i]<<\" \";}cout<<endl;}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint tansaku(int map[35][35], int meX, int meY, int t) {\n  int count = 1;\n  map[meX + 17][meY + 17] = 1;\n  printf(\"%d\\n\", t);\n  for(int i = -1; i < 2; i++) {\n    if(i == 0) {\n      if(map[meX + i + 17][meY + 1 + 17] != 1) {\n        map[meX + i + 17][meY + 1 + 17] = 1;\n        t--;\n        count++;\n        if(t <= 0) break;\n        count += tansaku(map, meX + i + 17, meY + 1 + 17, t);\n      }\n    }\n    for(int j = -1; j < 1; j++) {\n      if(map[meX + i + 17][meY + j + 17] != 1) {\n        map[meX + i + 17][meY + j + 17] = 1;\n        t--;\n        count++;\n        if(t <= 0) break;\n        count += tansaku(map, meX + i + 17, meY + j + 17, t);\n      }\n    }\n  }\n  return count;\n}\n\nint main() {\n  int count = 0;\n  int t, n;\n  int x, y;\n  int map[35][35];\n  int meX, meY;\n\n  while(true){\n    for(int i = 0; i < 35; i++) {\n      for(int j = 0; j < 35; j++) {\n        map[i][j] = 0;\n      }\n    }\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++) {\n      cin >> x >> y;\n      map[x + 17][y + 17] = 1;\n    }\n\n\n    cin >> meX >> meY;\n    int count = 0;\n    count = tansaku(map, meX, meY, t);\n    cout << ++count << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a)*b);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0) return 1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0) return +2;\n\tif(norm(b) < norm(c) ) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\nxy_t crosspoint(const line &l, const line &m){\n\tdouble a = cross(l.second - l.first, m.second - m.first);\n\tdouble b = cross(l.second - l.first, l.second - m.first);\n\tif(abs(a) < EPS && abs(b) < EPS) return m.first;\n\tif(abs(a) < EPS) assert(false);\n\treturn m.first + b / a * (m.second - m.first);\n}\n\nconst int a = 100;\nint visit[200][200];\nbool can[200][200];\nint dy[] = {1, 0, -1, 0, 1, -1};\nint dx[] = {0, -1, 0, 1, 1, -1};\n\n\nint main(){\n\tint n, t;\n\twhile(cin >> t >> n && (n || t)){\n\t\tmemset(visit, -1, sizeof(visit));\n\t\tmemset(can, true, sizeof(can));\n\t\tfor(int i = 0; i <n; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tcan[x+a][y+a] = false;\n\t\t}\n\t\tint sx, sy;\n\t\tint res = 1;\n\t\tcin >> sx >> sy;\n\t\tqueue<PP> que;\n\t\tvisit[sx+a][sy+a] = 0;\n\t\tque.push(PP(0, P(sx+a, sy+a)));\n\t\twhile(!que.empty()){\n\t\t\tPP pp = que.front();\n\t\t\tque.pop();\n\t\t\tP p = pp.second;\n\t\t\tint turn = pp.first;\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tif(turn>= t) continue;\n\t\t\tfor(int i = 0; i < 6;  i++){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(visit[x2][y2] == -1 && can[x2][y2]){\n\t\t\t\t\tvisit[x2][y2] = turn + 1;\n\t\t\t\t\tres++;\n\t\t\t\t\tque.push(PP(visit[x2][y2], P(x2, y2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 50\n#define NN 2*N\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n\n  while( cin>>t>>n && (t|n) ){\n    char d[NN][NN]; // 50 geta\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = 0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[x][y] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;\n    q.push( S(x,y,t) );\n    int dx[6] = {1,1,0,-1,-1,0};\n    int dy[6] = {1,0,-1,-1,0,1};\n\n    int ans=0;\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n\n      if( s.t<0 ) continue;\n      if( d[s.x][s.y]!=0 ) continue;\n      d[s.x][s.y]=1;\n      ans++;\n\n      int nt = s.t-1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( d[nx][ny]!=0 ) continue;\n\tq.push( S(nx,ny,nt) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n#define N 100\n#define G 50\n#define KABE -1\n#define NON  0\n\nint map[N][N];\n\nint ans;\nvoid dfs(int x, int y, int t ){\n  if( t==0 )\n    return;\n  if( map[x][y] == KABE )\n    return;\n\n  if( abs(x-G) > 30 ||  abs(y-G) > 30 )\n    return;\n\n  ///  if( map[x][y] >= t )    return;\n\n  if( map[x][y] == NON )\n    ans++;\n  map[x][y] = t;\n\n\n  t--;\n  int dx[] = {1,1,0,-1,-1, 0};\n  int dy[] = {0,1,1, 0,-1,-1};\n  for( int d=0;d<6;d++ )\n    dfs(x+dx[d], y+dy[d], t );\n}\n\nint main(){\n  int t,n;\n  while( cin>>t>>n && (t|n) ){\n\n    for( int i=0;i<N;i++ )\n      for( int j=0;j<N;j++ )\n\tmap[i][j] = NON;\n\n    int y,x;\n    while( n-- ){\n      cin >> x >> y;\n      map[x+G][y+G] = KABE;\n    }\n    cin >> x >> y;\n\n    x+=G; y+=G;\n    ans = 0;\n    dfs(x, y, t+1 );\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\t//for(int i=0;i<jama.size();i++)\n\t//\t\tcout<<jama[i].first<<\"\\t\"<<jama[i].second<<endl;\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(!q.empty()&&q.front().second<=t){\n\t\t\tpiii fr=q.front();\n\t\t\tpii p=fr.first;\n\t\t\tint x=fr.first.first;\n\t\t\tint y=fr.first.second;\n\t\t\tint c=fr.second;\n\t\t\tq.pop();\n\t\t\tif(visited.find(p)!=visited.end())continue;\n\t\t\tvisited.insert(p);\n\t\t//\tcerr<<\"data:\\t\"<<x<<\"\\t\"<<y<<\"\\t\"<<c<<\"\\t\"<<endl;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(x+dx[i],y+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end()){\n\t\t\t\t\tq.push(piii(cur,c+1));\n\t\t\t//\t\tcerr<<\"\\t\\t\\t\\tpush:\\t\"<<cur.first<<\"\\t\"<<cur.second<<\"\\t\"<<c+1<<\"\\t\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,y,t;\n};\n\nint main(){\n  for(int t,n;cin>>t>>n,t|n;){\n    bool p[61][61]={{}};\n    bool o[61][61]={{}};\n    while(n--){\n      int x,y;\n      cin>>x>>y;\n      o[y+30][x+30]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    queue<S> que;\n    S is={sx+30,sy+30,t};\n    que.push(is);\n    while(!que.empty()){\n      S c=que.front();\n      que.pop();\n      if(p[c.y][c.x]++)continue;\n      if(c.t){\n\tfor(int i=0;i<6;i++){\n\t  int dy[]={1,1,0,-1,-1,0};\n\t  int dx[]={0,1,1,0,-1,-1};\n\t  int x=c.x+dx[i];\n\t  int y=c.y+dy[i];\n\t  if(x<0||61<x||y<0||61<y||o[y][x]){\n\t    continue;\n\t  }else{\n\t    S ns={x,y,c.t-1};\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    cout<<count(p[0],p[61],true)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nint _(int x) {\n  return x + 500;\n}\n\nstruct point {\n  int x;\n  int y;\n  int d;\n  point(int x, int y, int d)\n    : x(x), y(y), d(d) {\n  }\n};\n\nvoid solve() {\n  int t, n;\n  while (cin >> t >> n, t) {\n    vvi m(1000, vi(1000, false));\n    while (n--) {\n      int x, y;\n      cin >> x >> y;\n      m[_(x)][_(y)] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    queue<point> q;\n    q.push(point(sx, sy, 0));\n    int c = 0;\n    while (q.size()) {\n      point p = q.front();\n      q.pop();\n      if (p.d > t || m[_(p.x)][_(p.y)]) continue;\n      c++;\n      m[_(p.x)][_(p.y)] = true;\n      int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, 0, 1};\n      rep(i, 6) q.push(point(p.x + dx[i], p.y + dy[i], p.d + 1));\n    }\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\nint mtx[67][67]={0};\n\nint main(){\n    int t,n,x,y;\n    while(1){\n        queue< pair<int,pair<int,int> > > que;\n        fill(mtx[0],mtx[66],0);\n        scanf(\"%d %d\",&t,&n);\n        if(!t && !n){break;}\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&x,&y);\n            mtx[x+33][y+33]=-1;\n        }\n        scanf(\"%d %d\",&x,&y);\n        mtx[x+33][y+33]=1;\n        que.push(make_pair(0,make_pair(x+33,y+33)));\n        int cnt=0;\n        while(!que.empty()){\n            pair< int,pair<int,int> > p=que.front();\n            que.pop();\n            if(p.first>t){break;}\n            for(int j=0;j<6;j++){\n                int tx=p.second.first+dx[j];\n                int ty=p.second.second+dy[j];\n                int tu=p.first+1;\n                if(mtx[tx][ty]==0){\n                    mtx[tx][ty]=1;\n                    que.push(make_pair(tu,make_pair(tx,ty)));\n                }\n            }\n            cnt++;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int base=35;\n\nvoid solve(int t,int n){\n  int x,y;\n  bool d[75][75],used[75][75];\n  int dx[6]={1,1,0,-1,-1,0};\n  int dy[6]={1,0,-1,-1,-0,1};\n\n  rep(i,75)rep(j,75){\n    d[i][j]=true;\n    used[i][j]=false;\n  }\n  \n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    d[a+base][b+base]=false;\n  }\n  cin>>x>>y;\n  \n  queue<pi> que;\n  que.push(mp(x,y));\n  used[x+base][y+base]=true;\n  for(int i=0;i<t;i++){\n    int size=que.size();\n    for(int j=0;j<size;j++){\n      pi dir=que.front();que.pop();\n      for(int k=0;k<6;k++){\n\tpi tmp=mp(dir.first+dx[k],dir.second+dy[k]);\n\t//cout<<tmp.first<<\" \"<<tmp.second<<endl;\n\tif(!used[tmp.first+base][tmp.second+base]&&d[tmp.first+base][tmp.second+base]&&abs(tmp.first)<=30&&abs(tmp.second)<=30){\n\t  //cout<<tmp.first<<\" \"<<tmp.second<<endl;\n\t  que.push(tmp);\n\t  used[tmp.first+base][tmp.second+base]=true;\n\t}\n      }\n    }\n  }\n  int ans=0;\n  rep(i,75)rep(j,75)ans+=used[i][j];\n  cout<<ans<<endl;\n}\n\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0&&n==0)break;\n    solve(t,n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm> \n#include <queue>\n\nusing namespace std;\n\nstruct square{\n\tint x, y;\n\tbool flg;\t//到達フラグ\n\tbool sflg;\t//障害物フラグ\n\tint dist;\t//距離\n};\n\nvoid push_q( queue<square> *q, int x, int y, int d, int t,  vector< vector< square > > *s ){\n\tif( ( x < 0 ) || ( x > 60 ) ) return;\n\tif( ( y < 0 ) || ( y > 60 ) ) return;\n\tif( s -> at(x).at(y).flg == true ) return;\n\tif( s -> at(x).at(y).sflg == true ) return;\n\tif( d > t ) return;\n\n\tsquare sq;\n\tsq.x = x;\n\tsq.y = y;\n\tsq.dist = d;\n\tsq.flg = true;\n\n\ts->at(x).at(y) = sq;\n\n\tq -> push( sq );\n\n}\n\nvoid search_bfs( queue<square> *q, vector< vector< square > > *sq, int t){\n\twhile( q -> empty() == false ) {\n\t\tsquare s;\n\t\ts = q -> front();\n\t\tq -> pop();\n\n\t\tpush_q( q, s.x + 1, s.y, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x - 1, s.y, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x + 1, s.y + 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x - 1, s.y - 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x, s.y + 1, s.dist + 1, t, sq);\n\t\tpush_q( q, s.x, s.y - 1, s.dist + 1, t, sq);\n\t}\n}\n\nint main(void){\n  // FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile(1){\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif( t == 0 && n == 0 ) break;\n\n\t\tvector< vector< square > > sq;\n\t\tfor(int i = 0; i < 61; i++) {\n\t\t\tvector< square > sqr;\n\t\t\tfor(int j = 0; j < 61; j++) {\n\t\t\t\tsquare s;\n\t\t\t\ts.flg = false;\n\t\t\t\ts.dist = 0;\n\t\t\t\ts.sflg = false;\n\t\t\t\ts.x = i;\n\t\t\t\ts.y = j;\n\t\t\t\tsqr.push_back(s);\n\t\t\t}\n\t\t\tsq.push_back( sqr );\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint xpos, ypos;\n\t\t\tcin >> xpos >> ypos;\n\t\t\txpos += 30;\n\t\t\typos += 30;\n\t\t\tsq[xpos][ypos].sflg = true;\n\t\t}\n\n\t\tqueue< square > q;\n\t\tsquare squr;\n\t\tcin >> squr.x >> squr.y;\n\t\tsqur.x += 30;\n\t\tsqur.y += 30;\n\t\tsqur.dist = 0;\n\t\tsqur.flg = true;\n\t\tsqur.sflg = false;\n\t\tsq[squr.x][squr.y] = squr;\n\t\tq.push( squr );\n\n\t\tsearch_bfs( &q, &sq, t );\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 61; i++) {\n\t\t\tfor(int j = 0; j < 61; j++) {\n\t\t\t\tif( sq[j][i].flg == true ) ans ++;\n\t\t\t\t//cout << sq[j][i].flg ;\n\t\t\t}\n\t\t//\tcout << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\t//while(1){}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*cout <<\"Debug\"\ncout <<x-30<<' '<<y-30<<endl;*/\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[61][61];\nint cnt = 0;\nint d_x[] = {1,1,0,-1,0,-1};\nint d_y[] = {1,0,1,0,-1,-1};\nint t;\n/*\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cout <<\"Debug \";\n  cout <<x-30<<' '<<y-30<<endl;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  int used[6] = {0};\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(watasi < t)&&(mp[nx][ny] == 0)){\n        dfs(nx,ny,watasi);\n        used[dx] = 1;\n    }\n    for(int i = 0;i<6;i++){\n      if(used[i]){\n        if((nx == x + d_x[i])&&(ny == y + d_y[i])){\n          dfs(nx,ny,watasi);\n        }\n      }\n    }\n    }\n}\n*/\nint main(){\n  int n,t;\n\n  cin >>t>>n;\n  while(!((t == 0)&&(n == 0))){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<61;i++){\n      for(int j = 0;j<61;j++){\n        mp[i][j]=-1;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+30][y+30] = 1;\n    }\n    cin >>fx>>fy;\n\n    cnt = 0;\n\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(fx+30,fy+30));\n    mp[fx+30][fy+30] = 0;\n    while (!qu.empty()) {\n      pair<int ,int> pr = qu.front();\n      qu.pop();\n      int nx = pr.first,ny= pr.second;\n      cnt++;\n      if(mp[nx][ny] == t)continue;\n      for(int i = 0;i<6;i++){\n        int cx = nx+d_x[i],cy = ny+d_y[i];\n        if(mp[cx][cy] != -1)continue;\n        mp[cx][cy] = mp[nx][ny] + 1;\n        qu.push(make_pair(cx,cy));\n      }\n    }\n\n    cout <<cnt<<endl;\n    cin >>t>>n;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint M[200][200],X[]={-1,-1,0,0,1,1},Y[]={-1,0,-1,1,0,1};\nmain(){\n\tint r,n,k,x,y;\n\tfor(;scanf(\"%d%d\",&n,&k),n;printf(\"%d\\n\",r)){\n\t\tfor(memset(M,r=0,sizeof(M));k;k--)scanf(\"%d%d\",&x,&y),M[x+100][y+100]=1;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tqueue<pair<pair<int,int>,int> >q;\n\t\tfor(q.push(make_pair(make_pair(x+100,y+100),0));!q.empty();){\n\t\t\tpair<pair<int,int>,int>p=q.front();q.pop();\n\t\t\tif(M[p.first.first][p.first.second])continue;\n\t\t\tr+=M[p.first.first][p.first.second]=1;\n\t\t\tif(p.second<n)for(int i=0;i<6;i++)q.push(make_pair(make_pair(p.first.first+X[i],p.first.second+Y[i]),p.second+1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n\nusing namespace std;\n\n#define pb push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,j,k) for(int i=j;i<(k);i++)\nint sx,sy, t, n;\nint dx[6] = {0,0,1,1,-1,-1};\nint dy[6] = {1,-1,0,1,0,-1};\nstruct P{\n\tint x,y,a;\n\tP(int x, int y){\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\ta = 0;\n\t}\n\tP(int x, int y,int a){\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->a = a;\n\t}\n\t\n};\n\nint bfs(vector< vector<int> > &d){\n\tint sum = 1;\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\td[sx][sy] = -1;\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tif(p.a>=t){ continue; }\n\t\trep(i,6){\n\t\t\tint nx = p.x+dx[i],ny = p.y+dy[i];\n\t\t\tif(0<=nx&&0<=ny&&ny<200&&nx<200&&d[nx][ny]==0){\n\t\t\t\td[nx][ny] = -1;\n\t\t\t\tque.push(P(nx,ny,p.a+1));\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n\t\n}\n\nint main(){\n\twhile(1){\n\t\tvector< vector<int> > d(200,vector<int>(200,0));\n\t\tcin >> t >> n;\n\t\tif(t==0&&n==0){ return 0;}\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\td[x+100][y+100] = -1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 100;\n\t\tsy += 100;\n\t\tcout << bfs(d) << endl;\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) <= i) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) <= t) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAX_RANGE 500\n\nstruct POS\n{\n\tint X,Y,far;\n};\n\nPOS move(POS &now, POS &power)\n{\n\tPOS ans = {now.X+power.X, now.Y+power.Y, now.far+1};\n\treturn ans;\n}\nbool eq(POS &a, POS &b){return a.X == b.Y && a.Y == b.Y;}\n\nPOS mpow[6]={{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\nbool list[MAX_RANGE][MAX_RANGE];\n\nint movenum(POS &start, int t, int n);\n\nint main()\n{\n\tint t,n,x,y;\n\tPOS start;\n\twhile(true){\n\t\tstd::cin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0; i<MAX_RANGE; i++)\n\t\t\tfor(int j=0; j<MAX_RANGE; j++) list[i][j] = false;\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tstd::cin >> x >> y;\n\t\t\tlist[x+MAX_RANGE/2][y+MAX_RANGE/2] = true;\n\t\t}\n\t\tstart.X = x;\n\t\tstart.Y = y;\n\t\tstart.far = 0;\n\t\tstd::cout << movenum(start, t, n) << std::endl;\n\t}\n\treturn 0;\n}\n\nint movenum(POS &start, int t, int num)\n{\n\tint n = num, mnum=1;\n\tPOS now = start;\n\tstd::queue<POS> q;\n\tfor(;;){\n\t\tif(now.far != t){\n\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\tPOS s = move(now, mpow[j]);\n\t\t\t\tif(!list[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2]){\n\t\t\t\t\tmnum++;\n\t\t\t\t\tlist[s.X+MAX_RANGE/2][s.Y+MAX_RANGE/2] = true;\n\t\t\t\t\tq.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.empty()) break;\n\t\tnow = q.front();\n\t\tq.pop();\n\t}\n\treturn mnum;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint dx[6] = { -1,-1,0,1,1,0 };\nint dy[6] = { 0,-1,-1,0,1,1 };\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tint T, N; cin >> T >> N;\n\t\tif (!T)break;\n\t\tset<pair<int, int>>mp;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tmp.emplace(x, y);\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tqueue<aa>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tmp.emplace(sx, sy);\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tif (atop.turn == T)break;\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\tint nx = atop.x + dx[i];\n\t\t\t\t\tint ny = atop.y + dy[i];\n\t\t\t\t\tif (mp.find(make_pair(nx, ny)) == mp.end()) {\n\t\t\t\t\t\tmp.emplace(nx, ny);\n\t\t\t\t\t\tque.push(aa{ nx,ny,atop.turn + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mp.size() - N << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,t;};\nint main(){\n  int t,n,i,j,k,x,y;\n  cin >> t >> n;\n  while(t!=0||n!=0){\n    \n    int m[200][200]={{}};\n    int dis[200][200]={{}};\n    queue <Point> ps;\n    Point p,b;\n    for(i=0;i<n;i++){\n      cin >> x >> y;\n      dis[100+x][100+y]=1;\n    }\n    cin >> p.x  >> p.y;\n    p.x+=100;p.y+=100;\n    m[p.x][p.y]=1;\n    p.t=0;\n    ps.push(p);\n    int o=0;\n    while(!ps.empty()){\n      o++;\n      p=ps.front();\n      ps.pop();\n      if(p.t<t){\n\tif(m[p.x+1][p.y]+dis[p.x+1][p.y]==0){\n\t  b.x=p.x+1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y+1]+dis[p.x][p.y+1]==0){\n\t  b.x=p.x;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x+1][p.y+1]+dis[p.x+1][p.y+1]==0){\n\t  b.x=p.x+1;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y]+dis[p.x-1][p.y]==0){\n\t  b.x=p.x-1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y-1]+dis[p.x][p.y-1]==0){\n\t  b.x=p.x;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y-1]+dis[p.x-1][p.y-1]==0){\n\t  b.x=p.x-1;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n      }\n    }\n    cout << o << endl;\n    //cout << t << endl;\n    cin >> t >> n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint data[100][100];\n\t\tint flag[100][100];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX+=50;\n\t\t\ttmpY+=50;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[tmpY][tmpX]=-1;\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tsx+=50;\n\t\tsy+=50;\n\t\tcin>>sx>>sy;\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[1000][1000];\nbool close_graph[1000][1000];\n/**********************************************/\n\nvoid bfs(){\n    deque<P> que;\n    que.clear();\n    que.push_back(P(y.back()+500, x.back()+500));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > t) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop_front();\n            REP(i, 6){\n                if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                    que.push_back(P(cur.first + dy[i], cur.second + dx[i]));\n                    close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                    graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 1000) REP(j, 1000) if(graph[i][j] != INF){\n        //cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 1000) REP(j, 1000) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 1000){\n            REP(j, 1000){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[500 + y[i]][500 + x[i]] = true;\n        }\n        graph[500 + y.back()][500 + x.back()] = 0;\n        close_graph[500 + y.back()][500 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nbool inside(PII p) {\n    return 0 <= p.first && p.first <= 60 && 0 <= p.second && p.second <= 60;\n}\nvoid solve(int t, int n) {\n    int cnt = 0;\n    vector<vector<bool>> used(65, vector<bool>(65, false));\n    int dx[] = {0, 0, -1, -1, 1, 1};\n    int dy[] = {-1, 1, -1, 0, 0, 1};\n    set<PII> block;\n    PII start;\n    REP(_, n) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        used[x + 30][y + 30] = true;\n    }\n    int x, y; scanf(\"%d%d\", &x, &y);\n    start = MP(x + 30, y + 30);\n    queue<pair<PII, int>> q;\n    q.push(MP(start, 0));\n    while (!q.empty()) {\n        auto buf = q.front(); q.pop();\n        PII now = buf.first;\n        if (buf.second > t) continue;\n        if (used[now.first][now.second]) continue;\n        used[now.first][now.second] = true;\n        cnt++;\n        REP(i, 6) {\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n            if (!inside(MP(nx, ny))) continue;\n            q.push(MP(MP(nx, ny), buf.second + 1));\n        }\n    }\n    cout << cnt << endl;\n    return;\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    while (cin >> n >> m, n) {\n        solve(n, m);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nint main(void){\n\tint t, n, i, j, field[61][61], ix, iy, count;\n\tconst int standard = 30, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<int> x, y;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t == 0 && n == 0)\n\t\t\tbreak;\n\t\tmemset(field,-1,sizeof(field));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&ix,&iy);\n\t\t\tfield[iy + standard][ix + standard] = 0;\n\t\t}\n\t\tscanf(\"%d%d\",&ix,&iy);\n\t\tx.push(standard + ix),y.push(standard + iy);\n\t\tfield[standard + iy][standard + ix] = 0;\n\t\twhile(x.size()){\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(field[y.front() + dy[i]][x.front() + dx[i]] == -1 && field[y.front()][x.front()] < t){\n\t\t\t\t\tx.push(x.front() + dx[i]),y.push(y.front() + dy[i]);\n\t\t\t\t\tfield[y.front() + dy[i]][x.front() + dx[i]] = field[y.front()][x.front()] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.pop(), y.pop();\n\t\t}\n\t\tcount = 1;\n\t\tfor(i = 0;i < 61;i++){\n\t\t\tfor(j = 0;j < 61;j++)\n\t\t\t\tif(field[i][j] > 0)\n\t\t\t\t\tcount++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\n// const int offset = 30;\n// const int SIZE = 2 * offset + 1;\nconst int offset = 100;\nconst int SIZE = 2 * offset + 1;\nconst int INF = 1e9;\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, 1, 0, -1, 1, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < SIZE && 0 <= y && y < SIZE;\n}\n\nint bfs(int t, int n) {\n    set<P> blocks;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        blocks.insert(P(x + offset, y + offset));\n    }\n\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += offset;\n    sy += offset;\n\n    queue<P> que;\n    que.push(P(sx, sy));\n    VV d(SIZE, V(SIZE, INF));\n    d[sx][sy] = 0;\n\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        rep(k, 6) {\n            int nx = p.first + dx[k], ny = p.second + dy[k];\n            if (inside(nx, ny) && blocks.count(P(nx, ny)) == 0 && d[nx][ny] == INF) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, SIZE) {\n        rep(j, SIZE) {\n            if (d[i][j] <= t) {\n                ans++;\n            }\n        }\n    }\n\n    return ans;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int t, n;\n    while (cin >> t >> n, t) {\n        cout << bfs(t, n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nint main(){\n\tint t,n,s=1000;\n\tvvi field(s*2+3,vi(s*2+3,0));\n\twhile(cin>>t>>n,t){\n\t\tauto v=field;\n\t    int x,y;\n\t\trep(i,n+1){\n\t\t    cin>>x>>y;\n\t\t    x+=s+1,y+=s+1;\n        \tv[y][x]=1;\n\t\t}\n\t\tqueue<pair<int,pii>> que;\n\t\tque.emplace(0,mp(y,x));\n\t\tvi f={0,1,1,0,-1,-1,0};\n\t\tint ans=1;\n\t\twhile(que.front().fs<t){\n\t\t    auto c=que.front().sc;\n\t\t    rep(i,6){\n\t\t        if(v[c.fs+f[i]][c.sc+f[i+1]]==0){\n\t\t            ans++;\n\t\t            que.emplace(que.front().fs+1, mp(c.fs+f[i], c.sc+f[i+1]));\n\t\t            v[c.fs+f[i]][c.sc+f[i+1]]=2;\n\t\t        }\n\t\t    }\n\t\t    que.pop();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint dy[] = {0,1,1,0,-1,-1};\nint dx[] = {1,1,0,-1,-1,0};\nint t,n;\nset<pair<int,int> > point;\ntypedef pair<int,int> P;\nconst int C = 40;\nconst int INF = 100000;\n\nvoid solve() {\n    int dist[103][103];\n    rep(i,103) rep(j,103) dist[i][j]=INF;\n    int x,y;\n    rep(i,n) {\n        cin>>x>>y;\n        x+=C;\n        y+=C;\n        \n        point.insert(make_pair(y,x));\n    }\n    queue<P> que;\n    cin>>x>>y;\n    x+=C;\n    y+=C;\n    que.push(P(y,x));\n    dist[y][x]=0;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i,6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(0<=nx && 0<=ny && dist[ny][nx] == INF && point.find(P(ny,nx)) == point.end()) {\n                dist[ny][nx] = dist[y][x]+1;\n                que.push(P(ny,nx));\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,102) rep(j,102) if(dist[i][j]<=t) ans++;\n    cout<<ans<<endl;\n\n    point.clear();\n    \n\n}\n\nint main() {\n    while(cin>>t>>n) {\n        if(t+n==0) return 0;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <utility>\n#include <typeinfo>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nvoid reach(int a[][61],int b)//b回目のリーチで行ける場所をb+1に塗りつぶす\n{\n\tint x[6]={-1,-1,0,1,0,1};\n\tint y[6]={1,0,-1,0,1,-1};\n\t\n\tfor(int i=0;i<61;i++)\n\t{\n\t\tfor(int j=0;j<61;j++)\n\t\t{\n\t\t\tif(a[i][j]==b)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<6;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i+x[k]>-1 && i+x[k]<61 && j+y[k]>-1 && j+y[k]<61)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i+x[k]][j+y[k]]==0)a[i+x[k]][j+y[k]]=b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\tint t,n;\n\twhile(cin>>t>>n&&!(n==0&&t==0))\n\t{\n\t\tint a[61][61]={};//座標は0~60\n\t\tREP(i,n){int x,y;cin>>x>>y;a[x+30][y+30]=-1;} //a[x][y]=-1なら障害物あり\n\t\tint x,y;cin>>x>>y;a[x+30][y+30]=1;//便宜所スタート地点は1にする。nターン目に行ける場所をn+1で塗りつぶす\n\t\tREP(i,t) reach(a,i+1);\n\t\tint ans(0);\n\t\tREP(i,61)REP(j,61)if(a[i][j]!=0&&a[i][j]!=-1)ans++;\n\t\t//REP(i,61){REP(j,61){cout << a[j][i]<<\" \";}cout<<endl;}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\tdo{i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}while(i<n-1)\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,a,n) for(int i=a;i<n;i++)\nint dy[]={1,1,0,0,-1,-1};\nint dx[]={1,0,1,-1,0,-1};\nint a[200][200];\nint main(){\n\tint n,t,b[300][2],x,y;\n\twhile(cin>>t>>n,t){\n\t\tr(i,0,200)r(j,0,200)a[i][j]=-1;\n\t\tr(i,0,n){\n\t\t\tcin>>x>>y;\n\t\t\ta[y+100][x+100]=0;\n\t\t}\n\t\tcin>>x>>y;\n\t\tint s=0;\n\t\tqueue<int>q1,q2;\n\t\tq1.push(x+100);\n\t\tq2.push(y+100);\n\t\ta[y+100][x+100]=1;\n\t\twhile(!q1.empty()){\n\t\t\tint x2=q1.front();q1.pop();\n\t\t\tint y2=q2.front();q2.pop();\n\t\t\tif(y2-100==t+1||y2+100==t+1)break;\n\t\t\tif(x2-100==t+1||x2+100==t+1)break;\n\t\t\ts++;\n\t\t\ta[y2][x2]=1;\n\t\t\tr(i,0,6){\n\t\t\t\tint x3=x2+dx[i];\n\t\t\t\tint y3=y2+dy[i];\n\t\t\t\tif(a[y3][x3]!=-1)continue;\n\t\t\t\tq1.push(x3);\n\t\t\t\tq2.push(y3);\n\t\t\t}\n\t\t}\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\nusing namespace std;\n\nint d[100][100];\nint xx[6] = {1,1,-1,-1,0,0};\nint yy[6] = {1,0,-1,0,1,-1};\n\n\nint main(){\n\n  int t, n;\n  while(cin >> t >> n && (t||n)){\n    memset(d,0,sizeof(d));\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      d[y+50][x+50] = 1;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    d[y+50][x+50] = 1;\n    int cnt = 1;\n\n    queue<pair<int, pair<int, int> > > q;\n    q.push(make_pair(t, make_pair(x+50, y+50)));\n    int ttc = 0;\n\n    while(!q.empty()){\n      pair<int, pair<int, int> > cq = q.front();\n      q.pop();\n      if(cq.first == 0) continue;\n      int tc = cq.first;\n     for(int i = 0; i < 6; i++){\n       int nx = xx[i] + cq.second.first, ny = yy[i] + cq.second.second;\n       if(d[ny][nx] != 1){\n         d[ny][nx] = 1;\n         cnt++;\n         q.push(make_pair(tc-1,make_pair(nx,ny)));\n       }\n     }\n     ttc++;\n    }\n\n    cout << cnt << endl;\n\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tP p_(x,y);\n\t\tint cnt = f[p_] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << f[p_] << endl;\n\t\tif( cnt > t )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p] == -2 ) continue;\n\t\t\t\n\t\t\tif( f[p] == -1 ){\n\t\t\t\tf[p] = cnt;\n\t\t\t\tque.push( p );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\tf.clear();\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -2;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 0;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tsolve( t , f , que );\n\t\tint ans = 0;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] >= 0 ) ans++;\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\nclass Integer {\n\tint value;\npublic:\n\tInteger() : value(0) {}\n\tInteger(int x) : value(x) {}\n\toperator int() const {return value;}\n};\nconst int dx[] = {1, 0, -1, -1, 0, 1};\nconst int dy[] = {0, -1, -1, 0, 1, 1};\n\nint main () {\n\tint t, n;\n\twhile (cin >> t >> n, t || n) {\n\t\tmap<int, map<int, Integer> > blocks;\n\t\tmap<int, map<int, Integer> > visited;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tblocks[x][y] = 1;\n\t\t}\n\t\tint count = 0;\n\t\tqueue<pair<int, pair<int, int> > > que;\n\t\tpair<int, int> pos;\n\t\tcin >> pos.first >> pos.second;\n\t\tque.push(make_pair(0, pos));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, pair<int, int> > current = que.front();\n\t\t\tconst int s = current.first;\n\t\t\tconst int x = current.second.first;\n\t\t\tconst int y = current.second.second;\n\t\t\tque.pop();\n\t\t\tif (visited[x][y]) continue;\n\t\t\tvisited[x][y] = 1;\n\t\t\tcount++;\n\t\t\tif (s == t) continue;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tconst int nx = x + dx[i];\n\t\t\t\tconst int ny = y + dy[i];\n\t\t\t\tif (abs(nx) <= 30 && abs(ny) <= 30 && !blocks[nx][ny]) {\n\t\t\t\t\tque.push(make_pair(s + 1, make_pair(nx, ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\nint mtx[67][67]={0};\n\nint main(){\n    int t,n,x,y;\n    while(1){\n        queue< pair<int,pair<int,int> > > que;\n        fill(mtx[0],mtx[66],0);\n        scanf(\"%d %d\",&t,&n);\n        if(!t && !n){break;}\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&x,&y);\n            mtx[x+33][y+33]=-1;\n        }\n        scanf(\"%d %d\",&x,&y);\n        mtx[x+33][y+33]=1;\n        que.push(make_pair(0,make_pair(x+33,y+33)));\n        int cnt=0;\n        while(!que.empty()){\n            pair< int,pair<int,int> > p=que.front();\n            que.pop();\n            if(p.first>t){break;}\n            for(int j=0;j<6;j++){\n                int tx=p.second.first+dx[j];\n                int ty=p.second.second+dy[j];\n                int tu=p.first+1;\n                if(mtx[tx][ty]==0){\n                    mtx[tx][ty]=1;\n                    que.push(make_pair(tu,make_pair(tx,ty)));\n                }\n            }\n            cnt++;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n\nusing namespace std;\n   \n#define INF 1000000\n#define WALL -1\n\nstruct S{\n\tint x,y,t;\n};\n\nint main(void){\n      \n    int fi[122][122]; ///-60~60 -> 1~121 //\n\tint t,n;\n\tint x,y;\n\tint dy[]={ 1, 1, 0,-1,-1, 0};\n\tint dx[]={ 0, 1, 1, 0,-1,-1};\n\tint cnt;\n\tstack<S> s;\n\tS s1,s2;\n\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(int i=0;i<122;i++){\n\t\t\tfor(int j=0;j<122;j++){\n\t\t\t\tfi[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tfi[y+61][x+61]=WALL;\n\t\t}\n\t\tcin>>x>>y;\n\t\ts1.x=x+61,s1.y=y+61,s1.t=0;\n\t\tfi[y+61][x+61]=0;\n\t\tcnt=1;\n\t\ts.push(s1);\n\t\twhile(!s.empty()){\n\t\t\ts1=s.top();\n\t\t\ts.pop();\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tif(fi[s1.y][s1.x]+1<fi[s1.y+dy[i]][s1.x+dx[i]]){\n\t\t\t\t\tif(fi[s1.y+dy[i]][s1.x+dx[i]]==INF) cnt++;\n\t\t\t\t\tfi[s1.y+dy[i]][s1.x+dx[i]]=fi[s1.y][s1.x]+1;\n\t\t\t\t\ts2.x=s1.x+dx[i],s2.y=s1.y+dy[i],s2.t=fi[s1.y][s1.x]+1;\n\t\t\t\t\tif(s2.t!=t) s.push(s2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> point;\n\n// up right down left\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nconst double EPS = 1e-9;\nconst int days[]     = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nconst int ddx[] = {0,-1,-1,0,1,1};\nconst int ddy[] = {1,0,-1,-1,0,1};\n\ntypedef pair<pair<int,int>,int>  qp;\n\nint &qy(qp &q){\n    return q.first.first;\n}\nint &qx(qp &q){\n    return q.first.second;\n}\nint &qd(qp &q){\n    return q.second;\n}\n\nqp make_qp(int y,int x,int depth){\n    return mp(mp(y,x),depth);\n}\n\nint main(){\n    while(true){\n        const int width = 100;\n        const int height = 100;\n        const char got = 'o',emp = '.',obj = 'x';\n        vector<vector<char> > F(height,vector<char>(width,emp));\n        int t,n;\n        cin >> t >> n;\n        if(t==0) break;\n        rep(i,n){\n            int x,y;\n            cin >> x >> y;\n            x+=width/2;y+=height/2;\n            F[y][x] = obj;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=width/2;sy+=height/2;\n\n        queue<qp> Q;\n        F[sy][sx] = got;\n        Q.push(make_qp(sy,sx,0));\n\n        while(!Q.empty()){\n            qp q = Q.front();\n            Q.pop();\n            if(qd(q) == t) continue;\n            rep(i,6){\n                int ny = qy(q) + ddy[i];\n                int nx = qx(q) + ddx[i];\n                if(F[ny][nx] == emp){\n                    F[ny][nx] = got;\n                    Q.push(make_qp(ny,nx,qd(q)+1));\n                }\n            }\n        }\n        int cnt = 0;\n        rep(i,height) rep(j,width){\n            if(F[i][j] == got){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[200][200];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\tVi vans;\n\twhile (cin >> t >> n) {\n\t\tif (!t && !n) break;\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 100, b += 100;\n\t\t\tg[b][a] = 3;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 100, b += 100;\n\t\tg[b][a]++;\n\t\tint ans = 1;\n\t\tset<Pii> s;\n\n\t\trep(k, 0, t) {\n\t\t\ts.clear();\n\t\t\trep(x, 1, 199) rep(y, 1, 199) {\n\t\t\t\tif (g[y][x] == 1) {\n\t\t\t\t\tg[y][x]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[ny][nx] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tvans.pb(ans);\n\t}\n\tfor (auto a: vans) cout << a << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\nusing namespace std;\nint mod = 1000000007;\n\nint ans = 0;\nint T;\n\nint dx[] = {0, -1, 0, 1, 1, -1};\nint dy[] = {1, 0, -1, 0, 1, -1};\n\nint grid[150][150];\nbool visited[150][150];\n\nvoid init(){\n    ans = 0;\n    rep(i, 150) rep(j, 150){grid[i][j] = 0; visited[i][j] = false;}\n}\n\nint main(void){\n    int N;\n    vector<int> oput;\n    while(true){\n        init();\n        cin >> T >> N;\n        if(N == 0 && T == 0) break;\n        rep(i, N){\n            int x, y; cin >> x >> y;\n            x += 70; y += 70;\n            grid[x][y] = -1;\n        }\n        int st_x, st_y; cin >> st_x >> st_y;\n        st_x += 70; st_y += 70;\n        queue<pair<int, pair<int, int>>> que;\n        que.push(make_pair(0, make_pair(st_x, st_y)));\n        while(!que.empty()){\n            pair<int, pair<int, int>> op = que.front();\n            que.pop();\n            int t = op.first;\n            int sx = op.second.first;\n            int sy = op.second.second;\n            if(visited[sx][sy]) continue;\n            visited[sx][sy] = true;\n            ans++;\n            if(t == T) continue;\n            rep(i, 6){\n                int nx = sx + dx[i];\n                int ny = sy + dy[i];\n                if(grid[nx][ny] == 0 && !visited[nx][ny]) que.push(make_pair(t+1, make_pair(nx, ny)));\n            }\n        }\n        /*for(int i = 25; i < 40; i++){\n            for(int j = 25; j < 40; j++){\n                cout << visited[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n        oput.push_back(ans);\n    }\n    rep(i, oput.size()) cout << oput[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing P = pair<int, int>;\n\nconst int T = 60;\nconst int INF = 1e9;\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n  int t, n;\n  while (cin >> t >> n, t) {\n    vector<vector<int>> g(2 * T + 1, vector<int>(2 * T + 1, INF));\n    REP(i, n) {\n      int x, y;\n      cin >> x >> y;\n      g[T + x][T + y] = -1;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    int ans = 0;\n    queue<P> q({{T + sx, T + sy}});\n    g[T + sx][T + sy] = 0;\n    while (!q.empty()) {\n      int x = q.front().first;\n      int y = q.front().second;\n      q.pop();\n      if (g[x][y] > t) continue;\n      ans++;\n      REP(i, 6) {\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if (g[tx][ty] == -1) continue;\n        if (g[tx][ty] <= g[x][y] + 1) continue;\n        g[tx][ty] = g[x][y] + 1;\n        q.push({tx, ty});\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) <= t) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) <= t) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef struct{\n\tint x;\n\tint y;\n}POS;\nqueue <POS> q;\nPOS start,flag;\nint map[129][129];//64?????????0??¨??????\nint x,y,t,n,count,turn;\n\nvoid check(){\n\tPOS pos,next;\n\tflag.x=flag.y=200;\n\tq.push(start);\n\tq.push(flag);\n\twhile(1){\n\t\tif(turn==t+1)return;\n\t\tpos=q.front();\n\t\tq.pop();\n\n\t\tif(pos.x==200){\n\t\t\tturn++;\n\t\t\tq.push(flag);\n\t\t}else{\n\t\t\tcount++;\n\t\t\tif(pos.x>0&&pos.y>0&&map[pos.x-1][pos.y-1]==0){\n\t\t\t\tnext.x=pos.x-1;\n\t\t\t\tnext.y=pos.y-1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x<128&&pos.y<128&&map[pos.x+1][pos.y+1]==0){\n\t\t\t\tnext.x=pos.x+1;\n\t\t\t\tnext.y=pos.y+1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x>0&&map[pos.x-1][pos.y]==0){\n\t\t\t\tnext.x=pos.x-1;\n\t\t\t\tnext.y=pos.y;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.y>0&&map[pos.x][pos.y-1]==0){\n\t\t\t\tnext.x=pos.x;\n\t\t\t\tnext.y=pos.y-1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.x<128&&map[pos.x+1][pos.y]==0){\n\t\t\t\tnext.x=pos.x+1;\n\t\t\t\tnext.y=pos.y;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t\tif(pos.y<128&&map[pos.x][pos.y+1]==0){\n\t\t\t\tnext.x=pos.x;\n\t\t\t\tnext.y=pos.y+1;\n\t\t\t\tmap[next.x][next.y]=1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >>t >>n;\n\t\tif(!(t||n))break;\n\t\tfor(int i=0;i<129;i++){\n\t\t\tfor(int j=0;j<129;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[x+64][y+64]=1;\n\t\t}\n\t\tcin >>start.x>>start.y;\n\t\tstart.x+=64;\n\t\tstart.y+=64;\n\t\tturn=0;\n\t\tcount=0;\n\t\tmap[start.x][start.y]=1;\n\t\tcheck();\n\t\tcout <<count <<endl;\n\t\twhile(!q.empty())q.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\nstruct Node\n{\n\tint x, y, turn;\n};\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::vector<int> results;\n\t\tstd::array<std::array<int, 61>, 61> field;\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tfield = { {0} };\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 30][x + 30] = 1;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 30][startX + 30] = 1;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tq.push(Node{ startX+30, startY+30, 0 });\n\t\t\tint dx[] = {1, 0, -1, -1, 0, 1};\n\t\t\tint dy[] = {0, -1, -1, 0, 1, 1};\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i]; next.turn++;\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 60 || next.y < 0 || next.y > 60) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = 2;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (now.turn >= t - 1) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.push_back(discoverdCount);\n\t\t\t\n\t\t}\n\n\t\tfor (auto& x : results) {\n\t\t\tstd::cout << x << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nconst int kOffset = 100;\n\nint main(void){\n    for(int n, t, res; cin >> t >> n, t; cout << res << endl){\n        res = 0;\n\n        vvi used, hasTrap;\n        used = hasTrap = vvi(2 * kOffset, vi(2 * kOffset));\n\n        rep(i, n){\n            int x, y; cin >> x >> y;\n            x += kOffset; y += kOffset;\n\n            hasTrap[y][x] = true;\n        }\n\n        pii s; cin >> s.X >> s.Y;\n        s.X += kOffset; s.Y += kOffset;\n\n        queue< pair<pii, int> > q;\n        q.push(mp(s, 0));\n\n        while(!q.empty()){\n            pii cur_pos = q.front().first;\n            int cur_turn = q.front().second;\n            q.pop();\n\n            if(used[cur_pos.Y][cur_pos.X] || hasTrap[cur_pos.Y][cur_pos.X] || t < cur_turn) continue;\n\n            used[cur_pos.Y][cur_pos.X] = true;\n            res++;\n\n            rep(i, 6){\n                pair<pii, int> next(mp(cur_pos.X + dx[i], cur_pos.Y + dy[i]), cur_turn + 1);\n                q.push(next);\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#define ini 100\nusing namespace std ;\n\ntypedef pair<int,int> P ;\n\nqueue<P> q ;\nint dx[] = {0,1,1,0,-1,-1} ;\nint dy[] = {1,1,0,-1,-1,0} ;\n\nint main(){\n\t\n\tint t , n ;\n\tint x , y ;\n\tint ans ;\n\tint field[200][200] ;\n\t/*\n\t1:コスト(1インデックス)\n\t0:空き地\n\t-1:障害物\n\t*/\n\t\n\twhile( cin >> t >> n , t ){\n\t\t\n\t\t\n\t\tfor( int i=0 ; i<200 ; i++ ){\n\t\t\tfor( int j=0 ; j<200 ; j++ ){\n\t\t\t\tfield[i][j] = 0 ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 1 ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> x >> y ;\n\t\t\tfield[y+ini][x+ini]  = -1 ;\n\t\t}\n\t\t\n\t\tcin >> x >> y ;\n\t\t\n\t\tq.push( P(x+ini,y+ini) ) ;\n\t\tfield[y+ini][x+ini] = 1 ;\n\t\t\n\t\tint j=0 , k=0 ;\n\t\twhile( !q.empty() ){\n\t\t\tx = q.front().first ;\n\t\t\ty = q.front().second ;\n\t\t\t//cout << \"OK\" << endl ;//--------------------\n\t\t\tif( field[y][x] > t+1 ) break ;\n\t\t\tfor( int i=0 ; i<6 && field[y][x] <= t ; i++ ){\n\t\t\t\tif( field[y+dy[i]][x+dx[i]] == 0 ){\n\t\t\t\t\tfield[y+dy[i]][x+dx[i]] = field[y][x]+1 ;\n\t\t\t\t\tq.push( P(x+dx[i],y+dy[i]) ) ;\n\t\t\t\t\t//cout<<\"# \"<<x-ini<<\" \"<<y-ini<<endl;\n\t\t\t\t\tans++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop() ;\n\t\t}\n\t\t\n\t\tcout << ans << endl ;\n\t\t\n\t\twhile( !q.empty()  ){\n\t\t\tq.pop() ;\n\t\t}\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\n\n// s[y][x] := ツ鳴「ツ探ツ催オツづ個づ?つォINF, ツ探ツ催オツ催渉づ敖づ個づ?つォツタツーツδ督青板つェツ禿シツづゥ\nint s[100][100];\n// b[P(x,y)] := ツ津環づェツづ按つ「ツづ?つォtrue\nint b[100][100];\n\nint bfs(int sx , int sy , int t ){\n\ts[sy][sx] = 0;\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tint cnt = s[y][x];\n\t\tq.pop();\n\t\t\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx > 60 || my > 60 ) continue;\n\t\t\tif( b[my][mx] ) continue;\n\t\t\t \n\t\t\tif( cnt + 1 <= t && s[my][mx] == INF ){\n\t\t\t\ts[my][mx] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint result = 0;\n\tfor(int y=0 ; y <= 60 ; y++ ){\n\t\tfor(int x = 0 ; x <= 60 ; x++ ){\n\t\t\tif( s[y][x] != INF ){\n\t\t\t\tresult++;\n\t\t\t} \n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\t\n\t\tfor(int y = 0 ; y < 100 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 100 ; x++ ){\n\t\t\t\ts[y][x] = INF;\n\t\t\t\tb[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 30;\n\t\t\ty += 30;\n\t\t\tb[y][x] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = bfs( sx+30 , sy+30 , t );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define MAX 30\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n\tint t, n, x, y;\n\tint cost[MAX * 4 + 1][MAX * 4 + 1];\n\tbool visited[MAX * 4 + 1][MAX * 4 + 1];\n\tqueue<pair<int, pair<int, int>>> q;\n\twhile (cin >> t >> n, t) {\n\t\tfill(cost[0], cost[MAX * 4 + 1], -1);\n\t\tfill(visited[0], visited[MAX * 4 + 1], false);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tx += MAX * 2; y += MAX * 2;\n\t\t\tcost[y][x] = MAX;\n\t\t}\n\t\tcin >> x >> y;\n\t\tx += MAX * 2; y += MAX * 2;\n\t\tint c = 0;\n\t\tq.push(make_pair(t, make_pair(x, y)));\n\t\twhile (!q.empty()) {\n\t\t\tauto e = q.front();\n\t\t\tq.pop();\n\t\t\tt = e.first; x = e.second.first; y = e.second.second;\n\t\t\tif (!visited[y][x]) {\n\t\t\t\tvisited[y][x] = true;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tcost[y][x] = max(cost[y][x], t);\n\t\t\tif (t > 0) {\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (t > cost[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\t\tq.push(make_pair(t - 1, make_pair(x + dx[i], y + dy[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first;\n#define se second;\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dy[6] = {1, 1, 0, 0, -1, -1};\nint dx[6] = {1, 0, 1, -1, 0, -1};\nconst int INF = 1e9;\n\nsigned main(){\n    int t, n;\n    int sx, sy;\n    while(1){\n        cin >> t >> n;\n        if(t == 0 &&  n == 0) break;\n        set<P> st;\n        rep(i, 0, n){\n            int x, y;\n            cin >> x >> y;\n            st.insert(P(100 + y, 100 + x));\n        }\n        cin >> sx >> sy;\n        int d[200][200] = {};\n        rep(i, 0, 200) rep(j, 0, 200) d[i][j] = INF;\n        queue<P> q;\n        q.push(P(100 + sy, 100 + sx));\n        d[100 + sy][100 + sx] = 0;\n        while(!q.empty()){\n            P p = q.front(); q.pop();\n            int y = p.fi;\n            int x = p.se;\n            rep(i, 0, 6){\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if(st.count(P(ny, nx))) continue;\n                if(d[ny][nx] != INF) continue;\n                d[ny][nx] = d[y][x] + 1;\n                if(d[ny][nx] > t) continue;\n                q.push(P(ny, nx));\n            }\n        }\n        int ans = 0;\n        rep(i, 0, 200){\n            rep(j, 0, 200){\n                if(d[i][j] <= t) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<10\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int dx[] = { 0, 1, 1, 0,-1,-1 };\nconst int dy[] = { 1, 1, 0,-1,-1, 0 };\nconst int basex = 100;\nconst int basey = 100;\nconst int MAX_N = 200;\n\nint vis[MAX_N][MAX_N];\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tint t, n;\n\twhile (cin >> t >> n, t ){\n\t\tmemset (vis, -1, sizeof (vis ) );\n\t\trep (i, n ){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tx += basex, y += basey;\n\t\t\tvis[y][x] = 0;\n\t\t} // end rep\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += basex, sy += basey;\n\t\tqueue<P> que;\n\t\tque.push (P (sy, sx ) );\n\t\tvis[sy][sx] = 0;\n\t\tint res = 1;\n\n\t\twhile (!que.empty() ){\n\t\t\tP cur = que.front(); que.pop();\n\t\t\tint cy = cur.first;\n\t\t\tint cx = cur.second;\n\t\t\tint ct = vis[cy][cx];\n\t\t\tif (ct == t ) continue;\n\n\t\t\trep (k, 6 ){\n\t\t\t\tint ny = cy + dy[k];\n\t\t\t\tint nx = cx + dx[k];\n\t\t\t\tif (vis[ny][nx] == -1 ){\n\t\t\t\t\tvis[ny][nx] = ct + 1;\n\t\t\t\t\tque.push (P (ny, nx ) );\n\t\t\t\t\tres++;\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end while\n\t\tcout << res << endl;\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nstruct po{\n  int x,y,t;\n};\n\nint main(){\n  int tu,n;\n  while(1){\n    cin>>tu>>n;\n    if(tu==0 && n==0) break;\n    queue<po> Q;\n    set< pair<int,int> > co;\n      for(int i=0;i<n;i++){\n\tint nx,ny;\n\tcin>>nx>>ny;\n\tco.insert(make_pair(nx,ny));\n      }\n    int sx,sy;\n    cin >>sx>>sy;\n    Q.push((po){sx,sy,0});\n    co.insert(make_pair(sx,sy));\n    int dx[6]={1,0,-1,-1,0,1},dy[6]={0,-1,-1,0,1,1};\n    while(Q.empty()==false){\n      po u = Q.front();\n      Q.pop();\n      if(u.t<tu){\n\tfor(int i=0;i<6;i++){\n\t  int nx=u.x+dx[i];\n\t  int ny=u.y+dy[i];\n\t  if(co.count(make_pair(nx,ny))==0){\n\t    co.insert(make_pair(nx,ny));\n\t    Q.push((po){nx,ny,u.t+1});\n\t  }\n\t}\n      }\n    }\n    cout<<co.size()-n<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAXX 60\n#define MAXY 60\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\n\nint solve(int x,int y,int depth){\n\tint cnt=0;\n\tqueue<pair<int,pair<int,int> > > q;\n\tq.push(pair<int,pair<int,int> >(x,pair<int,int>(y,depth)));\n\twhile(!q.empty()){\n\t\tint cx,cy,cd;\n\t\tpair<int,pair<int,int> > frt = q.front();\n\t\tq.pop();\n\t\tcx=frt.first;\n\t\tcy=frt.second.first;\n\t\tcd=frt.second.second;\n\t\tif(!flg[cx][cy]) cnt++;\n\t\tflg[cx][cy]=true;\n\t\tif(cd>0){\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nnx = (cx+xd[i])%MAXX;\n\t\t\t\tint nny = (cy+yd[i])%MAXY;\n\t\t\t\tint nnd = cd-1;\n\t\t\t\tif(mp[nnx][nny] && !flg[nnx][nny])\n\t\t\t\t\tq.push(pair<int,pair<int,int> >(nnx,pair<int,int>(nny,nnd)));\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define ADD 100\n\nint map[200][200];\nint dx[]={0,1,-1,1,-1,0};\nint dy[]={1,1,0,0,-1,-1};\nvoid check(int x,int y,int t)\n{\n  if(map[x][y]==-1)\n    return;\n  map[x][y]=1;\n  if(t<=0)\n    return;\n  for(int i=0;i<6;i++)\n    check(x+dx[i],y+dy[i],t-1);\n}\n\nint main()\n{\n  int t,n;\n  for(;cin>>t>>n,t;)\n    {\n      memset(map,0,sizeof(map));\n      for(int i=0;i<n;i++)\n\t{\n\t  int x,y;\n\t  cin>>x>>y;\n\t  map[x+ADD][y+ADD]=-1;\n\t}\n      int x,y;\n      cin>>x>>y;\n      queue<pair<pair<int,int>,int> >qu;\n      qu.push(make_pair(make_pair(x+ADD,y+ADD),t));\n      while(!qu.empty())\n\t{\n\t  pair<int,int>pos=qu.front().first;\n\t  int tt=qu.front().second;\n\t  qu.pop();\n\t  if(map[pos.first][pos.second]!=0)\n\t    continue;\n\t  map[pos.first][pos.second]=1;\n\t  if(tt<=0)\n\t    continue;\n\t  for(int i=0;i<6;i++)\n\t    {\n\t      //  if(map[pos.first+dx[i]][pos.second+dy[i]]==0)\n\t\tcheck(pos.first+dx[i],pos.second+dy[i],tt-1);\n\t    }\n\t}\n      int ans=0;\n      for(int i=0;i<200;i++)\n\tfor(int j=0;j<200;j++)\n\t  if(map[i][j]==1)\n\t    {\n\t      ans++;\n\t    }\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x_;\n    int y_;\n    int t_;\n\n    State(int x, int y, int t) {\n        x_ = x;\n        y_ = y;\n        t_ = t;\n    }\n};\n\nint main (int argc, char *argv[]) {\n    int n, t;\n    int dx[6] = {1, 1, 0, -1, -1, 0};\n    int dy[6] = {0, 1, 1, 0, -1, -1};\n    while (cin>>t>>n, t||n) {\n        int sx, sy;\n        bool ob[61][61] = {false};\n        bool visited[61][61] = {false};\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            cin>>x>>y;\n            ob[x+30][y+30] = true;\n        }\n        cin>>sx>>sy;\n        queue<State> que;\n        que.push(State(sx, sy, 0));\n        visited[sx+30][sy+30] = true;\n        while (!que.empty()) {\n            State s = que.front();\n            que.pop();\n            for (int i = 0; i < 6; ++i) {\n                int nx = s.x_ + dx[i];\n                int ny = s.y_ + dy[i];\n                if (-30 <= nx && nx <= 30 && -30 <= ny && ny <= 30 \n                && !visited[nx+30][ny+30] && !ob[nx+30][ny+30] && s.t_ < t) {\n                    que.push(State(nx, ny, s.t_ + 1));\n                    // printf(\"(%d, %d)\\n\", nx, ny);\n                    visited[nx+30][ny+30] = true;\n                    ans++;\n                }\n            }\n        }\n        cout<<ans + 1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#define MAXX 60\n#define MAXY 60\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\nint ccc;\n\n\n//深さ優先の再帰関数\nvoid solve2(int x,int y,int depth){\n\t//深さ0で終了\n\tif(depth==0) return;\n\t//x,y点周辺を探索済みにする\n\tfor(int i=0;i<6;i++){\n\t\tif(!flg[(x+xd[i])%MAXX][(y+yd[i])%MAXY] && mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY] ){\n\t\t\tccc++;\n\t\t}\n\t\tflg[(x+xd[i])%MAXX][(y+yd[i])%MAXY]=true;\n\t}\n\t//x,y点周辺でかつ，障害物のない点を探索する\n\tfor(int i=0;i<6;i++)\n\t\tif(mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY])\n\t\t\tsolve2((x+xd[i])%MAXX,(y+yd[i])%MAXY,depth-1);\n}\n\n//再帰関数を呼び出し，数え上げるための関数\nint solve(int x,int y,int depth){\n\tccc=1;\n\t//始点を探索済みにする\n\tflg[x][y]=true;\n\t//始点より深さ優先\n\tsolve2(x,y,depth);\n\t//解を出力\n\treturn ccc;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\n\nint t,n;\nint fie[70][70];\nbool used[70][70];\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\nint sx,sy;\nclass data{\npublic:\n\tint x,y,t;\n\tdata(){}\n\tdata(int ix,int iy,int it){\n\t\tx=ix;\n\t\ty=iy;\n\t\tt=it;\n\t}\n};\n\nint bfs(){\n\tstd::queue<data> que;\n\tmemset(used,false,sizeof(used));\n\tque.push(data(sx,sy,0));\n\tused[sx][sy]=true;\n\tint res=1;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tif(d.t==t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\t\tint nx=d.x+dx[i],ny=d.y+dy[i];\n\t\t\tif(nx<0 || nx>=70 || ny<0 || ny>=70)continue;\n\t\t\tif(!used[nx][ny] && fie[nx][ny]==0){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tres++;\n\t\t\t\tque.push(data(nx,ny,d.t+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&t,&n);\n\t\tif(t+n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint bx,by;\n\t\t\tscanf(\"%d %d\",&bx,&by);\n\t\t\tbx+=35;\n\t\t\tby+=35;\n\t\t\tfie[bx][by]=-1;\n\t\t}\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx+=35,sy+=35;\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+30·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_OBS 301\n#define MAX_T 31\n#define MAX_COOR 62\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 30][obsy + 30] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 30;\n\t\tstarty += 30;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<\"ans = \" <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÄA)\n\t\t\t\tif(nowx <= 60 && nowx >= 0 && nowy <= 60 && nowy >= 0 && endcnt[nowx][nowy] == false){\n\t\t\t\t\t//cout <<\"x = \" <<nowx - 30 <<\" y = \" <<nowy - 30 <<endl;\n\t\t\t\t\t//if((nowx == 34 && nowy == 34) || nowx == 30 && nowy == 32){\n\t\t\t\t\t//\tcout <<endcnt[nowx][nowy] <<endl;\n\t\t\t\t\t//}\n\t\t\t\t\t\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\t//cout <<\"push_x = \" <<qunextx.back() <<\" push_y = \" <<qunexty.back() <<endl;\n\t\t\t\t\t//cout <<\"i = \" <<i <<\"ok\" <<endl;\n\t\t\t\t}\n\t\t\t\t//cout <<\"i = \" <<i <<\"ok!\" <<endl;\n\t\t\t}\n\t\t\t//cout <<\"i = \" <<i <<\"ok?\" <<endl;\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t\t//qunowx = qunextx;\n\t\t//qunowx = qunexty;\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int offset=100;\nbool table[210][210];\nbool visited[210][210];\n\nint dx[6]={1,1,0,-1,-1,0};\nint dy[6]={1,0,-1,-1,0,1};\n\nstruct state{\n\tint x,y,t;\n};\n\nint main(void){\n\tint t,n;\n\twhile(cin >> t >> n){\n\t\tif(t==0)\n\t\t\tbreak;\n\t\trep(i,210)rep(j,210)\n\t\t\ttable[i][j]=visited[i][j]=false;\n\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[x+offset][y+offset]=true;\n\t\t}\n\t\tstate s;\n\t\tcin >> s.x >> s.y;\n\t\ts.t=0;\n\t\tqueue<state> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tstate cur=q.front(); q.pop();\n\t\t\tif(visited[cur.x+offset][cur.y+offset])\n\t\t\t\tcontinue;\n\t\t\tvisited[cur.x+offset][cur.y+offset]=true;\n\t\t\tif(cur.t>=t)\n\t\t\t\tcontinue;\n\t\t\trep(i,6){\n\t\t\t\tstate next=cur;\n\t\t\t\tnext.x+=dx[i];\n\t\t\t\tnext.y+=dy[i];\n\t\t\t\tnext.t++;\n\t\t\t\tif(!table[next.x+offset][next.y+offset])\n\t\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,210)rep(j,210) ans+=visited[i][j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 70\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs(int,int);\nint dy[6]={-1,-1,0,1,1,0};\nint dx[6]={-1,0,1,1,0,-1};\nint t;\nint data[N][N];\nint main(){\n  int n,x,y,sx,sy;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0;\n    while(n--){\n      cin >> x >> y;\n      data[y+30][x+30]=-1;\n    }\n    cin >> sx >> sy;\n    data[sy+30][sx+30]=1;\n    bfs(sy+30,sx+30);\n    int cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(data[i][j]==1) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid bfs(int y,int x){\n  queue<P1> Q;\n  Q.push(P1(0,P(y,x)));\n  while(Q.empty()!=1){\n    P1 v=Q.front();\n    Q.pop();\n    int d=v.first,y1=v.second.first,x1=v.second.second;\n    for(int i=0;i<6;i++){\n      if(0<=y1+dy[i]&&y1+dy[i]<N&&0<=x1+dx[i]&&x1+dx[i]<N&&data[y1+dy[i]][x1+dx[i]]==0&&d<=t){\n\tdata[y1+dy[i]][x1+dx[i]]=1;\n\tif(d<=t-2) Q.push(P1(d+1,P(y1+dy[i],x1+dx[i])));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1) cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD=1000000007;\nconst int INF=INT_MAX/3-1;\nconst double EPS=1e-9;\nconst int dx4[]={1,0,-1,0};\nconst int dy4[]={0,1,0,-1};\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool isRange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n\n}\n\nint dx[6]={0,0,1,1,-1,-1};\nint dy[6]={1,-1,0,1,0,-1};\n\nint main(){\n    int n,t;\n    while(cin>>t>>n,t){\n        vvi ob(61,vi(61,0));\n        vvi iscan(61,vi(61,0));\n        int x,y;\n        REP(i,n) cin>>x>>y,ob[x+30][y+30]=1;\n        cin>>x>>y;\n        queue<tuple<int,int,int>> q;\n        q.push(make_tuple(x+30,y+30,0));\n        while(!q.empty()){\n            auto now=q.front();\n            q.pop();\n            int x=get<0>(now);\n            int y=get<1>(now);\n            int turn=get<2>(now);\n            iscan[x][y]=1;\n            if(turn>=t)\n                continue;\n            REP(i,6){\n             int nx=x+dx[i];\n             int ny=y+dy[i];\n             if(isRange(nx,ny))\n 　　　　if(!ob[nx][ny]&&!iscan[nx][ny])\n                q.push(make_tuple(nx,ny,turn+1));\n            }\n        }\n      int cnt=0;\n        REP(i,61)\n            REP(j,61)\n                if(iscan[i][j])\n                    cnt++;\n        cout<<cnt<<endl;\n\n\n    }\n\n\n}\n\n\n                   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n    int x;\n    int y;\n    int cnt;\n    P(int x, int y, int cnt){\n        this->x = x;\n        this->y = y;\n        this->cnt = cnt;\n    }\n};\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y, cnt = 0;\n        cin >> x >> y;\n        x += 50; y += 50;\n\n        int ans = 0;\n        queue< P > que;\n        que.push( P(x, y, 0) );\n\n        while(!que.empty()){\n            P q = que.front(); que.pop();\n            x = q.x; y = q.y; cnt = q.cnt;\n            if(cnt > t) break;\n            ans++;\n\n            used[y][x] = true;\n            for(int d = 0; d < 6; d++){\n                int nx = x + dx[d], ny = y + dy[d];\n                if(used[ny][nx] == true || g[ny][nx] == 1) continue;\n                used[ny][nx] = true;\n                que.push(P(nx, ny, cnt+1));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = { 1, 1, 0,-1,-1, 0};\nint dy[] = { 0, 1, 1, 0,-1,-1};\n\nint g[100][100];\nbool used[100][100];\n\nint t, n;\n\nint dfs(int x, int y, int turn){\n    if(used[y][x] || g[y][x] == 1 || turn > t ) return 0;\n    used[y][x] = true;\n\n    int res = 0;\n    for(int d = 0; d < 6; d++){\n        int nx = x + dx[d], ny = y + dy[d];\n        res += dfs(nx, ny, turn+1);\n    }\n    used[y][x] = false;\n    return res + 1;\n}\n\nint main(void){\n    while(cin >> t >> n, t | n){\n        for(int i = 0; i < 100; i++) for(int j = 0; j < 100; j++){g[i][j] = 0; used[i][j] = false;}\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y; x += 50; y += 50;\n            g[y][x] = 1;\n        }\n        int x, y;\n        cin >> x >> y;\n        x += 50; y += 50;\n        cout << dfs(x, y, 0) << endl;\n    }\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\nconst int WMAX = 80, HMAX = 80;\n#define MAP(y, x) field[y + 40][x + 40]\nlli t, n;\nint field[HMAX][WMAX];\n\nvoid dfs(int y, int x, int turn) {\n  int nor = y * y + x * x;\n  if (nor > 900 || turn <= 0 || MAP(y, x) >= turn) return;\n  MAP(y, x) = turn;\n  REP(i, 6) {\n    dfs(y + dy[i], x + dx[i], turn - 1);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n\n  while (cin >> t >> n and t) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = 0;\n    }\n    REP(i, n) {\n      int y, x;\n      cin >> x >> y;\n      MAP(y, x) = INF;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    dfs(sy, sx, t + 1);\n    int sum = 0;\n    FOR(y, -32, 32) FOR(x, -32, 32) {\n      if (MAP(y, x) > 0 and MAP(y, x) != INF) sum ++;\n    }\n    cout << sum << endl;\n/*    FOR(y, -10, 10) {\n      REP(i, 10 - y) cout << ' ';\n      FOR(x, -10, 10) {\n        if (MAP(y, x) == INF) cout << 'x';\n        else if (MAP(y, x) == 0)   cout << '.';\n        else if (y == sy and x == sx) cout << 'S';\n        else cout << 'o';\n        cout << ' ';\n      }\n      cout << endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\n\nint main()\n{\n    int t,n;\n    while(cin >> t >> n) {\n        if(t == 0 && n == 0) break;\n        \n\n        int GETA = 100;\n        bool used[200][200];\n        memset(used,0,sizeof(used));\n\n        rep(i,n) {\n            int x,y;\n            cin >> x >> y;\n            \n            used[y+GETA][x+GETA] = true;\n        }\n\n        queue<pair<pair<int,int>,int> > que;\n        int sx,sy;\n        cin >> sy >> sx;\n\n        sy += GETA;\n        sx += GETA;\n\n        que.push(mp(mp(sy,sx),0));\n\n        int ans = 1;\n        used[sy][sx] = true;\n\n        while(que.size()) {\n            int y = que.front().first.first;\n            int x = que.front().first.second;\n            int cnt = que.front().second;\n            que.pop();\n\n            if(cnt < t) {\n                rep(i,6) {\n                    int ny = y + dy[i];\n                    int nx = x + dx[i];\n\n                    if(!used[ny][nx]) {\n                        used[ny][nx] = true;\n                        ans++;\n                        \n                        que.push(mp(mp(ny,nx),cnt+1));\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 61\n#define CONT 30\n\nint T,N;\n\nvoid dfs(int x, int y, int turn, vector< vector<int> > &field)\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\tif(x < 0 || x > MAX || y < 0 || y > MAX){ return; } //範囲外\n\n\tif(turn > T){ return; } //ターン数オーバー\n\n\tif(field[x][y] < turn && field[x][y]){ return; } //到達修正\n\tif(field[x][y] == -1){ return; } //障害物\n\n\tfield[x][y] = turn;\n\t\n\trep(i,6){\n\t\tdfs(x+dx[i], y+dy[i], turn+1, field);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> T >> N )\n\t{\n\t\tif(T == 0 && N == 0){ break; }\n\n\t\tvector< vector<int> > field(MAX,vector<int>(MAX,0));\n\t\n\t\tint X,Y;\n\t\trep(nth,N)\n\t\t{\n\t\t\tcin >> X >> Y;\n\t\t\tfield[X+CONT][Y+CONT] = -1;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\n\t\tint ans = 0;\n\t\tdfs(sx+CONT,sy+CONT,0,field);\n\t\tfield[sx+CONT][sy+CONT] = 1;\n\n\t\trep(y,MAX){\n\t\t\trep(x,MAX){\n\t\t\t\tif(field[x][y] > 0){ ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// (ÀWð\\»·éÏÍSÄA}CiXð\\»·é½ßÉ+30·é)\n\n#include<iostream>\n#include<queue>\n#define MAX_OBS 301\n#define MAX_T 31\n#define MAX_COOR 62\nusing namespace std;\n\n//}bvÌBÅ«éR}Ìð¦éÖ\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]);\n\nint main(){\n\t\n\t//t = ^[, n = áQ¨Ì\n\tint t, n;\n\t\n\twhile(cin >>t >>n){\n\t\tif(t == 0 && n == 0) break;\n\t\t\n\t\t// obs[áQ¨ÌxÀW][áQ¨ÌyÀW] = áQ¨ÌÀW(true:áQ¨ è, false:áQ¨Èµ)\n\t\t//endcnt[] = JEgµIíÁ½R}ðL^(true:JEgÏ, false:Ü¾JEgµÄÈ¢) áQ¨Ì éR}Íß©çtrueÆ·é\n\t\tint startx, starty;\n\t\tbool endcnt[MAX_COOR][MAX_COOR] = {false};\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint obsx, obsy;\n\t\t\tcin >>obsx >>obsy;\n\t\t\tendcnt[obsx + 30][obsy + 30] = true;\n\t\t}\n\t\tcin >>startx >>starty;\n\t\tstartx += 30;\n\t\tstarty += 30;\n\t\tendcnt[startx][starty] = true;\n\t\t\n\t\tcout <<mapsearch(t, startx, starty, endcnt) <<endl;\n\t}\n\treturn 0;\n}\n\nint mapsearch(int t, int x, int y, bool endcnt[][MAX_COOR]){\n\t\n\t//cnt = }bvÌBÅ«éR}ÌðL¯·éÏ\n\tint cnt = 1;\n\t\n\t//movex[] = Ú®·éxÀWðì·ézñ, movey[] = Ú®·éyÀWðì·ézñ\n\tint movex[6] = {0, 1, 1, 0, -1, -1}, movey[6] = {1, 1, 0, -1, -1, 0};\n\t\n\t//qunextx = Ì[³Å²×éxÀW, qunexty = Ì[³Å²×éyÀW\n\t//qunowx = ¡Ì[³Å²×éxÀW, qunowy = ¡Ì[³Å²×éyÀW\n\tqueue<int> qunextx, qunexty, qunowx, qunowy;\n\t\n\t//X^[gn_ÌÀWðqunowÉL^\n\tqunowx.push(x);\n\tqunowy.push(y);\n\t\n\t//§ÀÌ^[ªéÜÅAÌ[³És¯éÀWðL^¨[³ðißé\n\tfor(int i = 0; i < t; i++){\n\t\t\n\t\t//L^µÄ¢éÀWªóÉÈéÜÅ\n\t\twhile(qunowx.empty() != 1){\n\t\t\t\n\t\t\t//×èÁÄ¢éR}ðSÄ²×é\n\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\n\t\t\t\t//nowx = ²×½¢xÀW, nowy = ²×½¢yÀW\n\t\t\t\tint nowx = qunowx.front() + movex[k], nowy = qunowy.front() + movey[k];\n\t\t\t\t\n\t\t\t\t//Ú®Å«é©Ç¤©(Å«éÈçÌ½ßÌì)\n\t\t\t\tif(nowx <= 60 && nowx >= 0 && nowy <= 60 && nowy >= 0 && endcnt[nowx][nowy] == false){\n\t\t\t\t\tqunextx.push(nowx);\n\t\t\t\t\tqunexty.push(nowy);\n\t\t\t\t\tendcnt[nowx][nowy] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqunowx.pop();\n\t\t\tqunowy.pop();\n\t\t}\n\t\t//qunowÉqunextðüêé\n\t\twhile(qunextx.empty() != 1){\n\t\t\tqunowx.push(qunextx.front());\n\t\t\tqunextx.pop();\n\t\t\tqunowy.push(qunexty.front());\n\t\t\tqunexty.pop();\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint m[200][200];\n\nint main() {\n\tint t,n;\n\twhile(cin>>t>>n,t){\n\t\tint i,j;\n\t\tfor(i=0;i<200;i++){\n\t\t\tfor(j=0;j<200;j++){\n\t\t\t\tm[i][j]=100100100;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=100;y+=100;\n\t\t\tm[y][x]=-1;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=100;sy+=100;\n\t\tpriority_queue<pair<int,pint> > q;\n\t\tq.push(mp(0,mp(sx,sy)));\n\t\tpair<int,pint> buf;\n\t\tint res=0;\n\t\twhile(!q.empty()){\n\t\t\tbuf=q.top();\n\t\t\tq.pop();\n\t\t\tif(m[buf.second.second][buf.second.first]<=buf.first)continue;\n\t\t\tif(buf.first>t)continue;\n//cout<<buf.second.first<<\" \"<<buf.second.first<<\" \"<<buf.first<<endl;\n\t\t\tm[buf.second.second][buf.second.first]=buf.first;\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first+1,buf.second.second)));\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first-1,buf.second.second)));\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first,buf.second.second+1)));\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first,buf.second.second-1)));\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first+1,buf.second.second+1)));\n\t\t\tq.push(mp(buf.first+1,mp(buf.second.first-1,buf.second.second-1)));\n\t\t}\n//for(i=90;i<110;i++){\n//for(j=90;j<110;j++){\n//cout<<j-100<<\" \"<<i-100<<\" \"<<m[i][j]<<endl;\n//}\n//}\n\t\tfor(i=0;i<200;i++){\n\t\t\tfor(j=0;j<200;j++){\n\t\t\t\tif(0<=m[i][j]&&m[i][j]<=t)res++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint dx[6] = { -1,-1,0,1,1,0 };\nint dy[6] = { 0,-1,-1,0,1,1 };\nstruct aa {\n\tint x;\n\tint y;\n\tint t;\n};\nint main() {\n\twhile (1) {\n\t\tint T, N; cin >> T >> N;\n\t\tif (!T)break;\n\t\tset<pair<int, int>>m;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tm.emplace(x, y);\n\t\t}\n\t\tint u,v; cin >> u >> v;\n\t\tqueue<aa>q;\n\t\tq.push(aa{ u,v,0 });\n\t\tm.emplace(u, v);\n\t\twhile (q.size()) {\n\t\t\taa atop(q.front());\n\t\t\tq.pop();\n\t\t\tif (atop.t == T)break;\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\tint nx = atop.x + dx[i];\n\t\t\t\t\tint ny = atop.y + dy[i];\n\t\t\t\t\tif (!m.count(make_pair(nx, ny))) {\n\t\t\t\t\t\tm.emplace(nx, ny);\n\t\t\t\t\t\tq.push(aa{ nx,ny,atop.t + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << m.size() - N << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nstruct pr{\n\tint nx,ny,cnt;\n};\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pr>q;\n\t\tpr p;\n\t\tp.nx=sx;p.ny=sy;p.cnt=t;\n\t\tq.push(p);\n\t\twhile(!q.empty()){\n\t\t\tpr pi=q.front();q.pop();\n\t\t\tint x=pi.nx;\n\t\t\tint y=pi.ny;\n\t\t\tint tt=pi.cnt;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tpr p2;p2.nx=x+dx[i];p2.ny=y+dy[i];p2.cnt=tt-1;\n\t\t\t\tq.push(p2);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint field[200][200];\nbool visited[200][200];\n\nint T, N, SX, SY;\n\nint ty[] = {1, 1, 0, -1, -1, 0};\nint tx[] = {1, 0, -1, -1, 0, 1};\n\nvoid init() {\n  fill(&field[0][0], &field[199][200], 0);\n  fill(&visited[0][0], &visited[199][200], false);\n}\nstruct P {\n  int x, y, c;\n  P(int x, int y, int c) : x(x), y(y), c(c) {}\n};\nint _solve(int x, int y, int depth) {\n  queue<P> Q;\n  \n  Q.push(P(x, y, 0));\n\n  while (!Q.empty()) {\n    P cur = Q.front();\n    Q.pop();\n    int cx = cur.x;\n    int cy = cur.y;\n    int d = cur.c;\n    if (visited[cy][cx] || field[cy][cx] == 1 || d > T) {\n      continue;\n    }\n    visited[cy][cx] = true;\n    for (int i = 0; i < 6; i++) {\n      int nx = cx + tx[i];\n      int ny = cy + ty[i];\n      Q.push(P(nx, ny, d + 1));\n    }\n  }\n}\n\nvoid solve() {\n  int res = _solve(SX + 100, SY + 100, 0);\n  int cnt = 0;\n  for (int i = 0; i < 200; i++) {\n    for (int j = 0; j < 200; j++) {\n      if (visited[i][j]) {\n        cnt++;\n      }\n    }\n  }\n  printf(\"%d\\n\", cnt);\n}\n\nvoid print_field() {\n\n}\n\n\nint main() {\n  while (true) {\n    scanf(\"%d %d \", &T, &N);\n    if (T == 0 && N == 0) {\n      return 0;\n    }\n    init();\n    \n    for (int i = 0; i < N; i++) {\n      int x, y;\n      scanf(\"%d %d \", &x, &y);\n      field[y + 100][x + 100] = 1;\n    }\n    scanf(\"%d %d \", &SX, &SY);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int CX = 60;\nconst int CY = 60;\nconst int MAX_X = CX * 2 + 1;\nconst int MAX_Y = CY * 2 + 1;\n\nconst int dxs[] = { 1, 1, 0, -1, -1,  0 };\nconst int dys[] = { 0, 1, 1,  0, -1, -1 };\n\nconst int INF = 1 << 29;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint dists[MAX_Y][MAX_X];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int tn, n;\n    cin >> tn >> n;\n    if (tn == 0) break;\n\n    for (int y = 0; y < MAX_Y; y++)\n      for (int x = 0; x < MAX_X; x++) dists[y][x] = INF;\n    \n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      dists[y + CY][x + CX] = -1;\n    }\n\n    int sx, sy;\n    cin >> sx >> sy;\n    sx += CX, sy += CY;\n\n    dists[sy][sx] = 0;\n\n    queue<pii> q;\n    q.push(pii(sx, sy));\n\n    int count = 1;\n    \n    while (! q.empty()) {\n      pii u = q.front(); q.pop();\n      int& ux = u.first;\n      int& uy = u.second;\n\n      int ud = dists[uy][ux];\n      if (ud >= tn) continue;\n\n      for (int di = 0; di < 6; di++) {\n\tint vx = ux + dxs[di], vy = uy + dys[di];\n\tif (dists[vy][vx] >= INF) {\n\t  dists[vy][vx] = ud + 1;\n\t  q.push(pii(vx, vy));\n\t  count++;\n\t}\n      }\n    }\n\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint dx[6] = {1, 0, -1, 0, 1, -1};\nint dy[6] = {0, 1, 0, -1, 1, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nconst int basex = 100;\nconst int basey = 100;\n\nint depth;\nint d[200][200];\ntypedef pair<int, int> P;\n\nint bfs(int x, int y){\n    int cnt = 1;\n    memset(d, -1, sizeof(d));\n    queue<P> que;\n    que.push(P(x,y));\n    d[x][y] = 0;\n\n    while(!que.empty()){\n        P p = que.front(); que.pop();\n        if(d[p.first][p.second]==depth) continue;\n        REP(i,6){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(d[nx][ny] != -1) continue;\n            cnt++;\n            que.push(P(nx,ny));\n            d[nx][ny] = d[p.first][p.second] + 1;\n        }\n    }\n   return cnt;\n}\n\nint main(){\n    int n;\n    while(cin >> depth >> n){\n        if(depth + n == 0) break;\n        int x, y;\n        REP(i,n){\n            cin >> x >> y;\n            d[x+basex][y+basey] = 0;\n        }\n        cin >> x >> y;\n        int res = bfs(x+basex,y+basey);\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {1,0,-1,-1,0,1};\nconst int dy[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      auto Q = q.front();q.pop();\n      d = v[Q.fi][Q.se];\n      if(d >= t) continue ;\n      rep(i,6){\n        ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n        if(value(nx,ny,61,61) && v[nx][ny] == inf){\n          q.push(mp(nx,ny));\n          ++cnt;\n          v[nx][ny] = d+1;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n+1){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {1,-1,0, 0,1,-1};\nint dy[] = {0, 0,1,-1,1,-1};\nint pos[200][200];\n\nint bfs(int x, int y, int t){\n  int res = 1;\n  queue<PII> q;\n  q.push(MP(x,y));\n  pos[y][x] = t;\n\n  bool visit[200][200];\n  fill((bool*)visit, (bool*)visit+200*200, false);\n  visit[y][x] = true;\n  \n  while(!q.empty()){\n\tPII pii = q.front(); q.pop();\n\tx = pii.first, y = pii.second;\n\tif(pos[y][x] <= 0) continue;\n\tREP(i,6){\n\t  int tx = pii.first + dx[i], ty = pii.second + dy[i];\n\t  if(visit[ty][tx] || pos[ty][tx] == -1) continue;\n\t  visit[ty][tx] = true;\n\t  ++res;\n\t  pos[ty][tx] = pos[y][x] - 1;\n\t  q.push(MP(tx,ty));\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int T, N;\n  while(cin >> T >> N, T){\n\tfill((int*)pos, (int*)pos+200*200, 0);\n\tREP(i,N){\n\t  int x, y; cin >> x >> y;\n\t  pos[y+100][x+100] = -1;\n\t}\n\tint sx, sy; cin >> sx >> sy;\n\tcout << bfs(sx+100,sy+100,T) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint t, n, sx, sy;\nint field[100][100];\n\nint dx[] = { 0, 1, 1, 0, -1, -1 };\nint dy[] = { 1, 1, 0, -1, -1, 0 };\n\nvoid solve(){\n\tfield[sy][sx] = 0;\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front();\n\t\tque.pop();\n\n\t\tREP(i, 6){\n\t\t\tint ny = p.first + dy[i], nx = p.second + dx[i];\n\t\t\tif (ny >= 20 && ny <= 80 && nx >= 20 && nx <= 80){\n\t\t\t\tif (field[p.first][p.second] >= 0 && field[p.first][p.second] < t){\n\t\t\t\t\tif (field[ny][nx] == INF){\n\t\t\t\t\t\tfield[ny][nx] = field[p.first][p.second] + 1;\n\t\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\twhile (cin >> t >> n&&t + n){\n\t\tint ans = 0;\n\t\tREP(i, 100)REP(j, 100)field[i][j] = INF;\n\t\tREP(i, n){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 50;\n\t\t\ty += 50;\n\t\t\tfield[y][x] = -1;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tsx += 50;\n\t\tsy += 50;\n\t\tsolve();\n\t\tREP(i, 100){\n\t\t\tREP(j, 100){\n\t\t\t\tif (field[i][j] >= 0 && field[i][j] <= t){\n\t\t\t\t\tans++;\n\t\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[61][61];\nint t,n;\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty() && q.front().first < t){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\tcout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n\tgrid[ny][nx]=-1;\n      }\n    }\n  }\nreturn res;\n}\n\nint main(){\n    while(cin>>t>>n){\n      if(t==0 && n==0)break;\n      memset(grid,0,sizeof(grid));\n      for(int i=0;i<n;i++){\n\tint x,y;\n\tcin>>x>>y;\n\tgrid[y+30][x+30]=-1;\n      }\n      int sx,sy;\n      cin>>sx>>sy;\n      grid[sy+30][sx+30]=-1;\n      cout <<  bfs(sx+30,sy+30) << endl;\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  while(1){\n    int t, N, i;\n    scanf(\"%d%d\", &t, &N);\n    if(t == 0 && N == 0){\n      return 0;\n    }\n    vector<vector<int>> B(161, vector<int>(161, -1));\n    int sx, sy;\n    int x, y, d, v, ans = 0;\n    for(i = 0; i < N; i++){\n      scanf(\"%d%d\", &x, &y);\n      B[x + 80][y + 80] = -2;\n    }\n    scanf(\"%d%d\", &sx, &sy);\n    sx += 80;\n    sy += 80;\n    int dx[6] = {0, 1, 1, 0, -1, -1};\n    int dy[6] = {1, 1, 0, -1, -1, 0};\n    queue<pair<pair<int, int>, int>> q;\n    q.push(pair<pair<int, int>, int>(pair<int, int>(sx, sy), 0));\n    while(q.size() > 0){\n      x = q.front().first.first;\n      y = q.front().first.second;\n      v = q.front().second;\n      q.pop();\n      if(v > t){\n        break;\n      }\n      if(B[x][y] == -1){\n        B[x][y] = v;\n        ans++;\n        for(d = 0; d < 6; d++){\n          q.push(pair<pair<int, int>, int>(pair<int, int>(x + dx[d], y + dy[d]), v + 1));\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,t;\nint map[100][100],first[100][100];\nint dx[]={0,1,0,-1,1,-1},dy[]={1,0,-1,0,1,-1};\nvoid DFS(int y,int x,int len){\n\tmap[y][x]=1;\n\tif(len<t&&len<first[y][x]){\n\tfirst[y][x]=len;\n\tfor(int i=0;i<6;i++){\n\t\tif(map[y+dy[i]][x+dx[i]]!=-1)\n\t\t\tDFS(y+dy[i],x+dx[i],len+1);\n\t}\n\t}\n}\nint main(){\n\twhile(true){\n\tcin>>t>>n;\n\tif(t==0&&n==0)\n\t\tbreak;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tmap[i][j]=0;\n\t\t\tfirst[i][j]=50;\n\t\t}\n\t}\n\tint x,y;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x>>y;\n\t\tmap[50+y][50+x]=-1;\n\t}\n\tcin>>x>>y;\n\tDFS(y+50,x+50,0);\n\tint ans=0;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tif(map[i][j]==1)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\t/* ?????? */\n\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\n\t//???????????¢\n\tint d[MAX_X][MAX_Y];\n\tmemset(d, 0x3f, sizeof(d));\n\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\t//??´??????????????¢?´¢????????????\n\t\tif (u == pii(gx, gy))break;\n\t\t//?§????4???????????¢?´¢\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\t\t//??¢?´¢???????£???°???\n\t\t\t\tif (d[nx][ny] != INF)continue;\n\t\t\t\td[nx][ny] = d[sx][sy] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[gx][gy];\n}\n\n#define MAX 70\n#define O 35\n\nint main() {\n\tbool m[MAX][MAX]; //?????????\n\tint d[MAX][MAX];\n\tfor (int t, n; cin >> t >> n&&t;) {\n\t\tmemset(m, false, sizeof(m));\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += O; y += O;\n\t\t\tm[x][y] = true;\n\t\t}\n\t\tint sx, sy; cin >> sx >> sy;\n\t\tsx += O; sy += O;\n\n\t\tqueue<pii> Q;\n\t\tQ.push(pii(sx, sy));\n\t\td[sx][sy] = 0;\n\n\t\t//?§????6?????????????????????\n\t\tint dx[6] = { 1,1,0,-1,-1,0 };\n\t\tint dy[6] = { 0,1,1,0,-1,-1 };\n\t\tfor (pii u; !Q.empty();) {\n\t\t\tu = Q.front(); Q.pop();\n\t\t\t//?§????6???????????¢?´¢\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < MAX && 0 <= ny&&ny < MAX) {\n\t\t\t\t\t//?????????????£???°???\n\t\t\t\t\tif (m[nx][ny])continue;\n\t\t\t\t\t//??¢?´¢???????£???°???\n\t\t\t\t\tif (d[nx][ny] != INF)continue;\n\t\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int x = 0; x < MAX; x++) {\n\t\t\tfor (int y = 0; y < MAX; y++) {\n\t\t\t\tif (d[x][y] <= t)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdio>\n#include <complex>\n#include <queue>\nusing namespace std;\n#define P pair<int, int>\n#define mp(a, b) make_pair(a, b)\n\nint main() {\n  int t, n;\n  while (cin >> t >> n, t|n) {\n    vector<vector<int> > f(61, vector<int>(61, -1));\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      f[x+30][y+30] = 0;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    int cnt = 1;\n    queue<P> q;\n    q.push(mp(sx+30, sy+30));\n    f[sx+30][sy+30] = 0;\n    const int dx[] = {1, 1, 0,  0, -1, -1};\n    const int dy[] = {0, 1, 1, -1,  0, -1};\n\n    while (!q.empty()) {\n      P p = q.front();\n      q.pop();\n      if (f[p.first][p.second] == t) continue;\n     \n      for (int i = 0; i < 6; i++) {\n        int xx = p.first  + dx[i];\n        int yy = p.second + dy[i];\n        if (xx >= 0 && xx < 61 && yy >= 0 && yy < 61 && f[xx][yy] == -1) {\n          cnt++;\n          f[xx][yy] = f[p.first][p.second] + 1;\n          q.push(mp(xx, yy));\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[1024][1024] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  std::ifstream in(\"input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    cin >> tt >> nn;\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      cin >> x >> y;\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    cin >> x >> y;\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<1024;j++){\n      for(k=0;k<1024;k++){\n        visited[j][k]=0;\n      }\n    }\n    cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main() {\n\tint d1[6] = { 1,0,-1,0,1,-1 };\n\tint d2[6] = { 0,1,0,-1,1,-1 };\n\tint t, n;\n\twhile (cin >> t>>n, t) {\n\t\tint p[100][100] = {};\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tp[19][i] = p[i][19] = 1;\n\t\t\tp[81][i] = p[i][81] = 1;\n\t\t}\n\t\tint x, y, sta, las;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[x + 50][y + 50] = 1;\n\t\t}\n\t\tcin >> sta >> las; sta += 50; las += 50;\n\t\tint used[100][100] = {};\n\t\tused[sta][las] = 1;\n\t\tvector<P> v;\n\t\tv.push_back({ sta,las });\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint len = v.size();\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tint nx = v[0].first; int ny = v[0].second; v.erase(v.begin());\n\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\tif (p[nx + d1[k]][ny + d2[k]] == 0 && used[nx + d1[k]][ny + d2[k]]==0) {\n\t\t\t\t\t\tused[nx + d1[k]][ny + d2[k]] = 1;\n\t\t\t\t\t\tv.push_back({ nx + d1[k],ny + d2[k] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif (used[i][j] == 1)cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define REPEAT(i, n) for(int i=0;i<(n);i++)\n\n#define INF 1<<28\n\n#define SIZE 200\n#define OFFSET 100\n\ntypedef pair<int, int> point;\n\nint field[SIZE][SIZE];\n\nint dx[] = {-1, 1, 0, 0, -1, 1};\nint dy[] = {0, 0, -1, 1, -1, 1};\n\nvoid init() {\n    memset(field, -1, sizeof(field));\n}\n\nint main() {\n    int t, n;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        init();\n        REPEAT(i, n) {\n            int x, y;\n            cin >> x >> y;\n            field[x+OFFSET][y+OFFSET] = INF;\n        }\n        int sx, sy; cin >> sx >> sy;\n        field[sx+OFFSET][sy+OFFSET] = 0;\n        queue<point> Q; Q.push(point(sx, sy));\n        while (!Q.empty()) {\n            point cur = Q.front(); Q.pop();\n            if (field[cur.first+OFFSET][cur.second+OFFSET] == t) {\n                continue;\n            }\n            REPEAT(i, 6) {\n                int cx = cur.first;\n                int cy = cur.second;\n                int nx = cx+dx[i];\n                int ny = cy+dy[i];\n                if (field[nx+OFFSET][ny+OFFSET] == -1) {\n                    Q.push(point(nx, ny));\n                    field[nx+OFFSET][ny+OFFSET] = field[cx+OFFSET][cy+OFFSET]+1;\n                }\n            }\n        }\n        int count = 0;\n        REPEAT(i, SIZE) {\n            REPEAT(j, SIZE) {\n                if (field[i][j] != -1 && field[i][j] != INF) count++;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[]={0,1,1,0,-1,-1},dy[]={1,1,0,-1,-1,0};\n\nint trans(int n){\n\treturn 50-n;\n}\n\tint t,n;\n\nint dfs(vvi &m,int x,int y,int step){\n\tm[x][y]=1;\n\tif(step==t){\n\t\treturn 1;\n\t}\n\tint ans=1;\n\tREP(i,6){\n\t\tint xx=x+dx[i];\n\t\tint yy=y+dy[i];\n\t\tif(!m[xx][yy]){\n\t\t\tans+=dfs(m,xx,yy,step+1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nstruct node{\n\tint x,y,step;\n\tnode(int x,int y,int step):x(x),y(y),step(step){}\n};\nint main(){\n\twhile(cin>>t>>n,t|n){\n\t\tvvi m(100,vi(100));\n\t\tvi x(n),y(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tREP(i,n){\n\t\t\tm[trans(x[i]-sx)][trans(y[i]-sy)]=1;\n\t\t}\n\t\tqueue<node> q;\n\t\tq.push(node(trans(0),trans(0),0));\n\t\tm[trans(0)][trans(0)]=1;\n\t\tint ans=1;\n\t\twhile(!q.empty()){\n\t\t\tnode n=q.front();\n\t\t\tq.pop();\n\t\t\tif(n.step==t){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,6){\n\t\t\t\tint xx=n.x+dx[i];\n\t\t\t\tint yy=n.y+dy[i];\n\t\t\t\tif(!m[xx][yy]){\n\t\t\t\t\tm[xx][yy]=1;\n\t\t\t\t\tans++;\n\t\t\t\t\tq.push(node(xx,yy,n.step+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\nconst int OBSTACLE = -INF;\nconst int DIFF = 100;\nint field[200][200];\n\nint dx[] = {1, 0, -1, 0, 1, -1};\nint dy[] = {0, -1, 0, 1, 1, -1};\n\nbool in_field(int x, int y){\n    return 0<=x && x<200 & 0<=y && y<200;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T, N;\n    while(cin>>T>>N, T|N){\n        for(int i=0; i<200; i++)\n            for(int j=0; j<200; j++)\n                field[i][j] = INF;\n        int x, y;\n        while(N--){\n            cin >> x >> y;\n            field[x+DIFF][y+DIFF] = OBSTACLE;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        \n        queue<pair<int, int>> que;\n        field[sx+DIFF][sy+DIFF] = 0;\n        que.push(make_pair(sx+DIFF, sy+DIFF));\n        \n        while(!que.empty()){\n            auto p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            \n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(in_field(nx, ny) && field[nx][ny] == INF){\n                    field[nx][ny] = field[x][y] + 1;\n                    que.push(make_pair(nx, ny));\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<200; i++)\n            for(int j=0; j<200; j++)\n                ans += (0<=field[i][j] && field[i][j]<=T);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\nint t, n;\nint dy[] = {1, 1, 0, -1, -1, 0}, dx[] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n  while(scanf(\"%d%d\", &t, &n) && t+n){\n    int board[300][300] = {};\n    rep(i, 300) rep(j, 300) board[i][j] = INF;\n    int x, y;\n    rep(i, n){\n      scanf(\"%d%d\", &x, &y); \n      board[y+100][x+100] = -1;\n    }\n\n    scanf(\"%d%d\", &x, &y); \n    board[y+100][x+100] = 0;\n    //    printf(\"%d %d\\n\", y+100, x+100);\n    queue<pair<int,int> >q;\n    q.push(make_pair(y+100, x+100));\n    for(int k = 1; k <= t; k++){\n      //      printf(\"%d\\n\", k);\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpair<int, int>p = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", p.Y, p.X);\n\trep(j, 6){\n\t  int nx = p.X + dx[j], ny = p.Y + dy[j];\n\t  //\t  printf(\"%d %d\\n\", ny, nx);\n\t  if(board[ny][nx] <= k) continue;\n\t  board[ny][nx] = k;\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n\n      /*      REP(i, 90, 110){\n\tREP(j, 90, 110) printf(board[i][j] != INF?\"%2d\":\" N\", board[i][j]);\n\tputs(\"\");\n\t} */\n    }\n    int res = 0;\n    rep(i, 300) rep(j, 300) if(board[i][j] >= 0 && board[i][j] < INF) res++;\n\n\n\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tvector<pair<int, int> > obstacle;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobstacle.push_back(make_pair(x, y));\n\t\t}\n\n\t\tint startX, startY;\n\t\tcin >> startX >> startY;\n\t\tint map[100][100];\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpair<int, int> p;\n\t\t\tp = obstacle.at(i);\n\t\t\tmap[p.second + 50][p.first + 50] = INT_MIN;\n\t\t}\n\n\t\tqueue<data> q;\n\t\tdata first;\n\t\tfirst.cx = startX + 50;\n\t\tfirst.cy = startY + 50;\n\t\tq.push(first);\n\t\tmap[startY + 50][startX + 50] = 0;\n\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tint cx = d.cx;\n\t\t\tint cy = d.cy;\n\t\t\tif (map[cy][cx] != INT_MAX && map[cy][cx] + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (nx < 0 || nx >= 100 || ny < 0 || ny >= 100)continue;\n\t\t\t\tif (map[ny][nx] == INT_MIN)continue;\n\t\t\t\tif (map[ny][nx] != INT_MAX)continue;\n\t\t\t\tmap[ny][nx] = map[cy][cx] + 1;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] > INT_MIN && map[i][j] < INT_MAX)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nstruct point {\n  int x, y;\n};\n\nconst int dir[6][2] = { {1, 0}, {-1, 0}, {1, 1}, {-1, -1}, {0, 1}, {0, -1} };\n\nint main() {\n  int t, n;\n  while(scanf(\"%d%d\", &t, &n) != EOF && t) {\n    bool visited[200][200]; // 障害物＝もう訪れた、とする。\n    fill(&visited[0][0], &visited[0][0]+200*200, false);\n    for (int i=0; i<n; i++) {\n      int tx, ty;\n      scanf(\"%d%d\", &tx, &ty); tx += 100; ty += 100;\n      visited[tx][ty] = true;\n    }\n    queue<pair<point,int>> Q; // 幅優先探索で解く。\n    int sx, sy;\n    scanf(\"%d%d\", &sx, &sy); sx += 100; sy += 100;\n    point p = { sx, sy };\n    Q.push(make_pair(p, 0));\n    int count = 0;\n    while (! Q.empty()) {\n      int times = Q.front().second;\n      if (times > t) break;\n      p = Q.front().first;\n      Q.pop();\n      if (! visited[p.x][p.y]) {\n\tvisited[p.x][p.y] = true;\n\tcount++;\n\t// cerr << \"Visited (\" << p.x << \",\" << p.y << \")\" << \" at \" << times << endl;\n\tfor (int i=0; i<6; i++) {\n\t  int tx = p.x+dir[i][0];\n\t  int ty = p.y+dir[i][1];\n\t  if (! visited[tx][ty]) {\n\t    point temp = {tx, ty};\n\t    Q.push(make_pair(temp, times+1));\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 75\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs(int,int);\nint dy[6]={-1,-1,0,1,1,0};\nint dx[6]={-1,0,1,1,0,-1};\nint t;\nint data[N][N];\nint main(){\n  int n,x,y,sx,sy;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0;\n    while(n--){\n      cin >> x >> y;\n      data[y+30][x+30]=-1;\n    }\n    cin >> sx >> sy;\n    data[sy+30][sx+30]=1;\n    bfs(sy+30,sx+30);\n    int cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(data[i][j]==1) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid bfs(int y,int x){\n  queue<P1> Q;\n  Q.push(P1(0,P(y,x)));\n  while(Q.empty()!=1){\n    P1 v=Q.front();\n    Q.pop();\n    int d=v.first,y1=v.second.first,x1=v.second.second;\n    for(int i=0;i<6;i++){\n      if(0<=y1+dy[i]&&y1+dy[i]<N&&0<=x1+dx[i]&&x1+dx[i]<N&&data[y1+dy[i]][x1+dx[i]]==0&&d<=t){\n\tdata[y1+dy[i]][x1+dx[i]]=1;\n\tif(d<=t-2) Q.push(P1(d+1,P(y1+dy[i],x1+dx[i])));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define mp(a, b) make_pair(a, b)\ntypedef pair<pair<int, int>, int> State;\n\nstatic const int MAX = 60;\nstatic const int N =  2*MAX+1;\nstatic const int dx[6] = {1, 1, 0, -1, -1, 0};\nstatic const int dy[6] = {0, 1, 1, 0, -1, -1};\nmain(){\n  bool O[N][N];\n  int t, n, x, y, sx, sy;\n  while(1){\n    cin >> t >> n;\n    if ( t == 0 && n == 0 ) break;\n    rep(i, N) rep(j, N) O[i][j] = false;\n    rep(i, n){\n      cin >> x >> y;\n      O[x+MAX][y+MAX] = true;\n    }\n    cin >> sx >> sy;\n    sx += MAX;\n    sy += MAX;\n    queue<State> Q;\n    State u;\n    Q.push(mp(mp(sx, sy), 0));\n    O[sx][sy] = true;\n    int cnt = 0;\n    while(!Q.empty()){\n      u = Q.front(); Q.pop();\n\n      cnt++;\n      for ( int r = 0; r < 6; r++ ){\n\tint nx = u.first.first + dx[r];\n\tint ny = u.first.second + dy[r];\n\tif ( O[nx][ny] || u.second+1 > t) continue;\n\tO[nx][ny] = true;\n\tQ.push(mp(mp(nx, ny), u.second+1));\n      }\n    }\n    cout << cnt << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define O 60\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\nint m[O * 2 + 1][O * 2 + 1];\n\nint f(int x, int y, int t) {\n\tint c = 0;\n\tif (m[y][x] == -1) {\n\t\tc++;\n\t}\n\tm[y][x] = t;\n\tif (t > 0) {\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (t > m[y + dy[i]][x + dx[i]]) {\n\t\t\t\tc += f(x + dx[i], y + dy[i], t - 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main() {\n\tint t, n, x, y;\n\twhile (cin >> t >> n, t) {\n\t\tfill(m[0], m[O * 2 + 1], -1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tm[y + O][x + O] = 300;\n\t\t}\n\t\tcin >> x >> y;\n\t\tcout << f(x + O, y + O, t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int p = 150;\n\nstruct St{\n  int t, x, y;\n  St() {}\n  St(int _x, int _y, int _t): x(_x), y(_y), t(_t) {}\n};\n\nint xdir[6] = {0, 1, 1, -1, 0, -1}, ydir[6] = {1, 1, 0, -1, -1, 0};\nint bfs(bool a[301][301], int t, int sx, int sy)\n{\n  int cnt = 1;\n  queue<St> que;\n  a[sy+p][sx+p] = false;\n  que.push(St(sx, sy, t));\n\n  while(!que.empty()){\n    St st = que.front();\n    que.pop();\n    \n    if(st.t == 0) continue;\n\n    for(int i = 0; i < 6; i++){\n      int dx = st.x+xdir[i], dy = st.y+ydir[i];\n      if(a[dy+p][dx+p]){\n\ta[dy+p][dx+p] = false;\n\tcnt++;\n\tque.push(St(dx, dy, st.t-1));\n      }\n    }\n  }\n\n  return cnt;\n}\n\nint main()\n{\n  int t, n, u, v;\n  bool a[301][301];\n\n  while(cin>>t>>n && (t+n)){\n    fill(&a[0][0], &a[300][300], true);    \n    while(n--){\n      cin >> u >> v;\n      a[v+p][u+p] = false;\n    }\n    cin >> u >> v;\n\n    cout << bfs(a, t, u, v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n//bool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { 0, 1, -1, 1, -1, 0 };\nint dy[] = { 1, 1, 0, 0, -1, -1 };\n\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n, t)\n\t{\n\t\tbool fld[200][200] = {};\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 100; y += 100;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100, sy += 100;\n\t\tset<P> st;\n\t\tqueue<pair<P, int>> que;\n\t\tque.push(make_pair(P(sx, sy), 0));\n\t\tst.insert(P(sx, sy));\n\t\twhile (que.size())\n\t\t{\n\t\t\tP now = que.front().first;\n\t\t\tint tx = now.first;\n\t\t\tint ty = now.second;\n\t\t\tint time = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (time > t - 1) break;\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i];\n\t\t\t\tint ny = ty + dy[i];\n\t\t\t\tif (fld[nx][ny]) continue;\n\t\t\t\tque.push(make_pair(P(nx, ny), time + 1));\n\t\t\t\tst.insert(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tcout << st.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nclass state{\npublic:\n\tint x;\n\tint y;\n\tint turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tREP(i, 6) {\n\t\t\t\t\tint x = s.x+dx[i];\n\t\t\t\t\tint y = s.y+dy[i];\n\t\t\t\t\tif(field[x][y] == OPEN) {\n\t\t\t\t\t\tQ.push(state(x, y, s.turn+1));\n\t\t\t\t\t\tfield[x][y] = WALL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint t, n;\n\tint DX[6] = { 0,1,1,0,-1,-1 }, DY[6] = { 1,1,0,-1,-1,0 };\n\twhile (cin >> t >> n&&t)\n\t{\n\t\tint z = 100;\n\t\tint a[200][200];\n\t\tmemset(a, -1, sizeof a);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ta[x+z][y+z] = -2;\n\t\t}\n\t\tpii st;\n\t\tcin >> st.first >> st.second;\n\t\tst.first += z;\n\t\tst.second += z;\n\t\ta[st.first][st.second] = t;\n\t\tqueue<pii> que;\n\t\tque.push(st);\n\t\tint ans = 1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front();\n\t\t\tque.pop();\n\t\t\tif (a[now.first][now.second] == 0)continue;\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += DX[i];\n\t\t\t\tnext.second += DY[i];\n\t\t\t\tif (a[next.first][next.second] == -1)\n\t\t\t\t{\n\t\t\t\t\ta[next.first][next.second] = a[now.first][now.second] - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {1,0,-1,-1,0,1};\nconst int dy[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt,z = 100;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(200,vector<ll>(200,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += z;\n      y += z;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += z;\n    y += z;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      auto Q = q.front();q.pop();\n      d = v[Q.fi][Q.se];\n      if(d >= t) continue ;\n      rep(i,6){\n        ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n        if( v[nx][ny] == inf){\n          q.push(mp(nx,ny));\n          ++cnt;\n          v[nx][ny] = d+1;\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cstdlib>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cfloat>\n\n#include <map>\n\n#include <utility>\n\n#include <set>\n\n#include <iostream>\n\n#include <memory>\n\n#include <string>\n\n#include <vector>\n\n#include <algorithm>\n\n#include <functional>\n\n#include <sstream>\n\n#include <complex>\n\n#include <stack>\n\n#include <queue>\n\n#include <numeric>\n\n#include <cstring>\n\n\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n#define pb push_back\n\n\n\nusing namespace std;\n\n\n\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\ntypedef vector<int> vi;\n\n\n\nconst int INF = 1 << 29;\n\nconst double EPS = 1e-9;\n\nconst int MAX_N = 100;\n\n\n\nint field[1000][1000];\n\n\n\nint bfs(int sx, int sy, int t){\n\n\t\tP p;\n\n\t\tqueue<P> q;\n\n\t\tqueue<int> qt;\n\n\t\tint dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\n\t\tint mx, my, count = 0;\n\n\n\n\t\tq.push(P(sx, sy));\n\n\t\tcount++;\n\n\t\tfield[sx][sy] = -1;\n\n\t\tqt.push(t);\n\n\n\n\t\twhile(q.size()){\n\n\t\t\t\tp = q.front(), q.pop();\n\n\t\t\t\tt = qt.front(), qt.pop();\n\n\t\t\t\tif(t == 0) break;\n\n\t\t\t\tt--;\n\n\t\t\t\tsx = p.first, sy = p.second;\n\n\n\n\t\t\t\trep(i, 6){\n\n\t\t\t\t\t\tmx = sx + dx[i], my = sy + dy[i];\n\n\t\t\t\t\t\tif(mx >= 0 && my >= 0 && mx < 1000 && my < 1000 && field[mx][my] == 0){\n\n\t\t\t\t\t\t\t\tfield[mx][my] = -1;\n\n\t\t\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\t\t\tq.push(P(mx, my));\n\n\t\t\t\t\t\t\t\tqt.push(t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n}\n\n\n\n\n\nint main(){\n\n\t\tint n, sx, sy, t, x, y, ans;\n\n\t\twhile(1){\n\n\t\t\t\tmemset(field, 0, sizeof(field));\n\n\n\n\t\t\t\tcin >> t >> n;\n\n\t\t\t\tif(t == 0 && n == 0) break;\n\n\n\n\t\t\t\trep(i, n){\n\n\t\t\t\t\t\tcin >> x >> y;\n\n\t\t\t\t\t\tx += 500, y += 500;\n\n\t\t\t\t\t\tfield[x][y] = INF;\n\n\t\t\t\t}\n\n\n\n\t\t\t\tcin >> sx >> sy;\n\n\t\t\t\tsx += 500, sy += 500;\n\n\t\t\t\tans = bfs(sx, sy, t);\n\n\t\t\t\tcout << ans << endl;\n\n\t\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[80][80], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=1;return ans;}\n\tmap[y][x] = 1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[80][80] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nint u[70][70] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=t;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]<t){\n                u[ny+35][nx+35] = t;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x]>0)a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct point {\n  int x;\n  int y;\n  int t;\n} POINT;\n\nint t, n, sx, sy, cnt;\nbool d[61][61];\nbool f[61][61];\nqueue<POINT> que;\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &t, &n);\n  if (!t && !n) return false;\n  fill(d[0], d[0] + 61 * 61, true);\n  fill(f[0], f[0] + 61 * 61, true);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &sx, &sy);\n    d[sy + 30][sx + 30] = false;\n  }\n  scanf(\"%d %d\", &sx, &sy);\n\n  while (!que.empty()) que.pop();\n\n  return true;\n}\n\nint main() {\n  POINT a, b;\n\n  while (input()) {\n    a.x = sx + 30;\n    a.y = sy + 30;\n    a.t = t + 1;\n    cnt = 0;\n    que.push(a);\n    while (!que.empty()) {\n      a = que.front();\n      que.pop();\n      printf(\"%d %d %d\\n\", a.x, a.y, a.t);\n      if (!a.t) break;\n      if (!d[a.y][a.x] || !f[a.y][a.x]) continue;\n      f[a.y][a.x] = false;\n      cnt++;\n      \n      b.x = a.x + 1;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y - 1;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x - 1;\n      b.y = a.y + 0;\n      b.t = a.t - 1;\n      que.push(b);\n      b.x = a.x + 0;\n      b.y = a.y + 1;\n      b.t = a.t - 1;\n      que.push(b);\n    }\n    printf(\"%d\\n\", cnt);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[64][64] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    cin >> tt >> nn;\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      cin >> x >> y;\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    cin >> x >> y;\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<64;j++){\n      for(k=0;k<64;k++){\n        visited[j][k]=0;\n      }\n    }\n    cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint data[121][121];\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nint check(int m,int i,int j){\n\tint ans = 0;\n\tfor(int k = 0;k < 6;k++){\n\t\tif(i+dx[k] < 121 && i+dx[k] > -1 && j+dy[k] < 121 && j+dy[k] > -1){\n\t\t\tif(data[j+dy[k]][i+dx[k]] == 0){\n\t\t\t\tdata[j+dy[k]][i+dx[k]] = m + 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint t,n,x,y,result;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t == 0)break;\n\t\tresult = 1;\n\t\tfor(int i = 0;i < 121;i++){\n\t\t\tfor(int j = 0;j < 121;j++){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tdata[y+60][x+60] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tdata[y+60][x+60] = 1;\n\t\tfor(int m = 0;m < t;m++){\n\t\t\tfor(int i = 0;i < 121;i++){\n\t\t\t\tfor(int j = 0;j < 121;j++){\n\t\t\t\t\tif(data[j][i] == m+1){\n\t\t\t\t\t\tresult += check(m+1,i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0;i < 61;i++){\n\t\t\tfor(int j = 0;j < 61;j++){\n\t\t\t\tcout << data[j][i] <<\" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state{\n\tint x, y, turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tREP(i, 6) {\n\t\t\t\t\tint x = s.x+dx[i];\n\t\t\t\t\tint y = s.y+dy[i];\n\t\t\t\t\tif(field[x][y] == OPEN) {\n\t\t\t\t\t\tQ.push(state(x, y, s.turn+1));\n\t\t\t\t\t\tfield[x][y] = WALL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef pair<int,int> P;\nint d[140][140],dx[6]={0,1,1,0,-1,-1},dy[6]={1,1,0,-1,-1,0},mid=70,t;\nbool obs[140][140];\nvoid bfs(int x,int y){\n\td[x][y]=0;\n\tqueue<P> que;\n\tque.push(P(x,y));\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tint x=p.first,y=p.second;\n\t\tif(d[x][y]==t) break;\n\t\trep(i,6){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(obs[nx][ny] || d[nx][ny]!=1e8) continue;\n\t\t\td[nx][ny]=d[x][y]+1;\n\t\t\tque.push(P(nx,ny));\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> t >> n;\n\t\tif(t==0) break;\n\t\trep(i,140) rep(j,140) d[i][j]=1e8,obs[i][j]=0;\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=mid,y+=mid;\n\t\t\tobs[x][y]=true;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tbfs(x+mid,y+mid);\n\t\tint cnt=0;\n\t\trep(i,140) rep(j,140) if(d[i][j]!=1e8) cnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n\n#define N 100\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nusing namespace std;\n\nint main(void)\n{\n\n\tint t,n;\n\tint xx,yy;\n\tint x,y;\n\tint start_x,start_y;\n\t\n\tint i1,i2;\n\n\tint f[N][N];\n\n\tint num;\n\tint count;\n\n\n\n\twhile(1){\n\n\t\tfor(i1=0;i1<N;i1++){\n\t\t\tfor(i2=0;i2<N;i2++){\n\t\t\t\tf[i1][i2] = 100;\n\t\t\t}\n\t\t}\n\n\t\tcin >> t;\n\t\tcin >> n;\n\t\tif(t == 0 && n == 0) break;\n\n\n\t\tfor(i1=0;i1<n;i1++){\n\t\t\tcin >> xx;\n\t\t\tcin >> yy;\n\n\n\t\t\tf[yy+50][xx+50] = 500;\n\t\t}\n\n\t\tcount = 1;\n\t\tnum = 0;\n\n\n\t\tcin >> start_x;\n\t\tcin >> start_y;\n\n\t\tstart_x += 50;\n\t\tstart_y += 50;\n\n\n\t\tqueue<pair<int, int> > q;\n\n\t\tf[start_y][start_x] = 0;\n\t\tq.push(make_pair(start_x,start_y));\n\n\n\t\twhile(!q.empty()) {\n\n\t\t\tx = q.front().first;\n\t\t\ty = q.front().second;\n\t\t\tq.pop();\n\n//\t\t\t\tcout << x << \" \" << y << \" \" << num << endl;\n\t\t\tif ( f[y][x] < t){\n\t\t\t\tnum = f[y][x];\n\n\t\t\t\tfor(i1=0;i1<6;i1++){\n\n\t\t\t\t\tif (f[y+dy[i1]][x+dx[i1]]==100){\n\t\t\t\t\t\tf[y+dy[i1]][x+dx[i1]] = num + 1;\n\t\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\tcout << count << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n \n#define mp(a,b) make_pair(a, b)\n \nusing namespace std;\n \ntypedef pair<int, int> xy;\n \nint main() {\n \n    const int SIZE = 200;\n    const int OFFSET = 100;\n    const int   mx[] = {0, 1, 1, 0, -1, -1},\n                my[] = {1, 1, 0, -1, -1, 0};\n \n    int t, n;\n \n    while(cin >> t >> n,t||n) {\n        vector< vector<bool> > f(SIZE, vector<bool>(SIZE, true));\n        queue< pair< pair<int, int>, int> > open;\n \n        while (n--) {\n            int x, y;\n            cin >>x >>y;\n \n            f[y+OFFSET][x+OFFSET] = false;\n        }\n \n        int x, y, cnt = 0;\n        cin >>x >>y;\n        x += OFFSET; y += OFFSET;\n        f[y][x] = false;\n        open.push(mp(mp(x, y), 0) );\n \n        while(!open.empty()) {\n            pair<xy, int> tmp = open.front(); open.pop();\n            xy tmp2 = tmp.first;\n            int x = tmp2.first,\n                y = tmp2.second,\n                c = tmp.second;\n \n            cnt++;\n            if (c >= t) continue;\n \n            for( int i = 0; i < 6; i++) {\n                int nx = x + mx[i],\n                    ny = y + my[i];\n \n                if ( f[ny][nx] != true ) continue;\n \n                f[ny][nx] = false;\n                open.push( mp(mp(nx,ny), c+1));\n            }\n        }\n        cout <<cnt <<endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\nmap<P,int> m;\n\nvoid init(){\n\tfor(int y = -100 ; y <= 100 ; y++ ){\n\t\tfor(int x = -100 ; x <= 100 ; x++ ){\n\t\t\tm[P(x,y)] = INF;\n\t\t}\n\t}\n}\n\n\nint solve(int sx, int sy, int t){\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\tm[P(sx,sy)] = 0;\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( m[P(mx,my)] == -1 ) continue;\n\t\t\tif( m[P(mx,my)] == INF && m[P(x,y)] + 1 <= t ){\n\t\t\t\tm[P(mx,my)] = m[P(x,y)] + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int y = -100 ; y <= 100 ; y++ ){\n\t\tfor(int x = -100 ; x <= 100 ; x++ ){\n\t\t\tif( m[P(x,y)] != -1 && m[P(x,y)] != INF )\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tm[P(x,y)] = -1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = solve( sx , sy , t );\n\t\tcout << ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 200\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs(int,int);\nint dy[6]={-1,-1,0,1,1,0};\nint dx[6]={-1,0,1,1,0,-1};\nint t;\nint data[N][N];\nint main(){\n  int n,x,y,sx,sy;\n  while(1){\n    cin >> t >> n;\n    if(t==0&&n==0) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) data[i][j]=0;\n    while(n--){\n      cin >> x >> y;\n      data[y+100][x+100]=-1;\n    }\n    cin >> sx >> sy;\n    data[sy+100][sx+100]=1;\n    bfs(sy+100,sx+100);\n    int cnt=0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(data[i][j]==1) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid bfs(int y,int x){\n  queue<P1> Q;\n  Q.push(P1(0,P(y,x)));\n  while(Q.empty()!=1){\n    P1 v=Q.front();\n    Q.pop();\n    int d=v.first,y1=v.second.first,x1=v.second.second;\n    for(int i=0;i<6;i++){\n      if(0<=y1+dy[i]&&y1+dy[i]<N&&0<=x1+dx[i]&&x1+dx[i]<N&&data[y1+dy[i]][x1+dx[i]]==0){\n\tdata[y1+dy[i]][x1+dx[i]]=1;\n\tif(d<=t-2) Q.push(P1(d+1,P(y1+dy[i],x1+dx[i])));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {0,1,1,0,-1,-1};\nconst int    DY[] = {1,1,0,-1,-1,0};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nconst int M = 200;\nconst int OFFSET = 100;\nint T, N;\n\nVVB done;\nVVB bads;\n\nint solve() {\n    bads = VVB(M, VB(M));\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        bads[OFFSET + y][OFFSET + x] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    done = VVB(M, VB(M));\n\n    queue<pair<int, PII>> q;\n    q.push(MP(T, MP(OFFSET + sy, OFFSET + sx)));\n    while (q.size()) {\n        int t = q.front().fst;\n        int y = q.front().snd.fst;\n        int x = q.front().snd.snd;\n        q.pop();\n\n        if (done[y][x]) continue;\n        done[y][x] = true;\n        if (!t) continue;\n\n        rep(i, 6) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if (!RANGEBOX(ny, nx, M, M)) continue;\n            if (bads[ny][nx]) continue;\n            q.push(MP(t - 1, MP(ny, nx)));\n        }\n    }\n\n    int cnt = 0;\n    rep(i, M) cnt += count(ALL(done[i]), true);\n\n    return cnt;\n}\n\nint main(void) {\n    while (cin >> T >> N, T) cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nint main(){\n    int a,b;\n    while(cin >> a >> b,a){\n        rep(i,200)rep(j,200)ban[i][j]=bfs[i][j]=0;\n        rep(i,b){\n            int x,y;\n            cin >> x >> y;\n            x+=100;\n            y+=100;\n            ban[y][x]=1;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx+=100;\n        sy+=100;\n        queue qy;\n        queue qx;\n        qx.push(sx);\n        qy.push(sy);\n        bfs[sy][sx] = a+1;\n        while(q.size()){\n            int y = qy.front();\n            int x = qx.front();\n            qx.pop();qy.pop();\n            if(bfs[y][x] == 1) break;\n            rep(i,6){\n                int nx = x+dx[i];\n                int ny = y+dy[i];\n                if(!bfs[ny][nx]&&!ban[ny][nx]){\n                    bfs[ny][nx] = bfs[y][x]-1;\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n        int ret = 0;\n        rep(i,200)rep(j,200)if(bfs[i][j])ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nconst int MAXINT=200;\nint dx[6]={1,-1,0,0,1,-1};\nint dy[6]={0,0,1,-1,1,-1};\nbool used[MAXINT][MAXINT];\nbool rock[MAXINT][MAXINT];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n,t||n){\n\t\trep(i,MAXINT){\n\t\t\tfill(used[i],used[i]+MAXINT,false);\n\t\t\tfill(rock[i],rock[i]+MAXINT,false);\n\t\t}\n\t\tint x,y;\n\t\trep(i,n){\n\t\t\tcin>>x>>y;\n\t\t\trock[y+MAXINT/2][x+MAXINT/2]=true;\n\t\t}\n\t\tcin>>x>>y;\n\t\tused[y+MAXINT/2][x+MAXINT/2]=true;\n\t\tqueue<piii> que;\n\t\tque.push(piii(0,pii(x+MAXINT/2,y+MAXINT/2)));\n\t\twhile(!que.empty()){\n\t\t\tpiii now=que.front();\n\t\t\tused[now.second.second][now.second.first]=true;\n\t\t\tque.pop();\n\t\t\trep(i,6){\n\t\t\t\tint nextx=now.second.first+dx[i],nexty=now.second.second+dy[i];\n\t\t\t\tif(used[nexty][nextx]||rock[nexty][nextx])continue;\n\t\t\t\tif(now.first+1>t)continue;\n\t\t\t\tused[nexty][nextx]=true;\n\t\t\t\tque.push(piii(now.first+1,pii(nextx,nexty)));\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\trep(i,MAXINT){\n\t\t\trep(j,MAXINT){\n\t\t\t\tif(used[i][j])cnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nint field[100][100];\nvoid setf(int x, int y, int val) {\n\tfield[x+50][y+50] = val;\n}\nint getf(int x, int y) {\n\treturn field[x+50][y+50];\n}\n\nstruct t_node {\n\tint x, y, t;\n\tt_node( int tx, int ty, int tt ) {\n\t\tx = tx;\n\t\ty = ty;\n\t\tt = tt;\n\t}\n};\nbool operator<( const t_node &lhs, const t_node &rhs ) {\n\treturn lhs.t < rhs.t;\n}\n\nconst int INF = 1<<30;\n\nint main() {\n\tint t, n;\n\twhile( cin >> t >> n, t||n ) {\n\t\tmemset( field, -1, sizeof(field) );\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tsetf(x, y, INF);\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(sx, sy, t) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n\t\t\tif( getf(tn.x, tn.y) > 0 ) continue;\n\t\t\tsetf( tn.x, tn.y, tn.t );\n\t\t\tif( tn.t == 0 ) continue;\n\t\t\tint dx[6] = {0, 1, 1,  0, -1, -1};\n\t\t\tint dy[6] = {1, 1, 0, -1, -1,  0};\n\t\t\trep(i, 6) {\n\t\t\t\tint nx = tn.x + dx[i];\n\t\t\t\tint ny = tn.y + dy[i];\n\t\t\t\tif( -30<=nx && nx<=30 &&\n\t\t\t\t\t-30<=ny && ny<=30 &&\n\t\t\t\t\tgetf(nx, ny) < tn.t-1 ) {\n\t\t\t\t\tque.push( t_node(nx, ny, tn.t-1) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int y=-30; y<=30; y++) {\n\t\t\tfor(int x=-30; x<=30; x++) {\n\t\t\t\tint f = getf(x, y);\n\t\t\t\tif( 0<=f && f<INF ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 50\n#define NN 2*N\n#define UNKNOWN 10000\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,1,0,-1,-1,0};\n  int dy[6] = {1,0,-1,-1,0,1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN; // 何ステップで行けるのかわからない\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[x][y] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;    q.push( S(x,y,0) );\n    d[x][y] = 0;\n\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      int nt = s.t+1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( nx<0 || nx>=NN ) continue;\n\tif( ny<0 || ny>=NN ) continue;\n\tif( d[nx][ny]==UNKNOWN ){\n\t  if( nt<t )\n\t    q.push( S(nx,ny,nt) );\n\t  d[nx][ny]=nt; ans++;\n\t}\n\t/*\n\tif( nt>=d[nx][ny] ) continue;\n\tif( d[nx][ny]==UNKNOWN ) ans++;\n\td[nx][ny]=nt;\n\tif( nt<t )\n\t  q.push( S(nx,ny,nt) );\n\t*/\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct sindo{\n  int x;\n  int y;\n  int count;\n};\n\nint main(){\n  int t,n;\n  int houkoux[6]={1,1,0,-1,-1,0};\n  int houkouy[6]={1,0,-1,-1,0,1};\n  while(1){\n    cin >> t >> n;\n    if(t==0) return 0;\n    vector<vector<int>> field(200,vector<int>(200,0));\n    vector<vector<bool>> tootta(200,vector<bool>(200,false));\n    int x,y;\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      field[y+100][x+100]=1;\n    }\n    cin >> x >> y;\n    queue<struct sindo> bfs;\n    int ans=0;\n    bfs.push({x,y,0});\n    tootta[y+100][x+100]=true;\n    struct sindo now;\n    while(!bfs.empty()){\n      now = bfs.front();\n      bfs.pop();\n      ans++;\n      if(now.count<t){\n        for(int i=0;i<6;i++){\n          if(!field[now.y+houkouy[i]+100][now.x+houkoux[i]+100]&&(!tootta[now.y+houkouy[i]+100][now.x+houkoux[i]+100])){\n              bfs.push({now.x+houkoux[i],now.y+houkouy[i],now.count+1});\n              tootta[now.y+houkouy[i]+100][now.x+houkoux[i]+100]=true;\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t, n;\nbool used[100][100], block[100][100];\n\nstruct State {\n  int x, y, t;\n  State(){}\n  State(int ax, int ay, int at):\n  x(ax), y(ay), t(at)\n  {}\n};\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = true;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<State> que;\n  que.push(State(sx, sy, t));\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    if (used[s.y][s.x] || block[s.y][s.x]) continue;\n    used[s.y][s.x] = true;\n    res++;\n    \n    if (s.t <= 0) continue;\n    for (int z = 0; z < 6; z += 1) {\n      int tx = s.x + dx[z];\n      int ty = s.y + dy[z];\n      \n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(State(tx, ty, s.t-1));\n    }\n  }\n  /*\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  */\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n/** Problem2253 : Brave Force Story **/\nint T;\nconst int dx0[6]={0, 1, 1, 0, -1, -1};\nconst int dy0[6]={1, 1, 0, -1, -1, 0};\nint ans;\nset<P> vis;\ntypedef struct {\n\tP pos; int cost;\n} S;\n\nint main()\n{\n\tint n, sx, sy;\n\twhile (cin>>T>>n, T||n) {\n\t\tvis.clear();\n\t\tans=0;\n\t\t\n\t\trep(k, n) {\n\t\t\tint x, y;\n\t\t\tcin>>x>>y;\n\t\t\tvis.insert(P(x, y));\n\t\t}\n\t\tcin >> sx >> sy;\n\t\tS s = {P(sx, sy), 0};\n\t\tqueue<S> Q;\n\t\tQ.push(s);\n\t\twhile (Q.size()) {\n\t\t\tS t = Q.front(); Q.pop();\n\t\t\t\t\t\t\n\t\t\tif (vis.find(t.pos)!=vis.end()) continue;\n\t\t\tvis.insert(t.pos);\n\t\t\t\n\t\t\trep(i, 6) {\n\t\t\t\tint nx=t.pos.first+dx0[i], ny=t.pos.second+dy0[i];\n\t\t\t\tif (-30<=nx&&nx<=30 && -30<=ny&&ny<=30) {\n\t\t\t\t\tif (vis.find(P(nx, ny)) == vis.end() && t.cost+1<=T) {\n\t\t\t\t\t\tS ns = {P(nx, ny), t.cost+1};\n\t\t\t\t\t\tQ.push(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << vis.size()-n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint main(){\n\tint n, t;\n\n\twhile(cin >> t >> n, !(t == 0 && n == 0)) {\n\t\tset<pii> wall;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\twall.insert(pii(x, y));\n\t\t}\n\n\t\tmap<pii, int> d;\n\t\tqueue<pii> q;\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\td[pii(sx, sy)] = 0;\n\t\tq.emplace(sx, sy);\n\n\t\tconst int dx[] = {0, 1, 1, 0, -1, -1};\n\t\tconst int dy[] = {-1, 0, 1, 1, 0, -1};\n\n\t\twhile(!q.empty()) {\n\t\t\tauto p = q.front(); q.pop();\n\n\t\t\tif(d[p] == t) {\n\t\t\t  continue;\n\t\t\t}\n\n\t\t\tfor(int k = 0; k < 6; ++k) {\n\t\t\t  int nx = p.first + dx[k];\n\t\t\t  int ny = p.second + dy[k];\n\n\t\t\t  pii np(nx, ny);\n\t\t\t  if(wall.count(np) || d.count(np)) {\n\t\t\t\tcontinue;\n\t\t\t  }\n\n\t\t\t  d[np] = d[p] + 1;\n\t\t\t  q.push(np);\n\t\t\t}\n\t\t}\n\n\t\tcout << d.size() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nvoid solve(int t, int n) {\n    int a[n], b[n];\n    rep(i, n) {\n        cin >> a[i] >> b[i];\n    }\n    int stx, sty;\n    cin >> stx >> sty;\n    rep(i, n) {\n        a[i] -= stx; b[i] -= sty;\n    }\n    queue<pair<pii, int> > q;\n    q.push({{0, 0}, 0});\n    set<pii> s;\n    s.insert({0, 0});\n    while (!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        int step = q.front().second;\n        q.pop();\n        if (step == t) continue;\n        rep(i, 6) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 31 || ny >= 31) continue;\n            int flg = 0;\n            rep(j, n) {\n                if (nx == a[j] && ny == b[j]) {\n                    flg = 1;\n                    break;\n                }\n            }\n            if (flg) continue;\n            q.push({{nx, ny}, step + 1});\n            s.insert({nx, ny});\n        }\n    }\n    cout << s.size() << endl;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    while (cin >> t >> n && (t || n)) {\n        solve(t, n);\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint t;\nint dy[]={0,1,-1};\nint dx[]={0,1,-1};\nint ans=0;\nmap<pii,int>mp;\nvoid dfs(pii now,int cnt){\n    if(cnt>t||mp[now]==1)return;\n    if(abs(now.first)>30||abs(now.second)>30)return;\n    mp[now]=1;\n    ans++;\n    //cout<<now.first<<\" \"<<now.second<<endl;\n    rep(i,3)\n    rep(j,3){\n        if(dx[i]+dy[j]==0)continue;\n        dfs(pii(now.first+dx[i],now.second+dy[j]),cnt+1);\n    }\n}\nint main(){\n    int n;\n    while(cin>>t>>n,t+n){\n        map<pii,int>hoge; mp=hoge;\n        ans=0;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=1;\n        }\n        pii p; cin>>p.first>>p.second;\n        dfs(p,0);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define ms(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool fld[200][200];\nint cnt[200][200];\nint dx[] = { 0, -1, -1, 0, 1, 1 };\nint dy[] = { 1, 0, -1, -1, 0, 1 };\n\nint main()\n{\n\tint n, t;\n\twhile (cin >> t >> n, t)\n\t{\n\t\tREP(i, 200)REP(j, 200) cnt[i][j] = INF;\n\t\tms(fld, true);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfld[x + 100][y + 100] = false;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100; sy += 100;\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\tcnt[sx][sy] = 0;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint x = que.front().first;\n\t\t\tint y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (cnt[x][y] >= t) break;\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (fld[nx][ny] && cnt[nx][ny]==INF)\n\t\t\t\t{\n\t\t\t\t\tcnt[nx][ny] = cnt[x][y] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 200)REP(j, 200)\n\t\t{\n\t\t\tif (cnt[i][j] != INF) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 1;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tint field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>20){if(!field[x-1][y]){field[x-1][y] = 1;sum++;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>20){if(!field[x][y-1]){field[x][y-1] = 1;sum++;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<80){if(!field[x+1][y]){field[x+1][y] = 1;sum++;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<80){if(!field[x][y+1]){field[x][y+1] = 1;sum++;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>20 && y>20){if(!field[x-1][y-1]){field[x-1][y-1] = 1;sum++;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<80 && y<80){if(!field[x+1][y+1]){field[x+1][y+1] = 1;sum++;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define rep(X,Y) for(int X=0;X<(Y);++X)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[]={1,1,0,-1,-1,0},dy[]={0,1,1,0,-1,-1};\n\nint d[1000][1000],INF=1000;\n\nint main(){\n  int t,n;\n  while(cin>>t>>n,t||n){\n    fill(d[0],d[0]+1000000,INF);\n    int x,y;\n    rep(i,n){\n      cin>>x>>y;\n      d[y+500][x+500]=-1;\n    }\n    cin>>x>>y;\n    d[y+500][x+500]=0;\n    queue<pii> que;\n    que.emplace(x,y);\n    while(!que.empty()){\n      pii cur=que.front(); que.pop();\n      if(d[cur.Y+500][cur.X+500]>t)break;\n      rep(i,6){\n\tpii nxt=cur;\n\tnxt.X+=dx[i]; nxt.Y+=dy[i];\n\tif(d[nxt.Y+500][nxt.X+500]>d[cur.Y+500][cur.X+500]+1){\n\t  d[nxt.Y+500][nxt.X+500]=d[cur.Y+500][cur.X+500]+1;\n\t  que.push(nxt);\n\t}\n      }\n    }\n    int re=0;\n    rep(i,1000)rep(j,1000)\n      re+=d[i][j]<=t && d[i][j]>=0;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 0 未到達 1 到達 2 障害物あり\nvector<vector<int>> field(200, vector<int>(200, 0));\nint ans;\n\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nint dfs(int x, int y, int limit) {\n    field[y][x] = limit;\n    if (limit == 0) return 0;\n    for (int i = 0; i < 6; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (field[ny][nx] < limit - 1) {\n            dfs(nx, ny, limit - 1);\n        }\n    }\n    return 0;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (1) {\n        int INF = 1000000000;\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                field[i][j] = -1;\n            }\n        }\n        int t, n;\n        cin >> t >> n;\n        if (!t & !n) break;\n        int x, y;\n        for (int i = 0; i < n; i++) {\n            cin >> x >> y;\n            field[y + 100][x + 100] = INF;\n        }\n        cin >> x;\n        cin >> y;\n        ans = 0;\n\n        dfs(x + 100, y + 100, t);\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                if (0 <= field[i][j] && field[i][j] != INF) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define P pair<int,int>\nusing namespace std;\nint m[123][123];\nint main()\n{\n  int n,t,x,y,c,i;\n  P next[] = { P(1,0), P(-1,0), P(0,1), P(0,-1), P(1,1), P(-1,-1), };\n\n  while(cin >> t >> n, (t || n)){\n    memset(m,0,sizeof(m));\n    for(x=0;x<123;x++) m[0][x] = -1;\n    for(x=0;x<123;x++) m[122][x] = -1;\n    for(y=0;y<123;y++) m[y][0] = -1;\n    for(y=0;y<123;y++) m[y][122] = -1;\n    while(n--){\n      cin >> x >> y;\n      m[y+61][x+61] = -1;\n    }\n    queue< P > q;\n    cin >> x >> y;\n    m[y+61][x+61] = 1;\n    q.push( P(x+61,y+61) );\n    c = 1;\n    while(!q.empty()){\n      P p = q.front(); q.pop();\n      if(m[p.second][p.first] > t) continue;\n      for(i=0;i<6;i++){\n\tif(m[p.second + next[i].second][p.first + next[i].first] == 0){\n\t  c++;\n\t  m[p.second + next[i].second][p.first + next[i].first]\n\t    = m[p.second][p.first] + 1;\n\t  q.push( P(p.first + next[i].first, p.second + next[i].second) );\n\t}\n      }\n    }\n    cout << c << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint dx[] = {1, 1, 0, -1, -1, 0};\nint dy[] = {0, 1, 1, 0, -1, -1};\n\nint main() {\n    int t, n;   // ターン数 t, 障害物の数 n\n    while (cin >> t >> n, t) {\n        map<pair<int, int>, int> dp;\n        while (n--) {\n            int x, y; cin >> x >> y;\n            dp[{x, y}] = -1;\n        }\n        int sx, sy; cin >> sx >> sy;\n        queue<pair<pair<int, int>, int>> q;\n        q.emplace(make_pair(sx, sy), t);\n        while (!q.empty()) {\n            auto p = q.front(); q.pop();\n            int cx = p.first.first, cy = p.first.second, t = p.second;\n            if (dp[{cx, cy}] != 0) continue;\n            if (t < 0) continue;\n            dp[{cx, cy}] = 1;\n            for (int i = 0; i < 6; i++) {\n                q.emplace(make_pair(cx + dx[i], cy + dy[i]), t - 1);\n            }\n        }\n        int cnt = 0;\n        for (auto p : dp) if (p.second == 1) cnt++;\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n\nstruct xyt{\n\tint x, y, ti;\n};\n\nbool map[63][63], check[63][63];\nqueue <xyt> q;\nint ans;\n\nvoid search(int x,int y, int n, int t){\n\tint d[6][2] = {{1,1},{1,0},{0,1},{-1,0},{0,-1},{-1,-1}};\n\txyt s;\n\t//cout << x-31 << \" \" << y-31;\n\tans++;\n\tif(n<t){\n\t\tfor(int k=0;k<6;k++){\n\t\t\tif(map[x+d[k][0]][y+d[k][1]]==0 && check[x+d[k][0]][y+d[k][1]]==0){\n\t\t\t\tcheck[x+d[k][0]][y+d[k][1]]=1;\n\t\t\t\ts.x = x+d[k][0];\n\t\t\t\ts.y = y+d[k][1];\n\t\t\t\ts.ti = n+1;\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n\tq.pop();\n\tif(!q.empty())search(q.front().x, q.front().y, q.front().ti, t);\n}\n\nint main(){\n\tint i, j, t, n, x, y;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t==0&&n==0) break;\n\t\tfor(i=-31;i<=31;i++){\n\t\t\tfor(j=-31;j<=31;j++){\n\t\t\t\tcheck[i+31][j+31] = 0;\n\t\t\t\tif(j>=0&&i==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i>=0&&j==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(j<=0&&i==-31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i<=0&&j==-31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i+j==31) map[i+31][j+31] = 1;\n\t\t\t\telse if(i+j==-31) map[i+31][j+31] = 1;\n\t\t\t\telse map[i+31][j+31] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tmap[x+31][y+31] = 1;\n\t\t}\n\t\tans = 0;\n\t\tcin >> x >> y;\n\t\tcheck[x+31][y+31] = 1;\n\t\txyt a;\n\t\ta.x = x + 31;\n\t\ta.y = y +31;\n\t\ta.ti = 0;\n\t\tq.push(a);\n\t\tsearch(q.front().x, q.front().y, q.front().ti, t);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint d[]={0,1,-1};\n#define piii pair<pii,int>\npiii _pi(pii t,int h) {piii hoge; hoge.first=t; hoge.second=h; return hoge;}\nint main(){\n    int t,n;\n    while(cin>>t>>n, t+n){\n        map<pii,int>mp;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            temp=pii(temp.first+300,temp.second+300);\n            mp[temp]++;\n        }\n        pii s; cin>>s.first>>s.second;\n        vvi visit(1001,vi(1001,INF));\n        queue<pii>que;\n        que.push(pii(s.first+300,s.second+300));\n        visit[s.first+300][s.second+300]=0;\n        int ans=1;\n        while(!que.empty()){\n            pii now=que.front(); que.pop();\n            if(visit[now.first][now.second]+1>t)continue;\n            rep(i,3)rep(j,3){\n                if(d[i]+d[j]==0)continue;\n                pii hoge=pii(now.first+d[i],now.second+d[j]);\n                if(mp[hoge])continue;\n                if(visit[hoge.first][hoge.second]==INF)ans++;\n                else continue;\n                if(visit[hoge.first][hoge.second]<visit[now.first][now.second]+1)continue;\n                visit[hoge.first][hoge.second]=visit[now.first][now.second]+1;\n                que.push(hoge);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int t,n;\n    cin>>t>>n;\n    if(!t)break;\n    vector<vector<int>> m(61,vector<int>(61));\n    vector<vector<int>::iterator> vitr(61);\n    REP(i,61) vitr[i] = begin(m[i]) + 30;\n    auto grid = begin(vitr) + 30;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      grid[x][y] = 1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    set<tuple<int,int>> vis;\n    vis.insert(make_tuple(sx,sy));\n    queue<tuple<int,int,int>> q;\n    q.push(make_tuple(0,sx,sy));\n    while(!q.empty()){\n      int i,j,d;\n      tie(d,i,j) = q.front();q.pop();\n      if(d==t)continue;\n      int di[] = {1,1,0,-1,-1,0};\n      int dj[] = {1,0,-1,-1,0,1};\n      REP(k,6){\n        int ni=i+di[k];\n        int nj=j+dj[k];\n        if(abs(ni)>30||abs(nj)>30)continue;\n        if(grid[ni][nj] == 1) continue;\n        if(vis.find(make_tuple(ni,nj)) != end(vis))continue;\n        vis.insert(make_tuple(ni,nj));\n        q.push(make_tuple(d+1,ni,nj));\n      }\n    }\n    cout << vis.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll;\n\nint g[100][100];\nint dx[6] = { 0,1,1,0,-1,-1 };\nint dy[6] = { 1,1,0,-1,-1,0 };\n\nint main()\n{\n\tint t, n;\n\tVi va;\n\twhile (cin >> t >> n && (t || n)) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tint a, b;\n\t\trep(i, 0, n) {\n\t\t\tcin >> a >> b;\n\t\t\ta += 50, b += 50;\n\t\t\tg[a][b] = 2;\n\t\t}\n\t\tcin >> a >> b;\n\t\ta += 50, b += 50;\n\t\tg[a][b]++;\n\t\tint ans = 1;\n\n\t\trep(k, 0, t) {\n\t\t\tset<Pii> s;\n\t\t\trep(x, 1, 99) rep(y, 1, 99) {\n\t\t\t\tif (g[x][y] == 1) {\n\t\t\t\t\tg[x][y]++;\n\t\t\t\t\trep(l, 0, 6) {\n\t\t\t\t\t\tint nx = x + dx[l];\n\t\t\t\t\t\tint ny = y + dy[l];\n\t\t\t\t\t\tif (g[nx][ny] == 0) {\n\t\t\t\t\t\t\ts.insert(Pii(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (int)s.size();\n\t\t\tfor (auto p: s) g[p.first][p.second]++;\n\t\t}\n\t\tva.pb(ans);\n\t}\n\tfor (auto a:va) cout << a << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\nconst int N = 1001;\n\nstruct point{ int x, y; };\nstatic const int dy[6] = {0,1,1,0,-1,-1};\nstatic const int dx[6] = {1,1,0,-1,-1,0};\n\nint bfs(bool *M, int x, int y, int t){\n    int temp[N * N];\n    int *dis = temp + (N / 2 * N + N / 2);\n\n    queue<point> q;\n    rep(i, N * N) temp[i] = INF;\n    point start_coordinate = {x, y};\n\n    dis[start_coordinate.y * N + start_coordinate.x] = 0;\n    q.push(start_coordinate);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,6){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= -1 * N / 2 && next.y <= N / 2 && next.x >= -1 * N / 2 && next.x <= N / 2){\n                if(dis[next.y * N + next.x] == INF && M[next.y * N + next.x] == 0){\n                    dis[next.y * N + next.x] = dis[u.y * N + u.x] + 1;\n                    //cout << next.x <<' '<<next.y<< endl;\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    int cnt = 0;\n    rep(i, N * N){\n        if(temp[i] <= t) cnt++;\n    }\n    return cnt;\n}\n\nint main(){\n    int t, n, sx, sy;\n    while(cin >> t >> n, t||n){\n        bool M[N * N] = {0};\n        bool *atl = M + (N / 2 * N + N / 2);\n        rep(i,n){\n            int x, y;\n            cin >> x >> y;\n            atl[y * N + x] = 1;\n        }\n        cin >> sx >> sy;\n        cout << bfs(atl, sx, sy, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[100][100];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 50;\n      Y += 50;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 50;\n    sy += 50;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint turn;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tint map[100][100];\n\t\tbool object[100][100];\n\t\tmemset(object, false, sizeof(object));\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobject[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<data> q;\n\t\tdata f;\n\t\tf.cx = sx + 50;\n\t\tf.cy = sy + 50;\n\t\tf.turn = 0;\n\t\tmap[f.cy][f.cx] = 0;\n\t\tq.push(f);\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\td.turn++;\n\t\t\tif (d.turn > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = d.cx + dx[i];\n\t\t\t\tint ny = d.cy + dy[i];\n\t\t\t\t\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 100 || ny >= 100)continue;\n\t\t\t\tif (object[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] >= d.turn)continue;\n\t\t\t\tmap[ny][nx] = d.turn;\n\t\t\t\tdata next;\n\t\t\t\tnext.cx = nx;\n\t\t\t\tnext.cy = ny;\n\t\t\t\tnext.turn = d.turn;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MAX)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// AOJ 2253\n\n#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <int, int> P;\n\nint field[200][200];\nint wall[200][200];\nint num[200][200];\nint dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {1, 0, -1, -1, 0, 1};\nint t;\n\nint main(void)\n{\n\tint n;\n\twhile (cin >> t >> n){\n\t\tif (t == 0 && n == 0) break;\n\t\tint y, x;\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tfor (int j = 0; j < 200; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tnum[i][j] = 0;\n\t\t\t\twall[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\ty += 100;\n\t\t\tx += 100;\n\t\t\twall[y][x] = 1;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tsx += 100;\n\t\tsy += 100;\n\t\tfield[sy][sx] = t + 1;\n\n\t\tint ret = 0;\n\t\tqueue <P> q;\n\t\tq.push(P(sy, sx));\n\t\twhile (q.size()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\tint y = p.first, x = p.second;\n\t\t\t// cout << \"DEBUG : \" << y-100 << \" \" << x-100 << \" \" << field[y][x] << endl;\n\t\t\t// field[p.first][p.second] |= 1;\n\t\t\t// さいごのたーん\n\t\t\tif (field[y][x] == 1) break;\n\t\t\tfor (int i = 0; i < 6; i++){\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif (ny < 0 || nx < 0 || 200 <= ny || 200 <= nx) continue;\n\t\t\t\tif (field[ny][nx] == 0 && wall[ny][nx] == 0){\n\t\t\t\t\tfield[ny][nx] = (field[y][x] - 1);\n\t\t\t\t\tq.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tfor (int j = 0; j < 200; j++){\n\t\t\t\tif (0 < field[i][j]) {\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint t,n;\n\tcin >> t >> n;\n\n\twhile ( t != 0 || n != 0 ) {\n\t\tstd::map< std::pair<int,int>, int> area;\n\t\tstd::pair<int,int> now,temp;\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tcin >> temp.first >> temp.second;\n\t\t\tarea[temp] = -1;\n\t\t}\n\n\t\tint count_area = 1;\n\t\tcin >> now.first >> now.second;\n\t\tstd::queue< std::pair<int,int> > search;\n\t\tstd::queue<int> d;\n\t\tsearch.push(now);\n\t\td.push(0);\n\t\tint turn = 0;\n\n\t\twhile ( (turn < t) && !(d.empty()) ) {\n\t\t\tnow = search.front();\n\t\t\ttemp = now;\n\t\t\tarea[temp] = -1;\n\n\t\t\tturn = d.front();\n\t\t\tsearch.pop();\n\t\t\td.pop();\n\n\t\t\tif ( turn < t ) {\n\t\t\t\ttemp.first++;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t\ttemp.second++;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t\ttemp.first--;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t\ttemp.first--;\n\t\t\t\ttemp.second--;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t\ttemp.second--;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t\ttemp.first++;\n\t\t\t\tif (area[temp] != -1) {\n\t\t\t\t\tsearch.push(temp);\n\t\t\t\t\td.push(turn+1);\n\t\t\t\t\tcount_area++;\n\t\t\t\t\tarea[temp] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count_area << endl;\n\t\tcin >> t >> n;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 600;\n\nclass S{\npublic:\n  int y, x, c;\n};\n\nint t, n, sy, sx;\nbool mapData[N][N];\nbool visited[N][N];\nint dy[] = {1, 0, -1, -1, 0, 1};\nint dx[] = {1, 1, 0, -1, -1, 0};\n\nint bfs(){\n  int res = 0;\n  fill(visited[0], visited[N], false);\n  S u, v;\n  queue<S> q;\n  u.y = sy;\n  u.x = sx;\n  u.c = 0;\n  q.push(u);\n  visited[sy][sx] = true;\n  res++;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    if(u.c >= t) continue;\n    for(int i=0;i<6;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(!mapData[ny][nx]) continue;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = true;\n      res++;\n      v.y = ny;\n      v.x = nx;\n      v.c = u.c+1;\n      q.push(v);\n    }\n  }\n  return res;\n}\n\n\nmain(){\n  while(cin >> t >> n && (t|n)){\n    fill(mapData[0], mapData[N], true);\n    for(int i=0;i<n;i++){\n      int y, x;\n      cin >> x >> y; \n      mapData[y+N/2][x+N/2] = false;\n    }\n    cin >> sx >> sy;\n    sx += N/2;\n    sy += N/2;\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n//[-30,30] -> [0,60]\nint f[61][61];\n\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\n\nint main(){\n    int t,n;\n    \n    while(cin >> t >> n){\n        if((t|n) == 0) break;\n        memset(f,0,sizeof(f));\n        int x,y;\n        vector<pair<int,int> > diff;\n\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            f[x+30][y+30] = -1;\n        }\n\n        cin >> x >> y;\n        x += 30;\n        y += 30;\n        f[x][y] = 1;\n        \n        for(int i=0;i<t;i++){\n            for(int p=0;p<61;p++){\n                for(int q=0;q<61;q++){\n                    if(f[p][q] == 1){\n                        for(int k=0;k<6;k++){\n                            x = p + dx[k];\n                            y = q + dy[k];\n\n                            if(0 <= x && x < 61 &&\n                               0 <= y && y < 61 &&\n                                f[x][y] != -1){\n                                diff.push_back(make_pair(x,y));\n                            }\n                        }\n                    }\n                }\n            }\n            for(int j=0;j<diff.size();j++){\n                f[diff[j].first][diff[j].second] = 1;\n            }\n            diff.clear();\n        }\n        int ret = 0;\n\n        for(int i=0;i<61;i++){\n            for(int j=0;j<61;j++){\n                if(f[i][j] == 1) ret++;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {1,0,-1,-1,0,1};\n\nint t, n, sx, sy, ans, diff = 200;\nbool visited[300][300][31];  //(a, b) -> visited[a+30][b+30]\nbool obj[300][300];\n\nvoid dfs(int y, int x, int turn){\n  if(visited[y+diff][x+diff][turn]) return;\n  if(turn > t) return;\n\n  bool flag = true;\n  REP(i,0,31){\n    if(visited[y+diff][x+diff][i]) flag = false;  /*??\\????????¨?????????*/\n  }\n  if(flag) ans++;\n\n  visited[y+diff][x+diff][turn] = true;\n\n  REP(k,0,6){\n    int nx = x + dx[k], ny = y + dy[k];\n    //if(!CH(ny+100, 0, 61) || !CH(nx+100, 0, 61)) continue;\n    if(obj[ny+diff][nx+diff]) continue;\n    dfs(ny, nx, turn + 1);\n  }\n  return;\n}\n\nint main() {\n  //test\n  //vector<int> v;\n\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0) break;\n    REP(i,0,300)REP(j,0,300) obj[i][j] = false;\n    REP(i, 0, n){\n      int x, y;\n      cin>>x>>y;\n      obj[y+diff][x+diff] = true;\n    }\n    cin>>sx>>sy;\n\n    REP(i,0,300)REP(j,0,300)REP(k,0,31) visited[i][j][k] = false;\n    ans = 0;\n\n    dfs(sy, sx, 0);\n\n    cout<<ans<<endl;\n    //v.push_back(ans);\n  }\n\n  //REP(i,0,v.size()) cout<<v[i]<<\" \";\n  cout<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int t,n;\n    cin>>t>>n;\n    if(!t)break;\n    vector<vector<int>> m(121,vector<int>(121));\n    vector<vector<int>::iterator> vitr(121);\n    REP(i,121) vitr[i] = begin(m[i]) + 60;\n    auto grid = begin(vitr) + 60;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      grid[x][y] = 1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    set<tuple<int,int>> vis;\n    vis.insert(make_tuple(sx,sy));\n    queue<tuple<int,int,int>> q;\n    q.push(make_tuple(0,sx,sy));\n    while(!q.empty()){\n      int i,j,d;\n      tie(d,i,j) = q.front();q.pop();\n      if(d==t)continue;\n      int di[] = {1,1,0,-1,-1,0};\n      int dj[] = {1,0,-1,-1,0,1};\n      REP(k,6){\n        int ni=i+di[k];\n        int nj=j+dj[k];\n        if(grid[ni][nj] == 1) continue;\n        if(vis.find(make_tuple(ni,nj)) != end(vis))continue;\n        vis.insert(make_tuple(ni,nj));\n        q.push(make_tuple(d+1,ni,nj));\n      }\n    }\n    cout << vis.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nbool mp[100][101]={};\nbool vis[100][100]={};\nint dx[6]={1,0,-1,-1,0,1};\nint dy[6]={1,1,0,-1,-1,0};\n\nint bfs(int y,int x,int t){\n  vis[y][x]=true;\n  queue<tuple<int,int,int>> q;\n  q.emplace(x,y,t);\n  while(!q.empty()){\n    int a,b,c;\n    tie(a,b,c)=q.front();\n    q.pop();\n    rep(i,6){\n      int na=a+dx[i];\n      int nb=b+dy[i];\n      if(0<c&&0<=na&&na<=60&&nb<=60&&0<=nb&&!mp[nb][na]&&!vis[nb][na]){\n        vis[nb][na]=true;\n        q.emplace(na,nb,c-1);\n      }\n    }\n  }\n  int cnt=0;\n  rep(i,100)rep(j,100)cnt+=vis[i][j];\n  return cnt;\n}\n\nsigned main(){\n  int t,n;\n  while (cin>>t>>n,t) {\n    memset(vis,0,sizeof(vis));\n    memset(mp,0,sizeof(mp));\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      x+=30;y+=30;\n      mp[y][x]=true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    sx+=30;sy+=30;\n    cout<<bfs(sy,sx,t)<<endl;\n\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#define MAXX 2000\n#define MAXY 2000\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\n//深さ優先の再帰関数\nvoid solve2(int x,int y,int depth){\n\t//深さ0で終了\n\tif(depth==0) return;\n\t//x,y点周辺を探索済みにする\n\tfor(int i=0;i<6;i++)\n\t\tflg[x+xd[i]][y+yd[i]]=true;\n\t//x,y点周辺でかつ，障害物のない点を探索する\n\tfor(int i=0;i<6;i++)\n\t\tif(mp[x+xd[i]][y+yd[i]])\n\t\t\tsolve2(x+xd[i],y+yd[i],depth-1);\n}\n\n//再帰関数を呼び出し，数え上げるための関数\nint solve(int x,int y,int depth){\n\tint cnt=0;\n\t//始点を探索済みにする\n\tflg[x][y]=true;\n\t//始点より深さ優先\n\tsolve2(x,y,depth);\n\t//すべての点について\n\tfor(int i=0;i<MAXX;i++)\n\t\tfor(int j=0;j<MAXY;j++)\n\t\t\t//障害物がなく，探索済みな点の数を数え上げる\n\t\t\tif(mp[i][j]&&flg[i][j]) cnt++;\n\t//解を出力\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[cX+x][cY+y]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t\t//実行・解の表示\n\t\tcout << solve(cX+x,cX+y,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nint d[140][140];\nbool blocked[140][140];\nint X_OFFSET = 60;\nint Y_OFFSET = 60;\nint X_size = 140;\nint Y_size = 140;\nint move_x[6] = {-1, 1, 0, 0, -1, 1};\nint move_y[6] = {0, 0, -1, 1, -1, 1};\nint main(){\n  while(true){\n    int t;\n    int n;\n    cin >> t >> n;\n    if(t == 0 && n == 0){\n      break;\n    }\n\n    for(int i = 0; i <= X_size; i++){\n      for(int j = 0; j <= Y_size; j++){\n        d[i][j] = INT_MAX;\n        blocked[i][j] = false;\n      }\n    }\n\n    for(int i = 0; i < n; i++){\n      int x;\n      int y;\n      cin >> x >> y;\n      blocked[x + X_OFFSET][y + Y_OFFSET] = true;\n    }\n\n    int start_x;\n    int start_y;\n    cin >> start_x >> start_y;\n    start_x += X_OFFSET;\n    start_y += Y_OFFSET;\n\n    d[start_x][start_y] = 0;\n    queue <pair <int, int> > q;\n    q.push(make_pair(start_x, start_y));\n\n    int ans = 1;\n    while(!q.empty()){\n      int cur_x = q.front().first;\n      int cur_y = q.front().second;\n      q.pop();\n\n      if(d[cur_x][cur_y] < t){\n        for(int i = 0; i < 6; i++){\n          int next_x = cur_x + move_x[i];\n          int next_y = cur_y + move_y[i];\n          if(!blocked[next_x][next_y] && d[next_x][next_y] == INT_MAX){\n            d[next_x][next_y] = d[cur_x][cur_y] + 1;\n            ans ++;\n            q.push(make_pair(next_x, next_y));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint search(int x, int y, int t, int n);\n\nint visited[64][64] = {};\nvector<int> t;\nvector<int> n;\nvector<vector<int> > xdata;\nvector<vector<int> > ydata;\nint main(void){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n\n  int tt,nn,ss;\n  int x,y;\n  int i,j,k;\n  i=0;\n\n  //input data\n  while(1){\n    cin >> tt >> nn;\n    if(tt==0 && nn==0)break;\n    t.push_back(tt);\n    n.push_back(nn);\n    vector<int> xt;\n    vector<int> yt;\n    xdata.push_back(xt);\n    ydata.push_back(yt);\n    for(j=0;j<nn;j++){\n      cin >> x >> y;\n      xdata[i].push_back(x+30);\n      ydata[i].push_back(y+30);\n    }\n    cin >> x >> y;\n    xdata[i].push_back(x+30);\n    ydata[i].push_back(y+30);\n    i++;\n  }\n  int n = i; //number of data\n  for(i=0;i<n;i++){\n    for(j=0;j<64;j++){\n      for(k=0;k<64;k++){\n        visited[j][k]=0;\n      }\n    }\n    //cout << search(xdata[i][xdata[i].size()-1],ydata[i][ydata[i].size()-1],t[i]+1,i) << endl;\n  }\n}\n\nint search(int x, int y, int t, int n){\n  //if(t==0)return 0;\n  int flag=0;\n  for(int i=0;i<xdata[n].size()-1;i++){\n    if(xdata[n][i] == x && ydata[n][i] ==y)flag=1;\n  }\n  if(flag==1)return 0;\n  int ans = 0;\n  if(t==1){\n    if(visited[x][y]==1) return ans;\n    else {visited[x][y]=1;return ans+1;}\n  }\n  ans+=search(x-1,y,t-1,n);\n  ans+=search(x-1,y-1,t-1,n);\n  ans+=search(x+1,y,t-1,n);\n  ans+=search(x+1,y+1,t-1,n);\n  ans+=search(x,y-1,t-1,n);\n  ans+=search(x,y+1,t-1,n);\n  if(visited[x][y]==1) return ans;\n  else {visited[x][y]=1;return ans+1;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int x,y;\n  int dx[] = {1,0,1,-1,0,-1};\n  int dy[] = {0,1,1,0,-1,-1};\n  int map[200][200];\n  int t,n,ans;\n  queue<int> qx,qy;\n\n  while(1){\n    cin >> t >> n;\n    if(!t && !n)break;\n\n    memset(map,0,sizeof(map));\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      map[100+y][100+x] = -1;\n    }\n\n    cin >> x >> y;\n    map[100+y][100+x] = 1;\n    qx.push(x);\n    qy.push(y);\n\n    ans = 1;\n    while(qx.size()){\n      x = qx.front();\n      y = qy.front();\n      qx.pop();\n      qy.pop();\n\n      if(map[100+y][100+x]<=t){\n\tfor(int i=0;i<6;i++){\n\t  if(map[100+y+dy[i]][100+x+dx[i]] == 0){\n\t    qx.push(x+dx[i]);\n\t    qy.push(y+dy[i]);\n\t    map[100+y+dy[i]][100+x+dx[i]] = map[100+y][100+x] + 1;\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#pragma warning(disable : 4996)\nusing namespace std;\nint t, n, x, y, a, b, v[123][123]; bool s[123][123];\nint main() {\n\twhile (~scanf(\"%d%d\", &t, &n)) {\n\t\tif (t == 0) break;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\ts[i][j] = true, v[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y); s[y + 61][x + 61] = true;\n\t\t}\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tqueue<pair<int, int> > que; que.push(make_pair(a, b)); v[b][a] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint x = que.front().first;\n\t\t\tint y = que.front().second; que.pop();\n\t\t\tif (v[y][x] == t) continue;\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tif (i + j && v[y + i][x + j] == -1 && !s[y + i][x + j]) {\n\t\t\t\t\t\tv[y + i][x + j] = v[y][x] + 1;\n\t\t\t\t\t\tque.push(make_pair(x + j, y + i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i <= 122; i++) {\n\t\t\tfor (int j = 0; j <= 122; j++) {\n\t\t\t\tif (v[i][j] != -1) ret++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint hoge[63][63];\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {0,1,1,0,-1,-1};\n\nvoid f(int x, int y, int t, int& ans){\n\tif(hoge[x][y]==0) ans++;\n\thoge[x][y] = t+1;\n\tif(t==0) return;\n\tfor(int i=0;i<6;i++){\n\t\tint x2 = x+dx[i];\n\t\tint y2 = y+dy[i];\n\t\tif(hoge[x2][y2] != -1 && hoge[x2][y2] < t){\n\t\t\tf(x2, y2, t-1, ans);\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve(){\n\twhile(1){\n\t\tint t,n;\n\t\tcin>> t>> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int i=0;i<63;i++){\n\t\t\tfor(int j=0;j<63;j++){\n\t\t\t\tif(i==0 || j==0 || i==62 || j==62){\n\t\t\t\t\thoge[i][j] = -1;\n\t\t\t\t}else{\n\t\t\t\t\thoge[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>> x>> y;\n\t\t\tx += 31;\n\t\t\ty += 31;\n\t\t\thoge[x][y] = -1;\n\t\t}\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\tx += 31;\n\t\ty += 31;\n\t\t\n\t\tint ans = 0;\n\t\tf(x, y, t, ans);\n\t\tcout<< ans<< endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,n-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n \nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\n\nstruct state {\n\tint x, y, t;\n\tstate(int xx, int yy, int tt) {\n\t\tx = xx;\n\t\ty = yy;\n\t\tt = tt;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(121, vi(121, 0));\n\t\tqueue<state> Q;\n\n\t\tint x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = 1;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tQ.push(state(sx, sy, 0));\n\t\tfield[sx+30][sy+30] = 1;\n\t\tint count = 1;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\t\t\tREP(d, 6) {\n\t\t\t\tif(abs(st.x+dx[d]) <= 60 && abs(st.y+dy[d]) <= 60) {\n\t\t\t\t\tif(field[st.x+dx[d]+30][st.y+dy[d]+30] == 0) {\n\t\t\t\t\t\tfield[st.x+dx[d]+30][st.y+dy[d]+30] = 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif(st.t+1 < t) {\n\t\t\t\t\t\t\tQ.push(state(st.x+dx[d], st.y+dy[d], st.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<int, int> P;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t, n;\n  bool cango[100][100];\n  int vy[6] = {1,0,-1,-1,0,1};\n  int vx[6] = {1,1,0,-1,-1,0};\n  while(cin>>t>>n,t||n) {\n    FOR(i,0,100) FOR(j,0,100) cango[i][j] = true;\n    FOR(i,0,n) {\n      int x, y; cin >> x >> y;\n      cango[y+50][x+50] = false;\n    }\n    int sx, sy; cin >> sx >> sy;\n    int ans = 1;\n    queue<P> Q;\n    Q.push(P(sy+50, sx+50));\n    cango[sy+50][sx+50] = false;\n    FOR(i,0,t) {\n      vector<P> tmp;\n      while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        int y = p.first;\n        int x = p.second;\n        FOR(j,0,6) {\n          int ny = y + vy[j];\n          int nx = x + vx[j];\n          if(!cango[ny][nx]) continue;\n          ans++;\n          tmp.push_back(P(ny, nx));\n          cango[ny][nx] = false;\n        }\n      }\n      FOR(j,0,tmp.size()) {\n        Q.push(tmp[j]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = { 1,1,0,-1,-1,0 };\nconst int dy[] = { 0,1,1,0,-1,-1 };\nconst int geta = 30;\n\nint main()\n{\n\twhile (true) {\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\t\n\t\tif (t == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint map[61][61];\n\t\tfor (int i = 0; i < 61; i++) {\n\t\t\tfor (int j = 0; j < 61; j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tmap[y + geta][x + geta] = 1;\n\t\t}\n\n\t\tint startx, starty;\n\t\tcin >> startx >> starty;\n\n\t\tint ans = 1;\n\t\tint now = 0;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push({ starty + geta,startx + geta });\n\t\tmap[starty + geta][startx + geta] = 1;\n\n\t\twhile (q.empty() == false) {\n\t\t\tunsigned int count = q.size();\n\n\t\t\twhile (count > 0) {\n\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tcount--;\n\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint ny = temp.first + dy[i];\n\t\t\t\t\tint nx = temp.second + dx[i];\n\n\t\t\t\t\tif (ny >= 0 && ny < 61 && nx >= 0 && nx < 61 && map[ny][nx] == 0) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tmap[ny][nx] = 1;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow++;\n\t\t\tif (now == t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"ctime\"\n#include \"chrono\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n#include \"list\"\n#include \"climits\"\n\nusing namespace std;\n\n\nint main() {\n\t\n\tint dir_y[] = { 1,1,0,-1,-1,0 };\n\tint dir_x[] = { 0,1,1,0,-1,-1 };\n\tint N, K;\n\tlist<int>ret;\n\tcin >> N >> K;\n\twhile (N) {\n\t\tvector<vector<int>>v(100, vector<int>(100, INT_MAX));\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tint y, x;\n\t\t\tcin >> y >> x;\n\t\t\ty += 50;\n\t\t\tx += 50;\n\t\t\tv[y][x] = -1;\n\t\t}\n\t\tint sy, sx;\n\t\tcin >> sy >> sx;\n\t\tsy += 50;\n\t\tsx += 50;\n\t\tqueue<pair<int,int>>Q;\n\t\tQ.push({ sy,sx });\n\t\tv[sy][sx] = 0;\n\t\tint cnt = 0;\n\t\twhile (cnt<=N&&!Q.empty()) {\n\t\t\tint cy = Q.front().first;\n\t\t\tint cx = Q.front().second;\n\t\t\tcnt = max(cnt, v[cy][cx] + 1);\n\t\t\tQ.pop();\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint ny = cy + dir_y[i];\n\t\t\t\tint nx = cx + dir_x[i];\n\t\t\t\tif (v[ny][nx]>cnt) {\n\t\t\t\t\tv[ny][nx] = cnt;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (auto i : v) {\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j >= 0 && j <= N) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret.push_back(ans);\n\t\tcin >> N >> K;\n\t}\n\tfor (auto i : ret) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#ifdef DEBUG\n#define line() cout << \"[\" << __LINE__ << \"] \";\n#define dump(i) cout << #i \": \" << i << \" \";\n#define dumpl(i) cout << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError\n{\n};\n\nint main(int argc, char const *argv[])\n{\n    pair<int, int> d[] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}};\n    while (true)\n    {\n        map<pair<int, int>, bool> block;\n        map<pair<int, int>, bool> mp;\n        deque<pair<int, int>> que;\n        ll ans = 0;\n        int t, n;\n        cin >> t >> n;\n        if (t == 0 && n == 0)\n            break;\n        rep(i, n)\n        {\n            pair<int, int> p;\n            cin >> p.first >> p.second;\n            block[p] = true;\n        }\n        pair<int, int> p;\n        cin >> p.first >> p.second;\n        que.push_back(p);\n        mp[p] = true;\n        ans++;\n        rep(_, t)\n        {\n            deque<pair<int, int>> next;\n            while (!que.empty())\n            {\n                pair<int, int> pos = que.back();\n                int x = pos.first;\n                int y = pos.second;\n\n                que.pop_back();\n                rep(i, 6)\n                {\n                    int nx = x + d[i].first;\n                    int ny = y + d[i].second;\n                    if (block[{nx, ny}] == false && mp[{nx, ny}] == false)\n                    {\n                        mp[{nx, ny}] = true;\n                        next.push_back({nx, ny});\n                        ans++;\n                    }\n                }\n            }\n            while (!next.empty())\n            {\n                que.push_back(next.back());\n                next.pop_back();\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint foo(int map[80][80], int x, int y, int t){//if(!map[y][x])cout<<t<<\" \"<<y<<\" \"<<x<<\" \"<<map[y][x]<<endl;\n\tif(map[y][x]==-1)return 0;\n\tif(map[y][x] >= t+1)return 0;\n\tint ans = (map[y][x]==0);\n\tif(!t){map[y][x]=t+1;return ans;}\n\tmap[y][x] = t+1;\n\tfor(int i = -1; i <= 1; i++){\n\t\tfor(int j = -1; j <= 1; j++){\n\t\t\tif((i==1&&j==-1)||(i==-1&&j==1)||(i==0&&j==0))continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tans += foo(map,x+i,y+j,t-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint t, n, map[80][80] = {},x,y;\n\t\tcin>>t>>n;\n\t\tif(!t&&!n)break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>x>>y;\n\t\t\tmap[y+40][x+40] = -1;\n\t\t}\n\t\tcin>>x>>y;\n\t\tcout<<foo(map,40+x,40+y,t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\ntypedef pair<pii,int>piii;\nint dx[]={0,-1,1};\nint dy[]={0,-1,1}\n;int main(){\n    int t,n;\n    while(cin>>t>>n){\n        int ans=0;\n        if(t+n==0)break;\n        map<pii,int>mp;\n        pii s;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            mp[temp]=-INF;\n        }\n        cin>>s.first>>s.second;\n        queue<piii>que;\n        que.push(make_pair(s,0));\n        while(!que.empty()){\n            piii now=que.front();que.pop();\n            if(abs(now.first.first)>30||abs(now.first.second)>30)continue;\n            if(now.second>t)continue;\n            if(now.second>mp[now.first]&&mp[now.first]!=0)continue;\n            if(mp[now.first]==0)ans++;\n            mp[now.first]=now.second;\n            if(now.first==s)mp[s]=-INF;\n            rep(i,3)rep(j,3){\n                if(dx[i]+dy[j]==0)continue;\n                pii next=pii(now.first.first+dx[i],now.first.second+dy[j]);\n                if(mp[next]==-INF)continue;\n                piii hoge;\n                hoge.first=next;\n                hoge.second=now.second+1;\n                que.push(hoge);\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30;\n        s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto ele=q.front();\n            auto p=ele.first;\n            int turn=ele.second;\n            if(turn==t)\n                continue;\n            if(turn>t)\n                for(;;){}\n\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    if(turn==t)\n                    continue;\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n \nusing namespace std;\n  \n#define NMAX 50\n \ntypedef map<int,bool>::value_type VT;\n \nstruct data{\n    int x,y,turn;\n};\n \nint main(void){\n     \n    int t,n;\n    int x,y;\n    map<int,bool> road,ok[31];\n    stack<data> no;\n    data tm,da;\n    int dx[]={1,1,0,-1,-1,0};\n    int dy[]={0,1,1,0,-1,-1};\n    int cnt;\n \n    for(int i=-31;i<=31;i++){\n        for(int j=-31;j<=31;j++){\n            road.insert(VT(i+j*100,true));\n            for(int k=0;k<31;k++){\n                ok[k].insert(VT(i+j*100,true));\n            }\n        }\n    }\n    while(1){\n        cin>>t>>n;\n        if(t==0&&n==0) break;\n        for(int i=-30;i<=30;i++){\n            for(int j=-30;j<=30;j++){\n                road[i+j*100]=true;\n                for(int k=0;k<31;k++){\n                    ok[k][i+j*100]=true;\n                }\n            }\n        }\n        for(int i=-31;i<=31;i++){\n            road[-31+i*100]=false;\n            road[31+i*100]=false;\n            road[i+31*100]=false;\n            road[i-31*100]=false;\n        }\n \n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            road[y+x*100]=false;\n        }\n        cin>>x>>y;\n        tm.x=x,tm.y=y,tm.turn=0;\n        no.push(tm);\n        cnt=1;\n        while(!no.empty()){\n            tm=no.top();\n            no.pop();\n            if(tm.turn==t){\n                if(ok[tm.turn][tm.y+tm.x*100]==true){\n                    ok[tm.turn][tm.y+tm.x*100]=false;\n                    cnt++;\n                }\n                continue;\n            }\n            for(int i=0;i<6;i++){\n                if(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==true&&ok[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]==true){\n                    ok[tm.turn][(tm.y+dy[i])+(tm.x+dx[i])*100]=false;\n                    da.x=tm.x+dx[i];\n                    da.y=tm.y+dy[i];\n                    da.turn=tm.turn+1;\n                    no.push(da);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n#define llong long long\n#define REP(i,n) for(auto i=0;i<n;++i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define FOR(i,a,b) for(auto i=a;i<b++i)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n\nusing namespace std;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nint main(){\n  while(true){\n    int t,n;cin >> t >> n;\n    if(t == 0 && n == 0)break;\n    vector<vector<int> > m(64, vector<int>(64,0));\n    int x0 = 32, y0 = 32;\n    for(int i = 0; i < n; i++){\n      int x,y; cin >>x >> y;\n      x += x0; y += y0;\n      m[x][y] = -1;\n    }\n    int sx,sy;cin >> sx >> sy;\n    sx += x0; sy += y0;\n    queue<pair<int, int> > q;\n    q.push(make_pair(sx,sy));\n    int ans = 1;\n    while(!q.empty()){\n      auto now = q.front();\n      int turn = m[now.first][now.second];\n      if(now == make_pair(sx,sy)){\n        m[sx][sy] = -1;\n      }\n      q.pop();\n      for(int i = 0;i < 6; i++){\n        int nextx = now.first + dx[i];\n        int nexty = now.second + dy[i];\n        if(m[nextx][nexty] == 0 && turn < t){\n          if(abs(nextx-x0) > 30 || abs(nexty-y0) > 30)continue;\n          q.push(make_pair(nextx,nexty));\n          ans++;\n          m[nextx][nexty] = turn+1;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n          \n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nint ddx[6]={0,1,0,-1,1,-1},ddy[6]={-1,0,1,0,1,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint obs[200][200];\nint sy,sx;\nint t,n;\nint mas[200][200];\n\n\n\nint main(){\n\twhile(1){\n\t\tcin>>t>>n;\n\t\tif(t==0&&n==0)break;\n\t\tREP(i,200)\n\t\t\tREP(j,200){\n\t\t\tobs[i][j]=0;\n\t\t\tmas[i][j]=-1;\n\t\t\t}\n\t\tREP(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tobs[b+100][a+100]=1;\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tsy+=100,sx+=100;\n\t\tint ans=0;\n\t\tqueue<Pi> q;\n\t\tq.push(Pi(sy,sx));\n\t\tmas[sy][sx]=0;\n\t\twhile(q.size()){\n\t\t\tPi tp=q.front();q.pop();\n\t\t\tans++;\n\t\t\tif(mas[tp.first][tp.second]==t)continue;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint ny=tp.first+ddy[i];\n\t\t\t\tint nx=tp.second+ddx[i];\n\t\t\t\tif(mas[ny][nx]==-1&&obs[ny][nx]==0){\n\t\t\t\t\tq.push(Pi(ny,nx));\n\t\t\t\t\tmas[ny][nx]=mas[tp.first][tp.second]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,t;};\nint main(){\n  int t,n,i,j,k,x,y;\n  cin >> t >> n;\n  while(t!=0||n!=0){\n    \n    int m[100][100]={{}};\n    int dis[100][100]={{}};\n    queue <Point> ps;\n    Point p,b;\n    for(i=0;i<n;i++){\n      cin >> x >> y;\n      dis[50+x][50+y]=1;\n    }\n    cin >> p.x  >> p.y;\n    p.x+=50;p.y+=50;\n    m[p.x][p.y]=1;\n    p.t=0;\n    ps.push(p);\n    int o=0;\n    while(!ps.empty()){\n      o++;\n      p=ps.front();\n      ps.pop();\n      if(p.t<t){\n\tif(m[p.x+1][p.y]+dis[p.x+1][p.y]==0){\n\t  b.x=p.x+1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y+1]+dis[p.x][p.y+1]==0){\n\t  b.x=p.x;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x+1][p.y+1]+dis[p.x+1][p.y+1]==0){\n\t  b.x=p.x+1;b.y=p.y+1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y]+dis[p.x-1][p.y]==0){\n\t  b.x=p.x-1;b.y=p.y;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x][p.y-1]+dis[p.x][p.y-1]==0){\n\t  b.x=p.x;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n\tif(m[p.x-1][p.y-1]+dis[p.x-1][p.y-1]==0){\n\t  b.x=p.x-1;b.y=p.y-1;b.t=p.t+1;\n\t  m[b.x][b.y]=1;\n\t  ps.push(b);\n\t}\n      }\n    }\n    cout << o << endl;\n    //cout << t << endl;\n    cin >> t >> n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    \n    while(1){\n\n        int t, n; cin >> t >> n;\n        if(!t) break;\n\n        bool field[200][200];\n        memset(field, true, sizeof(field));\n\n        for(int i = 0; i < n; i++){\n            int x, y; cin >> x >> y;\n            x += 100;\n            y += 100;\n            field[x][y] = false;\n        }\n\n        int x, y; cin >> x >> y;\n        x += 100;\n        y += 100;\n\n\n        //幅優先\n        queue<pair<int, pair<int, int> > > q;      //turn, {x, y}\n        field[x][y] = false;\n        q.push({0, {x, y}});\n\n        int ans = 1;\n        while(!q.empty()){\n\n            int x = q.front().second.first;\n            int y = q.front().second.second;\n            int turn = q.front().first;\n            q.pop();\n            if(turn == t) continue;\n        \n            for(int h = 0; h < 6; h++){\n                int nx = x + dx[h];\n                int ny = y + dy[h];\n\n                if(field[nx][ny]){\n                    field[nx][ny] = false;\n                    q.push({turn + 1, {nx, ny}});\n                    ans++;\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[500][500];\n  int count = 0;\n  queue<State> open;\n  open.push(State(sx,sy,0));\n  memset(closed,0,sizeof(closed));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 250;\n      Y += 250;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 250;\n    sy += 250;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int di[6] = {1, 1, 0, -1, -1, 0};\nconst int dj[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n    while(true){\n        int field[200][200];\n        int cfield[200][200];\n        int t, n;\n        scanf(\"%d%d\", &t, &n);\n        if(t == 0 && n == 0) break;\n        for(int i = 0; i < 200; i++){\n            for(int j = 0; j < 200; j++){\n                field[i][j] = cfield[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            x += 100; y += 100;\n            field[x][y] = cfield[x][y] = -1;\n        }\n        int cx, cy;\n        scanf(\"%d%d\", &cx, &cy);\n        cx += 100; cy += 100;\n        field[cx][cy] = cfield[cx][cy] = 1;\n        bool check = true;\n        for(int i = 0; i < 200; i++){\n            for(int j = 0; j < 200; j++){\n                if(field[i][j] != cfield[i][j]){\n                    check = false;\n                }\n            }\n        }\n        assert(check);\n        for(int _ = 0; _ < t; _++){\n            for(int i = 5; i < 195; i++){\n                for(int j = 5; j < 195; j++){\n                    if(field[i][j] > 0){\n                        for(int d = 0; d < 6; d++){\n                            int ni = i + di[d];\n                            int nj = j + dj[d];\n                            if(cfield[ni][nj] >= 0){\n                                cfield[ni][nj] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            for(int i = 5; i < 195; i++){\n                for(int j = 0; j < 195; j++){\n                    field[i][j] = cfield[i][j];\n                }\n            }\n            bool check = true;\n            for(int i = 0; i < 200; i++){\n                for(int j = 0; j < 200; j++){\n                    if(field[i][j] != cfield[i][j]){\n                        check = false;\n                    }\n                }\n            }\n            assert(check);\n        }\n        int ans = 0;\n        for(int i = 5; i < 195; i++){\n            for(int j = 5; j < 195; j++){\n                if(field[i][j] > 0){\n                    ++ans;\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<utility>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<sstream>\n#include<queue>\nconst int INF=1000000;\n#define mp make_pair\nusing namespace std;\ntypedef pair<pair<int,int>,int> P;\nint t,n;\nint b[61][61];\nint sx,sy;\nint ans;\nint tt;\nbool bb;\nint dx[]={-1,0,1,1,0,-1,0};\nint dy[]={0,1,1,0,-1,-1,0};\nvoid bfs(int tt)\n{\n    queue<P> que;\n    que.push(mp(mp(sy,sx),tt));\n    while(que.size())\n    {\n        P p=que.front();\n        que.pop();\n        if(p.second==t)break;\n        for(int i=0;i<7;i++)\n        {\n            int ny=p.first.first+dy[i];\n            int nx=p.first.second+dx[i];\n            if(0<=ny&&0<=nx&&nx<61&&ny<61&&(b[ny][nx]==0))\n            {\n                b[ny][nx]=2;\n                que.push(mp(mp(ny,nx),p.second+1));\n                  \n            }\n\n        }\n\n    }\n}\nint main()\n{\n    while(cin>>t>>n)\n    {\n        if(t==0&&n==0)break;\n        for(int i=0;i<61;i++)\n        {\n            for(int j=0;j<61;j++)\n            {\n                b[i][j]=0;\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            b[y][x]=1;\n        }\n        cin>>sx>>sy;\n        sx+=30;\n        sy+=30;\n        tt=0;\n        ans=0;\n        bfs(0);\n\n        for(int i=0;i<61;i++)\n        {\n            for(int j=0;j<61;j++)\n            {\n                if(b[i][j]==2)ans++;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 35\n#define NN 70\n#define UNKNOWN 0\nusing namespace std;\n#define S pair<int,int>\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,0,1,-1,0,-1};\n  int dy[6] = {0,1,1,0,-1,-1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y;\n      d[y+N][x+N] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    queue<S> q; q.push( S(x+N,y+N) ); d[y+N][x+N]=1;\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      if( d[s.second][s.first]<=t ){\n\tfor( int i=0,nt=d[s.second][s.first]+1;i<6;i++ ){\n\t  int nx=s.first+dx[i], ny=s.second+dy[i];\n\t  if( d[ny][nx]==UNKNOWN ){\n\t    d[ny][nx]=nt;\n\t    ans++;\n\t    q.push( S(nx,ny) );\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[62][62];\nbool flag[62][62];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\tmp[tx+31][ty+31]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint sum=1;\n\t\tflag[sx+31][sy+31]=true;\n\t\tqueue<pair<int,PII> >q;\n\t\tq.push(MP(t,MP(sx+31,sy+31)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tif(pi.first==0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(pi.first-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * コンセプト\n * とりあえずスタート地点から深さ決めて探索する．\n * で，探索したら探索済みの点をマークする．\n * 全部の点を回ったら　探索済みでかつ，障害物のない点の数をかぞえる\n * と，それが答え\n */\n#include <iostream>\n#define MAXX 60\n#define MAXY 60\n\nusing namespace std;\n\n//原点座標\nint cX=MAXX/2;\nint cY=MAXY/2;\n//HEX移動用の差分\nint xd[6]={0,1,1,0,-1,-1};\nint yd[6]={1,1,0,-1,-1,0};\n//探索済み判定用配列,探索済みならtrue\nbool flg[MAXX][MAXY];\n//障害物判定用配列,障害物がないならtrue\nbool mp[MAXX][MAXY];\n\n\n//深さ優先の再帰関数\nvoid solve2(int x,int y,int depth){\n\t//深さ0で終了\n\tif(depth==0) return;\n\t//x,y点周辺を探索済みにする\n\tfor(int i=0;i<6;i++)\n\t\tflg[(x+xd[i])%MAXX][(y+yd[i])%MAXY]=true;\n\t//x,y点周辺でかつ，障害物のない点を探索する\n\tfor(int i=0;i<6;i++)\n\t\tif(mp[(x+xd[i])%MAXX][(y+yd[i])%MAXY])\n\t\t\tsolve2((x+xd[i])%MAXX,(y+yd[i])%MAXY,depth-1);\n}\n\n//再帰関数を呼び出し，数え上げるための関数\nint solve(int x,int y,int depth){\n\tint cnt=0;\n\t//始点を探索済みにする\n\tflg[x][y]=true;\n\t//始点より深さ優先\n\tsolve2(x,y,depth);\n\t//すべての点について\n\tfor(int i=0;i<MAXX;i++)\n\t\tfor(int j=0;j<MAXY;j++)\n\t\t\t//障害物がなく，探索済みな点の数を数え上げる\n\t\t\tif(mp[i][j]&&flg[i][j]) cnt++;\n\t//解を出力\n\treturn cnt;\n}\n\nint main ( void ){\n\twhile(1){\n\t\tint t,n;\n\t\tint x,y;\n\t\t//t,nの入力\n\t\tcin >> t;\n\t\tcin >> n;\n\t\t//ターミナル処理\n\t\tif(t==0 && n==0) break;\n\t\t//配列初期化\n\t\tfor(int i=0;i<MAXX;i++){\n\t\t\tfor(int j=0;j<MAXY;j++){\n\t\t\t\tmp[i][j]=true;\n\t\t\t\tflg[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t//障害物の入力\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\tcin >> y;\n\t\t\tmp[(cX+x)%MAXX][(cY+y)%MAXY]=false;\n\t\t}\n\t\t//始点の入力\n\t\tcin >> x;\n\t\tcin >> y;\n\t//\tfor(int i=0;i<10000;i++)\n\t\t//\tsolve((cX+x)%MAXX,(cX+y)%MAXY,t) ;\n\t\t//実行・解の表示\n\t\tcout << solve((cX+x)%MAXX,(cX+y)%MAXY,t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define N 200\n#define INF 10000000\nusing namespace std;\n\nint n,m[N][N],t;\nqueue<pair<int,int> > q;\n\nint bfs(){\n  int cnt=1,cntt=0,d[N][N]={};\n  int x[6]={1,1,0,-1,-1,0},y[6]={1,0,-1,-1,0,1};\n  pair<int,int> map,mapa;\n   while(!q.empty()){\n        map=q.front(),q.pop();\n    for(int i=0;i<6;i++){\n        mapa=make_pair(map.first+x[i],map.second+y[i]);\n\tif(m[mapa.first][mapa.second]==INF) d[mapa.first][mapa.second]=d[map.first][map.second]+1;\n      if(m[mapa.first][mapa.second]!=INF|| m[mapa.first][mapa.second]==-1 || d[mapa.first][mapa.second]>t)continue;\n\t\tq.push(mapa),m[mapa.first][mapa.second]=1,cnt++;\n    }\n    cntt++;\n  }\n  return cnt;\n}\n \nint main(){\n  pair<int,int>  map;\n  int x,y,ans;\n  while(1){\n   for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) m[i][j]=INF;\n      cin>>t>>n;\n      if(t+n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      m[100+x][100+y]=-1;\n    }\n    cin>>x>>y;\n    m[100+x][100+y]=1;\n      map=make_pair(100+x,100+y);\n     q.push(map);\n     ans=bfs();\n     cout<<ans<<endl;\n  }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint field[100][100];\nint maping(int x, int y, int sum, int lot);\nint main(){\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = -1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tcout<<maping(s_x+50,s_y+50,0,t)<<endl;\t\t\n\t}\n\treturn 0;\n}\nint maping(int x, int y, int sum, int lot){\n\tif(!field[x][y]){\n\t\tfield[x][y] = 1;\n\t\tsum++;\n\t}\n\tif(lot>0){\n\t\tif(x>20){if(field[x-1][y] != -1){sum += maping(x-1,y,0,lot-1);}}\n\t\tif(y>20){if(field[x][y-1] != -1){sum += maping(x,y-1,0,lot-1);}}\n\t\tif(x<80){if(field[x+1][y] != -1){sum += maping(x+1,y,0,lot-1);}}\n\t\tif(y<80){if(field[x][y+1] != -1){sum += maping(x,y+1,0,lot-1);}}\n\t\tif(x>20 && y>20){if(field[x-1][y-1] != -1){sum += maping(x-1,y-1,0,lot-1);}}\n\t\tif(x<80 && y<80){if(field[x+1][y+1] != -1){sum += maping(x+1,y+1,0,lot-1);}}\n\t}\n\treturn sum;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pair<int,PII> >q;\n\t\tq.push(MP(t,MP(sx,sy)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tif(x<=0||y<=0)cout<<\"!!\"<<endl;\n\t\t\tint tt=pi.first;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(tt-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[6] = { 1, 1, 0, 0, -1, -1 };\nint dy[6] = { 1, 0, -1, 1, 0, -1 };\n\nbool field[100][100];\nint turn;\n\nint bfs( int sx, int sy ) {\n\tint ans = 1;\n\n\tqueue<pair<P, int> > que;\n\tque.emplace( MP( sx, sy ), 0);\n\tfield[sx][sy] = false;\n\n\twhile( !que.empty() ) {\n\t\tpair<P, int> t = que.front(); que.pop();\n\t\tif( t.second == turn ) break;\n\n\t\tREP( i, 6 ) {\n\t\t\tint nx = t.X + dx[i];\n\t\t\tint ny = t.Y + dy[i];\n\n\t\t\tif( field[nx][ny] ) {\n\t\t\t\tfield[nx][ny] = false;\n\t\t\t\tans++;\n\t\t\t\tque.emplace( MP( nx, ny ), t.second + 1 );\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn ans;\n\n}\n\nsigned main() {\n\tint n;\n\twhile( cin >> turn >> n, turn ) {\n\t\tfill( field[0], field[100], true );\n\t\tREP( i, n ) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tfield[x + 30][y + 30] = false;\n\t\t}\n\n\t\tint sx, sy; cin >> sx >> sy;\n\n\t\tcout << bfs( sx + 30, sy + 30 ) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[200][200];\nint t,n;\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty() && q.front().first < t){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n      if(0 <= nx && nx <= 60 && \n\t 0 <= ny && ny <= 60 &&\n\t grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n\tgrid[ny][nx]=-1;\n      }\n    }\n  }\nreturn res;\n}\n\nint main(){\n    while(cin>>t>>n){\n      if(t==0 && n==0)break;\n      memset(grid,0,sizeof(grid));\n      for(int i=0;i<n;i++){\n\tint x,y;\n\tcin>>x>>y;\n\tgrid[y+30][x+30]=-1;\n      }\n      int sx,sy;\n      cin>>sx>>sy;\n      grid[sy+30][sx+30]=-1;\n      cout <<  bfs(sx+30,sy+30) << endl;\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 1, -1};\nint dx[]={1, -1, 0, 0, 1, -1};\n\n//#define int long long\n\n/*************** using variables ***************/\nint t, n;\nvector<int> x, y;\nint graph[65][65];\nbool close_graph[65][65];\n/**********************************************/\n\nvoid bfs(){\n    queue<P> que;\n    que.push(P(y.back()+31, x.back()+31));\n    int cnt = 1;\n    while(!que.empty()){\n        if(cnt > t) break;\n        int qsize = que.size();\n        REP(j, qsize){\n            P cur = que.front();\n            que.pop();\n            REP(i, 6){\n                if(cur.first + dy[i] >= 0 && cur.first + dy[i] <= 64 && cur.second + dx[i] >= 0 && cur.second + dx[i] <= 64){\n                    if(!close_graph[cur.first + dy[i]][cur.second + dx[i]]){\n                        que.push(P(cur.first + dy[i], cur.second + dx[i]));\n                        close_graph[cur.first + dy[i]][cur.second + dx[i]] = true;\n                        graph[cur.first + dy[i]][cur.second + dx[i]] = cnt;\n                    }\n                }\n            }\n        }\n        cnt++;\n    }\n    int ans = 0;\n    REP(i, 65) REP(j, 65) if(abs(graph[i][j]) != INF){\n        //cout << i -31 << \" \" << j-31 << \" \" << graph[i][j] << endl;\n        ans++;\n    }\n    cout << ans << endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> t >> n, t != 0 || n != 0){\n        x.resize(n+1);\n        y.resize(n+1);\n        REP(i, 65) REP(j, 65) close_graph[i][j] = false;\n        REP(i, n+1) cin >> x[i] >> y[i];\n        REP(i, 65){\n            REP(j, 65){\n                graph[i][j] = INF;\n            }\n        }\n        REP(i, n){\n            close_graph[31 + y[i]][31 + x[i]] = true;\n        }\n        graph[31 + y.back()][31 + x.back()] = 0;\n        close_graph[31 + y.back()][31 + x.back()] = true;\n        bfs();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] < INF) res++;\n      }\n    }\n    // print begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) memo[i][j] = 0;\n      }\n    }\n\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          cout << memo[30-i+j][60-i] << \" \";\n        }\n        cout << memo[60][30-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          cout << memo[i-30+j][i] << \" \";\n        }\n        cout << memo[60][i-30];\n      }\n      cout << el;\n    }\n    */\n    // print end\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (n); ++i)\n\nstruct Info { int turn, x, y; };\n\nconst int dx[] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[] = { 1, 0, -1, -1, 0, 1 };\n\nint main()\n{\n    int t, n, x, y, c[140][140];\n    \n    while(cin >> t >> n && t)\n    {\n        int ans = 1;\n        fill_n(*c, 140*140, 0);\n        rep(i, n) cin >> x >> y, c[x+70][y+70] = -1;\n        \n        cin >> x >> y;\n        c[x+70][y+70] = 1;\n        queue<Info> que;\n        que.push((Info){ 0, x+70, y+70 });\n        \n        while(!que.empty())\n        {\n            Info a = que.front(); que.pop();\n            if(a.turn == t) continue;\n            rep(i, 6) {\n                if(c[a.x+dx[i]][a.y+dy[i]] == 0) {\n                    ++ans;\n                    c[a.x+dx[i]][a.y+dy[i]] = 1;\n                    que.push((Info){ a.turn+1, a.x+dx[i], a.y+dy[i] });\n                }\n            }\n        }\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#define dot pair<int,int>\nusing namespace std;\nint main(){\n  int dx[6]={1,-1,0,0,1,-1};\n  int dy[6]={0,0,1,-1,1,-1};\n  int field[300][300];\n  int t,n;\n  while(cin >>t>>n,t||n){\n    for(int i=0; i<300; i++) for(int j=0; j<300; j++) field[i][j] = 0;\n    for(int i=0,a,b; i<n; i++){\n      cin >>a>>b;\n      field[a+100][b+100] = 1;\n    }\n    int sx,sy;\n    cin >>sx>>sy;\n    queue<dot > f;\n    int ans = 0;\n    f.push(make_pair(100+sx,100+sy));\n    field[100+sx][100+sy] = 1;\n    while(!f.empty()){\n      ans++;\n      dot x = f.front();\n      f.pop();\n      if(field[x.first][x.second]<=t){\n\tfor(int i=0; i<6; i++){\n\t  if(field[x.first+dx[i]][x.second+dy[i]] == 0){\n\t    field[x.first+dx[i]][x.second+dy[i]] = field[x.first][x.second]+1;\n\t    f.push(make_pair(x.first+dx[i],x.second+dy[i]));\n\t  }\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <algorithm>\n//#include <cstring>\n//#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define repi(i, a, b) for( int i = a; i < b; i++ )\n#define m_t 30\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nvoid dfs( int x, int y, int a ){\n    //if( a >= t ) return;\n    rep(i, 6){\n        int nx = x + dx[i];\n        int ny = (y + dy[i]) * (m_t*2 + m_t*2+1-abs(y+dy[i])) / 2;\n        if( field[zero+nx+ny] != -1 ){\n            //cout << nx << ' ' << y+dy[i] << endl;\n            if( field[zero+nx+ny] == 0 ) cnt++;\n            field[zero+nx+ny] = 1;\n            if( a+1 < t ) dfs(nx, y+dy[i], a+1);\n        }\n    }\n}\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 0 );\n        int x, y;\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = -1;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 1;\n        cnt = 1;\n        dfs(sx, sy, 0);\n        /*queue<pair<int, int> > que;\n        que.push(mp(sx, sy));\n        while( !que.empty() ){\n            int cx = que.front().first;\n            int cy = que.front().second;\n            que.pop();\n            rep(i, 6){\n                int nx = cx + dx[i];\n                int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                if( field[zero+nx+ny] != -1 ){\n                    //cout << nx << ' ' << y+dy[i] << endl;\n                    field[zero+nx+ny] = field[zero+cx+cy]+1;\n                    //cnt++;\n                    if( field[zero+nx+ny] < t ) que.push(mp(nx, cy+dy[i]));\n                }\n            }\n        }*/\n        //cout << cx << ' ' << cy << endl;\n\n        /*rep(i, max){\n            if( field[i] == 1 ) cnt++;\n        }*/\n        cout << cnt << endl;\n        /*int l = 0;\n        rep(i, m_t*2+1){\n            rep(j, m_t*2+1-abs(m_t-i)){\n                cout << field[l++];\n            }\n            cout << endl;\n        }*/\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x > 0 && !map[x-1][y] && i < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (y > 0 && !map[x][y-1] && i < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (x < 60 && !map[x+1][y] && i < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (y < 60 && !map[x][y+1] && i < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] < INF) res++;\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\nbool closed[500][500];\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  int count = 0;\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n/*\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n  */\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n  memset(closed,0,sizeof(closed));\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      closed[X][Y] = true;\n      //ox.push_back(X);\n      //oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[200][200];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif(a[p.real()+50][p.imag()+50] == -2) return 0;\n\tif(k <= a[p.real()+50][p.imag()+50]) return 0;\n\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == -1) res++;\n\ta[p.real()+50][p.imag()+50] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tmemset(a, -1, sizeof(a));\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\nstruct masu{int x,y,tn;};//x,y,ターン\nbool ta[150][150];\nbool used[150][150];\nbool come[150][150];\nint dx[6]={1,-1,1,0,0,-1},dy[6]={0,0,1,1,-1,-1};\nint main(){\n\tint t,n;\n\twhile(true){\n\tcin>>t>>n;\n\tif(n==0&&t==0)break;\n\tfor(int i=0;i<150;i++)for(int j=0;j<150;j++)ta[i][j]=0,used[i][j]=0,come[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\tint tx,ty;\n\tcin>>tx>>ty;\n\ttx+=50,ty+=50;\n\tta[ty][tx]=1;\n\t}\n\tint nx,ny;\n\tcin>>nx>>ny;\n\tused[ny+50][nx+50]=1;\n\tmasu start;\n\tstart.x=nx+50,start.y=ny+50,start.tn=0;\n\tqueue<masu>bfs;\n\tbfs.push(start);\n\twhile(bfs.empty()==false){\n\tmasu tmp=bfs.front();\n\tbfs.pop();\n\tint nx=tmp.x,ny=tmp.y,ntn=tmp.tn;\n\t//cout<<nx<<\" \"<<ny<<endl;\n\tif(come[ny][nx]==1)continue;\n\tcome[ny][nx]=1;\n\tused[ny][nx]=1;\n\tif(ntn+1>t)continue;\n\t\tfor(int i=0;i<6;i++){\n\t\tint nextx=nx+dx[i],nexty=ny+dy[i];\n\t\t\tif(ta[nexty][nextx]==0&&used[nexty][nextx]==0){\n\t\t\tmasu next;\n\t\t\tnext.x=nx+dx[i],next.y=ny+dy[i];\n\t\t\tnext.tn=ntn+1;\n\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<150;i++){\n\tfor(int j=0;j<150;j++){\n\tif(come[i][j]){ans++;}\n\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[6]={1,1,0,0,-1,-1};\nint dy[6]={1,0,1,-1,0,-1};\n\nbool isrange(int x,int y){\n    return 0<=x && x<=60 && 0<=y && y<=60;\n}\nint main()\n{\n    int t,n;\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(61,vector<int>(61,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            x+=30;\n            y+=30;\n            ob[x][y]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        s.first+=30,s.second+=30;\n        vector<vector<int>> been(61,vector<int>(61,0));\n        been[s.first][s.second]=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        int cnt=1;\n        while(!q.empty()){\n            auto p=q.front().first;\n            int turn=q.front().second;\n            q.pop();\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isrange(tox,toy) && !ob[tox][toy] && !been[tox][toy]){\n                    been[tox][toy]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n\n                }\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define POS 1\n#define INPOS -1\n#define adj 100\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\nconst int dx[] = {0, -1, -1, 0, 1, 1};\nconst int dy[] = {1, 0, -1, -1, 0, 1};\n\nstruct State{\n  int x, y;\n  int turn;\n  State(int xx, int yy, int t){\n    x = xx, y = yy, turn = t;\n  }\n};\n\nint field[200][200];\nint t;\nint sx, sy;\n\nvoid bfs(){\n  queue<State> que;\n  que.push(State(sx, sy, t));\n  while(!que.empty()){\n    State tmp = que.front();\n    que.pop();\n    if(tmp.turn == 0) continue;\n    rep(i, 6){\n      int nx = tmp.x+dx[i], ny = tmp.y+dy[i];\n      if(field[ny][nx] == POS) continue;\n      if(field[ny][nx] != INPOS){\n\tfield[ny][nx] = POS;\n\tque.push(State(nx, ny, tmp.turn-1));\n      }\n    }\n  }\n}\n    \nint main(){\n  int n;\n  int jx, jy;\n  while(cin >> t >> n, t|n){\n    memset(field, 0, sizeof(field));\n    while(n--){\n      cin >> jx >> jy;\n      jx += adj, jy += adj;\n      field[jy][jx] = INPOS;\n    }\n    cin >> sx >> sy;\n    sx += adj, sy += adj;\n    int ans = 0;\n    field[sy][sx] = POS;\n    bfs();\n    rep(i, 200){\n      rep(j, 200){\n\tif(field[i][j] == POS) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nbool isRange(int x,int y){\n    return -50<=x && x<=50 && -50<=y && y<=50;\n}\nint main(){\n    int t,n;\n    int dx[6]={1,1,0,-1,-1,0};\n    int dy[6]={1,0,-1,-1,0,1};\n    while(cin>>t>>n,t){\n        vector<vector<int>> ob(101,vector<int>(101,0));\n        for(int i=0;i<n;i++){\n            int x,y;\n            cin>>x>>y;\n            ob[x+50][y+50]=1;\n        }\n        pair<int,int> s;\n        cin>>s.first>>s.second;\n        vector<vector<int>> been(101,vector<int>(101,0));\n        been[s.first+50][s.second+50]=1;\n        int cnt=1;\n        queue<pair<pair<int,int>,int>> q;\n        q.push(make_pair(s,0));\n        while(!q.empty()){\n            auto state=q.front();\n            q.pop();\n            auto p=state.first;\n            int turn=state.second;\n            if(turn==t)\n                continue;\n            for(int i=0;i<6;i++){\n                int tox=p.first+dx[i];\n                int toy=p.second+dy[i];\n                if(isRange(tox,toy) && !ob[tox+50][toy+50] && !been[tox+50][toy+50]){\n                    been[tox+50][toy+50]=1;\n                    cnt++;\n                    q.push(make_pair(make_pair(tox,toy),turn+1));\n                }\n\n\n            }\n\n        }\n        cout<<cnt<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) > i || abs(b[k]) > i) continue;\n                        int flg = 0;\n                        if (i % 2 == 0) {\n                            if (a[k] == i / 2 && b[k] == -i / 2) {ans--; flg = 1;}\n                            if (a[k] == -i / 2 && b[k] == i / 2) {ans--; flg = 1;}\n                        }\n                        if (flg == 0) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(j, n) {\n            if (abs(a[j]) > t || abs(b[j]) > t) continue;\n            int flg = 0;\n            if (t % 2 == 0) {\n                if (a[j] == t / 2 && b[j] == -t / 2) {flg = 1; ans--;}\n                if (a[j] == -t / 2 && b[j] == t / 2) {flg = 1; ans--;}\n            }\n            if (flg == 0) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  static const int dx[] = {-1,-1,0,1,1,0};\n  static const int dy[] = {-1,0,1,1,0,-1};\n  bool closed[500][500];\n  int count = 0;\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 250;\n      Y += 250;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 250;\n    sy += 250;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {0,1,1,0,-1,-1};\nconst int    DY[] = {1,1,0,-1,-1,0};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nconst int M = 62;\nconst int OFFSET = 30;\nint T, N;\n\nVVB done;\nVVB bads;\n\nint solve() {\n    bads = VVB(M, VB(M));\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        bads[OFFSET + y][OFFSET + x] = true;\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n\n    done = VVB(M, VB(M));\n\n    queue<pair<int, PII>> q;\n    q.push(MP(T, MP(OFFSET + sy, OFFSET + sx)));\n    while (q.size()) {\n        int t = q.front().fst;\n        int y = q.front().snd.fst;\n        int x = q.front().snd.snd;\n        q.pop();\n\n        if (done[y][x]) continue;\n        done[y][x] = true;\n        if (!t) continue;\n\n        rep(i, 6) {\n            int ny = y + DY[i];\n            int nx = x + DX[i];\n            if (!RANGEBOX(ny, nx, M, M)) continue;\n            if (bads[ny][nx]) continue;\n            q.push(MP(t - 1, MP(ny, nx)));\n        }\n    }\n\n    int cnt = 0;\n    rep(i, M) cnt += count(ALL(done[i]), true);\n\n    return cnt;\n}\n\nint main(void) {\n    while (cin >> T >> N, T) cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[200][200];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sy-data[1][i])>2*t+1){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (100-sx);\n\t\t\ttmpY += (100-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t\t//cout<<\"tmpX=\"<<tmpX<<\"tmpY=\"<<tmpY<<endl;\n\t\t}\n\t\tsx=100;\n\t\tsy=100;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = { 1,1,0,0,-1,-1 }, dy[] = { 0,1,-1,1,-1,0 };\n\nstruct dat {\n\tint x, y, t;\n\tdat(int x, int y, int t) :x(x), y(y), t(t) {}\n};\n\nint main() {\n\tint t, n;\n\twhile (cin >> t >> n, t) {\n\t\tbool G[120][120] = {};\n\t\tint x, y;\n\t\twhile (n--) {\n\t\t\tcin >> x >> y;\n\t\t\tG[x + 60][y + 60] = true;\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<dat> q;\n\t\tcin >> x >> y;\n\t\tG[x + 60][y + 60] = true;\n\t\tq.push(dat(x + 60, y + 60, 0));\n\t\twhile (!q.empty()) {\n\t\t\tauto now = q.front(); q.pop();\n\t\t\tif (now.t > t) break;\n\t\t\tans++;\n\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\tint nx = now.x + dx[i], ny = now.y + dy[i];\n\t\t\t\tif (G[nx][ny]) continue;\n\t\t\t\tG[nx][ny] = true;\n\t\t\t\tq.push(dat(nx, ny, now.t + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\n\nbool checkSyougai(vector<pair<int, int> > syougai, int x, int y){\n\tfor(int i = 0; i < syougai.size(); i++){\n\t\tif(syougai[i].first == x && syougai[i].second == y) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint dx[] = {-1, -1, 0, 0, 1, 1};\n\tint dy[] = {-1, 0, 1, -1, 0, 1};\n\tmap<int, map<int, bool> > field;\n\tint t, n;\n\tvector<pair<int, int> > syougai;\n\tpair<int, int> start;\n\n\twhile(cin >> t >> n && (t != 0 || n != 0)){\n\t\t//fieldの初期化\n\t\tfor(int i = -30; i <= 30; i++){\n\t\t\tfor(int j = -30; j <= 30; j++){\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\t//障害物とスタート地点の読み込み\n\t\tsyougai.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpair<int, int> tmp;\n\t\t\tcin >> tmp.X >> tmp.Y;\n\t\t\tsyougai.push_back(tmp);\n\t\t}\n\t\tcin >> start.X >> start.Y;\n\n\t\t//□■■\n\t\t//■■■\n\t\t//■■□fieldは普通の配置を想定して、こんなかんじで探索\n\t\tqueue<pair<int, int> > a;\n\t\tint count = 1;\n\t\ta.push(start);\n\t\tfield[start.Y][start.X] = true;\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tqueue<pair<int, int> > b;\n\t\t\twhile(!a.empty()){\n\t\t\t\tpair<int, int> tmp = a.front();\n\t\t\t\ta.pop();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\tif(checkSyougai(syougai, tmp.X + dx[i], tmp.Y + dy[i]) && field[tmp.Y + dy[i]][tmp.X + dx[i]] != true){\n\t\t\t\t\t\tpair<int ,int> next(tmp.X + dx[i], tmp.Y + dy[i]);\n\t\t\t\t\t\tb.push(next);\n\t\t\t\t\t\tfield[tmp.Y + dy[i]][tmp.X + dx[i]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta = b;\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n//#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        //fill( field.begin(), field.end(), 1 );  // reset\n        rep(i, max) field[i] = 1;\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n  \nusing namespace std;\n   \n#define NMAX 100\n#define INF 10000000\n#define WALL -1\ntypedef map<int,int>::value_type VT;\n  \nstruct data{\n    int x,y,turn;\n};\n  \nint main(void){\n      \n    int t,n;\n    int x,y;\n    map<int,int> road;\n    stack<data> no;\n    data tm,da;\n    int dx[]={1,1,0,-1,-1,0};\n    int dy[]={0,1,1,0,-1,-1};\n    int cnt;\n  \n    for(int i=-35;i<=35;i++){\n        for(int j=-35;j<=35;j++){\n        road.insert(VT(i+j*100,INF));\n        }\n    }\n    while(1){\n        cin>>t>>n;\n        if(t==0&&n==0) break;\n        for(int i=-35;i<=35;i++){\n            for(int j=-35;j<=35;j++){\n                road[i+j*100]=INF;\n            }\n        }\n        for(int i=-31;i<=31;i++){\n            road[-31+i*100]=WALL;\n            road[31+i*100]=WALL;\n            road[i+31*100]=WALL;\n            road[i-31*100]=WALL;\n        }\n  \n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            road[y+x*100]=WALL;\n        }\n        cin>>x>>y;\n        tm.x=x,tm.y=y,tm.turn=0;\n        no.push(tm);\n        road[y+x*100]=0;\n        cnt=1;\n        while(!no.empty()){\n            tm=no.top();\n            no.pop();\n            if(tm.turn==t) continue;\n            for(int i=0;i<6;i++){\n                if(road[(tm.y+dy[i])+(tm.x+dx[i])*100]>road[(tm.y)+(tm.x)*100]+1){\n                    if(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==INF) cnt++;\n                    road[(tm.y+dy[i])+(tm.x+dx[i])*100]=road[(tm.y)+(tm.x)*100]+1;\n                    da.x=tm.x+dx[i];\n                    da.y=tm.y+dy[i];\n                    da.turn=tm.turn+1;\n                    no.push(da);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n      \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint dx[] = { 0, 1, -1, 1, -1, 0 };\nint dy[] = { 1, 1, 0, 0, -1, -1 };\n\nbool fld[50][50];\n\nint main()\n{\n\tint t, n;\n\twhile (cin >> t >> n, t)\n\t{\n\t\tREP(i, 50)REP(j, 50) fld[i][j] = false;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tset<P> st;\n\t\tqueue<pair<P, int>> que;\n\t\tque.push(make_pair(P(sx, sy), 0));\n\t\tst.insert(P(sx,sy));\n\t\twhile (que.size())\n\t\t{\n\t\t\tP now = que.front().first;\n\t\t\tint tx = now.first;\n\t\t\tint ty = now.second;\n\t\t\tint time = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (time > t-1) break;\n\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i];\n\t\t\t\tint ny = ty + dy[i];\n\t\t\t\tif (fld[nx][ny]) continue;\n\t\t\t\tque.push(make_pair(P(nx, ny), time + 1));\n\t\t\t\tst.insert(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tcout << st.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nconst int OPEN = 0;\nconst int WALL = 1;\n\nclass state{\npublic:\n\tint x;\n\tint y;\n\tint turn;\n\n\tstate(int sx, int sy, int t) {\n\t\tx = sx;\n\t\ty = sy;\n\t\tturn = t;\n\t}\n};\n\nint main() {\n\tint t, n;\n\n\twhile(cin >> t >> n, t) {\n\t\tvvi field(62, vi(62, OPEN));\n\n\t\tREP(i, 62) {\n\t\t\tfield[0][i] = WALL;\n\t\t\tfield[61][i] = WALL;\n\t\t\tfield[i][0] = WALL;\n\t\t\tfield[i][61] = WALL;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tfield[x+30][y+30] = WALL;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<state> Q;\n\t\tQ.push(state(sx+30, sy+30, 0));\n\t\tfield[sx+30][sy+30] = WALL;\n\n\t\tint visited = 0;\n\n\t\twhile(!Q.empty()) {\n\t\t\tstate s = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(s.turn < t) {\n\t\t\t\tif(field[s.x+1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y+1, s.turn+1));\n\t\t\t\t\tfield[s.x][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y, s.turn+1));\t\n\t\t\t\t\tfield[s.x-1][s.y] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x, s.y-1, s.turn+1));\t\n\t\t\t\t\tfield[s.x][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x+1][s.y+1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x+1, s.y+1, s.turn+1));\t\n\t\t\t\t\tfield[s.x+1][s.y+1] = WALL;\n\t\t\t\t}\n\t\t\t\tif(field[s.x-1][s.y-1] == OPEN) {\n\t\t\t\t\tQ.push(state(s.x-1, s.y-1, s.turn+1));\n\t\t\t\t\tfield[s.x-1][s.y-1] = WALL;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\n\t\t\t++visited;\n\t\t}\n\n\t\tcout << visited << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n \ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n \nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n \nvoid clear(){\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            d[i][j] = 0;\n            stage[i][j] = 0;\n        }\n    }\n}\nvoid s(queue<P>,int turn);\nint sum(){\n    int res = 0;\n    for(int i = 0;i < MAX+1;i++){\n        for(int j = 0;j < MAX+1;j++){\n            if(d[i][j] == 1) res++;\n        }\n    }\n    return res;\n}\n \nint main() {\n    int t,n,sX,sY,x,y;\n    while(1){\n        clear();\n        //input\n        cin >> t >> n;\n        if(t == 0 && n == 0) break;\n        for(int i=0;i<n;i++){\n            cin >> x >> y;\n            stage[x+30][y+30] = 1;\n        }\n        cin >> sX >> sY;\n        //input end\n        queue<P> que;\n        que.push(P(sX+30,sY+30)); \n        d[sX+30][sY+30] = 1;\n        s(que,t);\n        cout << sum() << endl;\n    }\n    return 0;\n}\n \nvoid s(queue<P> que1,int turn){\n    if(turn == 0) return;\n    queue<P> que2;\n    while(!que1.empty()){\n        P xy = que1.front();\n        que1.pop();\n        int x = xy.first,y = xy.second;\n        for(int i = 0;i < 6;i++){\n            if(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0 && x+dx[i] < 61 && x+dx[i] > 0 && y+dy[i] > 0&& y+dy[i] < 61){\n                d[x+dx[i]][y+dy[i]] = 1;\n                que2.push(P(x+dx[i],y+dy[i]));\n            }\n        }\n    }\n     \n    s(que2,turn-1);\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tfor(;;){\n\t\tint t, n, x, y, sum = 1;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tbool field[100][100] = {0};\n\t\twhile(n--){\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = 1;\n\t\t}\n\t\tcin >>x>>y;\n\t\tpoint.push(make_pair(x+50,y+50));\n\t\tfield[x+50][y+50] = 1;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tx = point.front().first;\n\t\t\t\ty = point.front().second;\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(x>20){if(!field[x-1][y]){field[x-1][y] = 1;sum++;point.push(make_pair(x-1,y));}}\n\t\t\t\t\tif(y>20){if(!field[x][y-1]){field[x][y-1] = 1;sum++;point.push(make_pair(x,y-1));}}\n\t\t\t\t\tif(x<80){if(!field[x+1][y]){field[x+1][y] = 1;sum++;point.push(make_pair(x+1,y));}}\n\t\t\t\t\tif(y<80){if(!field[x][y+1]){field[x][y+1] = 1;sum++;point.push(make_pair(x,y+1));}}\n\t\t\t\t\tif(x>20 && y>20){if(!field[x-1][y-1]){field[x-1][y-1] = 1;sum++;point.push(make_pair(x-1,y-1));}}\n\t\t\t\t\tif(x<80 && y<80){if(!field[x+1][y+1]){field[x+1][y+1] = 1;sum++;point.push(make_pair(x+1,y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\nint t, n;\nbool used[100][100], block[100][100];\n\nvoid solve() {\n  memset(block, 0, sizeof block);\n  memset(used, 0, sizeof used);\n  for(int i=0;i<n;i++) {\n    int tx, ty;\n    cin>>tx>>ty;\n    tx += 50; ty += 50;\n    block[ty][tx] = true;\n  }\n\n  int sx, sy;\n  cin>>sx>>sy;\n  sx += 50; sy += 50;\n  \n  int res = 0;\n  queue<pair<int,P> > que;\n  que.push(make_pair(t, P(sx, sy)));\n  while (!que.empty()) {\n    pair<int,P> p = que.front(); que.pop();\n    int tt = p.first;\n    int x = p.second.first, y = p.second.second;\n    \n    if (used[y][x] || block[y][x]) continue;\n    used[y][x] = true;\n    res++;\n    \n    if (tt == 0) continue;\n    \n    for (int z = 0; z < 6; z += 1) {\n      int tx = x + dx[z], ty = y + dy[z];\n      if (used[ty][tx] || block[ty][tx]) continue;\n      que.push(make_pair(tt-1, P(tx, ty)));\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>t>>n, t||n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint t, n;\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\nstruct node{\n    int x;\n    int y;\n    int step;\n};\nbool inrange(int x, int y){\n    return x >= 0 && y >= 0 && x <= 200 && y <= 200;\n}\nbool jam[201][201];\nint main(){\n    while(cin >> t >> n, t||n){\n        memset(jam, 0, sizeof(jam));\n        rep(i, n){\n            int bx, by;\n            cin >> bx >> by;\n            bx += 100;\n            by += 100;\n            jam[bx][by] = true;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 100;\n        sy += 100;\n        queue<node> q;\n        set<pair<int, int> > st;\n        q.push((node){sx, sy, 0});\n        while(!q.empty()){\n            int x = q.front().x;\n            int y = q.front().y;\n            int step = q.front().step;\n            q.pop();\n            //      cout << x << \" \" << y << \" \" << step << endl;\n            if(st.find(mp(x, y)) != st.end()) continue;\n            if(step >= t+1) break;\n            st.insert(mp(x, y));\n            rep(i, 6){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(inrange(nx, ny) && !jam[nx][ny]){\n                    q.push((node){nx, ny, step+1});\n                }\n            }\n            \n        }\n        cout << st.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int\tSIZE=200,\n\t\t\tOF=100;\nconst int\tvx[]={1,1,0,-1,-1,0},\n\t\t\tvy[]={1,0,-1,-1,0,1};\n\nint main(){\n\tint t,n;\n\twhile(cin >> t >> n , t||n){\n\t\tvector<vector<bool> > map(SIZE, vector<bool>(SIZE, true));\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tx+=OF; y+=OF;\n\t\t\tmap[x][y]=false;\n\t\t}\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tsx+=OF; sy+=OF;\n\t\tmap[sx][sy]=false;\n\n\t\tqueue<pair<pair<int,int>,int> > open;\n\t\topen.push(make_pair(make_pair(sx,sy),0));\n\t\tint ans=1;\n\n\t\twhile(!open.empty()){\n\t\t\tpair<pair<int,int>,int > now=open.front();\n\t\t\topen.pop();\n\t\t\tif(now.second >= t)\tcontinue;\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tint xx=now.first.first+vx[i],\n\t\t\t\t\tyy=now.first.second+vy[i];\n\t\t\t\tif(!map[xx][yy])\tcontinue;\n\t\t\t\tmap[xx][yy]=false;\n\t\t\t\topen.push(make_pair(make_pair(xx,yy), now.second+1));\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define INF 1e8\nusing namespace std;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nbool table[150][150];\nint d[150][150];\nint turn;\nvoid bfs(int x,int y){\n    d[x][y] = 0;\n    queue<pair<int,int> > que;\n    que.push(pair<int,int>(x,y));\n    while(!que.empty()){\n\t\tpair<int,int> p = que.front();\n        que.pop();\n        int x = p.first,y = p.second;\n        if(d[x][y] == turn) break;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(table[nx][ny] || d[nx][ny] != INF) continue;\n            d[nx][ny] = d[x][y] + 1;\n            que.push(pair<int,int>(nx,ny));\n        }\n    }\n}\nint main(){\n    int block;\n    while(cin >> turn >> block){\n        if(turn == 0 && block == 0) break;\n        rep(i,150){\n            rep(j,150) {\n                d[i][j] = INF;\n                table[i][j] = 0;\n            }\n        }\n        int x,y;\n        rep(i,block){\n            cin >> x >> y;\n            table[x+70][y+70] = 1;\n        }\n        int sx,sy;\n        cin >> sx >> sy;\n        sx += 70; sy += 70;\n        bfs(sx,sy);\n        int ans = 0;\n        rep(i,150){\n            rep(j,150){\n                if(d[i][j] != INF) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint t, n;\nint dx[] = {0, 1, 1, 0, -1, -1};\nint dy[] = {1, 1, 0, -1, -1, 0};\nstruct node{\n    int x;\n    int y;\n    int step;\n};\nbool inrange(int x, int y){\n    return x >= 0 && y >= 0 && x <= 60 && y <= 60;\n}\nbool jam[101][101];\nint main(){\n    while(cin >> t >> n, t||n){\n        memset(jam, 0, sizeof(jam));\n        rep(i, n){\n            int bx, by;\n            cin >> bx >> by;\n            bx += 30;\n            by += 30;\n            jam[bx][by] = true;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        sx += 30;\n        sy += 30;\n        queue<node> q;\n        set<pair<int, int> > st;\n        q.push((node){sx, sy, 0});\n        while(!q.empty()){\n            int x = q.front().x;\n            int y = q.front().y;\n            int step = q.front().step;\n            q.pop();\n            //      cout << x << \" \" << y << \" \" << step << endl;\n            if(st.find(mp(x, y)) != st.end()) continue;\n            if(step >= t+1) break;\n            st.insert(mp(x, y));\n            rep(i, 6){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(inrange(nx, ny) && !jam[nx][ny]){\n                    q.push((node){nx, ny, step+1});\n                }\n            }\n            \n        }\n        cout << st.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define CR 100\n#define INF 1 << 30\nusing namespace std;\nint t, n, field[200][200];\n\nvoid dfs(int nx, int ny){\n  if(field[nx][ny] == t) return;\n  int dx[] = {-1,-1,0,0,1,1}, dy[] = {-1,0,-1,1,0,1};\n  rep(i, 6){\n    if(field[nx+dx[i]][ny+dy[i]] == -1 || field[nx+dx[i]][ny+dy[i]] <= field[nx][ny]) continue;\n    field[nx+dx[i]][ny+dy[i]] = min(field[nx+dx[i]][ny+dy[i]], field[nx][ny]+1);\n    //    fprintf(stderr, \"%d %d %d\\n\",nx+dx[i], ny+dy[i], field[nx+dx[i]][ny+dy[i]]);\n    dfs(nx+dx[i], ny+dy[i]);\n  }\n  //  return;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &t, &n) && (t||n)){\n    int x, y;\n    rep(i, 200) rep(j, 200) field[i][j] = INF;\n    rep(i, n){\n      scanf(\"%d%d\", &x, &y);\n      field[x+CR][y+CR] = -1;\n    }\n    scanf(\"%d%d\", &x, &y);\n    field[x+CR][y+CR] = 0;\n    dfs(x+CR, y+CR);\n    int res = 1;\n    rep(i, 200) rep(j, 200) if(field[i][j] > 0 && field[i][j] < 100) res++;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint output=1,t=0,n=0,j=0, start_x=0, start_y=0;\n\t\tint syougai_x[301]={0};\n\t\tint syougai_y[301]={0};\n\t\tcin >> t >> n;\n\t\tif((t == 0) && (n == 0)) break;\n\t\tj = t;\n\t\tfor(;j>0;j--) output += j*6;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> syougai_x[i] >> syougai_y[i];\n\t\t}\n\t\tcin >> start_x >> start_y;\n\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tif((syougai_x[i] <= start_x + t) && (syougai_x[i] >= start_x-t))\n\t\t\t{\n\t\t\t\tif((syougai_y[i] <= start_y + t) && (syougai_y[i] >= start_y-t))\n\t\t\t\t{\n\t\t\t\t\toutput--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << output << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int mid = 35;\nconst int dx[6] = {1,-1,1,0,-1,0};\nconst int dy[6] = {1,-1,0,1,0,-1};\n\nbool g[70][70] = {};\nbool u[70][70] = {};\nvoid bfs(int y,int x,int t){\n    queue<int> qx;\n    queue<int> qy;\n    queue<int> qt;\n    qx.push(x);\n    qy.push(y);\n    qt.push(t);\n    u[y+35][x+35]=true;\n    while(!qx.empty()){\n        x = qx.front();\n        y = qy.front();\n        t = qt.front();\n        qx.pop();qy.pop();qt.pop();\n        if(t<1) continue;\n        rep(i,6){\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx<-30||nx>30||ny<-30||ny>30) continue;\n            if(g[ny+35][nx+35]==false && u[ny+35][nx+35]==false){\n                u[ny][nx] = true;\n                qx.push(nx);\n                qy.push(ny);\n                qt.push(t-1);\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int t,n;\n\nwhile(cin >> t >> n,t){\n    rep(y,70)rep(x,70){g[y][x]=0;u[y][x]=0;}\n    rep(i,n){\n        int x,y;\n        cin >> x >> y;\n        g[y+35][x+35] = true;\n    }\n    int x,y;\n    cin >> x >> y;\n    bfs(y,x,t);\n    int a=0;\n    rep(y,70)rep(x,70)if(u[y][x])a++;\n    cout << a << endl;\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mLife;\n  int mX;\n  int mY;\n  State(int life,int x,int y) : mLife(life), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mLife < s.mLife;\n  }\n\n  bool operator >(const State& s) const{\n    return mLife > s.mLife;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //0:unvisited\n      //1:obstacle\n      //2:visited\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    if(stage.find(P(sx,sy)) != stage.end()\n       && stage[P(sx,sy)] == -1) goto last;\n\n    priority_queue<State,vector<State> > que;\n    que.push(State(t,sx,sy));\n    stage[P(sx,sy)] = t;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.mLife <= 0) continue;\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\tif(abs(dx) > 30 || abs(dy) > 30) continue;\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && stage[P(dx,dy)] <= s.mLife-1) continue;\n\n\tstage[P(dx,dy)] = s.mLife-1;\n\tque.push(State(s.mLife-1,dx,dy));\n      }\n    }\n\n  last:;\n    int res = CoundVisitedCell(stage);\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n\nusing namespace std;\n\ntypedef std::array<bool, 63> Line;\ntypedef std::array<Line, 63> Table;\n\nTable table; // [X][Y]\nstd::array< std::array<int, 63>, 63> standed; // [X][Y]\n\nint current_x;\nint current_y;\nint g_count;\nint g_turn;\nint g_current_turn;\n\nint g_dx[] = { 0, 1, 1, 0, -1, -1 };\nint g_dy[] = { 1, 1, 0, -1, -1, 0 };\n\nint calc(int x) {\n\treturn x + 32;\n}\n\nvoid solution() {\n\tif (standed[calc(current_x)][calc(current_y)] == -1) {\n\t\t++g_count;\n\t} else if (standed[calc(current_x)][calc(current_y)] <= g_current_turn) return;\n\t\n\tstanded[calc(current_x)][calc(current_y)] = g_current_turn;\n\tif (g_current_turn >= g_turn) return;\n\n\tauto x = current_x;\n\tauto y = current_y;\n\n\tfor (int i = 0; i < 6; ++i) {\n\t\tif (!table[calc(current_x + g_dx[i])][calc(current_y + g_dy[i])]) {\n\t\t\tcurrent_x += g_dx[i];\n\t\t\tcurrent_y += g_dy[i];\n\n\t\t\t++g_current_turn;\n\t\t\tsolution();\n\t\t\t--g_current_turn;\n\n\t\t\tcurrent_x = x;\n\t\t\tcurrent_y = y;\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"sample.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tfor_each(table.begin(), table.end(), [](Line & line) {\n\t\t\tline.fill(false);\n\t\t});\n\t\tfor_each(standed.begin(), standed.end(), [](std::array<int, 63> & line) {\n\t\t\tline.fill(-1);\n\t\t});\n\t\tg_count = 0;\n\t\tg_current_turn = 0;\n\n\t\tint n;\n\t\tcin >> g_turn >> n;\n\t\tif (g_turn == 0) break;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttable[calc(x)][calc(y)] = true;\n\t\t}\n\n\t\tcin >> current_x >> current_y;\n\n\t\tsolution();\n\n\t\tcout << g_count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n//#include <cmath>\n//#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\n#define m_t 60\n#define max (3*m_t*(m_t+1)+1)\n#define zero (max/2)\n#define mp make_pair\n\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nvector<int> field(max);\nint t, n;\nint cnt;\n\nint main(){\n    while( cin >> t >> n, t ){\n        fill( field.begin(), field.end(), 1 );  // reset\n        int x, y;\n        /* input of obstacle */\n        rep(i, n){\n            cin >> x >> y;\n            y = y * (m_t*2 + m_t*2+1-abs(y)) / 2;\n            field[zero+x+y] = 0;\n        }\n        int sx, sy;\n        /* input of the starting point */\n        cin >> sx >> sy;\n        x = sx;\n        y = sy * (m_t*2 + m_t*2+1-abs(sy)) / 2;\n        field[zero+x+y] = 0;\n        //cnt = 0;\n        //dfs(sx, sy, 0);\n\n        int ans = 0;\n        queue< pair< pair<int, int>, int > > rt;\n        rt.push(mp(mp(sx, sy), 0));\n\n        while( !rt.empty() ){\n            ans++;\n            int cx = rt.front().first.first;\n            int cy = rt.front().first.second;\n            int ct = rt.front().second;\n            rt.pop();\n\n            if( ct < t ){\n                rep(i, 6){\n                    int nx = cx + dx[i];\n                    int ny = (cy + dy[i]) * (m_t*2 + m_t*2+1-abs(cy+dy[i])) / 2;\n                    if( field[zero+nx+ny] ){\n                        field[zero+nx+ny] = 0;\n                        rt.push(mp(mp(nx, cy+dy[i]), ct+1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Point {\n  int y, x;\n  Point() = default;\n  Point(int y, int x): y(y), x(x) { }\n};\n\nstruct Search {\n  int dist, y, x;\n  Search() = default;\n  Search(int d, int y, int x): dist(d), y(y), x(x) { }\n};\n\nint main() {\n  while (true) {\n    int t, n;\n    cin >> t >> n;\n    if (t + n == 0) {\n      break;\n    }\n    vector<Point> object;\n    vector<Point> checked;\n\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      object.push_back(Point(y, x));\n    }\n    int sx, sy;\n    cin >> sx >> sy;\n    int ans = 0;\n\n    queue<Search> que;\n    que.push(Search(0, sy, sx));\n    while (!que.empty()) {\n      Search s = que.front(); que.pop();\n      bool isOK = true;\n      for (auto e : object) {\n        if (s.y == e.y && s.x == e.x) {\n          isOK = false;\n        }\n      }\n      for (auto e : checked) {\n        if (s.y == e.y && s.x == e.x) {\n          isOK = false;\n        }\n      }\n      if (s.dist > t) {\n        continue;\n      }\n      if (!isOK) {\n        continue;\n      }\n\n      ans++;\n      \n      checked.push_back(Point(s.y, s.x));\n\n      int dy[6] = { 1, 0, -1, -1, 0, 1 };\n      int dx[6] = { 1, 1, 0, -1, -1, 0 };\n\n      for (int i = 0; i < 6; i++) {\n        int y = s.y + dy[i];\n        int x = s.x + dx[i];\n        que.push(Search(s.dist + 1, y, x));\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nbool in(ll y, ll x, ll h, ll w){\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(){\n    while(1){\n        ll t,n; cin >> t >> n;\n        if(!t && !n) break;\n        int s[130][130];\n        rep(i,130) rep(j,130) s[i][j] = 1;\n        rep(i,n){\n            ll x,y; cin >> x >> y;\n            x += 60; y += 60;\n            s[x][y] = 0;\n        }\n        ll sx,sy; cin >> sx >> sy;\n        sx += 60; sy += 60;\n        queue<pair<P,ll>> q;\n        q.emplace(P(sx,sy),0);\n        ll ans = 1;\n        bool visit[130][130];\n        rep(i,130) rep(j,130) visit[i][j] = false;\n        visit[sx][sy] = true;\n        while(!q.empty()){\n            auto p = q.front(); q.pop();\n            ll y = p.first.first;\n            ll x = p.first.second;\n            if(p.second >= t) continue;\n            rep(i,6){\n                ll ny = y + dy[i];\n                ll nx = x + dx[i];\n                if(in(ny,nx,130,130) && s[ny][nx] && !visit[ny][nx]){\n                    visit[ny][nx] = true;\n                    ans++;\n                    q.emplace(P(ny,nx),p.second+1);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint a[1000][1000];\nint dx[]={1,0,-1,-1,0,1},dy[]={0,-1,-1,0,1,1};\nmain()\n{\n\tint n,t;\n\twhile(cin>>t>>n,t)\n\t{\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)a[i][j]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;cin>>x>>y;a[x+500][y+500]=-1;\n\t\t}\n\t\tint x,y;cin>>x>>y;\n\t\tqueue<pair<pair<int,int>,int> >P;\n\t\tP.push(make_pair(make_pair(x+500,y+500),t));\n\t\ta[x+500][y+500]=1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first.first,y=P.front().first.second,T=P.front().second;\n\t\t\tP.pop();\n\t\t\tif(T<0)continue;\n\t\t\tfor(int r=0;r<6;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(a[tx][ty]==0)\n\t\t\t\t{\n\t\t\t\t\ta[tx][ty]=1;\n\t\t\t\t\tP.push(make_pair(make_pair(tx,ty),T-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<1000;i++)for(int j=0;j<1000;j++)cnt+=a[i][j]==1;\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Brave Force Story\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair< pair<int, int>, int> Q;\n#define INF -1\nint dx[6]={1, 1, 0, -1, -1, 0}, dy[6]={1, 0, -1, -1, 0, 1};\nint mp[61][61];//+30\nint d[61][61]; //+30\n\nQ make_Q(int x, int y, int z){\n  Q ret;\n  ret.first.first=x;\n  ret.first.second=y;\n  ret.second=z;\n  return ret;\n}\n\nint main(){\n  int t, n;\n  while(cin>>t>>n, !(t==0&&n==0)){\n    memset(mp, 0, sizeof(mp));\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\td[i][j]=INF;\n    while(n--){\n      int tmp_x, tmp_y;\n      cin>>tmp_x>>tmp_y;\n      mp[tmp_x+30][tmp_y+30]=INF;\n    }\n    int sx, sy;\n    cin>>sx>>sy;\n    d[sx+30][sy+30]=0;\n    queue<Q> q;\n    q.push(make_Q(sx+30, sy+30, t));\n    while(!q.empty()){\n      Q now=q.front(); q.pop();\n      if(now.second==0)break;\n      for(int i=0; i<6; i++){\n\tint nx=now.first.first+dx[i], ny=now.first.second+dy[i];\n\tif(0<=nx && nx<61 && 0<=ny && ny<61 && mp[nx][ny]!=INF && d[nx][ny]==INF){\n\t  q.push(make_Q(nx, ny, now.second-1));\n\t  d[nx][ny]=d[now.first.first][now.first.second]+1;\n\t}\n      }\n    }\n    int cnt=0;\n    for(int i=0; i<61; i++)\n      for(int j=0; j<61; j++)\n\tif(d[i][j]!=INF)cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,1,0,-1,-1};\nint ty[] = {1,1,0,-1,-1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mStep;\n  int mX;\n  int mY;\n  State(int step,int x,int y) : mStep(step), mX(x), mY(y) {}\n  bool operator <(const State& s) const{\n    return mStep < s.mStep;\n  }\n\n  bool operator >(const State& s) const{\n    return mStep > s.mStep;\n  }\n};\n\nint CoundVisitedCell(map<P,int>& stage){\n  int count = 0;\n  for(int y=-30;y<=30;y++){\n    for(int x=-30;x<=30;x++){\n      if(stage.find(P(x,y)) == stage.end()) continue;\n      if(stage[P(x,y)] >= 0) count++;\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int t,n;\n  while(~scanf(\"%d %d\",&t,&n)){\n\n    if(t==0 && n==0) break;\n\n    map<P,int> stage;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      stage[P(x,y)] = -1;\n    }\n\n    int sx,sy;\n    scanf(\"%d %d\",&sx,&sy);\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(0,sx,sy));\n    stage[P(sx,sy)] = 0;\n\n    int res = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      res++;\n      if(s.mStep >= t) continue;\n\n      for(int i=0;i<6;i++){\n\tint dx = s.mX + tx[i];\n\tint dy = s.mY + ty[i];\n\n\t//obstacle\n\tif(stage.find(P(dx,dy)) != stage.end()\n\t   && stage[P(dx,dy)] == -1) continue;\n\n\t//small step count is better\n\tif(stage.find(P(dx,dy)) != stage.end() \n\t   && s.mStep+1 >= stage[P(dx,dy)] ) continue;\n\n\tstage[P(dx,dy)] = s.mStep+1;\n\tque.push(State(s.mStep+1,dx,dy));\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tvisited.insert(fr);\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(fr.first.first+dx[i],fr.first.second+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end())q.push(piii(cur,fr.second+1));\n\t\t\t}\n\t\t}\n\t\tcout<<visited.size()<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,n,x,y,ans,sx,sy;\n  int mp[61][61];\n  while(1){\n    cin>>t>>n;\n    for(int i=0;i<61;i++){\n      for(int j=0;j<61;j++){\n\tmp[i][j]=0;\n      }\n    }\n    ans=0;\n    if(t==0 && n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      mp[y+30][x+30]=-1;\n    }\n    cin>>sx>>sy;\n    mp[sy+30][sx+30]=1;\n    for(int i=1;i<=t;i++){\n      for(int j=0;j<61;j++){\n\tfor(int k=0;k<61;k++){\n\t  if(mp[j][k]==i){\n\t    for(int l=-1;l<2;l++){\n\t      if(mp[j+l][k]==0){\n\t\tmp[j+l][k]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j][k+l]==0){\n\t\tmp[j][k+l]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j+l][k+l]==0){\n\t\tmp[j+l][k+l]=i+1;\n\t\tans++;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nbool o[200][200];\nbool reached[200][200];\n\nint search(int sx, int sy, int t);\n\ntypedef struct{\n\tint x;\n\tint y;\n\tint r;\n}node;\n\nint main(void){\n\tint t, n;\n\tint sx, sy;\n\twhile(1){\n\t\tfor(int i=0; i<200; i++){\n\t\t\tfor(int j=0; j<200; j++){\n\t\t\t\to[i][j]=false;\n\t\t\t\treached[i][j]=false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> t >> n;\n\t\tif(t==0 && n==0) break;\n\t\tfor(int k=0; k<n; k++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\to[x+100][y+100]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\n\t\tint count = search(sx, sy, t);\n\t\tcout << count << endl;\n\t}\n\t\n\treturn 0;\n}\n\nint search(int sx, int sy, int t){\n\tint count = 0;\n\t\n\tnode s = {sx, sy, t};\n\treached[s.x+100][s.y+100] = true;\n\tcount++;\n\tqueue<node> qu;\n\tqu.push(s);\n\t\n\twhile(!qu.empty()){\n\t\tnode n = qu.front();\n\t\tint x, y, r;\n\t\tx = n.x;\n\t\ty = n.y;\n\t\tr = n.r;\n\t\tqu.pop();\n\t\t\n\t\tnode no[6]={{x+1,y+1,r-1}, {x+1,y,r-1}, {x,y+1,r-1}, {x,y-1,r-1}, {x-1,y,r-1}, {x-1,y-1,r-1}};\n\t\tfor(int i=0; i<6; i++){\n\t\t\tif(!reached[no[i].x+100][no[i].y+100] && !o[no[i].x+100][no[i].y+100]){\n\t\t\t\treached[no[i].x+100][no[i].y+100] = true;\n\t\t\t\tcount++;\n\t\t\t\tif(no[i].r>0){\n\t\t\t\t\tqu.push(no[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\ntypedef pair<int, int> Pii;\n\n\nint a[100][100];\nP dd[] = {P(1,0), P(1,1), P(0,1), P(-1,0), P(-1,-1), P(0,-1)};\n\n\nint dfs(P p, int k){\n\tif(a[p.real()+50][p.imag()+50] == -2) return 0;\n\tif(k <= a[p.real()+50][p.imag()+50]) return 0;\n\n\tint res = 0;\n\tif(a[p.real()+50][p.imag()+50] == -1) res++;\n\ta[p.real()+50][p.imag()+50] = k;\n\tfor(int i=0;i<6;i++){\n\t\tres += dfs(p+dd[i], k-1);\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint t, n;\n\tcin>> t>> n;\n\tif(t==0 && n==0) return false;\n\t\n\tmemset(a, -1, sizeof(a));\n\tfor(int i=0;i<n;i++){\n\t\tint x, y;\n\t\tcin>> x>> y;\n\t\ta[x+50][y+50] = -2;\n\t}\n\tP p;\n\tcin>> p.real()>> p.imag();\n\tint ans = dfs(p, t);\n\tcout<< ans<< endl;\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {-1, -1, 0, 0, 1, 1}, dy[] = {-1, 0, -1, 1, 0, 1}, b[70][70], t;\n\nint dfs(int y, int x, int num) {\n  //cout << \"y:\" << y << \" x:\" << x << \" num:\" << num << endl;\n  b[y+30][x+30] = num;\n  if (num == t) {\n    return 0;\n  }\n\n  REP(i, 6) {\n    int nx = x + dx[i], ny = y + dy[i];\n    //cout << ny << \" \" << nx << \" \" << b[ny+30][nx+30] << endl;\n    if (abs(nx) <= 30 && abs(ny) <= 30 && b[ny + 30][nx + 30] > num) {\n      //cout << ny << \":\" << nx << endl;\n      dfs(ny, nx, num + 1);\n    }\n  }\n\n  return 0;\n}\n/*\n2 2\n-2 1\n2 0\n2 2\n\n2 0\n-1 1\n\n4 4\n-2 1\n1 -2\n1 2\n3 -3\n-2 0\n*/\n\nsigned main(void) {\n  while (true) {\n    int n, x[305], y[305], sx, sy;\n    cin >> t >> n;\n    if(!t && !n) break;\n    REP(i, 70) REP(j, 70) b[i][j] = INF;\n    REP(i, n) {\n      cin >> x[i] >> y[i];\n      b[y[i] + 30][x[i] + 30] = -1;\n    }\n    cin >> sx >> sy;\n\n    dfs(sy, sx, 0);\n\n    int ret = 0;\n    REP(i, 65) REP(j, 65) {\n      if (b[i][j] != INF && b[i][j] != -1) {\n        ret++;\n        //cout << i-30 << \" \" << j-30 << endl;\n      }\n    }\n\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\n\n\n//0-indexed\nclass BreadthFirstSearch\n{\npublic:\n\tlong long int **Used,**BFSResult;\n\tchar **HW;\n\tlong long int MaxH,MaxW;\n\tstack<pair<long long int,long long int> >Root;\n\t\n\tBreadthFirstSearch(long long int H,long long int W){\n\t\tMaxH=H;\n\t\tMaxW=W;\n\t\tHW= new char*[H+1];\n\t\tUsed= new long long int*[H+1];\n\t\tBFSResult= new long long int*[H+1];\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tHW[i]= new char[W+1];\n\t\t\tUsed[i]= new long long int[W+1];\n\t\t\tBFSResult[i]= new long long int[W+1];\n\t\t}\n\t}\n\t\n\tvoid DoBFS(pair<long long int,long long int>Start){\n\t\tfor(int i=0;i<MaxH;i++)\n\t\t{\n\t\t\tfor(int j=0;j<MaxW;j++)\n\t\t\t{\n\t\t\t\tUsed[i][j]=0;\n\t\t\t\tBFSResult[i][j]=1000;\n\t\t\t}\n\t\t}\nBFSResult[Start.first][Start.second]=0;\n\t\tqueue<pair<long long int,long long int> >task;\n\t\ttask.push(Start);\n\t\tUsed[Start.first][Start.second]=1;\n\t\t\n\t\twhile(!task.empty())\n\t\t{\n\t\t\tlong long int h=task.front().first;\n\t\t\tlong long int w=task.front().second;\n\t\t\tfor(int i=-1;i<=1;i++)\n\t\t\t{\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(h+i<0||w+j<0||h+i>=MaxH||w+j>=MaxW||abs(i-j)==2) \n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(Used[h+i][w+j]==0&&HW[h+i][w+j]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tUsed[h+i][w+j]=1;\n\t\t\t\t\t\tBFSResult[h+i][w+j]=BFSResult[h][w]+1;\n\t\t\t\t\t\ttask.push({h+i,w+j});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttask.pop();\n\t\t}\n\t}\n\t\n};\n\nint main(){\n\tlong long int n,t;\n\tcin>>t>>n;\n\twhile(n!=0||t!=0){\n\t\tBreadthFirstSearch bfs(150,150);\n\t\n\t\tfor(int i=0;i<125;i++){\n\t\t\tfor(int j=0;j<125;j++)\n\t\t\t{\n\t\t\t\tbfs.HW[i][j]='.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong long int x,y;\n\t\t\tcin>>x>>y;\n\t\t\tbfs.HW[x+60][60+y]='#';\n\t\t}\n\t        \n\t\tlong long int p,q;\n\t\tcin>>p>>q;\n\t\tbfs.DoBFS({p+60,q+60});\n\t\t//cout<<4;\n\t\tlong long int res=0;\n\t\tfor(int i=-60;i<65;i++)\n\t\t{\n\t\t\tfor(int j=-60;j<65;j++)\n\t\t\t{\n\t\t\t\tif(bfs.BFSResult[60+i][60+j]<=t){res++;}\n\t\t\t}\n\t\t\t\n\t\t}\n               cout<<res<<endl;\n\t\tcin>>t>>n;\n\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dx[] = {1,0,-1,-1,0,1};\nconst int dy[] = {1,1,0,-1,-1,0};\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t,n,x,y,cnt;\n  while(cin >> t >> n && t+n){\n    vector<vector<ll>> v(65,vector<ll>(65,inf));\n\n    rep(i,n){\n      cin >> x >> y;\n      x += 30;\n      y += 30;\n      v[x][y] = -1;\n    }\n    cin >> x >> y;\n    x += 30;\n    y += 30;\n    cnt = 1;\n    queue<pll> q;\n    q.push(mp(x,y));\n    ll d = 0;\n    v[x][y] = d;\n    while(q.size()){\n      if(d == t) break;\n      ++d;\n      auto S = q.size();\n      rep(j,S){\n        auto Q = q.front();q.pop();\n        rep(i,6){\n          ll nx = Q.fi + dx[i],ny = Q.se + dy[i];\n          if(value(nx,ny,61,61) && v[nx][ny] > v[Q.fi][Q.se]){\n//             cout << nx - 30<< ' ' << ny-30 << endl;\n            q.push(mp(nx,ny));\n            if(v[nx][ny] == inf)\n            ++cnt;\n            v[nx][ny] = d;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define f(i,x,n) for(int i=x;i<(int)(n);++i)\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=50005,INF=1<<29;\nvector<int> dy={1,1,0,-1,-1,0},dx={0,1,1,0,-1,-1};\nint dis[MAX];\n\nvoid BFS(int u,int t){\n    queue<int> Q;\n    Q.push(u);\n    \n    while(!Q.empty()){\n        int a=Q.front();Q.pop();\n        if(dis[a]==t) continue;\n        \n        for(int i=0;i<6;i++){\n            int x=a%200,y=a/200;\n            int xto=x+dx[i],yto=y+dy[i];\n            //if(xto<0||yto<0||xto>=100||yto>=100) continue;\n            \n            if(dis[xto+yto*200]==-1){\n                dis[xto+yto*200]=dis[x+y*200]+1;\n                Q.push(xto+yto*200);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int T,N;cin>>T>>N;\n        if(T+N==0) break;\n        \n        memset(dis,-1,sizeof(dis));\n        \n        for(int i=0;i<N;i++){\n            int a,b;cin>>a>>b;\n            a+=100;b+=100;\n            dis[a+b*200]=INF;\n        }\n        \n        int a,b;cin>>a>>b;\n        a+=100;b+=100;\n        \n        dis[a+b*200]=0;\n        \n        BFS(a+b*200,T);\n        int cnt=0;\n        \n        for(int i=0;i<MAX;i++){\n            if(dis[i]!=-1&&dis[i]<=T) cnt++;\n        }\n        \n        cout<<cnt<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint t, n, d[130][130];\nbool s[130][130];\n\n\nvoid bfs(int x, int y, int k){\n    if(k == 0)return;\n    \n    if(d[x + 1][y] + 1 < k && !s[x + 1][y]){\n        d[x + 1][y] = k - 1;\n        bfs(x + 1, y, k - 1);\n    }\n    if(d[x - 1][y] + 1 < k && !s[x - 1][y]){\n        d[x - 1][y] = k - 1;\n        bfs(x - 1, y, k - 1);\n    }\n    if(d[x + 1][y + 1] + 1 < k && !s[x + 1][y + 1]){\n        d[x + 1][y + 1] = k - 1;\n        bfs(x + 1, y + 1, k - 1);\n    }\n    if(d[x - 1][y - 1] + 1 < k && !s[x - 1][y - 1]){\n        d[x - 1][y - 1] = k - 1;\n        bfs(x - 1, y - 1, k - 1);\n    }\n    if(d[x][y + 1] + 1 < k && !s[x][y + 1]){\n        d[x][y + 1] = k - 1;\n        bfs(x, y + 1, k - 1);\n    }\n    if(d[x][y - 1] + 1 < k && !s[x][y - 1]){\n        d[x][y - 1] = k - 1;\n        bfs(x, y - 1, k - 1);\n    }\n}\n\nint main() {\n    int sx, sy;\n    \n    cin >> t >> n;\n    \n    while(t != 0 || n != 0){\n        REP(i, 130){\n            REP(j, 130){\n                d[i][j] = -INF;\n                s[i][j] = false;\n            }\n        }\n        \n        REP(i, n){\n            int x, y;\n            cin >> x >> y;\n            s[x + 65][y + 65] = true;\n        }\n        \n        cin >> sx >> sy;\n        \n        d[sx + 65][sy + 65] = t;\n        bfs(sx + 65, sy + 65, t);\n        \n        int ans = 0;\n        REP(i, 130){\n            REP(j, 130){\n                if(d[i][j] != -INF)ans++;\n            }\n        }\n        \n        cout << ans << endl;\n        \n        cin >> t >> n;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) v.begin(), v.end()\n#define rev(v) v.rbegin(), v.rend()\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\n\nbool checkSyougai(vector<pair<int, int> > syougai, int x, int y){\n\tfor(int i = 0; i < syougai.size(); i++){\n\t\tif(syougai[i].first == x && syougai[i].second == y) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint dx[] = {-1, -1, 0, 0, 1, 1};\n\tint dy[] = {-1, 0, 1, -1, 0, 1};\n\tmap<int, map<int, bool> > field;\n\tint t, n;\n\tvector<pair<int, int> > syougai;\n\tpair<int, int> start;\n\n\twhile(cin >> t >> n && (t != 0 || n != 0)){\n\t\t//fieldの初期化\n\t\tfor(int i = -30; i <= 30; i++){\n\t\t\tfor(int j = -30; j <= 30; j++){\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\t//障害物とスタート地点の読み込み\n\t\tsyougai.clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpair<int, int> tmp;\n\t\t\tcin >> tmp.X >> tmp.Y;\n\t\t\tsyougai.push_back(tmp);\n\t\t}\n\t\tcin >> start.X >> start.Y;\n\n\t\t//□■■\n\t\t//■■■\n\t\t//■■□fieldは普通の配置を想定して、こんなかんじで探索\n\t\tqueue<pair<int, int> > a;\n\t\tint count = 1;\n\t\ta.push(start);\n\t\tfield[start.Y][start.X] = true;\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tqueue<pair<int, int> > b;\n\t\t\twhile(!a.empty()){\n\t\t\t\tpair<int, int> tmp = a.front();\n\t\t\t\ta.pop();\n\t\t\t\tfor(int j = 0; j < 6; j++){\n\t\t\t\tif((tmp.X + dx[j] < -30 && tmp.X + dx[j] > 30) || (tmp.Y + dy[j] < -30 && tmp.Y + dy[j] > 30)) continue;\n\t\t\t\tif(checkSyougai(syougai, tmp.X + dx[j], tmp.Y + dy[j]) && field[tmp.Y + dy[j]][tmp.X + dx[j]] != true){\n\t\t\t\t\t\tpair<int ,int> next(tmp.X + dx[j], tmp.Y + dy[j]);\n\t\t\t\t\t\tb.push(next);\n\t\t\t\t\t\tfield[tmp.Y + dy[j]][tmp.X + dx[j]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta = b;\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nbool grid[200][200];\nbool syogai[200][200];\nint dx[6] = {1,1,0,-1,-1,0};\nint dy[6] = {0,1,1,0,-1,-1};\nint t,n;\nint memo[200][200];\nvoid dfs(int turn,int x,int y){\n  if(turn==t+1) return ;\n  if(memo[y+100][x+100]<=turn) return;\n  grid[y+100][x+100] = true;\n  memo[y+100][x+100] = turn;\n  REP(r,6){\n    int nx = x+dx[r];\n    int ny = y+dy[r];\n    if(syogai[ny+100][nx+100]==false){\n      dfs(turn+1,nx,ny);\n    }\n  }\n}\n\nint main(void){\n  while(cin>>t>>n){\n    memset(grid,0,sizeof(grid));\n    memset(syogai,0,sizeof(syogai));\n    REP(y,200)REP(x,200)memo[y][x]=INF;\n    if(t==0&&n==0) break;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      syogai[y+100][x+100] = true;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    dfs(0,sx,sy);\n    int ans = 0;\n    REP(fy,200)REP(fx,200)if(grid[fy][fx]){\n      ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pxyi;\n\nvector<pii> N;\nset <pii> s;\nconst int dx[] = {1, 1, 0, -1, -1, 0}, dy[] = {0, 1, 1, 0, -1, -1};\n  \nvoid bfs(int sx, int sy, int st)\n{\n  queue<pxyi> q;\n  q.push(pxyi(pii(sx,sy),st));\n  while(!q.empty()){\n    int x, y, t;\n    x = q.front().first.first;\n    y = q.front().first.second;\n    t = q.front().second;\n    q.pop();\n    s.insert(pii(x,y));\n    if(t == 0){\n      if(q.empty()) break;\n      else continue;\n    }\n    bool flag;\n    for(int i = 0; i < 6; i++){\n      flag = false;\n      int next_x = x + dx[i], next_y = y + dy[i];\n      for(int j = 0; j < (int)N.size(); j++){\n        if(N[j].first == next_x && N[j].second == next_y)\n          flag = true;\n      }\n      if(flag) continue;\n      q.push(pxyi(pii(next_x,next_y),t-1));\n    }\n  }\n}\n\n\nint main()\n{\n  while(1){\n    s.erase(s.begin(),s.end());\n    N.erase(N.begin(),N.end());\n    int t, n;\n    cin >> t >> n;\n    if(t == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){\n      int x, y;\n      cin >> x >> y;\n      N.push_back(pii(x,y));\n    }\n    int start_x, start_y;\n    cin >> start_x >> start_y;\n    bfs(start_x,start_y,t);\n    cout << s.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint T, N, X, Y, SX, SY;\nmap<pii, int> P;\nint dd[7] = { 0, 1, 1, 0, -1, -1, 0 };\n\nint dfs(pii p, int t, int ans) {\n  if((P.count(p) && t >= P[p]) || t > T) return ans;\n  if(P.count(p) == 0) ans++;\n  P[p] = t;\n  REP(i, 0, 6) ans = dfs(pii(p.fi + dd[i], p.se + dd[i + 1]), t + 1, ans);\n  return ans;\n}\n\nint main(void) {\n  while(cin >> T >> N, T || N) {\n    P.clear();\n    REP(i, 0, N) {\n      cin >> X >> Y;\n      P[pii(X, Y)] = 0;\n    }\n    cin >> SX >> SY;\n\n    cout << dfs(pii(SX, SY), 0, 0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int dx[] = { 1, 1, 0,-1,-1, 0 };\nconst int dy[] = { 1, 0,-1,-1, 0, 1 };\nconst int offset=100;\nint board[200][200];\nint cnt,m_turn;\n\nvoid dfs(int x,int y,int t){\n\tboard[y][x]=t;\n\tif(t==m_turn){\n\t\treturn ;\n\t}\n\t\n\tfor(int i=0;i<6;i++){\n\t\tint nx=dx[i]+x,ny=dy[i]+y;\n\t\tif(board[ny][nx]==-1){\n\t\t\tcnt++;\n\t\t}\n\t\tif(board[ny][nx]!=0){\n\t\t\tdfs(nx,ny,t+1);\t\t\t\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tint sx,sy;\n\twhile(cin>>m_turn>>n,m_turn||n){\n\t\tcnt=1;\n\t\tfill((char*)board,(char*)(board+200),-1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tboard[y+offset][x+offset]=0;\n\t\t}\n\t\tcin>>sx>>sy;\t\n\t\tdfs(sx+offset,sy+offset,0);\n\t\t\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 100\n#define NN 200\nusing namespace std;\n#define S pair<int,int>\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,0,1,-1,0,-1};\n  int dy[6] = {0,1,1,0,-1,-1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = 0;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y;\n      d[y+N][x+N] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n    queue<S> q; q.push( S(x,y) ); d[y][x]=1;\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      if( d[s.second][s.first]<=t ){\n\tfor( int i=0,nt=d[s.second][s.first]+1;i<6;i++ ){\n\t  int nx=s.first+dx[i], ny=s.second+dy[i];\n\t  if( d[ny][nx]==0 ){\n\t    q.push( S(nx,ny) ); d[ny][nx]=nt;\n\t    ans++;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdint.h>\n\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef std::pair<int, int> pii;\n\nint Map_[128][128];\nint& Map(int x, int y) {\n  return Map_[x + 64][y + 64];\n}\n\nint dist_[128][128];\nint& dist(int x, int y) {\n  return dist_[x + 64][y + 64];\n}\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      Map_[i][j] = 0;\n      dist_[i][j] = -1;\n    }\n  }\n}\n\n\nconst int dx[6] = {1, 1, 0, -1, -1, 0};\nconst int dy[6] = {0, 1, 1, 0, -1, -1};\nvoid dfs(int x, int y, int d) {\n  if( not ( -64 <= x and x < 64 and -64 <= y and y < 64 ) ) return;\n  if( dist(x, y) >= d ) return;\n  if( Map(x, y) == 1 ) return;\n  if( d < 0 ) return;\n  dist(x, y) = d;\n  for(int i = 0; i < 6; ++i) {\n    dfs(x + dx[i], y + dy[i], d - 1);\n  }\n}\n\nint answer() {\n  int res = 0;\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      if( dist_[i][j] != -1 ) res += 1;\n    }\n  }\n  return res;\n}  \n\nint main() {\n\n  for(;;) {\n    init();\n    int t, n;\n    std::cin >> t >> n;\n    if( t == 0 and n == 0 ) break;\n    int x, y;\n    for(int i = 0; i < n; ++i) {\n      std::cin >> x >> y;\n      Map(x, y) = 1;\n    }\n    std::cin >> x >> y;\n    dfs(x, y, t);\n    std::cout << answer() << std::endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,1,0,-1,-1};\nint dy[] = {1,1,0,-1,-1,0};\n\nvoid solve(int t, map<P,int>& f, queue<P>& que){\n\n\twhile( !que.empty() ){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\t\tP p_(x,y);\n\t\tint cnt = f[p_] + 1;\n\t\t//cout << \"(x,y) = (\" << x << \",\" << y << \") : \" << cnt << endl;\n\t\tif( cnt > t+1 )\n\t\t\tcontinue;\n\t\t\t\n\t\tfor(int i=0 ; i<6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tP p(mx,my);\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 || f[p] == -1 ) continue;\n\t\t\t\n\t\t\tif( f[p] == 0 ){\n\t\t\t\tf[p] = cnt;\n\t\t\t\tque.push( p );\n\t\t\t}\n\t\t}\n\t};\n}\n\nint main(){\n\tint t,n;\n\t\n\twhile( cin >> t >> n , t||n ){\n\t\tmap<P,int> f;\n\t\tf.clear();\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tf[p] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tP p(x,y);\n\t\t\tf[p] = -1;\n\t\t}\n\t\t\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tP sp(sx,sy);\n\t\tf[sp] = 1;\n\t\tqueue<P> que;\n\t\tque.push( sp );\n\t\tsolve( t , f , que );\n\t\tint ans = 0;\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x=-30 ; x <= 30 ; x++ ){\n\t\t\t\tP p(x,y);\n\t\t\t\tif( f[p] > 0 ) ans++;\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans : \" << ans << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t, n;\n    int table[31] = {0};\n    table[1] = 1;\n    rrep(i, 2, 31) {\n        table[i] = table[i - 1] + 6 * i - 6;\n    }\n    //rep(i, 31) cout << table[i] << \" \"; cout << endl;\n    while (cin >> t >> n) {\n        if (t == 0 && n == 0) break;\n        int a[31], b[31];\n        int stx, sty;\n        rep(i, n) {\n            cin >> a[i] >> b[i];\n        }\n        cin >> stx >> sty;\n        rep(i, n) {\n            a[i] -= stx;\n            b[i] -= sty;\n        }\n        int ans = 0;\n        rrep(i, 1, 31) {\n            int tabl[6] = {0};\n            rep(j, n) {\n                if (a[j] == i && b[j] == i) tabl[0] = 1;\n                if (a[j] == i && b[j] == 0) tabl[1] = 1;\n                if (a[j] == 0 && b[j] == -i) tabl[2] = 1;\n                if (a[j] == -i && b[j] == -i) tabl[3] = 1;\n                if (a[j] == -i && b[j] == 0) tabl[4] = 1;\n                if (a[j] == 0 && b[j] == i) tabl[5] = 1;\n            }\n            //rep(j, 6) cout << tabl[j] << \" \"; cout << endl;\n            rep(j, 6) {\n                if (tabl[j] == 0) break;\n                if (j == 5) {\n                    rep(k, n) {\n                        if (abs(a[k]) > i) continue;\n                        int flg = 0;\n                        if (i % 2 == 0) {\n                            if (a[k] == i / 2 && b[k] == -i / 2) {ans--; flg = 1;}\n                            if (a[k] == -i / 2 && b[k] == i / 2) {ans--; flg = 1;}\n                        }\n                        if (flg == 0) ans--;\n                    }\n                    //cout << ans << endl;\n                    ans += table[i + 1];\n                    cout << ans << endl;\n                    return 0;\n                }\n            }\n            \n        }\n        ans += table[t + 1];\n        rep(i, n) {\n            if (abs(a[i]) > t) continue;\n            int flg = 0;\n            if (t % 2 == 0) {\n                if (a[i] == t / 2 && b[i] == -t / 2) {flg = 1; ans--;}\n                if (a[i] == -t / 2 && b[i] == t / 2) {flg = 1; ans--;}\n            }\n            if (flg == 0) ans--;\n        }\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\tmp[tx+50][ty+50]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tint sum=1;\n\t\tflag[sx+50][sy+50]=true;\n\t\tqueue<pair<int,PII> >q;\n\t\tq.push(MP(t,MP(sx+50,sy+50)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tint tt=pi.first;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(tt-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1,1,0,-1,-1,0};\nint dy[] = {1,0,-1,-1,0,1};\n\nint t, n, sx, sy, ans, diff = 200;\nbool visited[300][300][31];  //(a, b) -> visited[a+30][b+30]\nbool obj[300][300];\n\nvoid dfs(int y, int x, int turn){\n  if(visited[y+diff][x+diff][turn]) return;\n  if(turn > t) return;\n\n  bool flag = true;\n  REP(i,0,31){\n    if(visited[y+diff][x+diff][i]) flag = false;  /*??\\????????¨?????????*/\n  }\n  if(flag) ans++;\n\n  visited[y+diff][x+diff][turn] = true;\n\n  REP(k,0,6){\n    int nx = x + dx[k], ny = y + dy[k];\n    //if(!CH(ny+100, 0, 61) || !CH(nx+100, 0, 61)) continue;\n    if(obj[ny+diff][nx+diff]) continue;\n    dfs(ny, nx, turn + 1);\n  }\n  return;\n}\n\nint main() {\n  //test\n  //vector<int> v;\n\n  while(1){\n    cin>>t>>n;\n    if(t==0 && n==0) break;\n    REP(i,0,300)REP(j,0,300) obj[i][j] = false;\n    REP(i, 0, n){\n      int x, y;\n      cin>>x>>y;\n      obj[y+diff][x+diff] = true;\n    }\n    cin>>sx>>sy;\n\n    REP(i,0,300)REP(j,0,300)REP(k,0,31) visited[i][j][k] = false;\n    ans = 0;\n\n    dfs(sy, sx, 0);\n\n    cout<<ans<<endl;\n    //v.push_back(ans);\n  }\n\n  //REP(i,0,v.size()) cout<<v[i]<<\" \";\n  //cout<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define MAX 128\n#define INF 128\n\nint main()\n{\n\tconst int dx[6] = {1, 1, 0, -1, -1, 0}, dy[6] = {1, 0, -1, -1, 0, 1};\n\twhile(1) {\n\t\tbool is_wall[MAX][MAX] = {false};\n\t\tint d[MAX][MAX] = {0};\n\t\tqueue<P> que;\n\t\tint t, n;\n\t\tint px, py;\n\t\tint ans = 0;\n\t\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &t, &n);\n\t\tif(!t && !n) break;\n\t\twhile(n--) {\n\t\t\tint wx, wy;\n\t\t\tscanf(\"%d %d\", &wx, &wy);\n\t\t\tis_wall[wx+30][wy+30] = true;\n\t\t}\n\t\tscanf(\"%d %d\", &px, &py);\n\t\tque.push(P(px, py));\n\t\td[px+30][py+30] = 0;\n\t\twhile(!que.empty()) {\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(d[x+30][y+30] == t) continue;\n\t\t\tfor(int i = 0; i < 6; i++) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif(-30 <= xx && xx <= 30 && -30 <= yy && yy <= 30 && !is_wall[xx+30][yy+30] ) {\n\t\t\t\t\tif(d[xx+30][yy+30] > d[x+30][y+30] + 1) {\n\t\t\t\t\t\td[xx+30][yy+30] = d[x+30][y+30] + 1;\n\t\t\t\t\t\tque.push(P(xx, yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(d[i][j] <= t) ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nvector<int> ox; //障害物のx座標\nvector<int> oy; //障害物のy座標\n\nclass State{\npublic:\n  int x, y, cost;\n\n  State(){}\n  State(int _x,int _y,int _cost){\n    x = _x;\n    y = _y;\n    cost = _cost;\n  }\n};\n\nint Breadth_First_Search(int t, int n, int sx, int sy) {\n  //static const int dx[] = {-1,-1,0,1,1,0};\n  //static const int dy[] = {-1,0,1,1,0,-1};\n  int dx[] = {0,1,1,0,-1,-1};\n  int dy[] = {1,1,0,-1,-1,0};\n  bool closed[500][500];\n  int count = 0;\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(sx,sy,0));\n\n  for(int i = 0; i < t; i++){\n    closed[ox[i]][oy[i]] = true;\n  }\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.x][st.y] || st.cost > n)\n      continue;\n    closed[st.x][st.y] = true;\n\n    count++;\n\n    for(int i = 0; i < 6; i++) {\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      open.push(State(nx, ny, st.cost + 1));\n    }\n  }\n\n  return count;\n}\n\nint main() {\n  int t; //ターン数\n  int n; //障害物の数\n  int sx, sy; //スタートマス\n\n  while(1){\n    cin >> t >> n;\n    if(t == 0 && n == 0)\n      break;\n\n    for(int i = 0; i < n; i++) {\n      int X, Y;\n      cin >> X >> Y;\n      X += 200;\n      Y += 200;\n      ox.push_back(X);\n      oy.push_back(Y);\n    }\n\n    cin >> sx >> sy;\n    sx += 200;\n    sy += 200;\n\n    cout << Breadth_First_Search(t, n, sx, sy) << endl;\n    ox.clear();\n    oy.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[6] = {1, 1, 0, -1, -1, 0};\nint dy[6] = {1, 0, -1, -1, 0, 1};\ntypedef tuple<int, int, int> T;\n\nvoid solve(int t, int n){\n\tint a[500][500];\n\tfor(int i=0; i<500; ++i)\n\t\tfor(int j=0; j<500; ++j)\n\t\t\ta[i][j] = 0;\n\tfor(int i=0; i<n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ta[x+200][y+200] = -1;\n\t}\n\tint x, y;\n\tcin >> x >> y;\n\ta[x+200][y+200] = t+1;\n\tqueue<T> q;\n\tq.push(T(x+200, y+200, t+1));\n\twhile(!q.empty()){\n\t\tT tp = q.front();\n\t\tq.pop();\n\t\tfor(int i=0; i<6; ++i){\n\t\t\tint nx = get<0>(tp)+dx[i];\n\t\t\tint ny = get<1>(tp)+dy[i];\n\t\t\tif(0 <= nx && nx < 500 && 0 <= ny && ny < 500 && a[nx][ny] != -1 && get<2>(tp) - 1 > a[nx][ny]){\n\t\t\t\ta[nx][ny] = get<2>(tp) - 1;\n\t\t\t\tif(a[nx][ny] > 1)\n\t\t\t\t\tq.push(T(nx, ny, a[nx][ny]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<500; ++i)\n\t\tfor(int j=0; j<500; ++j){\n\t\t\tif(a[i][j] > 0)\n\t\t\t\t++ans;\n//\t\t\tcout << a[i][j] << (j == 60 ? \"\\n\" : \" \");\n\t\t}\n\tcout << ans << \"\\n\";\n}\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tint t, n;\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) return 0;\n\t\tsolve(t, n);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<bool, 70>, 70> hex, array<array<int32_t, 70>, 70> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 1;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t posx = x + iter->first;\n      int32_t posy = y + iter->second;\n      if (0 <= posx && posx < 70 && 0 <= posy && posy < 70 && !hex[posx][posy] && dists[posx][posy] == 0) {\n        dists[posx][posy] = dists[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<bool, 70>, 70> hex;\n    array<array<int32_t, 70>, 70> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        hex[i][j] = false;\n        dists[i][j] = 0;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      hex[x + 35][y + 35] = true;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(hex, dists, x + 35, y + 35);\n\n    uint32_t count = 0;\n    for (auto iter = dists.begin(); iter < dists.end(); iter++) {\n      for (auto i = iter->begin(); i < iter->end(); i++) {\n        if (1 <= *i && *i <= t + 1) {\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\n\nint bfs(int sx , int sy , int t ,map<P,int> s ,map<P,bool> b ){\n\ts[P(sx,sy)] = 0;\n\tqueue<P> q;\n\tq.push( P(sx,sy) );\n\t\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tint cnt = s[P(x,y)];\n\t\tfor(int i=0 ; i < 6 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( b[P(mx,my)] ) continue;\n\t\t\tif( abs(mx) > 30 || abs(my) > 30 ) continue;\n\t\t\t \n\t\t\tif( cnt + 1 <= t && s[P(mx,my)] == INF ){\n\t\t\t\ts[P(mx,my)] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint result = 0;\n\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\tfor(int x = -30 ; x <= 30 ; x++ ){\n\t\t\tif( s[P(x,y)] != INF ){\n\t\t\t\tresult++;\n\t\t\t} \n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\tint t, n;\n\twhile( cin >> t >> n , t || n ){\n\t\t// s[P(x,y)] := ツ鳴「ツ探ツ催オツづ個づ?つォINF, ツ探ツ催オツ催渉づ敖づ個づ?つォツタツーツδ督青板つェツ禿シツづゥ\n\t\tmap<P,int> s;\n\t\t// b[P(x,y)] := ツ津環づェツづ按つ「ツづ?つォtrue\n\t\tmap<P,bool> b;\n\n\t\tfor(int y=-30 ; y <= 30 ; y++ ){\n\t\t\tfor(int x = -30 ; x <= 30 ; x++ ){\n\t\t\t\ts[P(x,y)] = INF;\n\t\t\t\tb[P(x,y)] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tb[P(x,y)] = true;\n\t\t}\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\t\tint ans = bfs( sx , sy , t , s , b );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"queue\"\nusing namespace std;\nint dx[6]={0,1,1,0,-1,-1},dy[6]={-1,0,1,1,0,-1};\nbool pass[100][100];\nbool used[100][100];\nint t,n;\nint main(void)\n{\n\twhile (cin>>t>>n,t) {\n\t\tmemset(pass,0,sizeof(pass));\n\t\tmemset(used,0,sizeof(used));\n\t\tint x,y;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin>>x>>y;\n\t\t\tpass[y+30][x+30]=true;\t\n\t\t}\n\t\tcin>>x>>y;\n\t\tqueue<int> xs,ys,cnts;\n\t\txs.push(x+30); ys.push(y+30); cnts.push(0);\n\t\twhile (!xs.empty()) {\n\t\t\tint x=xs.front(),y=ys.front(),cnt=cnts.front();\n\t\t\txs.pop(); ys.pop(); cnts.pop();\n\t\t\tused[y][x]=true;\n\t\t\tif(cnt<t)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx&&0<=ny&&!pass[ny][nx]&&!used[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\txs.push(nx); ys.push(ny); cnts.push(cnt+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nstring str;\n\nchar leftKey[] = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'};\n\nbool inLeft(char c) {\n  for (int i = 0; i < sizeof(leftKey); i++) {\n    if (c == leftKey[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n  int isLeft = inLeft(str[0]);\n  int cnt = 0;\n  \n  for (int i = 1; i < str.size(); i++) {\n    if (isLeft != inLeft(str[i])) {\n      isLeft = inLeft(str[i]);\n      cnt++;\n    }\n  }\n  printf(\"%d\\n\", cnt);\n}\n\nint main() {\n  while (true) {\n    getline(cin, str);\n    if (str == \"#\") {\n      return 0;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint main() {\n  int t, n;\n  while(cin >> t >> n && (t|n)) {\n    int M[100][100] = {};\n    int const BX = 50, BY = 50;\n    for(int i=0; i<n; i++) {\n      int x, y;\n      cin >> x >> y;\n      M[y+BY][x+BX] = 1;\n    }\n    \n    int const dx[] = {-1,1,0,0,1,-1};\n    int const dy[] = {0,0,-1,1,1,-1};\n    \n    typedef pair<int, int> Pii;\n    typedef pair<Pii, int> P;\n    \n    bool used[100][100] = {};\n    int ans = 0;\n    \n    int sx, sy;\n    cin >> sx >> sy; sx += BX, sy += BY;\n    \n    queue<P> Q;\n    Q.push(P(Pii(sx, sy), t));\n    used[sy][sx] = true;\n    \n    while(!Q.empty()) {\n      P const p = Q.front(); Q.pop();\n      ans ++;\n      \n      if(p.snd <= 0) continue;\n      \n      for(int i=0; i<6; i++) {\n\tint nx = p.fst.fst + dx[i], ny = p.fst.snd + dy[i];\n\tif(!used[ny][nx] && M[ny][nx] == 0) {\n\t  Q.push( P(Pii(nx, ny), p.snd-1) );\n\t  used[ny][nx] = true;\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nint dx[6]={1,1,0,-1,-1,0},dy[6]={1,0,-1,-1,0,1};\n\nint grid[200][200];\n\npiii makePiii(int a,int b,int c){\n  pii A=make_pair(b,c);\n  piii res=make_pair(a,A);\n  return res;\n}\n\nint bfs(int t,int sx,int sy){\n  int res=1;\n  queue<piii> q;\n  q.push(makePiii(0,sx,sy));\n  while(!q.empty()){\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    int cnt=q.front().first;\n    q.pop();\n    if(cnt == t)continue;\n    //cout << \"cnt:\" << cnt << \" q.size:\" << q.size()<< endl;\n\n    for(int i=0;i<6;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(grid[ny][nx]==0){\n\t//cout << \"nx:\" << nx << \" ny:\" << ny << endl;\n\tgrid[ny][nx]=-1;\n\tres++;\n\tq.push(makePiii(cnt+1,nx,ny));\n      }\n    }\n  }\n  return res;\n}\nconst int base=100;\nint main(){\n  int t,n;\n  while(cin>>t>>n){\n    if(t==0 && n==0)break;\n    memset(grid,0,sizeof(grid));\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin>>x>>y;\n      grid[y+base][x+base]=-1;\n    }\n    int sx,sy;\n    cin>>sx>>sy;\n    grid[sy+base][sx+base]=-1;\n    cout <<  bfs(t,sx+base,sy+base) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n); for(int i=0;i<(n);i++)\n\nint vec1[]={0,1,-1,1,-1,0};\nint vec2[]={1,1,0,0,-1,-1};\n\nint t,n;\nint table[200][200];\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\nqueue<piii> q1;\n\nint ans;\n\nint solve(int y,int x){\n\tqueue<piii> p;\n\tq1.push(make_pair(0,make_pair(y,x)));\n\twhile(!q1.empty()){\n\t\tif(t <= q1.front().first)\n\t\t\treturn 0;\n\t\tREP(i,6){\n\t\t\tint n_y = q1.front().second.first + vec1[i];\n\t\t\tint n_x = q1.front().second.second + vec2[i];\n\t\t\tif(table[n_y][n_x] = 0){\n\t\t\t\tans++;\n\t\t\t\ttable[n_y][n_x] = 1;\n\t\t\t\tq1.push(make_pair(q1.front().first + 1,make_pair(n_y,n_x)));\n\t\t\t}\n\t\t}\n\t\tq1.pop();\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(cin>>t>>n,t+n){\n\t\tans = 0;\n\t\tfill_n(table[0],200*200,0)\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\ttable[100+y][100+x] = 1;\n\t\t}\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttable[100+y][100+x] = 1;\n\t\tsolve(100+y,100+x);\n\t\tcout<<ans+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x,y;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;\n\t\tfor(int i=0;i<s;i++){\n\t\t\tcin >> x >> y;\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY;\n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define MAX 100\n#define INF 1e9\n\nstruct P{\n  int x, y, d;\n  P(int x, int y, int d){\n    this->x = x;\n    this->y = y;\n    this->d = d;\n  }\n};\n\nint t, sx, sy;\nbool impossible[MAX][MAX];\nint dist[MAX][MAX];\nconst int dx[] = {-1,0,0,-1,1,1};\nconst int dy[] = {-1,-1,1,0,0,1};\n\nbool check(int x, int y){\n  if(0 <= x && x <= 60 && \n     0 <= y && y <= 60){\n    return true;\n  }\n  return false;\n}\n\nint bfs(int x, int y){\n  fill(dist[0],dist[MAX],INF);\n\n  queue<P> que;\n  que.push(P(x,y,0));\n  dist[x][y] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n\n    if(impossible[p.x][p.y] || p.d >= t){\n      continue;\n    }\n\n    for(int i = 0 ; i < 6 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      \n      if(!check(nx,ny) || impossible[nx][ny] ||\n         dist[nx][ny] != INF){\n        continue;\n      }\n\n      dist[nx][ny] = dist[p.x][p.y] + 1;\n      que.push(P(nx,ny,dist[nx][ny]));\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dist[i][j] <= t){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, x, y;\n\n  while(cin >> t >> n , (t | n)){\n    memset(impossible,false,sizeof(impossible));\n    for(int i = 0 ; i < n ; i++){\n      cin >> x >> y;\n      x += 30, y += 30;\n      impossible[x][y] = true;\n    }\n    cin >> sx >> sy;\n    cout << bfs(sx+30, sy+30) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,n,x,y,ans,sx,sy;\n  int mp[61][61];\n  while(1){\n    cin>>t>>n;\n    for(int i=0;i<61;i++){\n      for(int j=0;j<61;j++){\n\tmp[i][j]=0;\n      }\n    }\n    ans=0;\n    if(t==0 && n==0) break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      mp[y+30][x+30]=-1;\n    }\n    cin>>sx>>sy;\n    mp[sy+30][sx+30]=1;\n    for(int i=1;i<=t;i++){\n      for(int j=0;j<61;j++){\n\tfor(int k=0;k<61;k++){\n\t  if(mp[j][k]==i){\n\t    for(int l=-1;l<2;l++){\n\t      if(mp[j+l][k]==0){\n\t\tmp[j+l][k]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j][k+l]==0){\n\t\tmp[j][k+l]=i+1;\n\t\tans++;\n\t      }\n\t      if(mp[j+l][k+l]==0){\n\t\tmp[j+l][k+l]=i+1;\n\t\tans++;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<ans+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(void){\n    int t, n;\n    int dx[]={1, 1, 0, -1, -1, 0};\n    int dy[]={0, 1, 1, 0, -1, -1};\n    while(cin>>t>>n, t){\n        bool field[202][202];\n        for(int i=0; i<=200; i++){\n            for(int j=0; j<=200; j++){\n                field[i][j]=true;\n            }\n        }\n        while(n--){\n            int x, y;\n            cin >> x >> y;\n            field[x+100][y+100]=false;\n        }\n        int sx, sy;\n        cin >> sx >> sy;\n        queue<pair<pair<int, int>,int>> q;\n        bool visited[202][202];\n        for(int i=0; i<=200; i++){\n            for(int j=0; j<=200; j++){\n                visited[i][j]=false;\n            }\n        }\n        visited[sx+100][sy+100]=true;\n        q.push(make_pair(make_pair(sx+100, sy+100),0));\n        int count=0;\n        while(!q.empty()){\n            int nx=q.front().first.first, ny=q.front().first.second, now=q.front().second;\n            if(now>t) break;\n            count++;\n            for(int i=0; i<6; i++){\n                if(field[nx+dx[i]][ny+dy[i]]&&!visited[nx+dx[i]][ny+dy[i]]){\n                    visited[nx+dx[i]][ny+dy[i]]=true;\n                    q.push(make_pair(make_pair(nx+dx[i], ny+dy[i]),now+1));\n                }\n            }\n            q.pop();\n        }\n        cout << count << \"\\n\";\n         \n    }\n     \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define MAX 60\nusing namespace std;\n\ntypedef pair<int,int> P;\nint stage[MAX+1][MAX+1];\nint d[MAX+1][MAX+1];\n\nint dx[6] = {0,1,0,-1,1,-1};\nint dy[6] = {1,0,-1,0,1,-1};\n\nvoid clear(){\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\td[i][j] = 0;\n\t\t\tstage[i][j] = 0;\n\t\t}\n\t}\n}\nvoid s(queue<P>,int turn);\nint sum(){\n\tint res = 0;\n\tfor(int i = 0;i < MAX+1;i++){\n\t\tfor(int j = 0;j < MAX+1;j++){\n\t\t\tif(d[i][j] == 1) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint t,n,sX,sY,x=0,y=0,i;\n\twhile(1){\n\t\tclear();\n\t\t//input\n\t\tcin >> t >> n;\n\t\tif(t == 0 && n == 0) break;i=0;\n\t\twhile(i<n){i++;\n\t\t\tcin >> x >> y;getchar();\n\t\t\tstage[x+30][y+30] = 1;\n\t\t}\n\t\tcin >> sX >> sY; \n\t\t//input end\n\t\tqueue<P> que;\n\t\tque.push(P(sX+30,sY+30)); \n\t\td[sX+30][sY+30] = 1;\n\t\ts(que,t);\n\t\tque.pop();\n\t\tcout << sum() << endl;\n\t}\n\treturn 0;\n}\n\nvoid s(queue<P> que1,int turn){\n\tif(turn == 0) return;\n\tqueue<P> que2;\n\twhile(!que1.empty()){\n\t\tP xy = que1.front();\n\t\tque1.pop();\n\t\tint x = xy.first,y = xy.second;\n\t\tfor(int i = 0;i < 6;i++){\n\t\t\tif(stage[x+dx[i]][y+dy[i]] == 0 && d[x+dx[i]][y+dy[i]] == 0){\n\t\t\t\td[x+dx[i]][y+dy[i]] = 1;\n\t\t\t\tque2.push(P(x+dx[i],y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts(que2,turn-1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nint d[]={0,1,-1};\n#define piii pair<pii,int>\nint main(){\n    int t,n;\n    while(cin>>t>>n, t+n){\n        map<pii,int>mp;\n        rep(i,n){\n            pii temp; cin>>temp.first>>temp.second;\n            temp=pii(temp.first,temp.second);\n            mp[temp]++;\n        }\n        queue<piii>que;\n        pii s; cin>>s.first>>s.second;\n        map<pii,int>visit;\n        que.push(make_pair(s,0));\n        int ans=0;\n        while(!que.empty()){\n            piii now=que.front(); que.pop();\n            if(now.second>t)continue;\n            if(mp[now.first])continue;\n            if(!visit[now.first])ans++;\n            if(visit[now.first]!=0&&visit[now.first]<now.second)continue;\n            visit[now.first]=now.second;\n            if(now.first==s)visit[now.first]=1;\n            rep(i,3)rep(j,3){\n                if(d[i]+d[j]==0)continue;\n                que.push(make_pair(pii(now.first.first+d[i],now.first.second+d[j]),now.second+1));\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[] = {-1, -1,  0, 0, 1, 1};\nint dy[] = {-1,  0, -1, 1, 0, 1};\nbool Field[61][61];\n\nvoid solve()\n{\n\tint t, n;\n\twhile(cin >> t >> n, t || n)\n\t{\n\t\tmemset(Field, 0, sizeof(Field));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x ,y;\n\t\t\tcin >> x >> y;\n\t\t\tField[y + 30][x + 30] = true;\n\t\t}\n\t\tint count = 1;\n\t\tP p;\n\t\tcin >> p.first >> p.second;\n\t\tp.first += 30;\n\t\tp.second += 30;\n\t\tqueue<P> Que;\n\t\tQue.push(p);\n\t\tField[p.second][p.first] = true;\n\t\tqueue<P> NextQue;\n\t\tfor(int a = 0; a < t; ++a)\n\t\t{\n\t\t\twhile(!Que.empty())\n\t\t\t{\n\t\t\t\tP p1 = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor(int i = 0; i < 6; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = p1.first + dx[i];\n\t\t\t\t\tnext.second = p1.second + dy[i];\n\t\t\t\t\tif(Field[next.second][next.first] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tField[next.second][next.first] = true;\n\t\t\t\t\t\tNextQue.push(next);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!NextQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(NextQue.front());\n\t\t\t\tNextQue.pop();\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<functional>\n\n\n#define TEST 1\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./ans.txt\", \"w\", stdout);\n#endif\n\nusing namespace std;\n\nconst int dx[6] = { 1, 1, 0, -1, -1, 0 };\nconst int dy[6] = { 0, 1, 1, 0, -1, -1 };\nint x, y;\nmap<pair<int, int>, bool> state;\nqueue<int> qx,qy,qt;\nint t,n;\nint sx, sy;\n\nint f(int nx,int ny,int turn){\n\tint ans = 1;\n\tstate[make_pair(nx,ny)] = true;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqt.push(turn);\n\t\twhile (!qx.empty()){\n\t\t\tnx = qx.front(), ny = qy.front(), turn = qt.front();\n\t\t\t\tqx.pop();\n\t\t\t\tqy.pop();\n\t\t\t\tqt.pop();\n\t\t\t\tif (!state[make_pair(nx, ny)]){\n\t\t\t\t\tans++;\n\t\t\t\t\tstate[make_pair(nx, ny)] = true;\n\t\t\t\t}\n\t\t\tif (turn < t){\n\t\t\t\tfor (int i = 0; i < 6; ++i){\n\t\t\t\t\tif (!state[make_pair(nx + dx[i],ny + dy[i])]){\n\t\t\t\t\t\tqx.push(nx + dx[i]);\n\t\t\t\t\t\tqy.push(ny + dy[i]);\n\t\t\t\t\t\tqt.push(turn + 1);\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\n\twhile (1){\n\t\tcin >> t >> n;\n\t\tif (!t&&!n)break;\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x >> y;\n\t\t\tstate[make_pair(x,y)]=true;\n\t\t}\n\t\tcin >> sx >> sy;\n\t\t\tcout << f(sx, sy, 0) << endl;\n\n\t\tstate.clear();\n\n\t}\n#if TEST\n\tfclose(in);\n\tfclose(out);\n#endif\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n\nint T,N;\nint sx,sy;\n\nvoid solve(){\n    set<pair<int,int>> obs;\n    for(int i=0;i<N;i++){\n        int x,y;\n        cin >> x >> y;\n        obs.insert(make_pair(x,y));\n    }\n    cin >> sx >> sy;\n\n    using Node = tuple<int,int,int>;\n    using P = pair<int,int>;\n\n    map<P,int> vis;\n    queue<Node> que;\n    vis[P(sx,sy)] = 0;\n    que.push(Node(sx,sy,0));\n    while(!que.empty()){\n        int x,y,t;\n        tie(x,y,t) = que.front();\n        que.pop();\n        if(t == T) continue;\n\n        for(int dx=-1;dx<=1;dx++){\n            for(int dy=-1;dy<=1;dy++){\n                if(dx*dy==-1 or (dx==0 and dy==0)) continue;\n                int nx = x + dx;\n                int ny = y + dy;\n                //if(abs(nx) > 30 or abs(ny) > 30) continue;\n                if(obs.count(make_pair(nx,ny))) continue;\n\n                if(vis.count(P(nx,ny)) and vis[P(nx,ny)] <= t+1) continue;\n                vis[P(nx,ny)] = t+1;\n                que.push(Node(nx,ny,t+1));\n            }\n        }\n    }\n    int cnt = 0;\n    for(auto p : vis){\n        cnt++;\n        if(obs.count(p.first)){\n            cout << \"ERROR\" << endl;\n        }\n    }\n    cout << cnt << endl;\n}\n\nint main(){\n    while(1){\n        cin >> T >> N;\n        if(T==0 and N==0) break;\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={1,0,1,-1,0,-1};\nint ban[200][200];\nint bfs[200][200];\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b),a){\n        for(int i=0;i<200;i++)for(int j=0;j<200;j++)ban[i][j]=bfs[i][j]=0;\n        for(int i=0;i<b;i++){\n            int c,d;\n            scanf(\"%d%d\",&c,&d);\n            c+=100;\n            d+=100;\n            ban[c][d]=1;\n        }\n        int p,q;\n        scanf(\"%d%d\",&p,&q);\n        p+=100;\n        q+=100;\n        queue<pair<int,int> > Q;\n        Q.push(make_pair(p,q));\n        bfs[p][q]=a+1;\n        while(Q.size()){\n            int row=Q.front().first;\n            int col=Q.front().second;\n            Q.pop();\n            if(bfs[row][col]==1)break;\n            for(int i=0;i<6;i++){\n                if(!bfs[row+dx[i]][col+dy[i]]&&!ban[row+dx[i]][col+dy[i]]){\n                    bfs[row+dx[i]][col+dy[i]]=bfs[row][col]-1;\n                    Q.push(make_pair(row+dx[i],col+dy[i]));\n                }\n            }\n        }\n        int ret=0;\n        for(int i=0;i<200;i++)for(int j=0;j<200;j++)if(bfs[i][j])ret++;printf(\"%d\\n\",ret);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,-1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    while(1){\n        int t,n;\n        cin >> t >> n;\n        if(t == 0) break;\n        set<P> suzu;\n        for(int i=0; i<n; i++){\n            int a,b;\n            cin >> a >> b;\n            P p = {a, b};\n            suzu.insert(p);\n        }\n        int fx,fy;\n        cin >> fx >> fy;\n        set<P> used;\n        queue<pair<int,P>> que;\n        que.emplace(0,make_pair(fx,fy));\n        used.insert(make_pair(fx,fy));\n        while(que.size()){\n            auto hoge = que.front();\n            que.pop();\n            int cnt = hoge.first;\n            int x,y;\n            x = hoge.second.first;\n            y = hoge.second.second;\n            if(cnt == t) continue;\n            for(int i=0; i<6; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                P p = {nx,ny};\n                if(!suzu.count(p) and !used.count(p)){\n                    used.insert(p);\n                    que.emplace(cnt+1,p);\n                }\n            }\n        }\n        cout << used.size() << enld;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define N 50\n#define NN 2*N\nusing namespace std;\nstruct S{\n  int x,y,t;\n  S(int x=0,int y=0,int t=0):x(x),y(y),t(t){};\n};\n\nint main(){\n  int t,n,x,y;\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN]; // 50 geta\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = 1000;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[x][y] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n\n    queue<S> q;\n    q.push( S(x,y,0) );\n    int dx[6] = {1,1,0,-1,-1,0};\n    int dy[6] = {1,0,-1,-1,0,1};\n\n    int ans=1; // 初期位置\n    d[x][y] = 0;\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n\n      int nt = s.t+1;\n      if( nt>t ) continue;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.x+dx[i], ny=s.y+dy[i];\n\tif( d[nx][ny]<=nt ) continue;\n\td[nx][ny]=nt; ans++;\n\tq.push( S(nx,ny,nt) );\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint cnt;\nint t;\nint field[61][61];\n\nvoid dfs(int x,int y,int turn){\n  int dx[6] = {0, 1, 1, 0, -1, -1};\n  int dy[6] = {1, 1, 0, -1, -1, 0};\n\n  if(x<0 || x>60 || y<0 || y>60) return;\n\n  if(turn>t) return;\n\n  if(field[x][y]==-1) return;\n  else{\n    field[x][y] = turn;\n    if(turn==0) field[x][y]=100;\n    //cnt++;\n  }\n\n  for(int i=0;i<6;++i){\n    dfs(x+dx[i],y+dy[i],turn+1);\n  }\n  //cout << turn << \" \" << x-30 << \" \" << y-30 << endl;\n  return;\n}\n\nint main(){\n\n  for(int n;cin>>t>>n,t;){\n    cnt = 0;\n\n    // initialize\n    for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n        field[i][j] = 0;\n      }\n    }\n\n    // syougaibutsu\n    for(int i=0;i<n;++i){\n      int x,y;\n      cin>>x>>y;\n      field[x+30][y+30] = -1;\n    }\n\n /*   for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n       cout << field[i][j] << \" \";\n      }\n      cout << endl;\n    }\n*/\n    int sx,sy;\n    cin>>sx>>sy;\n\n    dfs(sx+30,sy+30,0);\n\n    for(int i=0;i<61;++i){\n      for(int j=0;j<61;++j){\n        if(field[i][j]>0) cnt++;\n     }\n    }\n\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2253\n\n\n\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n\n\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n\n\n\nusing namespace std;\n\n\n\n\n#define MAX 121\n#define CONT 60\n\n\n\n\nint T,N;\n\n\n\n\nvoid dfs(int x, int y, int turn, vector< vector<int> > &field)\n{\n\tint dx[6] = {0, 1, 1, 0, -1, -1};\n\tint dy[6] = {1, 1, 0, -1, -1, 0};\n\n\n\n\n\tif(x < 0 || x >= MAX || y < 0 || y >= MAX){ return; } //範囲外\n\n\n\n\n\tif(turn > T){ return; } //ターン数オーバー\n\n\n\n\n\tif(field[x][y] <= turn && field[x][y]){ return; } //到達修正\n\tif(field[x][y] == -1){ return; } //障害物\n\n\n\n\n\tfield[x][y] = turn;\n\t\n\trep(i,6){\n\t\tdfs(x+dx[i], y+dy[i], turn+1, field);\n\t}\n}\n\n\n\n\nint main()\n{\n\twhile(cin >> T >> N )\n\t{\n\t\tif(T == 0 && N == 0){ break; }\n\n\n\n\n\t\tvector< vector<int> > field(MAX,vector<int>(MAX,0));\n\t\n\t\tint X,Y;\n\t\trep(nth,N)\n\t\t{\n\t\t\tcin >> X >> Y;\n\t\t\tfield[X+CONT][Y+CONT] = -1;\n\t\t}\n\n\n\n\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\n\t\tint ans = 0;\n\t\tdfs(sx+CONT,sy+CONT,0,field);\n\t\tfield[sx+CONT][sy+CONT] = 1;\n\t\t\n\t\trep(y,MAX){\n\t\t\trep(x,MAX){\n\t\t\t\tif(field[x][y] > 0){ ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n#define fr first\n#define sc second\nconst int dy[] = { -1, -1, 0, 1, 1, 0 }, dx[] = { -1, 0, 1, 1, 0, -1 };\nbool mas[128][128], used[128][128];\n\nint main(){\n  int n, t;\n  while(cin >> t >> n , t){\n    fill_n( *mas, 128 * 128, false);\n    fill_n( *used, 128 * 128, false);\n    for(int i = 0 ; i < n ; i++ ){\n      int y, x;\n      cin >> x >> y;\n      mas[50 + y][50 + x] = true;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    int ret = 0;\n    queue< Pii > que;\n    que.push(Pii( t, Pi(sy + 50, sx + 50)));\n    while(!que.empty()){\n      Pii p = que.front();\n      que.pop();\n      if(p.fr < 0 || used[p.sc.fr][p.sc.sc]++) continue;\n      ret++;\n      for(int i = 0 ; i < 6 ; i++ ){\n        int ny = p.sc.fr + dy[i], nx = p.sc.sc + dx[i];\n        if(!mas[ny][nx]) que.push(Pii( p.fr - 1, Pi( ny, nx)));\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <math.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\t\tqueue<int> cnt;\n\n\t\tvoid push(int px,int py,int sCnt);\n\t\tint frontX();\n\t\tint frontY();\n\t\tint frontCnt();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py,int sCnt){\n\tx.push(px);\n\ty.push(py);\n\tcnt.push(sCnt);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\nint PointQueue::frontCnt(){\n\treturn cnt.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n\tcnt.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\n\nint main(){\n\tint t,n;\n\n\twhile(cin>>t>>n){\n\t\tif(t==0 && n==0)break;\n\n\t\tPointQueue q;\n\n\t\tint flag[200][200];\n\t\tint data[2][400];\n\n\t\tint dx[6]={0,1,1,0,-1,-1};\n\t\tint dy[6]={1,1,0,-1,-1,0};\n\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tflag[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<400;j++){\n\t\t\t\tdata[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmpX,tmpY;\n\t\t\tcin>>tmpX>>tmpY;\n\t\t\tdata[0][i]=tmpX;\n\t\t\tdata[1][i]=tmpY;\n\t\t}\n\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(abs(sx-data[0][i])+abs(sx-data[1][i])>2*t){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpX,tmpY;\n\t\t\ttmpX = data[0][i];\n\t\t\ttmpY = data[1][i];\n\n\t\t\ttmpX += (100-sx);\n\t\t\ttmpY += (100-sy);\n\t\t\tflag[tmpY][tmpX]=-1;\n\t\t}\n\t\tsx=100;\n\t\tsy=100;\n\n\n\n\t\tq.push(sx,sy,0);\n\t\tflag[sy][sx]=1;\n\t\tint ans=0;\n\n\t\twhile(q.size()!=0){\n\t\t\tint topX=q.frontX();\n\t\t\tint topY=q.frontY();\n\t\t\tint topCnt = q.frontCnt();\n\t\t\tq.pop();\n\t\t\tans++;\n\n\t\t\tif(topCnt==t)continue;\n\n\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nextX=topX+dx[i];\n\t\t\t\tint nextY=topY+dy[i];\n\n\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\tq.push(nextX,nextY,topCnt+1);\n\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint panel[101][101];\nint dd[] = {0, 1, 1, 0, -1, -1, 0};\n\nvoid wfs(int x, int y, int t) {\n  priority_queue<PIP> q;\n  q.push(PIP(t, P(x, y)));\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    if (panel[p.se.se][p.se.fi] == 1) continue;\n    else panel[p.se.se][p.se.fi] = 1;\n\n    if (p.fi == 0) continue;\n    rep(i, 6) {\n      int yy = p.se.se + dd[i], xx = p.se.fi + dd[i + 1];\n      if (panel[yy][xx] == 0) q.push(PIP(p.fi - 1, P(xx, yy)));\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t, n;\n  while(cin >> t >> n, t | n) {\n    rep(i, 101)rep(j, 101) panel[i][j] = 0;\n\n    rep(i, n) {\n      int x, y;\n      cin >> x >> y; x += 50, y += 50;\n      if (0 <= x && x < 101 && 0 <= y && y < 101) panel[y][x] = 2;\n    }\n\n    int x, y;\n    cin >> x >> y;\n    wfs(x + 50, y + 50, t);\n\n    int ans = 0;\n    rep(i, 101)rep(j, 101) if (panel[i][j] == 1) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool map[61][61];\nint memo[61][61];\n\nvoid visit(int t, int x, int y, int i) {\n  memo[x][y] = i;\n  if (t == 0) return;\n  if (x < 60 && !map[x+1][y] && i+1 < memo[x+1][y]) visit(t-1, x+1, y, i+1);\n  if (x < 60 && y < 60 && !map[x+1][y+1] && i+1 < memo[x+1][y+1]) visit(t-1, x+1, y+1, i+1);\n  if (y < 60 && !map[x][y+1] && i+1 < memo[x][y+1]) visit(t-1, x, y+1, i+1);\n  if (x > 0 && !map[x-1][y] && i+1 < memo[x-1][y]) visit(t-1, x-1, y, i+1);\n  if (x > 0 && y > 0 && !map[x-1][y-1] && i+1 < memo[x-1][y-1]) visit(t-1, x-1, y-1, i+1);\n  if (y > 0 && !map[x][y-1] && i+1 < memo[x][y-1]) visit(t-1, x, y-1, i+1);\n}\n\nint main() {\n  int t, n, x, y, res;\n  while (cin >> t >> n, t | n) {\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        map[i][j] = false;\n        memo[i][j] = INF;\n      }\n    }\n    while (n--) {\n      cin >> x >> y;\n      map[x+30][y+30] = true;\n    }\n    cin >> x >> y;\n    visit(t, x+30, y+30, 0);\n    //print1 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      for (int j = 0; j < 61; j++) {\n        if (memo[i][j] == INF) cout << \"X \";\n        else cout << memo[i][j] << \" \";\n      }\n      cout << el;\n    }\n    */\n    //print1 end\n\n    // print2 begin\n    /*\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30-i; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 30 + i; j++) {\n          if (map[30-i+j][60-i]) cout << \"* \";\n          else if (memo[30-i+j][60-i] == INF) cout << \"X \";\n          else cout << memo[30-i+j][60-i] << \" \";\n        }\n        if (map[60][60-i]) cout << \"*\";\n        else if (memo[60][60-i] == INF) cout << \"X\";\n        else cout << memo[60][60-i];\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (map[j][30]) cout << \"* \";\n          else if (memo[j][30] == INF) cout << \"X \";\n          else cout << memo[j][30] << \" \";\n        }\n      } else {\n        for (int j = 0; j < i-30; j++) {\n          cout << \" \";\n        }\n        for (int j = 0; j < 90 - i; j++) {\n          if (map[j][60-i]) cout << \"* \";\n          else if (memo[j][60-i] == INF) cout << \"X \";\n          else cout << memo[j][60-i] << \" \";\n        }\n        if (map[90-i][60-i]) cout << \"*\";\n        else if (memo[90-i][60-i] == INF) cout << \"X\";\n        else cout << memo[90-i][60-i];\n      }\n      cout << el;\n    }\n    */\n    // prin2 end\n    res = 0;\n    for (int i = 0; i < 61; i++) {\n      if (i < 30) {\n        for (int j = 0; j < 30 + i; j++) {\n          if (memo[30-i+j][60-i] < INF) res++;\n        }\n      } else if (i == 30) {\n        for (int j = 0; j < 61; j++) {\n          if (memo[j][30] < INF) res++;\n        }\n      } else {\n        for (int j = 0; j < 90 - i; j++) {\n          if (memo[j][60-i] < INF) res++;\n        }\n      }\n    }\n    cout << res << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int x,y,t;\n};\n\nint T,N;\nint F[111][111];\nint H[111][111];\n\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\n\nint main(){\n  while( cin >> T >> N && (T||N) ){\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin >> x >> y;\n      x+=50; y+=50;\n      F[x][y] = 1;\n    }\n    int x,y;\n    cin >> x >> y;\n    x+=50; y+=50;\n    queue<state> q;\n    q.push(  (state){x,y,0} );\n    H[x][y] = 1;\n    while( !q.empty() ){\n      state p = q.front(); q.pop();\n      if( p.t == T ) continue;\n      for(int i=0;i<6;i++){\n\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\tif( F[nx][ny] ) continue;\n\tif( !H[nx][ny] ) {\n\t  H[nx][ny] = 1;\n\t  q.push( (state){nx,ny,p.t+1} );\n\t}\n      }\n    }\n    int cnt = 0;\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<=100;j++){\n\tif( H[j][i] ) cnt++;\n      }\n    }\n    cout << cnt << endl;\n    memset(H,0,sizeof(H));\n    memset(F,0,sizeof(F));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint data[61][61],result;\nint dx[6] = {0,1,-1,1,-1,0};\nint dy[6] = {1,1,0,0,-1,-1};\nint check(int m,int i,int j){\n\tint ans = 0;\n\tfor(int k = 0;k < 6;k++){\n\t\tif(i+dx[k] < 61 && i+dx[k] >= 0 && j+dy[k] < 61 && j+dy[k] >= 0){\n\t\t\tif(data[i+dx[k]][j+dy[k]] == 0){\n\t\t\t\tdata[i+dx[k]][j+dy[k]] = m + 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint t,n,x,y,a;\n\twhile(1){\n\t\tcin >> t >> n;\n\t\tif(t == 0)break;\n\t\tresult = 0;\n\t\tfor(int i = 0;i < 61;i++){\n\t\t\tfor(int j = 0;j < 61;j++){\n\t\t\t\tdata[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x >> y;\n\t\t\tdata[x+30][y+30] = -1;\n\t\t}\n\t\tcin >> x >> y;\n\t\tdata[x+30][y+30] = 1;\n\t\tresult++;\n\t\tfor(int m = 1;m <= t;m++){\n\t\t\ta = 0;\n\t\t\tfor(int i = 0;i < 61;i++){\n\t\t\t\tfor(int j = 0;j < 61;j++){\n\t\t\t\t\tif(data[i][j] == m){\n\t\t\t\t\t\ta += check(m,i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(a == 0)break;\n\t\t\tresult += a;\n\t\t}\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<int> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint dx[] = {1, -1, 0, 1, 0, -1};\nint dy[] = {0, 0, 1, 1, -1, -1};\n\nsigned main() {\n    int t, n;\n    while(cin >> t >> n, t || n) {\n        set<pii> used, obstacle;\n        rep(i,0,n) {\n            int x, y; cin >> x >> y;\n            obstacle.insert(pii(x, y));\n        }\n        int x, y; cin >> x >> y;\n\n        queue< pair<P, int> > q;\n        q.push(make_pair(P(x, y), 0));\n        used.insert(pii(x, y));\n        while(!q.empty()) {\n            pair<P, int> cur = q.front(); q.pop();\n            if(cur.second == t) continue;\n\n            int sx = cur.first.X, sy = cur.first.Y;\n            rep(i,0,6) {\n                int nx = sx + dx[i];\n                int ny = sy + dy[i];\n                if(obstacle.count(pii(nx, ny))) continue;\n                if(used.count(pii(nx, ny))) continue;\n                used.insert(pii(nx, ny));\n                q.push(make_pair(P(nx, ny), cur.second+1));\n            }\n        }\n        cout << used.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nint dx[]={1,1,0,0,-1,-1};\nint dy[]={0,1,-1,1,-1,0};\n\nbool mp[100][100];\nbool flag[100][100];\n\nint main(){\n\tint t,n;\n\twhile(cin>>t>>n){\n\t\tif(t==0&&n==0)break;\n\t\t\n\t\tCLR(mp);CLR(flag);\n\t\tREP(i,n){\n\t\t\tint tx,ty;\n\t\t\tcin>>tx>>ty;\n\t\t\ttx+=50;ty+=50;\n\t\t\tmp[tx][ty]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tsx+=50;sy+=50;\n\t\tif(t==0){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint sum=1;\n\t\tflag[sx][sy]=true;\n\t\tqueue<pair<int,PII > >q;\n\t\tq.push(MP(t,MP(sx,sy)));\n\t\twhile(!q.empty()){\n\t\t\tpair<int,PII> pi=q.front();q.pop();\n\t\t\tint x=pi.second.first;\n\t\t\tint y=pi.second.second;\n\t\t\tint tt=pi.first;\n\t\t\tif(tt<=0)continue;\n\t\t\tREP(i,6)if(!flag[x+dx[i]][y+dy[i]]&&!mp[x+dx[i]][y+dy[i]]){\n\t\t\t\tflag[x+dx[i]][y+dy[i]]=true;\n\t\t\t\tsum++;\n\t\t\t\tq.push(MP(tt-1,MP(x+dx[i],y+dy[i])));\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\nconst int dx[6] = {0, 1, 0, -1, 1, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[6] = {1, 0, -1, 0, 1, -1}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\nconst int WMAX = 100, HMAX = 100;\n#define MAP(y, x) field[y + 50][x + 50]\nlli t, n;\nint field[HMAX][WMAX];\n\nvoid dfs(int y, int x, int turn) {\n  int nor = y * y + x * x;\n  if (nor > 900 || turn <= 0 || MAP(y, x) >= turn) return;\n  MAP(y, x) = turn;\n  REP(i, 6) {\n    dfs(y + dy[i], x + dx[i], turn - 1);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n\n  while (cin >> t >> n and t) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = 0;\n    }\n    REP(i, n) {\n      int y, x;\n      cin >> x >> y;\n      MAP(y, x) = INF;\n    }\n    int sy, sx;\n    cin >> sx >> sy;\n    dfs(sy, sx, t + 1);\n    int sum = 0;\n    FOR(y, -32, 32) FOR(x, -32, 32) {\n      if (MAP(y, x) > 0 and MAP(y, x) != INF) sum ++;\n    }\n    cout << sum << endl;\n/*    FOR(y, -10, 10) {\n      REP(i, 10 - y) cout << ' ';\n      FOR(x, -10, 10) {\n        if (MAP(y, x) == INF) cout << 'x';\n        else if (MAP(y, x) == 0)   cout << '.';\n        else if (y == sy and x == sx) cout << 'S';\n        else cout << 'o';\n        cout << ' ';\n      }\n      cout << endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tqueue< pair<int,int> > point;\n\tbool field[100][100];\n\tfor(;;){\n\t\tint t, n;\n\t\tcin >>t>>n;\n\t\tif(!t && !n){break;}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint x,y;\n\t\t\tcin >>x>>y;\n\t\t\tfield[x+50][y+50] = 1;\n\t\t}\n\t\tint s_x,s_y;\n\t\tcin >>s_x>>s_y;\n\t\tpoint.push(make_pair(s_x+50,s_y+50));\n\t\tint sum = 0;\n\t\tfor(int i=0; i<=t; i++){\n\t\t\tif(point.empty()){break;}\n\t\t\tint r = point.size();\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tint p_x = point.front().first, p_y = point.front().second;\n\t\t\t\tif(field[p_x][p_y] == 0){\n\t\t\t\t\tsum++;\n\t\t\t\t\tfield[p_x][p_y] = 1;\n\t\t\t\t}\n\t\t\t\tif(i<t){\n\t\t\t\t\tif(p_x>20){if(field[p_x-1][p_y] == 0){point.push(make_pair(p_x-1,p_y));}}\n\t\t\t\t\tif(p_y>20){if(field[p_x][p_y-1] == 0){point.push(make_pair(p_x,p_y-1));}}\n\t\t\t\t\tif(p_x<80){if(field[p_x+1][p_y] == 0){point.push(make_pair(p_x+1,p_y));}}\n\t\t\t\t\tif(p_y<80){if(field[p_x][p_y+1] == 0){point.push(make_pair(p_x,p_y+1));}}\n\t\t\t\t\tif(p_x>20 && p_y>20){if(field[p_x-1][p_y-1] == 0){point.push(make_pair(p_x-1,p_y-1));}}\n\t\t\t\t\tif(p_x<80 && p_y<80){if(field[p_x+1][p_y+1] == 0){point.push(make_pair(p_x+1,p_y+1));}}\n\t\t\t\t}\n\t\t\t\tpoint.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<utility>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nbool check[62][62];\nbool jama_grid[62][62];\n\nvoid solve(int t, int n) {\n    int ans = 0, origin_x, origin_y, x, y;\n    for(int i = 0; i < 62; i++){\n        for(int j = 0; j <62; j++){\n            check[i][j] = false;\n            jama_grid[i][j] = false;\n        }\n    }\n    for(int i = 0; i < n; i++){\n            cin>>x>>y;\n            jama_grid[y+30][x+30] = true;\n    }\n    cin >> origin_x >> origin_y;\n\n    // BFSの処理\n    queue<PP> Q;\n    PP start = mp(mp(origin_y + 30, origin_x + 30), t);\n    Q.push(start);\n    check[origin_y + 30][origin_x + 30] = true;\n\n    while (!Q.empty()) {\n        PP now = Q.front();\n        Q.pop();\n        int dx[6] = {-1, 0, 1, 0, -1, 1}, dy[6] = {0, -1, 0, 1, -1, 1};\n        for (int i = 0; i < 6; i++) {\n            int nx = now.first.second + dy[i], ny = now.first.first + dx[i];\n            if (nx >= 0 && nx <= 60 && ny >= 0 && ny <= 60 && now.second > 0 && !jama_grid[ny][nx] && !check[ny][nx]) {\n                check[ny][nx] = true;\n                Q.push(mp(mp(ny, nx), now.second - 1));\n                // cout << nx << \" \" << ny << \" \" << \"count : \" << now.second << endl;\n            }\n        }\n    }\n\n    for (int i = 0; i < 62; i++) for (int j = 0; j < 62; j++) {\n        if (check[i][j]) ans++;\n    }\n\n    cout << ans << endl;\n    return;\n}\n\nint main(){\n    int t, n;\n    \n    while(1){\n        cin>>t>>n;\n        if(n == 0 && t == 0)break;\n        else solve(t, n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\nusing namespace std;\n\nint main(){\n\tint t,N;\n\tint dx[6]={1,1,0,-1,-1,0};\n\tint dy[6]={0,1,1,0,-1,-1};\n\twhile(cin>>t>>N && (t!=0||N!=0)){\n\t\tbool obs[61][61]={false};\n\t\tint visited[61][61]={0};\n\t\tint tx,ty,ans=0;\n\t\tqueue<pair<int,int>> q;\n\t\tREP(i,0,N){\n\t\t\tcin>>tx>>ty;\n\t\t\tobs[ty+30][tx+30]=true;\n\t\t}\n\t\tint sx,sy;\n\t\tcin>>sx>>sy;\n\t\tq.push({sx+30,sy+30});\n\t\tvisited[sy+30][sx+30]=1;\n\t\twhile(!q.empty()){\n\t\t\tint nowx=q.front().first,nowy=q.front().second;\n\t\t\tq.pop();\n\t\t\tREP(k,0,6){\n\t\t\t\tint nextx=nowx+dx[k],nexty=nowy+dy[k];\n\t\t\t\tif(obs[nexty][nextx]||visited[nexty][nextx]!=0) continue;\n\t\t\t\tvisited[nexty][nextx]=visited[nowy][nowx]+1;\n\t\t\t\tif(visited[nexty][nextx]<=t)\t\tq.push({nextx,nexty});\n\t\t\t}\n\t\t}\n\t\tREP(i,0,61)\tREP(j,0,61)\tif(visited[i][j]!=0)\tans++;\n\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2253.cpp\n// Author: ymiyamoto\n//\n// Created on Mon Nov 20 21:17:57 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic void wfs(array<array<int32_t, 200>, 200> &dists, int32_t x, int32_t y)\n{\n  queue<pair<int32_t, int32_t>> q;\n  dists[x][y] = 0;\n  q.push({x, y});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> point = q.front();\n    int32_t x = point.first;\n    int32_t y = point.second;\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> vec({{0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}});\n    for (auto iter = vec.begin(); iter < vec.end(); iter++) {\n      int32_t posx = x + iter->first;\n      int32_t posy = y + iter->second;\n      if (0 <= posx && posx < (int32_t)dists.size() && 0 <= posy && posy < (int32_t)dists[0].size() && dists[posx][posy] == INT32_MAX) {\n        dists[posx][posy] = dists[x][y] + 1;\n        q.push({posx, posy});\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    array<array<int32_t, 200>, 200> dists;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        dists[i][j] = INT32_MAX;\n      }\n    }\n\n    int32_t t, n;\n    cin >> t >> n;\n    if (t == 0 && n == 0) break;\n\n    for (int32_t i = 0; i < n; i++) {\n      int32_t x, y;\n      cin >> x >> y;\n      dists[x + 100][y + 100] = -1;\n    }\n\n    int32_t x, y;\n    cin >> x >> y;\n    wfs(dists, x + 100, y + 100);\n\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < dists.size(); i++) {\n      for (uint32_t j = 0; j < dists[i].size(); j++) {\n        int32_t dist = dists[i][j];\n        if (0 <= dist && dist <= t) {\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*cout <<\"Debug\"\ncout <<x-30<<' '<<y-30<<endl;*/\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nint mp[61][61];\nint cnt = 0;\nint d_x[] = {1,1,0,-1,0,-1};\nint d_y[] = {1,0,1,0,-1,-1};\nint t;\n/*\nvoid dfs(int x,int y,int lpcnt){\n  mp[x][y] = 1;\n  cout <<\"Debug \";\n  cout <<x-30<<' '<<y-30<<endl;\n  cnt++;\n  lpcnt++;\n  int watasi = lpcnt;\n  int used[6] = {0};\n  for(int dx = 0;dx<6;dx++){\n    int nx = x+d_x[dx],ny = y+d_y[dx];\n    int dft = sqrt((nx-30)*(nx-30)+(ny-30)*(ny-30));\n    if((dft<=30)&&(watasi < t)&&(mp[nx][ny] == 0)){\n        dfs(nx,ny,watasi);\n        used[dx] = 1;\n    }\n    for(int i = 0;i<6;i++){\n      if(used[i]){\n        if((nx == x + d_x[i])&&(ny == y + d_y[i])){\n          dfs(nx,ny,watasi);\n        }\n      }\n    }\n    }\n}\n*/\nint main(){\n  int n,t;\n\n  cin >>t>>n;\n  while(!((t == 0)&&(n == 0))){\n    int fx,fy;\n    cnt = 0;\n    for(int i = 0;i<61;i++){\n      for(int j = 0;j<61;j++){\n        mp[i][j]=-1;\n      }\n    }\n    for(int i = 0;i<n;i++){\n      int x,y;\n      cin >>x>>y;\n      mp[x+30][y+30] = 1;\n    }\n    cin >>fx>>fy;\n\n    cnt = 0;\n\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(fx+30,fy+30));\n    mp[fx+30][fy+30] = 0;\n    while (!qu.empty()) {\n      pair<int ,int> pr = qu.front();\n      qu.pop();\n      int nx = pr.first,ny= pr.second;\n      cnt++;\n      if(mp[nx][ny] == t)continue;\n      for(int i = 0;i<6;i++){\n        int cx = nx+d_x[i],cy = ny+d_y[i];\n        if(mp[cx][cy] != -1)continue;\n        mp[cx][cy] = mp[nx][ny] + 1;\n        qu.push(make_pair(cx,cy));\n      }\n    }\n\n    cout <<cnt<<endl;\n    cin >>t>>n;\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dx[6] = {-1,-1, 0, 1, 1, 0};\nint dy[6] = {-1, 0, 1, 1, 0,-1};\n\nint bfs(int sy, int sx, int st, vvi& board, vvi& used){\n\n  queue<piii> que;\n  que.push(piii(pii(sy,sx),st));\n  \n  int ans = 0;\n  while(que.size()){\n    int y = que.front().first.first;\n    int x = que.front().first.second;\n    int t = que.front().second;\n    que.pop();\n    if(y > 60 || y < 0 || x > 60 || x < 0) continue; // ?£????\n    if(used[y][x]  == 1) continue;  // ??¢?´¢?????? \n    if(board[y][x] == 1) continue;;  // ?????????\n    if(t < 0) continue; // ???????????°??????\n    \n    ans++;\n    used[y][x] = 1; \n    for(int i=0; i<6; i++){\n      int nx = x + dx[i]; int ny = y + dy[i];\n      que.push(piii(pii(ny,nx),t-1));\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    int t,n;\n    cin >> t >> n;\n    if(!t and !n)break;\n    \n    vvi board(61,vi(61,0));\n    vvi used(61,vi(61,0));\n    for(int i=0; i<n; i++){\n      int x,y; cin >> x >> y;\n      board[y+30][x+30] = 1; // ?????????\n    }\n    int sx,sy; cin >> sx >> sy;\n    cout << bfs(sy+30,sx+30,t,board,used) << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\n#include<string>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<utility>\n#include<tuple>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ITR(x,v) for(auto &x:v)\ntypedef pair<int, int> P;\n\nconst int dx[] = { 0,1,1,0,-1,-1 };\nconst int dy[] = { 1,1,0,-1,-1,0 };\nint main() {\n\tint t,n;\n\twhile (cin >> t >> n,t) {\n\t\tmap<P,int> z;\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tz[P(x, y)] = -114514;\n\t\t}\n\t\tqueue<P> que;\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tque.push(P(a, b));\n\t\tz[P(a, b)] = 0;\n\t\twhile (que.size()) {\n\t\t\tint x, y;\n\t\t\ttie(x, y) = que.front(); que.pop();\n\t\t\tif (z[P(x, y)] == t)continue;\n\t\t\tREP(i, 6) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (z.count(P(nx, ny)))continue;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tz[P(nx, ny)] = z[P(x, y)] + 1;\n\t\t\t}\n\n\n\t\t}\n\t\tcout << z.size() - n << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <array>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio> \n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define rangeRep(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\n\nstruct Node\n{\n\tint x, y;\n};\n\nclass Solve {\npublic:\n\tSolve() {};\n\t~Solve() {};\n\n\tvoid solver() {\n\t\tstd::array<std::array<bool, 121>, 121> field;\n\t\tint dx[] = { 1, 0, -1, -1, 0, 1 };\n\t\tint dy[] = { 0, -1, -1, 0, 1, 1 };\n\n\t\twhile (1) {\n\t\t\tint t, n;\n\t\t\tint startX, startY;\n\t\t\tstd::cin >> t >> n;\n\t\t\tif (!t && !n) break;\n\n\t\t\t//Setting obstacles\n\t\t\tfield = { { 0 } };\n\t\t\trep(i, n) {\n\t\t\t\tint x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tfield[y + 60][x + 60] = true;\n\t\t\t}\n\t\t\tstd::cin >> startX >> startY;\n\t\t\tfield[startY + 60][startX + 60] = true;\n\n\t\t\t//Breadth-first search\n\t\t\tstd::queue<Node> q; //Remember coordinates\n\t\t\tint discoverdCount = 1;\n\t\t\tint turn = 0;\n\t\t\tq.push(Node{ startX + 60, startY + 60 });\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto now = q.front(); q.pop();\n\t\t\t\tturn++;\n\t\t\t\trep(i, 6) {\n\t\t\t\t\tauto next = now;\n\t\t\t\t\tnext.x += dx[i]; next.y += dy[i];\n\n\t\t\t\t\t//out of range\n\t\t\t\t\tif (next.x < 0 || next.x > 120 || next.y < 0 || next.y > 120) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//obstacle or discovered\n\t\t\t\t\tif (field[next.y][next.x]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//OK\n\t\t\t\t\tdiscoverdCount++;\n\t\t\t\t\tfield[next.y][next.x] = true;\n\t\t\t\t\t//turn is over\n\t\t\t\t\tif (turn >= t) continue;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::cout << discoverdCount << std::endl;\n\t\t}\n\t}\nprivate:\n\n};\n\nint main() {\n\tSolve solve;\n\tsolve.solver();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 35\n#define NN 2*N\n#define UNKNOWN 10000\nusing namespace std;\n#define S pair<int,int>\n\nint main(){\n  int t,n,x,y;\n  int dx[6] = {1,0,1,-1,0,-1};\n  int dy[6] = {0,1,1,0,-1,-1};\n\n  while( cin>>t>>n && (t|n) ){\n    int d[NN][NN];\n    for( int i=0;i<NN;i++ )\n      for( int j=0;j<NN;j++ )\n\td[i][j] = UNKNOWN;\n    for( int i=0;i<n;i++ ){\n      cin >> x >> y; x+=N; y+=N;\n      d[y][x] = -1; // 障害物\n    }\n    cin >> x >> y; // 開始位置\n    x+=N; y+=N;\n    queue<S> q; q.push( S(x,y) );\n    d[y][x]=0;\n    int ans=1; // 初期位置\n    while( !q.empty() ){\n      S s = q.front(); q.pop();\n      int nt = d[s.second][s.first] + 1;\n      for( int i=0;i<6;i++ ){\n\tint nx=s.first+dx[i], ny=s.second+dy[i];\n\tif( d[ny][nx]==UNKNOWN ){\n\t  d[ny][nx]=nt; ans++;\n\t  if( nt<t ) q.push( S(nx,ny) );\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<limits.h>\n\nusing namespace std;\ntypedef struct\n{\n\tint cx;\n\tint cy;\n\tint turn;\n} data;\nint main()\n{\n\tint t, n;\n\tint dx[] = { 0, 1, 1, 0, -1, -1 };\n\tint dy[] = { 1, 1, 0, -1, -1, 0 };\n\twhile (cin >> t >> n && t != 0 || n != 0)\n\t{\n\t\tint map[100][100];\n\t\tbool object[100][100];\n\t\tmemset(object, false, sizeof(object));\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tmap[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tobject[y + 50][x + 50] = true;\n\t\t}\n\n\t\tint sx, sy;\n\t\tcin >> sx >> sy;\n\n\t\tqueue<data> q;\n\t\tdata f;\n\t\tf.cx = sx + 50;\n\t\tf.cy = sy + 50;\n\t\tf.turn = 0;\n\t\tmap[f.cy][f.cx] = 0;\n\t\tq.push(f);\n\t\twhile (q.size() > 0)\n\t\t{\n\t\t\tdata d = q.front(); q.pop();\n\t\t\tif (d.turn + 1 > t)continue;\n\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t{\n\t\t\t\tint nx = d.cx + dx[i];\n\t\t\t\tint ny = d.cy + dy[i];\n\t\t\t\t\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 100 || ny >= 100)continue;\n\t\t\t\tif (object[ny][nx])continue;\n\t\t\t\tif (map[ny][nx] > d.turn)\n\t\t\t\t{\n\t\t\t\t\tmap[ny][nx] = d.turn + 1;\n\t\t\t\t\tdata next;\n\t\t\t\t\tnext.cx = nx;\n\t\t\t\t\tnext.cy = ny;\n\t\t\t\t\tnext.turn = d.turn + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 100; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 100; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] != INT_MAX)ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint field[61][61],\n    dx[6] = {0, 1, 1, 0, -1, -1,},\n    dy[6] = {1, 1, 0, -1, -1, 0,};\n\nvoid move(int cx, int cy, int t, int& count) {\n    if (field[cy][cx] == 0) {\n        count++;\n    }\n    field[cy][cx] = 1;\n    if (t == 0) {\n        return;\n    }\n    for (int i = 0; i < 6; i++) {\n        if (field[cy + dy[i]][cx + dx[i]] != -1) {\n            move(cx + dx[i], cy + dy[i], t - 1, count);\n        }\n    }\n}\n\nint main() {\n    while (true) {\n        int t, n;\n        cin >> t >> n;\n        if ((t | n) == 0) {\n            break;\n        }\n        for (int i = 0; i < 61; i++) {\n            for (int j = 0; j < 61; j++) {\n                field[i][j] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            field[y + 30][x + 30] = -1;\n        }\n        int cx, cy, count = 0;\n        cin >> cx >> cy;\n        move(cx + 30, cy + 30, t, count);\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst int d = 30;\n\nint dx[6] = {-1, 0, 1, 1, 0, -1};\nint dy[6] = {0, 1, 1, 0, -1, -1};\n\nint main(){\n\tint t, n;\n\tint field[90][90];\n\twhile(cin >> t >> n, t+n){\n\t\tt += 2;\n\t\tvector<pair<int, int> > v(n);\n\t\trep(i, 90)rep(j, 90) field[i][j] = 0;\n\t\trep(i, n){int x, y; cin >> x >> y; field[x+d][y+d] = -1;}\n\t\tint sx, sy; cin >> sx >> sy; sx += d; sy += d;\n\t\tfield[sx][sy] = 1;\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(sx, sy));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\tif(field[x][y] == t) continue;\n\t\t\trep(i, 6){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(abs(nx-d) <= 30 && abs(ny-d) <= 30 && field[nx][ny] != -1 && (field[x][y]+1 < field[nx][ny] || field[nx][ny] == 0)){\n\t\t\t\t\tfield[nx][ny] = field[x][y]+1;\n\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\trep(i, 90)rep(j, 90) if(0 < field[i][j]) count++;\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<stack>\n \nusing namespace std;\n  \n#define NMAX 50\n#define INF 1000000\n#define WALL -1\ntypedef map<int,int>::value_type VT;\n \nstruct data{\n    int x,y,turn;\n};\n \nint main(void){\n     \n    int t,n;\n    int x,y;\n    map<int,int> road;\n    stack<data> no;\n    data tm,da;\n    int dx[]={1,1,0,-1,-1,0};\n    int dy[]={0,1,1,0,-1,-1};\n    int cnt;\n \n    for(int i=-31;i<=31;i++){\n        for(int j=-31;j<=31;j++){\n        road.insert(VT(i+j*100,INF));\n        }\n    }\n    while(1){\n        cin>>t>>n;\n        if(t==0&&n==0) break;\n        for(int i=-30;i<=30;i++){\n            for(int j=-30;j<=30;j++){\n                road[i+j*100]=INF;\n            }\n        }\n        for(int i=-31;i<=31;i++){\n            road[-31+i*100]=WALL;\n            road[31+i*100]=WALL;\n            road[i+31*100]=WALL;\n            road[i-31*100]=WALL;\n        }\n \n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            road[y+x*100]=WALL;\n        }\n        cin>>x>>y;\n        tm.x=x,tm.y=y,tm.turn=0;\n        no.push(tm);\n        road[y+x*100]=0;\n        cnt=1;\n        while(!no.empty()){\n            tm=no.top();\n            no.pop();\n            if(tm.turn==t) continue;\n            for(int i=0;i<6;i++){\n                if(road[(tm.y+dy[i])+(tm.x+dx[i])*100]>road[(tm.y)+(tm.x)*100]+1){\n\t\t\t\t\tif(road[(tm.y+dy[i])+(tm.x+dx[i])*100]==INF) cnt++;\n\t\t\t\t\troad[(tm.y+dy[i])+(tm.x+dx[i])*100]=road[(tm.y)+(tm.x)*100]+1;\n                    da.x=tm.x+dx[i];\n                    da.y=tm.y+dy[i];\n                    da.turn=tm.turn+1;\n                    no.push(da);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nint dx[]={0,1,1,0,-1,-1};\nint dy[]={1,1,0,-1,-1,0};\nint main()\n{\n\tint t,n;\n\twhile(cin>>t>>n,t!=0){\n\t\tvector<pii> jama(n);\n\t\tint sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tjama.push_back(pii(x,y));\n\t\t}\n\t\tcin>>sx>>sy;\n\t\tset<pii> visited;\n\t\tqueue<piii> q;\n\t\tq.push(piii(pii(sx,sy),0));\n\t\twhile(q.front().second<=n){\n\t\t\tpiii fr=q.front();\n\t\t\tq.pop();\n\t\t\tif(visited.find(fr.first)!=visited.end())continue;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tpii cur(fr.first.first+dx[i],fr.first.second+dy[i]);\n\t\t\t\tif(visited.find(cur)==visited.end()&&find(jama.begin(),jama.end(),cur)==jama.end())q.push(piii(cur,fr.second+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\nconst int dy[]={-1,-1,0,0,1,1};\nconst int dx[]={-1,0,-1,1,0,1};\nint main(){\n\n\tint n,t;\n\tconst int base=150;\n\tconst int MAX_P=301;\n\twhile(cin>>t>>n&&!(t==0&&n==0)){\n\t\tbool passed[MAX_P][MAX_P];\n\t\tbool isArrival[2][MAX_P][MAX_P];\n\t\tbool obj[MAX_P][MAX_P];\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tmemset(obj,0,sizeof(obj));\n\t\tmemset(passed,0,sizeof(passed));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tobj[y+base][x+base]=true;\n\t\t}\n\t\tint sy,sx;\n\t\tcin>>sx>>sy;\n\t\tisArrival[0][sy+base][sx+base]=true;\n\t\tpassed[sy+base][sx+base]=true;\n\t\tfor(int l = 0; l < t; l++){\n\t\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\t\tif(isArrival[l%2][i][j]){\n\t\t\t\t\t\tfor(int k = 0; k < 6; k++){\n\t\t\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tif(!obj[ny][nx]){\n\t\t\t\t\t\t\t\tisArrival[(l+1)%2][ny][nx]=true;\n\t\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tisArrival[l%2][i][j]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < MAX_P; i++){\n\t\t\tfor(int j = 0; j < MAX_P; j++){\n\t\t\t\tif(passed[i][j])\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> ppiii;\ntypedef vector<int> vi;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RREP(i,x) for(int i=(x)-1;i>=0;i--)\n#define RFOR(i,c) for(auto i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\n\nint t, n;\nint x, y;\n\nint d[6][2] = {{0, 1},{1, 0},{0, -1},{-1, 0},{1,1},{-1,-1}};\n\nmain(){\n\twhile(cin >> t >> n, t){\n\t\tset<pii> obst;\n\t\tREP(i, n){\n\t\t\tcin >> x >> y;\n\t\t\tobst.insert(pii(x, y));\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<ppiii> q;\n\t\tcin >> x >> y;\n\t\tq.push(ppiii(0, pii(x, y)));\n\t\tobst.insert(pii(x, y));\n\t\twhile(!q.empty()){\n\t\t\tint c = q.front().first;\n\t\t\tpii s = q.front().second;q.pop();\n\t\t\tans ++;\n\t\t\tif(c < t) REP(i, 6){\n\t\t\t\tpii t(s.first + d[i][0], s.second + d[i][1]);\n\t\t\t\tif(!obst.count(t)){\n\t\t\t\t\tq.push(ppiii(c+1, t));\n\t\t\t\t\tobst.insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0, 1, -1};\nint dy[] = {0, 0, 1, -1, 1, -1};\n\nint T, N;\nint maze[61][61];\n\nstruct State{\n\tint x, y, t;\n\tState(int _x, int _y, int _t){\n\t\tx = _x;\n\t\ty = _y;\n\t\tt = _t;\n\t}\n};\n\nbool check(int x, int y){\n\treturn x >= 0 && x < 61 && y >= 0 && y < 61 && maze[x][y] != 2;\n}\n\nint main() {\n\twhile(cin >> T >> N && (T || N)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tint a, b;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> a >> b;\n\t\t\tmaze[a + 30][b + 30] = 2;\n\t\t}\n\t\tint sx, sy, count = 0;\n\t\tcin >> sx >> sy;\n\t\tqueue<State> q;\n\t\tq.push(State(sx + 30, sy + 30, 0));\n\t\twhile(!q.empty()){\n\t\t\tState st = q.front(); q.pop();\n\t\t\tif(st.t > T || maze[st.x][st.y] != 0)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tmaze[st.x][st.y] = -1;\n\t\t\tcount++;\n\t\t\tfor(int i = 0; i < 6; ++i){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tif(check(nx, ny))\n\t\t\t\t\tq.push(State(nx, ny, st.t + 1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << count << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = length (bfs' 0 is [s])\n where\n  is = [(x,y) | x<-[(sx-t)..(sx+t)], y<-[(sy-t)..(sy+t)]] \\\\ (s:os)\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | null is' = rs'\n   | null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (is1 ++ rs')\n   where\n    (is1,is2) = partition neighbor is'\n    neighbor (xi,yi) = let ns = [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)] in (not.null) (intersect ns rs')"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\nimport Data.Sequence ((<|), (|>), (><), ViewL(..), ViewR(..), Seq)\nimport qualified Data.Sequence as Sq\n\nmain :: IO ()\nmain = do\n  [t, n] <- f\n  unless (t == 0 && n == 0) $ do\n    solve t <$> replicateM n (g <$> f) <*> (g <$> f) >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n    g [x, y] = (x, y)\n\nsolve :: Int -> [(Int, Int)] -> (Int, Int) -> Int\nsolve t sps bp = let iv = V.replicate (63 ^ 2) (-1) // ((toIdx bp, 0) : [(i, -2)| i <- map toIdx sps]) :: Vector Int\n                     iq = Sq.singleton bp\n                 in loop iq iv 0\n  where\n    loop q v ct = case Sq.viewl q of\n      EmptyL -> ct\n      (x, y) :< rq -> let bst = v ! (toIdx (x, y))\n                          nps = [(nx, ny) | bst < t,\n                                            (dx, dy) <- [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)],\n                                            let (nx, ny) = (x + dx, y + dy),\n                                            v ! (toIdx (nx, ny)) == (-1)]\n                          nq = foldl' (|>) rq nps\n                          nv = v // [(i, bst+1) | i <- map toIdx nps]\n                      in loop nq nv (ct + 1)\n\ntoIdx (x, y) = let (x', y') = (x + 31, y + 31)\n               in x' + 63 * y'\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is' = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union is1 rs')\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi)\n     | abs (xi-sx) > t+1 || abs (yi-sy) > t+1 = False\n     | otherwise = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is' = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union is1 rs')\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi)\n     | xi-sx > t || yi-sy > t = False\n     | otherwise = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs :: (Int, [(Int,Int)], (Int,Int)) -> Int\nbfs (t,os,i) = S.size $ advance 0 (S.singleton i) (S.singleton i)\n where\n  os' = S.fromList os\n  advance t' b r\n   | t' == t = r\n   | S.null b' = r\n   | otherwise = advance (t'+1) (S.difference b' r) (S.union r b')\n   where\n    b' = S.difference (S.foldl' (\\acc x -> S.union acc (S.fromList (neighbors x))) b b) os'\n    neighbors (x,y) = [(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x-1,y-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = length (bfs' 0 is [s])\n where\n  is = [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | null is' = rs'\n   | null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (is1 ++ rs')\n   where\n    (is1,is2) = partition neighbor is'\n    neighbor (xi,yi)\n     | (xi-sx) > (t+1) || (yi-sy) > (t+1) = False\n     | otherwise = let ns = [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)] in (not.null) (intersect ns rs')"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union rs' is1)\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi)\n     | abs (xi-sx) > t+1 || abs (yi-sy) > t+1 = False\n     | otherwise = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs :: (Int, [(Int,Int)], (Int,Int)) -> Int\nbfs (t,os,i) = S.size $ advance 0 (S.singleton i) (S.singleton i)\n where\n  advance t' b r\n   | t' == t = r\n   | S.null b = r\n   | otherwise = advance (t'+1) (S.difference b' r) (S.union r b')\n   where\n    b' = S.unions $ map (S.fromList . neighbors) (S.toList b)\n    neighbors (x,y) = filter inborder $ [(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x-1,y-1)] \\\\ os\n    inborder (x,y) = abs x <= 30 && abs y <= 30 && abs (x-y) <= 30"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], abs (x-y) <= 30, notElem (x,y) (s:os)]\n   where\n    (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n    (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is' = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union rs' is1)\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi)\n     | abs (xi-sx) > t+1 || abs (yi-sy) > t+1 = False\n     | otherwise = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = length (bfs' 0 is [s])\n where\n  is = [(x,y) | x<-[(sx-t)..(sx+t)], y<-[(sy-t)..(sy+t)]] \\\\ (s:os)\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | null is' = rs'\n   | otherwise = bfs' (t'+1) is2 (is1 ++ rs')\n   where\n    (is1,is2) = partition neighbor is'\n    neighbor (xi,yi) = (not.null) (intersect [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)] rs')"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\napply :: Int -> (a -> a) -> a -> a\napply n f x = foldr ($) x (replicate n f)\n\nmain :: IO ()\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs :: (Int, [(Int,Int)], (Int,Int)) -> Int\nbfs (t,os,i) = S.size $ apply t advance (S.singleton i)\n where\n  advance = S.unions . map (S.fromList . neighbors) . S.toList \n  neighbors (x,y) = filter inborder $ [(x,y),(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x-1,y-1)] \\\\ os\n  inborder (x,y) = x<=30 && y<=30 && abs (x-y) <= 30"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\napply :: Int -> (a -> a) -> a -> a\napply n f x = foldr ($) x (replicate n f)\n\nmain :: IO ()\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs :: (Int, [(Int,Int)], (Int,Int)) -> Int\nbfs (t,os,i) = S.size $ advance 0 (S.singleton i) (S.singleton i)\n where\n  advance t' b r\n   | t' == t = r\n   | otherwise = advance (t'+1) (S.difference b' r) (S.union r b')\n   where\n    b' = S.unions $ map (S.fromList . neighbors) (S.toList b)\n    neighbors (x,y) = filter inborder $ [(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x-1,y-1)] \\\\ os\n    inborder (x,y) = x<=30 && y<=30 && abs (x-y) <= 30"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\nimport Data.Sequence ((<|), (|>), (><), ViewL(..), ViewR(..), Seq)\nimport qualified Data.Sequence as Sq\n\nmain :: IO ()\nmain = do\n  [t, n] <- f\n  unless (t == 0 && n == 0) $ do\n    solve t <$> replicateM n (g <$> f) <*> (g <$> f) >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n    g [x, y] = (x, y)\n\nsolve :: Int -> [(Int, Int)] -> (Int, Int) -> Int\nsolve t sps bp = let iv = V.replicate (123 ^ 2) (-1) // ((toIdx bp, 0) : [(i, -2)| i <- map toIdx sps]) :: Vector Int\n                     iq = Sq.singleton bp\n                 in loop iq iv 0\n  where\n    loop q v ct = case Sq.viewl q of\n      EmptyL -> ct\n      (x, y) :< rq -> let bst = v ! (toIdx (x, y))\n                          nps = [(nx, ny) | bst < t,\n                                            (dx, dy) <- [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)],\n                                            let (nx, ny) = (x + dx, y + dy),\n                                            v ! (toIdx (nx, ny)) == (-1)]\n                          nq = foldl' (|>) rq nps\n                          nv = v // [(i, bst+1) | i <- map toIdx nps]\n                      in loop nq nv (ct + 1)\n\ntoIdx (x, y) = let (x', y') = (x + 61, y + 61)\n               in x' + 123 * y'\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs :: (Int, [(Int,Int)], (Int,Int)) -> Int\nbfs (t,os,i) = S.size $ advance 0 (S.singleton i) (S.singleton i)\n where\n  advance t' b r\n   | t' == t = r\n   | otherwise = advance (t'+1) (S.difference b' r) (S.union r b')\n   where\n    b' = S.unions $ map (S.fromList . neighbors) (S.toList b)\n    neighbors (x,y) = filter inborder $ [(x+1,y),(x-1,y),(x,y+1),(x,y-1),(x+1,y+1),(x-1,y-1)] \\\\ os\n    inborder (x,y) = abs x <= 30 && abs y <= 30 && abs (x-y) <= 30"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = length (bfs' 0 is [s])\n where\n  is = [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | null is' = rs'\n   | null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (is1 ++ rs')\n   where\n    (is1,is2) = partition neighbor is'\n    neighbor (xi,yi)\n     | (xi-sx) > (t+1) || (yi-sy) > (t+1) = False\n     | otherwise = any (flip elem rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], notElem (x,y) (s:os)]\n  (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is' = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union is1 rs')\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi) = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Set as S\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = S.size (bfs' 0 is (S.singleton s))\n where\n  is = S.fromList [(x,y) | x<-[minx..maxx], y<-[miny..maxy], abs (x-y) <= 30, notElem (x,y) (s:os)]\n   where\n    (minx,maxx) = (max (-30) (sx-t), min 30 (sx+t))\n    (miny,maxy) = (max (-30) (sy-t), min 30 (sy+t))\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | S.null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (S.union rs' is1)\n   where\n    (is1,is2) = S.partition neighbor is'\n    neighbor (xi,yi)\n     | abs (xi-sx) > t+1 || abs (yi-sy) > t+1 = False\n     | otherwise = any (flip S.member rs') [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)]"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\nimport Data.Sequence ((<|), (|>), (><), ViewL(..), ViewR(..), Seq)\nimport qualified Data.Sequence as Sq\n\nmain :: IO ()\nmain = do\n  [t, n] <- f\n  unless (t == 0 && n == 0) $ do\n    solve t <$> replicateM n (g <$> f) <*> (g <$> f) >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n    g [x, y] = (x, y)\n\nsolve :: Int -> [(Int, Int)] -> (Int, Int) -> Int\nsolve t sps bp = let iv = V.replicate (61 ^ 2) (-1) // ((toIdx bp, 0) : [(i, -2)| i <- map toIdx sps]) :: Vector Int\n                     iq = Sq.singleton bp\n                 in loop iq iv 0\n  where\n    loop q v ct = case Sq.viewl q of\n      EmptyL -> ct\n      (x, y) :< rq -> let bst = v ! (toIdx (x, y))\n                          nps = [(nx, ny) | bst < t,\n                                            (dx, dy) <- [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)],\n                                            let (nx, ny) = (x + dx, y + dy),\n                                            v ! (toIdx (nx, ny)) == (-1)]\n                          nq = foldl' (|>) rq nps\n                          nv = v // [(i, bst+1) | i <- map toIdx nps]\n                      in loop nq nv (ct + 1)\n\ntoIdx (x, y) = let (x', y') = (x + 31, y + 31)\n               in x' + 63 * y'\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . bfs) . parse . map (map read . words) . lines\n where\n  parse [[0,0]] = []\n  parse ([t,o]:xs) = (t, map (\\[a,b]->(a,b)) os, (x,y)) : parse xs'\n   where (os,([x,y]:xs')) = splitAt o xs\n\nbfs (t,os,s@(sx,sy)) = length (bfs' 0 is [s])\n where\n  is = [(x,y) | x<-[(sx-t)..(sx+t)], y<-[(sy-t)..(sy+t)]] \\\\ (s:os)\n  bfs' t' is' rs'\n   | t' == t = rs'\n   | null is' = rs'\n   | null is1 = rs'\n   | otherwise = bfs' (t'+1) is2 (is1 ++ rs')\n   where\n    (is1,is2) = partition neighbor is'\n    neighbor (xi,yi)\n     | (xi-sx) > (t+1) || (yi-sy) > (t+1) = False\n     | otherwise = let ns = [(xi+1,yi),(xi-1,yi),(xi,yi+1),(xi,yi-1),(xi+1,yi+1),(xi-1,yi-1)] in (not.null) (intersect ns rs')"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\nimport Data.Sequence ((<|), (|>), (><), ViewL(..), ViewR(..), Seq)\nimport qualified Data.Sequence as Sq\n\nmain :: IO ()\nmain = do\n  [t, n] <- f\n  unless (t == 0 && n == 0) $ do\n    solve t <$> replicateM n (g <$> f) <*> (g <$> f) >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n    g [x, y] = (x, y)\n\nsolve :: Int -> [(Int, Int)] -> (Int, Int) -> Int\nsolve t sps bp = let iv = V.replicate (61 ^ 2) (-1) // ((toIdx bp, 0) : [(i, -2)| i <- map toIdx sps]) :: Vector Int\n                     iq = Sq.singleton bp\n                 in loop iq iv 0\n  where\n    loop q v ct = case Sq.viewl q of\n      EmptyL -> ct\n      (x, y) :< rq -> let bst = v ! (toIdx (x, y))\n                          nps = [(nx, ny) | (dx, dy) <- [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)],\n                                            let (nx, ny) = (x + dx, y + dy),\n                                            bst < t,\n                                            v ! (toIdx (nx, ny)) == (-1)]\n                          nq = foldl' (|>) rq nps\n                          nv = v // [(i, bst+1) | i <- map toIdx nps]\n                      in loop nq nv (ct + 1)\n\ntoIdx (x, y) = let (x', y') = (x + 30, y + 30)\n               in x' + 61 * y'\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[1000],qy[1000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[62][130]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][30-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=30-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||60<ny||nx<0||120<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[70][70]={};//(0,0)=35,35\nint n,t;\nvoid dfs(int x,int y,int i){\n  a[x][y]=i;\n  i++;\n  if(t>=i-1){\n    if(a[x-1][y-1]==0 || a[x-1][y-1]>i) dfs(x-1,y-1,i);\n    if(a[x-1][y]==0 || a[x-1][y]>i) dfs(x-1,y,i);\n    if(a[x][y-1]==0 || a[x][y-1]>i) dfs(x,y-1,i);\n    if(a[x+1][y+1]==0 || a[x+1][y+1]>i) dfs(x+1,y+1,i);\n    if(a[x+1][y]==0 || a[x+1][y]>i) dfs(x+1,y,i);\n    if(a[x][y+1]==0 || a[x][y+1]>i) dfs(x,y+1,i);\n  }\n  else return;\n}\n\n\nint main(){\n  int i,j,c,co;\n  int x,y,cx,cy;\n  while(1){\n    //syoki\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\ta[i][j]=0;\n      }\n    }\n    co=0;\n    scanf(\"%d%d\",&t,&n);\n    if(t==0&&n==0)break;\n    //printf(\"point 1\\n\");///\n    for(i=0;i<n;i++){\n      scanf(\"%d%d\",&x,&y);\n      // printf(\"\\n\");\n      a[x+35][y+35]=-1;\n    }\n    //printf(\"point 2\\n\");///\n    scanf(\"%d%d\",&cx,&cy);\n    cx+=35;\n    cy+=35;\n    dfs(cx,cy,1);\n    //printf(\"point 3\\n\");///\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\tif(a[i][j]>0)co++;\n      }\n    }\n    printf(\"%d\\n\",co);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define ORIGIN 50\n\nint vx[6] ={1, 1, 0, 0, -1, -1};\nint vy[6] ={1, 0, 1, -1, 0, -1};\nint cell[ORIGIN*2][ORIGIN*2];\n\nint func(int x, int y, int turn){\n\tint ans=0;\n\n\tif(cell[y][x] >= turn ) return 0;\n\tif(cell[y][x] == 0)ans++;\n\tcell[y][x]=turn;\n\n\tif(turn > 0){\n\t\tfor(int i=0; i<6; i++){\n\t\t\tans += func(x+vx[i], y+vy[i], turn-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(void){\n\tint turn, n, x, y, tmp_x, tmp_y, ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\", &turn, &n);\n\t\tif(turn == 0 && n == 0) break;\n\n\t\tmemset(cell, 0, sizeof(cell));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d %d\", &tmp_x, &tmp_y);\n\t\t\tcell[tmp_y+ORIGIN][tmp_x+ORIGIN] =500;\n\t\t}\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tans = func(x+ORIGIN, y+ORIGIN, turn+1);\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={1,1,0,0,-1,-1};\nint X[]={0,1,-1,1,-1,0};\nint main(){\n  int n,m,ny,nx,i,j,t,r,y[10000],x[10000],a,b;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[100][100]={};\n    for(i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[b+50][a+50]=1e9;\n    }\n    scanf(\"%d %d\",&a,&b);\n    d[y[0]=b+50][x[t=0]=a+50]=n+1;\n    for(r=1;r-t;t++){\n      if(d[y[t]][x[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(ny<20||nx<20||ny>80||nx>80)continue;\n\tif(d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 1000000\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\ntypedef struct{\n    int x;\n    int y;\n    int turn;\n}Point;\nint mv[6][2]={{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\nint t,n;\nPoint queue[N];\nint head,num,cnt;\nvoid enqueue(int x,int y,int turn){\n    if(num<N){\n        queue[(head+num)%N].x=x;\n        queue[(head+num)%N].y=y;\n        queue[(head+num)%N].turn=turn;\n        num++;\n    }else{\n        printf(\"エラー\\n\");\n        exit(1);\n    }\n}\nPoint dequeue(){\n    Point d={-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&t,&n);\n        if(n+t==0) break;\n        int x,y;\n        int block[1000][1000]={0};\n        rep(i,n){\n            scanf(\"%d%d\",&x,&y);\n            block[500+x][500+y]=1;\n        }\n        scanf(\"%d%d\",&x,&y);\n        block[500+x][500+y]=1;\n        cnt=1; head=num=0;\n        enqueue(500+x,500+y,0); block[500+x][500+y]=1;\n        while(1){\n            Point tmp=dequeue();\n            if(tmp.x==-1) break;\n            if(tmp.turn==t) continue;\n            for(int i=0;i<6;i++){\n                int nx=tmp.x+mv[i][0],ny=tmp.y+mv[i][1];\n                int nt=tmp.turn+1;\n                //if(nx<0||ny<0) continue;\n                if(block[nx][ny]) continue;\n                cnt++; block[nx][ny]=1;\n                enqueue(nx,ny,nt);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2253: Brave Force Story\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define BASE 50\n#define E 0\n#define S 1\n#define W 2\n#define N 3\ntypedef struct { int r, c, k; } Q;\nQ q[25000]; int top, end;\n\nchar b[100][100];\nchar mk[100][100];\nint mv[6][2] = {{-1,-1},{0,-1},{1,0},{1,1},{0,1},{-1,0}};\n\nint main()  \n{  \n\tint t, n, i, r, c, r2, c2, k, ans;\n\n\twhile (scanf(\"%d%d\", &t, &n) && t > 0) {\n\t\tmemset(mk, 0, sizeof(mk)), memset(b, 0, sizeof(b));\n\t\twhile (n--) {\n\t\t\tscanf(\"%d%d\", &c, &r);\n\t\t\tb[r+BASE][c+BASE] = 1;\n\t\t}\n\t\tscanf(\"%d%d\", &c, &r);\n\t\tr += BASE, c += BASE;\n\t\tmk[r][c] = 1;\n\t\tq[0].r = r, q[0].c = c, q[0].k = 0; top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top].c, k = q[top++].k;\n\t\t\tif (k >= t) continue;\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tr2 = r + mv[i][0];\n\t\t\t\tc2 = c + mv[i][1];\n\t\t\t\tif (b[r2][c2] || mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1;\n\t\t\t\tq[end].r = r2, q[end].c = c2, q[end++].k = k+1;\n\t\t\t}\n\t\t}\n\t\tfor (ans = 0, r = 0; r < 100; r++) for (c = 0; c < 100; c++)\n\t\t\tif (mk[r][c]) ans++;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nll d6[]={0,1,1,0,-1,-1,0};\nll que[9999],quecnt;\nll p[199][199];\n\nint main(){\n\tll n,t;\n\twhile(scanf(\"%lld%lld\",&t,&n),t){\n\t\trep(i,0,199)rep(j,0,199)p[i][j]=99;\n\t\tll x,y;\n\t\trep(i,0,n){\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tp[x+70][y+70]=-1;\n\t\t}\n\n\t\tll ans=1;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tp[x+70][y+70]=0;\n\t\tquecnt=0;\n\t\tque[quecnt++]=(x+70)*256+(y+70);\n\t\tfor(int idx=0;idx<quecnt;idx++){\n\t\t\tint x=que[idx]/256;\n\t\t\tint y=que[idx]%256;\n\t\t\tif(p[x][y]==t)continue;\n\t\t\t\n\t\t\trep(k,0,6){\n\t\t\t\tint xx=x+d6[k];\n\t\t\t\tint yy=y+d6[k+1];\n\t\t\t\tif(p[xx][yy]==99){\n\t\t\t\t\tp[xx][yy]=p[x][y]+1;\n\t\t\t\t\tque[quecnt++]=xx*256+yy;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define STD 200\n#define STATE_MAX 3000\t\t/* max state = 6*0 + 6*1 + 6*2 + .... 6*30  < 3000*/\n#define DIR 6\nint objects[STD][STD], queue[STATE_MAX], visited[STD][STD], dir_x[DIR] = {1, 0, -1, -1, 0, 1}, dir_y[DIR] = {0, -1, -1, 0, 1, 1};\nint top, bottom;\n\nvoid put(int val)\n{\n  queue[bottom++] = val;\n}\n\nint get(void)\n{\n  return queue[top++];\n}\n\nint empty(void)\n{\n  return top == bottom;\n}\n\nint main(void)\n{\n  int turn, obj_n, x, y, nx, ny, getted_val, used_turn, i;\n  while(1)\n    {\n      scanf(\"%d %d\", &turn, &obj_n);\n      if(turn == 0 && obj_n == 0)\n\t{\n\t  break;\n\t}\n      top = bottom = used_turn = 0;\n      memset(objects, 0, sizeof(objects));\n      memset(visited, 0, sizeof(visited));\n      while(obj_n--)\n\t{\n\t  scanf(\"%d %d\", &x, &y);\n\t  objects[100 + x][100 + y] = 1;\n\t}\n      scanf(\"%d %d\", &x, &y);\n      x += 100;\n      y += 100;\n      visited[x][y] = 1;\n      put(x * 1000 + y);\n      while(!empty())\n\t{\n\t  getted_val = get();\n\t  x = getted_val / 1000;\n\t  y = getted_val % 1000;\n\t  used_turn = visited[x][y];\n\t  for(i = 0; i < DIR; i++)\n\t    {\n\t      nx = x + dir_x[i];\n\t      ny = y + dir_y[i];\n\t      if(!objects[nx][ny] && !visited[nx][ny] && used_turn <= turn)\n\t\t{\n\t\t  visited[nx][ny] = used_turn + 1;\n\t\t  put(nx * 1000 + ny);\n\t\t}\n\t    }\n\t}\n      printf(\"%d\\n\", top);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 80\n#define M N/2\n\nint count;\n\nvoid mapPaint( char map[ N ][ N ], int x, int y, int t ) {\n  if( !t || !map[ y + M ][ x + M ] )\n    return ;\n\n  map[ y + M ][ x + M ] = t + 1;\n\n  mapPaint( map,  x + 1,  y,      t - 1 );\n  mapPaint( map,  x - 1,  y,      t - 1 );\n  mapPaint( map,  x + 1,  y + 1,  t - 1 );\n  mapPaint( map,  x - 1,  y - 1,  t - 1 );\n  mapPaint( map,  x,      y + 1,  t - 1 );\n  mapPaint( map,  x,      y - 1,  t - 1 );\n}\n\nint main( void ) {\n\n  while( 1 ) {\n    int i, j;\n    int t, n;\n    int x,  y;\n    char map[ N ][ N ];\n\n    scanf( \"%d%d\", &t, &n );\n    if( !t && !n )\n      break;\n\n    /* initialize */\n    count = 0;\n    for( i = 0; i < N; i++ )\n      for( j = 0; j < N; j++ )\n        map[ i ][ j ] = 1;\n\n    /* calculator */\n    for( i = 0; i < n; i++ ) {\n      scanf( \"%d%d\", &x, &y );\n      map[ y + M ][ x + M ] = 0;\n    }\n\n    scanf( \"%d%d\", &x, &y );\n    mapPaint( map, x, y, t + 1 );\n\n    for( i = 0; i < N; i++ )\n      for( j = 0; j < N; j++ )\n        if( map[ i ][ j ] > 1 )\n          count++;\n\n    printf( \"%d\\n\", count );\n  }\n\n  return( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||60<ny||nx<0||121<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2253: Brave Force Story\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define BASE 100\n\ntypedef struct { int x, y, k; } Q;\nQ q[100000]; int top, end;\n\nchar b[200][200];\nchar mk[200][200];\nint mv[6][2] = {{-1,-1},{-1,0},{0,-1},{0,1},{1,0},{1,1}};\n\nint main()  \n{  \n\tint t, n, i, x, y, x2, y2, k, ans;\n\n\twhile (scanf(\"%d%d\", &t, &n) && t > 0) {\n\t\tmemset(mk, 0, sizeof(mk)), memset(b, 0, sizeof(b));\n\t\twhile (n--) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tb[x+BASE][y+BASE] = 1;\n\t\t}\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx += BASE, y += BASE;\n\t\tmk[x][y] = 1;\n\t\tq[0].x = x, q[0].y = y, q[0].k = 0; top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tx = q[top].x, y = q[top].y, k = q[top++].k;\n\t\t\tif (k++ >= t) continue;\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tx2 = x + mv[i][0];\n\t\t\t\ty2 = y + mv[i][1];\n\t\t\t\tif (b[x2][y2] || mk[x2][y2]) continue;\n\t\t\t\tmk[x2][y2] = 1;\n\t\t\t\tq[end].x = x2, q[end].y = y2, q[end++].k = k;\n\t\t\t}\n\t\t}\n\t\tfor (ans = 0, x = 0; x < 200; x++) for (y = 0; y < 200; y++)\n\t\t\tif (mk[x][y]) ans++;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n#define ORIGIN 50\n\nint vx[6] ={1, 1, 0, 0, -1, -1};\nint vy[6] ={1, 0, 1, -1, 0, -1};\nint cell[ORIGIN*2][ORIGIN*2];\n\nint func(int x, int y, int turn){\n\tint ans=0;\n\n\tif(cell[y][x] >= turn || turn <= 0) return 0;\n\tif(cell[y][x] == 0)ans++;\n\tcell[y][x]=turn;\n\n\tfor(int i=0; i<6; i++){\n\t\tans += func(x+vx[i], y+vy[i], turn-1);\n\t}\n\treturn ans;\n}\n\n\nint main(void){\n\tint turn, n, x, y, tmp_x, tmp_y, ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\", &turn, &n);\n\t\tif(turn == 0 && n == 0) break;\n\n\t\tmemset(cell, 0, sizeof(cell));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d %d\", &tmp_x, &tmp_y);\n\t\t\tcell[tmp_y+ORIGIN][tmp_x+ORIGIN] =INT_MAX;\n\t\t}\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tans = func(x+ORIGIN, y+ORIGIN, turn+1);\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1,-1,1};\nint X[]={1,0,-1,0,-1,1};\nint main(){\n  int n,m,t,r,a,b,x[5010],y[5010],i,j,ny,nx;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[100][100]={0};\n    for(i=t=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[b+40][a+40]=40;\n    }\n    scanf(\"%d %d\",&y[0],&x[0]);\n    d[y[0]=40][x[0]=40]=n+1;\n    //printf(\"%d %d\\n\",y[0],x[0]);\n    //printf(\"%d\\n\",d[y[0]][x[0]]);\n    for(r=1;r-t;t++){\n      //if(d[y[t]][x[t]]==1)break;\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx]+1>=d[y[t]][x[t]])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    /*for(i=32;i<48;i++){\n      for(j=32;j<48;j++)printf(\"(%2d,%2d)%2d  \",i-40,j-40,d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||61<ny||nx<0||121<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={1,1,0,0,-1,-1};\nint X[]={0,1,-1,1,-1,0};\nint main(){\n  int n,m,ny,nx,i,j,t,r,y[10000],x[10000],a,b;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[200][200]={};\n    for(i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[b+100][a+100]=1;\n    }\n    scanf(\"%d %d\",&a,&b);\n    d[y[0]=b+100][x[t=0]=a+100]=n+1;\n    for(r=1;r-t;t++){\n      if(d[y[t]][x[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define STD 200\n#define STATE_MAX 3000\t\t/* max state = 6*0 + 6*1 + 6*2 + .... 6*30  < 3000*/\n#define DIR 6\nint objects[STD][STD], queue[STATE_MAX], visited[STD][STD], dir_x[DIR] = {1, 0, -1, -1, 0, 1}, dir_y[DIR] = {0, -1, -1, 0, 1, 1};\nint top, bottom;\n\nvoid put(int val)\n{\n  queue[bottom++] = val;\n}\n\nint get(void)\n{\n  return queue[top++];\n}\n\nint empty(void)\n{\n  return top == bottom;\n}\n\nint main(void)\n{\n  int turn, obj_n, x, y, nx, ny, getted_val, used_turn, i;\n  while(1)\n    {\n      scanf(\"%d %d\", &turn, &obj_n);\n      if(turn == 0 && obj_n == 0)\n\t{\n\t  break;\n\t}\n      top = bottom = used_turn = 0;\n      memset(objects, 0, sizeof(objects));\n      memset(visited, 0, sizeof(visited));\n      while(obj_n--)\n\t{\n\t  scanf(\"%d %d\", &x, &y);\n\t  objects[100 + x][100 + y] = 1;\n\t}\n      scanf(\"%d %d\", &x, &y);\n      x += 100;\n      y += 100;\n      visited[x][y] = 1;\n      put(x * 1000 + y);\n      while(!empty())\n\t{\n\t  getted_val = get();\n\t  x = getted_val / 1000;\n\t  y = getted_val % 1000;\n\t  used_turn = visited[x][y];\n\t  for(i = 0; i < DIR; i++)\n\t    {\n\t      nx = x + dir_x[i];\n\t      ny = y + dir_y[i];\n\t      if(!objects[nx][ny] && !visited[nx][ny] && used_turn <= turn)\n\t\t{\n\t\t  visited[nx][ny] = used_turn + 1;\n\t\t  put(nx * 1000 + ny);\n\t\t}\n\t    }\n\t}\n      printf(\"%d\\n\", top);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||61<ny||nx<0||121<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define S 30\n\nusing namespace std;\n\nint main(void){\n\tint i, j, x, y, sx, sy, t, n, f[S * 2 + 1][S * 2 + 1], ans, dx[6] = {1,1,0,-1,-1,0}, dy[6] = {1,0,-1,-1,0,1};\n\tqueue<pair<int,int> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(!t && !n) break;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tf[x + S][y + S] = -1;\n\t\t}\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tque.push(pair<int,int>(sx + S,sy + S));\n\t\twhile(que.size()){\n\t\t\tx = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tif(f[x][y] >= t) continue;\n\t\t\tfor(i = 0;i < 6;i++){\n\t\t\t\tif(0 <= x + dx[i] && x + dx[i] <= S * 2 && 0 <= y + dy[i] && y + dy[i] <= S * 2 && f[x + dx[i]][y + dy[i]] == 0){\n\t\t\t\t\tf[x + dx[i]][y + dy[i]] = f[x][y] + 1;\n\t\t\t\t\tque.push(pair<int,int>(x + dx[i],y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[sx + S][sy + S] = 0;\n\t\tans = 1;\n\t\tfor(i = 0;i <= S * 2;i++)\n\t\t\tfor(j = 0;j <= S * 2;j++) if(f[i][j] > 0) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[70][70]={};//(0,0)=35,35\nint n,t;\nvoid dfs(int x,int y,int i){\n  a[x][y]=i;\n  i++;\n  if(t>=i-1){\n    if(a[x-1][y-1]==0 || a[x-1][y-1]>i) dfs(x-1,y-1,i);\n    if(a[x-1][y]==0 || a[x-1][y]>i) dfs(x-1,y,i);\n    if(a[x][y-1]==0 || a[x][y-1]>i) dfs(x,y-1,i);\n    if(a[x+1][y+1]==0 || a[x+1][y+1]>i) dfs(x+1,y+1,i);\n    if(a[x+1][y]==0 || a[x+1][y]>i) dfs(x+1,y,i);\n    if(a[x][y+1]==0 || a[x][y+1]>i) dfs(x,y+1,i);\n  }\n  else return;\n}\n\n\nint main(){\n  int i,j,c,co;\n  int x,y,cx,cy;\n  while(1){\n    //syoki\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\ta[i][j]=0;\n      }\n    }\n    co=0;\n    scanf(\"%d%d\",&t,&n);\n    if(t==0&&n==0)break;\n    //printf(\"point 1\\n\");///\n    for(i=0;i<n;i++){\n      scanf(\"%d%d\",&x,&y);\n      // printf(\"\\n\");\n      a[x+35][y+35]=-1;\n    }\n    //printf(\"point 2\\n\");///\n    scanf(\"%d%d\",&cx,&cy);\n    cx+=35;\n    cy+=35;\n    dfs(cx,cy,1);\n    //printf(\"point 3\\n\");///\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\tif(a[i][j]>0)co++;\n      }\n    }\n    printf(\"%d\\n\",co);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint T,N,i,j,x,y,f[150][150]={0},q[1000000][3],l,r,t;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0][0]=x+70;\n\t\tq[0][1]=y+70;\n\t\tq[0][2]=T;\n\t\tfor(r=0,l=1;r<l;r++)\n\t\t{\n\t\t\tx=q[r][0];\n\t\t\ty=q[r][1];\n\t\t\tt=q[r][2];\n\t\t\tf[x][y]=-1;\n\t\t\tfor(i=0;i<6;i++)\n\t\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t\t{\n\t\t\t\t\tq[l][0]=x+mx[i];\n\t\t\t\t\tq[l][1]=y+my[i];\n\t\t\t\t\tq[l][2]=t-1;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<150;i++)\n\t\t\tfor(j=0;j<150;j++)\n\t\t\t\tif(f[i][j]==-1)\n\t\t\t\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||60<ny||nx<0||121<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint T,N,i,j,x,y,f[200][200]={0},q[10000000][3],l,r,t;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0][0]=x+70;\n\t\tq[0][1]=y+70;\n\t\tq[0][2]=T;\n\t\tfor(r=0,l=1;r<l;r++)\n\t\t{\n\t\t\tx=q[r][0];\n\t\t\ty=q[r][1];\n\t\t\tt=q[r][2];\n\t\t\tf[x][y]=-1;\n\t\t\tfor(i=0;i<6;i++)\n\t\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t\t{\n\t\t\t\t\tq[l][0]=x+mx[i];\n\t\t\t\t\tq[l][1]=y+my[i];\n\t\t\t\t\tq[l][2]=t-1;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<200;i++)\n\t\t\tfor(j=0;j<200;j++)\n\t\t\t\tif(f[i][j]==-1)\n\t\t\t\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2253: Brave Force Story\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define BASE 100\n\ntypedef struct { int x, y, k; } Q;\nQ q[4000]; int top, end;\n\nchar b[200][200];\nchar mk[200][200];\nint mv[6][2] = {{1,1},{-1,-1},{0,-1},{-1,0},{0,1},{1,0}};\n\nint main()  \n{  \n\tint t, n, i, x, y, x2, y2, k, ans;\n\n\twhile (scanf(\"%d%d\", &t, &n) && t > 0) {\n\t\tmemset(mk, 0, sizeof(mk)), memset(b, 0, sizeof(b));\n\t\twhile (n--) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tb[x+BASE][y+BASE] = 1;\n\t\t}\n\t\tscanf(\"%d%d\", &x, &y); x += BASE, y += BASE;\n\t\tq[0].x = x, q[0].y = y, q[0].k = 0; top = 0, end = 1;\n\t\tans = 1; mk[x][y] = 1;\n\t\twhile (top < end) {\n\t\t\tx = q[top].x, y = q[top].y, k = q[top++].k;\n\t\t\tif (k++ >= t) continue;\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tx2 = x + mv[i][0];\n\t\t\t\ty2 = y + mv[i][1];\n\t\t\t\tif (b[x2][y2] || mk[x2][y2]) continue;\n\t\t\t\tans++, mk[x2][y2] = 1;\n\t\t\t\tq[end].x = x2, q[end].y = y2, q[end++].k = k;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar visited[200][200];\n\nint dfs(int x,int y,int turn) {\n\tint sum=0;\n\tif(visited[y][x]==0)sum++;\n\tif(visited[y][x]>=turn+1)return 0;\n\tvisited[y][x]=turn+1;\n\tif(turn>0) {\n\t\tsum+=dfs(x,y+1,turn-1);\n\t\tsum+=dfs(x+1,y+1,turn-1);\n\t\tsum+=dfs(x-1,y,turn-1);\n\t\tsum+=dfs(x+1,y,turn-1);\n\t\tsum+=dfs(x-1,y-1,turn-1);\n\t\tsum+=dfs(x,y-1,turn-1);\n\t}\n\treturn sum;\n}\n\nint main(void) {\n\tint t,n;\n\twhile(scanf(\"%d%d\",&t,&n)==2 && (t|n)!=0) {\n\t\tint i,j;\n\t\tint x[300],y[300];\n\t\tint sx,sy;\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tfor(i=0;i<n;i++)visited[y[i]+100][x[i]+100]=100;\n\t\tprintf(\"%d\\n\",dfs(sx+100,sy+100,t));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint m[1000][1000];\ntypedef struct point{\n\tint x,y;\n}POINT;\nPOINT q[3000],sq[3000];\nint qn,sqn;\nint main(){\n\tint i,j,t,n,x,y,ans;\n\tint dx[]={0,1,-1,1,-1,0},dy[]={1,1,0,0,-1,-1};\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t==0 && n==0)break;\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tm[y+300][x+300]=2;\n\t\t}\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0].x=x+300,q[0].y=y+300;\n\t\tqn=1;sqn=0;ans=1;m[y+300][x+300]=1;\n\t\twhile(t--){\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\tfor(j=0;j<6;j++){\n\t\t\t\t\tif(m[q[i].y+dy[j]][q[i].x+dx[j]]==0){\n\t\t\t\t\t\tm[q[i].y+dy[j]][q[i].x+dx[j]]=1;\n\t\t\t\t\t\tsq[sqn].y=q[i].y+dy[j];\n\t\t\t\t\t\tsq[sqn].x=q[i].x+dx[j];\n\t\t\t\t\t\tsqn++;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqn=sqn;\n\t\t\tmemcpy(q,sq,sizeof(POINT)*qn);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[70][70]={};//(0,0)=35,35\nint n,t;\nvoid dfs(int x,int y,int i){\n  a[x][y]=i;\n  i++;\n  if(t>=i-1){\n    if(a[x-1][y-1]==0 || a[x-1][y-1]>i) dfs(x-1,y-1,i);\n    if(a[x-1][y]==0 || a[x-1][y]>i) dfs(x-1,y,i);\n    if(a[x][y-1]==0 || a[x][y-1]>i) dfs(x,y-1,i);\n    if(a[x+1][y+1]==0 || a[x+1][y+1]>i) dfs(x+1,y+1,i);\n    if(a[x+1][y]==0 || a[x+1][y]>i) dfs(x+1,y,i);\n    if(a[x][y+1]==0 || a[x][y+1]>i) dfs(x,y+1,i);\n  }\n  else return;\n}\n\n\nint main(){\n  int i,j,c,co;\n  int x,y,cx,cy;\n  while(1){\n    //syoki\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\ta[i][j]=0;\n      }\n    }\n    co=0;\n    scanf(\"%d%d\",&t,&n);\n    if(t==0&&n==0)break;\n    //printf(\"point 1\\n\");///\n    for(i=0;i<n;i++){\n      scanf(\"%d%d\",&x,&y);\n      // printf(\"\\n\");\n      a[x+35][y+35]=-1;\n    }\n    //printf(\"point 2\\n\");///\n    scanf(\"%d%d\",&cx,&cy);\n    cx+=35;\n    cy+=35;\n    dfs(cx,cy,1);\n    //printf(\"point 3\\n\");///\n    for(i=0;i<70;i++){\n      for(j=0;j<70;j++){\n\tif(a[i][j]>0)co++;\n      }\n    }\n    printf(\"%d\\n\",co);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint T,N,i,j,x,y,f[200][200]={0},q[10000][3],l,r,t;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n \nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0][0]=x+70;\n\t\tq[0][1]=y+70;\n\t\tq[0][2]=T;\n\t\tfor(r=0,l=1;r<l;r++)\n\t\t{\n\t\t\tx=q[r][0];\n\t\t\ty=q[r][1];\n\t\t\tt=q[r][2];\n\t\t\tfor(i=0;i<6;i++)\n\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t{\n\t\t\t\tq[l][0]=x+mx[i];\n\t\t\t\tq[l][1]=y+my[i];\n\t\t\t\tq[l][2]=t-1;\n\t\t\t\tf[x+mx[i]][y+my[i]]=-1;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<200;i++)\n\t\tfor(j=0;j<200;j++)\n\t\tif(f[i][j]==-1)\n\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={1,1,0,0,-1,-1};\nint X[]={0,1,-1,1,-1,0};\nint main(){\n  int n,m,ny,nx,i,j,t,r,y[10000],x[10000],a,b;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[100][100]={};\n    for(i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[b+50][a+50]=1e9;\n    }\n    scanf(\"%d %d\",&a,&b);\n    d[y[0]=b+50][x[t=0]=a+50]=n+1;\n    for(r=1;r-t;t++){\n      if(d[y[t]][x[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][60-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=60-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(ny<0||62<ny||nx<0||130<nx)continue;\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define ORIGIN 100\n\nint vx[6] ={1, 1, 0, 0, -1, -1};\nint vy[6] ={1, 0, 1, -1, 0, -1};\nint cell[ORIGIN*2][ORIGIN*2];\n\nint func(int x, int y, int turn){\n\tint ans=0;\n\n\tif(cell[y][x] >= turn || turn <= 0) return 0;\n\tif(cell[y][x] == 0)ans++;\n\tcell[y][x]=turn;\n\n\tfor(int i=0; i<6; i++){\n\t\tans += func(x+vx[i], y+vy[i], turn-1);\n\t}\n\treturn ans;\n}\n\n\nint main(void){\n\tint turn, n, x, y, tmp_x, tmp_y, ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\", &turn, &n);\n\t\tif(turn == 0 && n == 0) break;\n\n\t\tmemset(cell, 0, sizeof(cell));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d %d\", &tmp_x, &tmp_y);\n\t\t\tcell[tmp_y+ORIGIN][tmp_x+ORIGIN] =500;\n\t\t}\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tans = func(x+ORIGIN, y+ORIGIN, turn+1);\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint dx[]={0,-1,-1,0,1,1};\nint dy[]={1,0,-1,-1,0,1};\nint obstacle[200][200], visited[200][200];\nint q[40000], top, bottom;\n\nint main(void)\n{\n    int t, n;\n    while (scanf(\"%d%d\", &t, &n), t) {\n        int x, y, res;\n        memset(obstacle, 0, sizeof(obstacle));\n        memset(visited, 0, sizeof(visited));\n        while (n--) {\n            scanf(\"%d%d\", &x, &y);\n            obstacle[x+100][y+100]=1;\n        }\n        scanf(\"%d%d\", &x, &y);\n\n        res=top=bottom=0;\n        x+=100, y+=100;\n        q[bottom++]=x*1000+y;\n        visited[x][y]=1;\n        while (top<bottom) {\n            int i, k;\n            x=q[top]/1000;\n            y=q[top]%1000;\n            k=visited[x][y];\n            ++top;\n            for(i=0;i<6;++i) {\n                int nx=x+dx[i], ny=y+dy[i];\n                if (!visited[nx][ny] && !obstacle[nx][ny] && k<=t) {\n                    q[bottom++]=nx*1000+ny;\n                    visited[nx][ny]=k+1;\n                }\n            }\n        }\n        printf(\"%d\\n\", top);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1,-1,1};\nint X[]={1,0,-1,0,-1,1};\nint main(){\n  int n,m,t,r,a,b,x[5010],y[5010],i,j,ny,nx;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[300][300]={t=0};\n    while(m--){\n      scanf(\"%d %d\",&a,&b);\n      d[b+100][a+100]=40;\n    }\n    scanf(\"%d %d\",&x[0],&y[0]);\n    d[y[0]+=100][x[0]+=100]=n+1;\n    for(r=1;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx]+1>=d[y[t]][x[t]])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1,-1,1};\nint X[]={1,0,-1,0,-1,1};\nint main(){\n  int n,m,t,r,a,b,x[5010],y[5010],i,j,ny,nx;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[100][100]={t=0};\n    while(m--){\n      scanf(\"%d %d\",&a,&b);\n      d[b+40][a+40]=40;\n    }\n    scanf(\"%d %d\",&x[0],&y[0]);\n    d[y[0]+=40][x[0]+=40]=n+1;\n    for(r=1;r-t;t++){\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx]+1>=d[y[t]][x[t]])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 2253\n   Brave Force Story\n   2015/9/22\n*/\n\n#include<stdio.h>\n#include<limits.h>\n#define OBJ_MAX 300\n#define TURN_MAX 30\n#define COO_MAX 5000\n#define DIR 6\n\nstruct coordinates\n{\n  int x, y;\n};\n\nstruct visited\n{\n  int x, y, rest_turn;\n};\n\nint dir[DIR][2] = {{1, 0}, {0, -1}, {-1, -1}, {-1, 0}, {0, 1}, {1, 1}};\nstruct visited visited_table[COO_MAX];\nint cnt = 0;\n\n\nint can_go(int x, int y, int obj_n, int turn, struct coordinates* coordinates_table)\n{\n  int i;\n  for(i = 0; i < obj_n; i++)\n    {\n      if(x == coordinates_table[i].x && y == coordinates_table[i].y)\n\t{\n\t  return 0;\n\t}\n    }\n  for(i = 0; i < cnt; i++)\n    {\n      if(visited_table[i].x == x && visited_table[i].y == y)\n  \t{\n\t  if(visited_table[i].rest_turn >= turn)\n\t    {\n\t      return 0;\t      \n\t    }\n\t  else\n\t    {\n\t      visited_table[i].rest_turn = turn;\n\t      return 1;\n\t    }\n  \t}\n\n    }\n  visited_table[cnt].x = x;\n  visited_table[cnt].y = y;\n  visited_table[cnt].rest_turn = turn;\n  cnt++;\n  return 1;\n}\n\nvoid dfs_cnt(int x, int y, int turn_n, int obj_n, struct coordinates* coordinates_table)\n{\n  int i, next_x, next_y;\n\n  coordinates_table[obj_n].x = x;\n  coordinates_table[obj_n].y = y;\n  obj_n++;\n\n  if(turn_n <= 0)\n    {\n      return ;\n    }\n  for(i = 0; i < DIR; i++)\n    {\n      next_x = x + dir[i][0];\n      next_y = y + dir[i][1];\n\n      if(can_go(next_x, next_y, obj_n, turn_n, coordinates_table))\n\t{\n\t  dfs_cnt(next_x, next_y, turn_n - 1, obj_n, coordinates_table);\n\t}\n    }\n}\n\nint main(void)\n{\n  int i, start_x, start_y, turn_n, obj_n;\n  struct coordinates coordinates_table[COO_MAX];\n\n  while(1)\n    {\n      cnt = 0;\n      scanf(\"%d %d\", &turn_n, &obj_n);\n      if(turn_n == 0 && obj_n == 0)\n\t{\n\t  break;\n\t}\n      for(i = 0; i < obj_n; i++)\n\t{\n\t  scanf(\"%d %d\", &coordinates_table[i].x, &coordinates_table[i].y);\n\t}\n      scanf(\"%d %d\", &start_x, &start_y);\n      visited_table[cnt].x = start_x;\n      visited_table[cnt].y = start_y;\n      visited_table[cnt].rest_turn = 0;\n      cnt++;\n      dfs_cnt(start_x, start_y, turn_n, obj_n, coordinates_table);\n      printf(\"%d\\n\", cnt);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint m[100][100];\ntypedef struct point{\n\tint x,y;\n}POINT;\nPOINT q[1000],sq[1000];\nint qn,sqn;\nint main(){\n\tint i,j,t,n,x,y,ans;\n\tint dx[]={0,1,-1,1,-1,0},dy[]={1,1,0,0,-1,-1};\n\twhile(1){\n\t\tscanf(\"%d%d\",&t,&n);\n\t\tif(t==0 && n==0)break;\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tm[y+50][x+50]=2;\n\t\t}\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0].x=x+50,q[0].y=y+50;\n\t\tqn=1;sqn=0;ans=1;m[y+50][x+50]=1;\n\t\twhile(t--){\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\tfor(j=0;j<6;j++){\n\t\t\t\t\tif(m[q[i].y+dy[j]][q[i].x+dx[j]]==0){\n\t\t\t\t\t\tm[q[i].y+dy[j]][q[i].x+dx[j]]=1;\n\t\t\t\t\t\tsq[sqn].y=q[i].y+dy[j];\n\t\t\t\t\t\tsq[sqn].x=q[i].x+dx[j];\n\t\t\t\t\t\tsqn++;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqn=sqn;\n\t\t\tmemcpy(q,sq,sizeof(POINT)*qn);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={0,1,0,-1,-1,1};\nint X[]={1,0,-1,0,-1,1};\nint main(){\n  int n,m,t,r,a,b,x[1010],y[1010],i,j,ny,nx;\n  while(scanf(\"%d %d\",&n,&m),n){\n    int d[100][100]={0};\n    for(i=t=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      d[b+40][a+40]=40;\n    }\n    scanf(\"%d %d\",&y[0],&x[0]);\n    d[y[0]=40][x[0]=40]=n+1;\n    //printf(\"%d %d\\n\",y[0],x[0]);\n    //printf(\"%d\\n\",d[y[0]][x[0]]);\n    for(r=1;r-t;t++){\n      //if(d[y[t]][x[t]]==1)break;\n      for(i=0;i<6;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx]+1>=d[y[t]][x[t]])continue;\n\td[y[r]=ny][x[r]=nx]=d[y[t]][x[t]]-1;\n\tr++;\n      }\n    }\n    /*for(i=32;i<48;i++){\n      for(j=32;j<48;j++)printf(\"(%2d,%2d)%2d  \",i-40,j-40,d[i][j]);\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint T,N,i,j,x,y,f[200][200]={0},q[10000][3],l,r,t;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n \nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0][0]=x+70;\n\t\tq[0][1]=y+70;\n\t\tf[x+70][y+70]=-1;\n\t\tq[0][2]=T;\n\t\tfor(r=0,l=1;r<l;r++)\n\t\t{\n\t\t\tx=q[r][0];\n\t\t\ty=q[r][1];\n\t\t\tt=q[r][2];\n\t\t\tfor(i=0;i<6;i++)\n\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t{\n\t\t\t\tq[l][0]=x+mx[i];\n\t\t\t\tq[l][1]=y+my[i];\n\t\t\t\tq[l][2]=t-1;\n\t\t\t\tf[x+mx[i]][y+my[i]]=-1;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<200;i++)\n\t\tfor(j=0;j<200;j++)\n\t\tif(f[i][j]==-1)\n\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint T,N,i,j,x,y,f[150][150]={0},q[10000000][3],l,r,t;\nint mx[6]={0,1,1,0,-1,-1},my[6]={1,1,0,-1,-1,0};\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&T,&N),T;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=r=0;i<N;f[x+70][y+70]=1,i++)\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tq[0][0]=x+70;\n\t\tq[0][1]=y+70;\n\t\tq[0][2]=T;\n\t\tfor(r=0,l=1;r<l;r++)\n\t\t{\n\t\t\tx=q[r][0];\n\t\t\ty=q[r][1];\n\t\t\tt=q[r][2];\n\t\t\tf[x][y]=-1;\n\t\t\tfor(i=0;i<6;i++)\n\t\t\t\tif(f[x+mx[i]][y+my[i]]==0&&t>0)\n\t\t\t\t{\n\t\t\t\t\tq[l][0]=x+mx[i];\n\t\t\t\t\tq[l][1]=y+my[i];\n\t\t\t\t\tq[l][2]=t-1;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=r=0;i<150;i++)\n\t\t\tfor(j=0;j<150;j++)\n\t\t\t\tif(f[i][j]==-1)\n\t\t\t\t\tr++;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,y,x,ny,nx,t,r,qx[10000],qy[10000],i,j,c;\n  int X[]={1,2, 1,-1,-2,-1};\n  int Y[]={1,0,-1,-1, 0, 1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[620][1300]={0};\n    while(m--){\n      scanf(\"%d %d\",&x,&y);\n      d[30-y][30-y+x*2]=-1;\n    }\n    scanf(\"%d %d\",&x,&y);\n    qy[t=0]=30-y;\n    qx[0]=30-y+x*2;\n    d[qy[t]][qx[t]]=n+1;\n    c=1;\n    for(r=1;r-t;t++){\n      if(d[qy[t]][qx[t]]==1)continue;\n      for(i=0;i<6;i++){\n\tny=qy[t]+Y[i];\n\tnx=qx[t]+X[i];\n\tif(d[ny][nx])continue;\n\tc++;\n\td[ny][nx]=d[qy[t]][qx[t]]-1;\n\tqx[r  ]=nx;\n\tqy[r++]=ny;\n      }\n    }\n    /*for(i=0;i<62;i++){\n      for(j=0;j<130;j++){\n\tprintf(\"%2d\",d[i][j]);\n      }\n      printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    while(true){\n        val (t, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (t == 0 && n == 0) return\n        val hex = Array(121){BooleanArray(121){false}}\n        repeat(n){\n            val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n            hex[y + 60][x + 60] = true\n        }\n        val (sx, sy) = readLine()!!.trim().split(' ').map{it.toInt() + 60}\n        hex[sy][sx] = true\n        var current = listOf(HexPoint(sx, sy))\n        repeat(t){\n            current = current.flatMap {it.neighbors().filterNot{p -> hex[p.y][p.x]}}\n            current.forEach{hex[it.y][it.x] = true}\n        }\n        println(hex.sumBy{line -> line.count{it}} - n)\n    }\n}\ndata class HexPoint(val x: Int, val y: Int){\n    fun neighbors(): Iterable<HexPoint> = listOf(HexPoint(0, 1), HexPoint(1, 1), HexPoint(1, 0), HexPoint(0, -1), HexPoint(-1, -1), HexPoint(-1, 0)).map{it + this}\n    private operator fun plus(that: HexPoint): HexPoint = HexPoint(x + that.x, y + that.y)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val hex = Array(121){BooleanArray(121){false}}\n    while(true){\n        val (t, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (t == 0 && n == 0) return\n        hex.forEach { it.fill(false) }\n        repeat(n){\n            val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n            hex[y + 60][x + 60] = true\n        }\n        val (sx, sy) = readLine()!!.trim().split(' ').map{it.toInt() + 60}\n        hex[sy][sx] = true\n        var current = listOf(HexPoint(sx, sy))\n        repeat(t){\n            current = current.flatMap {it.neighbors().filterNot{p -> hex[p.y][p.x]}}.distinct()\n            current.forEach{hex[it.y][it.x] = true}\n        }\n        println(hex.sumBy{line -> line.count{it}} - n)\n    }\n}\ndata class HexPoint(val x: Int, val y: Int){\n    fun neighbors(): Iterable<HexPoint> = listOf(HexPoint(0, 1), HexPoint(1, 1), HexPoint(1, 0), HexPoint(0, -1), HexPoint(-1, -1), HexPoint(-1, 0)).map{it + this}\n    private operator fun plus(that: HexPoint): HexPoint = HexPoint(x + that.x, y + that.y)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    while(true){\n        val (t, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (t == 0 && n == 0) return\n        val hex = Array(4 * t + 1){BooleanArray(4 * t + 1){false}}\n        repeat(n){\n            val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n            hex[y + 2 * t][x + 2 * t] = true\n        }\n        val (sx, sy) = readLine()!!.trim().split(' ').map{it.toInt() + 2 * t}\n        hex[sy][sx] = true\n        var current = listOf(HexPoint(sx, sy))\n        repeat(t){\n            current = current.flatMap {it.neighbors().filterNot{p -> hex[p.y][p.x]}}\n            current.forEach{hex[it.y][it.x] = true}\n        }\n        println(hex.sumBy{line -> line.count{it}} - n)\n    }\n}\ndata class HexPoint(val x: Int, val y: Int){\n    fun neighbors(): Iterable<HexPoint> = listOf(HexPoint(0, 1), HexPoint(1, 1), HexPoint(1, 0), HexPoint(0, -1), HexPoint(-1, -1), HexPoint(-1, 0)).map{it + this}\n    private operator fun plus(that: HexPoint): HexPoint = HexPoint(x + that.x, y + that.y)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//B: Brave Force Story\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}};\n\t\twhile(true){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t==0&&n==0)break;\n\t\t\tboolean[][] map = new boolean[200][200];\n\t\t\twhile(n--!=0){\n\t\t\t\tint x = sc.nextInt()+100;\n\t\t\t\tint y = sc.nextInt()+100;\n\t\t\t\tmap[x][y] = true;\n\t\t\t}\n\t\t\tint x = sc.nextInt()+100;\n\t\t\tint y = sc.nextInt()+100;\n\t\t\tmap[x][y] = true;\n\t\t\tint c = 1;\n\t\t\tList<int[]> list = new ArrayList<int[]>();\n\t\t\tlist.add(new int[]{x, y});\n\t\t\twhile(t--!=0){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int[] a:list){\n\t\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\t\tint nx = a[0]+move[k][0];\n\t\t\t\t\t\tint ny = a[1]+move[k][1];\n\t\t\t\t\t\tif(!map[nx][ny]){\n\t\t\t\t\t\t\tmap[nx][ny] = true;\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tnext.add(new int[]{nx, ny});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 60;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = point.x + move[0];\n\t\t\t\t\tfinal int ny = point.y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= (MAX + 1 + MAX) || ny < 0 || ny >= (MAX + 1 + MAX)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tqueue.add(new Point(point.old + 1, nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[61][61];\n  dist=new int[61][61];\n  for(int i=0;i=60;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  bfs();\n  int ct=0;\n  for(int i=0;i=60;i++) for(int j=0;j<60;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n que.offerLast(new int[]{0,0});\n dist[OFFSET][OFFSET]=0;\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET];\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dx = {0, 1, 1, 0, -1, -1};\n\tstatic int[] dy = {1, 1, 0, -1, -1, 0};\n\tstatic int[][] time;\n\tstatic int offset = 50;\n\n\tstatic void rec(int cx, int cy, int t) {\n\t\tif (t < 0) return;\n\t\ttime[cx][cy] = t;\n\t\tfor (int i=0; i<6; i++) {\n\t\t\tint nx = cx + dx[i];\n\t\t\tint ny = cy + dy[i];\n\t\t\tif (time[nx][ny] < t) {\n\t\t\t\trec(nx, ny, t-1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tint t = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tif (t + n == 0) return false;\n\n\t\ttime = new int[100][100];\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tArrays.fill(time[i], -1);\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint x = in.nextInt() + offset;\n\t\t\tint y = in.nextInt() + offset;\n\t\t\ttime[x][y] = 1<<30;\n\t\t}\n\n\t\tint sx = in.nextInt() + offset;\n\t\tint sy = in.nextInt() + offset;\n\t\trec(sx, sy, t);\n\n\t\tint ans = 0;\n\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tfor (int j=0; j<100; j++) {\n\t\t\t\tif (time[i][j] < 0 || time[i][j] == 1<<30) continue;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] fault = new int[2][n];\n\t\t\tint[][] map = new int[200][200];\n\t\t\tboolean[][] reach = new boolean[200][200];\n\t\t\tint[][] move = {{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\n\t\t\t\n\t\t\tfor(int i = 0; i < 199; i++){\n\t\t\t\tfor(int j = 0; j < 199; j++){\n\t\t\t\t\tmap[j][i] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfault[0][i] = sc.nextInt();\n\t\t\t\tfault[1][i] = sc.nextInt();\n\t\t\t\tmap[fault[0][i] + 30][fault[1][i] + 30] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] start = {sc.nextInt() + 30 , sc.nextInt() + 30};\n\t\t\treach[start[0]][start[1]] = true;\n\t\t\tint count = 0;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tint size;\n\t\t\tQueue<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.offer(new Point(start[0], start[1]));\n\t\t\twhile(true){\n\t\t\t\tif(count == t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tx = queue.peek().x; \n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tfor(int j = 0; j < move.length; j++){\n\t\t\t\t\t\tnextx = x + move[j][0];\n\t\t\t\t\t\tnexty = y + move[j][1];\n\t\t\t\t\t\tif(0 <= nextx && 0 <= nexty && nextx <= 199 && nexty <= 199 && map[nextx][nexty] != -1\n\t\t\t\t\t\t\t\t&& !reach[nextx][nexty]){\n\t\t\t\t\t\t\treach[nextx][nexty]  = true;\n\t\t\t\t\t\t\tmap[nextx][nexty] = count + 1;\n\t\t\t\t\t\t\tqueue.offer(new Point(nextx, nexty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 199; i++){\n\t\t\t\tfor(int j = 0; j < 199; j++){\n\t\t\t\t\tif(reach[j][i]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint range = 30;\n\t\tint t,n,c;\n\t\twhile(true) {\n\t\t\tc=0;\n\t\t\tint[][] area = new int[range*2+1][range*2+1];\n\t\t\tt=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif(t==0) {break;}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarea[sc.nextInt()+range][sc.nextInt()+range] = -1000;\n\t\t\t}\n\t\t\tcanMove(area,sc.nextInt()+range,sc.nextInt()+range,t);\n\t\t\t\n\t\t\tfor(int i=0;i<range*2+1;i++) {\n\t\t\t\tfor(int j=0;j<range*2+1;j++) {\n\t\t\t\t\tif(area[i][j] > 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void canMove(int[][] area,int x,int y,int maxt) {\n\t\t\n\t\tfor(int i=0;i<=maxt;i++) {\n\t\t\tif(area[x][y] >= 0) {\n\t\t\t\tarea[x][y] ++;\n\t\t\t\tcanMove(area,x,y+1,maxt-1);\n\t\t\t\tcanMove(area,x+1,y+1,maxt-1);\n\t\t\t\tcanMove(area,x-1,y,maxt-1);\n\t\t\t\tcanMove(area,x+1,y,maxt-1);\n\t\t\t\tcanMove(area,x,y-1,maxt-1);\n\t\t\t\tcanMove(area,x-1,y-1,maxt-1);\n\t\t\t}\n\t\t}\n\t\treturn;\n//\t\t return area;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main\n{\n\n    private static final int[] dx = {0,1,1,0,-1,-1};\n    private static final int[] dy = {1,1,0,-1,-1,0};\n\n    private static class Pox implements Comparable<Pox>\n    {\n\tpublic Point p;\n\tpublic int cnt;\n\n\tPox()\n\t{\n\t    p = new Point(-1,-1);\n\t    cnt = 0;\n\t}\n\n\tPox(int x,int y,int c)\n\t{\n\t    p = new Point(x,y);\n\t    cnt = c;\n\t}\n\n\n\tpublic int compareTo(Pox a)\n\t{\n\t    return -1;\n\t}\n\n\n    }\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\twhile(true)\n\t    {\n\t\tString line;\n\t\tline = in.readLine();\n\t\tint t,n;\t\tt = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tn = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tif(t == 0 && n == 0)\n\t\t    break;\n\t\tHashMap<Point,Boolean> map = new HashMap<Point,Boolean>();\n\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint X,Y;\n\t\t\tline = in.readLine();\n\t\t\tX = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\t\tY = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\t\tmap.put(new Point(X,Y),true);\n\t\t    }\n\n\t\tint sx,sy;\n\t\tline = in.readLine();\n\t\tsx = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tsy = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tQueue<Pox> que = new PriorityQueue<Pox>();\n\t\tque.offer(new Pox(sx,sy,0));\n\t\tmap.put(new Point(sx,sy),false);\n\n\t\tint[][] used = new int[400][400];\n\n\t\tfor(int i=0;i<200;i++)\n\t\t    for(int j=0;j<200;j++)\n\t\t\tused[i][j] = 10000000;\n\n\t\twhile(que.size() > 0)\n\t\t    {\n\t\t\tPox pox = que.poll();\n\n\t\t\tif(pox.cnt >= t)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t    {\n\t\t\t\tint nx = pox.p.x + dx[i],ny = pox.p.y + dy[i];\n\t\t\t\tif(!(Math.abs(nx) <= 30 && Math.abs(ny) <= 30))\n\t\t\t\t    continue;\n\n\t\t\t\tif(map.containsKey(new Point(nx,ny)))\n\t\t\t\t    {\n\t\t\t\t\tif(map.get(new Point(nx,ny)))\n\t\t\t\t\t    continue;\n\t\t\t\t    }\n\n\t\t\t\tif(used[ny+100][nx+100] <= pox.cnt)\n\t\t\t\t    continue;\n\n\t\t\t\tused[ny+100][nx+100] = pox.cnt;\n\t\t\t\tmap.put(new Point(nx,ny),false);\n\t\t\t\tque.offer(new Pox(nx,ny,pox.cnt+1));\n\t\t\t    }\n\n\t\t    }\n\t\tSystem.out.println(map.size()-n);\n\t    }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\tboolean[][] map = new boolean[70][70];\n\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\twhile(true){\n\t\t\tlist1.clear();\n\t\t\tlist2.clear();\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<70;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+35][y+35] = false;\n\t\t\t}\n\t\t\t\n\t\t\tint now_x = Integer.parseInt(stdIn.next());\n\t\t\tint now_y = Integer.parseInt(stdIn.next());\n\t\t\tPoint now = new Point(now_x+35,now_y+35);\n\t\t\tmap[now_x+35][now_y+35] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tnow = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[now.x+d[j][0]][now.y+d[j][1]]){\n\t\t\t\t\t\t\tmap[now.x+d[j][0]][now.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(now.x+d[j][0],now.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 1, 0, 0, -1, -1 };\n\tint[] dy = { 1, 0, -1, 1, 0, -1 };\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((t | n) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] visit = new int[100][100];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt() + 30;\n\t\t\t\tint y = sc.nextInt() + 30;\n\t\t\t\tvisit[y][x] = -1;\n\t\t\t}\n\t\t\tint sx = sc.nextInt() + 30;\n\t\t\tint sy = sc.nextInt() + 30;\n\t\t\tvisit[sy][sx] = 1;\n\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sx, sy));\n\t\t\tint turn = 0;\n\t\t\twhile (!que.isEmpty() && turn++ < t) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tPos now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\t\tint nextX = now.x + dx[j];\n\t\t\t\t\t\tint nextY = now.y + dy[j];\n\t\t\t\t\t\tif (visit[nextY][nextX] == 0) {\n\t\t\t\t\t\t\tvisit[nextY][nextX] = 1;\n\t\t\t\t\t\t\tque.add(new Pos(nextX, nextY));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (visit[i][j] == 1) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint x;\n\t\tint y;\n\n\t\t/**\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tpublic Pos(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int lim) {\n\t\treturn 0 <= h && h < lim && 0 <= w && w < lim;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[][] map;\n    /*\n      [x][y]\n      0 : 未到達\n      1 : 到達済\n      -1 : 障害物があり、通れない\n    */\n    int x, y;\n    int t, n;\n    int count;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    map = new int[100][100];\n\t    t = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(t!=0){\n\t\tint i=n;\n\t\twhile(i>0){\n\t\t    i--;\n\t\t    map[sc.nextInt()+30][sc.nextInt()+30] = -1;\n\t\t}\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tcount = 0;\n\t\tsolve(t, x, y);\n\t\tSystem.out.println(count);\n\t    }\n\t}\n    }\n\n    int[][] dir = { {0, 1}, {1, 1}, {1, 0}, \n\t\t    {0, -1}, {-1, -1}, {-1, 0} };\n\t\t    \n    void solve(int t, int x, int y){\n\tif(t<0 || map[x+30][y+30]==-1 || map[x+30][y+30]>30) return;\n\t// 現在地が到達済か？\n\tif(map[x+30][y+30]!=-1){\n\t    if(map[x+30][y+30]==0)\n\t\tcount++;\n\t    map[x+30][y+30]++;\n\t}\n\t// 移動する\n\tfor(int i=0; i<dir.length; i++){\n\t    move(t-1, x+dir[i][0], y+dir[i][1], dir[i][0], dir[i][1]);\n\t    solve(t-1, x+dir[i][0], y+dir[i][1]);\n\t}\n    }\n\n    void move(int t, int x, int y, int dx, int dy){\n\twhile(t>0 && map[x+30][y+30]!=-1){\n\t    t--;\n\t    if(map[x+30][y+30]!=-1){\n\t\tif(map[x+30][y+30]==0)\n\t\t    count++;\n\t\tmap[x+30][y+30]++;\n\t    }\n\t    x += dx;\n\t    y += dy;\n\t}\n    }\n}   "
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point(){\n\n\t\t}\n\t\tpublic Point(int x,int y){\n\t\t\tthis.x=Math.max(Math.min(x,30),-30);\n\t\t\tthis.y=Math.max(Math.min(y,30),-30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode(){\n\t\t\treturn x+37*y;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\",\"+y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic{\n\t\tdir=new Point[]{\n\t\t\tnew Point(1,0),\n\t\t\tnew Point(1,1),\n\t\t\tnew Point(0,1),\n\t\t\tnew Point(-1,0),\n\t\t\tnew Point(-1,-1),\n\t\t\tnew Point(0,-1)};\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p,int turn){\n\t\tif((pmap.get(p) ==null || pmap.get(p)>turn) && turn <=t){\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tPoint _p=new Point(p.x+dir[i].x,p.y+dir[i].y);\n\t\t\t\tmove(_p,turn+1);\n\t\t\t}\n\t\t\tpmap.put(p,turn);\n\t\t}\n\t}\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap=new HashMap<Point, Integer>();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint p=new Point();\n\t\t\t\tp.x=sc.nextInt();\n\t\t\t\tp.y=sc.nextInt();\n\t\t\t\tpmap.put(p,-2);\n\t\t\t}\n\t\t\tPoint zero=new Point();\n\t\t\tzero.x=sc.nextInt();\n\t\t\tzero.y=sc.nextInt();\n\t\t\tmove(zero,0);\n\t\t\tcount=0;\n\t\t\tif(pmap.size()>0){\n\t\t\tfor(Entry<Point, Integer> p : pmap.entrySet()){\n\t\t\t\tif(p.getValue()>=0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 31;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && !wall[point.y][point.x - 1] && !visited[point.y][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && !wall[point.y][point.x + 1] && !visited[point.y][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y > 0 && !wall[point.y - 1][point.x] && !visited[point.y - 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y < (MAX + MAX) && !wall[point.y + 1][point.x] && !visited[point.y + 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && point.y > 0 && !wall[point.y - 1][point.x - 1] && !visited[point.y - 1][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && point.y < (MAX + MAX) && !wall[point.y + 1][point.x + 1] && !visited[point.y + 1][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int MAP_SIZE = 60;\n\tprivate static final int BLOCK = 99;\n\n\tpublic static void main(String[] arg) {\n\t\tString err = \"\";\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\terr += (life - 1) + \" \" + n + \"\\n\";\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\n\t\t\t\terr += (x - MAP_SIZE) + \" \" + (y - MAP_SIZE) + \"\\n\";\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\terr += (x - MAP_SIZE) + \" \" + (y - MAP_SIZE) + \"\\n\";\n\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t}\n\t\tin.close();\n\t\tthrow new RuntimeException(err);\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"%2d\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[61][61];\n\n    static void move(int x,int y,int tern){\n        if(x<-30 || 30<x || y<-30 || 30<y) return;\n        if(map[x+30][y+30]==-2) return;\n        if(map[x+30][y+30]==-1){\n            num++;\n            map[x+30][y+30]=tern;\n        }else if(map[x+30][y+30]>=tern) return;\n        if(tern==0) return;\n        move(x+1,y+1,tern-1);\n        move(x+1,y,tern-1);\n        move(x,y+1,tern-1);\n        move(x,y-1,tern-1);\n        move(x-1,y,tern-1);\n        move(x-1,y-1,tern-1);\n    }\n\n    public static void main(String[] args) {\n        int tern,object;\n\n        int x,y;\n\n        while(true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if(tern==0 && object==0) break;\n\n            for(int i=0;i<61;i++){\n                for(int j=0;j<61;j++)\n                    map[i][j]=-1;\n            }\n            num=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            move(x, y, tern);\n\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tAOJ2253 obj = new AOJ2253();\n\t\twhile(true){\n\t\t\tint t = in.nextInt(),n = in.nextInt();\n\t\t\tif(n+t==0)break;\n\t\t\tobj.doIt(t,n);\n\t\t}\n\t}\n\tclass AOJ2253{\n\t\tvoid doIt(int t,int n){\n\t\t\tint[][] map = new int[121][121];\n\t\t\tfor(int i=0;i<121;i++)Arrays.fill(map[i],-1);\n\t\t\tboolean syougai[][] = new boolean[121][121];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint gx = in.nextInt()+60;\n\t\t\t\tint gy = in.nextInt()+60;\n\t\t\t\tsyougai[gy][gx] = true;\n\t\t\t}\n\t\t\tint sx = in.nextInt()+60,sy = in.nextInt()+60;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tint ax[] = {1,0,1,-1,0,-1};\n\t\t\tint ay[] = {0,1,1,0,-1,-1};\n\t\t\tq.add(new State(sx, sy, 0));\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(map[now.y][now.x]>0)continue;\n\t\t\t\tmap[now.y][now.x] = now.step;\n\t\t\t\tif(now.step == t)continue;\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tint nx = ax[i]+now.x;\n\t\t\t\t\tint ny = ay[i]+now.y;\n\t\t\t\t\tif(nx<0||nx>=121||ny<0||ny>=121){\n//\t\t\t\t\t\tSystem.out.println(\"*\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(syougai[ny][nx])continue;\n\t\t\t\t\tq.add(new State(nx, ny, now.step+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<121;i++)for(int s=0;s<121;s++)if(map[i][s]>=0)cnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tclass State{\n\t\t\tint x,y,step;\n\t\t\tpublic State(int x,int y,int step) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static final int[] dx = {0, 1, 1, 0, -1, -1};\n\tpublic static final int[] dy = {1, 1, 0, -1, -1, 0};\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint t = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(t==0 && n == 0) break;\n\t\t\tboolean[][] block = new boolean[200][200];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint x = in.nextInt()+100;\n\t\t\t\tint y = in.nextInt()+100;\n\t\t\t\tblock[y][x] = true;\n\t\t\t}\n\t\t\tint sx = in.nextInt()+100;\n\t\t\tint sy = in.nextInt()+100;\n\t\t\tboolean[][] used = new boolean[200][200];\n\t\t\tQueue<Pos> qu = new LinkedList<Pos>();\n\t\t\tqu.add(new Pos(sy, sx, 0));\n\t\t\tint count = 0;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.y][p.x]) continue;\n\t\t\t\tif(p.turn > t) continue;\n\t\t\t\tused[p.y][p.x] = true;\n\t\t\t\tcount++;\n\t\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\t\tif(block[ny][nx]) continue;\n\t\t\t\t\tqu.add(new Pos(ny, nx, p.turn+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n\nclass Pos{\n\tint x, y;\n\tint turn;\n\tpublic Pos(int y, int x, int turn){\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t\tthis.turn = turn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 30;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && !wall[point.y][point.x - 1] && !visited[point.y][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && !wall[point.y][point.x + 1] && !visited[point.y][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y > 0 && !wall[point.y - 1][point.x] && !visited[point.y - 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y < (MAX + MAX) && !wall[point.y + 1][point.x] && !visited[point.y + 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && point.y > 0 && !wall[point.y - 1][point.x - 1] && !visited[point.y - 1][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && point.y < (MAX + MAX) && !wall[point.y + 1][point.x + 1] && !visited[point.y + 1][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if ((t | n) == 0)\n                break;\n            int[][] map = new int[61][61];\n            boolean[][] visited = new boolean[61][61];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                map[y + 30][x + 30] = -1;\n            }\n            Queue<Point> q = new LinkedList<Point>();\n            int sx = sc.nextInt() + 30;\n            int ans = 0;\n            int sy = sc.nextInt() + 30;\n            q.add(new Point(sx, sy));\n            visited[sy][sx] = true;\n            while (!q.isEmpty()) {\n                Point p = q.poll();\n                int x = p.x;\n                int y = p.y;\n                if (map[y][x] > t)\n                    continue;\n                ans++;\n                int dx[] = { 1, 1, 0, -1, -1, 0 };\n                int dy[] = { 0, 1, 1, 0, -1, -1 };\n                for (int i = 0; i < 6; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (nx >= 0 && ny >= 0 && ny < 61 && nx < 61\n                            && map[ny][nx] != -1) {\n                        if (visited[ny][nx]) {\n                            continue;\n                        }\n                        visited[ny][nx] = true;\n                        map[ny][nx] = map[y][x] + 1;\n                        q.add(new Point(nx, ny));\n                    }\n                }\n            }\n            System.out.println(ans);\n//            for (int i = 0; i <= 60; i++) {\n//                System.out.println(Arrays.toString(map[i]));\n//            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int MAX = 30;\n\tstatic final int[] H = new int[]{1, 1, 0, -1, -1, 0};\n\tstatic final int[] V = new int[]{1, 0, -1, -1, 0, 1};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tboolean[][][] obs = new boolean[4][MAX * 2 + 1][MAX * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tint[] q;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tq = quadrant(x, y);\n\t\t\t\tobs[q[0]][q[1]][q[2]] = true;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tint[] sq;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsq = quadrant(sx, sy);\n\n\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\tint count = 0;\n\n\t\t\tqueue.offer(new int[]{0, sq[0], sq[1], sq[2]});\n\t\t\tobs[sq[0]][sq[1]][sq[2]] = true;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] pq = queue.poll();\n\t\t\t\tint[] p = dequadrant(pq[1], pq[2], pq[3]);\n\t\t\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tint[] nq;\n\t\t\t\t\tnx = p[0] + H[i];\n\t\t\t\t\tny = p[1] + V[i];\n\t\t\t\t\tnq = quadrant(nx, ny);\n\t\t\t\t\tif (pq[0] < t && Math.abs(nx) <= MAX && ny <= MAX && !obs[nq[0]][nq[1]][nq[2]]) {\n\t\t\t\t\t\tqueue.offer(new int[]{pq[0] + 1, nq[0], nq[1], nq[2]});\n\t\t\t\t\t\tobs[nq[0]][nq[1]][nq[2]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t}//end main\n\n\t//quadrant I:    x >= 0, y >= 0\n\t//quadrant II:   x <  0, y >= 0\n\t//quadrant III:  x <  0, y <  0\n\t//quadrant IV:   x >= 0, y <  0\n\tstatic int[] quadrant(int x, int y) {\n\t\tint o = 0;\n\t\tif (0 <= x && 0 <= y) {\n\t\t\to = 0;\n\t\t} else if (x < 0 && 0 <= y) {\n\t\t\to = 1;\n\t\t} else if (x < 0 && y < 0) {\n\t\t\to = 2;\n\t\t} else {\n\t\t\to = 3;\n\t\t}\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn new int[]{o, x, y};\n\t}\n\n\tstatic int[] dequadrant(int o, int x, int y) {\n\t\tif (o == 1) {\n\t\t\tx = -x;\n\t\t} else if (o == 2) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t} else if (o == 3) {\n\t\t\ty = -y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tclass Point {\n\t\tint x, y;\n\t\tint o, ox, oy;\n\n\t\tPoint(int x, int y) {\n\t\t\tif (0 <= x && 0 <= y) {\n\t\t\t\to = 0;\n\t\t\t} else if (x < 0 && 0 <= y) {\n\t\t\t\to = 1;\n\t\t\t} else if (x < 0 && y < 0) {\n\t\t\t\to = 2;\n\t\t\t} else {\n\t\t\t\to = 3;\n\t\t\t}\n\t\t\tox = Math.abs(x);\n\t\t\toy = Math.abs(y);\n\t\t}\n\n\t\tPoint(int o, int ox, int oy) {\n\t\t\tif (o == 1) {\n\t\t\t\tx = -x;\n\t\t\t} else if (o == 2) {\n\t\t\t\tx = -x;\n\t\t\t\ty = -y;\n\t\t\t} else if (o == 3) {\n\t\t\t\ty = -y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int BLOCK = 100;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[61][61];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + 30;\n\t\t\t\tint y = in.nextInt() + 30;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tSystem.out.println(setMove(map, in.nextInt() + 30,\n\t\t\t\t\tin.nextInt() + 30, life));\n\t\t\t// showMap(map);\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static void showMap(int[][] map) {\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < 60 - sp; i++) {\n\t\t\t\tSystem.out.print(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tSystem.out.format(\"[%2d]\", i);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(x + \":\" + y + \"\\n\" + showMap(map));\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int MAX = 30;\n\tstatic final int[] H = new int[]{1, 1, 0, -1, -1, 0};\n\tstatic final int[] V = new int[]{1, 0, -1, -1, 0, 1};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tboolean[][][] obs = new boolean[4][MAX * 3][MAX * 3];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tint[] q;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tq = quadrant(x, y);\n\t\t\t\tobs[q[0]][q[1]][q[2]] = true;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tint[] sq;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsq = quadrant(sx, sy);\n\n\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\tint count = 0;\n\n\t\t\tqueue.offer(new int[]{0, sq[0], sq[1], sq[2]});\n\t\t\tobs[sq[0]][sq[1]][sq[2]] = true;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] pq = queue.poll();\n\t\t\t\tint[] p = dequadrant(pq[1], pq[2], pq[3]);\n\t\t\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tint[] nq;\n\t\t\t\t\tnx = p[0] + H[i];\n\t\t\t\t\tny = p[1] + V[i];\n\t\t\t\t\tnq = quadrant(nx, ny);\n\t\t\t\t\tif (pq[0] < t && !obs[nq[0]][nq[1]][nq[2]]) {\n\t\t\t\t\t\tqueue.offer(new int[]{pq[0] + 1, nq[0], nq[1], nq[2]});\n\t\t\t\t\t\tobs[nq[0]][nq[1]][nq[2]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t}//end main\n\n\t//quadrant I:    x >= 0, y >= 0\n\t//quadrant II:   x <  0, y >= 0\n\t//quadrant III:  x <  0, y <  0\n\t//quadrant IV:   x >= 0, y <  0\n\tstatic int[] quadrant(int x, int y) {\n\t\tint o = 0;\n\t\tif (0 <= x && 0 <= y) {\n\t\t\to = 0;\n\t\t} else if (x < 0 && 0 <= y) {\n\t\t\to = 1;\n\t\t} else if (x < 0 && y < 0) {\n\t\t\to = 2;\n\t\t} else {\n\t\t\to = 3;\n\t\t}\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn new int[]{o, x, y};\n\t}\n\n\tstatic int[] dequadrant(int o, int x, int y) {\n\t\tif (o == 1) {\n\t\t\tx = -x;\n\t\t} else if (o == 2) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t} else if (o == 3) {\n\t\t\ty = -y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tclass Point {\n\t\tint x, y;\n\t\tint o, ox, oy;\n\n\t\tPoint(int x, int y) {\n\t\t\tif (0 <= x && 0 <= y) {\n\t\t\t\to = 0;\n\t\t\t} else if (x < 0 && 0 <= y) {\n\t\t\t\to = 1;\n\t\t\t} else if (x < 0 && y < 0) {\n\t\t\t\to = 2;\n\t\t\t} else {\n\t\t\t\to = 3;\n\t\t\t}\n\t\t\tox = Math.abs(x);\n\t\t\toy = Math.abs(y);\n\t\t}\n\n\t\tPoint(int o, int ox, int oy) {\n\t\t\tif (o == 1) {\n\t\t\t\tx = -x;\n\t\t\t} else if (o == 2) {\n\t\t\t\tx = -x;\n\t\t\t\ty = -y;\n\t\t\t} else if (o == 3) {\n\t\t\t\ty = -y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point(){\n\n\t\t}\n\t\tpublic Point(int x,int y){\n\t\t\tthis.x=Math.max(Math.min(x,30),-30);\n\t\t\tthis.y=Math.max(Math.min(y,30),-30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode(){\n\t\t\treturn x+37*y;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\",\"+y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic{\n\t\tdir=new Point[]{\n\t\t\tnew Point(1,0),\n\t\t\tnew Point(1,1),\n\t\t\tnew Point(0,1),\n\t\t\tnew Point(-1,0),\n\t\t\tnew Point(-1,-1),\n\t\t\tnew Point(0,-1)};\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n//\tvoid move(Point p,int turn){\n//\t\tif((pmap.get(p) ==null || pmap.get(p)>turn) && turn <=t){\n//\t\t\tfor(int i=0;i<6;i++){\n//\t\t\t\tPoint _p=new Point(p.x+dir[i].x,p.y+dir[i].y);\n//\t\t\t\tmove(_p,turn+1);\n//\t\t\t}\n//\t\t\tpmap.put(p,turn);\n//\t\t}\n//\t}\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap=new HashMap<Point, Integer>();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint p=new Point();\n\t\t\t\tp.x=sc.nextInt();\n\t\t\t\tp.y=sc.nextInt();\n\t\t\t\tpmap.put(p,-2);\n\t\t\t}\n\t\t\tPoint zero=new Point();\n\t\t\tzero.x=sc.nextInt();\n\t\t\tzero.y=sc.nextInt();\n\t\t\t//move(zero,0);\n\t\t\tcount=0;\n\t\t\tif(pmap.size()>0){\n\t\t\tfor(Entry<Point, Integer> p : pmap.entrySet()){\n\t\t\t\tif(p.getValue()>=0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n    static Deque<Integer> nowX = new ArrayDeque<Integer>();\n    static Deque<Integer> nowY = new ArrayDeque<Integer>();\n    static Scanner scan = new Scanner(System.in);\n    static int ans;\n\n    public static void main(String[] args) {\n        while (scan.hasNext()) {\n            boolean[][] field = new boolean[101][101];\n            int turn = scan.nextInt();\n            int n = scan.nextInt();\n            if (turn == 0) {\n                break;\n            }\n            init(field, n);\n            for (int i = 0; i < turn; i++) {\n                bfs(field);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static void init(boolean field[][], int n) {\n        while (nowX.peek() != null) {\n            nowX.remove();\n            nowY.remove();\n        }\n        for (int i = 0; i < 101; i++) {\n            for (int j = 0; j < 101; j++) {\n                field[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x1 = scan.nextInt() + 50;\n            int y1 = scan.nextInt() + 50;\n            field[x1][y1] = true;\n        }\n        int x = scan.nextInt() + 50;\n        int y = scan.nextInt() + 50;\n        nowX.add(x);\n        nowY.add(y);\n        ans = 1;\n        field[x][y] = true;\n    }\n\n    static void bfs(boolean field[][]) {\n        Deque<Integer> nextX = new ArrayDeque<Integer>();\n        Deque<Integer> nextY = new ArrayDeque<Integer>();\n        int[] dx = {0, 1, 1, 0, -1, -1};\n        int[] dy = {1, 1, 0, -1, -1, 0};\n        while (nowX.peek() != null) {\n            int x = nowX.remove();\n            int y = nowY.remove();\n            for (int i = 0; i < 6; i++) {\n                if (check(x+dx[i]) && check(y+dy[i]) && \n                        !field[x+dx[i]][y+dy[i]]) {\n                    ans++;\n                    field[x+dx[i]][y+dy[i]] = true;\n                    //System.out.println(x+dx[i]);\n                    //System.out.println(y+dy[i]);\n                    nextX.add(x+dx[i]);\n                    nextY.add(y+dy[i]);\n                }\n            }\n        }\n        nowX = nextX;\n        nowY = nextY;\n    }\n\n    static boolean check(int a) {\n        if (0 <= a && a <= 100) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n    static Deque<Integer> nowX = new ArrayDeque<Integer>();\n    static Deque<Integer> nowY = new ArrayDeque<Integer>();\n    static Scanner scan = new Scanner(System.in);\n    static int ans;\n\n    public static void main(String[] args) {\n        while (scan.hasNext()) {\n            boolean[][] field = new boolean[61][61];\n            int turn = scan.nextInt();\n            int n = scan.nextInt();\n            if (turn == 0) {\n                break;\n            }\n            init(field, n);\n            for (int i = 0; i < turn; i++) {\n                bfs(field);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static void init(boolean field[][], int n) {\n        while (nowX.peek() != null) {\n            nowX.remove();\n            nowY.remove();\n        }\n        for (int i = 0; i < 61; i++) {\n            for (int j = 0; j < 61; j++) {\n                field[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x1 = scan.nextInt() + 30;\n            int y1 = scan.nextInt() + 30;\n            field[x1][y1] = true;\n        }\n        int x = scan.nextInt() + 30;\n        int y = scan.nextInt() + 30;\n        nowX.add(x);\n        nowY.add(y);\n        ans = 1;\n        field[x][y] = true;\n    }\n\n    static void bfs(boolean field[][]) {\n        Deque<Integer> nextX = new ArrayDeque<Integer>();\n        Deque<Integer> nextY = new ArrayDeque<Integer>();\n        int[] dx = {0, 1, 1, 0, -1, -1};\n        int[] dy = {1, 1, 0, -1, -1, 0};\n        while (nowX.peek() != null) {\n            int x = nowX.remove();\n            int y = nowY.remove();\n            for (int i = 0; i < 6; i++) {\n                if (check(x+dx[i]) && check(y+dy[i]) && \n                        !field[x+dx[i]][y+dy[i]]) {\n                    ans++;\n                    field[x+dx[i]][y+dy[i]] = true;\n                    //System.out.println(x+dx[i]);\n                    //System.out.println(y+dy[i]);\n                    nextX.add(x+dx[i]);\n                    nextY.add(y+dy[i]);\n                }\n            }\n        }\n        nowX = nextX;\n        nowY = nextY;\n    }\n\n    static boolean check(int a) {\n        if (0 <= a && a <= 60) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while(true) {\n            int t = scanner.nextInt();\n            int n = scanner.nextInt();\n            if(t==0 && n==0){\n                break;\n            }\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = scanner.nextInt();\n                y[i] = scanner.nextInt();\n            }\n            int startX = scanner.nextInt();\n            int startY = scanner.nextInt();\n            int count = t * (t + 1) * 3 + 1;\n            boolean[][] wall = new boolean[2*t+1][2*t+1];\n            for (int i = 0; i < n; i++) {\n                x[i] -= startX;\n                y[i] -= startY;\n                if (x[i] < -t || y[i] < -t || x[i] > t || y[i] > t) {\n                    continue;\n                }\n                if (x[i] < 0 && y[i] > 0 || x[i] > 0 && y[i] < 0) {\n                    if (Math.abs(x[i]) + Math.abs(y[i]) > t) {\n                        continue;\n                    }\n                }\n                wall[x[i] + t][y[i] + t] = true;\n            }\n\n            int [][] tmp = new int[2*t+1][2*t+1];\n            boolean [][] tmpB = new boolean[2*t+1][2*t+1];\n            for(int i=0; i<2*t+1; i++){\n                for(int j=0; j<2*t+1; j++){\n                    if (i < t && j > t || i > t && j < t) {\n                        if (Math.abs(i-t) + Math.abs(j-t) > t) {\n                            continue;\n                        }\n                    }\n                    if(!hasRoot(i - t, j - t, wall, t, t, tmp, tmpB)){\n                        //System.out.println(i+\",\" + j);\n                        count--;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    private static boolean hasRoot(int x, int y, boolean[][] wall, int t, int origT, int[][] tmp, boolean[][] tmpB){\n        if(x == 0 && y == 0) return true;\n        if(Math.abs(x) > origT || Math.abs(y) > origT || wall[x + origT][y + origT]){\n            return false;\n        }\n\n        if(t == 0){\n            return false;\n        }\n        if(tmp[x + origT][y + origT] > 0 && tmp[x + origT][y + origT] <= t && tmpB[x+origT][y+origT]) return true;\n        if(tmp[x + origT][y + origT] > 0 && tmp[x + origT][y + origT] >= t && !tmpB[x+origT][y+origT]) return false;\n        tmp[x+origT][y+origT] = t;\n        tmpB[x+origT][y+origT] = hasRoot(x + 1, y    , wall, t-1, origT, tmp, tmpB) ||\n                hasRoot(x    , y + 1, wall, t-1, origT, tmp, tmpB) ||\n                hasRoot(x + 1, y + 1, wall, t-1, origT, tmp, tmpB) ||\n                hasRoot(x - 1, y    , wall, t-1, origT, tmp, tmpB) ||\n                hasRoot(x    , y - 1, wall, t-1, origT, tmp, tmpB) ||\n                hasRoot(x - 1, y - 1, wall, t-1, origT, tmp, tmpB);\n        return tmpB[x+origT][y+origT];\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Brave Force Story\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\npublic class Main {\n\n\tstatic final int OFFSET = 30;\n\tstatic final int OBSTACLE = -1;\n\tstatic final int[] X = {0, 1, 1, 0, -1, -1};\n\tstatic final int[] Y = {1, 1, 0, -1, -1, 0};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tint[][] map = new int[OFFSET * 2 + 1][OFFSET * 2 + 1];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tmap[x + OFFSET][y + OFFSET] = OBSTACLE;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsx += OFFSET;\n\t\t\tsy += OFFSET;\n\n\t\t\tint count = 0;\n\t\t\tDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\t\tqueue.offer(new int[]{sx, sy, 0});\n\t\t\tmap[sx][sy] = OBSTACLE;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] hex = queue.poll();\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = hex[0] + X[i];\n\t\t\t\t\tny = hex[1] + Y[i];\n\t\t\t\t\tif (0 <= nx && nx <= 60 && 0 <= ny && ny <= 60 && hex[2] < t && map[nx][ny] != OBSTACLE) {\n\t\t\t\t\t\tqueue.offer(new int[]{nx, ny, hex[2] + 1});\n\t\t\t\t\t\tmap[nx][ny] = OBSTACLE;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t} // end while\n\t} // end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n    static Deque<Integer> nowX = new ArrayDeque<Integer>();\n    static Deque<Integer> nowY = new ArrayDeque<Integer>();\n    static Scanner scan = new Scanner(System.in);\n    static int ans;\n\n    public static void main(String[] args) {\n        while (scan.hasNext()) {\n            boolean[][] field = new boolean[301][301];\n            int turn = scan.nextInt();\n            int n = scan.nextInt();\n            if (turn == 0) {\n                break;\n            }\n            init(field, n);\n            for (int i = 0; i < turn; i++) {\n                bfs(field);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static void init(boolean field[][], int n) {\n        while (nowX.peek() != null) {\n            nowX.remove();\n            nowY.remove();\n        }\n        for (int i = 0; i < 301; i++) {\n            for (int j = 0; j < 301; j++) {\n                field[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x1 = scan.nextInt() + 150;\n            int y1 = scan.nextInt() + 150;\n            field[x1][y1] = true;\n        }\n        int x = scan.nextInt() + 150;\n        int y = scan.nextInt() + 150;\n        nowX.add(x);\n        nowY.add(y);\n        ans = 1;\n        field[x][y] = true;\n    }\n\n    static void bfs(boolean field[][]) {\n        Deque<Integer> nextX = new ArrayDeque<Integer>();\n        Deque<Integer> nextY = new ArrayDeque<Integer>();\n        int[] dx = {0, 1, 1, 0, -1, -1};\n        int[] dy = {1, 1, 0, -1, -1, 0};\n        while (nowX.peek() != null) {\n            int x = nowX.remove();\n            int y = nowY.remove();\n            for (int i = 0; i < 6; i++) {\n                if (!field[x+dx[i]][y+dy[i]]) {\n                    ans++;\n                    field[x+dx[i]][y+dy[i]] = true;\n                    //System.out.println(x+dx[i]);\n                    //System.out.println(y+dy[i]);\n                    nextX.add(x+dx[i]);\n                    nextY.add(y+dy[i]);\n                }\n            }\n        }\n        nowX = nextX;\n        nowY = nextY;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\tfinal int N = 30;\n\tfinal int[][] ofs = {\n\t\t\t{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1,-1}, {0, -1}\n\t};\n\tboolean[][] visited;\n\tint[][] d;\n\t\n\tint bfs(int sx, int sy, int t){\n\t\tint c = 1;\n\t\tvisited[sy+N][sx+N] = true;\n\t\t\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tint[] ne = {sx, sy};\n\t\tq.offer(ne);\n\t\twhile(true){\n\t\t\tif(q.isEmpty()){ break; };\n\t\t\tne = q.poll();\n\t\t\tif(d[ne[1]+N][ne[0]+N] >= t){ continue; };\n\t\t\t\n\t\t\tfor(int i=0; i<ofs.length; ++i){\n\t\t\t\tfinal int[] e = {\n\t\t\t\t\t\tne[0] + ofs[i][0], ne[1] + ofs[i][1]\n\t\t\t\t};\n\t\t\t\tif(-N<=e[0] && e[0]<=N && -N<=e[1] && e[1]<=N){\n\t\t\t\t\tif(!visited[e[1]+N][e[0]+N]){\n\t\t\t\t\t\tvisited[e[1]+N][e[0]+N] = true;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tq.offer(e);\n\t\t\t\t\t\td[e[1]+N][e[0]+N] = d[ne[1]+N][ne[0]+N] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\t\n\t\n\t\n\tvoid io(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tvisited = new boolean[N*2+1][N*2+1];\t//filled false\n\t\t\td = new int[N*2+1][N*2+1];\t//filled 0\n\t\t\t\n\t\t\tfinal int t = sc.nextInt();  final int n = sc.nextInt();\n\t\t\tif(t==0 && n==0){ return; }\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tvisited[y+N][x+N] = true;\n\t\t\t}\n\t\t\tfinal int sx = sc.nextInt();  final int sy = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(bfs(sx, sy, t));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tstatic class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point() {\n\n\t\t}\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = Math.max(Math.min(x, 30), -30);\n\t\t\tthis.y = Math.max(Math.min(y, 30), -30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn x + 37 * y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic {\n\t\tdir = new Point[] { new Point(1, 0), new Point(1, 1), new Point(0, 1),\n\t\t\t\tnew Point(-1, 0), new Point(-1, -1), new Point(0, -1) };\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p, int turn) {\n\t\tif ((pmap.get(p) == null || pmap.get(p) > turn) && turn <= t) {\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tPoint _p = new Point();\n\t\t\t\t_p.x = p.x + dir[i].x;\n\t\t\t\t_p.y = p.y + dir[i].y;\n\t\t\t\tmove(_p, turn + 1);\n\t\t\t}\n\t\t\tpmap.put(p, turn);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap = new HashMap<Point, Integer>();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tPoint p = new Point();\n\t\t\t\tp.x = sc.nextInt();\n\t\t\t\tp.y = sc.nextInt();\n\t\t\t\tpmap.put(p, -2);\n\t\t\t}\n\t\t\tPoint zero = new Point();\n\t\t\tzero.x = sc.nextInt();\n\t\t\tzero.y = sc.nextInt();\n\t\t\tmove(zero, 0);\n\t\t\tcount = 0;\n\t\t\tif (pmap.size() > 0) {\n\t\t\t\tfor (Entry<Point, Integer> p : pmap.entrySet()) {\n\t\t\t\t\tif (p.getValue() >= 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n\n    Scanner kbd = new Scanner(System.in);\n    Queue<Field> que;\n    \n    int[][] visit;\n    int[][] none;\n    int went;\n    int n;\n    int t;\n    int turn;\n\n    void run(){\n\twhile(kbd.hasNext()){\n\t    t = kbd.nextInt(); // ターン数\n\t    n = kbd.nextInt(); // 障害物数\n\t    // System.out.println(t+\" \"+n);\n\t    turn = 0;     // 移動出来るマスの記録用\n\t    if(t==0) break;\t    \n\n\t    que = new LinkedList<Field>();\n\t    // 移動できるマスの座標\n\n\t    visit = new int[1000][2];\n\t    went = 0;\n\t    // 移動済のマスの座標\n\n\t    none = new int[n][2];\n\t    // 障害物のマスの座標\n\n\t    // スタート座標 兼 現在の座標\n\t    int x, y, i=0;\n\t    \n\t    // 障害物 マス保存\n\t    i=0;\n\t    while(i<n){\n\t\tx = kbd.nextInt();\n\t\ty = kbd.nextInt();\n\t\t\n\t\tnone[i][0] = x;\n\t\tnone[i][1] = y;\n\n\t\ti++;\n\t    }\n\n\t    // スタート座標 兼 現在の座標\n\t    x = kbd.nextInt();\n\t    y = kbd.nextInt();\n\t    visit[went][0] = x;\n\t    visit[went][1] = y;\n\t    went++;\n\n\t    //System.out.println(x+\" \"+y);\n\t    int cnt = 1;  // 到達可能なマスの数、1はスタート地点\n\t    turn = 1;\n\t    setField(x+1, y, turn);\n\t    setField(x+1, y+1, turn);\n\t    setField(x, y+1, turn);\n\n\t    setField(x-1, y, turn);\n\t    setField(x-1, y-1, turn);\n\t    setField(x, y-1, turn);\n\n\t    // 移動始めここから\n\t    while(!que.isEmpty()){\n\t\t// 移動可能なマスのうち一つに移動する\n\t\tField next = que.poll();\n\t\tx = next.getX();\n\t\ty = next.getY();\n\t\tturn = next.getT();\n\t\t// System.out.println(x+\" \"+y);\n\t\tboolean a = true;\n\t\ti=0;\n\t\twhile(i<went){\n\t\t    if(visit[i][0]==x && visit[i][1]==y) a = false;\n\t\t    i++;\n\t\t}\n\t\tif(a){\n\t\t    visit[went][0] = x;\n\t\t    visit[went][1] = y;\n\t\t    went++;\t\n\t\t    cnt++;\n\t\t    //System.out.println(\"*\"+went);\n\t\t}\n\t\t    // 現在のマスから、移動可能なものを探してaddする\n\t\tif(turn+1<=t){\n\t\t    setField(x+1, y, turn+1);\n\t\t    setField(x+1, y+1, turn+1);\n\t\t    setField(x, y+1, turn+1);\n\t\t    \n\t\t    setField(x-1, y, turn+1);\n\t\t    setField(x-1, y-1, turn+1);\n\t\t    setField(x, y-1, turn+1);\n\t\t}\n\t    }\n\t    System.out.println(cnt);\n\t}\n    }\n\n    void setField(int x, int y, int t){\n\tboolean a = true;\n\tint i=0;\n\t\n\twhile(i<went){\n\t    if(visit[i][0]==x && visit[i][1]==y) a = false;\n\t    i++;\n\t}\n\ti=0;\n\twhile(i<n){\n\t    if(none[i][0]==x && none[i][1]==y) a = false;\n\t    i++;\n\t}\n\t\n\tif(a){\n\t    que.add(new Field(x, y, t));\n\t    //System.out.println(x+\" \"+y+\" \"+t);\n\t}\n    }\n}\n\nclass Field{\n    int x;\n    int y;\n    int turn;\n    public Field(int xx, int yy, int tt){\n\tx = xx;\n\ty = yy;\n\tturn = tt;\n    }\n    public int getX(){ return x; }\n    public int getY(){ return y; }\n    public int getT(){ return turn; }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int BLOCK = 100;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[61][61];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + 30;\n\t\t\t\tint y = in.nextInt() + 30;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + 30;\n\t\t\t\ty = in.nextInt() + 30;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tnew RuntimeException(showMap(map) + x + \":\" + y);\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < 60 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n    int[][] map;\n    int x, y;\n    int t, n;\n    int count;\n    int z = 100;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    map = new int[200][200];\n\t    t = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(t!=0){\n\t\tint i=n;\n\t\twhile(i>0){\n\t\t    i--;\n\t\t    int a = sc.nextInt();\n\t\t    int b = sc.nextInt();\n\t\t    map[a+z][b+z] = -1;\n\t\t}\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tcount = 0;\n\t\tsolve(t, x, y);\n\t\tSystem.out.println(count);\n\t    }\n\t}\n    }\n\n    int[][] dir = { {0, 1}, {1, 1}, {1, 0}, \n\t\t    {0, -1}, {-1, -1}, {-1, 0} };\n\t\t    \n    void solve(int t, int x, int y){\n\tif(t<0 || map[x+z][y+z]==-1 || map[x+z][y+z]>60) return;\n\t// 現在地が到達済か？\n\tif(map[x+z][y+z]!=-1){\n\t    if(map[x+z][y+z]==0)\n\t\tcount++;\n\t    map[x+z][y+z]++;\n\t}\n\t// 移動する\n\tfor(int i=0; i<dir.length; i++){\n\t    move(t-1, x+dir[i][0], y+dir[i][1], dir[i][0], dir[i][1]);\n\t    solve(t-1, x+dir[i][0], y+dir[i][1]);\n\t}\n    }\n\n    void move(int t, int x, int y, int dx, int dy){\n\twhile(t>0 && map[x+z][y+z]!=-1){\n\t    t--;\n\t    if(map[x+z][y+z]!=-1){\n\t\tif(map[x+z][y+z]==0)\n\t\t    count++;\n\t\tmap[x+z][y+z]++;\n\t    }\n\t    x += dx;\n\t    y += dy;\n\t}\n    }\n}   "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tpublic static int[][] map;\n\tpublic static ArrayDeque<Data> que;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tque = new ArrayDeque<Data>();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(t == 0 && n == 0) break;\n\t\t\tmap = new int[70][70];\n\t\t\tfor(int i = 0; i < 70; i++) {\n\t\t\t\tfor(int j = 0; j < 70; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tmap[y+30][x+30] = 9999999;\n\t\t\t}\n\t\t\t\n\t\t\tint x = stdIn.nextInt();\n\t\t\tint y = stdIn.nextInt();\n\t\t\tque.add(new Data(x+30,y+30,t));\n\t\t\twhile(!que.isEmpty()) {\n\t\t\t\tData a = que.poll();\n\t\t\t\tif(a.x < 0 || a.y < 0 || a.x >= 70|| a.y >= 70) continue;\n\t\t\t\tif(map[a.y][a.x] == 9999999) continue;\n\t\t\t\tif(map[a.y][a.x] >= a.t) continue;\n\t\t\t\t\n\t\t\t\tmap[a.y][a.x] = a.t;\n\t\t\t\tif(a.t-1 == -1) continue;\n\t\t\t\tque.add(new Data(a.x+1,a.y+1,a.t-1));\n\t\t\t\tque.add(new Data(a.x+1,a.y,a.t-1));\n\t\t\t\tque.add(new Data(a.x,a.y+1,a.t-1));\n\t\t\t\tque.add(new Data(a.x,a.y-1,a.t-1));\n\t\t\t\tque.add(new Data(a.x-1,a.y,a.t-1));\n\t\t\t\tque.add(new Data(a.x-1,a.y-1,a.t-1));\n\t\t\t}\n\t\t\t\n\t\t\tint c = 0;\n\t\t\tfor(int i = 0; i < 70; i++) {\n\t\t\t\tfor(int j = 0; j < 70; j++) {\n\t\t\t\t\tif(map[i][j] != -1 && map[i][j] != 9999999) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}\n\nclass Data {\n\tint x;\n\tint y;\n\tint t;\n\tpublic Data(int a, int b, int c) {\n\t\tx = a;\n\t\ty = b;\n\t\tt = c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main\n{\n\n    private static final int[] dx = {0,1,1,0,-1,-1};\n    private static final int[] dy = {1,1,0,-1,-1,0};\n\n    private static class Pox implements Comparable<Pox>\n    {\n\tpublic Point p;\n\tpublic int cnt;\n\n\tPox()\n\t{\n\t    p = new Point(-1,-1);\n\t    cnt = 0;\n\t}\n\n\tPox(int x,int y,int c)\n\t{\n\t    p = new Point(x,y);\n\t    cnt = c;\n\t}\n\n\n\tpublic int compareTo(Pox a)\n\t{\n\t    return -1;\n\t}\n\n\n    }\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\twhile(true)\n\t    {\n\t\tString line;\n\t\tline = in.readLine();\n\t\tint t,n;\t\tt = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tn = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tif(t == 0 && n == 0)\n\t\t    break;\n\t\tHashMap<Point,Boolean> map = new HashMap<Point,Boolean>();\n\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint X,Y;\n\t\t\tline = in.readLine();\n\t\t\tX = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\t\tY = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\t\tmap.put(new Point(X,Y),true);\n\t\t    }\n\n\t\tint sx,sy;\n\t\tline = in.readLine();\n\t\tsx = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tsy = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tQueue<Pox> que = new PriorityQueue<Pox>();\n\t\tque.offer(new Pox(sx,sy,0));\n\t\tmap.put(new Point(sx,sy),false);\n\n\t\tint[][] used = new int[400][400];\n\n\t\tfor(int i=0;i<200;i++)\n\t\t    for(int j=0;j<200;j++)\n\t\t\tused[i][j] = 10000000;\n\t\tused[sy+100][sx+100] = 0;\n\n\t\tint counter = 1;\n\t\twhile(que.size() > 0)\n\t\t    {\n\t\t\tPox pox = que.poll();\n\n\t\t\tif(pox.cnt >= t)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t    {\n\t\t\t\tint nx = pox.p.x + dx[i],ny = pox.p.y + dy[i];\n\t\t\t\t//if(!(Math.abs(nx) <= 30 && Math.abs(ny) <= 30))\n\t\t\t\t//continue;\n\n\t\t\t\tif(map.containsKey(new Point(nx,ny)))\n\t\t\t\t    {\n\t\t\t\t\tif(map.get(new Point(nx,ny)))\n\t\t\t\t\t    continue;\n\t\t\t\t    }\n\t\t\t\n\t\t\t\tif(used[ny+100][nx+100] <= pox.cnt)\n\t\t\t\t    continue;\n\n\t\t\t\tused[ny+100][nx+100] = pox.cnt;\t\t        \n\t\t\t\tmap.put(new Point(nx,ny),false);\n\t\t\t\tque.offer(new Pox(nx,ny,pox.cnt+1));\n\t\t\t    }\n\n\t\t    }\n\t\tSystem.out.println(map.size()-n);\n\t    }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 2253 \"ブレイブ・フォース・ストーリー\" (ICPC模擬国内予選 2011 Problem B)\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if (t == 0) {\n                break;\n            }\n            \n            int[][] field = new int[61][61];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                field[y+30][x+30] = -1;\n            }\n            int sx = sc.nextInt() + 30;\n            int sy = sc.nextInt() + 30;\n            \n            int[] dx = {0, 1, 1, 0, -1, -1};\n            int[] dy = {1, 1, 0, -1, -1, 0};\n            Queue<Field> que = new LinkedList<Field>();\n            que.offer(new Field(sx, sy));\n            while (que.peek() != null) {\n                Field tmp = que.poll();\n                int tmpx = tmp.x;\n                int tmpy = tmp.y;\n                if (field[tmpy][tmpx] == t) {\n                    continue;\n                }\n                for (int i = 0; i < dx.length; i++) {\n                    int nx = tmpx + dx[i];\n                    int ny = tmpy + dy[i];\n                    if (0 <= ny && ny < field.length && 0 <= nx && nx < field[ny].length\n                        && field[ny][nx] == 0 && !(nx == sx && ny == sy)) {\n                        que.offer(new Field(nx, ny));\n                        field[ny][nx] = field[tmpy][tmpx] + 1;\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length; j++) {\n                    if (field[i][j] > 0) {\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count + 1);\n        }\n    }\n}\n\nclass Field {\n    int x;\n    int y;\n    Field(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0)break;\n\t\t\telse calc(t, n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int t, int n){\n\t\tint[][] map = new int[161][161];\n\t\tfor(int i = 0; i < n; i ++){\n\t\t\tint x = sc.nextInt() + 80;\n\t\t\tint y = sc.nextInt() + 80;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint x = sc.nextInt() + 80;\n\t\tint y = sc.nextInt() + 80;\n\t\t\n\t\tmap[x][y] = 1;\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{x, y});\n\t\t\n\t\twhile(!list.isEmpty()){\n\t\t\tx = list.get(0)[0];\n\t\t\ty = list.get(0)[1];\n\t\t\tlist.remove(0);\n\t\t\tif(map[x][y] < t + 1){\n\t\t\t\tif(x > 0 && map[x-1][y] == 0){\n\t\t\t\t\tmap[x-1][y] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x-1, y});\n\t\t\t\t}\n\t\t\t\tif(x < 160 && map[x+1][y] == 0){\n\t\t\t\t\tmap[x+1][y] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x+1, y});\n\t\t\t\t}\n\t\t\t\tif(y > 0 && map[x][y-1] == 0){\n\t\t\t\t\tmap[x][y-1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x, y-1});\n\t\t\t\t}\n\t\t\t\tif(y < 160 && map[x][y+1] == 0){\n\t\t\t\t\tmap[x][y+1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x, y+1});\n\t\t\t\t}\n\t\t\t\tif(x > 0 && y > 0 && map[x-1][y-1] == 0){\n\t\t\t\t\tmap[x-1][y-1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x-1, y-1});\n\t\t\t\t}\n\t\t\t\tif(x < 160 && y < 160 && map[x+1][y+1] == 0){\n\t\t\t\t\tmap[x+1][y+1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x+1, y+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 161; i++){\n\t\t\tfor(int j = 0; j < 161; j++){\n\t\t\t\tif(map[i][j] <= t+1 && map[i][j] > 0) sum++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [] vx = {0,1,1,0,-1,-1};\n\tint [] vy = {1,1,0,-1,-1,0};\n\t\n\tclass C {\n\t\tint x,y,s;\n\n\t\tpublic C(int x, int y,int s) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.s = s;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sub = 200;\n\t\twhile(true){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif( t == 0 && n == 0) break;\n\t\t\tLinkedList<C> open = new LinkedList<Main.C>();\n\t\t\t\n\t\t\tboolean [][] close = new boolean[sub* 2+1][sub * 2+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + sub;\n\t\t\t\tint y = sc.nextInt() + sub;\n\t\t\t\tclose[y][x] = true;\n\t\t\t}\n\t\t\tint sx = sc.nextInt() + sub;\n\t\t\tint sy = sc.nextInt() + sub;\n\t\t\tclose[sy][sx] = true;\n\t\t\topen.add(new C(sx, sy,0));\n\t\t\tint ans = 0;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(now.x + \" \" + now.y);\n\t\t\t\tans++;\n\t\t\t\tif(now.s == t){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(close[yy][xx]) continue;\n\t\t\t\t\t\n\t\t\t\t\topen.add(new C(xx,yy,now.s+1));\n\t\t\t\t\tclose[yy][xx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        int[] dx = {1,1,0,-1,-1,0};\n        int[] dy = {0,1,1,0,-1,-1};\n        while(true){\n        \tint t = sc.nextInt();\n        \tint n = sc.nextInt();\n        \tif(t==0 && n==0){\n        \t\tbreak;\n        \t}\n        \tboolean[][] judge = new boolean[100][100];\n        \tfor(int i=0;i<n;i++){\n        \t\tjudge[sc.nextInt()+50][sc.nextInt()+50] = true;\n        \t}\n        \tint x = sc.nextInt();\n        \tint y = sc.nextInt();\n        \tPoint start = new Point(x,y);\n        \tint count = 1;\n        \tArrayList<Point> list1 = new ArrayList<Point>();\n        \tArrayList<Point> list2 = new ArrayList<Point>();\n        \tlist1.add(start);\n        \tjudge[start.x+50][start.y+50] = true;\n        \tfor(int i=0;i<t;i++){\n        \t\twhile(!list1.isEmpty()){\n        \t\t\tPoint point = list1.get(0);\n        \t\t\tlist1.remove(0);\n        \t\t\tfor(int j=0;j<6;j++){\n        \t\t\t\tif(!judge[point.x+50+dx[j]][point.y+50+dy[j]]){\n        \t\t\t\t\tcount++;\n        \t\t\t\t\tPoint p = new Point(point.x+dx[j],point.y+dy[j]);\n        \t\t\t\t\tlist2.add(p);\n        \t\t\t\t\tjudge[point.x+50+dx[j]][point.y+50+dy[j]] = true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tlist1.clear();\n        \t\tfor(int l=0;l<list2.size();l++){\n        \t\t\tlist1.add(list2.get(l));\n        \t\t}\n        \t\tlist2.clear();\n        \t}\n        \tout.println(count);\n        \tout.flush();\n        \tlist1.clear();\n        \tlist2.clear();\n        }\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\twhile(true){\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tboolean[][] map = new boolean[100][100];\n\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+50][y+50] = false;\n\t\t\t}\n\t\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\t\tint now_x = Integer.parseInt(stdIn.next());\n\t\t\tint now_y = Integer.parseInt(stdIn.next());\n\t\t\tPoint now = new Point(now_x+50,now_y+50);\n\t\t\tmap[now_x+50][now_y+50] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tPoint next = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[next.x+d[j][0]][next.y+d[j][1]]){\n\t\t\t\t\t\t\tSystem.out.println((next.x+d[j][0])+\" \"+(next.y+d[j][1]));\n\t\t\t\t\t\t\tmap[next.x+d[j][0]][next.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(next.x+d[j][0],next.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 30;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = point.x + move[0];\n\t\t\t\t\tfinal int ny = point.y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= (MAX + 1 + MAX) || ny < 0 || ny >= (MAX + 1 + MAX)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tqueue.add(new Point(point.old + 1, nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n\n    Scanner kbd = new Scanner(System.in);\n    Queue<Field> que;\n    HashSet<String> visit;\n    HashSet<String> none;\n    //int[][] visit;\n    //int[][] none;\n    int went;\n    int n;\n    int t;\n    int turn;\n    String now;\n\n    void run(){\n\twhile(kbd.hasNext()){\n\t    t = kbd.nextInt(); // ターン数\n\t    n = kbd.nextInt(); // 障害物数\n\t    // System.out.println(t+\" \"+n);\n\t    turn = 0;     // 移動出来るマスの記録用\n\t    if(t==0) break;\t    \n\n\t    que = new LinkedList<Field>();\n\t    // 移動できるマスの座標\n\n\t    visit = new HashSet<String>();\n\t    //visit = new int[1000][2];\n\t    went = 0;\n\t    // 移動済のマスの座標\n\n\t    none = new HashSet<String>();\n\t    //none = new int[n][2];\n\t    // 障害物のマスの座標\n\n\t    // スタート座標 兼 現在の座標\n\t    int x, y, i=0;\n\t    \n\t    // 障害物 マス保存\n\t    i=0;\n\t    while(i<n){\n\t\tx = kbd.nextInt();\n\t\ty = kbd.nextInt();\n\t\tnow = x+\" \"+y;\n\t\t/*\n\t\tnone[i][0] = x;\n\t\tnone[i][1] = y;\n\t\t*/\n\t\tnone.add(now);\n\t\ti++;\n\t    }\n\n\t    // スタート座標 兼 現在の座標\n\t    x = kbd.nextInt();\n\t    y = kbd.nextInt();\n\t    now = x+\" \"+y;\n\t    visit.add(now);\n\t    /*\n\t    visit[went][0] = x;\n\t    visit[went][1] = y;\n\t    went++;\n\t    */\n\n\t    //System.out.println(x+\" \"+y);\n\t    int cnt = 1;  // 到達可能なマスの数、1はスタート地点\n\t    turn = 1;\n\t    setField(x+1, y, turn);\n\t    setField(x+1, y+1, turn);\n\t    setField(x, y+1, turn);\n\n\t    setField(x-1, y, turn);\n\t    setField(x-1, y-1, turn);\n\t    setField(x, y-1, turn);\n\n\t    // 移動始めここから\n\t    while(!que.isEmpty()){\n\t\t// 移動可能なマスのうち一つに移動する\n\t\tField next = que.poll();\n\t\tx = next.getX();\n\t\ty = next.getY();\n\t\tnow = x+\" \"+y;\n\t\tturn = next.getT();\n\t\t// System.out.println(x+\" \"+y);\n\t\tboolean a = true;\n\t\t/*\n\t\ti=0;\n\t\twhile(i<went){\n\t\t    if(visit[i][0]==x && visit[i][1]==y) a = false;\n\t\t    i++;\n\t\t}\n\t\t*/\n\t\tif(!visit.contains(now)){\n\t\t    /*\n\t\t    visit[went][0] = x;\n\t\t    visit[went][1] = y;\n\t\t    went++;\n\t\t    */\n\t\t    now = x+\" \"+y;\n\t\t    visit.add(now);\t\n\t\t    cnt++;\n\t\t    //System.out.println(\"*\"+went);\n\t\t}\n\t\t    // 現在のマスから、移動可能なものを探してaddする\n\t\tif(turn+1<=t){\n\t\t    setField(x+1, y, turn+1);\n\t\t    setField(x+1, y+1, turn+1);\n\t\t    setField(x, y+1, turn+1);\n\t\t    \n\t\t    setField(x-1, y, turn+1);\n\t\t    setField(x-1, y-1, turn+1);\n\t\t    setField(x, y-1, turn+1);\n\t\t}\n\t    }\n\t    System.out.println(cnt);\n\t}\n    }\n\n    void setField(int x, int y, int t){\n\tboolean a = true;\n\tint i=0;\n\t/*\n\twhile(i<went){\n\t    if(visit[i][0]==x && visit[i][1]==y) a = false;\n\t    i++;\n\t}\n\t*/\n\tnow = x+\" \"+y;\n\tif(visit.contains(now)) a = false;\n\t/*\n\ti=0;\n\twhile(i<n){\n\t    if(none[i][0]==x && none[i][1]==y) a = false;\n\t    i++;\n\t}\n\t*/\n\tif(none.contains(now)) a = false;\n\tif(a){\n\t    que.add(new Field(x, y, t));\n\t    //System.out.println(x+\" \"+y+\" \"+t);\n\t}\n    }\n}\n\nclass Field{\n    int x;\n    int y;\n    int turn;\n    public Field(int xx, int yy){\n\tx = xx;\n\ty = yy;\n\tturn = 500;\n    }\n\n    public Field(int xx, int yy, int tt){\n\tx = xx;\n\ty = yy;\n\tturn = tt;\n    }\n    public int getX(){ return x; }\n    public int getY(){ return y; }\n    public int getT(){ return turn; }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if ((t | n) == 0)\n                break;\n            int[][] map = new int[61][61];\n            boolean[][] visited = new boolean[61][61];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                map[y + 30][x + 30] = -1;\n            }\n            Queue<Point> q = new LinkedList<Point>();\n            int sx = sc.nextInt() + 30;\n            int ans = 0;\n            int sy = sc.nextInt() + 30;\n            q.add(new Point(sx, sy));\n            visited[sy][sx] = true;\n            while (!q.isEmpty()) {\n                Point p = q.poll();\n                int x = p.x;\n                int y = p.y;\n                if (map[y][x] > t)\n                    continue;\n                ans++;\n                int dx[] = { 0, 1, 1, 0, -1, -1 };\n                int dy[] = { 1, 1, 0, -1, -1, 0 };\n                for (int i = 0; i < 6; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (nx >= 0 && ny >= 0 && ny < 61 && nx < 61\n                            && map[ny][nx] != -1) {\n                        if (visited[ny][nx]) {\n                            continue;\n                        }\n                        visited[ny][nx] = true;\n                        map[ny][nx] = map[y][x] + 1;\n                        q.add(new Point(nx, ny));\n                    }\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int MAP_SIZE = 60;\n\tprivate static final int BLOCK = 99;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(x + \":\" + y + \"\\n\" + showMap(map));\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[][] map;\n    /*\n      [x][y]\n      0 : 未到達\n      1 : 到達済\n      -1 : 障害物があり、通れない\n    */\n    int x, y;\n    int t, n;\n    int count;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    map = new int[100][100];\n\t    t = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(t!=0){\n\t\tint i=n;\n\t\twhile(i>0){\n\t\t    i--;\n\t\t    map[sc.nextInt()+30][sc.nextInt()+30] = -1;\n\t\t}\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tcount = 0;\n\t\tsolve(t, x, y);\n\t\tSystem.out.println(count);\n\t    }\n\t}\n    }\n\n    int[][] dir = { {0, 1}, {1, 1}, {1, 0}, \n\t\t    {0, -1}, {-1, -1}, {-1, 0} };\n\t\t    \n    void solve(int t, int x, int y){\n\tif(t<0 || map[x+30][y+30]==-1) return;\n\t// 現在地が到達済か？\n\tif(map[x+30][y+30]==0){\n\t    map[x+30][y+30] = 1;\n\t    count++;\n\t}\n\t// 移動する\n\tfor(int i=0; i<dir.length; i++){\n\t    solve(t-1, x+dir[i][0], y+dir[i][1]);\n\t}\n    }\n}   "
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tstatic class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point() {\n\n\t\t}\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = Math.max(Math.min(x, 30), -30);\n\t\t\tthis.y = Math.max(Math.min(y, 30), -30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn x + 37 * y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic {\n\t\tdir = new Point[] { new Point(1, 0), new Point(1, 1), new Point(0, 1),\n\t\t\t\tnew Point(-1, 0), new Point(-1, -1), new Point(0, -1) };\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p, int turn) {\n\t\tif ((pmap.get(p) == null || pmap.get(p) > turn) && turn <= t) {\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tPoint _p = new Point();\n\t\t\t\t_p.x = p.x + dir[i].x;\n\t\t\t\t_p.y = p.y + dir[i].y;\n\t\t\t\tmove(_p, turn + 1);\n\t\t\t}\n\t\t\tpmap.put(p, turn);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap = new HashMap<Point, Integer>();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tPoint p = new Point();\n\t\t\t\tp.x = sc.nextInt();\n\t\t\t\tp.y = sc.nextInt();\n\t\t\t\tpmap.put(p, -2);\n\t\t\t}\n\t\t\tPoint zero = new Point();\n\t\t\tzero.x = sc.nextInt();\n\t\t\tzero.y = sc.nextInt();\n\t\t\tmove(zero, 0);\n\t\t\tcount = 0;\n\t\t\tif (pmap.size() > 0) {\n\t\t\t\tfor (Entry<Point, Integer> p : pmap.entrySet()) {\n\t\t\t\t\tif (p.getValue() >= 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[121][121];\n  dist=new int[121][121];\n  for(int i=0;i<=120;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=120;i++) for(int j=0;j<=120;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=60,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET];\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by kazuki on 2014/07/08.\n */\npublic class Main {\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n            dataNum++;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num,dataNum=0;\n    static int[][] map = new int[101][101];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n//        if (x < -30 || 30 < x || y < -30 || 30 < y) return;\n        if (map[x + 50][y + 50] == -2) return;\n        if (map[x + 50][y + 50] == -1) {\n            num++;\n            map[x + 50][y + 50] = -2;\n        }\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 101; i++) {\n                for (int j = 0; j < 101; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n            dataNum=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 50][y + 50] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nimport java.util.HashSet;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n\n    int turn = scan.nextInt();\n    int object = scan.nextInt();\n\n    while(!(turn==0&&object==0)) {\n      HashSet<Point> canMove = new HashSet<>();\n      HashSet<Point> nextMove = new HashSet<>();\n      HashSet<Point> objects = new HashSet<>();\n\n      for(int i = 0; i < object; i++) {\n        Point dummyP = new Point(scan.nextInt(),scan.nextInt());\n        objects.add(dummyP);\n      }\n\n      Point startP = new Point(scan.nextInt(),scan.nextInt());\n      canMove.add(startP);\n      nextMove.add(startP);\n\n      for(int i = 0; i < turn; i++) {\n        HashSet<Point> dummyMove = new HashSet<>();\n        for(Point _p : nextMove) {\n          Point[] parr = new Point[6];\n          parr[0] = new Point(_p.x+1,_p.y);\n          parr[1] = new Point(_p.x,_p.y+1);\n          parr[2] = new Point(_p.x+1,_p.y+1);\n          parr[3] = new Point(_p.x-1,_p.y);\n          parr[4] = new Point(_p.x,_p.y-1);\n          parr[5] = new Point(_p.x-1,_p.y-1);\n\n          for(Point _pa : parr) {\n            if(!canMove.contains(_pa)&&!objects.contains(_pa)) {\n              //System.out.println(_pa);\n              dummyMove.add(_pa);\n              canMove.add(_pa);\n            }\n          }\n        }\n        if(dummyMove.size()<=0) break;\n\n        nextMove = dummyMove;\n      }\n\n      System.out.println(canMove.size());\n\n      turn = scan.nextInt();\n      object = scan.nextInt();\n    }\n  }\n}\n\nclass Point{\n  int x,y;\n  Point(int _x, int _y) {\n    x = _x;\n    y = _y;\n  }\n\n  @Override\n  public String toString() {\n    return \"(\"+x+\",\"+y+\")\";\n  }\n\n  @Override\n  public int hashCode() {\n    return x*10000+y;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if(x==((Point)obj).x&&y==((Point)obj).y) return true;\n    return false;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int[] vvx={0,1,0,-1,-1,1}, vvy={-1,0,1,0,-1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ2253();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\t// ICPC Domestic2008 - C\t15:28-15:55\n\tvoid AOJ1155(){\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tif(str.equals(\".\"))\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int p=0; p<=2; p++){\n\t\t\t\tfor(int q=0; q<=2; q++){\n\t\t\t\t\tfor(int r=0; r<=2; r++){\n\t\t\t\t\t\tString s2=str.replaceAll(\"P\", Integer.toString(p)).replaceAll(\"Q\", Integer.toString(q)).replaceAll(\"R\", Integer.toString(r))+\"#\";\n\t\t\t\t\t\t//out.println(s2+\" \"+new parsed(s2).intValue());\n\t\t\t\t\t\tif(new parsed(s2).intValue()==2)\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.print(\"ANS=\");\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t// for AOJ1155\n\tpublic class parsed{\n\t\tString line;\n\t\tint pos=0,ans=0;\n\t\tparsed(String line){\n\t\t\tthis.line=line;\n\t\t\tans=term();\n\t\t}\n\t\tprivate int term(){\n\t\t\tint res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tint old=res;\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res==2 || old==2)\tres=2;\n\t\t\t\t\telse if(res==0 && old==0)\tres=0;\n\t\t\t\t\telse\tres=1;\n\t\t\t\t}else if(op=='*'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res==0 || old==0)\tres=0;\n\t\t\t\t\telse if(res==2 && old==2)\tres=2;\n\t\t\t\t\telse\tres=1;\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate int fact(){\n\t\t\tif(line.charAt(pos)=='-'){\n\t\t\t\tpos++;\n\t\t\t\tint temp=fact();\n\t\t\t\treturn temp==0?2:temp==2?0:temp;\n\t\t\t}\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tint r=(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\treturn r;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tint res=term();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpublic int intValue(){return ans;}\n\t}\n\t\n\t\n\t// AOJ2255 2011MOGI - D\n\tHashSet<Integer> ans=new HashSet<Integer>();\n\tArrayList<Integer> d,k;\tArrayList<Character> e;\n\tvoid D(){\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='#')\tbreak;\n\t\t\td=new ArrayList<Integer>();\n\t\t\tk=new ArrayList<Integer>();\n\t\t\te=new ArrayList<Character>();\n\t\t\tint p=0;\n\t\t\tfor(int i=0; i<c.length; i++){\n\t\t\t\tif(Character.isDigit(c[i])){\n\t\t\t\t\tint dd=c[i]-'0';\n\t\t\t\t\twhile(i+1<c.length){\n\t\t\t\t\t\tif(!Character.isDigit(c[i+1]))\tbreak;\n\t\t\t\t\t\tdd=dd*10+(c[++i]-'0');\n\t\t\t\t\t}\n\t\t\t\t\td.add(dd);\n\t\t\t\t}else if(c[i]=='(')\tp++;\n\t\t\t\telse if(c[i]==')')\tp--;\n\t\t\t\telse{\n\t\t\t\t\te.add(c[i]);\n\t\t\t\t\tk.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(d);\n\t\t\tout.println(e);\n\t\t\tout.println(k);\n\t\t\t\n\t\t\tout.println(DtoString(d,e,k));\n\t\t\tfor(int i=0; i<k.size(); i++)\tsolveD(k,new boolean[k.size()],i,k.size());\n\t\t\t\n\t\t\tout.println(ans.size());\n\t\t}\n\t}\n\tvoid solveD(ArrayList<Integer> k,boolean[] b,int idx,int n){\n\t\tif(n<=0){\n\t\t\tans.add(new parsed(DtoString(d,e,k)).intValue());\n\t\t}else{\n\t\t\t// バックトラック\n\t\t}\n\t}\n\tString DtoString(ArrayList<Integer> d,ArrayList<Character> e,ArrayList<Integer> k){\n\t\tStringBuilder ans=new StringBuilder();\n\t\tint kk=0;\n\t\tfor(int i=0; i<e.size(); i++){\n\t\t\tif(kk<k.get(i)){\n\t\t\t\tfor(int j=0; j<abs(kk-k.get(i)); j++)\tans.append((kk<k.get(i)?\"(\":\")\"));\n\t\t\t\tkk=k.get(i);\n\t\t\t}\n\t\t\tans.append(d.get(i));\n\t\t\tif(kk>k.get(i)){\n\t\t\t\tfor(int j=0; j<abs(kk-k.get(i)); j++)\tans.append((kk<k.get(i)?\"(\":\")\"));\n\t\t\t\tkk=k.get(i);\n\t\t\t}\n\t\t\tans.append(e.get(i));\n\t\t}\n\t\tans.append(d.get(d.size()-1));\n\t\twhile(--kk>=0)\tans.append(\")\");\n\t\treturn ans.toString();\n\t}\n\t\n\t// 2011MOGI - A 15:02-15:08\n\tvoid AOJ2252(){\n\t\tHashSet<Character> right=new HashSet<Character>();\n\t\tright.add('y');\tright.add('h');\tright.add('n');\tright.add('u');\tright.add('j');\tright.add('m');\n\t\tright.add('i');\tright.add('k');\tright.add('o');\tright.add('l');\tright.add('p');\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='#')\tbreak;\n\t\t\tboolean r=false;\n\t\t\tif(right.contains(c[0]))\tr=true;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<c.length; i++){\n\t\t\t\tif(right.contains(c[i])){\n\t\t\t\t\tans+=!r?1:0;\n\t\t\t\t\tr=true;\n\t\t\t\t}else{\n\t\t\t\t\tans+=r?1:0;\n\t\t\t\t\tr=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// 2012MOGI - A\t14:50-14:57\n\tvoid AOJ2399(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tboolean[][] b=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int j=0; j<m; j++)\tb[i][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tboolean[] ans=new boolean[N+1];\n\t\t\tArrays.fill(ans, true);\n\t\t\tint k=sc.nextInt();\n\t\t\tfor(int i=0; i<k; i++){\n\t\t\t\tint p=sc.nextInt();\n\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\tif(!b[j][p])\tans[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=-1;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tif(ans[i]){\n\t\t\t\t\tif(res<0)\tres=i;\n\t\t\t\t\telse{\n\t\t\t\t\t\tres=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\t\n\t// AOJ2253 2011MOGI - B\t(AOJ - RE)\n\tvoid AOJ2253(){\n\t\twhile(sc.hasNext()){\n\t\t\tint t=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\tif(t==0)\tbreak;\n\t\t\tfinal int BASE=100,MAX=(BASE*2)+50;\n\t\t\tboolean[][] close=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<n; i++)\tclose[sc.nextInt()+BASE][sc.nextInt()+BASE]=true;\n\t\t\tint sx=sc.nextInt()+BASE,sy=sc.nextInt()+BASE;\n\t\t\tLinkedList<ClassB> open=new LinkedList<ClassB>();\n\t\t\topen.add(new ClassB(sx,sy,0));\n\t\t\tclose[sx][sy]=true;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tClassB now=open.poll();\n\t\t\t\tans++;\n\t\t\t\tif(now.t>=t)\tcontinue;\n\t\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\t\tint xx=now.x+vvx[i],yy=now.y+vvy[i];\n\t\t\t\t\t//if(!Point.ok(xx, yy, MAX, MAX))\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new ClassB(xx,yy,now.t+1));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass ClassB{\n\t\tint x,y,t;\n\t\tClassB(int x,int y,int t){this.x=x; this.y=y; this.t=t;}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\tboolean[][] map = new boolean[100][100];\n\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\twhile(true){\n\t\t\tlist1.clear();\n\t\t\tlist2.clear();\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+50][y+50] = false;\n\t\t\t}\n\t\t\t\n\t\t\tint now_x = Integer.parseInt(stdIn.next());\n\t\t\tint now_y = Integer.parseInt(stdIn.next());\n\t\t\tPoint now = new Point(now_x+50,now_y+50);\n\t\t\tmap[now_x+50][now_y+50] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tPoint next = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[next.x+d[j][0]][next.y+d[j][1]]){\n\t\t\t\t\t\t\tSystem.out.println((next.x+d[j][0])+\" \"+(next.y+d[j][1]));\n\t\t\t\t\t\t\tmap[next.x+d[j][0]][next.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(next.x+d[j][0],next.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n /* for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }*/\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[][][] map = new int[2][61][61];\n\t\n\tint[] vx = {0, 1, -1, 1, -1, 0}, vy = {1, 1, 0, 0, -1, -1};\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint t = in.nextInt(), n = in.nextInt();\n\t\t\tif (t == 0) break;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tArrays.fill(map[0][i], 0);\n\t\t\t\tArrays.fill(map[1][i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt();\n\t\t\t\tmap[0][30+x][30+y] = map[1][30+x][30+y] = -1;\n\t\t\t}\n\t\t\tint startX = in.nextInt(), startY = in.nextInt();\n\t\t\t\n\t\t\tmap[0][30+startX][30+startY] = 1;\n\t\t\t\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 60; k++) {\n\t\t\t\t\t\tif (map[cur][j][k] == 1) {\n\t\t\t\t\t\t\tmap[cur^1][j][k] = 1;\n\t\t\t\t\t\t\tfor (int a = 0; a < vx.length; a++) {\n\t\t\t\t\t\t\t\tint nx = j + vx[a], ny = k + vy[a];\n\t\t\t\t\t\t\t\tif (isOk(nx, 61, ny, 61) && map[cur][nx][ny] != -1) {\n\t\t\t\t\t\t\t\t\tmap[cur^1][nx][ny] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur ^= 1;\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tif (map[cur][i][j] == 1) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tboolean isOk(int x, int M, int y, int N) {\n\t\treturn 0 <= x && x < M && 0 <= y && y < N && Math.abs(x-30) + Math.abs(y-30) <= 30;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        int[] dx = {1,1,0,-1,-1,0};\n        int[] dy = {0,1,1,0,-1,-1};\n        while(true){\n        \tint t = sc.nextInt();\n        \tint n = sc.nextInt();\n        \tif(t==0 && n==0){\n        \t\tbreak;\n        \t}\n        \tboolean[][] judge = new boolean[100][100];\n        \tfor(int i=0;i<n;i++){\n        \t\tjudge[sc.nextInt()+50][sc.nextInt()+50] = true;\n        \t}\n        \tint x = sc.nextInt();\n        \tint y = sc.nextInt();\n        \tPoint start = new Point(x,y);\n        \tint count = 1;\n        \tArrayList<Point> list1 = new ArrayList<Point>();\n        \tArrayList<Point> list2 = new ArrayList<Point>();\n        \tlist1.add(start);\n        \tjudge[start.x+50][start.y+50] = true;\n        \tfor(int i=0;i<t;i++){\n        \t\twhile(!list1.isEmpty()){\n        \t\t\tPoint point = list1.get(0);\n        \t\t\tlist1.remove(0);\n        \t\t\tfor(int j=0;j<6;j++){\n        \t\t\t\tif(!judge[point.x+50+dx[j]][point.y+50+dy[j]]){\n        \t\t\t\t\tcount++;\n        \t\t\t\t\tPoint p = new Point(point.x+dx[j],point.y+dy[j]);\n        \t\t\t\t\tlist2.add(p);\n        \t\t\t\t\tjudge[point.x+50+dx[j]][point.y+50+dy[j]] = true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tlist1.clear();\n        \t\tfor(int l=0;l<list2.size();l++){\n        \t\t\tlist1.add(list2.get(l));\n        \t\t}\n        \t\tlist2.clear();\n        \t}\n        \tout.println(count);\n        \tout.flush();\n        \tlist1.clear();\n        \tlist2.clear();\n        }\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\npublic class Main {\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n            dataNum++;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num,dataNum=0;\n    static int[][] map = new int[101][101];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n//        if (x < -30 || 30 < x || y < -30 || 30 < y) return;\n        if (map[x + 50][y + 50] == -2) return;\n        if (map[x + 50][y + 50] == -1) {\n            num++;\n            map[x + 50][y + 50] = -2;\n        }\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 101; i++) {\n                for (int j = 0; j < 101; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n            dataNum=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 50][y + 50] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        int[] dx = {1,1,0,-1,-1,0};\n        int[] dy = {0,1,1,0,-1,-1};\n        while(true){\n        \tint t = sc.nextInt();\n        \tint n = sc.nextInt();\n        \tif(t==0 && n==0){\n        \t\tbreak;\n        \t}\n        \tboolean[][] judge = new boolean[200][200];\n        \tfor(int i=0;i<n;i++){\n        \t\tjudge[sc.nextInt()+100][sc.nextInt()+100] = true;\n        \t}\n        \tint x = sc.nextInt();\n        \tint y = sc.nextInt();\n        \tPoint start = new Point(x,y);\n        \tint count = 1;\n        \tArrayList<Point> list1 = new ArrayList<Point>();\n        \tArrayList<Point> list2 = new ArrayList<Point>();\n        \tlist1.add(start);\n        \tjudge[start.x+100][start.y+100] = true;\n        \tfor(int i=0;i<t;i++){\n        \t\twhile(!list1.isEmpty()){\n        \t\t\tPoint point = list1.get(0);\n        \t\t\tlist1.remove(0);\n        \t\t\tfor(int j=0;j<6;j++){\n        \t\t\t\tif(!judge[point.x+100+dx[j]][point.y+100+dy[j]]){\n        \t\t\t\t\tcount++;\n        \t\t\t\t\tPoint p = new Point(point.x+dx[j],point.y+dy[j]);\n        \t\t\t\t\tlist2.add(p);\n        \t\t\t\t\tjudge[point.x+100+dx[j]][point.y+100+dy[j]] = true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tlist1.clear();\n        \t\tfor(int l=0;l<list2.size();l++){\n        \t\t\tlist1.add(list2.get(l));\n        \t\t}\n        \t\tlist2.clear();\n        \t}\n        \tout.println(count);\n        \tout.flush();\n        \tlist1.clear();\n        \tlist2.clear();\n        }\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n//\tstatic class Point {\n//\t\tint x;\n//\t\tint y;\n//\n//\t\tpublic Point() {\n//\t\t}\n//\n//\t\tpublic Point(int x, int y) {\n//\t\t\tthis.x = Math.max(Math.min(x, 30), -30);\n//\t\t\tthis.y = Math.max(Math.min(y, 30), -30);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic boolean equals(Object obj) {\n//\t\t\tif (obj instanceof Point) {\n//\t\t\t\tPoint p = (Point) obj;\n//\t\t\t\treturn x == p.x && y == p.y;\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t}\n//\n//\t\tpublic int hashCode() {\n//\t\t\treturn x + 37 * y;\n//\t\t}\n//\n//\t\tpublic String toString() {\n//\t\t\treturn x + \",\" + y;\n//\t\t}\n//\t}\n\n//\tHashMap<Point, Integer> pmap;\n//\n//\tstatic Point[] dir;\n//\tstatic {\n//\t\tdir = new Point[] { new Point(1, 0), new Point(1, 1), new Point(0, 1),\n//\t\t\t\tnew Point(-1, 0), new Point(-1, -1), new Point(0, -1) };\n//\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n//\tvoid move(Point p, int turn) {\n//\t\tif ((pmap.get(p) == null || pmap.get(p) > turn) && turn <= t) {\n//\t\t\tfor (int i = 0; i < 6; i++) {\n//\t\t\t\tPoint _p = new Point();\n//\t\t\t\t_p.x = p.x + dir[i].x;\n//\t\t\t\t_p.y = p.y + dir[i].y;\n//\t\t\t\tmove(_p, turn + 1);\n//\t\t\t}\n//\t\t\tpmap.put(p, turn);\n//\t\t}\n//\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n//\t\t\tn = 0;\n//\t\t\tpmap = new HashMap<Point, Integer>();\n//\t\t\tt = sc.nextInt();\n//\t\t\tn = sc.nextInt();\n//\t\t\tif (t == 0 && n == 0) {\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tPoint p = new Point();\n//\t\t\t\tp.x = sc.nextInt();\n//\t\t\t\tp.y = sc.nextInt();\n//\t\t\t\tpmap.put(p, -2);\n//\t\t\t}\n//\t\t\tPoint zero = new Point();\n//\t\t\tzero.x = sc.nextInt();\n//\t\t\tzero.y = sc.nextInt();\n//\t\t\tmove(zero, 0);\n//\t\t\tcount = 0;\n//\t\t\tif (pmap.size() > 0) {\n//\t\t\t\tfor (Entry<Point, Integer> p : pmap.entrySet()) {\n//\t\t\t\t\tif (p.getValue() >= 0) {\n//\t\t\t\t\t\tcount++;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[][][] map = new int[2][61][61];\n\t\n\tint[] vx = {0, 1, -1, 1, -1, 0}, vy = {1, 1, 0, 0, -1, -1};\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint t = in.nextInt(), n = in.nextInt();\n\t\t\tif (t == 0) break;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tArrays.fill(map[0][i], 0);\n\t\t\t\tArrays.fill(map[1][i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt();\n\t\t\t\tmap[0][30+x][30+y] = map[1][30+x][30+y] = -1;\n\t\t\t}\n\t\t\tint startX = in.nextInt(), startY = in.nextInt();\n\t\t\t\n\t\t\tmap[0][30+startX][30+startY] = 1;\n\t\t\t\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 60; k++) {\n\t\t\t\t\t\tif (map[cur][j][k] == 1) {\n\t\t\t\t\t\t\tmap[cur^1][j][k] = 1;\n\t\t\t\t\t\t\tfor (int a = 0; a < vx.length; a++) {\n\t\t\t\t\t\t\t\tint nx = j + vx[a], ny = k + vy[a];\n\t\t\t\t\t\t\t\tif (isOk(nx, 61, ny, 61) && map[cur][nx][ny] != -1) {\n\t\t\t\t\t\t\t\t\tmap[cur^1][nx][ny] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur ^= 1;\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tif (map[cur][i][j] == 1) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tboolean isOk(int x, int M, int y, int N) {\n\t\treturn 0 <= x && x < M && 0 <= y && y < N;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic boolean[][] obstacleMap;\n\tstatic int[][] directions8 = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 },\n\t\t\t{ 1, 1 } };\n\tstatic int[][] directions6 = { { -1, -1 }, { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 }, { 1, 1 } };\n\tstatic int[][] directions4 = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\tstatic int ans;\n\tstatic int t;\n\tstatic ArrayDeque<int[]> q;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tt = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif ((t | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// [30][30]が(0,0)。\n\t\t\tobstacleMap = new boolean[1000][1000];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tobstacleMap[sc.nextInt() + 300][sc.nextInt() + 300] = true;\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tint[] start = { sc.nextInt() + 300, sc.nextInt() + 300, 0 };\n\t\t\tq = new ArrayDeque<>();\n\t\t\tq.add(start);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint[] next = q.poll();\n\t\t\t\twalk(next[0], next[1], next[2]);\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tstatic void walk(int nowX, int nowY, int idx) {\n\t\tif (idx > t || obstacleMap[nowX][nowY]) {\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tobstacleMap[nowX][nowY] = true;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint[] next = { nowX + directions6[i][0], nowY + directions6[i][1], idx + 1 };\n\t\t\tq.add(next);\n\t\t}\n\t}\n\n\t// BFS用に二つの配列を足し算する\n\tstatic int[] addArrayElms(int[] a, int[] b) {\n\t\tint[] c = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t\treturn c;\n\t}\n\n\t// //二分探索\n\t// k <= num となる最小の配列要素kのインデックスを返す\n\tstatic private int binarySearch(long num, long[] orderedArray) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedArray.length;\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedArray[mid] <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// 二分探索\n\t// k <= num となる最小のList要素kのインデックスを返す\n\tstatic private int binarySearch(long num, ArrayList<Long> orderedList) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedList.size();\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedList.get(mid) <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// aとbの最小公倍数を求める\n\tpublic static int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int BLOCK = 100;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[61][61];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + 30;\n\t\t\t\tint y = in.nextInt() + 30;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + 30;\n\t\t\t\ty = in.nextInt() + 30;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tnew RuntimeException(showMap(map) + x + \":\" + y);\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < 60 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(System.lineSeparator());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\n/**\n * Created by kazuki on 2014/07/08.\n */\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[61][61];\n    static Deque<Integer> queue = new ArrayDeque<Integer>();\n\n\n    static void move(int x, int y,int turn) {\n        if (map[x][y] == -2) return;\n        if (map[x][y] == -1) {\n            num++;\n            map[x][y] = -2;\n        }\n        if(turn==0) return;\n        queue.offer((turn-1)*10000+(x+1)*100+(y+1));\n        queue.offer((turn-1)*10000+(x+1)*100+(y));\n        queue.offer((turn-1)*10000+(x)*100+(y+1));\n        queue.offer((turn-1)*10000+(x)*100+(y-1));\n        queue.offer((turn-1)*10000+(x-1)*100+(y));\n        queue.offer((turn-1)*10000+(x-1)*100+(y-1));\n    }\n\n    public static void main(String[] args) {\n        int turn, object;\n        int x, y;\n\n        while (true) {\n            turn = s.nextInt();\n            object = s.nextInt();\n\n            if (turn == 0 && object == 0) break;\n\n            for (int i = 0; i < 61; i++) {\n                for (int j = 0; j < 61; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt()+30;\n                y = s.nextInt()+30;\n\n                map[x][y] = -2;\n            }\n\n            x = s.nextInt()+30;\n            y = s.nextInt()+30;\n\n            queue.offer(turn*10000+x*100+y);\n            int p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                int tt = p/10000;\n                int xx = (p/100)%100;\n                int yy = p%100;\n\n                move(xx, yy,tt);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 60;\n\tpublic static final int ABS_SIZE = 30;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX == SIZE + 1){\n\t\t\teX = SIZE;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY == SIZE + 1){\n\t\t\teY = SIZE;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] != UNREA){\n\t\t\t\tif(field[i][j] == UNDEF && isAround(x,y,i,j)){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        int[] dx = {1,1,0,-1,-1,0};\n        int[] dy = {0,1,1,0,-1,-1};\n        while(true){\n        \tint t = sc.nextInt();\n        \tint n = sc.nextInt();\n        \tif(t==0 && n==0){\n        \t\tbreak;\n        \t}\n        \tboolean[][] judge = new boolean[100][100];\n        \tfor(int i=0;i<n;i++){\n        \t\tjudge[sc.nextInt()+50][sc.nextInt()+50] = true;\n        \t}\n        \tint x = sc.nextInt();\n        \tint y = sc.nextInt();\n        \tPoint start = new Point(x,y);\n        \tint count = 1;\n        \tArrayList<Point> list1 = new ArrayList<Point>();\n        \tArrayList<Point> list2 = new ArrayList<Point>();\n        \tlist1.add(start);\n        \tjudge[start.x+50][start.y+50] = true;\n        \tfor(int i=0;i<t;i++){\n        \t\twhile(!list1.isEmpty()){\n        \t\t\tPoint point = list1.get(0);\n        \t\t\tlist1.remove(0);\n        \t\t\tfor(int j=0;j<6;j++){\n        \t\t\t\tif(!judge[point.x+50+dx[j]][point.y+50+dy[j]]){\n        \t\t\t\t\tcount++;\n        \t\t\t\t\tPoint p = new Point(point.x+dx[j],point.y+dy[j]);\n        \t\t\t\t\tlist2.add(p);\n        \t\t\t\t\tjudge[point.x+50+dx[j]][point.y+50+dy[j]] = true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tlist1.clear();\n        \t\tfor(int l=0;l<list2.size();l++){\n        \t\t\tlist1.add(list2.get(l));\n        \t\t}\n        \t\tlist2.clear();\n        \t}\n        \tout.println(count);\n        \tout.flush();\n        \tlist1.clear();\n        \tlist2.clear();\n        }\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tpublic static int[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(t == 0 && n == 0) break;\n\t\t\tmap = new int[70][70];\n\t\t\tfor(int i = 0; i < 70; i++) {\n\t\t\t\tfor(int j = 0; j < 70; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tmap[y+30][x+30] = 9999999;\n\t\t\t}\n\t\t\t\n\t\t\tint x = stdIn.nextInt();\n\t\t\tint y = stdIn.nextInt();\n\t\t\tsolv(x+30,y+30,t);\n\t\t\tint c = 0;\n\t\t\tfor(int i = 0; i < 70; i++) {\n\t\t\t\tfor(int j = 0; j < 70; j++) {\n\t\t\t\t\tif(map[i][j] != -1 && map[i][j] != 9999999) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void solv(int x, int y, int t) {\n\t\tif(x < 0 || y < 0 || x >= 70|| y >= 70 || t < 0) return;\n\t\tif(map[y][x] == 9999999) return;\n\t\tif(map[y][x] > t) return;\n\t\t\n\t\tmap[y][x] = t;\n\t\t\n\t\tsolv(x+1,y+1,t-1);\n\t\tsolv(x+1,y,t-1);\n\t\tsolv(x,y+1,t-1);\n\t\tsolv(x,y-1,t-1);\n\t\tsolv(x-1,y,t-1);\n\t\tsolv(x-1,y-1,t-1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] fault = new int[2][n];\n\t\t\tint[][] map = new int[61][61];\n\t\t\tboolean[][] reach = new boolean[61][61];\n\t\t\tint[][] move = {{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\n\t\t\t\n\t\t\tfor(int i = 0; i < 61; i++){\n\t\t\t\tfor(int j = 0; j < 61; j++){\n\t\t\t\t\tmap[j][i] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfault[0][i] = sc.nextInt();\n\t\t\t\tfault[1][i] = sc.nextInt();\n\t\t\t\tmap[fault[0][i] + 30][fault[1][i] + 30] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] start = {sc.nextInt() + 30 , sc.nextInt() + 30};\n\t\t\treach[start[0]][start[1]] = true;\n\t\t\tint count = 0;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tint size;\n\t\t\tQueue<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.offer(new Point(start[0], start[1]));\n\t\t\twhile(true){\n\t\t\t\tif(count == t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tx = queue.peek().x; \n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tfor(int j = 0; j < move.length; j++){\n\t\t\t\t\t\tnextx = x + move[j][0];\n\t\t\t\t\t\tnexty = y + move[j][1];\n\t\t\t\t\t\tif(0 <= nextx && 0 <= nexty && nextx <= 60 && nexty <= 60 && map[nextx][nexty] != -1\n\t\t\t\t\t\t\t\t&& !reach[nextx][nexty] && map[nextx][nexty] == Integer.MAX_VALUE){\n\t\t\t\t\t\t\treach[nextx][nexty]  = true;\n\t\t\t\t\t\t\tmap[nextx][nexty] = count + 1;\n\t\t\t\t\t\t\tqueue.offer(new Point(nextx, nexty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 60; i++){\n\t\t\t\tfor(int j = 0; j < 60; j++){\n\t\t\t\t\tif(reach[j][i]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int[] vvx={0,1,0,-1,-1,1}, vvy={-1,0,1,0,-1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ2253();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\t\n\t\n\t// 2011MOGI - A 15:02-15:08\n\tvoid AOJ2252(){\n\t\tHashSet<Character> right=new HashSet<Character>();\n\t\tright.add('y');\tright.add('h');\tright.add('n');\tright.add('u');\tright.add('j');\tright.add('m');\n\t\tright.add('i');\tright.add('k');\tright.add('o');\tright.add('l');\tright.add('p');\n\t\twhile(sc.hasNext()){\n\t\t\tchar[] c=sc.next().toCharArray();\n\t\t\tif(c[0]=='#')\tbreak;\n\t\t\tboolean r=false;\n\t\t\tif(right.contains(c[0]))\tr=true;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<c.length; i++){\n\t\t\t\tif(right.contains(c[i])){\n\t\t\t\t\tans+=!r?1:0;\n\t\t\t\t\tr=true;\n\t\t\t\t}else{\n\t\t\t\t\tans+=r?1:0;\n\t\t\t\t\tr=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// 2012MOGI - A\t14:50-14:57\n\tvoid AOJ2399(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tboolean[][] b=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int j=0; j<m; j++)\tb[i][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tboolean[] ans=new boolean[N+1];\n\t\t\tArrays.fill(ans, true);\n\t\t\tint k=sc.nextInt();\n\t\t\tfor(int i=0; i<k; i++){\n\t\t\t\tint p=sc.nextInt();\n\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\tif(!b[j][p])\tans[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=-1;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tif(ans[i]){\n\t\t\t\t\tif(res<0)\tres=i;\n\t\t\t\t\telse{\n\t\t\t\t\t\tres=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\t\n\t// AOJ2253 2011MOGI - B\n\tvoid AOJ2253(){\n\t\twhile(sc.hasNext()){\n\t\t\tint t=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\tfinal int BASE=100,MAX=BASE+50;\n\t\t\tif(t==0)\tbreak;\n\t\t\tboolean[][] close=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<n; i++)\tclose[sc.nextInt()+BASE][sc.nextInt()+BASE]=true;\n\t\t\tint sx=sc.nextInt()+BASE,sy=sc.nextInt()+BASE;\n\t\t\tLinkedList<ClassB> open=new LinkedList<ClassB>();\n\t\t\topen.add(new ClassB(sx,sy,0));\n\t\t\tclose[sx][sy]=true;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tClassB now=open.poll();\n\t\t\t\tans++;\n\t\t\t\tif(now.t>=t)\tcontinue;\n\t\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\t\tint xx=now.x+vvx[i],yy=now.y+vvy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, MAX, MAX))\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new ClassB(xx,yy,now.t+1));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass ClassB{\n\t\tint x,y,t;\n\t\tClassB(int x,int y,int t){this.x=x; this.y=y; this.t=t;}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 62;\n\tpublic static final int ABS_SIZE = 31;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] != UNREA){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j)){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while(true) {\n            int t = scanner.nextInt();\n            int n = scanner.nextInt();\n            if(t==0 && n==0){\n                break;\n            }\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = scanner.nextInt();\n                y[i] = scanner.nextInt();\n            }\n            int startX = scanner.nextInt();\n            int startY = scanner.nextInt();\n            int count = t * (t + 1) * 3 + 1;\n            boolean[][] wall = new boolean[2*t+1][2*t+1];\n            for (int i = 0; i < n; i++) {\n                x[i] -= startX;\n                y[i] -= startY;\n                if (x[i] < -t || y[i] < -t || x[i] > t || y[i] > t) {\n                    continue;\n                }\n                if (x[i] < 0 && y[i] > 0 || x[i] > 0 && y[i] < 0) {\n                    if (Math.abs(x[i]) + Math.abs(y[i]) > t) {\n                        continue;\n                    }\n                }\n                wall[x[i] + t][y[i] + t] = true;\n            }\n            for(int i=0; i<2*t+1; i++){\n                for(int j=0; j<2*t+1; j++){\n                    if (i < t && j > t || i > t && j < t) {\n                        if (Math.abs(i-t) + Math.abs(j-t) > t) {\n                            continue;\n                        }\n                    }\n                    int [][] tmp = new int[2*t+1][2*t+1];\n                    if(!hasRoot(i - t, j - t, wall, t, t, tmp)){\n                        //System.out.println(i+\",\" + j);\n                        count--;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    private static boolean hasRoot(int x, int y, boolean[][] wall, int t, int origT, int[][] tmp){\n        if(x == 0 && y == 0) return true;\n        if(Math.abs(x) > origT || Math.abs(y) > origT || wall[x + origT][y + origT]){\n            return false;\n        }\n\n        if(t == 0){\n            return false;\n        }\n        if(tmp[x + origT][y + origT] >= t) return false;\n        tmp[x+origT][y+origT] = t;\n        return hasRoot(x + 1, y    , wall, t-1, origT, tmp) ||\n                hasRoot(x    , y + 1, wall, t-1, origT, tmp) ||\n                hasRoot(x + 1, y + 1, wall, t-1, origT, tmp) ||\n                hasRoot(x - 1, y    , wall, t-1, origT, tmp) ||\n                hasRoot(x    , y - 1, wall, t-1, origT, tmp) ||\n                hasRoot(x - 1, y - 1, wall, t-1, origT, tmp);\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\tfinal int N = 60;\n\tfinal int[][] ofs = {\n\t\t\t{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1,-1}, {0, -1}\n\t};\n\tboolean[][] visited;\n\tint[][] d;\n\t\n\tint bfs(int sx, int sy, int t){\n\t\tint c = 1;\n\t\tvisited[sy+N][sx+N] = true;\n\t\t\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tint[] ne = {sx, sy};\n\t\tq.offer(ne);\n\t\twhile(true){\n\t\t\tif(q.isEmpty()){ break; };\n\t\t\tne = q.poll();\n\t\t\tif(d[ne[1]+N][ne[0]+N] >= t){ continue; };\n\t\t\t\n\t\t\tfor(int i=0; i<ofs.length; ++i){\n\t\t\t\tfinal int[] e = {\n\t\t\t\t\t\tne[0] + ofs[i][0], ne[1] + ofs[i][1]\n\t\t\t\t};\n\t\t\t\tif(-N<=e[0] && e[0]<=N && -N<=e[1] && e[1]<=N){\n\t\t\t\t\tif(!visited[e[1]+N][e[0]+N]){\n\t\t\t\t\t\tvisited[e[1]+N][e[0]+N] = true;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tq.offer(e);\n\t\t\t\t\t\td[e[1]+N][e[0]+N] = d[ne[1]+N][ne[0]+N] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\t\n\t\n\t\n\tvoid io(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tvisited = new boolean[N*2+1][N*2+1];\t//filled false\n\t\t\td = new int[N*2+1][N*2+1];\t//filled 0\n\t\t\t\n\t\t\tfinal int t = sc.nextInt();  final int n = sc.nextInt();\n\t\t\tif(t==0 && n==0){ return; }\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tvisited[y+N][x+N] = true;\n\t\t\t}\n\t\t\tfinal int sx = sc.nextInt();  final int sy = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(bfs(sx, sy, t));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static int map[][];\n\tpublic static int t, n;\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n ==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[100][100];\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[sc.nextInt() + 50][sc.nextInt() + 50] = -1;\n\t\t\t}\n\t\t\tsaiki(sc.nextInt() + 50, sc.nextInt() + 50, 0);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (map[i][j] >= 0 && map[i][j] != 1 << 30) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static int dx[] = {0,1,1,0,-1,-1};\n\tpublic static int dy[] = {1,1,0,-1,-1,0};\n\t\n\tpublic static void saiki(int x, int y, int turn){\n\t\tif (t < turn) {\n\t\t\treturn;\n\t\t}\n\t\tmap[x][y] = turn;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (map[x + dx[i]][y + dy[i]] > turn) {\n\t\t\t\tsaiki(x + dx[i], y + dy[i], turn + 1);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[][][] map = new int[2][61][61];\n\t\n\tint[] vx = {0, 1, -1, 1, -1, 0}, vy = {1, 1, 0, 0, -1, -1};\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint t = in.nextInt(), n = in.nextInt();\n\t\t\tif (t == 0) break;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tArrays.fill(map[0][i], 0);\n\t\t\t\tArrays.fill(map[1][i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt();\n\t\t\t\tmap[0][30+x][30+y] = map[1][30+x][30+y] = -1;\n\t\t\t}\n\t\t\tint startX = in.nextInt(), startY = in.nextInt();\n\t\t\t\n\t\t\tmap[0][30+startX][30+startY] = 1;\n\t\t\t\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 60; k++) {\n\t\t\t\t\t\tif (map[cur][j][k] == 1) {\n\t\t\t\t\t\t\tmap[cur^1][j][k] = 1;\n\t\t\t\t\t\t\tfor (int a = 0; a < vx.length; a++) {\n\t\t\t\t\t\t\t\tint nx = j + vx[a], ny = k + vy[a];\n\t\t\t\t\t\t\t\tif (isOk(nx, 61, ny, 61) && map[cur][nx][ny] != -1) {\n\t\t\t\t\t\t\t\t\tmap[cur^1][nx][ny] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur ^= 1;\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 60; i++) {\n\t\t\t\tfor (int j = 0; j <= 60; j++) {\n\t\t\t\t\tif (map[cur][i][j] == 1) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tboolean isOk(int x, int M, int y, int N) {\n\t\treturn 0 <= x && x < M && 0 <= y && y < N && Math.abs(x-30) <= 30 && Math.abs(y-30) <= 30;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int[][] field;\n\tstatic int center = 100;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (t == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[201][201];\n\t\t\tfor (int i = 0; i < 201; i++)\n\t\t\t\tfor (int j = 0; j < 201; j++)\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt() + center;\n\t\t\t\ty[i] = sc.nextInt() + center;\n\t\t\t\tfield[x[i]][y[i]] = -1;\n\t\t\t}\n\t\t\tint sx = sc.nextInt() + center;\n\t\t\tint sy = sc.nextInt() + center;\n\t\t\tfield[sx][sy] = 1;\n\t\t\tmove(sx, sy, t);\n\t\t\tint result = count(201);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void move(int x, int y, int t) {\n\t\tint[] dx = { 0, 1, 1, 0, -1, -1 };\n\t\tint[] dy = { 1, 1, 0, -1, -1, 0 };\n\t\tif (field[x][y] <= t)\n\t\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\t\tif (field[x + dx[i]][y + dy[i]] == 0) {\n\t\t\t\t\tfield[x + dx[i]][y + dy[i]] = field[x][y] + 1;\n\t\t\t\t\tmove(x + dx[i], y + dy[i], t);\n\t\t\t\t}\n\t\t\t\tif (field[x + dx[i]][y + dy[i]] > 0\n\t\t\t\t\t\t&& field[x + dx[i]][y + dy[i]] > field[x][y] + 1) {\n\t\t\t\t\tfield[x + dx[i]][y + dy[i]] = field[x][y] + 1;\n\t\t\t\t\tmove(x + dx[i], y + dy[i], t);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tstatic int count(int w) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tif (field[i][j] > 0)\n\t\t\t\t\tresult++;\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 62;\n\tpublic static final int ABS_SIZE = 31;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX == SIZE + 1){\n\t\t\teX = SIZE;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY == SIZE + 1){\n\t\t\teY = SIZE;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] != UNREA){\n\t\t\t\tif(field[i][j] == UNDEF && isAround(x,y,i,j)){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\n/**\n * Created by kazuki on 2014/07/08.\n */\npublic class Main {\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n            dataNum++;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num,dataNum=0;\n    static int[][] map = new int[61][61];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n        if (map[x + 30][y + 30] == -2) return;\n        if (map[x + 30][y + 30] == -1) {\n            num++;\n            map[x + 30][y + 30] = -2;\n        }\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 61; i++) {\n                for (int j = 0; j < 61; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n            dataNum=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int MAP_SIZE = 1000;\n\tprivate static final int BLOCK = 99;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(x + \":\" + y + \"\\n\" + showMap(map));\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"%2d\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[61][61];\n  dist=new int[61][61];\n  for(int i=0;i<=60;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  bfs();\n  int ct=0;\n  for(int i=0;i<=60;i++) for(int j=0;j<=60;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n que.offerLast(new int[]{0,0});\n dist[OFFSET][OFFSET]=0;\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET];\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tclass P {\n\t\tint x, y, t;\n\t\tP(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\t}\n\t\n\tvoid run() {\n\t\tint t, n;\n\t\tboolean[][] map = new boolean[140][140];\n\t\tboolean[][] check = new boolean[140][140];\n\t\tint[] dx = {0, 0, 1, -1, 1, -1};\n\t\tint[] dy = {1, -1, 0, 0, 1, -1};\n\t\tQueue<P> q = new LinkedList<P>();\n\t\twhile (true) {\n\t\t\tt = sc.nextInt(); n = sc.nextInt();\n\t\t\tif (t == 0) break;\n\t\t\tfor (int i = 0; i < 140; i++) {\n\t\t\t\tArrays.fill(map[i], true);\n\t\t\t\tArrays.fill(check[i], false);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[sc.nextInt()+70][sc.nextInt()+70] = false;\n\t\t\tint x = sc.nextInt()+70, y = sc.nextInt()+70;\n\t\t\tint ans = 0;\n\t\t\tcheck[x][y] = true;\n\t\t\tq.add(new P(x, y, 0));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tans++;\n\t\t\t\tP p = q.poll();\n\t\t\t\tif (p.t < t) {\n\t\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\t\tif (!check[p.x+dx[i]][p.y+dy[i]] && map[p.x+dx[i]][p.y+dy[i]]) {\n\t\t\t\t\t\t\tcheck[p.x+dx[i]][p.y+dy[i]] = true;\n\t\t\t\t\t\t\tq.add(new P(p.x+dx[i], p.y+dy[i], p.t+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[61][61];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n        if (x < -30 || 30 < x || y < -30 || 30 < y) return;\n        if (map[x + 30][y + 30] == -2) return;\n        if (map[x + 30][y + 30] == -1) {\n            num++;\n            map[x + 30][y + 30] = turn;\n        } else if (map[x + 30][y + 30] >= turn) return;\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 61; i++) {\n                for (int j = 0; j < 61; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  //bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic boolean[][] obs;//true:障害あり\n\tstatic int[][] map;//0:到達しない1:到達する\n\tstatic void visit(int x, int y, int turn) {\n\t\tif(! obs[x][y]) {\n\t\t\tmap[x][y]=1;\n\t\t\tif(turn>0) {\n\t\t\t\tturn--;\n\n\t\t\t\tvisit(x+1, y, turn);\n\t\t\t\tvisit(x+1, y+1, turn);\n\t\t\t\tvisit(x, y+1, turn);\n\t\t\t\tvisit(x-1, y, turn);\n\t\t\t\tvisit(x-1, y-1, turn);\n\t\t\t\tvisit(x, y-1, turn);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint t=sc.nextInt();//ターン数\n\t\t\t\tint n=sc.nextInt();//障害物数\n\t\t\t\tif(t+n==0) break;\n\t\t\t\t\n\t\t\t\tobs=new boolean[61][61];\n\t\t\t\tmap=new int[61][61];\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tint x=sc.nextInt();\n\t\t\t\t\tint y=sc.nextInt();\n\t\t\t\t\tobs[x+30][y+30]=true;\n\t\t\t\t}\n\t\t\t\tint startx=sc.nextInt()+30;\n\t\t\t\tint starty=sc.nextInt()+30;\n\t\t\t\tmap[startx][starty]=1;\n\t\t\t\t\n\t\t\t\tint nowx=startx;\n\t\t\t\tint nowy=starty;\n\t\t\t\tvisit(nowx, nowy, t);\n\t\t\t\tint ans=0;\n\t\t\t\tfor(int i=0; i<=60; i++) {\n\t\t\t\t\tfor(int j=0; j<=60; j++) {\n\t\t\t\t\t\tans+=map[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[200][200];\n    static Deque<Integer> queue = new ArrayDeque<Integer>();\n\n\n    static void move(int x, int y, int turn) {\n        if (map[x][y] == -2) return;\n        if (map[x][y] == -1) {\n            num++;\n            map[x][y] = -2;\n        }\n        if (turn == 0) return;\n        queue.offer((turn - 1) * 10000 + (x + 1) * 100 + (y + 1));\n        queue.offer((turn - 1) * 10000 + (x + 1) * 100 + (y));\n        queue.offer((turn - 1) * 10000 + (x) * 100 + (y + 1));\n        queue.offer((turn - 1) * 10000 + (x) * 100 + (y - 1));\n        queue.offer((turn - 1) * 10000 + (x - 1) * 100 + (y));\n        queue.offer((turn - 1) * 10000 + (x - 1) * 100 + (y - 1));\n    }\n\n    public static void main(String[] args) {\n        int turn, object;\n        int x, y;\n\n        while (true) {\n            turn = s.nextInt();\n            object = s.nextInt();\n\n            if (turn == 0 && object == 0) break;\n\n            for (int i = 0; i < 200; i++) {\n                for (int j = 0; j < 200; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt() + 100;\n                y = s.nextInt() + 100;\n\n                map[x][y] = -2;\n            }\n\n            x = s.nextInt() + 100;\n            y = s.nextInt() + 100;\n\n            queue.offer(turn * 10000 + x * 100 + y);\n            int p;\n            while (!queue.isEmpty()) {\n                p = queue.poll();\n                int tt = p / 10000;\n                int xx = (p / 100) % 100;\n                int yy = p % 100;\n\n                move(xx, yy, tt);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t,n,c;\n\t\twhile(true) {\n\t\t\tc=0;\n\t\t\tint[][] area = new int[61][61];\n\t\t\tt=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif(t==0) {break;}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarea[sc.nextInt()+30][sc.nextInt()+30] = -1;\n\t\t\t}\n\t\t\tcanMove(area,sc.nextInt()+30,sc.nextInt()+30,t);\n\t\t\t\n\t\t\tfor(int i=0;i<61;i++) {\n\t\t\t\tfor(int j=0;j<61;j++) {\n\t\t\t\t\tif(area[i][j] > 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tfor(int i=0;i<61;i++) {\n\t\t\t\tfor(int j=0;j<61;j++) {\n\t\t\t\t\tif(area[i][j]<0) {\n\t\t\t\t\t}else {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void canMove(int[][] area,int x,int y,int maxt) {\n\t\t\n\t\tif(maxt-->=0) {\n\t\t\tif(area[x][y] >= 0){\n\t\t\t\tarea[x][y] =1;\n\t\t\t\tcanMove(area,x,y+1,maxt);\n\t\t\t\tcanMove(area,x+1,y+1,maxt);\n\t\t\t\tcanMove(area,x-1,y,maxt);\n\t\t\t\tcanMove(area,x+1,y,maxt);\n\t\t\t\tcanMove(area,x,y-1,maxt);\n\t\t\t\tcanMove(area,x-1,y-1,maxt);\n\t\t\t}\n\t\t}\n\t\treturn;\n//\t\t return area;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] fault = new int[2][n];\n\t\t\tint[][] map = new int[61][61];\n\t\t\tboolean[][] reach = new boolean[61][61];\n\t\t\tint[][] move = {{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\n\t\t\t\n\t\t\tfor(int i = 0; i < 61; i++){\n\t\t\t\tfor(int j = 0; j < 61; j++){\n\t\t\t\t\tmap[j][i] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfault[0][i] = sc.nextInt();\n\t\t\t\tfault[1][i] = sc.nextInt();\n\t\t\t\tmap[fault[0][i] + 30][fault[1][i] + 30] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] start = {sc.nextInt() + 30 , sc.nextInt() + 30};\n\t\t\treach[start[0]][start[1]] = true;\n\t\t\tint count = 0;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tint size;\n\t\t\tQueue<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.offer(new Point(start[0], start[1]));\n\t\t\twhile(true){\n\t\t\t\tif(count == t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tx = queue.peek().x; \n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tfor(int j = 0; j < move.length; j++){\n\t\t\t\t\t\tnextx = x + move[j][0];\n\t\t\t\t\t\tnexty = y + move[j][1];\n\t\t\t\t\t\tif(0 <= nextx && 0 <= nexty && nextx <= 60 && nexty <= 60 && map[nextx][nexty] != -1\n\t\t\t\t\t\t\t\t&& !reach[nextx][nexty]){\n\t\t\t\t\t\t\treach[nextx][nexty]  = true;\n\t\t\t\t\t\t\tmap[nextx][nexty] = count + 1;\n\t\t\t\t\t\t\tqueue.offer(new Point(nextx, nexty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 60; i++){\n\t\t\t\tfor(int j = 0; j < 60; j++){\n\t\t\t\t\tif(reach[j][i]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n  // dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 62;\n\tpublic static final int ABS_SIZE = 31;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\tif(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\t//if(field[i][j] != UNREA && isAround(x,y,i,j)){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[200][200];\n    static Deque<Integer> queue = new ArrayDeque<Integer>();\n\n\n    static void move(int x, int y, int turn) {\n        if (map[x][y] == -2) return;\n        if (map[x][y] == -1) {\n            num++;\n            map[x][y] = -2;\n        }\n        if (turn == 0) return;\n        queue.offer((turn - 1) * 1000000 + (x + 1) * 1000 + (y + 1));\n        queue.offer((turn - 1) * 1000000 + (x + 1) * 1000 + (y));\n        queue.offer((turn - 1) * 1000000 + (x) * 1000 + (y + 1));\n        queue.offer((turn - 1) * 1000000 + (x) * 1000 + (y - 1));\n        queue.offer((turn - 1) * 1000000 + (x - 1) * 1000 + (y));\n        queue.offer((turn - 1) * 1000000 + (x - 1) * 1000 + (y - 1));\n    }\n\n    public static void main(String[] args) {\n        int turn, object;\n        int x, y,xx,yy,tt,p;\n        int i,j;\n\n        while (true) {\n            turn = s.nextInt();\n            object = s.nextInt();\n\n            if (turn == 0 && object == 0) break;\n\n            for (i = 0; i < 200; i++) {\n                for (j = 0; j < 200; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (i = 0; i < object; i++) {\n                x = s.nextInt() + 100;\n                y = s.nextInt() + 100;\n\n                map[x][y] = -2;\n            }\n\n            x = s.nextInt() + 100;\n            y = s.nextInt() + 100;\n\n            queue.offer(turn * 1000000 + x * 1000 + y);\n\n            while (!queue.isEmpty()) {\n                p = queue.poll();\n                tt = p / 1000000;\n                xx = (p / 1000) % 1000;\n                yy = p % 1000;\n\n                move(xx, yy, tt);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Walker {\n\tint[][] map;\n\tint maxTurn, nTile;\n\t\n\tpublic Walker(int[][] map, int turn) {\n\t\tthis.map = map;\n\t\tthis.maxTurn = turn;\n\t\tthis.nTile = 0;\n\t}\n\t\n\tpublic boolean canWalk(int x, int y) {\n\t\treturn (x >= 0 && x <= 60 && y >= 0 && y <= 60) && map[y][x] != 2;\n\t}\n\t\n\tpublic void walk(int x, int y, int turn) {\n\t\tif (map[y][x] == 0) nTile++;\n\n\t\tmap[y][x] = 1;\n\t\t//printMap();\n\n\t\tif (maxTurn == turn) return;\n\t\t\n\t\tif (canWalk(x, y + 1))     walk(x, y + 1, turn + 1);\n\t\tif (canWalk(x + 1, y + 1)) walk(x + 1, y + 1, turn + 1);\n\t\tif (canWalk(x + 1, y))     walk(x + 1, y, turn + 1);\n\t\tif (canWalk(x, y - 1))     walk(x, y - 1, turn + 1);\n\t\tif (canWalk(x - 1, y - 1)) walk(x - 1, y - 1, turn + 1);\n\t\tif (canWalk(x - 1, y))     walk(x - 1, y, turn + 1);\n\t}\n\n\tpublic void printMap() {\n\t\tprintMap(5, 5);\n\t}\n\t\n\tpublic void printMap(int w, int h) {\n\t\tSystem.out.println();\n\t\tfor (int y = -h; y <= h; y++) {\n\t\t\tint i = 60 - (y + 30);\n\t\t\tfor (int k = 0; k < y + h; k++) System.out.print(\" \");\n\n\t\t\tfor (int x = -w; x <= w; x++) {\n\t\t\t\tint j = x + 30;\n\t\t\t\tSystem.out.printf(\"%2d\", new Object[] { map[i][j] });\n\t\t\t}\n\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tint t = sc.nextInt(); \n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tif (t == 0 && n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[61][61];\n\t\t\t\n\t\t\tfor (; n > 0; n--) {\n\t\t\t\tint x = sc.nextInt() + 30;\n\t\t\t\tint y = sc.nextInt() + 30;\n\t\t\t\tmap[y][x] = 2;\n\t\t\t}\n\t\t\t\n\t\t\tint sx = sc.nextInt() + 30;\n\t\t\tint sy = sc.nextInt() + 30;\n\t\t\t\n\t\t\tWalker w = new Walker(map, t);\n\t\t\tw.walk(sx, sy, 0);\n\t\t\tSystem.out.println(w.nTile);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if ((t | n) == 0)\n                break;\n            int[][] map = new int[121][121];\n            boolean[][] visited = new boolean[121][121];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                map[y + 60][x + 60] = -1;\n            }\n            Queue<Point> q = new LinkedList<Point>();\n            int sx = sc.nextInt() + 60;\n            int ans = 0;\n            int sy = sc.nextInt() + 60;\n            q.add(new Point(sx, sy));\n            visited[sy][sx] = true;\n            while (!q.isEmpty()) {\n                Point p = q.poll();\n                int x = p.x;\n                int y = p.y;\n                if (map[y][x] > t)\n                    continue;\n                ans++;\n                int dx[] = { 1, 1, 0, -1, -1, 0 };\n                int dy[] = { 0, 1, 1, 0, -1, -1 };\n                for (int i = 0; i < 6; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (nx >= 0 && ny >= 0 && ny < 121 && nx < 121\n                            && map[ny][nx] != -1) {\n                        if (visited[ny][nx]) {\n                            continue;\n                        }\n                        visited[ny][nx] = true;\n                        map[ny][nx] = map[y][x] + 1;\n                        q.add(new Point(nx, ny));\n                    }\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static int map[][];\n\tpublic static int t, n;\n\tpublic static int dx[] = {0,1,1,0,-1,-1};\n\tpublic static int dy[] = {1,1,0,-1,-1,0};\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n ==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[100][100];\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[sc.nextInt() + 50][sc.nextInt() + 50] = -1;\n\t\t\t}\n\t\t\tQueue<Integer[]> que = new ArrayDeque<Integer[]>();\n\t\t\tint nx = sc.nextInt() + 50;\n\t\t\tint ny = sc.nextInt() + 50;\n\t\t\tque.add(new Integer[]{nx, ny});\n\t\t\tmap[nx][ny] = 0;\n\t\t\twhile (que.size()!=0) {\n\t\t\t\tInteger[] now = que.poll();\n\t\t\t\tint x = now[0];\n\t\t\t\tint y = now[1];\n\t\t\t\tif (map[x][y] >= t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (map[x + dx[i]][y + dy[i]] > map[x][y] + 1) {\n\t\t\t\t\t\tmap[x + dx[i]][y + dy[i]] = map[x][y] + 1;\n\t\t\t\t\t\tque.add(new Integer[]{x + dx[i],y + dy[i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (map[i][j] >= 0 && map[i][j] != 1 << 30) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\n/**\n * Created by kazuki on 2014/07/08.\n */\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[200][200];\n    static Deque<Integer> queue = new ArrayDeque<Integer>();\n\n\n    static void move(int x, int y, int turn) {\n        if (map[x][y] == -2) return;\n        if (map[x][y] == -1) {\n            num++;\n            map[x][y] = -2;\n        }\n        if (turn == 0) return;\n        queue.offer((turn - 1) * 10000 + (x + 1) * 100 + (y + 1));\n        queue.offer((turn - 1) * 10000 + (x + 1) * 100 + (y));\n        queue.offer((turn - 1) * 10000 + (x) * 100 + (y + 1));\n        queue.offer((turn - 1) * 10000 + (x) * 100 + (y - 1));\n        queue.offer((turn - 1) * 10000 + (x - 1) * 100 + (y));\n        queue.offer((turn - 1) * 10000 + (x - 1) * 100 + (y - 1));\n    }\n\n    public static void main(String[] args) {\n        int turn, object;\n        int x, y,xx,yy,tt,p;\n        int i,j;\n\n        while (true) {\n            turn = s.nextInt();\n            object = s.nextInt();\n\n            if (turn == 0 && object == 0) break;\n\n            for (i = 0; i < 200; i++) {\n                for (j = 0; j < 200; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (i = 0; i < object; i++) {\n                x = s.nextInt() + 60;\n                y = s.nextInt() + 60;\n\n                map[x][y] = -2;\n            }\n\n            x = s.nextInt() + 60;\n            y = s.nextInt() + 60;\n\n            queue.offer(turn * 10000 + x * 100 + y);\n\n            while (!queue.isEmpty()) {\n                p = queue.poll();\n                tt = p / 10000;\n                xx = (p / 100) % 100;\n                yy = p % 100;\n\n                move(xx, yy, tt);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int MAX = 30;\n\tstatic final int[] H = new int[]{1, 1, 0, -1, -1, 0};\n\tstatic final int[] V = new int[]{1, 0, -1, -1, 0, 1};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tboolean[][][] obs = new boolean[4][31][31];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tint[] q;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tq = quadrant(x, y);\n\t\t\t\tobs[q[0]][q[1]][q[2]] = true;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tint[] sq;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsq = quadrant(sx, sy);\n\n\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\tint count = 0;\n\n\t\t\tqueue.offer(new int[]{0, sq[0], sq[1], sq[2]});\n\t\t\tobs[sq[0]][sq[1]][sq[2]] = true;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] pq = queue.poll();\n\t\t\t\tint[] p = dequadrant(pq[1], pq[2], pq[3]);\n\t\t\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tint[] nq;\n\t\t\t\t\tnx = p[0] + H[i];\n\t\t\t\t\tny = p[1] + V[i];\n\t\t\t\t\tnq = quadrant(nx, ny);\n\t\t\t\t\tif (pq[0] < t && Math.abs(nx) <= MAX && ny <= MAX && !obs[nq[0]][nq[1]][nq[2]]) {\n\t\t\t\t\t\tqueue.offer(new int[]{pq[0] + 1, nq[0], nq[1], nq[2]});\n\t\t\t\t\t\tobs[nq[0]][nq[1]][nq[2]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t}//end main\n\n\t//quadrant I:    x >= 0, y >= 0\n\t//quadrant II:   x <  0, y >= 0\n\t//quadrant III:  x <  0, y <  0\n\t//quadrant IV:   x >= 0, y <  0\n\tstatic int[] quadrant(int x, int y) {\n\t\tint o = 0;\n\t\tif (0 <= x && 0 <= y) {\n\t\t\to = 0;\n\t\t} else if (x < 0 && 0 <= y) {\n\t\t\to = 1;\n\t\t} else if (x < 0 && y < 0) {\n\t\t\to = 2;\n\t\t} else {\n\t\t\to = 3;\n\t\t}\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn new int[]{o, x, y};\n\t}\n\n\tstatic int[] dequadrant(int o, int x, int y) {\n\t\tif (o == 1) {\n\t\t\tx = -x;\n\t\t} else if (o == 2) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t} else if (o == 3) {\n\t\t\ty = -y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int MAX = 60;\n\tstatic final int[] H = new int[]{1, 1, 0, -1, -1, 0};\n\tstatic final int[] V = new int[]{1, 0, -1, -1, 0, 1};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tboolean[][][] obs = new boolean[4][31][31];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tint[] q;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tq = quadrant(x, y);\n\t\t\t\tobs[q[0]][q[1]][q[2]] = true;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tint[] sq;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsq = quadrant(sx, sy);\n\n\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\tint count = 0;\n\n\t\t\tqueue.offer(new int[]{0, sq[0], sq[1], sq[2]});\n\t\t\tobs[sq[0]][sq[1]][sq[2]] = true;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] pq = queue.poll();\n\t\t\t\tint[] p = dequadrant(pq[1], pq[2], pq[3]);\n\t\t\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tint[] nq;\n\t\t\t\t\tnx = p[0] + H[i];\n\t\t\t\t\tny = p[1] + V[i];\n\t\t\t\t\tnq = quadrant(nx, ny);\n\t\t\t\t\tif (pq[0] < t && Math.abs(nx) <= MAX && ny <= MAX && !obs[nq[0]][nq[1]][nq[2]]) {\n\t\t\t\t\t\tqueue.offer(new int[]{pq[0] + 1, nq[0], nq[1], nq[2]});\n\t\t\t\t\t\tobs[nq[0]][nq[1]][nq[2]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t}//end main\n\n\t//quadrant I:    x >= 0, y >= 0\n\t//quadrant II:   x <  0, y >= 0\n\t//quadrant III:  x <  0, y <  0\n\t//quadrant IV:   x >= 0, y <  0\n\tstatic int[] quadrant(int x, int y) {\n\t\tint o = 0;\n\t\tif (0 <= x && 0 <= y) {\n\t\t\to = 0;\n\t\t} else if (x < 0 && 0 <= y) {\n\t\t\to = 1;\n\t\t} else if (x < 0 && y < 0) {\n\t\t\to = 2;\n\t\t} else {\n\t\t\to = 3;\n\t\t}\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn new int[]{o, x, y};\n\t}\n\n\tstatic int[] dequadrant(int o, int x, int y) {\n\t\tif (o == 1) {\n\t\t\tx = -x;\n\t\t} else if (o == 2) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t} else if (o == 3) {\n\t\t\ty = -y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tclass Point {\n\t\tint x, y;\n\t\tint o, ox, oy;\n\n\t\tPoint(int x, int y) {\n\t\t\tif (0 <= x && 0 <= y) {\n\t\t\t\to = 0;\n\t\t\t} else if (x < 0 && 0 <= y) {\n\t\t\t\to = 1;\n\t\t\t} else if (x < 0 && y < 0) {\n\t\t\t\to = 2;\n\t\t\t} else {\n\t\t\t\to = 3;\n\t\t\t}\n\t\t\tox = Math.abs(x);\n\t\t\toy = Math.abs(y);\n\t\t}\n\n\t\tPoint(int o, int ox, int oy) {\n\t\t\tif (o == 1) {\n\t\t\t\tx = -x;\n\t\t\t} else if (o == 2) {\n\t\t\t\tx = -x;\n\t\t\t\ty = -y;\n\t\t\t} else if (o == 3) {\n\t\t\t\ty = -y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n  // dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n  // if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\tfinal int N = 30*2;\t\t//30じゃだめ。スタートからの絶対値が30までってこと。\n\tfinal int[][] ofs = {\n\t\t\t{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1,-1}, {0, -1}\n\t};\n\tboolean[][] visited;\n\tint[][] d;\n\t\n\tint bfs(int sx, int sy, int t){\n\t\tint c = 1;\n\t\tvisited[sy+N][sx+N] = true;\n\t\t\n\t\tQueue<int[]> q = new LinkedList<int[]>();\n\t\tint[] ne = {sx, sy};\n\t\tq.offer(ne);\n\t\twhile(true){\n\t\t\tif(q.isEmpty()){ break; };\n\t\t\tne = q.poll();\n\t\t\tif(d[ne[1]+N][ne[0]+N] >= t){ continue; };\n\t\t\t\n\t\t\tfor(int i=0; i<ofs.length; ++i){\n\t\t\t\tfinal int[] e = {\n\t\t\t\t\t\tne[0] + ofs[i][0], ne[1] + ofs[i][1]\n\t\t\t\t};\n\t\t\t\t//if(-N<=e[0] && e[0]<=N && -N<=e[1] && e[1]<=N){\n\t\t\t\t\tif(!visited[e[1]+N][e[0]+N]){\n\t\t\t\t\t\tvisited[e[1]+N][e[0]+N] = true;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tq.offer(e);\n\t\t\t\t\t\td[e[1]+N][e[0]+N] = d[ne[1]+N][ne[0]+N] + 1;\n\t\t\t\t\t}\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\t\n\t\n\t\n\tvoid io(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tvisited = new boolean[N*2+1][N*2+1];\t//filled false\n\t\t\td = new int[N*2+1][N*2+1];\t//filled 0\n\t\t\t\n\t\t\tfinal int t = sc.nextInt();  final int n = sc.nextInt();\n\t\t\tif(t==0 && n==0){ return; }\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tvisited[y+N][x+N] = true;\n\t\t\t}\n\t\t\tfinal int sx = sc.nextInt();  final int sy = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(bfs(sx, sy, t));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[61][61];\n  dist=new int[61][61];\n  for(int i=0;i<=60;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=60;i++) for(int j=0;j<=60;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET];\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static int map[][];\n\tpublic static int t, n;\n\tpublic static int dx[] = {0,1,1,0,-1,-1};\n\tpublic static int dy[] = {1,1,0,-1,-1,0};\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n ==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[1000][1000];\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[sc.nextInt() + 500][sc.nextInt() + 500] = -1;\n\t\t\t}\n\t\t\tQueue<Integer[]> que = new ArrayDeque<Integer[]>();\n\t\t\tint nx = sc.nextInt() + 500;\n\t\t\tint ny = sc.nextInt() + 500;\n\t\t\tque.add(new Integer[]{nx, ny});\n\t\t\tmap[nx][ny] = 0;\n\t\t\twhile (que.size()!=0) {\n\t\t\t\tInteger[] now = que.poll();\n\t\t\t\tint x = now[0];\n\t\t\t\tint y = now[1];\n\t\t\t\tif (map[x][y] >= t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (map[x + dx[i]][y + dy[i]] > map[x][y] + 1) {\n\t\t\t\t\t\tmap[x + dx[i]][y + dy[i]] = map[x][y] + 1;\n\t\t\t\t\t\tque.add(new Integer[]{x + dx[i],y + dy[i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\t\tif (map[i][j] >= 0 && map[i][j] != 1 << 30) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfinal int offset = 100;\n\t\t\tboolean obst[][] = new boolean[2*offset + 2][2*offset + 2];\n\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\n\t\t\t\tobst[x + offset][y + offset] = true;\n\t\t\t}\n\n\t\t\tint startX = sc.nextInt();\n\t\t\tint startY = sc.nextInt();\n\t\t\t\n\t\t\tint dist[][] = new int[2*offset + 2][2*offset  + 2];\n//\t\t\tint result = 1;\n\t\t\t\n\t\t\tArrayDeque<Point> que = new ArrayDeque<Point>();\n\t\t\tque.add(new Point(startX, startY));\n\t\t\t\n\t\t\tint dx[] = {0,1,1,0,-1,-1};\n\t\t\tint dy[] = {1,1,0,-1,-1,0};\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPoint p = que.remove();\n\t\t\t\t\n\t\t\t\tif(dist[p.x + offset][p.y + offset] > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tdist[p.x + offset][p.y + offset] = true; \n\t\t\t\t\n//\t\t\t\tSystem.out.println(\"x \"+p.x + \" y \"+p.y+\" \"+que.size());\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tint tmpX = p.x + dx[i];\n\t\t\t\t\tint tmpY = p.y + dy[i];\n\t\t\t\t\t\n\t\t\t\t\tif(tmpX == startX && tmpY == startY){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tmpX < -offset || tmpX > offset || tmpY< -offset || tmpY > offset){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!obst[tmpX + offset][tmpY + offset] && dist[tmpX + offset][tmpY + offset] == 0){\n\t\t\t\t\t\tque.add(new Point(tmpX, tmpY));\n\t\t\t\t\t\tdist[tmpX + offset][tmpY + offset] = dist[p.x + offset][p.y + offset] + 1;\n//\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint result = 1;\n\t\t\tfor(int i = 0; i < dist.length ; i++){\n\t\t\t\tfor(int j = 0 ; j < dist[0].length; j++){\n//\t\t\t\t\tSystem.out.print(dist[i][j]+\" \");\n\t\t\t\t\tif(dist[i][j] > 0 && dist[i][j] <= t){\n//\t\t\t\t\t\tSystem.out.println((i - offset)+\",\"+(j - offset)+\" dist \"+dist[i][j]);\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\t\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dx = {0, 1, 1, 0, -1, -1};\n\tstatic int[] dy = {1, 1, 0, -1, -1, 0};\n\tstatic int[][] time;\n\tstatic int offset = 50;\n\n\tstatic boolean solve() {\n\t\tint t = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tif (t + n == 0) return false;\n\n\t\ttime = new int[100][100];\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tArrays.fill(time[i], -1);\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint x = in.nextInt() + offset;\n\t\t\tint y = in.nextInt() + offset;\n\t\t\ttime[x][y] = 1<<30;\n\t\t}\n\n\t\tint sx = in.nextInt() + offset;\n\t\tint sy = in.nextInt() + offset;\n\n\t\tArrayDeque<int[]> deq = new ArrayDeque<>();\n\t\tdeq.add(new int[]{sx, sy, t});\n\t\twhile (!deq.isEmpty()) {\n\t\t\tint[] cur = deq.pollFirst();\n\t\t\tint cx = cur[0], cy = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\tif (ct < 0) continue;\n\t\t\ttime[cx][cy] = ct;\n\n\t\t\tfor (int i=0; i<6; i++) {\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (time[nx][ny] < t) {\n\t\t\t\t\tdeq.add(new int[]{nx, ny, ct-1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tfor (int j=0; j<100; j++) {\n\t\t\t\tif (time[i][j] < 0 || time[i][j] == 1<<30) continue;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int OFFSET = 30;\n\tstatic final int OBSTACLE = -1;\n\tstatic final int[] X = {0, 1, 1, 0, -1, -1};\n\tstatic final int[] Y = {1, 1, 0, -1, -1, 0};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tint[][] map = new int[OFFSET * 2 + 1][OFFSET * 2 + 1];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tmap[x + OFFSET][y + OFFSET] = OBSTACLE;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsx += OFFSET;\n\t\t\tsy += OFFSET;\n\n\t\t\tint count = 0;\n\t\t\tDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\t\tqueue.offer(new int[]{sx, sy, 0});\n\t\t\tmap[sx][sy] = OBSTACLE;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] hex = queue.poll();\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = hex[0] + X[i];\n\t\t\t\t\tny = hex[1] + Y[i];\n\t\t\t\t\tif (0 <= nx && nx <= 60 && 0 <= ny && ny <= 60 && hex[2] < t && map[nx][ny] != OBSTACLE) {\n\t\t\t\t\t\tqueue.offer(new int[]{nx, ny, hex[2] + 1});\n\t\t\t\t\t\tmap[nx][ny] = OBSTACLE;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t} // end while\n\t} // end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Integer BLOCK = Integer.valueOf(31);\n\tstatic Map<Hex, Integer> move = new HashMap<Hex, Integer>();\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint t = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmove.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmove.put(new Hex(in.nextInt(), in.nextInt()), BLOCK);\n\t\t\t}\n\t\t\tsetMoved(new Hex(in.nextInt(), in.nextInt()), t);\n\t\t\tSystem.out.println(move.size() - n);\n\t\t}\n\t\tin.close();\n\t}\n\n\tstatic void setMoved(Hex hex, int t) {\n\t\tInteger thisT = Integer.valueOf(t);\n\t\tif (!move.containsKey(hex)) {\n\t\t\tmove.put(hex, t);\n\t\t} else {\n\t\t\tif (move.get(hex).compareTo(thisT) < 0) {\n\t\t\t\tmove.put(hex, thisT);\n\t\t\t}\n\t\t}\n\t\tif (t-- > 0) {\n\t\t\t// System.out.println(hex.x + \":\" + hex.y + \"=>\" + t);\n\t\t\tint x = hex.x;\n\t\t\tint y = hex.y;\n\t\t\tHex[] hexs = new Hex[] { new Hex(x + 1, y + 1), new Hex(x + 1, y),\n\t\t\t\t\tnew Hex(x, y - 1), new Hex(x - 1, y - 1),\n\t\t\t\t\tnew Hex(x - 1, y), new Hex(x, y + 1), };\n\t\t\tfor (Hex tonari : hexs) {\n\t\t\t\tif (!move.containsKey(tonari)\n\t\t\t\t\t\t|| move.get(tonari).intValue() < t) {\n\t\t\t\t\tsetMoved(tonari, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Hex {\n\tpublic final int x, y;\n\n\tpublic Hex(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + x;\n\t\tresult = prime * result + y;\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tHex other = (Hex) obj;\n\t\tif (x != other.x) {\n\t\t\treturn false;\n\t\t}\n\t\tif (y != other.y) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*21];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET;i++) for(int j=0;j<=OFFSET;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CBraveForceStory solver = new CBraveForceStory();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CBraveForceStory {\n        private static int[] DX = {1, 1, 0, -1, -1, 0};\n        private static int[] DY = {0, 1, 1, 0, -1, -1};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int t = in.nextInt(), n = in.nextInt();\n            while (t != 0 || n != 0) {\n                boolean[][] board = new boolean[200][200], visited = new boolean[200][200];\n                for (int i = 0; i < n; i++) {\n                    board[in.nextInt() + 100][in.nextInt() + 100] = true;\n                }\n\n                Queue<CBraveForceStory.Point> q = new ArrayDeque<>();\n                CBraveForceStory.Point start = new CBraveForceStory.Point(in.nextInt() + 100, in.nextInt() + 100, 0);\n                q.offer(start);\n                visited[start.x][start.y] = true;\n\n                while (!q.isEmpty()) {\n                    CBraveForceStory.Point p = q.poll();\n                    if (p.d < t) {\n                        for (int i = 0; i < 6; i++) {\n                            int nx = p.x + DX[i], ny = p.y + DY[i];\n                            if (board[nx][ny] || visited[nx][ny]) continue;\n                            visited[nx][ny] = true;\n                            q.offer(new CBraveForceStory.Point(nx, ny, p.d + 1));\n                        }\n                    }\n                }\n\n                int ans = 0;\n                for (int i = 0; i < 200; i++) {\n                    for (int j = 0; j < 200; j++) {\n                        if (visited[i][j]) ans++;\n                    }\n                }\n\n                out.println(ans);\n                t = in.nextInt();\n                n = in.nextInt();\n            }\n        }\n\n        private static class Point {\n            int x;\n            int y;\n            int d;\n\n            Point(int x, int y, int d) {\n                this.x = x;\n                this.y = y;\n                this.d = d;\n            }\n\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n    int[][] map;\n    Queue<int[]> que;\n    int x, y;\n    int t, n;\n    int count;\n    int z = 100;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    map = new int[200][200];\n\t    que = new LinkedList<int[]>();\n\t    t = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(t!=0){\n\t\tint i=n;\n\t\twhile(i>0){\n\t\t    i--;\n\t\t    int a = sc.nextInt();\n\t\t    int b = sc.nextInt();\n\t\t    map[a+z][b+z] = -1;\n\t\t}\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tcount = 0;\n\t\tsolve(t, x, y);\n\t\tSystem.out.println(count);\n\t    }\n\t}\n    }\n\n    int[][] dir = { {0, 1}, {1, 1}, {1, 0}, \n\t\t    {0, -1}, {-1, -1}, {-1, 0} };\n\t\t    \n    void solve(int t, int x, int y){\n\tmap[x+z][y+z] = 1;\n\tcount++; // スタート地点\n\tfor(int i=0; i<dir.length; i++){\n\t    int[] a = { x+dir[i][0], y+dir[i][1], 2};\n\t    que.add(a);\n\t}\n\tint now = 2;\n\twhile(!que.isEmpty()){\n\t    int[] a = que.poll();\n\t    x = a[0];\n\t    y = a[1];\n\t    now = a[2];\n\t    if(now<=t+1){\n\t\tif(map[x+z][y+z]==0){\n\t\t    map[x+z][y+z] = now+1;\n\t\t    count++;\n\t\t    for(int i=0; i<dir.length; i++){\n\t\t        int[] b = { x+dir[i][0], y+dir[i][1], now+1};\n\t\t\tque.add(b);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }   \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0)break;\n\t\t\telse calc(t, n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int t, int n){\n\t\tint[][] map = new int[61][61];\n\t\tfor(int i = 0; i < n; i ++){\n\t\t\tint x = sc.nextInt() + 30;\n\t\t\tint y = sc.nextInt() + 30;\n\t\t\tmap[x][y] = -1;\n\t\t}\n\t\tint x = sc.nextInt() + 30;\n\t\tint y = sc.nextInt() + 30;\n\t\t\n\t\tmap[x][y] = 1;\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{x, y});\n\t\t\n\t\twhile(!list.isEmpty()){\n\t\t\tx = list.get(0)[0];\n\t\t\ty = list.get(0)[1];\n\t\t\tlist.remove(0);\n\t\t\tif(map[x][y] < t + 1){\n\t\t\t\tif(x > 0 && map[x-1][y] == 0){\n\t\t\t\t\tmap[x-1][y] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x-1, y});\n\t\t\t\t}\n\t\t\t\tif(x < 60 && map[x+1][y] == 0){\n\t\t\t\t\tmap[x+1][y] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x+1, y});\n\t\t\t\t}\n\t\t\t\tif(y > 0 && map[x][y-1] == 0){\n\t\t\t\t\tmap[x][y-1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x, y-1});\n\t\t\t\t}\n\t\t\t\tif(y < 60 && map[x][y+1] == 0){\n\t\t\t\t\tmap[x][y+1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x, y+1});\n\t\t\t\t}\n\t\t\t\tif(x > 0 && y > 0 && map[x-1][y-1] == 0){\n\t\t\t\t\tmap[x-1][y-1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x-1, y-1});\n\t\t\t\t}\n\t\t\t\tif(x < 60 && y < 60 && map[x+1][y+1] == 0){\n\t\t\t\t\tmap[x+1][y+1] = map[x][y] + 1;\n\t\t\t\t\tlist.add(new int[]{x+1, y+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 61; i++){\n\t\t\tfor(int j = 0; j < 61; j++){\n\t\t\t\tif(map[i][j] <= t+1 && map[i][j] > 0) sum++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n    int[][] map;\n    int x, y;\n    int t, n;\n    int count;\n    int z = 100;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    map = new int[200][200];\n\t    t = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(t!=0){\n\t\tint i=n;\n\t\twhile(i>0){\n\t\t    i--;\n\t\t    int a = sc.nextInt();\n\t\t    int b = sc.nextInt();\n\t\t    map[a+z][b+z] = -1;\n\t\t}\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tcount = 0;\n\t\tsolve(t, x, y);\n\t\tSystem.out.println(count);\n\t    }\n\t}\n    }\n\n    int[][] dir = { {0, 1}, {1, 1}, {1, 0}, \n\t\t    {0, -1}, {-1, -1}, {-1, 0} };\n\t\t    \n    void solve(int t, int x, int y){\n\tif(t<0 || map[x+z][y+z]==-1 || map[x+z][y+z]>100000) return;\n\t// 現在地が到達済か？\n\tif(map[x+z][y+z]!=-1){\n\t    if(map[x+z][y+z]==0)\n\t\tcount++;\n\t    map[x+z][y+z]++;\n\t}\n\t// 移動する\n\tfor(int i=0; i<dir.length; i++){\n\t    move(t-1, x+dir[i][0], y+dir[i][1], dir[i][0], dir[i][1]);\n\t    solve(t-1, x+dir[i][0], y+dir[i][1]);\n\t}\n    }\n\n    void move(int t, int x, int y, int dx, int dy){\n\twhile(t>0 && map[x+z][y+z]!=-1){\n\t    t--;\n\t    if(map[x+z][y+z]!=-1){\n\t\tif(map[x+z][y+z]==0)\n\t\t    count++;\n\t\tmap[x+z][y+z]++;\n\t    }\n\t    x += dx;\n\t    y += dy;\n\t}\n    }\n}   "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 62;\n\tpublic static final int ABS_SIZE = 31;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\t//フィールドに着いたときのターン数\n\tpublic static int[][] numOfTurn = new int[SIZE][SIZE];\n\tpublic static int MAX_TURN = 30;\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t\tnumOfTurn[i][j] = MAX_TURN;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tnumOfTurn[x][y] = 0;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j) && turn < numOfTurn[i][j]){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tnumOfTurn[i][j] = turn;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t,n,c;\n\t\twhile(true) {\n\t\t\tc=0;\n\t\t\tint[][] area = new int[61][61];\n\t\t\tt=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif(t==0) {break;}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarea[sc.nextInt()+30][sc.nextInt()+30] = -1;\n\t\t\t}\n\t\t\tcanMove(area,sc.nextInt()+30,sc.nextInt()+30,t);\n\t\t\t\n\t\t\tfor(int i=0;i<61;i++) {\n\t\t\t\tfor(int j=0;j<61;j++) {\n\t\t\t\t\tif(area[i][j] > 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void canMove(int[][] area,int x,int y,int maxt) {\n\t\t/*\n\t\tif(maxt-->=0) {\n\t\t\tif(area[x][y] >= 0){\n\t\t\t\tarea[x][y] ++;\n\t\t\t\tcanMove(area,x,y+1,maxt);\n\t\t\t\tcanMove(area,x+1,y+1,maxt);\n\t\t\t\tcanMove(area,x-1,y,maxt);\n\t\t\t\tcanMove(area,x+1,y,maxt);\n\t\t\t\tcanMove(area,x,y-1,maxt);\n\t\t\t\tcanMove(area,x-1,y-1,maxt);\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tif(maxt-- >= 0) {\n\t\t\tarea[x][y]=1;\n\t\t\tif(area[x][y+1] >= 0) {canMove(area, x, y+1, maxt);}\n\t\t\tif(area[x+1][y+1] >= 0) {canMove(area, x+1, y+1, maxt);}\n\t\t\tif(area[x-1][y] >= 0) {canMove(area, x-1, y, maxt);}\n\t\t\tif(area[x+1][y] >= 0) {canMove(area, x+1, y, maxt);}\n\t\t\tif(area[x][y-1] >= 0) {canMove(area, x, y-1, maxt);}\n\t\t\tif(area[x-1][y-1] >= 0) {canMove(area, x-1, y-1, maxt);}\n\t\t\t}\n\t\t\t\n\t\t\n\t\treturn;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\tint t;\n\tSet<D> block, point;\n\tint[] dx = {-1, 0, 0, 1, 1, -1};\n\tint[] dy = {0, -1, 1, 0, 1, -1};\n\tQueue<D> queue = new LinkedList<D>();\n\n\tclass D implements Comparable<D>{\n\t\tint x, y, k;\n\n\t\tD(int x, int y, int k) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.k = k;\n\t\t}\n\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.x != o.x) {\n\t\t\t\treturn this.x - o.x;\n\t\t\t}\n\t\t\treturn this.y - o.y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \")\";\n\t\t}\n\t}\n\t\n\t\n\n\tvoid bfs(int x, int y, int k) {\n\t\tif (t < k) {\n\t\t\treturn;\n\t\t}\n\t\tD d = new D(x, y, k);\n\t\tif (point.contains(d)) {\n\t\t\treturn ;\n\t\t}\n\t\tif (block.contains(d)) {\n\t\t\treturn;\n\t\t}\n\t\tpoint.add(d);\n\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tqueue.add(new D(nx, ny, k + 1));\n\t\t}\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD nd = queue.poll();\n\t\t\tbfs(nd.x, nd.y, nd.k);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((t | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblock = new TreeSet<D>();\n\t\t\tpoint = new TreeSet<D>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tblock.add(new D(x, y, 0));\n\t\t\t}\n\t\t\tint ax = sc.nextInt();\n\t\t\tint ay = sc.nextInt();\n\n\t\t\tbfs(ax, ay, 0);\n\t\t\tSystem.out.println(point.size());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package main;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class p2253 {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point(){\n\n\t\t}\n\t\tpublic Point(int x,int y){\n\t\t\tthis.x=Math.max(Math.min(x,30),-30);\n\t\t\tthis.y=Math.max(Math.min(y,30),-30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode(){\n\t\t\treturn x+37*y;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\",\"+y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic{\n\t\tdir=new Point[]{\n\t\t\tnew Point(1,0),\n\t\t\tnew Point(1,1),\n\t\t\tnew Point(0,1),\n\t\t\tnew Point(-1,0),\n\t\t\tnew Point(-1,-1),\n\t\t\tnew Point(0,-1)};\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p,int turn){\n\t\tif((pmap.get(p) ==null || pmap.get(p)>turn) && turn <=t){\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tPoint _p=new Point();\n\t\t\t\t_p.x=p.x+dir[i].x;\n\t\t\t\t_p.y=p.y+dir[i].y;\n\t\t\t\tmove(_p,turn+1);\n\t\t\t}\n\t\t\tpmap.put(p,turn);\n\t\t}\n\t}\n\tpublic void run() {\n\t\tpmap=new HashMap<Point, Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap.clear();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint p=new Point();\n\t\t\t\tp.x=sc.nextInt();\n\t\t\t\tp.y=sc.nextInt();\n\t\t\t\tpmap.put(p,-2);\n\t\t\t}\n\t\t\tPoint zero=new Point();\n\t\t\tzero.x=sc.nextInt();\n\t\t\tzero.y=sc.nextInt();\n\t\t\tmove(zero,0);\n\t\t\tcount=0;\n\t\t\tfor(Entry<Point, Integer> p : pmap.entrySet()){\n\t\t\t\tif(p.getValue()>=0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew p2253().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package aoj2253;\n\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic Queue<Integer> queueX = new ArrayDeque<Integer>();\n\tstatic Queue<Integer> queueY = new ArrayDeque<Integer>();\n\n\tstatic int[][] field = new int[100][100];\n\tstatic int count;\n\tstatic int ans;\n\n\tpublic static void main (String[] args) {\n\t\twhile (scan.hasNext()) {\n\t\t\tint t = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(field[i], 0);\n\t\t\t}\n\t\t\tif (t != 0 || n != 0) {\n\t\t\t\tsolve(t, n);\n\t\t\t}\n\t\t\twhile (queueX.poll() != null);\n\t\t\twhile (queueY.poll() != null);\n\t\t}\n\t}\n\n\tstatic void solve(int turn, int n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmpX = scan.nextInt();\n\t\t\tint tmpY = scan.nextInt();\n\t\t\tfield[tmpX + 50][tmpY + 50] = -1;\n\t\t}\n\n\t\tqueueX.add(scan.nextInt() + 50);\n\t\tqueueY.add(scan.nextInt() + 50);\n\t\tfield[queueX.element()][queueY.element()] = 1;\n\n\t\tcount = 1;\n\t\tans = 1;\n\t\tfor (int i = 0; i < turn; i++) {\n\t\t\tcount = bfs(count);\n\t\t\t//System.out.println(count);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic int bfs(int count) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < count; j++) {\n\t\t\tif (queueX.peek() != null) {\n\t\t\t\tint posX = queueX.poll();\n\t\t\t\tint posY = queueY.poll();\n\t\t\t\tint VectorX[] = {-1, 0, 1, 1, 0, -1};\n\t\t\t\tint VectorY[] = {0, 1, 1, 0, -1, -1};\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (field[posX + VectorX[i] ][posY + VectorY[i] ] == 0) {\n\t\t\t\t\t\tfield[posX + VectorX[i] ][posY + VectorY[i] ] = 1;\n\t\t\t\t\t\tqueueX.add(posX + VectorX[i]);\n\t\t\t\t\t\tqueueY.add(posY + VectorY[i]);\t\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t/*\tSystem.out.print(posX + VectorX[i]+\" \");\n\t\t\t\t\t\tSystem.out.println(posY + VectorY[i]);\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 30;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && !wall[point.y][point.x - 1] && !visited[point.y][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && !wall[point.y][point.x + 1] && !visited[point.y][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y > 0 && !wall[point.y - 1][point.x] && !visited[point.y - 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y < (MAX + MAX) && !wall[point.y + 1][point.x] && !visited[point.y + 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && point.y > 0 && !wall[point.y - 1][point.x - 1] && !visited[point.y - 1][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + MAX) && point.y < (MAX + MAX) && !wall[point.y + 1][point.x + 1] && !visited[point.y + 1][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "//package aoj2253;\n\nimport java.util.*;\n\npublic class Main {\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic Queue<Integer> queueX = new ArrayDeque<Integer>();\n\tstatic Queue<Integer> queueY = new ArrayDeque<Integer>();\n\n\tstatic int[][] field = new int[100][100];\n\tstatic int count;\n\tstatic int ans;\n\n\tpublic static void main (String[] args) {\n\t\twhile (scan.hasNext()) {\n\t\t\tint t = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tArrays.fill(field[i], 0);\n\t\t\t}\n\t\t\tif (t != 0 || n != 0) {\n\t\t\t\tsolve(t, n);\n\t\t\t}\n\t\t\twhile (queueX.poll() != null);\n\t\t\twhile (queueY.poll() != null);\n\t\t}\n\t}\n\n\tstatic void solve(int turn, int n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmpX = scan.nextInt();\n\t\t\tint tmpY = scan.nextInt();\n\t\t\tfield[tmpX + 30][tmpY + 30] = -1;\n\t\t}\n\n\t\tqueueX.add(scan.nextInt() + 30);\n\t\tqueueY.add(scan.nextInt() + 30);\n\t\tfield[queueX.element()][queueY.element()] = 1;\n\n\t\tcount = 1;\n\t\tans = 1;\n\t\tfor (int i = 0; i < turn; i++) {\n\t\t\tcount = bfs(count);\n\t\t\t//System.out.println(count);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic int bfs(int count) {\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < count; j++) {\n\t\t\tif (queueX.peek() != null) {\n\t\t\t\tint posX = queueX.poll();\n\t\t\t\tint posY = queueY.poll();\n\t\t\t\tint VectorX[] = {-1, 0, 1, 1, 0, -1};\n\t\t\t\tint VectorY[] = {0, 1, 1, 0, -1, -1};\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (0 <= posX + VectorX[i] && posX + VectorX[i] < 61 &&\n\t\t\t\t\t\t\t0 <= posY + VectorY[i] && posY + VectorY[i] < 61 &&\n\t\t\t\t\t\t\tfield[posX + VectorX[i] ][posY + VectorY[i] ] == 0) {\n\t\t\t\t\t\tfield[posX + VectorX[i] ][posY + VectorY[i] ] = 1;\n\t\t\t\t\t\tqueueX.add(posX + VectorX[i]);\n\t\t\t\t\t\tqueueY.add(posY + VectorY[i]);\t\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t/*\tSystem.out.print(posX + VectorX[i]+\" \");\n\t\t\t\t\t\tSystem.out.println(posY + VectorY[i]);\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(x + \":\" + y + \"\\n\" + showMap(map));\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dx = {0, 1, 1, 0, -1, -1};\n\tstatic int[] dy = {1, 1, 0, -1, -1, 0};\n\tstatic int offset = 500;\n\n\tstatic boolean solve() {\n\t\tint t = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tif (t + n == 0) return false;\n\n\t\tboolean[][] visited = new boolean[1000][1000];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint x = in.nextInt() + offset;\n\t\t\tint y = in.nextInt() + offset;\n\t\t\tvisited[x][y] = true;\n\t\t}\n\n\t\tint sx = in.nextInt() + offset;\n\t\tint sy = in.nextInt() + offset;\n\n\t\tArrayDeque<int[]> deq = new ArrayDeque<>();\n\t\tint ans = 0;\n\t\tdeq.add(new int[]{sx, sy, t});\n\t\tvisited[sx][sy] = true;\n\n\t\twhile (!deq.isEmpty()) {\n\t\t\tint[] cur = deq.pollFirst();\n\t\t\tint cx = cur[0], cy = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\tans++;\n\t\t\tif (ct == 0) continue;\n\n\t\t\tfor (int i=0; i<6; i++) {\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (!visited[nx][ny]) {\n\t\t\t\t\tvisited[nx][ny] = true;\n\t\t\t\t\tdeq.add(new int[]{nx, ny, ct-1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main\n{\n\n    private static final int[] dx = {0,1,1,0,-1,-1};\n    private static final int[] dy = {1,1,0,-1,-1,0};\n\n    private static class Pox implements Comparable<Pox>\n    {\n\tpublic Point p;\n\tpublic int cnt;\n\n\tPox()\n\t{\n\t    p = new Point(-1,-1);\n\t    cnt = 0;\n\t}\n\n\tPox(int x,int y,int c)\n\t{\n\t    p = new Point(x,y);\n\t    cnt = c;\n\t}\n\n\n\tpublic int compareTo(Pox a)\n\t{\n\t    return -1;\n\t}\n\n\n    }\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\twhile(true)\n\t    {\n\t\tString line;\n\t\tline = in.readLine();\n\t\tint t,n;\t\tt = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tn = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tif(t == 0 && n == 0)\n\t\t    break;\n\t\tHashMap<Point,Boolean> map = new HashMap<Point,Boolean>();\n\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint X,Y;\n\t\t\tline = in.readLine();\n\t\t\tX = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\t\tY = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\t\tmap.put(new Point(X,Y),true);\n\t\t    }\n\n\t\tint sx,sy;\n\t\tline = in.readLine();\n\t\tsx = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tsy = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tQueue<Pox> que = new PriorityQueue<Pox>();\n\t\tque.offer(new Pox(sx,sy,0));\n\t\tmap.put(new Point(sx,sy),false);\n\n\t\tHashMap<Point,Integer> used = new HashMap<Point,Integer>();\n\t\tused.put(new Point(sx,sy),0);\n\n\n\t\twhile(que.size() > 0)\n\t\t    {\n\t\t\tPox pox = que.poll();\n\n\t\t\tif(pox.cnt >= t)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t    {\n\t\t\t\tint nx = pox.p.x + dx[i],ny = pox.p.y + dy[i];\n\t\t\t\tif(!(Math.abs(nx) <= 30 && Math.abs(ny) <= 30))\n\t\t\t\t    continue;\n\n\t\t\t\tif(map.containsKey(new Point(nx,ny)))\n\t\t\t\t    {\n\t\t\t\t\tif(map.get(new Point(nx,ny)))\n\t\t\t\t\t    continue;\n\t\t\t\t    }\n\n\t\t\t\tif(used.containsKey(new Point(nx,ny)) && used.get(new Point(nx,ny)) <= pox.cnt)\n\t\t\t\t    {\n\t\t\t\t\tcontinue;\n\t\t\t\t    }\n\n\t\t\t\tused.put(new Point(nx,ny),pox.cnt);\n\t\t\t\tmap.put(new Point(nx,ny),false);\n\t\t\t\tque.offer(new Pox(nx,ny,pox.cnt+1));\n\t\t\t    }\n\n\t\t    }\n\t\tSystem.out.println(map.size()-n);\n\t    }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tstatic int dx[] = { 1, 0, 1, -1, 0, -1 };\n\tstatic int dy[] = { 0, 1, 1, 0, -1, -1 };\n\n\tstatic int matrix[][];\n\tstatic int color[][];\n\tstatic int dist[][];\n\n\tstatic Queue<Integer> queueX = new ArrayDeque<>();\n\tstatic Queue<Integer> queueY = new ArrayDeque<>();\n\n\tstatic final int WHITE = 0;\n\tstatic final int GRAY = 1;\n\tstatic final int BLACK = 2;\n\n\tstatic final int MATRIX = 200;\n\n\tstatic int count = 0;\n\tstatic int t;\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile (true) {\n\t\t\tString str[] = br.readLine().split(\" \");\n\t\t\tt = Integer.parseInt(str[0]);\n\t\t\tint n = Integer.parseInt(str[1]);\n\n\t\t\tif (t == 0 && n == 0)\n\t\t\t\tbreak;\n\n\t\t\tmatrix = new int[MATRIX][MATRIX];\n\t\t\tcolor = new int[MATRIX][MATRIX];\n\t\t\tdist = new int[MATRIX][MATRIX];\n\n\t\t\tqueueX = new ArrayDeque<>();\n\t\t\tqueueY = new ArrayDeque<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tstr = br.readLine().split(\" \");\n\t\t\t\tint x = Integer.parseInt(str[0]) + 100;\n\t\t\t\tint y = Integer.parseInt(str[1]) + 100;\n\t\t\t\tmatrix[y][x] = -1;\n\t\t\t}\n\t\t\tstr = br.readLine().split(\" \");\n\t\t\tint sx = Integer.parseInt(str[0]) + 100;\n\t\t\tint sy = Integer.parseInt(str[1]) + 100;\n\t\t\tcount = 1;\n\t\t\tbfs(sx, sy);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic void bfs(int x, int y) {\n\t\tqueueX.add(x);\n\t\tqueueY.add(y);\n\t\tfor (int i = 0; i < MATRIX; i++) {\n\t\t\tfor (int j = 0; j < MATRIX; j++) {\n\t\t\t\tdist[i][j] = Integer.MAX_VALUE;\n\t\t\t\tcolor[i][j] = WHITE;\n\t\t\t}\n\t\t}\n\t\tcolor[y][x] = GRAY;\n\t\tdist[y][x] = 0;\n\n\t\tint a, b;\n\n\t\twhile (!queueX.isEmpty() && !queueY.isEmpty()) {\n\t\t\ta = queueX.poll();\n\t\t\tb = queueY.poll();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = a + dx[i];\n\t\t\t\tint ny = b + dy[i];\n\n\t\t\t\tif (nx >= 0 && nx < MATRIX && ny >= 0 && ny < MATRIX) {\n\t\t\t\t\tif (matrix[ny][nx] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (color[ny][nx] == WHITE) {\n\t\t\t\t\t\tdist[ny][nx] = dist[b][a] + 1;\n\t\t\t\t\t\tif (dist[ny][nx] <= t) {\n\t\t\t\t\t\t\tcolor[ny][nx] = GRAY;\n\t\t\t\t\t\t\tqueueX.add(nx);\n\t\t\t\t\t\t\tqueueY.add(ny);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor[b][a] = BLACK;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int BLOCK = 100;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[61][61];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + 30;\n\t\t\t\tint y = in.nextInt() + 30;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + 30;\n\t\t\t\ty = in.nextInt() + 30;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(showMap(map) + x + \":\" + y);\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < 60 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main{\n\n\tint dy[] = {1,0,-1,-1,0,1};\n\tint dx[] = {0,-1,-1,0,1,1};\n\n\tclass Position{\n\t\tint x, y;\n\t\tPosition(int _x, int _y){\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Object a){\n\t\t\treturn a instanceof Position && ((Position)a).x == this.x && ((Position)a).y == this.y;\n\t\t}\n\t\t\n\t\tpublic int hashCode(){\n\t\t\treturn java.util.Arrays.hashCode(new int[]{this.x, this.y});\n\t\t}\n\t}\n\n\tclass State{\n\t\tint x, y, dist;\n\t\tState(int _x, int _y, int _d){\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.dist = _d;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint t = in.nextInt(), n = in.nextInt();\n\t\t\tif(n==0 && t==0) return ;\n\t\t\tSet<Position> blocks = new HashSet<Position>();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tblocks.add(new Position(in.nextInt(), in.nextInt()));\n\t\t\t}\n\t\t\tPosition start = new Position(in.nextInt(), in.nextInt());\n\t\t\tSystem.out.println(solve(blocks, t, start));\n\t\t}\n\t}\n\n\tint solve(Set<Position> blocks, int t, Position start){\n\t\tSet<Position> visited = new HashSet<Position>();\n\t\tvisited.add(start);\n\t\tQueue<State> que = new LinkedList<State>();\n\t\tque.add(new State(start.x, start.y, 0));\n\t\twhile(!que.isEmpty()){\n\t\t\tState tp = que.poll();\n\t\t\tPosition cur = new Position(tp.x, tp.y);\n\t\t\tint dist = tp.dist;\n\t\t\tif(dist >= t){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=0; k<6; k++){\n\t\t\t\tPosition next = new Position(cur.x + dx[k], cur.y + dy[k]);\n\t\t\t\tif(!visited.contains(next) && !blocks.contains(next)){\n\t\t\t\t\tvisited.add(next);\n\t\t\t\t\tque.add(new State(next.x, next.y, dist + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn  visited.size();\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.awt.Point;\n\nclass Main\n{\n\n    private static final int[] dx = {0,1,1,0,-1,-1};\n    private static final int[] dy = {1,1,0,-1,-1,0};\n\n    private static class Pox implements Comparable<Pox>\n    {\n\tpublic Point p;\n\tpublic int cnt;\n\n\tPox()\n\t{\n\t    p = new Point(-1,-1);\n\t    cnt = 0;\n\t}\n\n\tPox(int x,int y,int c)\n\t{\n\t    p = new Point(x,y);\n\t    cnt = c;\n\t}\n\n\n\tpublic int compareTo(Pox a)\n\t{\n\t    return -1;\n\t}\n\n\n    }\n\n      public static void main(String args[])throws IOException\n    {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\twhile(true)\n\t    {\n\t\tString line;\n\t\tline = in.readLine();\n\t\tint t,n;\t\tt = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tn = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tif(t == 0 && n == 0)\n\t\t    break;\n\t\tHashMap<Point,Boolean> map = new HashMap<Point,Boolean>();\n\n\t\tfor(int i=0;i<n;i++)\n\t\t    {\n\t\t\tint X,Y;\n\t\t\tline = in.readLine();\n\t\t\tX = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\t\tY = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\t\tmap.put(new Point(X,Y),true);\n\t\t    }\n\n\t\tint sx,sy;\n\t\tline = in.readLine();\n\t\tsx = Integer.parseInt(line.substring(0,line.indexOf(\" \")));\n\t\tsy = Integer.parseInt(line.substring(line.indexOf(\" \")+1));\n\t\tQueue<Pox> que = new PriorityQueue<Pox>();\n\t\tque.offer(new Pox(sx,sy,0));\n\t\tmap.put(new Point(sx,sy),false);\n\n\t\twhile(que.size() > 0)\n\t\t    {\n\t\t\tPox pox = que.poll();\n\n\t\t\tif(pox.cnt >= t)\n\t\t\t    {\n\t\t\t\tcontinue;\n\t\t\t    }\n\n\t\t\tfor(int i=0;i<6;i++)\n\t\t\t    {\n\t\t\t\tint nx = pox.p.x + dx[i],ny = pox.p.y + dy[i];\n\t\t\t\tif(!(Math.abs(nx) <= 30 && Math.abs(ny) <= 30))\n\t\t\t\t    continue;\n\n\t\t\t\tif(map.containsKey(new Point(nx,ny)))\n\t\t\t\t    {\n\t\t\t\t\tif(map.get(new Point(nx,ny)))\n\t\t\t\t\t    continue;\n\t\t\t\t    }\n\n\t\t\t\tmap.put(new Point(nx,ny),false);\n\t\t\t\tque.offer(new Pox(nx,ny,pox.cnt+1));\n\t\t\t    }\n\n\t\t    }\n\t\tSystem.out.println(map.size()-n);\n\t    }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\t//怖いので余裕を持たせておく\n\tpublic static final int SIZE = 65;\n\tpublic static final int ABS_SIZE = 31;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\t//フィールドに着いたときのターン数\n\tpublic static int[][] numOfTurn = new int[SIZE][SIZE];\n\tpublic static int MAX_TURN = 30;\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t\tnumOfTurn[i][j] = MAX_TURN + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tnumOfTurn[x][y] = 0;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j) && turn < numOfTurn[i][j]){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tnumOfTurn[i][j] = turn;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\n        import java.util.Deque;\n        import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[121][121];\n    static Deque<Integer> queue = new ArrayDeque<Integer>();\n\n\n    static void move(int x, int y,int turn) {\n        if (map[x][y] == -2) return;\n        if (map[x][y] == -1) {\n            num++;\n            map[x][y] = -2;\n        }\n        if(turn==0) return;\n        queue.offer((turn-1)*10000+(x+1)*100+(y+1));\n        queue.offer((turn-1)*10000+(x+1)*100+(y));\n        queue.offer((turn-1)*10000+(x)*100+(y+1));\n        queue.offer((turn-1)*10000+(x)*100+(y-1));\n        queue.offer((turn-1)*10000+(x-1)*100+(y));\n        queue.offer((turn-1)*10000+(x-1)*100+(y-1));\n    }\n\n    public static void main(String[] args) {\n        int turn, object;\n        int x, y;\n\n        while (true) {\n            turn = s.nextInt();\n            object = s.nextInt();\n\n            if (turn == 0 && object == 0) break;\n\n            for (int i = 0; i < 121; i++) {\n                for (int j = 0; j < 121; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt()+60;\n                y = s.nextInt()+60;\n\n                map[x][y] = -2;\n            }\n\n            x = s.nextInt()+60;\n            y = s.nextInt()+60;\n\n            queue.offer(turn*10000+x*100+y);\n            int p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                int tt = p/10000;\n                int xx = (p/100)%100;\n                int yy = p%100;\n\n                move(xx, yy,tt);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint OFS = 75;\n\tint MAX = 150;\n\tboolean map[][] = new boolean[MAX][MAX];\n\t\n\tint t, n;\n\tint sx, sy;\n\t\n\tvoid init() {\n\t\tfor(boolean[] a: map) fill(a, false);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (n|t) == 0 ) break;\n\t\t\tinit();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tmap[sc.nextInt()+OFS][sc.nextInt()+OFS] = true;\n\t\t\t}\n\t\t\tsx = sc.nextInt();\n\t\t\tsy = sc.nextInt();\n\t\t\tSystem.out.println(bfs());\n\t\t}\n\t}\n\tint dx[] = {0,1,1,0,-1,-1};\n\tint dy[] = {1,1,0,-1,-1,0};\n\t\n\tint bfs() {\n\t\tint cnt = 0;\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tque.add(new P(sx+OFS, sy+OFS, t));\n\t\tmap[sx+OFS][sy+OFS] = true;\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.removeFirst();\n//\t\t\tdebug(now.x, now.y);\n\t\t\tcnt++;\n\t\t\tif(now.c == 0) continue;\n\t\t\tfor(int i=0;i<6;i++) if(!map[now.x+dx[i]][now.y+dy[i]]) {\n\t\t\t\tmap[now.x+dx[i]][now.y+dy[i]] = true;\n\t\t\t\tque.add(new P( now.x+dx[i], now.y+dy[i], now.c-1));\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tclass P {\n\t\tint x, y, c;\n\t\tP(int x, int y, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[][][] map = new int[2][121][121];\n\tboolean[][] visited = new boolean[121][121];\n\t\n\tint[] vx = {0, 1, -1, 1, -1, 0};\n\tint[] vy = {1, 1, 0, 0, -1, -1};\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint t = in.nextInt(), n = in.nextInt();\n\t\t\tif (t == 0) break;\n\t\t\tfor (int i = 0; i <= 120; i++) {\n\t\t\t\tArrays.fill(map[0][i], 0);\n\t\t\t\tArrays.fill(map[1][i], 0);\n\t\t\t\tArrays.fill(visited[i], false);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt(), y = in.nextInt();\n\t\t\t\tmap[0][60+x][60+y] = map[1][60+x][60+y] = -1;\n\t\t\t}\n\t\t\tint startX = in.nextInt(), startY = in.nextInt();\n\t\t\t\n\t\t\tmap[0][60+startX][60+startY] = 1;\n\t\t\tvisited[60+startX][60+startY] = true;\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < t; i++) {\n\t\t\t\tfor (int j = 0; j <= 120; j++) {\n\t\t\t\t\tfor (int k = 0; k <= 120; k++) {\n\t\t\t\t\t\tif (map[cur][j][k] == 1) {\n\t\t\t\t\t\t\tfor (int a = 0; a < vx.length; a++) {\n\t\t\t\t\t\t\t\tint nx = j + vx[a], ny = k + vy[a];\n\t\t\t\t\t\t\t\tif (map[cur][nx][ny] != -1) {\n\t\t\t\t\t\t\t\t\tmap[cur^1][nx][ny] = 1;\n\t\t\t\t\t\t\t\t\tvisited[nx][ny] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur ^= 1;\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i <= 120; i++) {\n\t\t\t\tfor (int j = 0; j <= 120; j++) {\n\t\t\t\t\tif (visited[i][j]) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tboolean isOk(int x, int M, int y, int N) {\n\t\treturn 0 <= x && x < M && 0 <= y && y < N && Math.abs(x-30) <= 30 && Math.abs(y-30) <= 30;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int MAP_SIZE = 60;\n\tprivate static final int BLOCK = 99;\n\n\tpublic static void main(String[] arg) {\n\t\tString err = \"\";\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\terr += (life - 1) + \" \" + n + \"\\n\";\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\n\t\t\t\terr += (x - MAP_SIZE) + \" \" + (y - MAP_SIZE) + \"\\n\";\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\terr += (x - MAP_SIZE) + \" \" + (y - MAP_SIZE) + \"\\n\";\n\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t}\n\t\tin.close();\n\t\tthrow new RuntimeException(err);\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"%2d\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=30,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t,n,c;\n\t\twhile(true) {\n\t\t\tc=0;\n\t\t\tint[][] area = new int[61][61];\n\t\t\tt=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif(t==0) {break;}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tarea[sc.nextInt()+30][sc.nextInt()+30] = -1000;\n\t\t\t}\n\t\t\tcanMove(area,sc.nextInt()+30,sc.nextInt()+30,t);\n\t\t\t\n\t\t\tfor(int i=0;i<61;i++) {\n\t\t\t\tfor(int j=0;j<61;j++) {\n\t\t\t\t\tif(area[i][j] > 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void canMove(int[][] area,int x,int y,int maxt) {\n\t\t\n\t\tfor(int i=0;i<=maxt;i++) {\n\t\t\tif(area[x][y] >= 0) {\n\t\t\t\tarea[x][y] ++;\n\t\t\t\tcanMove(area,x,y+1,maxt-1);\n\t\t\t\tcanMove(area,x+1,y+1,maxt-1);\n\t\t\t\tcanMove(area,x-1,y,maxt-1);\n\t\t\t\tcanMove(area,x+1,y,maxt-1);\n\t\t\t\tcanMove(area,x,y-1,maxt-1);\n\t\t\t\tcanMove(area,x-1,y-1,maxt-1);\n\t\t\t}\n\t\t}\n\t\treturn;\n//\t\t return area;\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "// AOJ 2253 \"ブレイブ・フォース・ストーリー\" (ICPC模擬国内予選 2011 Problem B)\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if (t == 0) {\n                break;\n            }\n            \n            int[][] field = new int[121][121];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                field[y+60][x+60] = -1;\n            }\n            int sx = sc.nextInt() + 60;\n            int sy = sc.nextInt() + 60;\n            int[] dx = {0, 1, 1, 0, -1, -1};\n            int[] dy = {1, 1, 0, -1, -1, 0};\n            Queue<Field> que = new LinkedList<Field>();\n            que.offer(new Field(sx, sy));\n            while (que.peek() != null) {\n                Field tmp = que.poll();\n                int tmpx = tmp.x;\n                int tmpy = tmp.y;\n                if (field[tmpy][tmpx] == t) {\n                    continue;\n                }\n                for (int i = 0; i < dx.length; i++) {\n                    int nx = tmpx + dx[i];\n                    int ny = tmpy + dy[i];\n                    if (0 <= ny && ny < field.length && 0 <= nx && nx < field[ny].length\n                        && field[ny][nx] == 0 && !(nx == sx && ny == sy)) {\n                        que.offer(new Field(nx, ny));\n                        field[ny][nx] = field[tmpy][tmpx] + 1;\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length; j++) {\n                    if (field[i][j] > 0 && field[i][j] <= t) {\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count + 1);\n        }\n    }\n    \n    static void debug(int[][] field) {\n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[i].length; j++) {\n                System.out.print(field[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass Field {\n    int x;\n    int y;\n    Field(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  t=ir.nextInt();\n  n=ir.nextInt();\n  if(t==0&&n==0) return;\n  ng=new boolean[OFFSET*2+1][OFFSET*2+1];\n  dist=new int[OFFSET*2+1][OFFSET*2+1];\n  for(int i=0;i<=OFFSET*2;i++) Arrays.fill(dist[i],INF);\n  for(int i=0;i<n;i++) ng[ir.nextInt()+OFFSET][ir.nextInt()+OFFSET]=true;\n  sx=ir.nextInt();\n  sy=ir.nextInt();\n  bfs();\n  int ct=0;\n  for(int i=0;i<=OFFSET*2;i++) for(int j=0;j<=OFFSET*2;j++) if(dist[i][j]!=INF) ct++;\n  out.println(ct);\n }\n}\n \nstatic int t,n,sx,sy;\nstatic final int OFFSET=60,INF=1<<25;\nstatic boolean[][] ng;\nstatic final int[] dx=new int[]{0,-1,-1,0,1,1},dy=new int[]{1,0,-1,-1,0,1};\nstatic int[][] dist;\n\npublic static void bfs(){\n Deque<int[]> que=new ArrayDeque<>();\n dist[sx+OFFSET][sy+OFFSET]=0;\n que.offerLast(new int[]{sx,sy});\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<6;i++){\n   int nx=p[0]+dx[i],ny=p[1]+dy[i];\n   if(ng[nx+OFFSET][ny+OFFSET]||dist[nx+OFFSET][ny+OFFSET]!=INF) continue;\n   dist[nx+OFFSET][ny+OFFSET]=dist[p[0]+OFFSET][p[1]+OFFSET]+1;\n   if(dist[nx+OFFSET][ny+OFFSET]<t) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 125;\n\tpublic static final int ABS_SIZE = 60;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\t//フィールドに着いたときのターン数\n\tpublic static int[][] numOfTurn = new int[SIZE][SIZE];\n\tpublic static int MAX_TURN = 30;\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t\tnumOfTurn[i][j] = MAX_TURN + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tnumOfTurn[x][y] = 0;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j) && turn < numOfTurn[i][j]){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tnumOfTurn[i][j] = turn;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint[][] dir = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 }, { 1, 1 },\n\t\t\t\t{ -1, -1 } };\n\t\twhile (true) {\n\t\t\tint t = nextInt();\n\t\t\tif (t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint n = nextInt();\n\t\t\tint[][] xy = new int[n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\txy[i][0] = nextInt();\n\t\t\t\txy[i][1] = nextInt();\n\t\t\t}\n\t\t\tint sx = nextInt();\n\t\t\tint sy = nextInt();\n\n\t\t\tint[][] map = new int[121][121];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = xy[i][0];\n\t\t\t\tint y = xy[i][1];\n\t\t\t\tmap[x + 60][y + 60] = -1;// 障害物は負の数にしておく\n\t\t\t}\n\n\t\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\t\tint sum = 1;\n\t\t\tInteger[] start = { sx + 60, sy + 60 };\n\t\t\tdeque.add(start);\n\t\t\tmap[sx + 60][sy + 60] = 1;\n\t\t\twhile (deque.size() > 0) {\n\t\t\t\tInteger[] poll = deque.poll();\n\t\t\t\tif (map[poll[0]][poll[1]] > t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < dir.length; i++) {\n\t\t\t\t\tif (poll[0] + dir[i][0] >= 0\n\t\t\t\t\t\t\t&& poll[1] + dir[i][1] >= 0\n\t\t\t\t\t\t\t&& map[poll[0] + dir[i][0]][poll[1] + dir[i][1]] == 0) {\n\t\t\t\t\t\tmap[poll[0] + dir[i][0]][poll[1] + dir[i][1]] = map[poll[0]][poll[1]] + 1;\n\t\t\t\t\t\tInteger[] add = { poll[0] + dir[i][0],\n\t\t\t\t\t\t\t\tpoll[1] + dir[i][1] };\n\t\t\t\t\t\tdeque.add(add);\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nextChar() {\n\t\ttry {\n\t\t\tint b = System.in.read();\n\t\t\twhile (b != -1 && (b == ' ' || b == '\\r' || b == '\\n'))\n\t\t\t\t;\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 1, 0, 0, -1, -1 };\n\tint[] dy = { 1, 0, -1, 1, 0, -1 };\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((t | n) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] visit = new int[150][150];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt() + 75;\n\t\t\t\tint y = sc.nextInt() + 75;\n\t\t\t\tvisit[y][x] = -1;\n\t\t\t}\n\t\t\tint sx = sc.nextInt() + 75;\n\t\t\tint sy = sc.nextInt() + 75;\n\t\t\tvisit[sy][sx] = 1;\n\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sx, sy));\n\t\t\tint turn = 0;\n\t\t\twhile (!que.isEmpty() && turn++ < t) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tPos now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\t\tint nextX = now.x + dx[j];\n\t\t\t\t\t\tint nextY = now.y + dy[j];\n\t\t\t\t\t\tif (visit[nextY][nextX] == 0) {\n\t\t\t\t\t\t\tvisit[nextY][nextX] = 1;\n\t\t\t\t\t\t\tque.add(new Pos(nextX, nextY));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < 150; i++) {\n\t\t\t\tfor (int j = 0; j < 150; j++) {\n\t\t\t\t\tif (visit[i][j] == 1) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint x;\n\t\tint y;\n\n\t\t/**\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tpublic Pos(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int lim) {\n\t\treturn 0 <= h && h < lim && 0 <= w && w < lim;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] fault = new int[2][n];\n\t\t\tint[][] map = new int[61][61];\n\t\t\tboolean[][] reach = new boolean[200][200];\n\t\t\tint[][] move = {{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\n\t\t\t\n\t\t\tfor(int i = 0; i < 61; i++){\n\t\t\t\tfor(int j = 0; j < 61; j++){\n\t\t\t\t\tmap[j][i] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfault[0][i] = sc.nextInt();\n\t\t\t\tfault[1][i] = sc.nextInt();\n\t\t\t\tmap[fault[0][i] + 30][fault[1][i] + 30] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] start = {sc.nextInt() + 30 , sc.nextInt() + 30};\n\t\t\treach[start[0]][start[1]] = true;\n\t\t\tint count = 0;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tint size;\n\t\t\tQueue<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.offer(new Point(start[0], start[1]));\n\t\t\twhile(true){\n\t\t\t\tif(count == t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tx = queue.peek().x; \n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tfor(int j = 0; j < move.length; j++){\n\t\t\t\t\t\tnextx = x + move[j][0];\n\t\t\t\t\t\tnexty = y + move[j][1];\n\t\t\t\t\t\tif(0 <= nextx && 0 <= nexty && nextx <= 60 && nexty <= 60 && map[nextx][nexty] != -1\n\t\t\t\t\t\t\t\t&& !reach[nextx][nexty] && map[nextx][nexty] == Integer.MAX_VALUE){\n\t\t\t\t\t\t\treach[nextx][nexty]  = true;\n\t\t\t\t\t\t\tmap[nextx][nexty] = count + 1;\n\t\t\t\t\t\t\tqueue.offer(new Point(nextx, nexty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 60; i++){\n\t\t\t\tfor(int j = 0; j < 60; j++){\n\t\t\t\t\tif(reach[j][i]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n    static Deque<Integer> nowX = new ArrayDeque<Integer>();\n    static Deque<Integer> nowY = new ArrayDeque<Integer>();\n    static Scanner scan = new Scanner(System.in);\n    static int ans;\n\n    public static void main(String[] args) {\n        while (scan.hasNext()) {\n            boolean[][] field = new boolean[61][61];\n            int turn = scan.nextInt();\n            int n = scan.nextInt();\n            if (turn == 0) {\n                break;\n            }\n            init(field, n);\n            for (int i = 0; i < turn; i++) {\n                bfs(field);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static void init(boolean field[][], int n) {\n        while (nowX.peek() != null) {\n            nowX.remove();\n            nowY.remove();\n        }\n        for (int i = 0; i < 61; i++) {\n            for (int j = 0; j < 61; j++) {\n                field[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x1 = scan.nextInt() + 30;\n            int y1 = scan.nextInt() + 30;\n            field[x1][y1] = true;\n        }\n        int x = scan.nextInt() + 30;\n        int y = scan.nextInt() + 30;\n        nowX.add(x);\n        nowY.add(y);\n        ans = 1;\n        field[x][y] = true;\n    }\n\n    static void bfs(boolean field[][]) {\n        Deque<Integer> nextX = new ArrayDeque<Integer>();\n        Deque<Integer> nextY = new ArrayDeque<Integer>();\n        int[] dx = {0, 1, 1, 0, -1, -1};\n        int[] dy = {1, 1, 0, -1, -1, 0};\n        while (nowX.peek() != null) {\n            int x = nowX.remove();\n            int y = nowY.remove();\n            for (int i = 0; i < 6; i++) {\n                if (!field[x+dx[i]][y+dy[i]]) {\n                    ans++;\n                    field[x+dx[i]][y+dy[i]] = true;\n                    //System.out.println(x+dx[i]);\n                    //System.out.println(y+dy[i]);\n                    nextX.add(x+dx[i]);\n                    nextY.add(y+dy[i]);\n                }\n            }\n        }\n        nowX = nextX;\n        nowY = nextY;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 60;\n\tpublic static final int ABS_SIZE = 30;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX == SIZE + 1){\n\t\t\teX = SIZE;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY == SIZE + 1){\n\t\t\teY = SIZE;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\tif(isAround(x,y,i,j) && field[i][j] != UNREA){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\twhile(true){\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tboolean[][] map = new boolean[100][100];\n\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+50][y+50] = false;\n\t\t\t}\n\t\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\t\tint now_x = Integer.parseInt(stdIn.next());\n\t\t\tint now_y = Integer.parseInt(stdIn.next());\n\t\t\tPoint now = new Point(now_x+50,now_y+50);\n\t\t\tmap[now_x+50][now_y+50] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tPoint next = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[next.x+d[j][0]][next.y+d[j][1]]){\n\t\t\t\t\t\t\tSystem.out.println((next.x+d[j][0])+\" \"+(next.y+d[j][1]));\n\t\t\t\t\t\t\tmap[next.x+d[j][0]][next.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(next.x+d[j][0],next.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dx = {0, 1, 1, 0, -1, -1};\n\tstatic int[] dy = {1, 1, 0, -1, -1, 0};\n\tstatic int[][] time;\n\tstatic int offset = 50;\n\n\tstatic boolean solve() {\n\t\tint t = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tif (t + n == 0) return false;\n\n\t\ttime = new int[100][100];\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tArrays.fill(time[i], -1);\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint x = in.nextInt() + offset;\n\t\t\tint y = in.nextInt() + offset;\n\t\t\ttime[x][y] = 1<<30;\n\t\t}\n\n\t\tint sx = in.nextInt() + offset;\n\t\tint sy = in.nextInt() + offset;\n\n\t\tArrayDeque<int[]> deq = new ArrayDeque<>();\n\t\tdeq.add(new int[]{sx, sy, t});\n\t\twhile (!deq.isEmpty()) {\n\t\t\tint[] cur = deq.pollFirst();\n\t\t\tint cx = cur[0], cy = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\ttime[cx][cy] = ct;\n\n\t\t\tif (ct == 0) continue;\n\n\t\t\tfor (int i=0; i<6; i++) {\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (time[nx][ny] < t) {\n\t\t\t\t\tdeq.add(new int[]{nx, ny, ct-1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i=0; i<100; i++) {\n\t\t\tfor (int j=0; j<100; j++) {\n\t\t\t\tif (time[i][j] < 0 || time[i][j] == 1<<30) continue;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t==0 && n==0) break;\n\t\t\t\n\t\t\tboolean[][] map = new boolean[150][150];\n\t\t\tboolean[][] visit = new boolean[150][150];\n\t\t\tint p, q, r;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tp = sc.nextInt()+75;\n\t\t\t\tq = sc.nextInt()+75;\n\t\t\t\tmap[q][p] = true;\n\t\t\t}\n\t\t\tp = sc.nextInt()+75;\n\t\t\tq = sc.nextInt()+75;\n\t\t\t\n\t\t\tint cnt = 1;\n\t\t\tLinkedList<Integer> x = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> y = new LinkedList<Integer>();\n\t\t\tint[] a = new int[]{1,1,0,-1,-1,0};\n\t\t\tint[] b = new int[]{1,0,1,-1,0,-1};\n\t\t\tx.offer(p);\n\t\t\ty.offer(q);\n\t\t\tvisit[q][p] = true;\n\t\t\tfor(int i=0;i<t;i++){\n\t\t\t\tr = x.size();\n\t\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\t\tp = x.poll();\n\t\t\t\t\tq = y.poll();\n\t\t\t\t\tfor(int k=0;k<6;k++){\n\t\t\t\t\t\tif(visit[q+b[k]][p+a[k]]==false && map[q+b[k]][p+a[k]]==false){\n\t\t\t\t\t\t\tvisit[q+b[k]][p+a[k]] = true;\n\t\t\t\t\t\t\tx.offer(p+a[k]);\n\t\t\t\t\t\t\ty.offer(q+b[k]);\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\n\tstatic final int OBSTACLE = -1;\n\tstatic final int[] X = {0, 1, 1, 0, -1, -1};\n\tstatic final int[] Y = {1, 1, 0, -1, -1, 0};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tint t, n;\n\t\t\tt = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint size, ox, oy;\n\t\t\tsize = t * 4 + 1;\n\t\t\tox = oy = t * 2;\n\t\t\tint[][] map = new int[size][size];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tx = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tmap[ox + x][oy + y] = OBSTACLE;\n\t\t\t}\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tsx = ox + Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = oy + Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tint count = 0;\n\t\t\tArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\t\tqueue.offer(new int[]{sx, sy, 0});\n\t\t\tmap[sx][sy] = OBSTACLE;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] hex = queue.poll();\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = hex[0] + X[i];\n\t\t\t\t\tny = hex[1] + Y[i];\n\t\t\t\t\tif (hex[2] < t && map[nx][ny] != OBSTACLE) {\n\t\t\t\t\t\tqueue.offer(new int[]{nx, ny, hex[2] + 1});\n\t\t\t\t\t\tmap[nx][ny] = OBSTACLE;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0},\n      {1, 1},\n      {-1, -1}\n  };\n\n  void run() {\n    for (; ; ) {\n      int t, n;\n      t = ni();\n      n = ni();\n      if ((t | n) == 0) {\n        break;\n      }\n      boolean[][] jama = new boolean[200][200];\n      boolean[][] done = new boolean[200][200];\n      int offset = 100;\n      for (int i = 0; i < n; ++i) {\n        int x = ni();\n        int y = ni();\n        jama[y + offset][x + offset] = true;\n      }\n      int ax = ni();\n      int ay = ni();\n      Queue<Integer> qx = new LinkedList<>();\n      Queue<Integer> qy = new LinkedList<>();\n      Queue<Integer> qn = new LinkedList<>();\n      qx.add(offset + ax);\n      qy.add(offset + ay);\n      qn.add(0);\n      int cnt = 0;\n      while (qx.size() > 0) {\n        int x = qx.poll();\n        int y = qy.poll();\n        int num = qn.poll();\n        if (num > t) {\n          continue;\n        }\n        if (jama[y][x]) {\n          continue;\n        }\n        if (done[y][x]) {\n          continue;\n        }\n        done[y][x] = true;\n        ++cnt;\n        for (int[] d : ofs) {\n          int nx = x + d[0];\n          int ny = y + d[1];\n          qx.add(nx);\n          qy.add(ny);\n          qn.add(num + 1);\n        }\n      }\n      System.out.println(cnt);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while(true) {\n            int t = scanner.nextInt();\n            int n = scanner.nextInt();\n            if(t==0 && n==0){\n                break;\n            }\n            int[] x = new int[n];\n            int[] y = new int[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = scanner.nextInt();\n                y[i] = scanner.nextInt();\n            }\n            int startX = scanner.nextInt();\n            int startY = scanner.nextInt();\n            int count = t * (t + 1) * 3 + 1;\n            boolean[][] wall = new boolean[2*t+1][2*t+1];\n            for (int i = 0; i < n; i++) {\n                x[i] -= startX;\n                y[i] -= startY;\n                if (x[i] < -t || y[i] < -t || x[i] > t || y[i] > t) {\n                    continue;\n                }\n                if (x[i] < 0 && y[i] > 0 || x[i] > 0 && y[i] < 0) {\n                    if (Math.abs(x[i]) + Math.abs(y[i]) > t) {\n                        continue;\n                    }\n                }\n                wall[x[i] + t][y[i] + t] = true;\n            }\n            for(int i=0; i<2*t+1; i++){\n                for(int j=0; j<2*t+1; j++){\n                    if (i < t && j > t || i > t && j < t) {\n                        if (Math.abs(i-t) + Math.abs(j-t) > t) {\n                            continue;\n                        }\n                    }\n                    if(!hasRoot(i - t, j - t, wall, t, t)){\n                        count--;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    private static boolean hasRoot(int x, int y, boolean[][] wall, int t, int origT){\n        if(x == 0 && y == 0) return true;\n        if(t == 0){\n            return false;\n        }\n\n        if(Math.abs(x) > origT || Math.abs(y) > origT || wall[x + origT][y + origT]){\n            return false;\n        }\n        return hasRoot(x + 1, y    , wall, t-1, origT) ||\n                hasRoot(x    , y + 1, wall, t-1, origT) ||\n                hasRoot(x + 1, y + 1, wall, t-1, origT) ||\n                hasRoot(x - 1, y    , wall, t-1, origT) ||\n                hasRoot(x    , y - 1, wall, t-1, origT) ||\n                hasRoot(x - 1, y - 1, wall, t-1, origT);\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nclass Walker {\n    int[][] map;\n    int maxTurn, nTile;\n     \n    public Walker(int[][] map, int turn) {\n        this.map = map;\n        this.maxTurn = turn;\n        this.nTile = 0;\n    }\n \n    public boolean canWalk(int x, int y) {\n        return (x >= 0 && x <= 60 && y >= 0 && y <= 60) && map[y][x] == 0;\n    }\n     \n    public void walk(int x, int y, Queue<Integer[]> queue) {\n        queue.offer(new Integer[] {0, x, y});\n        \n        while (true) {\n        \tInteger[] args = queue.poll();\n        \tif (args == null) break;\n                    \t\n        \tint t = args[0];\n        \tint cx = args[1];\n        \tint cy = args[2];\n\n        \tnTile++;\n        \tmap[cy][cx] = 1;\n        \t\n        \tint[][] dirs = {{0, 1}, {1, 1}, {1, 0}, {0, -1}, {-1, -1}, {-1, 0}};\n//        \tprintMap();\n\n        \tfor (int[] dir : dirs) {\n        \t\tint nx = cx + dir[0];\n        \t\tint ny = cy + dir[1];\n\n        \t\tif (canWalk(nx, ny)) {\n        \t\t\tmap[ny][nx] = 1;\n        \t\t\tif (t < maxTurn) queue.offer(new Integer[] {t + 1, nx, ny});\n        \t\t}\n        \t}\n        \t\n        }\n    }\n \n    public void printMap() {\n        printMap(5, 5);\n    }\n     \n    public void printMap(int w, int h) {\n        System.out.println();\n        for (int y = -h; y <= h; y++) {\n            int i = 60 - (y + 30);\n            for (int k = 0; k < y + h; k++) System.out.print(\" \");\n \n            for (int x = -w; x <= w; x++) {\n                int j = x + 30;\n                System.out.printf(\"%2d\", new Object[] { map[i][j] });\n            }\n \n            System.out.println();\n        }\n    }\n}\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int t = sc.nextInt(); \n            int n = sc.nextInt();\n             \n            if (t == 0 && n == 0) break;\n             \n            int[][] map = new int[61][61];\n\n            for (; n > 0; n--) {\n                int x = sc.nextInt() + 30;\n                int y = sc.nextInt() + 30;\n                map[y][x] = 2;\n            }\n            \n           int sx = sc.nextInt() + 30;\n           int sy = sc.nextInt() + 30;\n\n            Walker w = new Walker(map, t);\n            w.walk(sx, sy, new LinkedList<Integer[]>());\n            System.out.println(w.nTile);\n        }\n        \n        sc.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tpublic static int[][] map;\n\tpublic static ArrayDeque<Data> que;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tque = new ArrayDeque<Data>();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(t == 0 && n == 0) break;\n\t\t\tmap = new int[150][150];\n\t\t\tfor(int i = 0; i < 150; i++) {\n\t\t\t\tfor(int j = 0; j < 150; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tmap[y+75][x+75] = 9999999;\n\t\t\t}\n\t\t\t\n\t\t\tint x = stdIn.nextInt();\n\t\t\tint y = stdIn.nextInt();\n\t\t\tque.add(new Data(x+75,y+75,t));\n\t\t\twhile(!que.isEmpty()) {\n\t\t\t\tData a = que.poll();\n\t\t\t\tif(a.x < 0 || a.y < 0 || a.x >= 150|| a.y >= 150) continue;\n\t\t\t\tif(map[a.y][a.x] == 9999999) continue;\n\t\t\t\tif(map[a.y][a.x] >= a.t) continue;\n\t\t\t\t\n\t\t\t\tmap[a.y][a.x] = a.t;\n\t\t\t\tif(a.t-1 == -1) continue;\n\t\t\t\tque.add(new Data(a.x+1,a.y+1,a.t-1));\n\t\t\t\tque.add(new Data(a.x+1,a.y,a.t-1));\n\t\t\t\tque.add(new Data(a.x,a.y+1,a.t-1));\n\t\t\t\tque.add(new Data(a.x,a.y-1,a.t-1));\n\t\t\t\tque.add(new Data(a.x-1,a.y,a.t-1));\n\t\t\t\tque.add(new Data(a.x-1,a.y-1,a.t-1));\n\t\t\t}\n\t\t\t\n\t\t\tint c = 0;\n\t\t\tfor(int i = 0; i < 150; i++) {\n\t\t\t\tfor(int j = 0; j < 150; j++) {\n\t\t\t\t\tif(map[i][j] != -1 && map[i][j] != 9999999) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}\n\nclass Data {\n\tint x;\n\tint y;\n\tint t;\n\tpublic Data(int a, int b, int c) {\n\t\tx = a;\n\t\ty = b;\n\t\tt = c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\n\n/**\n * Created by kazuki on 2014/07/08.\n */\npublic class Main {\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[61][61];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n        if (map[x + 30][y + 30] == -2) return;\n        if (map[x + 30][y + 30] == -1) {\n            num++;\n            map[x + 30][y + 30] = -2;\n        }\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 61; i++) {\n                for (int j = 0; j < 61; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static int num;\n    static int[][] map = new int[61][61];\n\n    static void move(int x,int y,int tern){\n        if(x<-30 || 30<x || y<-30 || 30<y) return;\n        if(map[x+30][y+30]<0) return;\n        if(map[x+30][y+30]==0) num++;\n        map[x+30][y+30]=1;\n        if(tern==0) return;\n        move(x+1,y+1,tern-1);\n        move(x+1,y,tern-1);\n        move(x,y+1,tern-1);\n        move(x,y-1,tern-1);\n        move(x-1,y,tern-1);\n        move(x-1,y-1,tern-1);\n    }\n\n    public static void main(String[] args) {\n        int tern,object;\n\n        int x,y;\n\n        while(true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if(tern==0 && object==0) break;\n\n            for(int i=0;i<61;i++){\n                for(int j=0;j<61;j++)\n                    map[i][j]=0;\n            }\n            num=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -1;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            move(x, y, tern);\n\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] dx = {0, 1, 1, 0, -1, -1};\n\tstatic int[] dy = {1, 1, 0, -1, -1, 0};\n\tstatic int offset = 50;\n\n\tstatic boolean solve() {\n\t\tint t = in.nextInt();\n\t\tint n = in.nextInt();\n\t\tif (t + n == 0) return false;\n\n\t\tboolean[][] visited = new boolean[100][100];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint x = in.nextInt() + offset;\n\t\t\tint y = in.nextInt() + offset;\n\t\t\tvisited[x][y] = true;\n\t\t}\n\n\t\tint sx = in.nextInt() + offset;\n\t\tint sy = in.nextInt() + offset;\n\n\t\tArrayDeque<int[]> deq = new ArrayDeque<>();\n\t\tint ans = 0;\n\t\tdeq.add(new int[]{sx, sy, t});\n\t\tvisited[sx][sy] = true;\n\n\t\twhile (!deq.isEmpty()) {\n\t\t\tint[] cur = deq.pollFirst();\n\t\t\tint cx = cur[0], cy = cur[1];\n\t\t\tint ct = cur[2];\n\t\t\tans++;\n\t\t\tif (ct == 0) continue;\n\n\t\t\tfor (int i=0; i<6; i++) {\n\t\t\t\tint nx = cx + dx[i];\n\t\t\t\tint ny = cy + dy[i];\n\t\t\t\tif (!visited[nx][ny]) {\n\t\t\t\t\tvisited[nx][ny] = true;\n\t\t\t\t\tdeq.add(new int[]{nx, ny, ct-1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew AOJ2253().doIt();\n\t}\n\t\n\tclass AOJ2253{\n\t\tint t,n;\n\t\tHashSet<Point2D> set;\n\t\tint cnt = 0;\n\t\tboolean[][] map;\n\t\tint[] sx = {1,0,-1,0,1,-1};\n\t\tint[] sy = {0,1,0,-1,1,-1};\n\t\tvoid dfs(Point2D p,int cost){\n\t\t\tint x = (int) p.getX();\n\t\t\tint y = (int) p.getY();\n\t\t\tmap[y][x] = true;\n\t\t\tif(cost == t)return;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>100||ny<0||ny>100)continue;\n\t\t\t\tPoint2D np = new Point2D.Double(nx,ny);\n\t\t\t\tif(set.contains(np))continue;\n\t\t\t\tdfs(np,cost+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve(){\n\t\t\tcnt = 0;\n\t\t\tmap = new boolean[100][100];\n\t\t\tdfs(new Point2D.Double(in.nextInt()+50,in.nextInt()+50),0);\n\t\t\tfor(int i=0;i<100;i++)for(int s=0;s<100;s++)if(map[i][s])cnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(in.hasNext()){\n\t\t\t\tt = in.nextInt();\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(t+n==0)break;\n\t\t\t\tset = new HashSet<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)set.add(new Point2D.Double(in.nextInt()+50,in.nextInt()+50));\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] fault = new int[2][n];\n\t\t\tint[][] map = new int[200][200];\n\t\t\tboolean[][] reach = new boolean[200][200];\n\t\t\tint[][] move = {{1,1},{1,0},{0,-1},{-1,-1},{-1,0},{0,1}};\n\t\t\t\n\t\t\tfor(int i = 0; i < 200; i++){\n\t\t\t\tfor(int j = 0; j < 200; j++){\n\t\t\t\t\tmap[j][i] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfault[0][i] = sc.nextInt();\n\t\t\t\tfault[1][i] = sc.nextInt();\n\t\t\t\tmap[fault[0][i] + 100][fault[1][i] + 100] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] start = {sc.nextInt() + 100 , sc.nextInt() + 100};\n\t\t\treach[start[0]][start[1]] = true;\n\t\t\tint count = 0;\n\t\t\tint x;\n\t\t\tint nextx;\n\t\t\tint y;\n\t\t\tint nexty;\n\t\t\tint size;\n\t\t\tQueue<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.offer(new Point(start[0], start[1]));\n\t\t\twhile(true){\n\t\t\t\tif(count == t){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = queue.size();\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tx = queue.peek().x; \n\t\t\t\t\ty = queue.poll().y;\n\t\t\t\t\tfor(int j = 0; j < move.length; j++){\n\t\t\t\t\t\tnextx = x + move[j][0];\n\t\t\t\t\t\tnexty = y + move[j][1];\n\t\t\t\t\t\tif(0 <= nextx && 0 <= nexty && nextx < 200 && nexty < 200 && map[nextx][nexty] != -1\n\t\t\t\t\t\t\t\t&& !reach[nextx][nexty]){\n\t\t\t\t\t\t\treach[nextx][nexty]  = true;\n\t\t\t\t\t\t\tmap[nextx][nexty] = count + 1;\n\t\t\t\t\t\t\tqueue.offer(new Point(nextx, nexty));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 200; i++){\n\t\t\t\tfor(int j = 0; j < 200; j++){\n\t\t\t\t\tif(reach[j][i]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\tboolean[][] map = new boolean[70][70];\n\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\tPoint now = new Point(0,0);\n\t\twhile(true){\n\t\t\tlist1.clear();\n\t\t\tlist2.clear();\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<70;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+35][y+35] = false;\n\t\t\t}\n\t\t\t\n\t\t\tnow.x = Integer.parseInt(stdIn.next())+35;\n\t\t\tnow.y = Integer.parseInt(stdIn.next())+35;\n\t\t\tmap[now.x][now.y] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tnow = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[now.x+d[j][0]][now.y+d[j][1]]){\n\t\t\t\t\t\t\tmap[now.x+d[j][0]][now.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(now.x+d[j][0],now.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic final int center = 75;\n\tstatic int[][] field;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (t == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[151][151];\n\t\t\tfor (int i = 0; i < 151; i++)\n\t\t\t\tfor (int j = 0; j < 151; j++)\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfield[sc.nextInt() + center][sc.nextInt() + center] = -1;\n\t\t\tmove(t, sc.nextInt() + center, sc.nextInt() + center);\n\t\t\tint result = count();\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void move(int t, int x, int y) {\n\t\tint[] dx = { 0, 1, 1, 0, -1, -1 };\n\t\tint[] dy = { 1, 1, 0, -1, -1, 0 };\n\t\tfield[x][y] = 1;\n\t\tif (t > 0)\n\t\t\tfor (int i = 0; i < dx.length; i++)\n\t\t\t\tif (field[x + dx[i]][y + dy[i]] == 0)\n\t\t\t\t\tmove(t - 1, x + dx[i], y + dy[i]);\n\t}\n\n\tstatic int count() {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < 151; i++)\n\t\t\tfor (int j = 0; j < 151; j++)\n\t\t\t\tif (field[i][j] == 1)\n\t\t\t\t\tresult++;\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 30;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && !wall[point.y][point.x - 1] && !visited[point.y][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + 1 + MAX) && !wall[point.y][point.x + 1] && !visited[point.y][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y > 0 && !wall[point.y - 1][point.x] && !visited[point.y - 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.y < (MAX + 1 + MAX) && !wall[point.y + 1][point.x] && !visited[point.y + 1][point.x]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x, point.y + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x > 0 && point.y > 0 && !wall[point.y - 1][point.x - 1] && !visited[point.y - 1][point.x - 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x - 1, point.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(point.x < (MAX + 1 + MAX) && point.y < (MAX + 1 + MAX) && !wall[point.y + 1][point.x + 1] && !visited[point.y + 1][point.x + 1]){\n\t\t\t\t\tqueue.add(new Point(point.old + 1, point.x + 1, point.y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tAOJ2253 obj = new AOJ2253();\n\t\twhile(true){\n\t\t\tint t = in.nextInt(),n = in.nextInt();\n\t\t\tif(n+t==0)break;\n\t\t\tobj.doIt(t,n);\n\t\t}\n\t}\n\tclass AOJ2253{\n\t\tvoid doIt(int t,int n){\n\t\t\tint[][] map = new int[61][61];\n\t\t\tfor(int i=0;i<61;i++)Arrays.fill(map[i],-1);\n\t\t\tboolean syougai[][] = new boolean[61][61];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint gx = in.nextInt()+30;\n\t\t\t\tint gy = in.nextInt()+30;\n\t\t\t\tsyougai[gy][gx] = true;\n\t\t\t}\n\t\t\tint sx = in.nextInt()+30,sy = in.nextInt()+30;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tint ax[] = {1,0,1,-1,0,-1};\n\t\t\tint ay[] = {0,1,1,0,-1,-1};\n\t\t\tq.add(new State(sx, sy, 0));\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tif(map[now.y][now.x]>0)continue;\n\t\t\t\tmap[now.y][now.x] = now.step;\n\t\t\t\tif(now.step == t)continue;\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\tint nx = ax[i]+now.x;\n\t\t\t\t\tint ny = ay[i]+now.y;\n\t\t\t\t\tif(nx<0||nx>=61||ny<0||ny>=61)continue;\n\t\t\t\t\tif(syougai[ny][nx])continue;\n\t\t\t\t\tq.add(new State(nx, ny, now.step+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<61;i++)for(int s=0;s<61;s++)if(map[i][s]>=0)cnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tclass State{\n\t\t\tint x,y,step;\n\t\t\tpublic State(int x,int y,int step) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p10000;\n\nclass Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic void run() {\n\t\tpr(\"Hello World\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Hello World\");\n\t\t//new Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\tpublic static final int SIZE = 61;\n\tpublic static final int ABS_SIZE = 30;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\t//フィールドに着いたときのターン数\n\tpublic static int[][] numOfTurn = new int[SIZE][SIZE];\n\tpublic static int MAX_TURN = 30;\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t\tnumOfTurn[i][j] = MAX_TURN + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tnumOfTurn[x][y] = 0;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j) && turn <= numOfTurn[i][j]){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tnumOfTurn[i][j] = turn;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static int map[][];\n\tpublic static int t, n;\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n ==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[100][100];\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[sc.nextInt() + 50][sc.nextInt() + 50] = -1;\n\t\t\t}\n\t\t\tsaiki(sc.nextInt() + 50, sc.nextInt() + 50, 0);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (map[i][j] >= 0 && map[i][j] != 1 << 30) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static int dx[] = {0,1,1,0,-1,-1};\n\tpublic static int dy[] = {1,1,0,-1,-1,0};\n\t\n\tpublic static void saiki(int x, int y, int turn){\n\t\tif (t < turn) {\n\t\t\treturn;\n\t\t}\n\t\tmap[x][y] = turn;\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (map[x + dx[i]][y + dy[i]] > turn) {\n\t\t\t\tsaiki(x + dx[i], y + dy[i], turn + 1);\n\t\t\t} else if(map[x + dx[i]][y + dy[i]] != -1 && map[x+dx[i]][y+dy[i]] + 1< turn){\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 2253 \"ブレイブ・フォース・ストーリー\" (ICPC模擬国内予選 2011 Problem B)\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if (t == 0) {\n                break;\n            }\n            \n            int[][] field = new int[121][121];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                field[y+60][x+60] = -1;\n            }\n            int sx = sc.nextInt() + 60;\n            int sy = sc.nextInt() + 60;\n            debug(field);\n            int[] dx = {0, 1, 1, 0, -1, -1};\n            int[] dy = {1, 1, 0, -1, -1, 0};\n            Queue<Field> que = new LinkedList<Field>();\n            que.offer(new Field(sx, sy));\n            while (que.peek() != null) {\n                Field tmp = que.poll();\n                int tmpx = tmp.x;\n                int tmpy = tmp.y;\n                if (field[tmpy][tmpx] == t) {\n                    continue;\n                }\n                for (int i = 0; i < dx.length; i++) {\n                    int nx = tmpx + dx[i];\n                    int ny = tmpy + dy[i];\n                    if (0 <= ny && ny < field.length && 0 <= nx && nx < field[ny].length\n                        && field[ny][nx] == 0 && !(nx == sx && ny == sy)) {\n                        que.offer(new Field(nx, ny));\n                        field[ny][nx] = field[tmpy][tmpx] + 1;\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length; j++) {\n                    if (field[i][j] > 0 && field[i][j] <= t) {\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count + 1);\n            debug(field);\n        }\n    }\n    \n    static void debug(int[][] field) {\n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[i].length; j++) {\n                System.out.print(field[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass Field {\n    int x;\n    int y;\n    Field(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int MAP_SIZE = 100;\n\tprivate static final int BLOCK = 99;\n\n\tpublic static void main(String[] arg) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (in.hasNext()) {\n\t\t\tint life = in.nextInt() + 1;\n\t\t\tint n = in.nextInt();\n\t\t\tif (life == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] map = new int[MAP_SIZE * 2 + 1][MAP_SIZE * 2 + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = in.nextInt() + MAP_SIZE;\n\t\t\t\tint y = in.nextInt() + MAP_SIZE;\n\t\t\t\tmap[x][y] = BLOCK;\n\t\t\t}\n\t\t\tint x = 0, y = 0;\n\t\t\ttry {\n\t\t\t\tx = in.nextInt() + MAP_SIZE;\n\t\t\t\ty = in.nextInt() + MAP_SIZE;\n\t\t\t\tSystem.out.println(setMove(map, x, y, life));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(x + \":\" + y + \"\\n\" + showMap(map));\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t}\n\n\tprivate static String showMap(int[][] map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint sp = 0;\n\t\tfor (int[] line : map) {\n\t\t\tfor (int i = 0; i < MAP_SIZE * 2 - sp; i++) {\n\t\t\t\tsb.append(\"  \");\n\t\t\t}\n\t\t\tsp++;\n\t\t\tfor (int i : line) {\n\t\t\t\tsb.append(String.format(\"[%2d]\", i));\n\t\t\t}\n\t\t\tsb.append(\"\\r\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int setMove(int[][] map, int x, int y, int t) {\n\t\tint count = 0;\n\t\tif (map[x][y] < t) {\n\t\t\tif (map[x][y] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[x][y] = t;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// System.out.print(\"x=\" + (x - 30) + \" y=\" + (y - 30) + \" \" +\n\t\t// map[x][y]);\n\t\t// System.out.println(\"=>\" + t);\n\t\tif (--t > 0) {\n\t\t\tcount += setMove(map, x, y - 1, t);\n\t\t\tcount += setMove(map, x, y + 1, t);\n\t\t\tcount += setMove(map, x - 1, y, t);\n\t\t\tcount += setMove(map, x + 1, y, t);\n\t\t\tcount += setMove(map, x - 1, y - 1, t);\n\t\t\tcount += setMove(map, x + 1, y + 1, t);\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static class Data{\n        int x,y,tern;\n\n        Data(int x,int y,int tern) {\n            this.x=x;\n            this.y=y;\n            this.tern=tern;\n            dataNum++;\n        }\n    }\n    static Scanner s = new Scanner(System.in);\n    static int num,dataNum=0;\n    static int[][] map = new int[61][61];\n    static Deque<Data> queue = new ArrayDeque<Data>();\n\n\n    static void move(int x, int y, int turn) {\n        if (x < -30 || 30 < x || y < -30 || 30 < y) return;\n        if (map[x + 30][y + 30] == -2) return;\n        if (map[x + 30][y + 30] == -1) {\n            num++;\n            map[x + 30][y + 30] = -2;\n        }\n        if (turn == 0) return;\n        Data t1 = new Data(x+1,y+1,turn-1);\n        queue.offer(t1);\n        Data t2 = new Data(x+1,y,turn-1);\n        queue.offer(t2);\n        Data t3 = new Data(x,y+1,turn-1);\n        queue.offer(t3);\n        Data t4 = new Data(x,y-1,turn-1);\n        queue.offer(t4);\n        Data t5 = new Data(x-1,y,turn-1);\n        queue.offer(t5);\n        Data t6 = new Data(x-1,y-1,turn-1);\n        queue.offer(t6);\n    }\n\n    public static void main(String[] args) {\n        int tern, object;\n        int x, y;\n\n        while (true) {\n            tern = s.nextInt();\n            object = s.nextInt();\n\n            if (tern == 0 && object == 0) break;\n\n            for (int i = 0; i < 61; i++) {\n                for (int j = 0; j < 61; j++)\n                    map[i][j] = -1;\n            }\n            num = 0;\n            dataNum=0;\n\n            for (int i = 0; i < object; i++) {\n                x = s.nextInt();\n                y = s.nextInt();\n\n                map[x + 30][y + 30] = -2;\n            }\n\n            x = s.nextInt();\n            y = s.nextInt();\n\n            Data param = new Data(x,y,tern);\n            queue.offer(param);\n            Data p;\n            while(!queue.isEmpty()) {\n                p = queue.poll();\n                move(p.x, p.y, p.tern);\n            }\n            System.out.println(num);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point(){\n\n\t\t}\n\t\tpublic Point(int x,int y){\n\t\t\tthis.x=Math.max(Math.min(x,30),-30);\n\t\t\tthis.y=Math.max(Math.min(y,30),-30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode(){\n\t\t\treturn x+37*y;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\",\"+y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic{\n\t\tdir=new Point[]{\n\t\t\tnew Point(1,0),\n\t\t\tnew Point(1,1),\n\t\t\tnew Point(0,1),\n\t\t\tnew Point(-1,0),\n\t\t\tnew Point(-1,-1),\n\t\t\tnew Point(0,-1)};\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p,int turn){\n\t\tif((pmap.get(p) ==null || pmap.get(p)>turn) && turn <=t){\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tPoint _p=new Point();\n\t\t\t\t_p.x=p.x+dir[i].x;\n\t\t\t\t_p.y=p.y+dir[i].y;\n\t\t\t\tmove(_p,turn+1);\n\t\t\t}\n\t\t\tpmap.put(p,turn);\n\t\t}\n\t}\n\tpublic void run() {\n\t\tpmap=new HashMap<Point, Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = 0;\n\t\t\tpmap.clear();\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint p=new Point();\n\t\t\t\tp.x=sc.nextInt();\n\t\t\t\tp.y=sc.nextInt();\n\t\t\t\tpmap.put(p,-2);\n\t\t\t}\n\t\t\tPoint zero=new Point();\n\t\t\tzero.x=sc.nextInt();\n\t\t\tzero.y=sc.nextInt();\n\t\t\tmove(zero,0);\n\t\t\tcount=0;\n\t\t\tfor(Entry<Point, Integer> p : pmap.entrySet()){\n\t\t\t\tif(p.getValue()>=0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DX = { 1, 1, 0, -1, -1, 0 };\n\tstatic int[] DY = { 1, 0, -1, -1, 0, 1 };\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tint T = sc.nextInt();\n\t\t\tif (T == 0) break;\n\t\t\tint N = sc.nextInt();\n\t\t\tboolean[][] visited = new boolean[201][201];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint x = sc.nextInt() + 100;\n\t\t\t\tint y = sc.nextInt() + 100;\n\t\t\t\tvisited[x][y] = true;\n\t\t\t}\n\t\t\tArrayList<Point> ps = new ArrayList<Point>();\n\t\t\tint sx = sc.nextInt() + 100;\n\t\t\tint sy = sc.nextInt() + 100;\n\t\t\tvisited[sx][sy] = true;\n\t\t\tps.add(new Point(sx, sy));\n\t\t\tint ans = 1;\n\t\t\tfor (int i = 0; i < T; ++i) {\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : ps) {\n\t\t\t\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\t\t\t\tint nx = p.x + DX[j];\n\t\t\t\t\t\tint ny = p.y + DY[j];\n\t\t\t\t\t\tif (!visited[nx][ny]) {\n\t\t\t\t\t\t\tvisited[nx][ny] = true;\n\t\t\t\t\t\t\tnext.add(new Point(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += next.size();\n\t\t\t\tps = next;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Point{\n\t\tint old, x, y;\n\n\t\tpublic Point(int old, int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.old = old;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {1, 1}, {0, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\t\n\tpublic static void main(String[] args){\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int MAX = 30;\n\t\t\n\t\twhile(true){\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(t == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] visited = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\tboolean[][] wall = new boolean[MAX + 1 + MAX][MAX + 1 + MAX];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\twall[y + MAX][x + MAX] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s_x = sc.nextInt();\n\t\t\tfinal int s_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint p = new Point(0 ,s_x + MAX, s_y + MAX);\n\t\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\t\tqueue.add(p);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPoint point = queue.poll();\n\t\t\t\t\n\t\t\t\tif(point.old > t){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(visited[point.y][point.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[point.y][point.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = point.x + move[0];\n\t\t\t\t\tfinal int ny = point.y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(nx < 0 || nx >= (MAX + 1 + MAX) || ny < 0 || ny >= (MAX + 1 + MAX)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tqueue.add(new Point(point.old + 1, nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out  = new PrintWriter(System.out);\n\t\tint[][] d = {{0,1},{1,1},{1,0},{0,-1},{-1,-1},{-1,0}};\n\t\tboolean[][] map = new boolean[100][100];\n\t\tArrayList<Point> list1 = new ArrayList<Point>();\n\t\tArrayList<Point> list2 = new ArrayList<Point>();\n\t\twhile(true){\n\t\t\tlist1.clear();\n\t\t\tlist2.clear();\n\t\t\tint t = Integer.parseInt(stdIn.next());\n\t\t\tint n = Integer.parseInt(stdIn.next()); \n\t\t\tif(t==0 && n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tArrays.fill(map[i],true);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = Integer.parseInt(stdIn.next());\n\t\t\t\tint y = Integer.parseInt(stdIn.next());\n\t\t\t\tmap[x+50][y+50] = false;\n\t\t\t}\n\t\t\t\n\t\t\tint now_x = Integer.parseInt(stdIn.next());\n\t\t\tint now_y = Integer.parseInt(stdIn.next());\n\t\t\tPoint now = new Point(now_x+50,now_y+50);\n\t\t\tmap[now_x+50][now_y+50] = false;\n\t\t\tlist1.add(now);\n\t\t\tint count = 1;\n\t\t\twhile(t>0){\n\t\t\t\tfor(int i=0;i<list1.size();i++){\n\t\t\t\t\tnow = list1.get(i);\n\t\t\t\t\tfor(int j=0;j<d.length;j++){\n\t\t\t\t\t\tif(map[now.x+d[j][0]][now.y+d[j][1]]){\n\t\t\t\t\t\t\tmap[now.x+d[j][0]][now.y+d[j][1]] = false;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tPoint p = new Point(now.x+d[j][0],now.y+d[j][1]);\n\t\t\t\t\t\t\tlist2.add(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist1.clear();\n\t\t\t\tfor(int k=0;k<list2.size();k++){\n\t\t\t\t\tlist1.add(list2.get(k));\n\t\t\t\t}\n\t\t\t\tlist2.clear();\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tout.println(count);\n\t\t\tout.flush();\n\t\t}\n\t}\n\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//存在しないフィールド\n\tpublic static final int UNDEF = 0;\n\t//public static final int DEF = 1;\n\tpublic static final int REA = 2;\n\t//障害物のある場所\n\tpublic static final int UNREA = 3;\n\t//怖いので余裕を持たせておく\n\tpublic static final int SIZE = 61;\n\tpublic static final int ABS_SIZE = 30;\n\t//座標のx,y両方に2を足したもの\n\tpublic static int[][] field = new int[SIZE][SIZE];\n\t//フィールドに着いたときのターン数\n\tpublic static int[][] numOfTurn = new int[SIZE][SIZE];\n\tpublic static int MAX_TURN = 30;\n\tpublic static int maxTurn = 0;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\n\t}\n\tpublic static void init(){\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n//\t\t\t\tif(isDef(i,j)){\n//\t\t\t\t\tfield[i][j] = DEF;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tfield[i][j] = UNDEF;\n//\t\t\t\t}\n\t\t\t\tfield[i][j] = UNDEF;\n\t\t\t\tnumOfTurn[i][j] = MAX_TURN + 1;\n\t\t\t}\n\t\t}\n\t}\n//\tpublic static boolean isDef(int x, int y){\n//\t\tboolean bRet = false;\n//\t\tswitch(x){\n//\t\t\tcase 0:\n//\t\t\t\tif(y < 3){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 1:\n//\t\t\t\tif(y < 4){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 2:\n//\t\t\t\tbRet = true;\n//\t\t\t\tbreak;\n//\t\t\tcase 3:\n//\t\t\t\tif(y > 0){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t\tcase 4:\n//\t\t\t\tif(y > 1){\n//\t\t\t\t\tbRet = true;\n//\t\t\t\t}\n//\t\t\t\tbreak;\n//\t\t}\n//\t\treturn bRet;\n//\t}\n\tpublic static void printCount(){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tif(field[i][j] == REA){\n\t\t\t\t\tcount++;\n\t\t\t\t\t//System.out.println(\"x = \"+ (i - 2) + \", y = \" + (j - 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tmaxTurn = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\twhile(maxTurn != 0 || n != 0){\n\t\t\t//System.out.println(\"maxTurn = \"+maxTurn + \", n = \" + n);\n\t\t\tinit();\n\t\t\t//障害物設置\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\t\t//System.out.println(\"x = \"+x + \", y = \" + y);\n\t\t\t\t//if((0 <=x && x <= SIZE) && (0 <=y && y <= SIZE)){\n\t\t\t\t\tfield[x][y] = UNREA;\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//初期地点\n\t\t\tint x = sc.nextInt() + ABS_SIZE;\n\t\t\tint y = sc.nextInt() + ABS_SIZE;\n\t\t\tfield[x][y] = REA;\n\t\t\tnumOfTurn[x][y] = 0;\n\t\t\tgoAround(x,y,0);\n\t\t\tprintCount();\n\t\t\t\n\t\t\tmaxTurn = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t}\n\n\t}\n\tpublic static boolean isAround(int x1, int y1, int x2, int y2){\n\t\tint x0 = x1 - x2;\n\t\tint y0 = y1 - y2;\n\t\t//ななめ1個ずれ\n\t\tif((x0 == 1 && y0 == 1) || (x0 == -1 && y0 == -1)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tint x = Math.abs(x0);\n\t\tint y = Math.abs(y0);\n\t\t//縦横1個ずれ\n\t\tif((x == 1 && y == 0) || (x == 0 && y == 1)){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic static void goAround(int x, int y, int turn){\n\t\t//System.out.println(\"x = \"+ x + \", y = \" + y);\n\t\t//次のターンで終わりだったら\n\t\tif(turn == maxTurn){\n\t\t\treturn;\n\t\t}\n\t\t//周りを見に行く\n\t\tint sX = x - 1, eX = x + 1, sY = y - 1, eY = y + 1;\n\t\tif(sX == -1){\n\t\t\tsX = 0;\n\t\t}\n\t\tif(eX >= SIZE){\n\t\t\teX = SIZE - 1;\n\t\t}\n\t\tif(sY == -1){\n\t\t\tsY = 0;\n\t\t}\n\t\tif(eY >= SIZE){\n\t\t\teY = SIZE - 1;\n\t\t}\n\t\tfor(int i = sX; i <= eX; i++){\n\t\t\tfor(int j = sY; j <= eY; j++){\n\t\t\t\t//if(isAround(x,y,i,j) && field[i][j] == UNDEF){\n\t\t\t\tif(field[i][j] != UNREA && isAround(x,y,i,j) && turn < numOfTurn[i][j]){\n\t\t\t\t\tfield[i][j] = REA;\n\t\t\t\t\tnumOfTurn[i][j] = turn;\n\t\t\t\t\tgoAround(i,j,turn + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(true){\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if(t+n==0)break;\n            int[][]f = new int[500][500];\n            int offset = f.length/2;\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt()+offset;\n                int y = sc.nextInt()+offset;\n                f[x][y] = -1;\n            }\n            int sx = sc.nextInt()+offset, sy = sc.nextInt()+offset;\n\n            Queue<int[]>q = new LinkedList<int[]>();\n            q.add(new int[]{sx,sy,0});\n            f[sx][sy]=1;\n            int[] v1 = {0,0,1,1,-1,-1};\n            int[] v2 = {-1,1,0,1,0,-1};\n            while(!q.isEmpty()){\n                int x  =q.peek()[0];\n                int y  =q.peek()[1];\n                int ct = q.poll()[2];\n                if(ct==t)continue;\n                for (int i = 0; i < v2.length; i++) {\n                    int xx = x+v1[i];\n                    int yy = y+v2[i];\n                    if(f[xx][yy]==0){\n                        f[xx][yy]=1;\n                        q.add(new int[]{xx,yy,ct+1});\n                    }\n                }\n            }\n            int ans=0;\n            for (int i = 0; i < f.length; i++) {\n                for (int j = 0; j < f[i].length; j++) {\n                    if(f[i][j]==-1)continue;\n                    ans+=f[i][j];\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n    static Deque<Integer> nowX = new ArrayDeque<Integer>();\n    static Deque<Integer> nowY = new ArrayDeque<Integer>();\n    static Scanner scan = new Scanner(System.in);\n    static int ans;\n\n    public static void main(String[] args) {\n        while (scan.hasNext()) {\n            boolean[][] field = new boolean[101][101];\n            int turn = scan.nextInt();\n            int n = scan.nextInt();\n            if (turn == 0) {\n                break;\n            }\n            init(field, n);\n            for (int i = 0; i < turn; i++) {\n                bfs(field);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static void init(boolean field[][], int n) {\n        while (nowX.peek() != null) {\n            nowX.remove();\n            nowY.remove();\n        }\n        for (int i = 0; i < 101; i++) {\n            for (int j = 0; j < 101; j++) {\n                field[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int x1 = scan.nextInt() + 50;\n            int y1 = scan.nextInt() + 50;\n            field[x1][y1] = true;\n        }\n        int x = scan.nextInt() + 50;\n        int y = scan.nextInt() + 50;\n        nowX.add(x);\n        nowY.add(y);\n        ans = 1;\n        field[x][y] = true;\n    }\n\n    static void bfs(boolean field[][]) {\n        Deque<Integer> nextX = new ArrayDeque<Integer>();\n        Deque<Integer> nextY = new ArrayDeque<Integer>();\n        int[] dx = {0, 1, 1, 0, -1, -1};\n        int[] dy = {1, 1, 0, -1, -1, 0};\n        while (nowX.peek() != null) {\n            int x = nowX.remove();\n            int y = nowY.remove();\n            for (int i = 0; i < 6; i++) {\n                if (check(x+dx[i]) && check(y+dy[i]) && \n                        !field[x+dx[i]][y+dy[i]]) {\n                    ans++;\n                    field[x+dx[i]][y+dy[i]] = true;\n                    //System.out.println(x+dx[i]);\n                    //System.out.println(y+dy[i]);\n                    nextX.add(x+dx[i]);\n                    nextY.add(y+dy[i]);\n                }\n            }\n        }\n        nowX = nextX;\n        nowY = nextY;\n    }\n\n    static boolean check(int a) {\n        if (0 <= a && a <= 100) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static int map[][];\n\tpublic static int t, n;\n\tpublic static int dx[] = {0,1,1,0,-1,-1};\n\tpublic static int dy[] = {1,1,0,-1,-1,0};\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tt = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (t == 0 && n ==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[100][100];\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[sc.nextInt() + 50][sc.nextInt() + 50] = -1;\n\t\t\t}\n\t\t\tQueue<Integer[]> que = new ArrayDeque<Integer[]>();\n\t\t\tint nx = sc.nextInt() + 50;\n\t\t\tint ny = sc.nextInt() + 50;\n\t\t\tque.add(new Integer[]{nx, ny});\n\t\t\tmap[nx][ny] = 0;\n\t\t\twhile (que.size()!=0) {\n\t\t\t\tInteger[] now = que.poll();\n\t\t\t\tint x = now[0];\n\t\t\t\tint y = now[1];\n\t\t\t\tif (map[x][y] >= t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\t\tif (map[x + dx[i]][y + dy[i]] > map[x][y] + 1) {\n\t\t\t\t\t\tmap[x + dx[i]][y + dy[i]] = map[x][y] + 1;\n\t\t\t\t\t\tque.add(new Integer[]{x + dx[i],y + dy[i]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (map[i][j] >= 0 && map[i][j] != 1 << 30) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if ((t | n) == 0)\n                break;\n            int[][] map = new int[121][121];\n            boolean[][] visited = new boolean[121][121];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                map[y + 60][x + 60] = -1;\n            }\n            Queue<Point> q = new LinkedList<Point>();\n            int sx = sc.nextInt() + 60;\n            int ans = 0;\n            int sy = sc.nextInt() + 60;\n            q.add(new Point(sx, sy));\n            visited[sy][sx] = true;\n            while (!q.isEmpty()) {\n                Point p = q.poll();\n                int x = p.x;\n                int y = p.y;\n                if (map[y][x] > t)\n                    continue;\n                ans++;\n                int dx[] = { 1, 1, 0, -1, -1, 0 };\n                int dy[] = { 0, 1, 1, 0, -1, -1 };\n                for (int i = 0; i < 6; i++) {\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if (nx >= 0 && ny >= 0 && ny < 121 && nx < 121\n                            && map[ny][nx] != -1) {\n                        if (visited[ny][nx]) {\n                            continue;\n                        }\n                        visited[ny][nx] = true;\n                        map[ny][nx] = map[y][x] + 1;\n                        q.add(new Point(nx, ny));\n                    }\n                }\n            }\n            System.out.println(ans);\n//            for (int i = 0; i <= 60; i++) {\n//                System.out.println(Arrays.toString(map[i]));\n//            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 2253 \"ブレイブ・フォース・ストーリー\" (ICPC模擬国内予選 2011 Problem B)\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int t = sc.nextInt();\n            int n = sc.nextInt();\n            if (t == 0) {\n                break;\n            }\n            \n            int[][] field = new int[121][121];\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                field[y+60][x+60] = -1;\n            }\n            int sx = sc.nextInt() + 60;\n            int sy = sc.nextInt() + 60;\n            debug(field);\n            int[] dx = {0, 1, 1, 0, -1, -1};\n            int[] dy = {1, 1, 0, -1, -1, 0};\n            Queue<Field> que = new LinkedList<Field>();\n            que.offer(new Field(sx, sy));\n            while (que.peek() != null) {\n                Field tmp = que.poll();\n                int tmpx = tmp.x;\n                int tmpy = tmp.y;\n                if (field[tmpy][tmpx] == t) {\n                    continue;\n                }\n                for (int i = 0; i < dx.length; i++) {\n                    int nx = tmpx + dx[i];\n                    int ny = tmpy + dy[i];\n                    if (0 <= ny && ny < field.length && 0 <= nx && nx < field[ny].length\n                        && field[ny][nx] == 0 && !(nx == sx && ny == sy)) {\n                        que.offer(new Field(nx, ny));\n                        field[ny][nx] = field[tmpy][tmpx] + 1;\n                    }\n                }\n            }\n            \n            int count = 0;\n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length; j++) {\n                    if (field[i][j] > 0 && field[i][j] <= t) {\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count + 1);\n            debug(field);\n        }\n    }\n    \n    static void debug(int[][] field) {\n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[i].length; j++) {\n                System.out.print(field[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass Field {\n    int x;\n    int y;\n    Field(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 1, 0, 0, -1, -1 };\n\tint[] dy = { 1, 0, -1, 1, 0, -1 };\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\t\t\tint t = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((t | n) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] visit = new int[100][100];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt() + 50;\n\t\t\t\tint y = sc.nextInt() + 50;\n\t\t\t\tvisit[y][x] = -1;\n\t\t\t}\n\t\t\tint sx = sc.nextInt() + 50;\n\t\t\tint sy = sc.nextInt() + 50;\n\t\t\tvisit[sy][sx] = 1;\n\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sx, sy));\n\t\t\tint turn = 0;\n\t\t\twhile (!que.isEmpty() && turn++ < t) {\n\t\t\t\tint size = que.size();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tPos now = que.poll();\n\t\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\t\tint nextX = now.x + dx[j];\n\t\t\t\t\t\tint nextY = now.y + dy[j];\n\t\t\t\t\t\tif (visit[nextY][nextX] == 0) {\n\t\t\t\t\t\t\tvisit[nextY][nextX] = 1;\n\t\t\t\t\t\t\tque.add(new Pos(nextX, nextY));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tif (visit[i][j] == 1) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint x;\n\t\tint y;\n\n\t\t/**\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tpublic Pos(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int lim) {\n\t\treturn 0 <= h && h < lim && 0 <= w && w < lim;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Brave Force Story\n */\npublic class Main {\n\n\tstatic final int MAX = 60;\n\tstatic final int[] H = new int[]{1, 1, 0, -1, -1, 0};\n\tstatic final int[] V = new int[]{1, 0, -1, -1, 0, 1};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tP2253 main = new P2253();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint t, n;\n\t\t\tt = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((t | n) == 0) break;\n\n\t\t\tboolean[][][] obs = new boolean[4][31][31];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tint x, y;\n\t\t\t\tint[] q;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tq = quadrant(x, y);\n\t\t\t\tobs[q[0]][q[1]][q[2]] = true;\n\t\t\t}\n\n\t\t\tline = br.readLine();\n\t\t\tint sx, sy;\n\t\t\tint[] sq;\n\t\t\tsx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tsy = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tsq = quadrant(sx, sy);\n\n\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\tint count = 0;\n\n\t\t\tqueue.offer(new int[]{0, sq[0], sq[1], sq[2]});\n\t\t\tobs[sq[0]][sq[1]][sq[2]] = true;\n\t\t\tcount++;\n\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint[] pq = queue.poll();\n\t\t\t\tint[] p = dequadrant(pq[1], pq[2], pq[3]);\n\t\t\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tint[] nq;\n\t\t\t\t\tnx = p[0] + H[i];\n\t\t\t\t\tny = p[1] + V[i];\n\t\t\t\t\tnq = quadrant(nx, ny);\n\t\t\t\t\tif (pq[0] < t && Math.abs(nx) <= MAX && ny <= MAX && !obs[nq[0]][nq[1]][nq[2]]) {\n\t\t\t\t\t\tqueue.offer(new int[]{pq[0] + 1, nq[0], nq[1], nq[2]});\n\t\t\t\t\t\tobs[nq[0]][nq[1]][nq[2]] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}//end while\n\t}//end main\n\n\t//quadrant I:    x >= 0, y >= 0\n\t//quadrant II:   x <  0, y >= 0\n\t//quadrant III:  x <  0, y <  0\n\t//quadrant IV:   x >= 0, y <  0\n\tstatic int[] quadrant(int x, int y) {\n\t\tint o = 0;\n\t\tif (0 <= x && 0 <= y) {\n\t\t\to = 0;\n\t\t} else if (x < 0 && 0 <= y) {\n\t\t\to = 1;\n\t\t} else if (x < 0 && y < 0) {\n\t\t\to = 2;\n\t\t} else {\n\t\t\to = 3;\n\t\t}\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn new int[]{o, x, y};\n\t}\n\n\tstatic int[] dequadrant(int o, int x, int y) {\n\t\tif (o == 1) {\n\t\t\tx = -x;\n\t\t} else if (o == 2) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t} else if (o == 3) {\n\t\t\ty = -y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tclass Point {\n\t\tint x, y;\n\t\tint o, ox, oy;\n\n\t\tPoint(int x, int y) {\n\t\t\tif (0 <= x && 0 <= y) {\n\t\t\t\to = 0;\n\t\t\t} else if (x < 0 && 0 <= y) {\n\t\t\t\to = 1;\n\t\t\t} else if (x < 0 && y < 0) {\n\t\t\t\to = 2;\n\t\t\t} else {\n\t\t\t\to = 3;\n\t\t\t}\n\t\t\tox = Math.abs(x);\n\t\t\toy = Math.abs(y);\n\t\t}\n\n\t\tPoint(int o, int ox, int oy) {\n\t\t\tif (o == 1) {\n\t\t\t\tx = -x;\n\t\t\t} else if (o == 2) {\n\t\t\t\tx = -x;\n\t\t\t\ty = -y;\n\t\t\t} else if (o == 3) {\n\t\t\t\ty = -y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p2253;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tstatic class Point {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Point() {\n\t\t}\n\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = Math.max(Math.min(x, 30), -30);\n\t\t\tthis.y = Math.max(Math.min(y, 30), -30);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Point) {\n\t\t\t\tPoint p = (Point) obj;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn x + 37 * y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n\t}\n\n\tHashMap<Point, Integer> pmap;\n\n\tstatic Point[] dir;\n\tstatic {\n\t\tdir = new Point[] { new Point(1, 0), new Point(1, 1), new Point(0, 1),\n\t\t\t\tnew Point(-1, 0), new Point(-1, -1), new Point(0, -1) };\n\t}\n\tint x, y;\n\tint t, n;\n\tint count;\n\n\tvoid move(Point p, int turn) {\n\t\tif ((pmap.get(p) == null || pmap.get(p) > turn) && turn <= t) {\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tPoint _p = new Point();\n\t\t\t\t_p.x = p.x + dir[i].x;\n\t\t\t\t_p.y = p.y + dir[i].y;\n\t\t\t\tmove(_p, turn + 1);\n\t\t\t}\n\t\t\tpmap.put(p, turn);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n//\t\t\tn = 0;\n//\t\t\tpmap = new HashMap<Point, Integer>();\n//\t\t\tt = sc.nextInt();\n//\t\t\tn = sc.nextInt();\n//\t\t\tif (t == 0 && n == 0) {\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tPoint p = new Point();\n//\t\t\t\tp.x = sc.nextInt();\n//\t\t\t\tp.y = sc.nextInt();\n//\t\t\t\tpmap.put(p, -2);\n//\t\t\t}\n//\t\t\tPoint zero = new Point();\n//\t\t\tzero.x = sc.nextInt();\n//\t\t\tzero.y = sc.nextInt();\n//\t\t\tmove(zero, 0);\n//\t\t\tcount = 0;\n//\t\t\tif (pmap.size() > 0) {\n//\t\t\t\tfor (Entry<Point, Integer> p : pmap.entrySet()) {\n//\t\t\t\t\tif (p.getValue() >= 0) {\n//\t\t\t\t\t\tcount++;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tpr(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "//#define READ_FILE72\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nusing CHY72;\n\n\n\nnamespace CHY72{\n    \n    public class PointXY{\n        public int X , Y;\n        public int SQLength() { return X * X + Y * Y; }\n        public bool Flag = false;\n        public int ID = -1;\n        public PointXY(int _X,int _Y,int _ID = 0) {\n            X = _X; Y = _Y; ID = _ID;\n        }\n        public PointXY(PointXY P1, int _X = 0, int _Y = 0,int _ID = -1) {\n            X = P1.X + _X; Y = P1.Y + _Y; ID = _ID;\n        }\n        public static bool operator ==(PointXY P1, PointXY P2) {\n            return (P1.X== P2.X && P1.Y == P2.Y);\n        }\n        public static bool operator !=(PointXY P1, PointXY P2) {return !(P1 ==P2);}\n        public override int GetHashCode() {return X.GetHashCode() ^ Y.GetHashCode();}\n        public override bool Equals(object obj) {\n            if (obj == null || this.GetType() != obj.GetType()) {return false;}\n            return (this == (PointXY)obj);\n        }\n        public string CurrentInformation() {\n            return \"x:\" + X + \"  y:\" + Y + \"  ID:\" + ID;\n        } \n\n    }\n\n    public class Lib72 {\n        public static int NumFromChar(char CNUM) { return CNUM - 48; }\n        public static char LoopChar52(char _C, int n) {\n            //Char(C#) uses Uni-Code\n            //33 !  \"#$%&'(  41 )\n            //42 * +,-.  47/\n            //48 0  .... 57 9\n            //58 :;<=>? 64 @\n            //65 A .... 90 Z\n            //91 [\\]^_ 96`\n            //97 a .... 122 z\n            int i_C = (int)_C;\n            if (i_C > 64 && i_C < 91) i_C -= 65;//0~25 AZ\n            else if (i_C > 96 && i_C < 123) i_C -= 71;//26~51 az\n            else return '0';\n            int RESULT = Modulo ((i_C + n ) , 52);\n            if(RESULT < 26) return (char)(RESULT+65);\n            else return (char)(RESULT + 71);\n        }\n        public static int Modulo(int A, int B)  {\n            // -6 % 5 == -1\n            // -6 % 5 == 4\n            int Result = A % B;\n            if (Result >= 0) { return Result; }\n            else return Result + B;\n        }\n        public static int intFromHourMinSec(int _h,int _m,int _s) {\n            return _s + 60 * _m + 3600 * _h;\n        }\n\n        public static int[] KETAArray(int Num) {return KETAArray(Num.ToString()); }\n        public static int[] KETAArray(string Num) {\n            char[] cKETA = Num.ToCharArray();\n            int[] iKETA = new int[cKETA.Length];\n            for (int i = 0; i < iKETA.Length; i++) {\n                iKETA[i] = NumFromChar(cKETA[i]);\n            }\n            return iKETA;\n        }\n        public static int KETA(int Num) { return Num.ToString().ToCharArray().Length; }\n        public static int FromKETAArray(int[] _ketaarray) {\n            int result = 0;\n            int[] R_ketaarray = _ketaarray.Reverse().ToArray(); \n            for (int i = 0,j=1; i < R_ketaarray.Length; i++,j *=10) {\n                result += j * R_ketaarray[i];\n            }\n            return result;\n        }\n        public static bool isPrime(int p) {\n            if (p != 2 && p % 2 == 0) return false;\n            if (p == 1) return false;\n            int SQp = (int)(Math.Sqrt(p));\n            for (int i = 3; i <= SQp; i++) {\n                if (p % i == 0) return false;\n            }\n            return true;\n        } \n    }\n}    \n\npublic class Program {\n    static bool ReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int  ReadLine_1() {\n        return  int.Parse(Console.ReadLine());\n    }\n    static bool ReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true,int FinNum =0) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] ReadLine_Array(char Spliter = ' ') {\n        return Console.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n\n\n\n    const int DefaultMax = 72727272;\n\n\n    static void Main(string[] args) {\n\n\n        Main72();\n\n\n    }\n\n    static void Main72() {\n        while (true) {\n            int t = 0, n = 0;\n            if (ReadLine_2(ref t, ref n)) return;\n            bool[,] Searched = new bool[72, 72];\n            \n            for (int i = 0; i < n; i++) {\n                int _X = 0, _Y = 0;\n                ReadLine_2(ref _X,ref _Y);\n                Searched[_X +36,_Y +36] = true; \n            }\n            int ___X = 0, ___Y = 0;\n            ReadLine_2(ref ___X, ref ___Y);\n            PointXY StartPos = new PointXY(___X + 36, ___Y + 36, 0);\n            Queue<PointXY> MyPos = new Queue<PointXY>(); \n            MyPos.Enqueue(StartPos );\n            int Searching = 0;\n            \n            Searched[StartPos.X, StartPos.Y] = true;\n            int Answer = 1;\n            while (MyPos.Count > 0 ) {\n                var CurrentPos = MyPos.Dequeue();\n                Searching = CurrentPos.ID;\n                if (Searching == t) break;\n                Searching++;\n                \n                //Console.WriteLine(CurrentPos.CurrentInformation ());\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, 0, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 0, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X, CurrentPos.Y - 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, -1, Searching));\n                    Searched[CurrentPos.X, CurrentPos.Y - 1] = true;\n                }\n                if (!Searched[CurrentPos.X , CurrentPos.Y + 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, 1, Searching));\n                    Searched[CurrentPos.X , CurrentPos.Y + 1] = true;\n                }\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y -1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, -1, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y-1] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y+1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 1, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y + 1] = true;\n                }\n            }\n            Console.WriteLine(Answer);\n\n        }\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "//#define READ_FILE72\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nusing CHY72;\n\n\n\nnamespace CHY72{\n    \n    public class PointXY{\n        public int X , Y;\n        public int SQLength() { return X * X + Y * Y; }\n        public bool Flag = false;\n        public int ID = -1;\n        public PointXY(int _X,int _Y,int _ID = 0) {\n            X = _X; Y = _Y; ID = _ID;\n        }\n        public PointXY(PointXY P1, int _X = 0, int _Y = 0,int _ID = -1) {\n            X = P1.X + _X; Y = P1.Y + _Y; ID = _ID;\n        }\n        public static bool operator ==(PointXY P1, PointXY P2) {\n            return (P1.X== P2.X && P1.Y == P2.Y);\n        }\n        public static bool operator !=(PointXY P1, PointXY P2) {return !(P1 ==P2);}\n        public override int GetHashCode() {return X.GetHashCode() ^ Y.GetHashCode();}\n        public override bool Equals(object obj) {\n            if (obj == null || this.GetType() != obj.GetType()) {return false;}\n            return (this == (PointXY)obj);\n        }\n        public string CurrentInformation() {\n            return \"x:\" + X + \"  y:\" + Y + \"  ID:\" + ID;\n        } \n\n    }\n\n    public class Lib72 {\n        public static int NumFromChar(char CNUM) { return CNUM - 48; }\n        public static char LoopChar52(char _C, int n) {\n            //Char(C#) uses Uni-Code\n            //33 !  \"#$%&'(  41 )\n            //42 * +,-.  47/\n            //48 0  .... 57 9\n            //58 :;<=>? 64 @\n            //65 A .... 90 Z\n            //91 [\\]^_ 96`\n            //97 a .... 122 z\n            int i_C = (int)_C;\n            if (i_C > 64 && i_C < 91) i_C -= 65;//0~25 AZ\n            else if (i_C > 96 && i_C < 123) i_C -= 71;//26~51 az\n            else return '0';\n            int RESULT = Modulo ((i_C + n ) , 52);\n            if(RESULT < 26) return (char)(RESULT+65);\n            else return (char)(RESULT + 71);\n        }\n        public static int Modulo(int A, int B)  {\n            // -6 % 5 == -1\n            // -6 % 5 == 4\n            int Result = A % B;\n            if (Result >= 0) { return Result; }\n            else return Result + B;\n        }\n        public static int intFromHourMinSec(int _h,int _m,int _s) {\n            return _s + 60 * _m + 3600 * _h;\n        }\n\n        public static int[] KETAArray(int Num) {return KETAArray(Num.ToString()); }\n        public static int[] KETAArray(string Num) {\n            char[] cKETA = Num.ToCharArray();\n            int[] iKETA = new int[cKETA.Length];\n            for (int i = 0; i < iKETA.Length; i++) {\n                iKETA[i] = NumFromChar(cKETA[i]);\n            }\n            return iKETA;\n        }\n        public static int KETA(int Num) { return Num.ToString().ToCharArray().Length; }\n        public static int FromKETAArray(int[] _ketaarray) {\n            int result = 0;\n            int[] R_ketaarray = _ketaarray.Reverse().ToArray(); \n            for (int i = 0,j=1; i < R_ketaarray.Length; i++,j *=10) {\n                result += j * R_ketaarray[i];\n            }\n            return result;\n        }\n        public static bool isPrime(int p) {\n            if (p != 2 && p % 2 == 0) return false;\n            if (p == 1) return false;\n            int SQp = (int)(Math.Sqrt(p));\n            for (int i = 3; i <= SQp; i++) {\n                if (p % i == 0) return false;\n            }\n            return true;\n        } \n    }\n}    \n\npublic class Program {\n    static bool ReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int  ReadLine_1() {\n        return  int.Parse(Console.ReadLine());\n    }\n    static bool ReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true,int FinNum =0) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] ReadLine_Array(char Spliter = ' ') {\n        return Console.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n\n#if READ_FILE72\n    static bool FileReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int FileReadLine_1() {\n        return int.Parse(cReader.ReadLine());\n    }\n    static bool FileReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true, int FinNum = 0) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] FileReadLine_Array(char Spliter = ' ') {\n        return cReader.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n    \n    static System.IO.StreamReader cReader ;\n#endif\n\n    const int DefaultMax = 72727272;\n\n\n    static void Main(string[] args) {\n        #if READ_FILE72  \n            cReader = new System.IO.StreamReader(System.IO.Directory.GetCurrentDirectory() + \"\\\\Read.txt\", System.Text.Encoding.Unicode);\n        #endif\n\n        Main72();\n\n        #if READ_FILE72\n            cReader.Close();\n        #endif\n    }\n\n    static void Main72() {\n        while (true) {\n            int t = 0, n = 0;\n            if (ReadLine_2(ref t, ref n)) return;\n            bool[,] Searched = new bool[72, 72];\n            \n            for (int i = 0; i < n; i++) {\n                int _X = 0, _Y = 0;\n                ReadLine_2(ref _X,ref _Y);\n                Searched[_X +36,_Y +36] = true; \n            }\n            int ___X = 0, ___Y = 0;\n            ReadLine_2(ref ___X, ref ___Y);\n            PointXY StartPos = new PointXY(___X + 36, ___Y + 36, 0);\n            Queue<PointXY> MyPos = new Queue<PointXY>(); \n            MyPos.Enqueue(StartPos );\n            int Searching = 0;\n            \n            Searched[StartPos.X, StartPos.Y] = true;\n            int Answer = 1;\n            while (MyPos.Count > 0 ) {\n                var CurrentPos = MyPos.Dequeue();\n                Searching = CurrentPos.ID;\n                if (Searching == t) break;\n                Searching++;\n                \n                //Console.WriteLine(CurrentPos.CurrentInformation ());\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, 0, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 0, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X, CurrentPos.Y - 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, -1, Searching));\n                    Searched[CurrentPos.X, CurrentPos.Y - 1] = true;\n                }\n                if (!Searched[CurrentPos.X , CurrentPos.Y + 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, 1, Searching));\n                    Searched[CurrentPos.X , CurrentPos.Y + 1] = true;\n                }\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y -1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, -1, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y-1] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y+1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 1, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y + 1] = true;\n                }\n            }\n            Console.WriteLine(Answer);\n\n        }\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "//#define READ_FILE72\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nusing CHY72;\n\n\n\nnamespace CHY72{\n    \n    public class PointXY{\n        public int X , Y;\n        public int SQLength() { return X * X + Y * Y; }\n        public bool Flag = false;\n        public int ID = -1;\n        public PointXY(int _X,int _Y,int _ID = 0) {\n            X = _X; Y = _Y; ID = _ID;\n        }\n        public PointXY(PointXY P1, int _X = 0, int _Y = 0,int _ID = -1) {\n            X = P1.X + _X; Y = P1.Y + _Y; ID = _ID;\n        }\n        public static bool operator ==(PointXY P1, PointXY P2) {\n            return (P1.X== P2.X && P1.Y == P2.Y);\n        }\n        public static bool operator !=(PointXY P1, PointXY P2) {return !(P1 ==P2);}\n        public override int GetHashCode() {return X.GetHashCode() ^ Y.GetHashCode();}\n        public override bool Equals(object obj) {\n            if (obj == null || this.GetType() != obj.GetType()) {return false;}\n            return (this == (PointXY)obj);\n        }\n        public string CurrentInformation() {\n            return \"x:\" + X + \"  y:\" + Y + \"  ID:\" + ID;\n        } \n\n    }\n\n    public class Lib72 {\n        public static int NumFromChar(char CNUM) { return CNUM - 48; }\n        public static char LoopChar52(char _C, int n) {\n            //Char(C#) uses Uni-Code\n            //33 !  \"#$%&'(  41 )\n            //42 * +,-.  47/\n            //48 0  .... 57 9\n            //58 :;<=>? 64 @\n            //65 A .... 90 Z\n            //91 [\\]^_ 96`\n            //97 a .... 122 z\n            int i_C = (int)_C;\n            if (i_C > 64 && i_C < 91) i_C -= 65;//0~25 AZ\n            else if (i_C > 96 && i_C < 123) i_C -= 71;//26~51 az\n            else return '0';\n            int RESULT = Modulo ((i_C + n ) , 52);\n            if(RESULT < 26) return (char)(RESULT+65);\n            else return (char)(RESULT + 71);\n        }\n        public static int Modulo(int A, int B)  {\n            // -6 % 5 == -1\n            // -6 % 5 == 4\n            int Result = A % B;\n            if (Result >= 0) { return Result; }\n            else return Result + B;\n        }\n        public static int intFromHourMinSec(int _h,int _m,int _s) {\n            return _s + 60 * _m + 3600 * _h;\n        }\n\n        public static int[] KETAArray(int Num) {return KETAArray(Num.ToString()); }\n        public static int[] KETAArray(string Num) {\n            char[] cKETA = Num.ToCharArray();\n            int[] iKETA = new int[cKETA.Length];\n            for (int i = 0; i < iKETA.Length; i++) {\n                iKETA[i] = NumFromChar(cKETA[i]);\n            }\n            return iKETA;\n        }\n        public static int KETA(int Num) { return Num.ToString().ToCharArray().Length; }\n        public static int FromKETAArray(int[] _ketaarray) {\n            int result = 0;\n            int[] R_ketaarray = _ketaarray.Reverse().ToArray(); \n            for (int i = 0,j=1; i < R_ketaarray.Length; i++,j *=10) {\n                result += j * R_ketaarray[i];\n            }\n            return result;\n        }\n        public static bool isPrime(int p) {\n            if (p != 2 && p % 2 == 0) return false;\n            if (p == 1) return false;\n            int SQp = (int)(Math.Sqrt(p));\n            for (int i = 3; i <= SQp; i++) {\n                if (p % i == 0) return false;\n            }\n            return true;\n        } \n    }\n}    \n\npublic class Program {\n    static bool ReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int  ReadLine_1() {\n        return  int.Parse(Console.ReadLine());\n    }\n    static bool ReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true,int FinNum =0) {\n        string str = Console.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] ReadLine_Array(char Spliter = ' ') {\n        return Console.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n\n#if READ_FILE72\n    static bool FileReadLine_1(ref int num1, bool Fin0 = true) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str);\n        return (Fin0 && num1 == 0);\n    }\n    static int FileReadLine_1() {\n        return int.Parse(cReader.ReadLine());\n    }\n    static bool FileReadLine_2(ref int num1, ref int num2, char Spliter = ' ', bool Fin0 = true, int FinNum = 0) {\n        string str = cReader.ReadLine();\n        num1 = int.Parse(str.Split(Spliter)[0]);\n        num2 = int.Parse(str.Split(Spliter)[1]);\n        return (Fin0 && num1 == FinNum && num2 == FinNum);\n    }\n    static int[] FileReadLine_Array(char Spliter = ' ') {\n        return cReader.ReadLine().Split(Spliter).Select(s => int.Parse(s)).ToArray();\n    }\n    \n    static System.IO.StreamReader cReader ;\n#endif\n\n    const int DefaultMax = 72727272;\n\n\n    static void Main(string[] args) {\n        #if READ_FILE72  \n            cReader = new System.IO.StreamReader(System.IO.Directory.GetCurrentDirectory() + \"\\\\Read.txt\", System.Text.Encoding.Unicode);\n        #endif\n\n        Main72();\n\n        #if READ_FILE72\n            cReader.Close();\n        #endif\n    }\n\n    static void Main72() {\n        while (true) {\n            int t = 0, n = 0;\n            if (ReadLine_2(ref t, ref n)) return;\n            bool[,] Searched = new bool[720, 720];\n            \n            for (int i = 0; i < n; i++) {\n                int _X = 0, _Y = 0;\n                ReadLine_2(ref _X,ref _Y);\n                Searched[_X +360,_Y +360] = true; \n            }\n            int ___X = 0, ___Y = 0;\n            ReadLine_2(ref ___X, ref ___Y);\n            PointXY StartPos = new PointXY(___X + 360, ___Y + 360, 0);\n            Queue<PointXY> MyPos = new Queue<PointXY>(); \n            MyPos.Enqueue(StartPos );\n            int Searching = 0;\n            \n            Searched[StartPos.X, StartPos.Y] = true;\n            int Answer = 1;\n            while (MyPos.Count > 0 ) {\n                var CurrentPos = MyPos.Dequeue();\n                Searching = CurrentPos.ID;\n                if (Searching == t) break;\n                Searching++;\n                \n                //Console.WriteLine(CurrentPos.CurrentInformation ());\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, 0, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 0, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y] = true;\n                }\n                if (!Searched[CurrentPos.X, CurrentPos.Y - 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, -1, Searching));\n                    Searched[CurrentPos.X, CurrentPos.Y - 1] = true;\n                }\n                if (!Searched[CurrentPos.X , CurrentPos.Y + 1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 0, 1, Searching));\n                    Searched[CurrentPos.X , CurrentPos.Y + 1] = true;\n                }\n                if (!Searched[CurrentPos.X - 1, CurrentPos.Y -1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, -1, -1, Searching));\n                    Searched[CurrentPos.X - 1, CurrentPos.Y-1] = true;\n                }\n                if (!Searched[CurrentPos.X + 1, CurrentPos.Y+1]) {\n                    Answer++;\n                    MyPos.Enqueue(new PointXY(CurrentPos, 1, 1, Searching));\n                    Searched[CurrentPos.X + 1, CurrentPos.Y + 1] = true;\n                }\n            }\n            Console.WriteLine(Answer);\n\n        }\n    }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,t){\n   if(obj.hasOwnProperty(x+\",\"+y)==true && obj[x+\",\"+y]>=t)return;\n   obj[x+\",\"+y]=t;\n   if(t==0)return;\n   var dx=[0,1,1,0,-1,-1];\n   var dy=[1,1,0,-1,-1,0];\n   for(var i=0;i<6;i++){\n      if(xy[x+dx[i]][y+dy[i]]==0)bomb(x+dx[i],y+dy[i],t-1);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var tn=arr.shift();\n   if(tn==\"0 0\")break;\n   tn=tn.split(\" \").map(Number);\n   var xy=[];\n   for(var x=0;x<200;x++){\n      xy[x]=[];\n      for(var y=0;y<200;y++){\n         xy[x][y]=0;\n      }\n   }\n   while(tn[1]--){\n      var wall=arr.shift().split(\" \").map(Number);\n      var x=wall[0]+100;\n      var y=wall[1]+100;\n      xy[x][y]=1;\n   }\n   var start=arr.shift().split(\" \").map(Number);\n   var obj={};\n   bomb(start[0]+100,start[1]+100,tn[0]);\n   console.log(Object.keys(obj).length);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(x,y,t){\n   obj[x+\",\"+y]=true;\n   if(t==0)return;\n   var dx=[0,1,1,0,-1,-1];\n   var dy=[1,1,0,-1,-1,0];\n   for(var i=0;i<6;i++){\n      if(xy[x+dx[i]][y+dy[i]]==0)bomb(x+dx[i],y+dy[i],t-1);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var tn=arr.shift();\n   if(tn==\"0 0\")break;\n   tn=tn.split(\" \").map(Number);\n   var xy=[];\n   for(var x=0;x<200;x++){\n      xy[x]=[];\n      for(var y=0;y<200;y++){\n         xy[x][y]=0;\n      }\n   }\n   while(tn[1]--){\n      var wall=arr.shift().split(\" \").map(Number);\n      var x=wall[0]+100;\n      var y=wall[1]+100;\n      xy[x][y]=1;\n   }\n   var start=arr.shift().split(\" \").map(Number);\n   var obj={};\n   bomb(start[0]+100,start[1]+100,tn[0]);\n   console.log(Object.keys(obj).length);\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n            end\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_neighbour_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\nend\n\nloop {\n\tt, n = gets.split.map &:to_i\n\tbreak if t == 0\n\tg = (0..120).map { [0] * 120 }\n\tn.times {\n\t\tx, y = gets.split.map &:to_i\n\t\tg[x+60][y+60] = 1\n\t}\n\n\tg.extend Graphical\n\t$diff = [[1,0], [1,1], [0,1], [-1,0], [-1,-1], [0,-1]]\n\tdef g.each_neighbour_of(u)\n\t\tx1, y1 = u\n\t\t$diff.each{|dx, dy|\n\t\t\tx2, y2 = x1+dx, y1+dy\n\t\t\tnext if self[x2][y2] == 1\n\t\t\tyield [x2, y2] \n\t\t}\n\tend\n\n\tsx, sy = gets.split.map &:to_i\n\tp g.reachable_from([sx+60, sy+60], t).size\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n                break\n            end\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "Ruby",
    "code": "dx = [0,1,0,-1,1,-1]\ndy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = Array.new(200).map{Array.new(200,false)}\n    visited[sy+50][sx+50] = true\n    count = 1\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + dy[i]\n                cx = sx + dx[i]\n                if !blocks.include?([cy,cx]) && !visited[cy+50][cx+50]\n                    q2.push([cy,cx])\n                    visited[cy+50][cx+50] = true\n                    count += 1\n                end\n            end\n        end\n        q = q2\n    end\n    puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, -1], [-1, 0], [0, 1], [1, 1], [1, 0], [0, -1]]\nloop do\n  t, n = gets.split.map(&:to_i)\n  break if t == 0\n  fld = 61.times.map{ [0] * 61 }\n  n.times{ r, c = gets.split.map(&:to_i); fld[r + 30][c + 30] = false }\n  ar = []\n  ar << [*gets.split.map(&:to_i).map{ |a| a + 30 }, 0]\n  until ar.empty?\n    y, x, step = ar.shift\n    fld[y][x] = 1\n    if step < t\n      D.each do |my, mx|\n        p, q = y + my, x + mx\n        if fld[p][q] == 0\n          ar << [p, q, step + 1]\n        end\n      end\n    end\n  end\n  p fld.flatten.count{ |f| f == 1 }\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, -1], [-1, 0], [0, 1], [1, 1], [1, 0], [0, -1]]\nloop do\n  t, n = gets.split.map(&:to_i)\n  break if t == 0\n  fld = 128.times.map{ [0] * 128 }\n  n.times{ c, r = gets.split.map(&:to_i); fld[r + 64][c + 64] = false }\n  sx, sy = gets.split.map(&:to_i).map{ |a| a + 64 }\n  pts = 2.times.map{ [] }\n  pts[0] << [sy, sx]\n  fld[sy][sx] = 1\n  t.times do\n    pts[0].each do |y, x|\n      D.each do |mx, my|\n        p, q = y + my, x + mx\n        if fld[p][q] == 0\n          pts[1] << [p, q]\n          fld[p][q] = 1\n        end\n      end\n    end\n    pts[0], pts[1] = pts[1], []\n  end\n  p fld.flatten.count{ |f| f == 1 }\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\ndef bfs(sy, sx, t, blocks)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    count = 1\n    t.times do\n        q2 = []\n        while q.size > 0\n            sy, sx = q.shift\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                    count += 1\n                end\n            end\n        end\n        q = q2\n    end\n    return count\nend\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    puts bfs(sy, sx, t, blocks)\nend"
  },
  {
    "language": "Ruby",
    "code": "dx = [0,1,0,-1,1,-1]\ndy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = Array.new(200).map{Array.new(200,false)}\n    visited[sy+50][sx+50] = true\n    bl = Array.new(200).map{Array.new(200,false)}\n    blocks.each do |b1, b2|\n        bl[b1+50][b2+50] = true\n    end\n    count = 1\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + dy[i]\n                cx = sx + dx[i]\n                if !bl[cy+50][cx+50] && !visited[cy+50][cx+50]\n                    q2.push([cy,cx])\n                    visited[cy+50][cx+50] = true\n                    count += 1\n                end\n            end\n        end\n        q = q2\n    end\n    puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\ndef bfs(sy, sx, t, blocks)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    steps = Array.new((t+1)*3).map{Array.new((t+1)*3,0)}\n    steps[sy][sx] = 1\n    count = 1\n    while q.size > 0\n        sy, sx = q.shift\n        next if steps[sy][sx] > t\n        for i in 0..5\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if !blocks.include?([cy,cx]) && steps[cy][cx] == 0\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                steps[cy][cx] = steps[sy][sx] + 1\n                count += 1\n            end\n        end\n    end\n    return count\nend\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i + t}}\n    sy, sx = gets.split.map(&:to_i)\n    puts bfs(sy + t, sx + t, t, blocks)\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    next\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n            end\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "Ruby",
    "code": "SX = 100\nSY = 100\ndx = [-1, -1, 0, 0, 1, 1]\ndy = [-1, 0, -1, 1, 0, 1]\n\nloop do\n  t, n = gets.chomp.split.map(&:to_i)\n\n  if t | n == 0\n    break\n  end\n\n  visited = Array.new(200) {\n    Array.new(200, 0)\n  }\n\n  field = Array.new(200) {\n    Array.new(200, 0)\n  }\n  \n  n.times do\n    x, y = gets.chomp.split.map(&:to_i)\n    field[y + SY][x + SX] = 1\n  end\n\n  sx, sy = gets.chomp.split.map(&:to_i)\n  sx += SX\n  sy += SY\n\n  queue = [[sx, sy, 0]]\n  visited[sy][sx] = 1\n\n  while !queue.empty? do\n    tmp = queue.shift\n\n    if tmp[2] + 1 > t\n      next\n    end\n    \n    6.times do |i|\n      nx = tmp[0] + dx[i]\n      ny = tmp[1] + dy[i]\n      \n      if field[ny][nx] == 1 || visited[ny][nx] == 1\n        next\n      end\n\n      visited[ny][nx] = 1\n      queue.push([nx, ny, tmp[2] + 1])\n    end\n  end\n\n  ans = 0;\n  200.times do |i|\n    200.times do |j|\n      if visited[i][j] == 1\n        ans += 1\n      end\n    end\n  end\n                          \n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n            end\n            break\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.pop\t\n\t\t\t\teach_neighbour_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\nend\n\nloop {\n\tt, n = gets.split.map &:to_i\n\tbreak if t == 0\n\tg = (0..60).map { [0] * 60 }\n\tn.times {\n\t\tx, y = gets.split.map &:to_i\n\t\tg[x+30][y+30] = 1\n\t}\n\n\tg.extend Graphical\n\t$diff = [[1,0], [1,1], [0,1], [-1,0], [-1,-1], [0,-1]]\n\tdef g.each_neighbour_of(u)\n\t\tx1, y1 = u\n\t\t$diff.each{|dx, dy|\n\t\t\tx2, y2 = x1+dx, y1+dy\n\t\t\tnext unless (0..60) === x2 && (0..60) === y2\n\t\t\tnext if self[x2][y2] == 1\n\t\t\tyield [x2, y2] \n\t\t}\n\tend\n\n\tsx, sy = gets.split.map &:to_i\n\tp g.reachable_from([sx+30, sy+30], t).size\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\ndef bfs(sy, sx, t, blocks)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    steps = Array.new(200).map{Array.new(200,0)}\n    count = 1\n    steps[sy][sx] = 1\n    while q.size > 0\n        sy, sx = q.shift\n        next if steps[sy][sx] > t\n        for i in 0..5\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if !blocks.include?([cy,cx]) && steps[cy][cx] == 0 && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                steps[cy][cx] = steps[sy][sx] + 1\n                count += 1\n            end\n        end\n    end\n    return count\nend\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i + 100}}\n    sy, sx = gets.split.map(&:to_i)\n    puts bfs(sy + 100, sx + 100, t, blocks)\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[-1, -1], [-1, 0], [0, 1], [1, 1], [1, 0], [0, -1]]\nloop do\n  t, n = gets.split.map(&:to_i)\n  break if t == 0\n  fld = 61.times.map{ [0] * 61 }\n  n.times{ c, r = gets.split.map(&:to_i); fld[r + 30][c + 30] = false }\n  sx, sy = gets.split.map(&:to_i).map{ |a| a + 30 }\n  pts = (t+1).times.map{ [] }\n  pts[0] << [sy, sx]\n  fld[sy][sx] = 1\n  t.times do |i|\n    pts[i].each do |y, x|\n      D.each do |mx, my|\n        p, q = y + my, x + mx\n        if 0 < p && p <= 60 && 0 < q && q <= 60 && fld[p][q] == 0\n          pts[i+1] << [p, q]\n          fld[p][q] = 1\n        end\n      end\n    end\n  end\n  p fld.flatten.count{ |f| f == 1 }\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\ndef bfs(sy, sx, t, blocks)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    steps = Array.new(200).map{Array.new(200,0)}\n    count = 1\n    steps[sy][sx] = 1\n    while q.size > 0\n        sy, sx = q.shift\n        next if steps[sy][sx] > t\n        for i in 0..5\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if !blocks.include?([cy,cx]) && steps[cy][cx] == 0\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                steps[cy][cx] = steps[sy][sx] + 1\n                count += 1\n            end\n        end\n    end\n    return count\nend\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i + 100}}\n    sy, sx = gets.split.map(&:to_i)\n    puts bfs(sy + 100, sx + 100, t, blocks)\nend"
  },
  {
    "language": "Ruby",
    "code": "dx = [0,1,0,-1,1,-1]\ndy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)2\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = Array.new(200).map{Array.new(200,false)}\n    visited[sy+50][sx+50] = true\n    count = 1\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + dy[i]\n                cx = sx + dx[i]\n                if !blocks.include?([cy,cx]) && !visited[cy+50][cx+50]\n                    q2.push([cy,cx])\n                    visited[cy+50][cx+50] = true\n                    count += 1\n                end\n            end\n        end\n        q = q2\n    end\n    puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            next\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n            end\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "Ruby",
    "code": "dx = [-1, -1, 0, 0, 1, 1]\ndy = [-1, 0, -1, 1, 0, 1]\n\nloop do\n  t, n = gets.chomp.split.map(&:to_i)\n\n  if t | n == 0\n    break\n  end\n\n  visited = Array.new(200) { Array.new(200, 0) }\n\n  field = Array.new(200) { Array.new(200, 0) }\n  \n  n.times do\n    x, y = gets.chomp.split.map(&:to_i)\n    field[y + 100][x + 100] = 1\n  end\n\n  sx, sy = gets.chomp.split.map(&:to_i)\n  sx += 100\n  sy += 100\n\n  queue = [[sx, sy, 0]]\n  visited[sy][sx] = 1\n\n  while !queue.empty? do\n    tmp = queue.shift\n\n    if tmp[2] + 1 > t\n      next\n    end\n    \n    6.times do |i|\n      nx = tmp[0] + dx[i]\n      ny = tmp[1] + dy[i]\n      if field[ny][nx] == 1 || visited[ny][nx] == 1\n        next\n      end\n      visited[ny][nx] = 1\n      queue.push([nx, ny, tmp[2] + 1])\n    end\n  end\n\n  ans = 0;\n  200.times do |i|\n    200.times do |j|\n      ans += visited[i][j]\n    end\n  end\n                          \n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1,1,-1]\n$dy = [1,0,-1,0,1,-1]\nloop do\n    t, n = gets.split.map(&:to_i)\n    break if t == 0 && n == 0\n    blocks = n.times.map{gets.split.map{|c| c.to_i}}\n    sy, sx = gets.split.map(&:to_i)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    t.times do\n        q2 = []\n        q.each do |sy,sx|\n            for i in 0..5\n                cy = sy + $dy[i]\n                cx = sx + $dx[i]\n                next\n                if !blocks.include?([cy,cx]) && !visited.include?([cy,cx])\n                    q2.push([cy,cx])\n                    visited.push([cy,cx])\n                end\n            end\n        end\n        q = q2\n    end\n    puts visited.size\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nclass Data {\n\tint x, y, n;\n\tint opCmp (const Data d) const {\n\t\treturn n < d.n;\n\t}\n}\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new bool[][](61, 61);\n\t\tforeach (_; 0..x[1]) {\n\t\t\tauto y = readln.chomp.split.map!(to!int);\n\t\t\tarea[y[0]+30][y[1]+30] = 1;\n\t\t}\n\t\tint cnt;\n\t\tauto q = BinaryHeap!(Data[], \"a > b\")(new Data[100000], 0);\n\t\tauto s = readln.chomp.split.map!(to!int);\n\t\tData data = new Data();\n\t\tdata.x = s[0] + 30;\n\t\tdata.y = s[1] + 30;\n\t\tdata.n = x[0];\n\t\tq.insert(data);\n\t\twhile (!q.empty) {\n\t\t\tauto t = q.front;\n\t\t\tauto i = t.x;\n\t\t\tauto j = t.y;\n\t\t\tauto n = t.n;\n\t\t\tq.removeFront;\n\t\t\tif (area[i][j]) continue;\n\t\t\tarea[i][j] = 1;\n\t\t\tcnt++;\n\t\t\tif (!n) continue;\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < 61) {\n\t\t\t\t\tdata = new Data();\n\t\t\t\t\tdata.x = i + a;\n\t\t\t\t\tdata.y = j;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.insert(data);\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata = new Data();\n\t\t\t\t\tdata.x = i;\n\t\t\t\t\tdata.y = j + a;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.insert(data);\n\t\t\t\t}\n\t\t\t\tif (i + a >= 0 && i + a < 61 && j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata = new Data();\n\t\t\t\t\tdata.x = i + a;\n\t\t\t\t\tdata.y = j + a;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.insert(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new bool[][](61, 61);\n\t\tforeach (_; 0..x[1]) {\n\t\t\tauto y = readln.chomp.split.map!(to!int);\n\t\t\tarea[y[0]+30][y[1]+30] = 1;\n\t\t}\n\t\tint cnt;\n\t\talias Tuple!(int, int, int) Data;\n\t\tData[] list;\n\t\tauto q = DList!(Data)(list);\n\t\tauto s = readln.chomp.split.map!(to!int);\n\t\tData data;\n\t\tdata[0] = s[0] + 30;\n\t\tdata[1] = s[1] + 30;\n\t\tdata[2] = x[0];\n\t\tq.stableInsertBack(data);\n\t\twhile (!q.empty) {\n\t\t\tauto t = q.front;\n\t\t\tauto i = t[0];\n\t\t\tauto j = t[1];\n\t\t\tauto n = t[2];\n\t\t\tq.stableRemoveFront;\n\t\t\tif (area[i][j]) continue;\n\t\t\tarea[i][j] = 1;\n\t\t\tcnt++;\n\t\t\tif (!n) continue;\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (i + a >= 0 && i + a < 61 && j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nstruct Data {\n\tint x, y, n;\n}\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new bool[][](61, 61);\n\t\tforeach (_; 0..x[1]) {\n\t\t\tauto y = readln.chomp.split.map!(to!int);\n\t\t\tarea[y[0]+30][y[1]+30] = 1;\n\t\t}\n\t\tint cnt;\n\t\tDList!(Data) q;\n\t\tauto s = readln.chomp.split.map!(to!int);\n\t\tData data;\n\t\tdata.x = s[0] + 30;\n\t\tdata.y = s[1] + 30;\n\t\tdata.n = x[0];\n\t\tq.stableInsertBack(data);\n\t\twhile (!q.empty) {\n\t\t\tauto t = q.front;\n\t\t\tauto i = t.x;\n\t\t\tauto j = t.y;\n\t\t\tauto n = t.n;\n\t\t\tq.stableRemoveFront;\n\t\t\tif (area[i][j]) continue;\n\t\t\tarea[i][j] = 1;\n\t\t\tcnt++;\n\t\t\tif (!n) continue;\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < 61) {\n\t\t\t\t\tdata.x = i + a;\n\t\t\t\t\tdata.y = j;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata.x = i;\n\t\t\t\t\tdata.y = j + a;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (i + a >= 0 && i + a < 61 && j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata.x = i + a;\n\t\t\t\t\tdata.y = j + a;\n\t\t\t\t\tdata.n = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new bool[][](61, 61);\n\t\tforeach (_; 0..x[1]) {\n\t\t\tauto y = readln.chomp.split.map!(to!int);\n\t\t\tarea[y[0]+30][y[1]+30] = 1;\n\t\t}\n\t\tint cnt;\n\t\tDList!(Tuple!(int, int, int)) q;\n\t\tauto s = readln.chomp.split.map!(to!int);\n\t\tTuple!(int, int, int) data;\n\t\tdata[0] = s[0] + 30;\n\t\tdata[1] = s[1] + 30;\n\t\tdata[2] = x[0];\n\t\tq.stableInsertBack(data);\n\t\twhile (!q.empty) {\n\t\t\tauto t = q.front;\n\t\t\tauto i = t[0];\n\t\t\tauto j = t[1];\n\t\t\tauto n = t[2];\n\t\t\tq.stableRemoveFront;\n\t\t\tif (area[i][j]) continue;\n\t\t\tarea[i][j] = 1;\n\t\t\tcnt++;\n\t\t\tif (!n) continue;\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (i + a >= 0 && i + a < 61 && j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nconst real eps = 1e-10;\n\nvoid solve(ref int[][] g, bool[int[]] obs, int x, int y, int t, int tmax) {\n\tif(t > tmax) return;\n\n\tif(([x,y] in obs) is null){\n\t\t//writeln(x, \" \", y, \" \", t);\n\t\tif(g[x][y] > t) {\n\t\t\tg[x][y] = t;\n\t\t\tint[][] dx = [[0, 1], [0, -1], [1, 0], [1, 1], [-1, -1], [-1, 0]];\n\t\t\tforeach(dxi; dx) {\n\t\t\t\tsolve(g, obs, x+dxi[0], y+dxi[1], t+1, tmax);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid main(){\n\twhile(true) {\n\t\tauto tn = readInts();\n\t\tauto t = tn[0];\n\t\tauto n = tn[1];\n\t\tif((t|n) == 0) return;\n\n\t\tauto offset = [100, 100];\n\t\tbool[int[]] obs;\n\t\tfor(int i; i < n; ++i) {\n\t\t\tint[] xy = readInts();\n\t\t\txy[] += offset[];\n\t\t\tobs[xy.idup] = true;\n\t\t}\n\t\tint[] s = readInts();\n\t\ts[] += offset[];\n\n\t\tauto g = new int[][](200,200);\n\t\tfor(int i; i < 200; ++i) {\n\t\t\tfor(int j; j < 200; ++j) {\n\t\t\t\tg[i][j] = int.max/2;\n\t\t\t}\n\t\t}\n\t\tsolve(g, obs, s[0], s[1], 0, t);\n\t\tint ans;\n\t\tforeach(gi; g) {\n\t\t\tforeach(gii; gi) {\n\t\t\t\tif(gii <= t) {\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nconst real eps = 1e-10;\n\nvoid solve(ref int[][] g, bool[int[]] obs, int x, int y, int t, int tmax) {\n\tif(t > tmax) return;\n\n\tif(([x,y] in obs) is null && g[x][y] > t) {\n\t\tg[x][y] = t;\n\t\tint[][] dx = [[0, 1], [0, -1], [1, 0], [1, 1], [-1, -1], [-1, 0]];\n\t\tforeach(dxi; dx) {\n\t\t\tsolve(g, obs, x+dxi[0], y+dxi[1], t+1, tmax);\n\t\t}\n\t}\n}\n\nvoid main(){\n\twhile(true) {\n\t\tauto tn = readInts();\n\t\tauto t = tn[0];\n\t\tauto n = tn[1];\n\t\tif((t|n) == 0) return;\n\n\t\tauto offset = [50, 50];\n\t\tbool[int[]] obs;\n\t\tfor(int i; i < n; ++i) {\n\t\t\tint[] xy = readInts();\n\t\t\txy[] += offset[];\n\t\t\tobs[xy.idup] = true;\n\t\t}\n\t\tint[] s = readInts();\n\t\ts[] += offset[];\n\n\t\tauto g = new int[][](100,100);\n\t\tfor(int i; i < 100; ++i) {\n\t\t\tfor(int j; j < 100; ++j) {\n\t\t\t\tg[i][j] = int.max/2;\n\t\t\t}\n\t\t}\n\t\tsolve(g, obs, s[0], s[1], 0, t);\n\t\tint ans;\n\t\tforeach(gi; g) {\n\t\t\tforeach(gii; gi) {\n\t\t\t\tif(gii <= t) {\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new bool[][](61, 61);\n\t\tforeach (_; 0..x[1]) {\n\t\t\tauto y = readln.chomp.split.map!(to!int);\n\t\t\tarea[y[0]+30][y[1]+30] = 1;\n\t\t}\n\t\tint cnt;\n\t\talias Tuple!(int, int, int) Data;\n\t\tDList!(Data) q;\n\t\tauto s = readln.chomp.split.map!(to!int);\n\t\tData data;\n\t\tdata[0] = s[0] + 30;\n\t\tdata[1] = s[1] + 30;\n\t\tdata[2] = x[0];\n\t\tq.stableInsertBack(data);\n\t\twhile (!q.empty) {\n\t\t\tauto t = q.front;\n\t\t\tauto i = t[0];\n\t\t\tauto j = t[1];\n\t\t\tauto n = t[2];\n\t\t\tq.stableRemoveFront;\n\t\t\tif (area[i][j]) continue;\n\t\t\tarea[i][j] = 1;\n\t\t\tcnt++;\n\t\t\tif (!n) continue;\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t\tif (i + a >= 0 && i + a < 61 && j + a >= 0 && j + a < 61) {\n\t\t\t\t\tdata[0] = i + a;\n\t\t\t\t\tdata[1] = j + a;\n\t\t\t\t\tdata[2] = n - 1;\n\t\t\t\t\tq.stableInsertBack(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt.writeln;\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\n(t, n) = map(int, raw_input().split())\nwhile t != 0 or n != 0:\n    M = [[False]*100 for i in range(100)]\n    for i in range(n):\n        (obx, oby) = map(int, raw_input().split())\n        M[oby+50][obx+50] = True\n    (sx, sy) = map(int, raw_input().split())\n    ST = [] #0:y 1:x 2:turn num\n    cnt = 0\n    #----above init----#\n    #print s\n    ST.append([sy+50, sx+50, 0])\n    while len(ST) > 0:\n        y = ST[0][0]\n        x = ST[0][1]\n        c = ST[0][2]\n        ST.pop(0)\n        if c <= t and M[y][x] == False:\n            M[y][x] = True\n            cnt += 1\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    if dx+dy != 0:\n                        ST.append([y+dy, x+dx, c+1])\n    print cnt\n    \n    (t, n) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "class Queue:\n    def __init__(self, data=[]):\n        self.data = data\n\n    def enqueue(self, x):\n        self.data.append(x)\n\n    def dequeue(self):\n        return self.data.pop(0)  # 先頭を取り出す\n\n    def is_Empty(self):\n        if len(self.data) == 0:\n            return True\n        else:\n            return False\n\n\ndef bfs(cnt, t):\n    adjacent = [(1, 0), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, -1)]\n    cnt = {}\n    while not queue.is_Empty():\n        cx, cy = queue.dequeue()\n\n        cnt.setdefault((cx, cy), 0)\n        if cnt[(cx, cy)] >= t:\n            continue\n\n        for a, b in adjacent:\n            # if 0 > cx+a or 0 > cy+b:\n            #     continue\n            # if abs(cx+a) >= 61 or abs(cy+b) >= 61:\n            #     continue\n            if visited[cx+a][cy+b] == 1 or visited[cx+a][cy+b] == -1:\n                continue\n            cnt[(cx+a, cy+b)] = cnt[(cx, cy)] + 1\n            queue.enqueue((cx+a, cy+b))\n            visited[cx+a][cy+b] = 1\n\n\nwhile True:\n    t, n = map(int, input().split())  # ターン数t, 障害物の個数n\n    if n == 0 and t == 0:\n        break\n    obstacles = [list(map(int, input().split())) for _ in range(n)]\n    cx, cy = map(int, input().split())  # 初期位置\n\n    visited = [[0]*121 for _ in range(121)]\n    visited[cx+60][cy+60] = 1\n    for x, y in obstacles:\n        visited[x+60][y+60] = -1\n\n    queue = Queue()\n    queue.enqueue((cx+60, cy+60))\n    bfs(0, t)\n    ans = 0\n    for row in visited:\n        for x in row:\n            if x >= 0:\n                ans += x\n\n    print(ans)\n    # 非対象の座標もある\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport itertools\nimport math\nfrom collections import Counter, defaultdict\n\nclass Main(object):\n    \n    def __init__(self):\n        pass\n\n    def solve(self):\n        '''\n        insert your code\n        '''\n        while True:\n            t, n = map(int, raw_input().split())\n            if t == n == 0:\n                break\n            obs = []\n            for i in range(n):\n                x, y = map(int, raw_input().split())\n                obs.append((x, y))\n            sx, sy = map(int, raw_input().split())\n            q = [(sx, sy, 0)]\n            visited = set([(sx, sy)])\n            d = [(1, 0), (1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1)]\n            while q:\n                x, y, turn = q.pop(0)\n                if turn >= t:\n                    break\n                for dx, dy in d:\n                    if not (x + dx, y + dy) in obs:\n                        visited.add((x + dx, y + dy))\n                        q.append((x + dx, y + dy, turn + 1))\n            # print visited\n            print len(visited)\n        return None\n\nif __name__ == '__main__':\n    m = Main()\n    m.solve()"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    li = list(\"ixcm\")\n    k = [1,10,100,1000]\n    d = {\"i\":1,\"x\":10,\"c\":100,\"m\":1000}\n    f = [\"i\",\"x\",\"c\",\"m\"]\n    for _ in range(n):\n        a,b = LS()\n        s = 0\n        for i in range(len(a)):\n            if a[i] in li:\n                a[i] = d[a[i]]\n                if i > 0 and a[i-1] not in k:\n                    s += a[i-1]*a[i]\n                else:\n                    s += a[i]\n            else:\n                a[i] = int(a[i])\n\n        for i in range(len(b)):\n            if b[i] in li:\n                b[i] = d[b[i]]\n                if i > 0 and b[i-1] not in k:\n                    s += b[i-1]*b[i]\n                else:\n                    s += b[i]\n\n            else:\n                b[i] = int(b[i])\n        ans = []\n        while s != 0:\n            i = int(math.log(s+0.1,10))\n            m = s//k[i]\n            s %= k[i]\n            if m != 1:\n                ans.append(m)\n            ans.append(f[i])\n        for i in ans:\n            print(i,end=\"\")\n        print()\n    return\n\n#B\ndef B():\n    d = [(0,1),(0,-1),(1,0),(-1,0),(1,1),(-1,-1)]\n    while 1:\n        t,n = LI()\n        if t == n == 0:\n            break\n        f = defaultdict(lambda : 1)\n        for i in range(n):\n            x,y = LI()\n            f[(x,y)] = 0\n        x,y = LI()\n        bfs = defaultdict(lambda : 1)\n        q = deque()\n        q.append((x,y,0))\n        bfs[(x,y)] = 0\n        ans = 1\n        while q:\n            x,y,turn = q.popleft()\n            if turn < t:\n                for dx,dy in d:\n                    x2 = x+dx\n                    y2 = y+dy\n                    if bfs[(x2,y2)]:\n                        if f[(x2,y2)]:\n                            ans += 1\n                            bfs[(x2,y2)] = 0\n                            q.append((x2,y2,turn+1))\n        print(ans)\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    B()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq as hq\n\ndef bfs(x,y,t,Map):\n    queue = []\n    hq.heappush(queue,(0,(x,y)))\n    while len(queue) != 0:\n        p = hq.heappop(queue)\n        x,y = p[1]\n        if p[0] <= t and Map[y][x] == 0:\n            Map[y][x] = 1\n            dxdy = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)]\n            for dx,dy in dxdy:\n                hq.heappush(queue,(p[0] + 1, (x + dx, y + dy)))\n\nwhile True:\n    t,n = map(int,input().split())\n    if t == 0 and n == 0:\n        break\n\n    Map = [[0 for j in range(200)] for i in range(200)]\n    for _ in range(n):\n        x,y = map(lambda x:int(x) + 100,input().split())\n        Map[y][x] = -1\n    x,y = map(lambda x:int(x) + 100,input().split())\n    bfs(x,y,t,Map)\n\n    print(sum([0 if Map[i][j] == -1 else Map[i][j] for i in range(200) for j in range(200)]))"
  },
  {
    "language": "Python",
    "code": "while 1:\n    t,n = map(int,raw_input().split())\n    if t == n == 0: break\n    block = []\n    for loop in range(n):\n        x,y = map(int,raw_input().split())\n        block.append((x+100,y+100))\n    sx,sy = map(int,raw_input().split())\n    sx += 100; sy += 100\n    visited = [[False]*200 for _ in range(200)]\n    visited[sy][sx] = True\n    que = [[sx,sy,t]]\n    ans = 1\n    while que:\n        x,y,tt = que.pop(0)\n        if tt == 0: continue\n        for dx,dy in zip([1,1,0,-1,-1,0],[0,1,1,0,-1,-1]):\n            nx,ny = x+dx,y+dy\n            if not visited[ny][nx] and (nx,ny) not in block:\n                que.append([nx,ny,tt-1])\n                visited[ny][nx] = True\n                ans += 1\n    print ans"
  },
  {
    "language": "Python",
    "code": "import sys\ndef ds6(here, field, turn):\n\tif turn == -1 or here in field and (field[here] == -1 or field[here] >= turn) : \n\t\treturn\n\n\tfield[here] = turn\n\tds6((here[0], here[1]+1), field, turn - 1)\n\tds6((here[0], here[1]-1), field, turn - 1)\n\n\tds6((here[0]+1, here[1]), field, turn - 1)\n\tds6((here[0]-1, here[1]), field, turn - 1)\n\t\n\tds6((here[0]+1, here[1]+1), field, turn - 1)\n\tds6((here[0]-1, here[1]-1), field, turn - 1)\n\nsys.setrecursionlimit(10000)\nwhile 1:\n\tt, n = map(int,raw_input().split(\" \"))\n\tif (t,n) == (0,0):\n\t\tbreak\n\tfield = dict()\n\tfor i in range(n):\n\t\tblock = map(int,raw_input().split(\" \"))\n\t\tfield[(block[0],block[1])] = - 1\n\tstart = map(int,raw_input().split())\n\tds6((start[0],start[1]), field, t)\n\tprint len(field) - n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\n(t, n) = map(int, raw_input().split())\nwhile t != 0 or n != 0:\n    M = [[False]*100 for i in range(100)]\n    for i in range(n):\n        (obx, oby) = map(int, raw_input().split())\n        M[oby+50][obx+50] = True\n    (sx, sy) = map(int, raw_input().split())\n    ST = [] #0:y 1:x 2:turn num\n    cnt = 0\n    #----above init----#\n    #print s\n    ST.append([sy+50, sx+50, 0])\n    while len(ST) > 0:\n        y = ST[0][0]\n        x = ST[0][1]\n        c = ST[0][2]\n        ST.pop(0)\n        if c <= t and M[y][x] == False:\n            M[y][x] = True\n            cnt += 1\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    if dx+dy != 0:\n                        ST.append([y+dy, x+dx, c+1])\n    print cnt\n    \n    (t, n) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq as hq\n\ndef bfs(x,y,t,Map,depth):\n    queue = [(depth,(x,y))]\n    while len(queue) != 0:\n        p = hq.heappop(queue)\n        x,y = p[1]\n        if p[0] < t and Map[y][x] == 0:\n            Map[y][x] = 1\n            dxdy = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)]\n            for dx,dy in dxdy:\n                if 0 <= x + dx < 60 and 0 <= y + dy < 60:\n                    hq.heappush(queue,(p[0] + 1, (x + dx, y + dy)))\n\nwhile True:\n    t,n = map(int,input().split())\n    if t == 0 and n == 0:\n        break\n\n    Map = [[0 for j in range(60)] for i in range(60)]\n    for _ in range(n):\n        x,y = map(lambda x:int(x) + 30,input().split())\n        Map[y][x] = -1\n    x,y = map(lambda x:int(x) + 30,input().split())\n    bfs(x,y,t + 1,Map,0)\n\n    print(sum([0 if Map[i][j] == -1 else Map[i][j] for i in range(60) for j in range(60)]))"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport itertools\nimport math\nfrom collections import Counter, defaultdict\n\nclass Main(object):\n    \n    def __init__(self):\n        pass\n\n    def solve(self):\n        '''\n        insert your code\n        '''\n        while True:\n            t, n = map(int, raw_input().split())\n            if t == n == 0:\n                break\n            obs = []\n            for i in range(n):\n                x, y = map(int, raw_input().split())\n                obs.append((x, y))\n            sx, sy = map(int, raw_input().split())\n            q = [(sx, sy, 0)]\n            visited = set([(sx, sy)])\n            d = [(1, 0), (1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1)]\n            while q:\n                x, y, turn = q.pop(0)\n                if turn >= t:\n                    break\n                for dx, dy in d:\n                    if not (x + dx, y + dy) in obs and not (x + dx, y + dy) in visited:\n                        visited.add((x + dx, y + dy))\n                        q.append((x + dx, y + dy, turn + 1))\n            # print visited\n            print len(visited)\n        return None\n\nif __name__ == '__main__':\n    m = Main()\n    m.solve()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport collections\n\n\ndelta = [(0, 1), (1, 1), (1, 0), (0, -1), (-1, -1), (-1, 0)]\nwhile True:\n    t, n = map(int, raw_input().split())\n    if t == 0 and n == 0:\n        break\n    obstacle = set()\n    for i in xrange(n):\n        x, y = map(int, raw_input().split())\n        obstacle.add((x, y))\n    cand = [tuple(map(int, raw_input().split()))]\n    visited = set(cand)\n    for i in xrange(t):\n        new_cand = []\n        for x, y in cand:\n            for d_x, d_y in delta:\n                key = (x + d_x, y + d_y)\n                if key not in obstacle and key not in visited:\n                    visited.add(key)\n                    new_cand.append(key)\n        cand = new_cand\n    print len(visited)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    t,n = map(int,raw_input().split())\n    if t == n == 0: break\n    block = [map(int,raw_input().split()) for _ in range(n)]\n    sx,sy = map(int,raw_input().split())\n    visited = []\n    visited.append([sx,sy])\n    que = [[sx,sy,t]]\n    ans = 1\n    while que:\n        x,y,tt = que.pop(0)\n        if tt == 0: continue\n        for dx,dy in zip([1,1,0,-1,-1,0],[0,1,1,0,-1,-1]):\n            nx,ny = x+dx,y+dy\n            if [nx,ny] not in visited and [nx,ny] not in block:\n                que.append([nx,ny,tt-1])\n                visited.append([nx,ny])\n                ans += 1\n    print ans"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\n(t, n) = map(int, raw_input().split())\nwhile t != 0 or n != 0:\n    M = [[False]*100 for i in range(100)]\n    for i in range(n):\n        (obx, oby) = map(int, raw_input().split())\n        M[oby+50][obx+50] = True\n    (sx, sy) = map(int, raw_input().split())\n    ST = [] #0:y 1:x 2:turn num\n    cnt = 0\n    #----above init----#\n    #print s\n    ST.append([sy+50, sx+50, 0])\n    while len(ST) > 0:\n        y = ST[0][0]\n        x = ST[0][1]\n        c = ST[0][2]\n        ST.pop(0)\n        if c <= t and M[y][x] == False:\n            M[y][x] = True\n            cnt += 1\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    if dx+dy != 0 and 20 <= y+dy and y+dy <= 80 \\\n                        and 20 <= x+dx and x+dx <= 80 and M[y+dy][x+dx] == False:\n                        ST.append([y+dy, x+dx, c+1])\n    print cnt\n    \n    (t, n) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq as hq\n\ndef bfs(x,y,t,Map):\n    queue = [(0,(x,y))]\n    while len(queue) != 0:\n        p = hq.heappop(queue)\n        x,y = p[1]\n        if p[0] < t and Map[y][x] == 0:\n            Map[y][x] = 1\n            dxdy = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)]\n            for dx,dy in dxdy:\n                if 0 <= x + dx < 61 and 0 <= y + dy < 61:\n                    hq.heappush(queue,(p[0] + 1, (x + dx, y + dy)))\n\nwhile True:\n    t,n = map(int,input().split())\n    if t == 0 and n == 0:\n        break\n\n    Map = [[0 for j in range(61)] for i in range(61)]\n    for _ in range(n):\n        x,y = map(lambda x:int(x) + 30,input().split())\n        if x >= 61 or y >= 61:\n            print(x,y)\n        Map[y][x] = -1\n    x,y = map(lambda x:int(x) + 30,input().split())\n    bfs(x,y,t + 1,Map)\n\n    print(sum([0 if Map[i][j] == -1 else Map[i][j] for i in range(61) for j in range(61)]))"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\nmv=((1,0),(1,1),(0,1),(0,-1),(-1,0),(-1,-1))\n\nwhile True:\n    t,n=map(int,raw_input().split())\n    if t==n==0:break\n    obj=set(tuple(map(int,raw_input().split())) for i in range(n))\n    x,y=map(int,raw_input().split())\n    Q=Queue()\n    visited=set()\n    visited.add((x,y))\n    tt=0\n    Q.put((x,y,tt))\n    while not Q.empty():\n        x,y,tt=Q.get()\n        if tt==t:break\n        for dx,dy in mv:\n            mx,my=x+dx,y+dy\n            if (mx,my) not in obj and (mx,my) not in visited:\n                Q.put((mx,my,tt+1))\n                visited.add((mx,my))\n    print len(visited)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n  t, n = map(int, input().split())\n  if t == 0:break\n  bans = {tuple(map(int, input().split())) for _ in range(n)}\n  sx, sy = map(int, input().split())\n  vec = ((0, 1), (1, 1), (1, 0), (0, -1), (-1, -1), (-1, 0))\n  que = deque()\n  que.append((t, sx, sy))\n  reached = set()\n  reached.add((sx, sy))\n  while que:\n    turn, x, y = que.popleft()\n    if turn == 0:continue\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) not in reached and (nx, ny) not in bans:\n        reached.add((nx, ny))\n        que.append((turn - 1, nx, ny))\n  print(len(reached))\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    dd = [(1,1),(1,0),(0,1),(0,-1),(-1,0),(-1,-1)]\n\n    while True:\n        t,n = LI()\n        if t == 0 and n == 0:\n            break\n        a = [LI() for _ in range(n)]\n        si,sj = LI()\n        d = collections.defaultdict(bool)\n        for ai,aj in a:\n            d[(ai,aj)] = True\n        r = 1\n        c = [(si,sj)]\n        d[(si,sj)] = True\n        for _ in range(t):\n            n = []\n            for ci,cj in c:\n                for di,dj in dd:\n                    ni = ci + di\n                    nj = cj + dj\n                    if d[(ni,nj)]:\n                        continue\n                    d[(ni,nj)] = True\n                    n.append((ni,nj))\n                    r += 1\n            c = n\n\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\n(t, n) = map(int, raw_input().split())\nwhile t != 0 or n != 0:\n    M = [[False]*100 for i in range(100)]\n    for i in range(n):\n        (obx, oby) = map(int, raw_input().split())\n        M[oby+50][obx+50] = True\n    (sx, sy) = map(int, raw_input().split())\n    ST = [] #0:y 1:x 2:turn num\n    cnt = 0\n    #----above init----#\n    #print s\n    ST.append([sy+50, sx+50, 0])\n    while len(ST) > 0:\n        y = ST[0][0]\n        x = ST[0][1]\n        c = ST[0][2]\n        ST.pop(0)\n        if c <= t and M[y][x] == False:\n            M[y][x] = True\n            cnt += 1\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    if dx+dy != 0 and M[y+dy][x+dx] == False:\n                        ST.append([y+dy, x+dx, c+1])\n    print cnt\n    \n    (t, n) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n  t, n = map(int, input().split())\n  if t==0 and n==0:\n      break\n  else:\n    d = [[-1]*200 for _ in range(200)]\n    for i in range(n):\n      x, y = map(int, input().split())\n      d[x+100][y+100] = float(\"INF\")\n    sx, sy = map(int, input().split())\n    sx, sy = sx+100, sy+100\n\n    q = deque([])\n    q.append((sx, sy))\n    d[sx][sy] = 0\n\n    while len(q)>0:\n      cur = q.popleft()\n      curx, cury = cur[0], cur[1]\n      for dx_ in range(-1, 2):\n        for dy_ in range(-1, 2):\n          if (dx_*dy_==-1) or (dx_==0 and dy_==0):\n            continue\n          else:\n            nx, ny = curx+dx_, cury+dy_\n            if d[curx][cury]<t and 0<=nx<200 and 0<=ny<200 and d[nx][ny]==-1:\n              q.append((nx, ny))\n              d[nx][ny] = d[curx][cury]+1\n\n    ans = 0\n    for i in range(len(d)):\n      for ele in d[i]:\n        if 0<=ele<=t:\n          ans+=1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport queue\nmovable=[(0,1),(1,1),(1,0),(0,-1),(-1,-1),(-1,0)]\nwhile 1:\n    t,n=map(int,input().split())\n    if t==n and n==0:\n        break\n    field=[[0 for i in range(200)] for i in range(200)]\n    for i in range(n):\n        x,y=map(int,input().split())\n        field[x+100][y+100]=1\n    x_st,y_st=map(int,input().split())\n    q=queue.Queue()\n    q.put((x_st+100,y_st+100,0))\n    ans=0\n    while not q.empty():\n        x,y,c=q.get()\n        if c>t:\n            continue\n        if field[x][y]<0:\n            continue\n        field[x][y]=-1\n        ans+=1\n        for x_nxt,y_nxt in movable:\n            if field[x+x_nxt][y+y_nxt]!=1 and field[x+x_nxt][y+y_nxt]>=0:\n                q.put((x+x_nxt,y+y_nxt,c+1))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "dx = [1, 0, -1, -1, 0, 1]\ndy = [0, -1, -1, 0, 1, 1]\nwhile True:\n\tt, n = map(int, raw_input().split())\n\tif t == n == 0: break\n\tblocks = set(tuple(map(int, raw_input().split())) for i in xrange(n))\n\tque = [(0,) + tuple(map(int, raw_input().split()))]\n\tvisited = set()\n\tcount = 0\n\twhile que:\n\t\tstep, x, y = que.pop(0)\n\t\tif (x, y) in visited: continue\n\t\tvisited.add((x, y))\n\t\tcount += 1\n\t\tif step == t: continue\n\t\tfor u, v in zip(dx, dy):\n\t\t\tnx = x + u\n\t\t\tny = y + v\n\t\t\tif (nx, ny) not in blocks:\n\t\t\t\tque.append((step + 1, nx, ny))\n\tprint count"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\n(t, n) = map(int, raw_input().split())\nwhile t != 0 or n != 0:\n    M = [[False]*201 for i in range(201)]\n    for i in range(n):\n        (obx, oby) = map(int, raw_input().split())\n        M[oby+100][obx+100] = True\n    (sx, sy) = map(int, raw_input().split())\n    ST = [] #0:y 1:x 2:turn num\n    cnt = 0\n    #----above init----#\n    #print s\n    ST.append([sy+100, sx+100, 0])\n    while len(ST) > 0:\n        y = ST[0][0]\n        x = ST[0][1]\n        c = ST[0][2]\n        ST.pop(0)\n        if y < 0 or 200 < y or x < 0 or 200 < x:\n            continue\n        if c <= t and M[y][x] == False:\n            M[y][x] = True\n            cnt += 1\n            for dy in [-1, 0, 1]:\n                for dx in [-1, 0, 1]:\n                    if dx+dy != 0:\n                        ST.append([y+dy, x+dx, c+1])\n    print cnt\n    \n    (t, n) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\ndxy = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1))\n\nimport Queue\n\ndef main():\n    # input\n    while(True):\n        try:\n            buf = map(int, raw_input().split())\n            if len(buf) == 0:\n                break\n\n            t = buf[0]\n            N = buf[1]\n            obstacle = []\n            for x in range(N):\n                obstacle.append(tuple(map(int, raw_input().split())))\n            start = tuple(map(int, raw_input().split()))\n            print(countGrid(start, obstacle, t))\n\n        except EOFError:\n            break\n\ndef countGrid(start, obstacle, t):\n    cnt = [0,]\n\n    # 到達可能なマス\n    q = Queue.Queue()\n\n    # 障害物+ 一度通ったマス\n    obstacle.append(start)\n    invalid_area = obstacle\n\n    q.put(start)\n    cnt[0] += 1\n\n    def countGrid_(que, t):\n\n        for x in range(t):\n            grids = []\n            while not(que.empty()):\n                grid = que.get()\n\n                invalid_area.append(grid)\n                grids += makeGrids(grid)\n            clear_grids = ejectObstacle(grids, invalid_area)\n\n            for x in clear_grids:\n                que.put(x)\n                cnt[0] += 1\n\n        return\n\n    countGrid_(q, t)\n    return cnt[0]\n\ndef makeGrids(grid):\n    zipedGrid = [zip(grid, x) for x in dxy]\n    return tuple(map(lambda x:tuple(map(sum, x)), zipedGrid))\n\ndef ejectObstacle(grids, obstacle):\n    grids = list(set(grids))\n    return filter(lambda x: x not in obstacle, grids)\n\ndef test():\n    print(ejectObstacle(((1,2), (1,3), (1,4), ), [(1,2), (1, 5)]))\n    print(makeGrids((2,3)))\n    start = (0, 0)\n    obstacle = [(1, 0), (2, 0)]\n    t = 2\n    print(countGrid(start, obstacle, t))\n\nif __name__=='__main__':\n    # test()\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq as hq\n\ndef bfs(x,y,t,Map,depth):\n    queue = [(depth,(x,y))]\n    while len(queue) != 0:\n        p = hq.heappop(queue)\n        x,y = p[1]\n        if p[0] < t and Map[y][x] == 0:\n                Map[y][x] = 1\n                dxdy = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1)]\n                for dx,dy in dxdy:\n                    if 0 <= x + dx < 60 and 0 <= y + dy < 60:\n                        hq.heappush(queue,(p[0] + 1, (x + dx, y + dy)))\n\nwhile True:\n    t,n = map(int,input().split())\n    if t == 0 and n == 0:\n        break\n\n    Map = [[0 for j in range(60)] for i in range(60)]\n    for _ in range(n):\n        x,y = map(lambda x:int(x) + 30,input().split())\n        Map[y][x] = -1\n    x,y = map(lambda x:int(x) + 30,input().split())\n    bfs(x,y,t + 1,Map,0)\n\n    print(sum([0 if Map[i][j] == -1 else Map[i][j] for i in range(60) for j in range(60)]))\n\n    "
  },
  {
    "language": "Python",
    "code": "import copy\nwhile 1:\n    t,n=map(int,input().split())\n    if t==n==0:break\n    field=[[0 for i in range(2*t+1)] for j in range(2*t+1)]\n    stone=[]\n    for i in range(n):stone.append(list(map(int,input().split())))\n    x,y=map(int,input().split())\n    for xi,yi in stone:\n        if 0<=t+xi-x<=2*t and 0<=t+yi-y<=2*t:field[t+xi-x][t+yi-y]=-1\n    field[t][t]=1\n    for k in range(t):\n        field_c=copy.deepcopy(field)\n        for i in range(2*t+1):\n            for j in range(2*t+1):\n                if field[i][j]>0:\n                    field_c[i+1][j+1]=-1 if field_c[i+1][j+1]==-1 else 1\n                    field_c[i+1][j]=-1 if field_c[i+1][j]==-1 else 1\n                    field_c[i][j+1]=-1 if field_c[i][j+1]==-1 else 1\n                    field_c[i-1][j-1]=-1 if field_c[i-1][j-1]==-1 else 1\n                    field_c[i-1][j]=-1 if field_c[i-1][j]==-1 else 1\n                    field_c[i][j-1]=-1 if field_c[i][j-1]==-1 else 1\n        field=field_c\n    ct=[flatten for inner in field for flatten in inner]\n    print(ct.count(1))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef bfs(x,y,c):\n    global MAP\n    global ans\n    global q\n    if MAP[x][y] != 0 or c > t:\n        return\n    else:\n        q.append((x,y+1,c+1))\n        q.append((x,y-1,c+1))\n        q.append((x+1,y,c+1))\n        q.append((x-1,y,c+1))\n        q.append((x+1,y+1,c+1))\n        q.append((x-1,y-1,c+1))\n\nwhile True:\n    t,n = inpl()\n    if t == 0 and n == 0:\n        break\n    else:\n        MAP = defaultdict(lambda:defaultdict(int))\n        for _ in range(n):\n            x,y = inpl()\n            MAP[x][y] = -1\n\n        sx,sy = inpl()\n        ans = 0\n        q = deque([(sx,sy,0)])\n        while q:\n            x,y,c = q.popleft()\n            if MAP[x][y] == 0 and c <= t:\n                ans += 1\n                bfs(x,y,c)\n                MAP[x][y] = -1\n\n        print(ans)\n\n"
  }
]