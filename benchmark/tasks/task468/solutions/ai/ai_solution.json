[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_WIDTH 100\n#define MAX_TIME 1000\n\nint main() {\n    int W, max_people = 0;\n    int units[MAX_WIDTH];\n    int dp[MAX_TIME + 1][MAX_WIDTH];\n    \n    scanf(\"%d\", &W);\n    for (int i = 0; i < W; i++) {\n        scanf(\"%d\", &units[i]);\n    }\n    \n    memset(dp, 0, sizeof(dp));\n    \n    for (int t = 0; t <= MAX_TIME; t++) {\n        for (int i = 0; i < W; i++) {\n            if (units[i] < 0 && t >= abs(units[i])) {\n                dp[t][i] = -1;\n                continue;\n            }\n            \n            if (units[i] > 0 && t < units[i]) {\n                dp[t][i]++;\n            }\n            \n            if (units[i] == 0) {\n                max_people += dp[t][i];\n                dp[t][i] = 0;\n            }\n            \n            if (dp[t][i] > 0) {\n                if (i > 0 && dp[t][i-1] != -1) {\n                    dp[t+1][i-1] += dp[t][i] / 2;\n                }\n                if (i < W-1 && dp[t][i+1] != -1) {\n                    dp[t+1][i+1] += dp[t][i] / 2;\n                }\n                dp[t+1][i] += dp[t][i] - (dp[t][i] / 2) * 2;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_people);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_W 1000\n\nint W;\nint a[MAX_W];\nint blocked[MAX_W];\nint people[MAX_W][MAX_W]; // people[t][i] = number of people at unit i at time t\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve() {\n    memset(people, 0, sizeof(people));\n    memset(blocked, 0, sizeof(blocked));\n\n    for (int i = 0; i < W; i++) {\n        if (a[i] < 0) {\n            blocked[i] = -a[i];\n        }\n    }\n\n    for (int i = 0; i < W; i++) {\n        if (a[i] > 0) {\n            for (int t = 0; t < a[i]; t++) {\n                people[t][i]++;\n            }\n        }\n    }\n\n    int total = 0;\n    for (int t = 0; t < MAX_W; t++) {\n        for (int i = 0; i < W; i++) {\n            if (a[i] == 0) {\n                total += people[t][i];\n                people[t][i] = 0;\n            }\n        }\n\n        if (t + 1 >= MAX_W) break;\n\n        for (int i = 0; i < W; i++) {\n            if (blocked[i] && t + 1 >= blocked[i]) {\n                continue;\n            }\n            int max_prev = 0;\n            if (i > 0 && (!blocked[i-1] || t < blocked[i-1])) {\n                max_prev = max(max_prev, people[t][i-1]);\n            }\n            max_prev = max(max_prev, people[t][i]);\n            if (i < W - 1 && (!blocked[i+1] || t < blocked[i+1])) {\n                max_prev = max(max_prev, people[t][i+1]);\n            }\n            people[t+1][i] += max_prev;\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    scanf(\"%d\", &W);\n    for (int i = 0; i < W; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Event {\n    int time;\n    int pos;\n    bool operator<(const Event& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int W;\n    cin >> W;\n    vector<int> a(W);\n    for (int i = 0; i < W; ++i) {\n        cin >> a[i];\n    }\n\n    vector<int> fire_block_time(W, INT_MAX);\n    for (int i = 0; i < W; ++i) {\n        if (a[i] < 0) {\n            fire_block_time[i] = -a[i];\n        }\n    }\n\n    priority_queue<Event> pq;\n    vector<vector<int>> earliest_time(W, vector<int>(W, INT_MAX));\n\n    for (int i = 0; i < W; ++i) {\n        if (a[i] > 0) {\n            for (int t = 0; t < a[i]; ++t) {\n                pq.push({t + 1, i});\n                earliest_time[i][t + 1] = t + 1;\n            }\n        }\n    }\n\n    int result = 0;\n    while (!pq.empty()) {\n        Event current = pq.top();\n        pq.pop();\n        int t = current.time;\n        int pos = current.pos;\n\n        if (a[pos] == 0) {\n            result++;\n            continue;\n        }\n\n        if (t >= fire_block_time[pos]) {\n            continue;\n        }\n\n        for (int delta : {-1, 0, 1}) {\n            int new_pos = pos + delta;\n            if (new_pos >= 0 && new_pos < W) {\n                if (t + 1 < fire_block_time[new_pos] && t + 1 < earliest_time[new_pos][t + 1]) {\n                    earliest_time[new_pos][t + 1] = t + 1;\n                    pq.push({t + 1, new_pos});\n                }\n            }\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EvacuationRoute {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int W = scanner.nextInt();\n        int[] a = new int[W];\n        for (int i = 0; i < W; i++) {\n            a[i] = scanner.nextInt();\n        }\n\n        List<Integer> exits = new ArrayList<>();\n        List<Integer> fireDoors = new ArrayList<>();\n        Map<Integer, Integer> fireDoorTimes = new HashMap<>();\n        for (int i = 0; i < W; i++) {\n            if (a[i] == 0) {\n                exits.add(i);\n            } else if (a[i] < 0) {\n                fireDoors.add(i);\n                fireDoorTimes.put(i, -a[i]);\n            }\n        }\n\n        int totalPeople = 0;\n        for (int i = 0; i < W; i++) {\n            if (a[i] > 0) {\n                totalPeople += a[i];\n            }\n        }\n\n        int[][] grid = new int[W][totalPeople + 1];\n        for (int i = 0; i < W; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[1]));\n        for (int exit : exits) {\n            grid[exit][0] = 0;\n            queue.add(new int[]{exit, 0});\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int pos = current[0];\n            int time = current[1];\n            if (time > grid[pos][time]) continue;\n\n            for (int dir = -1; dir <= 1; dir++) {\n                int newPos = pos + dir;\n                if (newPos >= 0 && newPos < W) {\n                    int newTime = time + 1;\n                    if (fireDoorTimes.containsKey(newPos) && newTime >= fireDoorTimes.get(newPos)) {\n                        continue;\n                    }\n                    if (newTime < grid[newPos][newTime]) {\n                        grid[newPos][newTime] = newTime;\n                        queue.add(new int[]{newPos, newTime});\n                    }\n                }\n            }\n        }\n\n        int maxPeople = 0;\n        for (int i = 0; i < W; i++) {\n            if (a[i] > 0) {\n                int people = a[i];\n                int minTime = Integer.MAX_VALUE;\n                for (int t = 0; t <= totalPeople; t++) {\n                    if (grid[i][t] != Integer.MAX_VALUE) {\n                        minTime = Math.min(minTime, t);\n                    }\n                }\n                if (minTime != Integer.MAX_VALUE) {\n                    maxPeople += Math.min(people, minTime);\n                }\n            }\n        }\n\n        System.out.println(maxPeople);\n    }\n}",
    "timestamp": "2025-08-05 21:49:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EvacuationRoute {\n    public static int maxPeopleEscaped(int[] units) {\n        int W = units.length;\n        List<Integer> exits = new ArrayList<>();\n        List<Person>[] peopleAtTime = new List[W];\n        for (int i = 0; i < W; i++) {\n            peopleAtTime[i] = new ArrayList<>();\n        }\n\n        // Identify exit doors and generate people\n        for (int i = 0; i < W; i++) {\n            if (units[i] == 0) {\n                exits.add(i);\n            } else if (units[i] > 0) {\n                for (int t = 0; t < units[i]; t++) {\n                    peopleAtTime[t].add(new Person(i));\n                }\n            }\n        }\n\n        // Determine fire door blocking times\n        int[] fireBlocked = new int[W];\n        Arrays.fill(fireBlocked, Integer.MAX_VALUE);\n        for (int i = 0; i < W; i++) {\n            if (units[i] < 0) {\n                fireBlocked[i] = Math.abs(units[i]);\n            }\n        }\n\n        // DP array to track max people reaching exits\n        int[][] dp = new int[W * 100][W];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n\n        int maxEscaped = 0;\n        for (int exit : exits) {\n            maxEscaped += dfs(exit, 0, peopleAtTime, fireBlocked, dp);\n        }\n\n        return maxEscaped;\n    }\n\n    private static int dfs(int pos, int time, List<Person>[] peopleAtTime, int[] fireBlocked, int[][] dp) {\n        if (pos < 0 || pos >= fireBlocked.length || time >= fireBlocked[pos]) {\n            return 0;\n        }\n\n        if (dp[time][pos] != -1) {\n            return dp[time][pos];\n        }\n\n        int maxEscaped = 0;\n        for (Person p : peopleAtTime[time]) {\n            int dist = Math.abs(p.start - pos);\n            if (canReach(p.start, pos, time, fireBlocked)) {\n                maxEscaped++;\n            }\n        }\n\n        int[] directions = {-1, 0, 1};\n        for (int dir : directions) {\n            int nextPos = pos + dir;\n            maxEscaped = Math.max(maxEscaped, dfs(nextPos, time + 1, peopleAtTime, fireBlocked, dp));\n        }\n\n        dp[time][pos] = maxEscaped;\n        return maxEscaped;\n    }\n\n    private static boolean canReach(int start, int end, int time, int[] fireBlocked) {\n        int dist = Math.abs(start - end);\n        if (dist > time) return false;\n\n        for (int i = Math.min(start, end); i <= Math.max(start, end); i++) {\n            if (time >= fireBlocked[i]) return false;\n        }\n\n        return true;\n    }\n\n    private static class Person {\n        int start;\n        Person(int start) {\n            this.start = start;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] units1 = {3, 0, 0, 2, -3};\n        System.out.println(maxPeopleEscaped(units1));  // Example test case\n    }\n}",
    "timestamp": "2025-08-05 21:49:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxEvacuees(int W, vector<int>& doors) {\n        vector<vector<int>> dp(W, vector<int>(2001, 0));\n        vector<vector<int>> people(W);\n        \n        // Track people generation\n        for (int i = 0; i < W; i++) {\n            if (doors[i] > 0) {\n                for (int t = 0; t < doors[i]; t++) {\n                    people[i].push_back(t);\n                }\n            }\n        }\n        \n        // Initialize exit units\n        for (int i = 0; i < W; i++) {\n            if (doors[i] == 0) {\n                for (int t = 0; t < 2001; t++) {\n                    dp[i][t] = 1000000;\n                }\n            }\n        }\n        \n        // Dynamic programming for fire doors\n        vector<int> fireTime(W, 2001);\n        for (int i = 0; i < W; i++) {\n            if (doors[i] < 0) {\n                fireTime[i] = -doors[i];\n            }\n        }\n        \n        // DP to track maximum people reaching\n        for (int t = 0; t < 2000; t++) {\n            vector<vector<int>> nextDp(W, vector<int>(2001, 0));\n            \n            // Add newly generated people\n            for (int i = 0; i < W; i++) {\n                for (int p : people[i]) {\n                    if (p == t) {\n                        dp[i][t]++;\n                    }\n                }\n            }\n            \n            // Movement and tracking\n            for (int i = 0; i < W; i++) {\n                if (t >= fireTime[i]) continue;\n                \n                for (int move = max(0, i-1); move <= min(W-1, i+1); move++) {\n                    if (t+1 >= fireTime[move]) continue;\n                    \n                    for (int count = 1; count <= dp[i][t]; count++) {\n                        nextDp[move][t+1] = max(nextDp[move][t+1], count);\n                    }\n                }\n                \n                // Stay in current unit\n                nextDp[i][t+1] = max(nextDp[i][t+1], dp[i][t]);\n            }\n            \n            dp = nextDp;\n        }\n        \n        // Find maximum exit\n        int maxExit = 0;\n        for (int i = 0; i < W; i++) {\n            if (doors[i] == 0) {\n                for (int t = 0; t < 2001; t++) {\n                    maxExit = max(maxExit, dp[i][t]);\n                }\n            }\n        }\n        \n        return maxExit;\n    }\n};",
    "timestamp": "2025-08-05 21:49:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_people_to_exit(W, units):\n    # Graph representation for movement and initial setup\n    graph = []\n    people = [0] * W\n    fire_timers = [float('inf')] * W\n    exits = []\n\n    # Process unit information\n    for i in range(W):\n        if units[i] == 0:\n            exits.append(i)\n        elif units[i] < 0:\n            fire_timers[i] = abs(units[i])\n        elif units[i] > 0:\n            people[i] = units[i]\n\n    # Time simulation of movement\n    total_people = 0\n    time = 0\n\n    while sum(people) > 0:\n        new_people = [0] * W\n\n        for i in range(W):\n            if people[i] > 0:\n                # Check possible movements\n                if i > 0 and time < fire_timers[i - 1]:\n                    new_people[i - 1] += people[i]\n                if i < W - 1 and time < fire_timers[i + 1]:\n                    new_people[i + 1] += people[i]\n                if time < fire_timers[i]:\n                    new_people[i] += people[i]\n\n                # Check if at an exit\n                if i in exits:\n                    total_people += people[i]\n                    people[i] = 0\n\n        people = new_people\n        time += 1\n\n    return total_people\n\n# Sample input - replace with the actual input values\nW = 10\nunits = [2, -3, 1, 0, 0, 3, -1, 2, 0, -2]\nprint(max_people_to_exit(W, units))",
    "timestamp": "2025-08-13 07:35:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class EvacuationRoute {\n    public static int maxPeopleReachExit(int W, int[] a) {\n        int maxPeople = 0;\n        List<Integer> entrances = new ArrayList<>();\n        Set<Integer> exits = new HashSet<>();\n        Map<Integer, Integer> fireBlockingTimes = new HashMap<>();\n\n        for (int i = 0; i < W; i++) {\n            if (a[i] > 0) {\n                entrances.add(i);\n            } else if (a[i] == 0) {\n                exits.add(i);\n            } else if (a[i] < 0) {\n                fireBlockingTimes.put(i, -a[i]);\n            }\n        }\n\n        Map<Integer, Integer> peoplePositions = new HashMap<>();\n        for (int entrance : entrances) {\n            for (int t = 0; t < a[entrance]; t++) {\n                peoplePositions.put(t * W + entrance, 1);\n            }\n        }\n\n        int time = 1;\n        while (!peoplePositions.isEmpty()) {\n            Map<Integer, Integer> nextPositions = new HashMap<>();\n            for (Map.Entry<Integer, Integer> entry : peoplePositions.entrySet()) {\n                int current = entry.getKey();\n                int col = current % W;\n                int currentPeople = entry.getValue();\n\n                if (exits.contains(col)) {\n                    maxPeople += currentPeople;\n                    continue;\n                }\n\n                int fireBlockTime = fireBlockingTimes.getOrDefault(col, Integer.MAX_VALUE);\n                if (time < fireBlockTime) {\n                    int leftPos = current - 1;\n                    int rightPos = current + 1;\n                    int stayPos = current;\n\n                    if (col > 0) {\n                        nextPositions.put(leftPos, nextPositions.getOrDefault(leftPos, 0) + currentPeople);\n                    }\n                    if (col < W - 1) {\n                        nextPositions.put(rightPos, nextPositions.getOrDefault(rightPos, 0) + currentPeople);\n                    }\n                    nextPositions.put(stayPos, nextPositions.getOrDefault(stayPos, 0) + currentPeople);\n                }\n            }\n            peoplePositions = nextPositions;\n            time++;\n        }\n\n        return maxPeople;\n    }\n\n    public static void main(String[] args) {\n        int W = 7;\n        int[] a = {1, 0, 2, -2, 1, 0, -3};\n        System.out.println(maxPeopleReachExit(W, a)); //Example simulation call\n    }\n}",
    "timestamp": "2025-08-13 07:36:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_W 1000\n\ntypedef struct {\n    int position;\n    int time;\n} Person;\n\nint fire_blocks[MAX_W];\nint doors[MAX_W];\nint exits[MAX_W];\n\nint maxPeopleToExits(int W, int *a) {\n    int i, j, k, max_people = 0;\n    int people_in_corridor = 0;\n    int fire_door_num = 0;\n    int max_time = 0;\n\n    for (i = 0; i < W; i++) {\n        if (a[i] == 0) {\n            exits[i] = 1;\n        } else if (a[i] < 0) {\n            fire_blocks[i] = -a[i];\n            if (fire_blocks[i] > max_time) {\n                max_time = fire_blocks[i];\n            }\n        } else {\n            doors[i] = a[i];\n            people_in_corridor += a[i];\n        }\n    }\n\n    for (i = 0; i < W; i++) {\n        if (fire_blocks[i] > 0) {\n            fire_door_num++;\n        }\n    }\n\n    int *dp = (int *)malloc(sizeof(int) * W);\n    int t;\n\n    for (t = 1; t <= max_time + W; t++) {\n        for (i = 0; i < W; i++) {\n            if (exits[i]) {\n                dp[i] = max_people;\n                continue;\n            }\n\n            int max_prev = 0;\n\n            if (fire_blocks[i] > 0 && t > fire_blocks[i]) {\n                dp[i] = 0;\n                continue;\n            }\n\n            if (i > 0 && fire_blocks[i - 1] <= 0 || t <= fire_blocks[i - 1]) {\n                if (dp[i - 1] > max_prev) {\n                    max_prev = dp[i - 1];\n                }\n            }\n\n            if (i + 1 < W && fire_blocks[i + 1] <= 0 || t <= fire_blocks[i + 1]) {\n                if (dp[i + 1] > max_prev) {\n                    max_prev = dp[i + 1];\n                }\n            }\n\n            if (i < W && fire_blocks[i] <= 0 || t <= fire_blocks[i]) {\n                if (dp[i] > max_prev) {\n                    max_prev = dp[i];\n                }\n            }\n\n            dp[i] = max_prev;\n\n            if (t <= doors[i]) {\n                dp[i]++;\n            }\n        }\n\n        max_people = 0;\n        for (j = 0; j < W; j++) {\n            if (exits[j] && dp[j] > max_people) {\n                max_people = dp[j];\n            }\n        }\n    }\n\n    free(dp);\n    return max_people;\n}\n\nint main() {\n    int W;\n    int a[MAX_W];\n\n    // Assume input is provided according to the problem description\n    scanf(\"%d\", &W);\n    for (int i = 0; i < W; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int result = maxPeopleToExits(W, a);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:36:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_evacuees(W, doors):\n    # Create dynamic programming state tracking\n    dp = [[0] * W for _ in range(2001)]\n    people = [[0] * W for _ in range(2001)]\n    fire_blocked = [set() for _ in range(2001)]\n\n    # Initialize people entering at time 0\n    for i in range(W):\n        if doors[i] > 0:\n            people[0][i] = doors[i]\n\n    # Simulate evacuation and track fire blocking\n    for t in range(2000):\n        # Mark fire-blocked units\n        for i in range(W):\n            if doors[i] < 0 and t == abs(doors[i]):\n                fire_blocked[t].add(i)\n\n        # Move people\n        for i in range(W):\n            if fire_blocked[t] and i in fire_blocked[t]:\n                continue\n\n            # People can move to adjacent or stay in current unit\n            for di in [-1, 0, 1]:\n                next_pos = i + di\n                if 0 <= next_pos < W and (next_pos not in fire_blocked[t]):\n                    people[t+1][next_pos] += people[t][i]\n\n        # Track exits\n        for i in range(W):\n            if doors[i] == 0:\n                dp[t][i] += people[t][i]\n\n    # Return maximum number of people reaching exits\n    return max(sum(row) for row in dp)\n\n# Example usage\nW = 5\ndoors = [1, -3, 2, 0, 1]\nprint(max_evacuees(W, doors))",
    "timestamp": "2025-08-13 07:36:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    W = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    exits = []\n    fire_doors = []\n    entrances = []\n    \n    for i in range(W):\n        if a[i] == 0:\n            exits.append(i)\n        elif a[i] < 0:\n            fire_doors.append((i, -a[i]))\n        else:\n            for t in range(a[i]):\n                entrances.append((i, t + 1))  # (position, start moving time)\n    \n    # Precompute fire door blocking times\n    blocked = [float('inf')] * W\n    for i, t in fire_doors:\n        blocked[i] = t\n    \n    # For each entrance, find the earliest time to reach any exit\n    total = 0\n    \n    # We can model this as a BFS for each entrance, but that's O(W^2 * N) which might be too slow\n    # Instead, for each exit, find all entrances that can reach it before being blocked\n    \n    # Precompute for each cell i, the earliest time it gets blocked (including fire doors)\n    earliest_blocked = [float('inf')] * W\n    for i in range(W):\n        if blocked[i] != float('inf'):\n            earliest_blocked[i] = blocked[i]\n    \n    # For each exit, perform multi-source BFS to find all reachable entrances\n    for exit_pos in exits:\n        # BFS queue: (position, time)\n        q = deque()\n        visited = [False] * W\n        dist = [float('inf')] * W\n        q.append(exit_pos)\n        visited[exit_pos] = True\n        dist[exit_pos] = 0\n        \n        while q:\n            current = q.popleft()\n            for neighbor in [current - 1, current + 1]:\n                if 0 <= neighbor < W and not visited[neighbor]:\n                    if dist[current] + 1 < earliest_blocked[neighbor]:\n                        dist[neighbor] = dist[current] + 1\n                        visited[neighbor] = True\n                        q.append(neighbor)\n        \n        # Now, collect all entrances that can reach this exit\n        for (ent_pos, ent_time) in entrances:\n            if dist[ent_pos] <= ent_time and dist[ent_pos] < float('inf'):\n                total += 1\n                # Remove this entrance to avoid double counting\n                # So we need to mark it as used\n        # To avoid double counting, we need to remove entrances that are used\n        # So we need to process exits in an order and remove used entrances\n        # But this approach is not efficient, so we need a better way\n    \n    # The above approach counts each entrance for every exit it can reach, leading to overcounting\n    # So we need to find a maximum matching between entrances and exits\n    \n    # Alternative approach: model as bipartite graph and find maximum matching\n    # Left nodes: entrances (each entrance is a unique (pos, t))\n    # Right nodes: exits\n    # Edge from entrance to exit if the entrance can reach the exit\n    \n    # But exits can be used multiple times, so it's a many-to-one matching\n    \n    # So we can model this as a bipartite graph where exits have unlimited capacity\n    \n    # To implement this efficiently, we can process each entrance and assign it to the earliest reachable exit\n    \n    # So, first, for each entrance, find all exits it can reach, then assign to one\n    \n    # To maximize the count, we can use a greedy approach\n    \n    # So, let's re-process\n    \n    # Create a list of all entrances (pos, start_time)\n    # For each entrance, find all exits it can reach, and the earliest time to reach them\n    # Then, assign the entrance to the exit that can be reached earliest\n    \n    # To avoid overcounting, once an exit is assigned, it can be used again\n    \n    # So, we can process each entrance, and if it can reach any exit, count it\n    \n    # So the initial approach was correct, but overcounts when an entrance can reach multiple exits\n    \n    # So the correct answer is simply the number of entrances that can reach at least one exit\n    \n    # So we need to find for each entrance if there exists at least one exit it can reach\n    \n    # So, we can precompute for each cell i, the minimal distance to any exit\n    \n    # Multi-source BFS from all exits\n    \n    q = deque()\n    min_dist = [float('inf')] * W\n    for exit_pos in exits:\n        q.append(exit_pos)\n        min_dist[exit_pos] = 0\n    \n    while q:\n        current = q.popleft()\n        for neighbor in [current - 1, current + 1]:\n            if 0 <= neighbor < W:\n                if min_dist[neighbor] > min_dist[current] + 1:\n                    if min_dist[current] + 1 < earliest_blocked[neighbor]:\n                        min_dist[neighbor] = min_dist[current] + 1\n                        q.append(neighbor)\n    \n    total = 0\n    for (ent_pos, ent_time) in entrances:\n        if min_dist[ent_pos] <= ent_time and min_dist[ent_pos] < float('inf'):\n            total += 1\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 07:36:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent state\nstruct State {\n    int position;  // Position in the corridor\n    int time;      // Time step\n    int people;    // Number of people in this state\n    \n    State(int p, int t, int ppl) : position(p), time(t), people(ppl) {}\n};\n\nint getMaxPeopleToExit(int W, const vector<int>& a) {\n    vector<vector<int>> fireTime(W, vector<int>(W, INT_MAX));\n    vector<bool> isExit(W, false);\n    queue<State> q;\n\n    // Initialize fire and entrance details\n    for (int i = 0; i < W; ++i) {\n        if (a[i] < 0) {\n            int fire_start_time = -a[i];\n            for (int j = i; j < W && j < i + fire_start_time; ++j) {\n                fireTime[i][j] = min(fireTime[i][j], fire_start_time);\n            }\n        } else if (a[i] > 0) {\n            for (int t = 0; t < a[i]; ++t) {\n                q.push(State(i, t + 1, 1));\n            }\n        } else if (a[i] == 0) {\n            isExit[i] = true;\n        }\n    }\n\n    int maxReached = 0;\n    vector<vector<int>> dp(W, vector<int>(W * 2, 0));\n    \n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        \n        if (isExit[current.position]) {\n            maxReached += current.people;\n            continue;\n        }\n        \n        int curr_time = current.time;\n        int curr_pos = current.position;\n        int curr_people = current.people;\n        \n        for (int next_pos = curr_pos - 1; next_pos <= curr_pos + 1; ++next_pos) {\n            if (next_pos >= 0 && next_pos < W && curr_time < fireTime[curr_pos][next_pos]) {\n                int next_time = curr_time + 1;\n                if (dp[next_pos][next_time] < curr_people) {\n                    dp[next_pos][next_time] = curr_people;\n                    q.push(State(next_pos, next_time, curr_people));\n                }\n            }\n        }\n    }\n    \n    return maxReached;\n}\n\nint main() {\n    int W;\n    cin >> W;\n    vector<int> a(W);\n\n    for (int i = 0; i < W; ++i) {\n        cin >> a[i];\n    }\n\n    cout << getMaxPeopleToExit(W, a) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:39:53"
  }
]