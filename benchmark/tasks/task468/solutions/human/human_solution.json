[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ArrayBuffer\nobject Main extends App {\n  import scala.io.StdIn._\n  val w = readInt\n  val a = readLine.trim.split(' ').map(_.toInt)\n  val nearestRight: Array[Int] = a.indices.map(i ⇒ if (a(i) != 0) Int.MaxValue else i).toArray.also(arr ⇒ arr.indices.reverse.tail.foreach(i ⇒ arr(i) = math.min(arr(i), arr(i + 1))))\n  val nearestLeft: Array[Int] = a.indices.map(i ⇒ if (a(i) != 0) Int.MinValue else i).toArray.also(arr ⇒ arr.indices.tail.foreach(i ⇒ arr(i) = math.max(arr(i), arr(i - 1))))\n  val limitFromLeft = MinSegmentTree(a.indices.map(i ⇒ if (a(i) >= 0) Int.MaxValue else a(i).abs + startTimeFromLeft(i)).toArray)\n  val limitFromRight = MinSegmentTree(a.indices.map(i ⇒ if (a(i) >= 0) Int.MaxValue else a(i).abs + startTimeFromRight(i)).toArray)\n  println(\n    a.indices.filter(a(_) > 0).map(i ⇒ math.max(canMoveLeft(i, a(i), nearestLeft, limitFromRight), canMoveRight(i, a(i), nearestRight, limitFromLeft))).sum\n  )\n  def canMoveRight(position: Int, time: Int, nearestRight: Array[Int], limitFromLeft: MinSegmentTree): Int = {\n    if ((0 until w).contains(nearestRight(position)) && startTimeFromLeft(position) <= limitFromLeft.min(position, nearestRight(position))){\n      val t = startTimeFromLeft(position)\n      val min = limitFromLeft.min(position, nearestRight(position))\n      (startTimeFromLeft(position) until math.min(startTimeFromLeft(position) + time, limitFromLeft.min(position, nearestRight(position)))).length\n    }else 0\n  }\n  def canMoveLeft(position: Int, time: Int, nearestLeft: Array[Int], limitFromRight: MinSegmentTree): Int = {\n    if ((0 until w).contains(nearestLeft(position)) && startTimeFromRight(position) <= limitFromRight.min(nearestLeft(position), position)){\n      (startTimeFromRight(position) until math.min(startTimeFromRight(position) + time, limitFromRight.min(nearestLeft(position), position))).length\n    }else 0\n  }\n\n  def startTimeFromLeft(to: Int): Int = -to\n  def startTimeFromRight(to: Int): Int = to + 1 - w\n  object MinSegmentTree {\n    def apply(array: Array[Int]): MinSegmentTree = {\n      val arr = ArrayBuffer[Array[Int]](array)\n      while (arr.last.length != 1){\n        arr.append(Array.tabulate(arr.last.length / 2){_ ⇒ Int.MaxValue})\n      }\n      for (depth ← arr.indices.tail; i ← arr(depth).indices){\n        arr(depth)(i) = math.min(arr(depth - 1)(i * 2), arr(depth - 1)(i * 2 + 1))\n      }\n      new MinSegmentTree(arr.toArray)\n    }\n  }\n  class MinSegmentTree private (private val array: Array[Array[Int]]){\n    def min(from: Int, to: Int): Int = {\n      var depth = 0\n      var left = from\n      var right = to\n      var min = Int.MaxValue\n      while (left <= right){\n        if (left % 2 == 1){\n          min = math.min(min, array(depth)(left))\n          left += 2\n        }\n        if (right % 2 == 0){\n          min = math.min(min, array(depth)(right))\n          right -= 2\n        }\n        left /= 2\n        right /= 2\n        depth += 1\n      }\n      min\n    }\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def let[A](func: T ⇒ A): A = func(value)\n    @inline\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing P=pair<int,int>; //t,x\nint main(){\n    int W;\n    cin>>W;\n    vector<int> A(W);\n    for(auto &a:A) cin>>a;\n    vector<int> M(W);//避難できる上限\n    for(int i=0;i<W;i++){\n        if(A[i]==0){\n            M[i]=10000;\n            for(int j=i+1;j<W;j++){\n                if(A[j]<=0) break;\n                else M[j]=10000;\n            }\n            for(int j=i-1;j>=0;j--){\n                if(A[j]<=0||M[j]==10000) break;\n                else M[j]=10000; \n            }\n        }\n    }\n    vector<P> Event;\n    for(int i=0;i<W;i++){\n        if(A[i]<0){\n            Event.emplace_back(A[i],i);\n        }\n    }\n    sort(Event.begin(), Event.end());\n    for(auto e:Event){\n        int t,x;\n        tie(t,x)=e;\n        if(0<=x-1) M[x]=max(M[x],min(-t,M[x-1]-1));\n        if(x+1<W) M[x]=max(M[x],min(-t,M[x+1]-1));\n        for(int i=x-1;i>=0;i--){\n            if(M[i]<M[i+1]-1){\n                M[i]=M[i+1]-1;\n            }else{\n                break;\n            }\n        }\n        for(int i=x+1;i<W;i++){\n            if(M[i]<M[i-1]-1){\n                M[i]=M[i-1]-1;\n            }else{\n                break;\n            }\n        }\n    }\n    /**\n    for(int i=0;i<W;i++){\n        cout<<M[i]<<' ';\n    }cout<<endl;**/\n    int64_t ans=0;\n    for(int i=0;i<W;i++){\n        if(A[i]>0) ans+=min(A[i],M[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 20)\nint main(){\n\tint l[100000], r[100000], a[100000];\n\tint w;\n\tcin >> w;\n\tfor (int i = 0; i < w; ++i) {\n\t\tcin >> a[i];\n\t}\n\tl[0] = a[0] == 0 ? INF : 0;\n\tr[w-1] = a[w-1] == 0 ? INF : 0;\n\tfor (int i = 1; i < w; ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tl[i] = INF;\n\t\t} else if (a[i] < 0) {\n\t\t\tl[i] = min(-a[i], l[i-1] - 1);\n\t\t} else {\n\t\t\tl[i] = l[i-1] - 1;\n\t\t}\n\t}\n\tfor (int i = w-2; i >= 0; --i) {\n\t\tif (a[i] == 0) {\n\t\t\tr[i] = INF;\n\t\t} else if (a[i] < 0) {\n\t\t\tr[i] = min(-a[i], r[i+1] - 1);\n\t\t} else {\n\t\t\tr[i] = r[i+1] - 1;\n\t\t}\n\t}\n\tlong long int result = 0;\n\tfor (int i = 0; i < w; ++i) {\n\t\tl[i] = max(l[i], r[i]);\n\t\tl[i] = min(l[i], a[i]);\n\t\tl[i] = max(l[i], 0);\n\t\tresult += l[i];\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\n\nint main() {\n    int W;\n    vector<int> a, v0, tmax;\n    cin >> W;\n    a.resize(W);\n    tmax.resize(W, 0);\n    for(int i=0;i<W;i++){\n        cin >> a[i];\n        if(a[i] == 0){\n            v0.push_back(i);\n        }\n    }\n    for(auto i : v0){\n        tmax[i] = IINF;\n        for(int j=i-1;j>=0;j--){\n            if(a[j] == 0) break;\n            else if(a[j] > 0) tmax[j] = max(tmax[j], tmax[j+1]-1);\n            else tmax[j] = max(tmax[j], min(abs(a[j]), tmax[j+1]-1));\n        }\n        for(int j=i+1;j<W;j++){\n            if(a[j] == 0) break;\n            else if(a[j] > 0) tmax[j] = max(tmax[j], tmax[j-1]-1);\n            else tmax[j] = max(tmax[j], min(abs(a[j]), tmax[j-1]-1));\n        }\n    }\n    int ans = 0;\n    for(int i=0;i<W;i++){\n        if(a[i]>0){\n            ans += min(a[i], tmax[i]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    int cnt[n]={};\n    for(int i=0;i<n;i++){\n        if(a[i]==0){\n            int res=1e9;\n            int l=i-1;\n            while(l>=0){\n                if(a[l]==0) break;\n                if(a[l]<0) res = min(res,-a[l]);\n                if(a[l]>0){\n                    cnt[l]=max(cnt[l],min(a[l],res));\n                }\n                res--;\n                l--;\n                \n            }\n            l=i+1,res=1e9;\n            while(l<n){\n\n                if(a[l]==0) break;\n                if(a[l]<0) res = min(res,-a[l]);\n                if(a[l]>0){\n                    cnt[l]=max(cnt[l],min(a[l],res));\n                }\n                res--;\n                l++;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++) ans+=cnt[i];\n    cout<<ans<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int w;\n    scanf(\" %d\", &w);\n    vector<int> a(w);\n    rep(i,w) scanf(\" %d\", &a[i]);\n\n    vector<int> ev(w,0);\n\n    int now=0;\n    int state=0;\n\n    rep(i,w)\n    {\n        if(a[i]==0)\n        {\n            now=10000;\n            state=0;\n        }\n        if(a[i]<0)\n        {\n            now=min(now,-a[i]);\n            state=1;\n        }\n\n        ev[i]=max(ev[i],now);\n        if(state) --now;\n    }\n\n    now=0;\n    state=0;\n    for(int i=w-1; i>=0; --i)\n    {\n        if(a[i]==0)\n        {\n            now=10000;\n            state=0;\n        }\n        if(a[i]<0)\n        {\n            now=min(now,-a[i]);\n            state=1;\n        }\n\n        ev[i]=max(ev[i],now);\n        if(state) --now;\n    }\n\n    int ans=0;\n    rep(i,w)\n    {\n        if(a[i]>0) ans+=min(a[i],ev[i]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint main(){\n  int w;\n  scanf(\"%d\",&w);\n  vector<int> a(w),pop(w,0);\n  for(int i=0;i<w;i++)scanf(\"%d\",&a[i]);\n\n  int t = 0;\n  for(int i=0;i<w;i++){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else{\n      pop[i] = max(pop[i], t);\n    }\n    t--;\n  }\n\n  t = 0;\n  for(int i=w-1;i>=0;i--){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else{\n      pop[i] = max(pop[i], t);\n    }\n    t--;\n  }\n\n  int ans = 0;\n  for(int i=0;i<w;i++)ans += min(pop[i], abs(a[i]));\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 1000000000\nusing namespace std;\n\nint w;\nint a[100001],b[100001],c[100001];\n\nint main()\n{\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n  for(int i=0;i<w;i++){\n    if(a[i]==0){\n      b[i]=inf;\n      c[i]=inf;\n    }\n    else {\n      b[i]=0;\n      c[i]=0;\n    }\n  }\n  for(int i=0;i<w-1;i++){\n    if(a[i+1]==0)continue;\n    if(a[i]==0){\n      if(a[i+1]>0)b[i+1]=a[i+1];\n      else b[i+1]=-a[i+1];\n      continue;\n    }\n    if(a[i+1]>0){\n      if(a[i]<0)b[i+1]=max(0,b[i]-1);\n      if(a[i]>0)b[i+1]=min(b[i],a[i+1]);\n    }else {\n      b[i+1]=max(0,b[i]-1);\n    }\n  }\n\n  for(int i=w-1;i>=1;i--){\n    if(a[i-1]==0)continue;\n    if(a[i]==0){\n      if(a[i-1]>0)c[i-1]=a[i-1];\n      else c[i-1]=-a[i-1];\n      continue;\n    }\n    if(a[i-1]>0){\n      if(a[i]<0)c[i-1]=max(0,c[i]-1);\n      if(a[i]>0)c[i-1]=min(c[i],a[i-1]);\n    }else {\n      c[i-1]=max(0,c[i]-1);\n    }\n  }\n\n  int ans=0;\n  for(int i=0;i<w;i++){\n    if(a[i]>0)ans+=max(b[i],c[i]);\n    }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct segtree{\n    int n;\n    vector<int> dat;\n    segtree(int size,int x){\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,x);\n    }\n    // update k th element\n    void update(int k,int a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    // min [a, b)\n    int query(int a,int b) { return query(a,b,0,0,n); }\n    int query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return inf;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return min(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int w;\n    cin >> w;\n    vector<int> a(w);\n    rep(i,0,w) cin >> a[i];\n\n    vector<int> out;\n    segtree seg1(w,inf),seg2(w,inf);\n    out.emplace_back(-1);\n    rep(i,0,w){\n        if(a[i]==0) out.emplace_back(i);\n        if(a[i]<0){\n            seg1.update(i,-a[i]+i);\n            seg2.update(i,-a[i]-i);\n        }\n    }\n    out.emplace_back(inf);\n\n    int ans=0;\n    rep(i,0,w){\n        if(a[i]<=0) continue;\n        const int pos=i,num=a[i];\n        const int left_out=*(upper_bound(out.begin(),out.end(),pos)-1),right_out=*(upper_bound(out.begin(),out.end(),pos));\n        const int left_shutter=seg1.query(left_out,pos),right_shutter=seg2.query(pos,right_out);\n        auto ok=[&](const int x){\n            if(left_shutter==inf and left_out!=-1) return true;\n            if(right_shutter==inf and right_out!=inf) return true;\n            if(left_out!=-1 and x-1+pos<left_shutter) return true;\n            if(right_out!=inf and x-1-pos<right_shutter) return true;\n            return false;\n        };\n        int lb=0,ub=num+1;\n        while(ub-lb>1){\n            const int mid=(lb+ub)/2;\n            if(ok(mid)) lb=mid;\n            else ub=mid;\n        }\n        int prev=ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nint W, A[100000];\nint d, t, limit[100000];\n\nint main(void) {\n  cin >> W;\n  REP(i, 0, W) cin >> A[i];\n\n  REP(i, 0, W) limit[i] = 0;\n\n  d = INF, t = INF;\n  REP(i, 0, W) {\n    if(A[i] == 0) {\n      d = 0;\n      t = 0;\n    }\n    if(A[i] < 0) {\n      t = -A[i];\n    }\n    if(A[i] > 0) {\n      limit[i] = max(limit[i], t - d);\n    }\n  }\n\n  d = INF, t = INF;\n  REP(j, 0, W) {\n    int i = W - j - 1;\n    if(A[i] == 0) {\n      d = 0;\n      t = 0;\n    }\n    if(A[i] < 0) {\n      t = -A[i];\n    }\n    if(A[i] > 0) {\n      limit[i] = max(limit[i], t - d - 1);\n    }\n    d++;\n  }\n\n  ll ans = 0;\n  REP(i, 0, W) if(A[i] > 0) ans += min(A[i], limit[i]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 100005\nusing namespace std;\nint n,a[N],l[N],r[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    cin>>a[i];\n  for(int i=0;i<n;i++){\n    if(a[i])continue;\n    int x=INF;\n    r[i]=x;\n    for(int j=i+1;j<n;j++){\n      if(a[j]<0&&x>-a[j])x=-a[j];\n      if(!a[j])x=INF;\n      r[j]=x;\n      if(x)x--;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    if(a[i])continue;\n    int x=INF;\n    l[i]=x;\n    for(int j=i-1;j>=0;j--){\n      if(a[j]<0&&x>-a[j])x=-a[j];\n      if(!a[j])x=INF;\n      l[j]=x;\n      if(x)x--;\n    }\n  }\n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(a[i]>0)ans+=min(a[i],max(l[i],r[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint W;\n\tcin >> W;\n\tvector<int> a(W),dp1(W+2,-1e9),dp2(W+2,-1e9);\n\tfor(int i = 1 ; i <= W ; i++) cin >> a[i];\n\t\n\tfor(int i = 1 ; i <= W ; i++){\n\t\tif( a[i] == 0 ) dp1[i] = 1e9;\n\t\telse if( a[i] < 0 ) dp1[i] = min(dp1[i-1]-1,-a[i]);\n\t\telse dp1[i] = dp1[i-1]-1;\n\t}\n\tfor(int i = W ; i >= 1 ; i--){\n\t\tif( a[i] == 0 ) dp2[i] = 1e9;\n\t\telse if( a[i] < 0 ) dp2[i] = min(dp2[i+1]-1,-a[i]);\n\t\telse dp2[i] = dp2[i+1]-1;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1 ; i <= W ; i++)\n\t\tans += max(0,min(max(dp1[i],dp2[i]),a[i]));\n\tcout << ans << endl;\n\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    ll W;\n    cin >> W;\n    vector<ll>A(W), R(W, 0), L(W, 0);\n    for(int i = 0; i < W; i++)cin >> A[i];\n    for(ll i = 0, mx = 0; i < W; i++){\n        mx--;\n        if(A[i] == 0){\n            mx = 202020;\n            continue;\n        }\n        if(A[i] < 0){\n            mx = min(mx, -A[i]);\n            continue;\n        }\n        L[i] = min(A[i], mx);\n    }\n    for(ll i = W - 1, mx = 0; i >= 0; i--){\n        mx--;\n        if(A[i] == 0){\n            mx = 202020;\n            continue;\n        }\n        if(A[i] < 0){\n            mx = min(mx, -A[i]);\n            continue;\n        }\n        R[i] = max(min(A[i], mx), 0LL);\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < W; i++)ans += max(R[i], L[i]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1e9;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> a(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tvector<int> tll(N, inf), tlr(N, inf);\n\tif (a[0] != 0) tll[0] = 0;\n\tif (a[N-1] != 0) tlr[N-1] = 0;\n\tfor (int i = 1; i < N; ++i) {\n\t\ttll[i] = max(0, tll[i-1]-1);\n\t\tif (a[i] == 0) tll[i] = inf;\n\t\tif (a[i] < 0 && -a[i] < tll[i]) tll[i] = -a[i];\n\t}\n\tfor (int i = N-1; i >= 0; --i) {\n\t\ttlr[i] = max(0, tlr[i+1]-1);\n\t\tif (a[i] == 0) tlr[i] = inf;\n\t\tif (a[i] < 0 && -a[i] < tlr[i]) tlr[i] = -a[i];\n\t}\n\tvector<int> tl(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\ttl[i] = max(tll[i], tlr[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n//\t\tcout << tl[i] << \" \";\n\t\tif (a[i] > 0) {\n\t\t\tans += min(a[i], tl[i]);\n\t\t}\n\t}\n//\tcout << endl;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, A[100002];\n  int close[100002] = {};\n  \n  cin >> W;\n  for(int i = 1; i <= W; i++) {\n    cin >> A[i];\n    if(A[i] == 0) close[i] = INF;\n  }\n  for(int i = 1; i <= W; i++) {\n    close[i] = max(close[i], close[i - 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  for(int i = W; i >= 1; i--) {\n    close[i] = max(close[i], close[i + 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  int ret = 0;\n  for(int i = 1; i <= W; i++) {\n    ret += max(0, min(close[i], A[i]));\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//時刻tについて、移動→閉鎖→出現の順で進行。\n//考察：\n//i番目のユニットから移動を始めるj番目の人を考える。\n//移動方法：左か右のどちらかへ移動。出口があれば速攻出る。(2通り、最大w回の移動)\n//特徴：ユニットの出現が連続。j人目が脱出できる⇒j-1人目が脱出できる、が成り立つ。\n//i番目のユニットから脱出できる人の数をjを2分探索することで求める。(関係ないけど、間違っても全員の移動2^(人数)を列挙してたら無駄)\n//問題は、「どちらかに移動することで脱出できるか」を高速に求めることである。\n//左側への移動の場合、i-1番目のユニットに来た時点で、i-1番目のユニットにおけるMaxjより時間が超過していれば脱出できない。それ以外は脱出できる。\n//右側への移動の場合、i+1番目の(ry\n//ということで、これは、ならしO(1)で求めることができる。\n//全体でO(wlogMAX)\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\nusing namespace std;\n\nint w;\nint a[100000];\nint lmax[100000];\nint rmax[100000];\n\n//左移動moveto = -1, 右移動moveto = 1\n//ユニットiからスタート、j分目から移動開始。(これはj人目の行動)\nbool canout(int i, int j, int moveto) {\n\tint k;\n\tint t = j;\n\tfor( k = i; k >= 0 && k < w; k += moveto ) {\n\t\tif ( moveto > 0 && rmax[k] != -1 ) {\n\t\t\tif( rmax[k] - t >= 0 )\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\tif ( moveto < 0 && lmax[k] != -1 ) {\n\t\t\tif( lmax[k] - t >= 0 )\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif ( a[k] == 0 ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( a[k] < 0 && t > -a[k] ) {\n\t\t\treturn false;\n\t\t}\n\t\tt++;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i;\n\tcin >> w;\n\tfor( i = 0; i < w; i++ ) {\n\t\tcin >> a[i];\n\t\tlmax[i] = -1;\n\t\trmax[i] = -1;\n\t}\n\t\n\tfor( i = 0; i < w; i++ ) {\n\t\tif (a[i] > 0) {\n\t\t\tint st = 0, ed = 114514, medi;\n\t\t\twhile( st <= ed ) {\n\t\t\t\tmedi = st + ed;\n\t\t\t\tmedi /= 2;\n\t\t\t\tif( canout(i, medi, -1) ) {\n\t\t\t\t\tif( !canout(i, medi+1, -1) )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tst = medi + 1;\n\t\t\t\t} else {\n\t\t\t\t\ted = medi - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlmax[i] = medi;\n\t\t}\n\t}\n\tfor( i = w-1; i >= 0; i-- ) {\n\t\tif (a[i] > 0) {\n\t\t\tint st = 0, ed = 114514, medi;\n\t\t\twhile( st <= ed ) {\n\t\t\t\tmedi = st + ed;\n\t\t\t\tmedi /= 2;\n\t\t\t\tif( canout(i, medi, 1) ) {\n\t\t\t\t\tif( !canout(i, medi+1, 1) )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tst = medi + 1;\n\t\t\t\t} else {\n\t\t\t\t\ted = medi - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trmax[i] = medi;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor( i = 0; i < w; i++ ) {\n\t\tans += max(0, min( a[i] , max( lmax[i], rmax[i] )) );\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e17;\n\nlong long int a[110000], b[110000];\n\nint main(){\n\t\n\tint W;\n\tcin >> W;\n\t\n\tlong long int S1 = 0;\n\t\n\tfor(int i = 0; i < W; i++){\n\t\tcin >> a[i];\n\t\tb[i] = a[i];\n\t\tif(a[i] > 0){\n\t\t\tS1 += a[i];\n\t\t}\n\t}\n\t\n\tlong long int cap = 0;\n\tfor(int i = 0; i < W; i++){\n\t\tif(a[i] > 0){\n\t\t\tb[i] += cap;\n\t\t\tcap++;\n\t\t}else if(a[i] == 0){\n\t\t\tcap = -INF;\n\t\t}else{\n\t\t\tcap = max(cap, a[i]);\n\t\t\tcap++;\n\t\t}\n\t\tcap = min(0LL, cap);\n\t}\n\t\n\tcap = 0;\n\tfor(int i = W - 1; i >= 0; i--){\n\t\tif(a[i] > 0){\n\t\t\tb[i] += cap;\n\t\t\tcap++;\n\t\t}else if(a[i] == 0){\n\t\t\tcap = -INF;\n\t\t}else{\n\t\t\tcap = max(cap, a[i]);\n\t\t\tcap++;\n\t\t}\n\t\tcap = min(0LL, cap);\n\t}\n\t\n\tlong long int S2 = 0;\n\tfor(int i = 0; i < W; i++){\n\t\tif(b[i] > 0){\n\t\t\tS2 += b[i];\n\t\t}\n\t\t//cout << b[i] << \" \";\n\t}\n\t//cout << endl;\n\t\n\tcout << S1 - S2 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  int A[W], INF = 1000000;\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size(), s, t;\n  vector<int> ans(W,0);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = W+1;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = W+1;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1]+1;\n    t = INF;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s));\n      }\n    }\n    s = E[0]-1;\n    t = INF;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s));\n      }\n    }\n  }\n  long long int sum = 0LL; \n  /*\n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    cout << ans[i] << \" \";\n  }\n  cout << endl;\n  */\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nconst int INF = 1<<28;\n\nnamespace {\n    int W;\n    vector<int> A;\n    void input() {\n        cin >> W;\n        A.clear(); A.resize(W);\n        for (int i = 0; i < W; i++) cin >> A[i];\n    }\n\n    struct S {\n        int x;\n        int t;\n        S() {}\n        S(int x, int t) : x(x), t(t) {}\n    };\n\n    const int INT = 1<<28;\n\n    void solve() {\n        queue<S> Q;\n        vector<int> D(W, 0);\n        for (int i = 0; i < W; i++) {\n            if (A[i] == 0) {\n                D[i] = INF;\n                Q.push(S(i, INF));\n            }\n        }\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            for (int dx = -1; dx <= 1; dx += 2) {\n                int nx = c.x + dx;\n                if (nx < 0 || nx >= W) continue;\n                int nt;\n                if (A[nx] < 0) {\n                    nt = min(c.t - 1, -A[nx]);\n                } else {\n                    nt = c.t - 1;\n                }\n                if (D[nx] < nt) {\n                    D[nx] = nt;\n                    Q.push(S(nx, nt));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < W; i++) {\n            if (A[i] > 0) {\n                ans += min(A[i], D[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  long long int A[W], INF = 100000000000LL;\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size();\n  long long int s, t;\n  vector<long long int> ans(W,0LL);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = W+1;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = W+1;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1]+1;\n    t = INF;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s));\n      }\n    }\n    s = E[0]-1;\n    t = INF;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s));\n      }\n    }\n  }\n  long long int sum = 0LL; \n\n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    //cout << ans[i] << \" \";\n  }\n  //cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\n \nint main() {\n    int W; cin >> W;\n    vector<int> a(W);\n    for(int i = 0; i < W; ++i) cin >> a[i];\n    vector<int> L(W+1), R(W+1);\n    L[0] = -1;\n    for(int i = 0; i < W; ++i) {\n        L[i+1] = L[i] - 1;\n        if(a[i] == 0){\n            L[i+1] = INF;\n        }else if(a[i] < 0){\n            L[i+1] = min(L[i+1], -a[i]-1);\n        }\n    }\n    R[W] = -1;\n    for(int i = W-1; i >= 0; --i) {\n        R[i] = R[i+1] - 1;\n        if(a[i] == 0){\n            R[i] = INF;\n        }else if(a[i] < 0){\n            R[i] = min(R[i], -a[i]-1);\n        }\n    }\n    int res = 0;\n    for(int i = 0; i < W; ++i) {\n        if(a[i] > 0); else continue;\n        int t = max(L[i+1], R[i]);\n        if(t < 0) continue;\n        res += min(a[i], t+1);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint W;\n\tcin >> W;\n\tvector<int> a(W),s;\n\tint exit = false;\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) {\n\t\t\t++exit;\n\t\t}\n\t}\n\n\tint res = 0;\n\tif (exit > 0) {\n\t\tvector<int> r(W,0),l(W,0);\n\t\tint ind = 0;\n\t\tint ce = 0;\n\t\tfor (int i = 0; ce < exit && i < W; ++i) {\n\t\t\tr[i] = a[i];\n\t\t\tif (a[i] < 0) {\n\t\t\t\tfor (int j = ind; j < i; ++j) {\n\t\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\t\tif (r[j] > 0) {\n\t\t\t\t\t\t\tint temp = (i - j) + a[i];\n\t\t\t\t\t\t\tr[j] = min(r[j],-temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] == 0) {\n\t\t\t\tind = i + 1;\n\t\t\t\t++ce;\n\t\t\t}\n\t\t}\n\t\tce = 0;\n\t\tind = W-1;\n\t\tfor (int i = W-1; ce < exit && i >= 0; --i) {\n\t\t\tl[i] = a[i];\n\t\t\tif (a[i] < 0) {\n\t\t\t\tfor (int j = ind; j > i; --j) {\n\t\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\t\tif (l[j] > 0) {\n\t\t\t\t\t\t\tint temp = (j - i) + a[i];\n\t\t\t\t\t\t\tl[j] = min(l[j],-temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] == 0) {\n\t\t\t\tind = i - 1;\n\t\t\t\t++ce;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (r[i] > 0 || l[i] > 0) {\n\t\t\t\tres += max(r[i],l[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  VI a(n);\n  REP(i, n) cin >> a[i];\n\n  VI dp1(n);\n  dp1[0] = a[0]==0?INF:-1;\n  FOR(i, 1, n) {\n    if(a[i] == 0) dp1[i] = INF;\n    else if(a[i] > 0) dp1[i] = dp1[i-1] - 1;\n    else if(a[i] < 0) dp1[i] = min(dp1[i-1]-1, -a[i]-1);\n  }\n\n  VI dp2(n);\n  dp2[n-1] = a[n-1]==0?INF:-1;\n  for(int i=n-2; i>=0; --i) {\n    if(a[i] == 0) dp2[i] = INF;\n    else if(a[i] > 0) dp2[i] = dp2[i+1] - 1;\n    else if(a[i] < 0) dp2[i] = min(dp2[i+1]-1, -a[i]-1);\n  }\n\n  // cout << dp2 << endl;\n\n  int ret = 0;\n  REP(i, n) {\n    if(a[i] > 0) {\n      // 0-indexなので+1\n      ret += min(a[i], max({-1LL, dp1[i], dp2[i]})) + 1;\n    }\n  }\n\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint main(){\n    int w;\n    cin >> w;\n\n    int a[100005];\n    rep(i,w){\n        cin >> a[i];\n    }\n\n    int away[100005] = {0};\n    int cur = 0, ans = 0;\n    rep(i,w){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }else{\n            int tmp = min(a[i], cur);\n            ans += tmp;\n            a[i] -= tmp;\n            away[i] += tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cur = 0; \n    for(int i = w - 1; i >= 0; i--){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }\n        else{\n            int tmp = min(a[i], cur);\n            tmp = max(tmp - away[i], 0);\n            ans += tmp;\n            a[i] -= tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint n, a[MAX];\n\nint main(){\n    scanf(\"%d\", &n);\n    rep(i, n) scanf(\"%d\", &a[i]);\n\n    int lim[n];\n    int wall = -1;\n    rep(i, n){\n        --wall;\n        if(a[i] == 0) wall = mod;\n        else if(a[i] < 0) chmin(wall, abs(a[i]) - 1);\n        else{\n            lim[i] = max(wall, -1);\n        }\n    }\n    wall = -1;\n    rrep(i, n){\n        --wall;\n        if(a[i] == 0) wall = mod;\n        else if(a[i] < 0) chmin(wall, abs(a[i]) - 1);\n        else{\n            lim[i] = max({lim[i], wall, -1});\n        }\n    }\n\n    int ans = 0;\n    rep(i, n)if(a[i] > 0) ans += min(a[i], lim[i] + 1);\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing P=pair<int,int>; //t,x\nint main(){\n    int W;\n    cin>>W;\n    vector<int> A(W);\n    for(auto &a:A) cin>>a;\n    vector<int> M(W);//避難できる上限\n    for(int i=0;i<W;i++){\n        if(A[i]==0){\n            M[i]=1000000;\n            for(int j=i+1;j<W;j++){\n                if(A[j]<=0) break;\n                else M[j]=1000000;\n            }\n            for(int j=i-1;j>=0;j--){\n                if(A[j]<=0||M[j]==1000000) break;\n                else M[j]=1000000; \n            }\n        }\n    }\n    vector<P> Event;\n    for(int i=0;i<W;i++){\n        if(A[i]<0){\n            Event.emplace_back(A[i],i);\n        }\n    }\n    sort(Event.begin(), Event.end());\n    for(auto e:Event){\n        int t,x;\n        tie(t,x)=e;\n        if(0<=x-1) M[x]=max(M[x],min(-t,M[x-1]-1));\n        if(x+1<W) M[x]=max(M[x],min(-t,M[x+1]-1));\n        for(int i=x-1;i>=0;i--){\n            if(A[i]<0&&A[i]>A[x]) break;            \n            if(M[i]<M[i+1]-1){\n                M[i]=M[i+1]-1;\n            }else{\n                break;\n            }\n        }\n        for(int i=x+1;i<W;i++){\n            if(A[i]<0&&A[i]>A[x]) break;\n            if(M[i]<M[i-1]-1){\n                M[i]=M[i-1]-1;\n            }else{\n                break;\n            }\n        }\n    }\n    /**\n    for(int i=0;i<W;i++){\n        cout<<M[i]<<' ';\n    }cout<<endl;**/\n    int64_t ans=0;\n    for(int i=0;i<W;i++){\n        if(A[i]>0) ans+=min(A[i],M[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint W;\n\tcin >> W;\n\tvector<int> a(W), b(W, -1), c(W, -1);\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) b[i] = c[i] = 1e8;\n\t}\n\tfor (int i = 1; i < W; i++) {\n\t\tif (b[i - 1] > 0 && b[i] == -1) {\n\t\t\tb[i] = b[i - 1] - 1;\n\t\t\tif (a[i] < 0) {\n\t\t\t\tb[i] = min(b[i], -a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (c[i + 1] > 0 && c[i] == -1) {\n\t\t\tc[i] = c[i + 1] - 1;\n\t\t\tif (a[i] < 0) {\n\t\t\t\tc[i] = min(c[i], -a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tif (a[i] > 0 && max(b[i], c[i]) > 0) {\n\t\t\tres += min(a[i], max(b[i], c[i]));\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 100005\nusing namespace std;\nint n,a[N],l[N],r[N];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    cin>>a[i];\n  for(int i=0;i<n;i++){\n    if(a[i])continue;\n    int x=INF;\n    r[i]=x;\n    for(int j=i+1;j<n;j++){\n      if(a[j]<0&&x>-a[j])x=-a[j];\n      if(!a[j])x=INF;\n      r[j]=x;\n      if(x)x--;\n    }\n    break;\n  }\n  for(int i=n-1;i>=0;i--){\n    if(a[i])continue;\n    int x=INF;\n    l[i]=x;\n    for(int j=i-1;j>=0;j--){\n      if(a[j]<0&&x>-a[j])x=-a[j];\n      if(!a[j])x=INF;\n      l[j]=x;\n      if(x)x--;\n    }\n    break;\n  }\n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(a[i]>0)ans+=min(a[i],max(l[i],r[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : 加算の遅延 ( ADD )\n    S : 区間の要素を指定した値にする遅延 ( SET )\n\n    lazy_coef : \n    区間にいくら加算するのかor何をセットするのかを記録\n   */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass MixSegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N は要素数\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n  O(n)でRMQを初期化\n  [L,R)\n  tuple<int,int,int>(総和、最小値、最大値)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //各要素の値が一定でない場合 ( 配列に初期値をいれてそれで初期化する場合 )\n      //buf[] を用意し値を入れ RMQ[cur].value = buf[L]; とする\n      // RMQのL番目の要素をbuf[L]で更新\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //各要素が全て同じの場合\n      //RMQ[cur] = 0; // RMQ の各要素を０で初期化、 1 なら RMQ[cur] = 1などなど...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //initしてから使用すること!!! でないとlimitに正しい値が入っていません\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)に対して、oprを行う\n  今みてるレンジ[L,R)\n  [a,b)の各要素に対して、\n  opr が 'A'ならvを加算 ( ADD )\n  opr が 'S'ならvに置換 ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy にEMPTY以外の値がセットされているのであれば\n      その遅延を子ノードに伝える\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)が目的の範囲に入ったので、ここで処理を終える ( 今いるノードは更新するが子は更新しない, その代わり遅延を残しておく )\n        [今いるノード]            [今いるノード]\n        [子供]  [子供]     => [子供,遅延] [子供,遅延]\n        子供の値は変化しない\n        後にその子供を訪れた際に遅延を見て処理を行う\n      */\n      RMQ[index].lazy = opr; // 今いるノードに遅延を設定して処理をしてもらう\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) に対して opr を行う\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //子ノードにまだ正しい値が入っていない(遅延している)可能性があるので評価して正しい値を入れる\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //ここまでくると子の値が正しくなっているのでその和をとって今いるノードにも正しい値をいれる\n    return ret;\n  }\n\n  // [a,b) の総和、最小値、最大値を返す\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\nconst int MAX_V = 100010;\nconst int MINI_IINF = 500000;\nint W,arr[MAX_V];\n\nvoid compute(){\n  vector<int> goal;\n  rep(i,W) if( arr[i] == 0 ) goal.push_back(i);\n  if( goal.empty() ) { puts(\"0\"); return; }\n  vector<int> init(W);\n  rep(i,W) {\n    if( arr[i] >= 0 ) init[i] = MINI_IINF;\n    else              init[i] = -arr[i] - i;\n  }\n  MixSegmentTree segtree;\n  segtree.init(init.size());\n  segtree.build(init);\n\n  int index = 1;\n  int left = -1, right = goal[0];\n  int answer = 0;\n  rep(cur,W) {\n    /*\n    cout << cur << \" [\" << arr[cur] << \"] == \" << answer << endl;\n    cout << \"<\" << left << \",\" << right << \">\" << endl;\n    rep(i,W) {\n      cout << get<1>(segtree.query(i,i+1)) << \" \";\n    } puts(\"\");\n    */\n    int remain = arr[cur];\n\n    if( arr[cur] > 0 ) {\n      int maxi = 0;\n      if( left != -1 ) {\n        int mini = get<1>(segtree.query(left,cur));\n        if( mini > 0 ) maxi = max(maxi,mini);\n      } \n      if( right != -1 ) {\n        int mini = get<1>(segtree.query(cur+1,right));\n        if( mini > 0 ) maxi = max(maxi,mini);\n      }\n      answer += min(maxi,arr[cur]);\n    }\n    segtree.update(cur+1,W,'A',+1);\n    segtree.update(0,cur+1,'A',-1);\n    if( cur == right ) {\n      left = right;\n      if( index >= goal.size() ) right = -1;\n      else                       right = goal[index++];\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  scanf(\"%d\",&W);\n  rep(i,W) scanf(\"%d\",arr+i);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define ll long long\n#define ALL(x) x.begin(), x.end()\n#define INF (1 << 30)\nusing namespace std;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nint gx, gy;\n\nmap<pair<pair<int, int>, int>, bool> visited;\nmap<pair<int, int>, bool> mp;\n\nint main()\n{\n    int w;\n    cin >> w;\n    vector<int> a(w, 0);\n    rep(i, w) cin >> a[i];\n    int goal = -1;\n    int door = -1;\n    vector<int> rans(w, 0);\n    vector<int> lans(w, 0);\n    rep(i, w)\n    {\n        if (a[i] > 0 && door > 0)\n        {\n            rans[i] += min(a[i], door);\n            door--;\n        }\n        else if (a[i] == 0)\n        {\n            goal = 0;\n            door = INF;\n        }\n        else\n        {\n            door = min(door - 1, abs(a[i]) - 1);\n        }\n    }\n    door = -1;\n\n    for (int i = w - 1; i >= 0; i--)\n    {\n        if (a[i] > 0 && door > 0)\n        {\n            lans[i] += min(a[i], door);\n            door--;\n        }\n        else if (a[i] == 0)\n        {\n            goal = 0;\n            door = INF;\n        }\n        else\n        {\n            door = min(door - 1, abs(a[i]) - 1);\n        }\n    }\n    int ans = 0;\n    rep(i, w)\n    {\n        // cerr << rans[i] << \" \";\n        ans += max(lans[i], rans[i]);\n    }\n    //cerr << endl;\n    // rep(i, w)\n    //{\n    //   cerr << lans[i] << \" \";\n    // }\n    // cerr << endl;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int w; cin >> w;\n\n    vector<int> a(w);\n    for (int i = 0; i < w; i++) {\n        cin >> a[i];\n    }\n\n    vector<int> dp1(w, 0), dp2(w, 0);\n    for (int i = 0; i < w; i++) {\n        if (a[i] == 0) dp1[i] = 1e9;\n        else if (i > 0 && a[i] < 0)\n            dp1[i] = min(dp1[i - 1] - 1, -a[i]);\n        else if (i > 0)\n            dp1[i] = dp1[i - 1] - 1;\n    }\n    for (int i = w - 1; i >= 0; i--) {\n        if (a[i] == 0) dp2[i] = 1e9;\n        else if (i < w - 1 && a[i] < 0)\n            dp2[i] = min(dp2[i + 1] - 1, -a[i]);\n        else if (i < w - 1)\n            dp2[i] = dp2[i + 1] - 1;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < w; i++) {\n        if (a[i] <= 0) continue;\n        ans += max(0, min(a[i], max(dp1[i], dp2[i])));\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e10\nusing namespace std;\n\nlong long w;\nvector<long long> pre, suf, a;\n\nlong long solve();\n\nint main() {\n  cin >> w;\n  a.resize(w);\n  for(int i = 0; i < w; ++i) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = 0;\n  pre.assign(w + 2, 0);\n  suf.assign(w + 2, 0);\n  for(int i = 0; i < w; ++i)\n    if(a[i] == 0)\n      pre[i + 1] = inf;\n    else if(a[i] < 0)\n      pre[i + 1] = min(pre[i] - 1, -a[i]);\n    else\n      pre[i + 1] = pre[i] - 1;\n  for(int i = w; i > 0; --i)\n    if(a[i - 1] == 0)\n      suf[i] = inf;\n    else if(a[i - 1] < 0)\n      suf[i] = min(suf[i + 1] - 1, -a[i - 1]);\n    else\n      suf[i] = suf[i + 1] - 1;\n  for(int i = 0; i < w; ++i)\n    if(a[i] > 0)\n      ans += min(a[i], max({0LL, pre[i + 1], suf[i + 1]}));\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint W;\nvector<int> a(W);\n\nvoid exit_right(int s, int t, vector<int>& r) {\n\tfor (int i = s; i < t; ++i) {\n\t\tif (a[i] > 0) {\n\t\t\tr[i] = a[i];\n\t\t}\n\t\telse if (a[i] < 0) {\n\t\t\tfor (int j = s; j < i; ++j) {\n\t\t\t\tif (r[j] > 0) {\n\t\t\t\t\tint temp = (i - j) + a[i];\n\t\t\t\t\tr[j] = min(r[j],-temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid exit_left(int s, int t, vector<int>& l) {\n\tfor (int i = t; i > s; --i) {\n\t\tif (a[i] > 0) {\n\t\t\tl[i] = a[i];\n\t\t}\n\t\telse if (a[i] < 0) {\n\t\t\tfor (int j = i+1; j < t; ++j) {\n\t\t\t\tif (l[j] > 0) {\n\t\t\t\t\tint temp = (j - i) + a[i];\n\t\t\t\t\tl[j] = min(l[j],-temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin >> W;\n\tvector<int> exit;\n\tvector<bool> wall;\n\tint temp;\n\tbool find = false;\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> temp;\n\t\ta.push_back(temp);\n\t\tif (!find && a[i] < 0) {\n\t\t\tfind = true;\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\texit.push_back(i);\n\t\t\twall.push_back(find);\n\t\t\tfind = false;\n\t\t}\n\t}\n\n\tint res = 0;\n\tif (exit.size() > 0) {\n\t\tvector<int> r(W,0),l(W,0);\n\t\tint size = exit.size();\n\t\tfor (int i = 0; i < size+1; ++i) {\n\t\t\tif (i == 0 || i == size) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\texit_right(i,exit[i],r);\n\t\t\t\t}\n\t\t\t\tif (i == size) {\n\t\t\t\t\texit_left(exit[i-1],W-1,l);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texit_right(exit[i-1],exit[i],r);\n\t\t\t\tif (wall[i]) {\n\t\t\t\t\texit_left(exit[i-1],exit[i],l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (r[i] > 0 || l[i] > 0) {\n\t\t\t\tres += max(r[i],l[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define int long long\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nsigned main(void){\n    int n; cin >> n;\n    vi a(n);\n    for(auto & e : a) cin >> e;\n\n    vi num_es(n);\n    rep(loop, 2){\n        vi cur_num_es(n);\n        int cur = 0;\n\n        rep(i, n){\n            cur--;\n\n            if(a[i] == 0){\n                cur = inf;\n            }\n            else if(a[i] > 0){\n                cur_num_es[i] = min(a[i], cur);\n            }\n            else {\n                chmin(cur, -a[i]);\n            }\n        }\n\n        reverse(_all(a));\n\n        if(loop == 1) reverse(_all(cur_num_es));\n        rep(i, n){\n            chmax(num_es[i], cur_num_es[i]);\n        }\n    }\n\n    int res = 0;\n    for(auto & e : num_es){\n        res += e;\n    }\n    \n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nint main() {\n  int n;\n  R n;\n  int a[n];\n  rep(i,n) R a[i];\n  int x[n+1],y[n+1],ans=0;\n  x[0]=(!a[0])?MAX:-MAX;\n  REP(i,1,n) {\n    x[i]=x[i-1]-1;\n    if(!a[i]) x[i]=MAX;\n    if(a[i]<0) x[i]=min(x[i],-a[i]-1);\n  }\n  y[n]=-MAX;\n  rrep(i,n) {\n    y[i]=y[i+1]-1;\n    if(!a[i]) y[i]=MAX;\n    if(a[i]<0) y[i]=min(y[i],-a[i]-1);\n  }\n  rep(i,n) {\n    if(a[i]<=0) continue;\n    int z=max(x[i],y[i])+1;\n    ans+=max(min(a[i],z),0);\n  }\n  pr(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint can[100050];\nint a[100500];\n\nbool chmin(int &a, int b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool chmax(int &a, int b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W;\n    cin >> W;\n    for(int i = 0; i < W; i++) cin >> a[i];\n    for(int i = 0; i < W; i++) can[i] = -1;\n    priority_queue<i_i> que;\n    for(int i = 0; i < W; i++) {\n        if(a[i] == 0) {\n            can[i] = 1e9;\n            que.push({1e9, i});\n        }\n    }\n    int dw[2] = {1, -1};\n    while(!que.empty()) {\n        i_i now = que.top();\n        que.pop();\n        //cerr << now.first << \" \" << now.second << endl;\n        for(int index = 0; index <= 1; index++) {\n            int neww = now.second + dw[index];\n            if(neww < 0 || neww >= W) continue;\n            int newcost = can[now.second] - 1;\n            if(a[neww] < 0) {\n                chmin(newcost, -a[neww] - 1);\n            }\n            if(chmax(can[neww], newcost)) {\n                que.push({newcost, neww});\n            }\n        }\n    }\n    //for(int i = 0; i < W; i++) cerr << i << \" \" << can[i] << endl;\n    int ans = 0;\n    for(int i = 0; i < W; i++) {\n        if(a[i] <= 0) continue;\n        ans += min(a[i], can[i] + 1);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass MixSegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N は要素数\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    lazy_evaluate(index,L,R);\n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      RMQ[index].lazy = opr;\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); \n    return ret;\n  }\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n};\n\n\n\nconst int MAX_V = 100010;\nconst int MINI_IINF = 500000;\nint W,arr[MAX_V];\n\nvoid compute(){\n  vector<int> goal;\n  rep(i,W) if( arr[i] == 0 ) goal.push_back(i);\n  if( goal.empty() ) { puts(\"0\"); return; }\n  vector<int> init(W);\n  rep(i,W) {\n    if( arr[i] >= 0 ) init[i] = MINI_IINF;\n    else              init[i] = -arr[i] - i;\n  }\n  MixSegmentTree segtree;\n  segtree.init(init.size());\n  segtree.build(init);\n\n  int index = 1;\n  int left = -1, right = goal[0];\n  int answer = 0;\n  rep(cur,W) {\n    int remain = arr[cur];\n\n    if( arr[cur] > 0 ) {\n      int maxi = 0;\n      if( left != -1 ) {\n        int mini = get<1>(segtree.query(left,cur));\n        if( mini > 0 ) maxi = max(maxi,mini);\n      } \n      if( right != -1 ) {\n        int mini = get<1>(segtree.query(cur+1,right));\n        if( mini > 0 ) maxi = max(maxi,mini);\n      }\n      answer += min(maxi,arr[cur]);\n    }\n    segtree.update(cur+1,W,'A',+1);\n    segtree.update(0,cur+1,'A',-1);\n    if( cur == right ) {\n      left = right;\n      if( index >= goal.size() ) right = -1;\n      else                       right = goal[index++];\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  scanf(\"%d\",&W);\n  rep(i,W) scanf(\"%d\",arr+i);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t\tif (loop >= 500000000) { return 999990000; }\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define W 100010\nusing namespace std;\ntypedef long long ll;\nll w,mp[W];\nll l[W],r[W];\n \nint main(){\n  cin>>w;\n   \n  for(int i=0;i<w+2;i++)l[i]=r[i]=-10000000;\n  l[0]=0;\n  r[w+1]=0;\n \n  for(int i=1;i<=w;i++) {\n    cin>>mp[i];\n    if(mp[i]<0) l[i]=r[i]=mp[i];\n    if(mp[i]==0)l[i]=r[i]=-10000000;\n  }\n  w+=2;\n   \n  for(int i=1;i<w;i++){\n    int j=w-i-1;\n    if(mp[i]!=0)l[i]=max(l[i],l[i-1]+1);\n    if(mp[j]!=0)r[j]=max(r[j],r[j+1]+1);\n  }\n \n  ll ans=0;\n  for(int i=0;i<=w;i++){\n    if(mp[i]<=0)continue;\n    ll a=l[i]<0? min(mp[i],abs(l[i])):0;  \n    ll b=r[i]<0? min(mp[i],abs(r[i])):0;   \n    ans+=max(0LL,max(a,b));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint main() {\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tvector<int> l(n, 0), r(n, 0);\n\tint gl = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gl > 0) gl--;\n\t\tif (a[i] == 0) gl = 999999999;\n\t\tif (a[i] < 0) gl = min(gl, -a[i]);\n\t\tif (a[i] > 0) l[i] = gl;\n\t}\n\tint gr = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr > 0) gr--;\n\t\tif (a[i] == 0) gr = 999999999;\n\t\tif (a[i] < 0) gr = min(gr, -a[i]);\n\t\tif (a[i] > 0) r[i] = gr;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) ret += min(a[i], max(l[i], r[i]));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int w;\n    cin>>w;\n    vector<int> a(w);\n    for(int i=0;i<w;i++) cin>>a[i];\n\n    vector<int> avoidt(w,0);\n\n    auto f=[&](){\n        int fw=-1;\n        for(int i=0;i<w;i++){\n            if(a[i]==0){\n                fw=1e6;\n            }\n            if(a[i]<0){\n                fw=min(fw,abs(a[i]));\n            }\n            if(a[i]>0){\n                avoidt[i]=max(avoidt[i],min(fw,a[i]));\n            }\n            fw--;\n        }\n        return;\n    };\n    \n    f();\n    reverse(a.begin(),a.end());\n    reverse(avoidt.begin(),avoidt.end());\n    f();\n\n    cout<<accumulate(avoidt.begin(),avoidt.end(),0)<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint main() {\n\tint  W, a[100010], ans=0;\n\tcin>>W;\n\tREP(i, 0, W) cin>>a[i];\n\n\tvector<int> v, enter;\n\tv.push_back(-inf);\n\tREP(i, 0, W){\n\t\tif(a[i]<=0) v.push_back(i);\n\t\telse enter.push_back(i);\n\t}\n\tv.push_back(inf);\n\tfor(auto in:enter){\n\t\tint left, right;\n\t\tleft=right=a[in];\n\t\tauto itr=upper_bound(v.begin(), v.end(), in);\n\t\tif(*itr!=inf){\n\t\t\twhile(a[*itr]<0){\n\t\t\t\tright=min(right, -a[*itr]-(*itr-in));\n\t\t\t\titr++;\n\t\t\t\tif(*itr==inf){\n\t\t\t\t\tright=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tright=0;\n\t\t}\n\t\titr=upper_bound(v.begin(), v.end(), in)-1;\n\t\tif(*itr!=-inf){\n\t\t\twhile(a[*itr]<0){\n\t\t\t\tleft=min(left, -a[*itr]-(in-*itr));\n\t\t\t\titr--;\n\t\t\t\tif(*itr==-inf){\n\t\t\t\t\tleft=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tleft=0;\n\t\t}\n\t\tans+=max(left, right);\n\t}\n\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t\tif (loop >= 550000000) { return 999990000; }\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint main(){\n    int w;\n    cin >> w;\n\n    long long a[100005];\n    rep(i,w){\n        cin >> a[i];\n    }\n\n    long long away[100005] = {0};\n    long long cur = 0, ans = 0;\n    rep(i,w){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }else{\n            long long tmp = min(a[i], cur);\n            ans += tmp;\n            a[i] -= tmp;\n            away[i] += tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cur = 0; \n    for(int i = w - 1; i >= 0; i--){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }\n        else{\n            long long tmp = min(a[i], cur);\n            tmp = max(tmp - away[i], 0LL);\n            ans += tmp;\n            a[i] -= tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : 加算の遅延 ( ADD )\n    S : 区間の要素を指定した値にする遅延 ( SET )\n\n    lazy_coef : \n    区間にいくら加算するのかor何をセットするのかを記録\n   */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass MixSegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N は要素数\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n  O(n)でRMQを初期化\n  [L,R)\n  tuple<int,int,int>(総和、最小値、最大値)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //各要素の値が一定でない場合 ( 配列に初期値をいれてそれで初期化する場合 )\n      //buf[] を用意し値を入れ RMQ[cur].value = buf[L]; とする\n      // RMQのL番目の要素をbuf[L]で更新\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //各要素が全て同じの場合\n      //RMQ[cur] = 0; // RMQ の各要素を０で初期化、 1 なら RMQ[cur] = 1などなど...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //initしてから使用すること!!! でないとlimitに正しい値が入っていません\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)に対して、oprを行う\n  今みてるレンジ[L,R)\n  [a,b)の各要素に対して、\n  opr が 'A'ならvを加算 ( ADD )\n  opr が 'S'ならvに置換 ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy にEMPTY以外の値がセットされているのであれば\n      その遅延を子ノードに伝える\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)が目的の範囲に入ったので、ここで処理を終える ( 今いるノードは更新するが子は更新しない, その代わり遅延を残しておく )\n        [今いるノード]            [今いるノード]\n        [子供]  [子供]     => [子供,遅延] [子供,遅延]\n        子供の値は変化しない\n        後にその子供を訪れた際に遅延を見て処理を行う\n      */\n      RMQ[index].lazy = opr; // 今いるノードに遅延を設定して処理をしてもらう\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) に対して opr を行う\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //子ノードにまだ正しい値が入っていない(遅延している)可能性があるので評価して正しい値を入れる\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //ここまでくると子の値が正しくなっているのでその和をとって今いるノードにも正しい値をいれる\n    return ret;\n  }\n\n  // [a,b) の総和、最小値、最大値を返す\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\nconst int MAX_V = 100010;\nconst int MINI_IINF = 500000;\nint W,arr[MAX_V];\n\nvoid compute(){\n  vector<int> goal;\n  rep(i,W) if( arr[i] == 0 ) goal.push_back(i);\n  if( goal.empty() ) { puts(\"0\"); return; }\n  vector<int> init(W);\n  rep(i,W) {\n    if( arr[i] >= 0 ) init[i] = MINI_IINF;\n    else              init[i] = -arr[i] - i;\n  }\n  MixSegmentTree segtree;\n  segtree.init(init.size());\n  segtree.build(init);\n\n  int index = 1;\n  int left = -1, right = goal[0];\n  int answer = 0;\n  rep(cur,W) {\n    /*\n    cout << cur << \" [\" << arr[cur] << \"] == \" << answer << endl;\n    cout << \"<\" << left << \",\" << right << \">\" << endl;\n    rep(i,W) {\n      cout << get<1>(segtree.query(i,i+1)) << \" \";\n    } puts(\"\");\n    */\n    if( arr[cur] > 0 ) {\n      if( left != -1 ) {\n        int mini = get<1>(segtree.query(left,cur));\n        if( mini > 0 ) answer += min(mini,arr[cur]);\n      } \n      if( right != -1 ) {\n        int mini = get<1>(segtree.query(cur+1,right));\n        if( mini > 0 ) answer += min(mini,arr[cur]);\n      }\n    }\n    segtree.update(cur+1,W,'A',+1);\n    segtree.update(0,cur+1,'A',-1);\n    if( cur == right ) {\n      left = right;\n      if( index >= goal.size() ) right = -1;\n      else                       right = goal[index++];\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  scanf(\"%d\",&W);\n  rep(i,W) scanf(\"%d\",arr+i);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[110000];\nint c[110000];\nint segtree[2][262144];\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 999999999;\n\tif(c<=a&&b<=d)return segtree[f][e];\n\treturn min(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nvoid update(int a,int b,int c){\n\tb+=131072;\n\twhile(b){\n\t\tsegtree[a][b]=min(segtree[a][b],c);\n\t\tb/=2;\n\t}\n}\nint L[110000];\nint R[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",b+i);\n\tint ret=0;\n\tfor(int i=0;i<262144;i++)segtree[0][i]=segtree[1][i]=999999999;\n\tint at=-1;\n\tfor(int i=0;i<a;i++){\n\t\tif(b[i]==0)at=i;\n\t\tL[i]=at;\n\t}\n\tat=-1;\n\tfor(int i=a-1;i>=0;i--){\n\t\tif(b[i]==0)at=i;\n\t\tR[i]=at;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(b[i]<0){\n\t\t\tupdate(0,i,-b[i]+i);\n\t\t\tupdate(1,i,-b[i]-i);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(b[i]>0){\n\t\t\tint t=0;\n\t\t\tif(~L[i]){\n\t\t\t\tint val=query(0,131071,L[i],i,1,0);\n\t\t//\t\tprintf(\"%d \",val-i);\n\t\t\t\tt=max(t,val-i);\n\t\t\t}\n\t\t\tif(~R[i]){\n\t\t\t\tint val=query(0,131071,i,R[i],1,1);\n\t\t//\t\tprintf(\"%d \",val+i);\n\t\t\t\tt=max(t,val+i);\n\t\t\t}\n\t\t//\tprintf(\"%d\\n\",min(t,b[i]));\n\t\t\tret+=min(t,b[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2601&lang=jp\ntypedef long long ll;\n#define INF 1<<30\nusing namespace std;\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\t/* input */\n\tll W; cin >> W;\n\tvector<int> a(W);\n\tfor (int i = 0; i < W;i++) cin >> a[i];\n\n\t// right direction\n\tmap<int, int> ans1;\n\tint Exit = -1;\n\tint limit = INF;\n\tint limit_at = -1;\n\tfor (int i = 0; i < W;i++) {\n\t\tif (a[i] == 0) { \n\t\t\tExit = i;\n\t\t\tlimit = INF;\n\t\t\tlimit_at = -1;\n\t\t\tcontinue; \n\t\t}\n\t\tif (Exit == -1) continue;\n\t\tif (a[i] < 0) {\n\t\t\tif (limit < abs(a[i])) continue;\n\t\t\telse {\n\t\t\t\tint dif = i - limit_at;\n\t\t\t\tif (limit < abs(a[i]) + dif)continue;\n\t\t\t\tlimit = abs(a[i]);\n\t\t\t\tlimit_at = i;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint dif = i - limit_at;\n\t\t\tif (limit - dif <= 0) continue;\n\n\t\t\tans1[i] = min(limit - dif, a[i]);\n\t\t\t//cout << i << \" : \" << ans1[i] << endl;\n\t\t}\n\t}\n\n\t// left direction\n\tmap<int, int> ans2;\n\tExit = W;\n\tlimit = INF;\n\tlimit_at = W;\n\tfor (int i = W - 1; i >= 0;i--) {\n\t\tif (a[i] == 0) {\n\t\t\tExit = i;\n\t\t\tlimit = INF;\n\t\t\tlimit_at = W;\n\t\t\tcontinue;\n\t\t}\n\t\tif (Exit == W) continue;\n\t\tif (a[i] < 0) {\n\t\t\tif (abs(a[i]) > limit)continue;\n\t\t\telse {\n\t\t\t\tint dif = limit_at - i;\n\t\t\t\tif (abs(a[i]) + dif > limit)continue;\n\t\t\t\tlimit = abs(a[i]);\n\t\t\t\tlimit_at = i;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint dif = limit_at - i;\n\t\t\tif (limit - dif <= 0) continue;\n\t\t\tans2[i] = min(limit - dif, a[i]);\n\t\t\t//cout << i << \" : \" << ans2[i] << endl;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < W;i++) {\n\t\tans += max(ans1[i], ans2[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n\nint n;\nint a[100000];\nint b[100000];\n\nint main()\n{\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\t\n\tint t = 0;\n\trep(i, n){\n\t\tif (a[i] < 0) chmin(t, -a[i]);\n\t\telse if (a[i] == 0) t = INF;\n\t\tchmax(b[i], t);\n\t\tt--;\n\t}\n\tt = 0;\n\trrep(i, n){\n\t\tif (a[i] < 0) chmin(t, -a[i]);\n\t\telse if (a[i] == 0) t = INF;\n\t\tchmax(b[i], t);\n\t\tt--;\n\t}\n\n\tint res = 0;\n\trep(i, n){\n\t\tif (a[i] > 0) res += min(a[i], b[i]);\n\t}\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n;\n\tcin>>n;\n\tvi in(n),out(n);\n\trep(i,n)cin>>in[i];\n\tint res=0,t=0;\n\trep(i,n){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse out[i]=max(0,min(in[i],t));\n\t}\n\tt=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse res+=max(out[i],min(in[i],t));\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint W;\n\tcin >> W;\n\tvector<int> a(W), b(W, -1), c(W, -1);\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) b[i] = c[i] = 1e8;\n\t}\n\tfor (int i = 1; i < W; i++) {\n\t\tif (b[i - 1] > 0 && b[i] == -1) {\n\t\t\tb[i] = b[i - 1] - 1;\n\t\t\tif (a[i] < 0) {\n\t\t\t\tb[i] = min(b[i], -a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (c[i + 1] > 0 && c[i] == -1) {\n\t\t\tc[i] = c[i + 1] - 1;\n\t\t\tif (a[i] < 0) {\n\t\t\t\tc[i] = min(c[i], -a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tif (a[i] > 0 && max(b[i], c[i]) > 0) {\n\t\t\tres += min(a[i], max(b[i], c[i]));\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint cop; int dat1[400000]; int dat2[400000];\nvoid init(int cop_) {\n\tcop = 1;\n\twhile (cop < cop_)cop *= 2;\n\trep(i, 2*cop-1) {\n\t\tdat1[i] = (int)MOD;\n\t\tdat2[i] = (int)MOD;\n\t}\n}\nvoid update1(int k, int a) {\n\tk += cop - 1;\n\tdat1[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat1[k] = min(dat1[k * 2 + 1], dat1[k * 2 + 2]);\n\t}\n}\nvoid update2(int k, int a) {\n\tk += cop - 1;\n\tdat2[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat2[k] = min(dat2[k * 2 + 1], dat2[k * 2 + 2]);\n\t}\n}\nint query1(int a,int b,int k,int l,int r) {\n\tif (r <= a || b <= l)return (int)MOD;\n\tif (a <= l && r <= b)return dat1[k];\n\telse {\n\t\tint vl = query1(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query1(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint query2(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return (int)MOD;\n\tif (a <= l && r <= b)return dat2[k];\n\telse {\n\t\tint vl = query2(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query2(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n; cin >> n;\n\tcop = n;\n\tinit(cop);\n\tint a[100000]; int exr[100000]; int exl[100000];\n\tvector<int>ex; vector<int> ex2;\n\tint len = 0;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) {\n\t\t\tex.push_back(i);\n\t\t\tex2.push_back(-i);\n\t\t\tlen++;\n\t\t}\n\t}\n\tsort(ex2.begin(), ex2.end());\n\tif (len == 0) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\trep(i, n) {\n\t\tif(a[i]<0) {\n\t\t\tupdate1(i, -i - a[i]);\n\t\t\tupdate2(i, i - a[i]);\n\t\t}\n\t\tint r = lower_bound(ex.begin(), ex.end(), i) - ex.begin();\n\t\tint l = lower_bound(ex2.begin(), ex2.end(), -i) - ex2.begin();\n\t\tif (r < len) {\n\t\t\texr[i] = ex[r];\n\t\t}\n\t\telse {\n\t\t\texr[i] = -1;\n\t\t}\n\t\tif (l < len) {\n\t\t\texl[i] = -ex2[l];\n\t\t}\n\t\telse {\n\t\t\texl[i] = -1;\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, n) {\n\t\tif (a[i] <= 0)continue;\n\t\tint ma = 0;\n\t\tint lr;\n\t\tif (exr[i] != -1) {\n\t\t\tlr = query1(i, exr[i], 0, 0, cop)+i;\n\t\t\tif (lr >= 0) {\n\t\t\t\tma = max(ma, min(lr,a[i]));\n\t\t\t}\n\t\t}\n\t\tif (exl[i] != -1) {\n\t\t\tlr = query2(exl[i], i, 0, 0, cop)-i;\n\t\t\tif (lr >= 0) {\n\t\t\t\tma = max(ma, min(lr, a[i]));\n\t\t\t}\n\t\t}\n\t\tcnt += ma;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst ll inf = 1e15;\nconst int INF = 1e9;\n\nint main() {\n\tint  W, a[100010], ans = 0;\n\tcin >> W;\n\tREP(i, 0, W) cin >> a[i];\n\n\tvector<int> v, enter;\n\tREP(i, 0, W) {\n\t\tif (a[i] <= 0) v.push_back(i); // gate or exit\n\t\telse enter.push_back(i);       // entrance\n\t}\n\n\tfor (auto in : enter) {\n\t\tint left=a[in], right=a[in];\n\n\t\t// right\n\t\tauto itr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.end()) {\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tright = min(right, -a[*itr] - (*itr - in));\n\t\t\t\titr++;\n\t\t\t\tif (itr == v.end()) {\n\t\t\t\t\tright = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tright = 0;\n\t\t}\n\n\t\t// left\n\t\titr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.begin() && (itr - 1) != v.begin()) {\n\t\t\titr--;\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tleft = min(left, -a[*itr] - (in - *itr));\n\t\t\t\t\n\t\t\t\tif (itr == v.begin()) {\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tleft = 0;\n\t\t}\n\n\t\tans += max(left, right);\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint main() {\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tvector<int> l(n), r(n);\n\tint gl = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gl > 0) gl--;\n\t\tif (a[i] == 0) gl = 999999999;\n\t\tif (a[i] < 0) gl = min(gl, -a[i]);\n\t\tif (a[i] > 0) l[i] = gl;\n\t}\n\tint gr = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr > 0) gr--;\n\t\tif (a[i] == 0) gr = 999999999;\n\t\tif (a[i] < 0) gr = min(gr, -a[i]);\n\t\tif (a[i] > 0) r[i] = gr;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) ret += min(a[i], max(l[i], r[i]));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - 15000);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + 15000);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 100000001\nusing namespace std;\n\nint main()\n{\n  int w,a[100001],b[100001],c[100001];\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n  for(int i=0;i<w;i++){\n    if(a[i]==0){\n      b[i]=inf;\n      c[i]=inf;\n    }\n    else {\n      b[i]=0;\n      c[i]=0;\n    }\n  }\n  for(int i=0;i<w-1;i++){\n    if(a[i+1]==0)continue;\n    if(a[i+1]>0){\n      b[i+1]=max(0,min(b[i]-1,a[i+1]));\n    }else {\n      b[i+1]=min(b[i],(-1)*a[i+1]);\n    }\n  }\n  /*\n  for(int i=0;i<w;i++){\n    if(b[i]!=inf)cout<<b[i]<<\" \";\n    else cout<<'a'<<\" \";\n  }\n  cout<<endl;*/\n  for(int i=w-1;i>=1;i--){\n    if(a[i-1]==0)continue;\n    if(a[i-1]>0){\n      c[i-1]=max(0,min(c[i]-1,a[i-1]));\n    }else {\n      c[i-1]=max(0,min(c[i]-1,(-1)*a[i-1]));\n    }\n  }/*\n  for(int i=0;i<w;i++){\n    if(c[i]!=inf)cout<<c[i]<<\" \";\n    else cout<<'a'<<\" \";\n  }\n  cout<<endl;\n   */\n  int ans=0;\n  for(int i=0;i<w;i++){\n    if(a[i]>0)ans+=max(b[i],c[i]);\n    }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = (1LL << 60);\n\nint main(){\n    int w;\n    cin >> w;\n\n    long long a[100005];\n    rep(i,w){\n        cin >> a[i];\n    }\n\n    long long away[100005] = {0};\n    long long cur = 0, ans = 0;\n    rep(i,w){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }else{\n            long long tmp = min(a[i], cur);\n            ans += tmp;\n            away[i] += tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cur = 0; \n    for(int i = w - 1; i >= 0; i--){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }\n        else{\n            long long tmp = min(a[i], cur);\n            tmp = max(tmp - away[i], 0LL);\n            ans += tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int INF = 1e9+7;\n\nint main(){\n    int W;\n    int ans;\n    cin>>W;\n    vector<int> a(W+10);\n    \n    for(int i=0; i<W; i++){\n        cin>>a[i];\n    }\n\n    vector<int> left(W+10,-INF);\n    vector<int> right(W+10,-INF);\n\n    for(int i=0; i<W; i++){\n        if(a[i] == 0) left[i] = INF;\n        else if(a[i] > 0 && i >0) left[i] = left[i-1]-1;\n        else {\n            if(i > 0) left[i] = min(left[i-1]-1,-a[i]);\n        }\n    }\n\n    for(int i=W-1; i>=0; i--){\n        if(a[i] == 0) right[i] = INF;\n        else if(a[i] > 0 && i != W-1) right[i] = right[i+1] - 1;\n        else {\n            if(i != W-1) right[i] = min(right[i+1]-1,-a[i]);\n        }\n    }\n\n    ans = 0;\n\n    for(int i=0; i<W+1; i++){\n        int tmp1 = max(left[i],right[i]);\n        int tmp2 = min(a[i],tmp1);\n        ans += max(tmp2,0);\n    }\n\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing P=pair<int,int>; //t,x\nint main(){\n    int W;\n    cin>>W;\n    vector<int> A(W);\n    for(auto &a:A) cin>>a;\n    vector<int> M(W);//避難できる上限\n    for(int i=0;i<W;i++){\n        if(A[i]==0){\n            M[i]=10000;\n            for(int j=i+1;j<W;j++){\n                if(A[j]<=0) break;\n                else M[j]=9999;\n            }\n            for(int j=i-1;j>=0;j--){\n                if(A[j]<=0||M[j]==10000) break;\n                else M[j]=9999; \n            }\n        }\n    }\n    vector<P> Event;\n    for(int i=0;i<W;i++){\n        if(A[i]<0){\n            Event.emplace_back(A[i],i);\n        }\n    }\n    sort(Event.begin(), Event.end());\n    for(auto e:Event){\n        int t,x;\n        tie(t,x)=e;\n        if(0<=x-1) M[x]=max(M[x],min(-t,M[x-1]-1));\n        if(x+1<W) M[x]=max(M[x],min(-t,M[x+1]-1));\n        for(int i=x-1;i>=0;i--){\n            if(M[i]<M[i+1]-1){\n                M[i]=M[i+1]-1;\n            }else{\n                break;\n            }\n        }\n        for(int i=x+1;i<W;i++){\n            if(M[i]<M[i-1]-1){\n                M[i]=M[i-1]-1;\n            }else{\n                break;\n            }\n        }\n    }\n    /**\n    for(int i=0;i<W;i++){\n        cout<<M[i]<<' ';\n    }cout<<endl;**/\n    int64_t ans=0;\n    for(int i=0;i<W;i++){\n        if(A[i]>0) ans+=min(A[i],M[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\nusing namespace std;\nconst int inf=1e9;\n\nint tmp[100010];\nint main() {\n\tint W, a[100010], ans=0;\n\tcin>>W;\n\tREP(i, 0, W) cin>>a[i];\n\n\tint t=0;\n\tREP(i,0,W){\n\t\tif(a[i]==0) t=inf;\n\t\telse if(a[i]<0) t=min(t,-a[i]);\n\t\telse tmp[i]=t;\n\t\tt--;\n\t}\n\tt=0;\n\tfor(int i=W-1;i>=0;i--){\n\t\tif(a[i]==0) t=inf;\n\t\telse if(a[i]<0) t=min(t,-a[i]);\n\t\telse ans+=min(a[i],max(tmp[i],t));\n\t\tt--;\n\t}\n\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < W; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define repr(i, a, b) for (int i = (int)(a - 1); i >= b; i--)\n#define rep(i, n) repl(i, 0, n)\n#define each(itr, v) for (auto itr : v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(), (x).end()\n#define dbg(x) cout << #x \" = \" << x << endl\n#define dbgv(i, a, v) \\\n  rep(i, a) { cout << v[i] << ((i == a - 1 ? '\\n' : ' ')); }\n#define maxch(x, y) x = max(x, y)\n#define minch(x, y) x = min(x, y)\n#define uni(x) x.erase(unique(all(x)), x.end())\n#define exist(x, y) (find(all(x), y) != x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define INF INT_MAX / 3\n\nint main() {\n  cin.sync_with_stdio(false);\n  int w;\n  cin >> w;\n  int a[w] = {}, r[w] = {}, l[w] = {};\n  vector<int> in, ex, dr;\n  ex.pb(-1);\n  rep(i, w) {\n    cin >> a[i];\n    r[i] = l[i] = INF;\n    if (a[i] > 0) in.pb(i);\n    if (a[i] == 0) ex.pb(i);\n    if (a[i] < 0) dr.pb(i);\n  }\n  if (ex.size() == 1) {\n    cout << 0 << endl;\n  } else {\n    ex.pb(w);\n    rep(i, ex[1]) l[i] = -1;\n    repl(i, 1, ex.size() - 1) {\n      l[ex[i]] = -1;\n      int t = INF;\n      repl(j, ex[i] + 1, ex[i + 1]) {\n        if (a[j] < 0) {\n          if (t >= abs(a[j])) t = abs(a[j]) - 1;\n        }\n        l[j] = t;\n        t = max(t - 1, -1);\n      }\n    }\n    repr(i, w, ex[ex.size() - 2] + 1) r[i] = -1;\n    repr(i, ex.size() - 1, 1) {\n      r[ex[i]] = -1;\n      int t = INF;\n      repr(j, ex[i], ex[i - 1] + 1) {\n        if (a[j] < 0) {\n          if (t >= abs(a[j])) t = abs(a[j]) - 1;\n        }\n        r[j] = t;\n        t = max(t - 1, -1);\n      }\n    }\n    int ans = 0;\n    rep(i, w) {\n      if (a[i] > 0) ans += min(a[i] - 1, max(r[i], l[i])) + 1;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W;\nint A[100010];\nint L[100010],R[100010];\nint inf = 2e9;\nint main(){\n    cin >> W;\n    L[0] = -1; R[W+1] = -1;\n    for(int i=1;i<=W;i++){\n        cin >> A[i];\n        L[i] = -1; R[i] = -1;\n    }\n    for(int i=1;i<=W;i++){\n        if(L[i-1]==-1 && A[i]==0) L[i] = inf;\n        else{\n            if(A[i]==0) L[i] = max(L[i-1]-1,-1);\n            else if(A[i]>0) L[i] = max(L[i-1]-1,-1);\n            else{\n                if(L[i-1]==-1) L[i] = -1;\n                else L[i] = min(L[i-1]-1,-A[i]);\n            }\n        }\n    }\n    for(int i=W;i>=1;i--){\n        if(R[i+1]==-1 && A[i]==0) R[i] = inf;\n        else{\n            if(A[i]==0) R[i] = max(R[i+1]-1,-1);\n            else if(A[i]>0) R[i] = max(R[i+1]-1,-1);\n            else{\n                if(R[i+1]==-1) R[i] = -1;\n                else R[i] = min(R[i+1]-1,-A[i]);\n            }\n        }\n    }\n    int ans = 0;\n/*    for(int i=1;i<=W;i++) cerr << L[i] << \" \";\n    cerr << endl;\n    for(int i=1;i<=W;i++) cerr << R[i] << \" \";\n    cerr << endl;\n*/    for(int i=1;i<=W;i++){\n        if(A[i]<=0) continue;\n        int l = 0,r = 0;\n        if(L[i]!=-1) l = L[i];\n        if(R[i]!=-1) r = R[i];\n        ans += min(A[i],max(l,r));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W;\nint A[100010];\nint L[100010] = {},R[100010] = {};\nint inf = 2e9;\nint main(){\n    cin >> W;\n    for(int i=1;i<=W;i++){\n        cin >> A[i];\n    }\n    for(int i=1;i<=W;i++){\n        if(A[i]==0) L[i] = inf;\n        else if(A[i]>0) L[i] = max(L[i-1]-1,0);\n        else L[i] = min(max(L[i-1]-1,0),-A[i]);\n    }\n    for(int i=W;i>=1;i--){\n        if(A[i]==0) R[i] = inf;\n        else if(A[i]>0) R[i] = max(R[i+1]-1,0);\n        else R[i] = min(max(R[i+1]-1,0),-A[i]);\n    }\n    int ans = 0;\n/*    for(int i=1;i<=W;i++) cerr << L[i] << \" \";\n    cerr << endl;\n    for(int i=1;i<=W;i++) cerr << R[i] << \" \";\n    cerr << endl;\n*/    for(int i=1;i<=W;i++){\n        if(A[i]<=0) continue;\n        int l = 0,r = 0;\n        ans += min(A[i],max(L[i],R[i]));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W;\nint A[100010];\nint L[100010],R[100010];\nint inf = 2e9;\nint main(){\n    cin >> W;\n    for(int i=1;i<=W;i++){\n        cin >> A[i];\n    }\n    for(int i=1;i<=W;i++){\n        if(L[i-1]==0 && A[i]==0) L[i] = inf;\n        else{\n            if(A[i]==0) L[i] = max(L[i-1]-1,0);\n            else if(A[i]>0) L[i] = max(L[i-1]-1,0);\n            else L[i] = min(max(L[i-1]-1,0),-A[i]);\n        }\n    }\n    for(int i=W;i>=1;i--){\n        if(R[i+1]==0 && A[i]==0) R[i] = inf;\n        else{\n            if(A[i]==0) R[i] = max(R[i+1]-1,0);\n            else if(A[i]>0) R[i] = max(R[i+1]-1,0);\n            else R[i] = min(max(R[i+1]-1,0),-A[i]);\n        }\n    }\n    int ans = 0;\n    for(int i=1;i<=W;i++) cerr << L[i] << \" \";\n    cerr << endl;\n    for(int i=1;i<=W;i++) cerr << R[i] << \" \";\n    cerr << endl;\n    for(int i=1;i<=W;i++){\n        if(A[i]<=0) continue;\n        int l = 0,r = 0;\n        ans += min(A[i],max(L[i],R[i]));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint barrier[2][200000];\nint ok[2][200000];\nvoid solve(){\n\tint w;\n\tcin >> w;\n\tvector<int> inputs;\n\tREP(i, w) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\tREP(i, 200000) {\n\t\tbarrier[0][i] = 2e9;\n\t\tbarrier[1][i] = 2e9;\n\t}\n\tREP(i, w) {\n\t\tif (inputs[i] == 0) {\n\t\t\tok[0][i] = 1;\n\t\t\tbarrier[0][i] = 2e9;\n\t\t}\n\t\tok[0][i + 1] = ok[0][i];\n\n\t\tif (inputs[i] < 0) {\n\t\t\tbarrier[0][i] = min(barrier[0][i], llabs(inputs[i]));\n\t\t}\n\t\tbarrier[0][i + 1] = min(barrier[0][i + 1], barrier[0][i] - 1LL);\n\t}\n\n\tfor (int i = w - 1; i >= 0; --i) {\n\n\t\tif (inputs[i] == 0) {\n\t\t\tok[1][i] = 1;\n\t\t\tbarrier[1][i] = 2e9;\n\t\t}\n\t\tif(i != 0)\n\t\tok[1][i - 1] = ok[1][i];\n\n\t\tif (inputs[i] < 0) {\n\t\t\tbarrier[1][i] = min(barrier[1][i], llabs(inputs[i]));\n\t\t}\n\t\tif (i != 0) {\n\t\t\tbarrier[1][i - 1] = min(barrier[1][i - 1], barrier[1][i] - 1LL);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < w; ++i) {\n\t\tint hoge = 0;\n\t\tif (ok[0][i]) {\n\t\t\thoge = max(hoge, barrier[0][i]);\n\t\t}\n\t\tif (ok[1][i]) {\n\t\t\thoge = max(hoge, barrier[1][i]);\n\t\t}\n\t\thoge = min(hoge, inputs[i]);\n\t\tans += max(hoge, 0LL);\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint main(){\n    int w;\n    cin >> w;\n\n    int a[100005];\n    rep(i,w){\n        cin >> a[i];\n    }\n\n    int cur = 0, ans = 0;\n    rep(i,w){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }\n        else{\n            int tmp = min(a[i], cur);\n            ans += tmp;\n            a[i] -= tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cur = 0; \n    for(int i = w - 1; i >= 0; i--){\n        if(a[i] == 0) cur = INF;\n        else if(a[i] < 0){\n            cur = min(cur, -a[i]);\n        }\n        else{\n            int tmp = min(a[i], cur);\n            ans += tmp;\n            a[i] -= tmp;\n        }\n        if(cur > 0) cur--;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\n//end of lib\nint main() {\n\tint w;\n\tcin >> w;\n\tvi a(w), t(w, 0);\n\trep(i, w)cin >> a[i];\n\trep(i, w) {\n\t\tif (a[i] == 0)t[i] = 1e9;\n\t\telse if (i == 0)continue;\n\t\telse if (a[i] < 0)cmax(t[i],min(t[i - 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i - 1] - 1);\n\t}\n\trrep(i, w) {\n\t\tif (a[i] == 0 || i == w - 1)continue;\n\t\tif (a[i] < 0)cmax(t[i],min(t[i + 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i + 1] - 1);\n\t}\n\tll ans = 0;\n\trep(i, w) {\n\t\tif (a[i] > 0)ans += min(a[i], t[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,a[100001],t[100001]={};\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n\n  int f=0,m=1e9;\n  for(int i=0;i<w;i++,m--){\n    if(a[i]==0)f=1,m=1e9;\n    if(a[i]<0)m=min(m,-a[i]);\n    if(f&&a[i]>0)t[i]=max(0,min(a[i],m));\n  }\n\n\n  f=0,m=1e9;\n  for(int i=w-1;i>=0;i--,m--){\n    if(a[i]==0)f=1,m=1e9;\n    if(a[i]<0)m=min(m,-a[i]);\n    if(f&&a[i]>0)t[i]=max(t[i],min(a[i],m));\n  }\n\n  int ans=0;\n  for(int i=0;i<w;i++)ans+=t[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  int tt=0;\n  vector <int>uni(n,0);\n  for(int i=0;i<n;i++){\n    cin >> uni[i];\n  }\n  for(int i=0;i<n;i++){\n    int c;\n    int R=0;\n    int L=0;\n    if(uni[i]>0){\n      c=uni[i];\n      int co=0;\n      for(int j=i+1;j<n;j++){\n\tco++;\n\tif(uni[j]==0){\n\t  R=c;\n\t  break;\n\t}\n\tif(uni[j]<0){\n\t  c=min(c,uni[j]*-1-co);\n\t  if(c<=0)break;\n\t}\n      }\n      co=0;\n      for(int j=i-1;j>=0;j--){\n\tco++;\n\tif(uni[j]==0){\n\t  L=c;\n\t  break;\n\t}\n\tif(uni[j]<0){\n\t  c=uni[j]*-1-co;\n\t  if(c<=0)break;\n\t}\n      }\n      // cout << R << endl;\n      tt+=max(R,L);\n    }\n  }\n  cout << tt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nint func(){\n  int n = in();\n  vector<int> line(n);\n  foreach(i,line)i = in();\n  vector<int> dead_line_right(n,0);\n  vector<int> dead_line_left(n,0);\n  {\n    int time = -1;\n    rep(i,n){\n      --time;\n      if(line[i]==0){\n        time = INF;\n      }else if(line[i]<0){\n        chmin(time,-line[i]);\n      }else{\n        chmax(dead_line_left[i],time);\n      }\n    }\n  }\n  {\n    int time = -1;\n    per(i,n){\n      --time;\n      if(line[i]==0){\n        time = INF;\n      }else if(line[i]<0){\n        chmin(time,-line[i]);\n      }else{\n        chmax(dead_line_right[i],time);\n      }\n    }\n  }\n  int res = 0;\n  rep(i,n){\n    res += min(max(line[i],0),max({dead_line_left[i],dead_line_right[i],0}));\n  }\n  return res;\n}\n\nint main(){\n  cout << func() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n\tint W;\n\tcin>>W;\n\tint i=0;\n\tint a[100000]={0};\n\twhile(i<W){\n\t\tcin>>a[i];\n\t\ti++;\n\t}\n\n\ti=0;\n\tint cnt=0;\n\twhile(i<W){\n\t\tif(a[i]>0){\n\t\t\tint n,v,p0,p1;\n\t\t\tv=a[i];\n\t\t\tp0=100000;\n\t\t\tfor(n=i-1;n>=0;n--){\n\t\t\t\tif(a[n]<0){\n\t\t\t\t\tif(abs(a[n])-(i-n)<p0){\n\t\t\t\t\t\t//cout<<\"a[n]=\"<<a[n]<<\",i=\"<<i<<\",n=\"<<n<<endl;\n\t\t\t\t\t\tp0=abs(a[n])-(i-n);\n\t\t\t\t\t\t//cout<<\"p0=\"<<p0<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[n]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n==-1)\n\t\t\t\tp0=0;\n\t\t\telse\n\t\t\t\tif(p0==100000) p0=a[i];\n\n\t\t\tp1=100000;\n\t\t\tfor(n=i+1;n<W;n++){\n\t\t\t\tif(a[n]<0){\n\t\t\t\t\tif(abs(a[n])-(n-i)<p1){\n\t\t\t\t\t\t//cout<<\"a[n]=\"<<a[n]<<\",i=\"<<i<<\",n=\"<<n<<endl;\n\t\t\t\t\t\tp1=abs(a[n])-(n-i);\n\t\t\t\t\t\t//cout<<\"p0=\"<<p1<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[n]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n==W)\n\t\t\t\tp1=0;\n\t\t\telse\n\t\t\t\tif(p1==100000) p1=a[i];\n\n\t\t\t//cout<<\"p0,p1:\"<<p0<<\",\"<<p1<<endl;\n\t\t\tcnt+=p0<p1?p1:p0;\n\t\t}\n\t\ti++;\n\t}\n\tcout<<cnt<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Segment_Tree {\n\tvector<long long int>v;\n\tint num;\n\tlong long int ret;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = min(Update(place * 2), Update(place * 2 + 1));\n\t\treturn v[place];\n\t}\npublic:\n\tSegment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2) {\n\t\t\tnum *= 2;\n\t\t}\n\t\tv.resize(num, MOD * MOD);\n\t}\n\tvoid Insert(int place, long long int num) {\n\t\tplace += v.size() / 2;\n\t\tv[place] = num;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = min(v[place * 2], v[place * 2 + 1]);\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tlong long int RMQ(int a, int b) {\n\t\tret = INT_MAX;\n\t\tb++;\n\t\tfor (a += num/2, b += num / 2; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1)ret = min(ret, v[a++]);\n\t\t\tif (b & 1)ret = min(ret, v[--b]);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tSegment_Tree lsg(N);\n\tSegment_Tree rsg(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (v[i] < 0) {\n\t\t\tlsg.Insert(i, abs(v[i]) - i);\n\t\t\trsg.Insert(i, abs(v[i]) + i);\n\t\t}\n\t}\n\tvector<int>lexit(N, -1);\n\tvector<int>rexit(N, -1);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) {\n\t\t\tlexit[i] = lexit[i - 1];\n\t\t}\n\t\tif (v[i] == 0) {\n\t\t\tlexit[i] = i;\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (i + 1 != N) {\n\t\t\trexit[i] = rexit[i + 1];\n\t\t}\n\t\tif (v[i] == 0) {\n\t\t\trexit[i] = i;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (v[i] <= 0)continue;\n\t\tlong long int add = 0;\n\t\t//cout << i << \" \" << lexit[i] << \" \" << rexit[i] << endl;\n\t\tif (lexit[i] != -1)add = max(add, min(rsg.RMQ(lexit[i], i) - i, v[i]));\n\t\t//cout << lsg.RMQ(i, rexit[i]) << endl;\n\t\tif (rexit[i] != -1)add = max(add, min(lsg.RMQ(i, rexit[i]) + i, v[i]));\n\t\tans += add;\n\t\t//cout << i << \" \" << ans << endl;\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w;cin>>w;\n    vector<int> a(w);\n    for(int i=0;i<w;i++) cin>>a[i];\n    vector<int> dp(w,0);\n    if(a[0]==0) dp[0]=INF;\n    if(a[w-1]==0) dp[w-1]=INF;\n    for(int i=1;i<w;i++){\n        if(a[i]==0) dp[i]=INF;\n        else if(a[i]<0){\n            dp[i]=min(dp[i-1]-1, abs(a[i]));\n        }\n        else{\n            dp[i]=dp[i-1]-1;\n        }\n    }\n    for(int i=w-2;i>=0;i--){\n        if(a[i]==0) dp[i]=INF;\n        else if(a[i]<0){\n            int tmp=min(dp[i+1]-1,abs(a[i]));\n            dp[i]=max(dp[i],tmp);\n        }\n        else{\n            dp[i]=max(dp[i],dp[i+1]-1);\n        }\n    }\n    int res=0;\n    for(int i=0;i<w;i++){\n        //cout<<\" \"<<a[i]<<\" \"<<dp[i]<<endl;\n        if(a[i]==0 || a[i]<0) continue;\n        if(dp[i]<0) continue;\n        res+=min(a[i],dp[i]);\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int w;cin>>w;\n  int a[w];\n  for(int i=0;i<w;i++) cin>>a[i];\n  int c[2][w],d[2][w];\n  for(int i=0,t=-1,m=-1;i<w;i++){\n    if(a[i]<0&&(m<0||-a[m]+m>-a[i]+i)) m=i;\n    if(!a[i]) t=i,m=-1;\n    c[0][i]=m;\n    d[0][i]=t;\n  }\n  for(int i=w-1,t=-1,m=-1;i>=0;i--){\n    if(a[i]<0&&(m<0||-a[m]-m>-a[i]-i)) m=i;\n    if(!a[i]) t=i,m=-1;\n    c[1][i]=m;\n    d[1][i]=t;\n  }\n  int ans=0;\n  for(int i=0;i<w;i++){\n    int t1=0,t2=0;\n    if(d[0][i]>=0) t1=min(a[i],c[0][i]<0?a[i]:-a[c[0][i]]-i+c[0][i]);\n    if(d[1][i]>=0) t2=min(a[i],c[1][i]<0?a[i]:-a[c[1][i]]-c[1][i]+i);\n      ans+=max(0,max(t1,t2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  long long int A[W], INF = 100000000000LL;\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size();\n  long long int s, t;\n  vector<long long int> ans(W,0LL);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = INF;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+(long long int)j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = INF;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1]+1;\n    t = INF;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s));\n      }\n    }\n    s = E[0]-1;\n    t = INF;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s));\n      }\n    }\n  }\n  long long int sum = 0LL; \n\n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    //cout << ans[i] << \" \";\n  }\n  //cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n; cin >> n;\n\tvi v(n), es(n);\n\tREP(i, n) cin >> v[i];\n\tint tmp = 0;\n\tREP(i, n)\n\t{\n\t\ttmp--;\n\t\tif (v[i] == 0) tmp = INF;\n\t\telse if (v[i] < 0) chmin(tmp, -v[i]);\n\t\telse chmax(es[i], tmp);\n\t}\n\ttmp = 0;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\ttmp--;\n\t\tif (v[i] == 0) tmp = INF;\n\t\telse if (v[i] < 0) chmin(tmp, -v[i]);\n\t\telse chmax(es[i], tmp);\n\t}\n\tll ans = 0;\n\tREP(i, n) if (v[i]>0) ans += min(es[i], v[i]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e6;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W; cin >> W;\n  VI xs(W); REP(i,W) cin >> xs[i];\n  \n  VI num(W,-1);\n  int tmp = -1;\n  REP(x,W){\n\tif(xs[x] == 0) tmp = INF;\n\telse if(xs[x] > 0){\n\t  if(0 <= tmp && tmp < INF) --tmp;\n\t  num[x] = max(num[x], tmp);\n\t}\n\telse{\n\t  if(0 <= tmp && tmp < INF) --tmp;\n\t  tmp = min(tmp, abs(xs[x]) - 1);\n\t}\n  }\n\n  tmp = -1;\n  for(int x=W-1;x>=0;--x){\n\tif(xs[x] == 0) tmp = INF;\n\telse if(xs[x] > 0){\n\t  if(0 <= tmp && tmp < INF) --tmp;\n\t  num[x] = max(num[x], tmp);\n\t}\n\telse{\n\t  if(0 <= tmp && tmp < INF) --tmp;\n\t  tmp = min(tmp, abs(xs[x]) - 1);\n\t}\n  }\n\n  int ans = 0;\n  REP(x,W){\n\tif(xs[x] > 0) ans += min(num[x]+1, xs[x]);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n+2, 0), a_max(n+2, 0);\n\tfor(int i=1; i<=n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tif(a[i]!=0) continue;\n\t\tfor(int d=-1; d<2; d+=2){\n\t\t\tint shut=inf;\n\t\t\tint dist=0;\n\t\t\tfor(int j=i+d; a[j]!=0; j+=d){\n\t\t\t\tdist++;\n\t\t\t\tif(a[j]<0 && -a[j]<=shut-dist){\n\t\t\t\t\tshut = -a[j];\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t\tif(a[j]>0){\n\t\t\t\t\ta_max[j] = max(a_max[j], min(a[j], shut-dist));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tans += a_max[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint l[131072],r[130172],a[131072];\nint main(void)\n{\n  int n;\n  cin >> n;\n  FOR(i,1,n+1) cin >> a[i];\n  FOR(i,1,n+1)\n    if(a[i]<0){\n      l[i]=-a[i];\n      r[i]=-a[i];\n    }else{\n      l[i]=1048576;\n      r[i]=1048576;\n    }\n  l[0]=0;\n  REP(i,n) if(a[i+1]) l[i+1]=min(l[i]-1,l[i+1]);\n  r[n+1]=0;\n  REP(i,n) if(a[n-i]) r[n-i]=min(r[n-i+1]-1,r[n-i]);\n  int answer=0;\n  FOR(i,1,n+1) l[i]=max(l[i],r[i]);\n  FOR(i,1,n+1){\n    if(min(a[i],l[i])>0) answer+=min(a[i],l[i]);\n  }\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main (int argc, char ** argv){\n\n\tint w;\n\tint *a,*c;\n\n\tcin >> w;\n\ta = new int[w];\n\tc = new int[w];\n\n\tfor (int i=0;i<w;i++){\n\t\tcin >> a[i];\n\t\tif (a[i] > 0) c[i] = a[i];\n\t}\n\n\t//for (int i=0;i<w;i++) cout << a[i] << endl;\n\n\tint count = 0;\n\n\tfor (int i=0;i<w;i++){\n\t\tif (a[i]>0){\n\n\t\t\t//cout << \"---\" << endl;\n\t\t\t// ?????????~\n\t\t\tint p_count = c[i];\n\t\t\tfor (int xp =i ; xp<w; xp++){\n\t\t\t\tif (a[xp] < 0){\n\t\t\t\t\tint dist = xp - i;\n\t\t\t\t\tif (p_count >- (dist + a[xp]))\n\t\t\t\t\t\tp_count = - (dist + a[xp]);\n\t\t\t\t\tif (p_count <= 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if (a[xp] == 0){\n\t\t\t\t\tif (c[i] > 0){\n\t\t\t\t\t\tif (p_count <= c[i]){\n\t\t\t\t\t\t\tc[i] -= p_count;\n\t\t\t\t\t\t\tcount += p_count;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcount += c[i];\n\t\t\t\t\t\t\tc[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//cout << c[i] <<endl;\n\t\t\t// ?????????~\n\t\t\tint n_count = c[i];\n\t\t\tif (c[i] <= 0){continue;}\n\t\t\tfor (int xn =i ; xn>=0; xn--){\n\t\t\t\tif (a[xn] < 0){\n\t\t\t\t\tint dist = i-xn;\n\t\t\t\t\tif (n_count >- (dist + a[xn]))\n\t\t\t\t\t\tn_count = - (dist + a[xn]);\n\n\t\t\t\t\t//cout << n_count << endl;\n\t\t\t\t\tif (n_count <= 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if (a[xn] == 0){\n\t\t\t\t\tif (c[i] > 0){\n\t\t\t\t\t\tif (n_count <= c[i]){\n\t\t\t\t\t\t\tc[i] -= n_count;\n\t\t\t\t\t\t\tcount += n_count;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcount += c[i];\n\t\t\t\t\t\t\tc[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\t//cout << c[i] << endl;\n\t\t}\n\t}\n\n\tcout << count << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint main(){\n  int w;\n  scanf(\"%d\",&w);\n  vector<int> a(w);\n  for(int i=0;i<w;i++)scanf(\"%d\",&a[i]);\n\n  vector<int> pop(w,0);\n\n  int t = 0;\n  for(int i=0;i<w;i++){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else{\n      pop[i] = max(pop[i], t);\n    }\n    t = max(t-1,0);\n  }\n\n  t = 0;\n  for(int i=w-1;i>=0;i--){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else{\n      pop[i] = max(pop[i], t);\n    }\n    t = max(t-1,0);\n  }\n\n  int ans = 0;\n  for(int i=0;i<w;i++){\n    if(a[i]>0)ans += min(pop[i], a[i]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\nusing namespace std;\nconst int inf=1e9;\n\nint main() {\n\tint W, a[100010], ans=0;\n\tcin>>W;\n\tREP(i, 0, W) cin>>a[i];\n\n\tvector<int> v, enter;\n\tv.push_back(-inf);\n\tREP(i, 0, W){\n\t\tif(a[i]<=0) v.push_back(i);\n\t\telse enter.push_back(i);\n\t}\n\tv.push_back(inf);\n\tfor(auto in:enter){\n\t\tint left, right;\n\t\tleft=right=a[in];\n\t\tauto itr=upper_bound(v.begin(), v.end(), in);\n\t\tif(*itr!=inf){\n\t\t\twhile(a[*itr]<0){\n\t\t\t\tright=min(right,max(0, -a[*itr]-(*itr-in)));\n\t\t\t\titr++;\n\t\t\t\tif(*itr==inf){\n\t\t\t\t\tright=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tright=0;\n\t\t}\n\t\titr=upper_bound(v.begin(), v.end(), in)-1;\n\t\tif(*itr!=-inf){\n\t\t\twhile(a[*itr]<0){\n\t\t\t\tleft=min(left,max(0, -a[*itr]-(in-*itr)));\n\t\t\t\titr--;\n\t\t\t\tif(*itr==-inf){\n\t\t\t\t\tleft=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tleft=0;\n\t\t}\n\t\tans+=max(left, right);\n\t}\n\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <set>\n#define NOTHING 2 << 31\nusing namespace std;\ntypedef map<int, int> M;\ntypedef set<int> S;\n\ninline int zero_if_nothing(int num) {\n  return num == NOTHING ? 0 : num;\n}\n\nint main() {\n  int w, a;\n  cin >> w;\n  M ents, shuts;\n  S escs;\n  for (int i = 0; i < w; i++) {\n    cin >> a;\n    if (a > 0) {\n      ents[i] = a;\n    } else if (a < 0) {\n      shuts[i] = -a;\n    } else {\n      escs.insert(i);\n    }\n  }\n\n  int r = 0;\n  for (auto&& ent : ents) {\n    auto right_escit = escs.upper_bound(ent.first);\n    auto left_escit = right_escit;\n    if (right_escit != escs.begin()) {\n      left_escit--;\n    } else {\n      left_escit = escs.end();\n    }\n    auto right_esc = right_escit != escs.end() ? *right_escit : ent.first;\n    auto left_esc = left_escit != escs.end() ? *left_escit : ent.first;\n    int r_by_side[2] = {\n      left_esc == ent.first ? NOTHING : ent.second,\n      right_esc == ent.first ? NOTHING : ent.second\n    };\n    for (\n      auto shutit = shuts.upper_bound(left_escit != escs.end() ? *left_escit : ent.first);\n      shutit != shuts.end() && shutit->first < right_esc;\n      shutit++\n    ) {\n      ent.first;\n      bool side = ent.first < shutit->first;\n      r_by_side[side] = min(\n        r_by_side[side],\n        min(max(shutit->second - abs(ent.first - shutit->first), 0), ent.second)\n      );\n    }\n    r += max(zero_if_nothing(r_by_side[0]), zero_if_nothing(r_by_side[1]));\n  }\n\n  cout << r << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nint W,arr[100100],maxi[100100];\n\nint main(){\n  scanf(\"%d\",&W);\n  rep(i,W) { scanf(\"%d\",arr+i); maxi[i] = 0; }\n  int mini = 0;\n  rep(i,W) {\n    if( arr[i] == 0 ) mini = IINF;\n    else if( arr[i] < 0 ) mini = min(mini-1,-arr[i]);\n    else if( mini-1 > 0 ) maxi[i] = max(maxi[i],min(mini-1,arr[i])), --mini;\n  }\n  mini = 0;\n  for(int i=W-1;i>=0;i--){\n    if( arr[i] == 0 ) mini = IINF;\n    else if( arr[i] < 0 ) mini = min(mini-1,-arr[i]);\n    else if( mini-1 > 0 ) maxi[i] = max(maxi[i],min(mini-1,arr[i])), --mini;\n  }\n  int answer = 0;\n  rep(i,W) if( arr[i] > 0 ) answer += maxi[i];\n  printf(\"%d\\n\",answer);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : 加算の遅延 ( ADD )\n    S : 区間の要素を指定した値にする遅延 ( SET )\n\n    lazy_coef : \n    区間にいくら加算するのかor何をセットするのかを記録\n   */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass MixSegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N は要素数\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n  O(n)でRMQを初期化\n  [L,R)\n  tuple<int,int,int>(総和、最小値、最大値)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //各要素の値が一定でない場合 ( 配列に初期値をいれてそれで初期化する場合 )\n      //buf[] を用意し値を入れ RMQ[cur].value = buf[L]; とする\n      // RMQのL番目の要素をbuf[L]で更新\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //各要素が全て同じの場合\n      //RMQ[cur] = 0; // RMQ の各要素を０で初期化、 1 なら RMQ[cur] = 1などなど...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //initしてから使用すること!!! でないとlimitに正しい値が入っていません\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)に対して、oprを行う\n  今みてるレンジ[L,R)\n  [a,b)の各要素に対して、\n  opr が 'A'ならvを加算 ( ADD )\n  opr が 'S'ならvに置換 ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy にEMPTY以外の値がセットされているのであれば\n      その遅延を子ノードに伝える\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)が目的の範囲に入ったので、ここで処理を終える ( 今いるノードは更新するが子は更新しない, その代わり遅延を残しておく )\n        [今いるノード]            [今いるノード]\n        [子供]  [子供]     => [子供,遅延] [子供,遅延]\n        子供の値は変化しない\n        後にその子供を訪れた際に遅延を見て処理を行う\n      */\n      RMQ[index].lazy = opr; // 今いるノードに遅延を設定して処理をしてもらう\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) に対して opr を行う\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //子ノードにまだ正しい値が入っていない(遅延している)可能性があるので評価して正しい値を入れる\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //ここまでくると子の値が正しくなっているのでその和をとって今いるノードにも正しい値をいれる\n    return ret;\n  }\n\n  // [a,b) の総和、最小値、最大値を返す\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\nconst int MAX_V = 100010;\nconst int MINI_IINF = 500000;\nint W,arr[MAX_V];\n\nvoid compute(){\n  vector<int> goal;\n  rep(i,W) if( arr[i] == 0 ) goal.push_back(i);\n  if( goal.empty() ) { puts(\"0\"); return; }\n  vector<int> init(W);\n  rep(i,W) {\n    if( arr[i] >= 0 ) init[i] = MINI_IINF;\n    else              init[i] = -arr[i] - i;\n  }\n  MixSegmentTree segtree;\n  segtree.init(init.size());\n  segtree.build(init);\n\n  int index = 1;\n  int left = -1, right = goal[0];\n  int answer = 0;\n  rep(cur,W) {\n    /*\n    cout << cur << \" [\" << arr[cur] << \"] == \" << answer << endl;\n    cout << \"<\" << left << \",\" << right << \">\" << endl;\n    rep(i,W) {\n      cout << get<1>(segtree.query(i,i+1)) << \" \";\n    } puts(\"\");\n    */\n    int remain = arr[cur];\n    if( arr[cur] > 0 ) {\n      if( left != -1 ) {\n        int mini = get<1>(segtree.query(left,cur));\n        if( mini > 0 ) { answer += min(mini,remain); remain -= min(mini,remain); }\n      } \n      if( right != -1 ) {\n        int mini = get<1>(segtree.query(cur+1,right));\n        if( mini > 0 ) { answer += min(mini,remain); remain -= min(mini,remain); }\n      }\n    }\n    segtree.update(cur+1,W,'A',+1);\n    segtree.update(0,cur+1,'A',-1);\n    if( cur == right ) {\n      left = right;\n      if( index >= goal.size() ) right = -1;\n      else                       right = goal[index++];\n    }\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  scanf(\"%d\",&W);\n  rep(i,W) scanf(\"%d\",arr+i);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvi a;\n\nvi f(){\n\tvi b(n);\n\tint t=0;\n\tfor(int i=0;i<n;i++){\n\t\tt=max(t-1,0);\n\t\tif(a[i]<0) t=min(t,-a[i]);\n\t\tif(a[i]==0) t=inf;\n\t\tb[i]=t;\n\t}\n\treverse(a.begin(),a.end());\n\treturn b;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n;\n\ta=vi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tvi b=f(),c=f();\n\tint res=0;\n\tfor(int i=0;i<n;i++) if(a[i]>0) res+=min(a[i],max(b[i],c[n-i-1]));\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst ll inf = 1e15;\nconst int INF = 1e9;\n\nint main() {\n\tint  W, a[100010], ans = 0;\n\tcin >> W;\n\tREP(i, 0, W) cin >> a[i];\n\n\tvector<int> v, enter;\n\tREP(i, 0, W) {\n\t\tif (a[i] <= 0) v.push_back(i); // gate or exit\n\t\telse enter.push_back(i);       // entrance\n\t}\n\n\tfor (auto in : enter) {\n\t\tint left=a[in], right=a[in];\n\n\t\tauto itr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.end()) {\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tright = min(right, -a[*itr] - (*itr - in));\n\t\t\t\titr++;\n\t\t\t\tif (itr == v.end()) {\n\t\t\t\t\tright = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tright = 0;\n\t\t}\n\n\t\titr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.begin() && (itr - 1) != v.begin()) {\n\t\t\titr--;\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tleft = min(left, -a[*itr] - (in - *itr));\n\t\t\t\t\n\t\t\t\tif (itr == v.begin()) {\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tleft = 0;\n\t\t}\n\n\t\tans += max(left, right);\n\t\t\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n\nint main() {\n    int W;\n    cin >> W;\n    vector<int> v(W);\n    for(int i=0; i<W; ++i) {\n        cin >> v[i];\n    }\n    int l_out = -1, r_out = -1;\n    int l_wall = -1, r_wall = -1;\n    vector<int> ans(W);\n    for(int i=0; i<W; ++i) {\n        if(v[i] < 0) {\n            if(l_wall == -1 || i-l_wall-v[i] < -v[l_wall]) {\n                l_wall = i;\n            }\n        } else if(v[i] == 0) {\n            l_out = i;\n            l_wall = -1;\n        } else {\n            if(l_out != -1) {\n                if(l_wall == -1) {\n                    ans[i] = v[i];\n                } else if(i-l_wall+v[l_wall] < 0) {\n                    ans[i] = max(ans[i], min(-v[l_wall]-i+l_wall, v[i]));\n                }\n            }\n        }\n        int r = v.size() - 1 - i;\n        if(v[r] < 0) {\n            if(r_wall == -1 || r_wall-r-v[r] < -v[r_wall]) {\n                r_wall = r;\n            }\n        } else if(v[r] == 0) {\n            r_out = r;\n            r_wall = -1;\n        } else {\n            if(r_out != -1) {\n                if(r_wall == -1) {\n                    ans[r] = v[r];\n                } else if(r_wall-r+v[r_wall] < 0) {\n                    ans[r] = max(ans[r], min(-v[r_wall]+r-r_wall, v[r]));\n                }\n            }\n        }\n    }\n    cout << accumulate(ans.begin(), ans.end(), 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\n//end of lib\nint main() {\n\tint w;\n\tcin >> w;\n\tvi a(w), t(w, 0);\n\trep(i, w)cin >> a[i];\n\trep(i, w) {\n\t\tif (a[i] == 0)t[i] = 1e5;\n\t\telse if (i == 0)continue;\n\t\telse if (a[i] < 0)cmax(t[i],min(t[i - 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i - 1] - 1);\n\t}\n\trrep(i, w) {\n\t\tif (a[i] == 0 || i == w - 1)continue;\n\t\tif (a[i] < 0)cmax(t[i],min(t[i + 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i + 1] - 1);\n\t}\n\tll ans = 0;\n\trep(i, w) {\n\t\tif (a[i] > 0)ans += min(a[i], t[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define var auto\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    //cout << setprecision(15) << fixed;\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    bool containsExit = false;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        if (a[i] == 0) containsExit = true;\n    }\n    if (!containsExit){\n        cout << 0 << endl;\n        return 0;\n    }\n    int curMax = 0;\n    vector<int> maxTime(n, 0);\n    for (int i = 0; i < n; i++){\n        if (a[i] == 0) curMax = 1 << 29;\n        else if (a[i] < 0){\n            chmin(curMax, abs(a[i]));\n        }\n        else chmax(maxTime[i], curMax);\n        curMax--;\n    }\n    curMax = 0;\n    for (int i = n - 1; i >= 0; i--){\n        if (a[i] == 0) curMax = 1 << 29;\n        else if (a[i] < 0){\n            chmin(curMax, abs(a[i]));\n        }\n        else chmax(maxTime[i], curMax);\n        curMax--;\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++){\n        if (a[i] <= 0) continue;\n        if (maxTime[i] <= 0) continue;\n        res += min(a[i], maxTime[i]);\n    }\n    cout << res << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\n\n\nint main()\n{\n\tint w;\n\tcin >> w;\n\tvector<int> a(w);\n\tREP(i, w)cin >> a[i];\n\n\tint now = 0;\n\tvector<int> cap(w);\n\tREP(i, w) {\n\t\tnow--;\n\t\tif (a[i] == 0)now = INF;\n\t\telse if (a[i] < 0) {\n\t\t\tnow = min(now, -a[i]);\n\t\t}\n\t\tcap[i] = now;\n\t}\n\n\tnow = 0;\n\tfor (int i = w - 1; i >= 0; i--) {\n\t\tnow--;\n\t\tif (a[i] == 0)now = INF;\n\t\telse if (a[i] < 0) {\n\t\t\tnow = min(now, -a[i]);\n\t\t}\n\t\tcap[i] = max(cap[i], now);\n\t}\n\tREP(i, w)cap[i] = max(cap[i], 0);\n\n\tll res = 0;\n\tREP(i, w)if (a[i] > 0) {\n\t\tres += min(a[i], cap[i]);\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint W;\nvector<int> a(W);\n\nvoid exit_right(int s, int t, vector<int>& r) {\n\tfor (int i = s; i < t; ++i) {\n\t\tif (a[i] > 0) {\n\t\t\tr[i] = a[i];\n\t\t}\n\t\telse if (a[i] < 0) {\n\t\t\tfor (int j = s; j < i; ++j) {\n\t\t\t\tif (r[j] > 0) {\n\t\t\t\t\tint temp = (i - j) + a[i];\n\t\t\t\t\tr[j] = min(r[j],-temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid exit_left(int s, int t, vector<int>& l) {\n\tfor (int i = t; i > s; --i) {\n\t\tif (a[i] > 0) {\n\t\t\tl[i] = a[i];\n\t\t}\n\t\telse if (a[i] < 0) {\n\t\t\tfor (int j = i+1; j < t; ++j) {\n\t\t\t\tif (l[j] > 0) {\n\t\t\t\t\tint temp = (j - i) + a[i];\n\t\t\t\t\tl[j] = min(l[j],-temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin >> W;\n\tvector<int> exit;\n\tvector<bool> wall;\n\tint temp;\n\tbool find = false;\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> temp;\n\t\ta.push_back(temp);\n\t\tif (!find && a[i] < 0) {\n\t\t\tfind = true;\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\texit.push_back(i);\n\t\t\twall.push_back(find);\n\t\t\tfind = false;\n\t\t}\n\t}\n\n\tint res = 0;\n\tif (exit.size() > 0) {\n\t\tvector<int> r(W,0),l(W,0);\n\t\tint size = exit.size();\n\t\tfor (int i = 0; i < size+1; ++i) {\n\t\t\tif (i == 0 || i == size) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\texit_right(i,exit[i],r);\n\t\t\t\t}\n\t\t\t\tif (i == size) {\n\t\t\t\t\texit_left(exit[i-1],W,l);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texit_right(exit[i-1],exit[i],r);\n\t\t\t\tif (wall[i]) {\n\t\t\t\t\texit_left(exit[i-1],exit[i],l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (r[i] > 0 || l[i] > 0) {\n\t\t\t\tres += max(r[i],l[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nint W, A[100000];\nint d, limit[100000];\n\nint main(void) {\n  cin >> W;\n  REP(i, 0, W) cin >> A[i];\n\n  REP(i, 0, W) limit[i] = 0;\n\n  d = 0;\n  REP(i, 0, W) {\n    if(A[i] == 0) d = INF;\n    if(A[i] < 0) d = min(d, -A[i]);\n    if(A[i] > 0) limit[i] = max(limit[i], d);\n    if(d > 0) d--;\n  }\n\n  d = 0;\n  REP(j, 0, W) {\n    int i = W - j - 1;\n    if(A[i] == 0) d = INF;\n    if(A[i] < 0) d = min(d, -A[i]);\n    if(A[i] > 0) limit[i] = max(limit[i], d);\n    if(d > 0) d--;\n  }\n\n  ll ans = 0;\n  REP(i, 0, W) if(A[i] > 0) ans += min(A[i], limit[i]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W;\nint A[100010];\nint L[100010],R[100010];\nint inf = 2e9;\nint main(){\n    cin >> W;\n    for(int i=1;i<=W;i++){\n        cin >> A[i];\n    }\n    for(int i=1;i<=W;i++){\n        if(L[i-1]==0 && A[i]==0) L[i] = inf;\n        else{\n            if(A[i]==0) L[i] = max(L[i-1]-1,0);\n            else if(A[i]>0) L[i] = max(L[i-1]-1,0);\n            else L[i] = min(max(L[i-1]-1,0),-A[i]);\n        }\n    }\n    for(int i=W;i>=1;i--){\n        if(R[i+1]==0 && A[i]==0) R[i] = inf;\n        else{\n            if(A[i]==0) R[i] = max(R[i+1]-1,0);\n            else if(A[i]>0) R[i] = max(R[i+1]-1,0);\n            else R[i] = min(max(R[i+1]-1,0),-A[i]);\n        }\n    }\n    int ans = 0;\n/*    for(int i=1;i<=W;i++) cerr << L[i] << \" \";\n    cerr << endl;\n    for(int i=1;i<=W;i++) cerr << R[i] << \" \";\n    cerr << endl;\n*/    for(int i=1;i<=W;i++){\n        if(A[i]<=0) continue;\n        int l = 0,r = 0;\n        ans += min(A[i],max(L[i],R[i]));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t\tif (loop >= 550000000) { return 999990000; }\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << ' ' << loop << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - 15000);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + 15000);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#define INF 1e7\nusing namespace std;\n\nvector<int> index2;\n\nint w,n;\nint val[2][1<<18];\nvoid init(){\n\tn=1;\n\twhile(n<w)n*=2;\n\tfor(int i=0;i<2*n-1;i++)val[0][i]=val[1][i]=INF;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tval[0][k]=a-(k-(n-1));\n\tval[1][k]=a-(w-1-(k-(n-1)));\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tval[0][k]=min(val[0][k*2+1],val[0][k*2+2]);\n\t\tval[1][k]=min(val[1][k*2+1],val[1][k*2+2]);\n\t}\n}\n\nint query(int d,int a,int b,int k=0,int l=0,int r=n){\n\tif(a<=l && r<=b)return val[d][k];\n\tif(r<=a || b<=l)return INF;\n\tint vl=query(d,a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(d,a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n}\n\nint a[100001];\n\nint main(void){\n\tscanf(\"%d\",&w);\n\tinit();\n\tindex2.push_back(-1);\n\tfor(int i=0;i<w;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]==0)index2.push_back(i);\n\t\tif(a[i]<0){\n\t\t\tupdate(i,-a[i]);\n\t\t}\n\t}\n\tindex2.push_back(w);\n\tint cnt=0;\n\tfor(int i=0;i<w;i++){\n\t\tif(a[i]>0){\n\t\t\tint num=0;\n\t\t\tint ld=lower_bound(index2.begin(),index2.end(),i)-index2.begin();\n\t\t\tld--;\n\t\t\tint dat1=-INF,dat2=-INF;\n\t\t\tif(ld!=0){\n\t\t\t\tdat1=query(1,index2[ld]+1,i);\n\t\t\t\tif(dat1>=-(w-1-i))num=max(num,min(dat1+(w-1-i),a[i]));\n\t\t\t}\n\t\t\tint rd=lower_bound(index2.begin(),index2.end(),i)-index2.begin();\n\t\t\tif(rd!=index2.size()-1){\n\t\t\t\tdat2=query(0,i+1,index2[rd]);\n\t\t\t\tif(dat2>=-i)num=max(num,min(dat2+i,a[i]));\n\t\t\t}\n\t\t\tcnt+=num;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint A[111111];\nint ma[111111];\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>A[i];\n\n    int t=0;\n    for(int i=0;i<N;i++){\n        t--;\n        if(A[i]==0)t=INT_MAX;\n        else if(A[i]>0)chmax(ma[i],t);\n        else chmin(t,-A[i]);\n    }\n    t=0;\n    for(int i=N-1;i>=0;i--){\n        t--;\n        if(A[i]==0)t=INT_MAX;\n        else if(A[i]>0)chmax(ma[i],t);\n        else chmin(t,-A[i]);\n    }\n\n    int ans=0;\n    rep(i,N)if(A[i]>0)ans+=min(A[i],ma[i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\n\nint main() {\n    int W;\n    cin >> W;\n\n    vector<int> A(W);\n    for (auto& a : A) cin >> a;\n\n    vector<int> L(W);\n    // 時刻L[i]未満に来た人は左に行くと助かる\n    L[0] = (A[0] == 0 ? INF : -INF);\n    for (int i = 1; i < W; ++i) {\n        L[i] = L[i - 1] - 1;\n        if (A[i] < 0) {\n            L[i] = min(L[i], -A[i]);\n        } else if (A[i] == 0) {\n            L[i] = INF;\n        }\n    }\n\n    vector<int> R(W);\n    R[W - 1] = (A[W - 1] == 0 ? INF : -INF);\n    for (int i = W - 2; i >= 0; --i) {\n        R[i] = R[i + 1] - 1;\n        if (A[i] < 0) {\n            R[i] = min(R[i], -A[i]);\n        } else if (A[i] == 0) {\n            R[i] = INF;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < W; ++i) {\n        if (A[i] <= 0) continue;\n        ans += max(0, min(A[i], max(L[i], R[i])));\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int W; cin >> W;\n    vector<int> a(W);\n    REP(i, W) cin >> a[i];\n\n    vector<int> ma(W);\n\n    {\n        vector<int> dp(W+1);\n        RREP(i, W) {\n            if (a[i] == 0) {\n                dp[i] = INF;\n            }\n            if (a[i] < 0) {\n                dp[i] = min(dp[i+1] - 1, abs(a[i]));\n            }\n            if (a[i] > 0) {\n                dp[i] = dp[i+1] - 1;\n            }\n        }\n        REP(i, W) chmax(ma[i], dp[i]);\n    }\n    {\n        vector<int> dp(W+1);\n        REP(i, W) {\n            if (a[i] == 0) {\n                dp[i+1] = INF;\n            }\n            if (a[i] < 0) {\n                dp[i+1] = min(dp[i] - 1, abs(a[i]));\n            }\n            if (a[i] > 0) {\n                dp[i+1] = dp[i] - 1;\n            }\n        }\n        REP(i, W) chmax(ma[i], dp[i+1]);\n    }\n    ll ans = 0;\n    REP(i, W) {\n        if (a[i] > 0) {\n            ans += min(a[i], ma[i]);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    vector<int> dp(n);\n    int ans = -1;\n    for (int i = 0; i < n; ++i) {\n        ans--;\n        if(!v[i]) ans = INF<int>;\n        else if(v[i] < 0){\n            ans = min(ans, -v[i]);\n        }else {\n            dp[i] = max(dp[i], min(v[i], ans));\n        }\n    }\n    ans = -1;\n    for (int i = n-1; i >= 0; --i) {\n        ans--;\n        if(!v[i]) ans = INF<int>;\n        else if(v[i] < 0){\n            ans = min(ans, -v[i]);\n        }else {\n            dp[i] = max(dp[i], min(v[i], ans));\n        }\n\n    }\n    cout << accumulate(dp.begin(),dp.end(), 0) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n;\n\tcin>>n;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tint out=0,t=0;\n\trep(i,n){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse{\n\t\t\tint s=max(0,min(in[i],t));\n\t\t\tout+=s;\n\t\t\tin[i]-=s;\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse{\n\t\t\tint s=max(0,min(in[i],t));\n\t\t\tout+=s;\n\t\t\tin[i]-=s;\n\t\t}\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e8;\n\nint main() {\n    int n;\n    cin >> n;\n    VI a(n);\n    REP(i,n) cin >> a[i];\n    VI d(n);\n    priority_queue<P, vector<P>, greater<P> > q;\n    REP(i,n){\n        if (a[i] == 0){\n            d[i] = -INF;\n            q.push(P(-INF,i));\n        }\n    }\n    while (!q.empty()){\n        P p = q.top();\n        q.pop();\n        int now = p.second;\n        if(d[now] < p.first) continue;\n        FOR(i,-1,1){\n            int next = now + i;\n            if (next < 0 || next >= n) continue;\n            int cost = d[now] + 1;\n            if (a[next] < 0) cost = max(cost, a[next]);\n            if (d[next] > cost){\n                d[next] = cost;\n                q.push(P(d[next], next));\n            }\n        }\n    }\n    int ans = 0;\n    REP(i,n){\n        if (a[i] > 0){\n            ans += min(a[i], -d[i]);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint W;\n\tcin >> W;\n\tvector<int> a(W),s;\n\tint exit = false;\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) {\n\t\t\t++exit;\n\t\t}\n\t}\n\n\tint res = 0;\n\tif (exit > 0) {\n\t\tvector<int> r(W,0),l(W,0);\n\t\tint ce,ind;\n\t\tce = ind = 0;\n\t\tfor (int i = 0; ce < exit && i < W; ++i) {\n\t\t\tr[i] = a[i];\n\t\t\tif (a[i] < 0) {\n\t\t\t\tfor (int j = ind; j < i; ++j) {\n\t\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\t\tif (r[j] > 0) {\n\t\t\t\t\t\t\tint temp = (i - j) + a[i];\n\t\t\t\t\t\t\tr[j] = min(r[j],-temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] == 0) {\n\t\t\t\tind = i + 1;\n\t\t\t\t++ce;\n\t\t\t}\n\t\t}\n\t\tce = 0;\n\t\tind = W-1;\n\t\tfor (int i = W-1; ce < exit && i >= 0; --i) {\n\t\t\tl[i] = a[i];\n\t\t\tif (a[i] < 0) {\n\t\t\t\tfor (int j = ind; j > i; --j) {\n\t\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\t\tif (l[j] > 0 && l[j] > r[j]) {\n\t\t\t\t\t\t\tint temp = (j - i) + a[i];\n\t\t\t\t\t\t\tl[j] = min(l[j],-temp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] == 0) {\n\t\t\t\tind = i - 1;\n\t\t\t\t++ce;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tif (r[i] > 0 || l[i] > 0) {\n\t\t\t\tres += max(r[i],l[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define pii pair<int,int>\n#define INF 1000000000\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<int> node;\npublic:\n  SegmentTree(vector<int> v){\n    int sz = v.size();\n    n = 1;\n    while(n<sz) n *= 2;\n    node.resize(2*n-1,INF);\n    for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n    for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n  }\n\n  void update(int x, int val){\n    x += (n-1);\n    node[x] = val;\n    while(x>0){\n      x = (x-1)/2;\n      node[x] = min(node[2*x+1],node[2*x+2]);\n    }\n  }\n\n  int getmin(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    if(r<=a||b<=l) return INF;\n    if(a<=l&&r<=b) return node[k];\n    int vl = getmin(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmin(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  void show(){\n    for(int i=n-1;i<node.size()-1;i++){\n      cout << node[i] << \" \";\n    }\n    cout << node[node.size()-1] << endl;\n  }\n};\n\nint main(){\n\n  int w;\n  cin >> w;\n  vector<int> a(w);\n  rep(i,w)cin >> a[i];\n  int n_e=0;\n  vector<int> escape;\n  rep(i,w)if(a[i]==0){\n    n_e++;\n    escape.push_back(i);\n  }\n  if(n_e==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  // 各ユニットの最寄りの出口\n  vector<int> nearL(w,-INF),nearR(w,-INF);\n  vector<int> dd,dd2;\n  int ind = -1;\n  rep(i,w){\n    if(a[i]>0){\n      nearL[i] = ind;\n      nearR[i] = ind+1;\n      if(ind+1==n_e)nearR[i]=-1;\n      dd.push_back(INF);\n      dd2.push_back(INF);\n    }else if(a[i]==0){\n      ind++;\n      dd.push_back(INF);\n      dd2.push_back(INF);\n    }else{\n      dd.push_back(-a[i]+i);\n      dd2.push_back(-a[i]-i);\n    }\n  }\n\n  SegmentTree st1(dd),st2(dd2);\n\n  int sum = 0;\n  int el,er,flag,minl,minr;\n  int lflag=1,rflag=1;\n  rep(i,w){\n    if(a[i]>0){\n      if(nearL[i]>=0) {el = escape[nearL[i]];lflag=1;}\n      else lflag=0;\n      if(nearR[i]>=0) {er = escape[nearR[i]];rflag=1;}\n      else rflag=0;\n      flag = 0;\n      minl = -INF; minr = -INF;\n      if(lflag&&st1.getmin(el+1,i)<INF){minl = max(st1.getmin(el+1,i)-i,0);flag=1;}\n      if(rflag&&st2.getmin(i+1,er)<INF){minr = max(st2.getmin(i+1,er)+i,0);flag=1;}\n      int ret = min(max(minl,minr),a[i]);\n      if(flag)sum += ret;\n      else sum += a[i];\n    }\n  }\n  \n  cout << sum << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,a[100001],p=0,a1[100001],a2[100001],ans;\nmain(){\n  cin>>n;\n  r(i,n)cin>>a[i];\n  r(i,n){\n    if(!a[i])p=1e9;\n    if(a[i]<0)p=min(p,-a[i]);\n    if(a[i]>0)a1[i]=max(a1[i],min(a[i],p));\n    p--;\n  }\n  p=0;\n  for(int i=n-1;i>=0;i--){\n    if(!a[i])p=1e9;\n    if(a[i]<0)p=min(p,-a[i]);\n    if(a[i]>0)a1[i]=max(a1[i],min(a[i],p));\n    p--;\n  }\n  r(i,n)ans+=max(a1[i],a2[i]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\tint W; cin >> W;\n\tvector<int>as(W);\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> as[i];\n\t}\n\tvector<int>oks(W);\n\tfor (int i = 0; i < W; ++i) {\n\t\tif (!as[i]) {\n\t\t\t{\n\t\t\t\tint limit = 1e9;\n\t\t\t\tfor (int x = i - 1; x >= 0; --x) {\n\t\t\t\t\tif (as[x] == 0)break;\n\t\t\t\t\telse if (as[x] > 0) {\n\t\t\t\t\t\toks[x] = max(oks[x], min(as[x], limit));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlimit = min(limit, -as[x]);\n\t\t\t\t\t}\n\t\t\t\t\tlimit--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint limit = 1e9;\n\t\t\t\tfor (int x = i + 1; x <W; ++x) {\n\t\t\t\t\tif (as[x] == 0)break;\n\t\t\t\t\telse if (as[x] > 0) {\n\t\t\t\t\t\toks[x] = max(oks[x], min(as[x], limit));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlimit = min(limit,-as[x]);\n\t\t\t\t\t}\n\t\t\t\t\tlimit--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = accumulate(oks.begin(), oks.end(), 0);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t}\n\t}\n\treturn sum;\n}\n\nint sum2;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tcout << solve(W) << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  VI a(n);\n  REP(i, n) cin >> a[i];\n\n  VI dp1(n);\n  dp1[0] = a[0]==0?INF:-1;\n  FOR(i, 1, n) {\n    if(a[i] == 0) dp1[i] = INF;\n    else if(a[i] > 0) dp1[i] = dp1[i-1] - 1;\n    else if(a[i] < 0) dp1[i] = min(dp1[i-1]-1, -a[i]-1);\n  }\n\n  VI dp2(n);\n  dp2[n-1] = a[n-1]==0?INF:-1;\n  for(int i=n-2; i>=0; --i) {\n    if(a[i] == 0) dp2[i] = INF;\n    else if(a[i] > 0) dp2[i] = dp2[i+1] - 1;\n    else if(a[i] < 0) dp2[i] = min(dp2[i+1]-1, -a[i]-1);\n  }\n\n  // cout << dp2 << endl;\n\n  int ret = 0;\n  REP(i, n) {\n    if(a[i] > 0) {\n      // 0-indexなので+1\n      ret += min(a[i]-1, max({-1LL, dp1[i], dp2[i]})) + 1;\n    }\n  }\n\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define WMAX 100000\n#define ESC_UNLIMITED 10001\nusing namespace std;\n\nint main() {\n  short a_list[WMAX], leftesc[WMAX];\n  int w;\n  cin >> w;\n\n  short esc_limit = 0;\n  for (int i = 0; i < w; i++) {\n    cin >> a_list[i];\n    auto &a = a_list[i];\n    if (a == 0) {\n      esc_limit = ESC_UNLIMITED;\n    } else if (esc_limit > 0) {\n      if (a > 0) {\n        leftesc[i] = min(a, esc_limit);\n      } else {\n        esc_limit = min(esc_limit, (short)-a);\n      }\n      if (esc_limit != ESC_UNLIMITED) esc_limit--;\n    }\n  }\n\n  unsigned long r = 0;\n  esc_limit = 0;\n  for (int i = w - 1; i >= 0; i--) {\n    auto& a = a_list[i];\n    if (a == 0) {\n      esc_limit = ESC_UNLIMITED;\n    } else if (esc_limit > 0) {\n      if (a > 0) {\n        r += max(leftesc[i], min(a, esc_limit));\n      } else {\n        esc_limit = min(esc_limit, (short)-a);\n      }\n      if (esc_limit != ESC_UNLIMITED) esc_limit--;\n    } else if (a > 0) {\n      r += leftesc[i];\n    }\n  }\n\n  cout << r << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 100005;\nint lt[MAX], rt[MAX];\n\nint main() {\n\tint w; cin >> w;\n\tvector<int> a(w);\n\tfor (auto& e : a) cin >> e;\n\tlt[0] = (a[0] == 0 ? 1e9 : -1);\n\tfor (int i = 1; i < w; ++i) {\n\t\tif (a[i] == 0) lt[i] = 1e9;\n\t\telse if (a[i] > 0) lt[i] = lt[i - 1] - 1;\n\t\telse lt[i] = min(lt[i - 1], -a[i]) - 1;\n\t}\n\trt[w - 1] = (a[w - 1] == 0 ? 1e9 : -1);\n\tfor (int i = w - 2; i >= 0; --i) {\n\t\tif (a[i] == 0) rt[i] = 1e9;\n\t\telse if (a[i] > 0) rt[i] = rt[i + 1] - 1;\n\t\telse rt[i] = min(rt[i + 1], -a[i]) - 1;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < w; ++i) {\n\t\tif (a[i] <= 0) continue;\n\t\tans += min(a[i] - 1, max(max(lt[i], rt[i]), -1)) + 1;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 100000001\nusing namespace std;\n\nint main()\n{\n  int w,a[100001],b[100001],c[100001];\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n  for(int i=0;i<w;i++){\n    if(a[i]==0){\n      b[i]=inf;\n      c[i]=inf;\n    }\n    else {\n      b[i]=0;\n      c[i]=0;\n    }\n  }\n  for(int i=0;i<w-1;i++){\n    if(a[i+1]==0)continue;\n    if(a[i+1]>0){\n      b[i+1]=max(0,min(b[i]-1,a[i+1]));\n    }else {\n      b[i+1]=min(b[i],(-1)*a[i+1]);\n    }\n  }\n  /*\n  for(int i=0;i<w;i++){\n    if(b[i]!=inf)cout<<b[i]<<\" \";\n    else cout<<'a'<<\" \";\n  }\n  cout<<endl;*/\n  for(int i=w-1;i>=1;i--){\n    if(a[i-1]==0)continue;\n    if(a[i-1]>0){\n      c[i-1]=max(0,min(c[i]-1,a[i-1]));\n    }else {\n      c[i-1]=max(0,min(c[i]-1,(-1)*a[i-1]));\n    }\n  }\n  for(int i=0;i<w;i++){\n    if(c[i]!=inf)cout<<c[i]<<\" \";\n    else cout<<'a'<<\" \";\n  }/*\n  cout<<endl;\n  int ans=0;\n  for(int i=0;i<w;i++){\n    if(a[i]>0)ans+=max(b[i],c[i]);\n    }*/\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define W 100010\nusing namespace std;\ntypedef long long ll;\nll w,mp[W];\nll l[W],r[W];\n\nint main(){\n  cin>>w;\n  \n  for(int i=0;i<w+2;i++)l[i]=r[i]=-1000;\n  l[0]=0;\n  r[w+1]=0;\n  for(int i=1;i<=w;i++) {\n    cin>>mp[i];\n    if(mp[i]<0) l[i]=r[i]=mp[i];\n    if(mp[i]==0)l[i]=r[i]=-1000;\n  }\n  w+=2;\n  \n  for(int i=1;i<w;i++){\n    int j=w-i-1;\n    if(mp[i]!=0)l[i]=max(l[i],l[i-1]+1);\n    if(mp[j]!=0)r[j]=max(r[j],r[j+1]+1);\n  }\n\n  //  for(int i=0;i<w;i++)cout<<l[i]<<\" \";cout<<endl;\n  //for(int i=0;i<w;i++)cout<<r[i]<<\" \";cout<<endl;\n\n  ll ans=0;\n  for(int i=0;i<=w;i++){\n    if(mp[i]<=0)continue;\n    ll a=l[i]<0? min(mp[i],abs(l[i])):0;  \n    ll b=r[i]<0? min(mp[i],abs(r[i])):0;\n    \n    // cout <<a<<\" \"<<b<<endl;\n    ans+=max(0LL,max(a,b));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint W;\nint a[100010];\nint goalL[100010], goalR[100010];\nint wallL[100010], wallR[100010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> W;\n  for (int i = 0; i < W; i++) {\n    cin >> a[i];\n    goalL[i] = goalR[i] = -1;\n    wallL[i] = wallR[i] = -1;\n  }\n  for (int i = 0; i < W; i++) {\n    if (i == 0) {\n      goalL[i] = a[i] == 0 ? i : -1;\n      wallL[i] = a[i] < 0 ? i : -1;\n    } else {\n      if (a[i] > 0) {\n        goalL[i] = goalL[i - 1];\n        wallL[i] = wallL[i - 1];\n      } else if (a[i] < 0) {\n        goalL[i] = goalL[i - 1];\n        wallL[i] = wallL[i - 1] < 0 || a[i] > a[wallL[i - 1]] + i - wallL[i - 1] ? i : wallL[i - 1];\n      } else {\n        goalL[i] = i;\n        wallL[i] = -1;\n      }\n    }\n  }\n  for (int i = W - 1; i >= 0; i--) {\n    if (i + 1 == W) {\n      goalR[i] = a[i] == 0 ? i : -1;\n      wallR[i] = a[i] < 0 ? i : -1;\n    } else {\n      if (a[i] > 0) {\n        goalR[i] = goalR[i + 1];\n        wallR[i] = wallR[i + 1];\n      } else if (a[i] < 0) {\n        goalR[i] = goalR[i + 1];\n        wallR[i] = wallR[i + 1] < 0 || a[i] > a[wallR[i + 1]] + wallR[i + 1] - i ? i : wallR[i + 1];\n      } else {\n        goalR[i] = i;\n        wallR[i] = -1;\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int i = 0; i < W; i++) {\n    if (a[i] <= 0) continue;\n    int tmpL = goalL[i] < 0 ? 0 : min(a[i], wallL[i] < 0 ? a[i] : -a[wallL[i]] - (i - wallL[i]));\n    int tmpR = goalR[i] < 0 ? 0 : min(a[i], wallR[i] < 0 ? a[i] : -a[wallR[i]] - (wallR[i] - i));\n    ans += max({0, tmpL, tmpR});\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint cop; int dat1[400000]; int dat2[400000];\nvoid init(int cop_) {\n\tcop = 1;\n\twhile (cop < cop_)cop *= 2;\n\trep(i, 2*cop-1) {\n\t\tdat1[i] = (int)MOD;\n\t\tdat2[i] = (int)MOD;\n\t}\n}\nvoid update1(int k, int a) {\n\tk += cop - 1;\n\tdat1[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat1[k] = min(dat1[k * 2 + 1], dat1[k * 2 + 2]);\n\t}\n}\nvoid update2(int k, int a) {\n\tk += cop - 1;\n\tdat2[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat2[k] = min(dat2[k * 2 + 1], dat2[k * 2 + 2]);\n\t}\n}\nint query1(int a,int b,int k,int l,int r) {\n\tif (r <= a || b <= l)return (int)MOD;\n\tif (a <= l && r <= b)return dat1[k];\n\telse {\n\t\tint vl = query1(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query1(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint query2(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return (int)MOD;\n\tif (a <= l && r <= b)return dat2[k];\n\telse {\n\t\tint vl = query2(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query2(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n; cin >> n;\n\tcop = n;\n\tinit(cop);\n\tint a[100000]; int exr[100000]; int exl[100000];\n\tvector<int>ex; vector<int> ex2;\n\tint len = 0;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) {\n\t\t\tex.push_back(i);\n\t\t\tex2.push_back(-i);\n\t\t\tlen++;\n\t\t}\n\t}\n\tsort(ex2.begin(), ex2.end());\n\tif (len == 0) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\trep(i, n) {\n\t\tif(a[i]<0) {\n\t\t\tupdate1(i, -i - a[i]);\n\t\t\tupdate2(i, i - a[i]);\n\t\t}\n\t\tint r = lower_bound(ex.begin(), ex.end(), i) - ex.begin();\n\t\tint l = lower_bound(ex2.begin(), ex2.end(), -i) - ex2.begin();\n\t\tif (r < len) {\n\t\t\texr[i] = ex[r];\n\t\t}\n\t\telse {\n\t\t\texr[i] = -1;\n\t\t}\n\t\tif (l < len) {\n\t\t\texl[i] = -ex2[l];\n\t\t}\n\t\telse {\n\t\t\texl[i] = -1;\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, n) {\n\t\tif (a[i] <= 0)continue;\n\t\tint ma = 0;\n\t\tint lr;\n\t\tif (exr[i] != -1) {\n\t\t\tlr = query1(i, exr[i], 0, 0, cop)+i;\n\t\t\tif (lr >= 0) {\n\t\t\t\tma = max(ma, min(lr,a[i]));\n\t\t\t}\n\t\t}\n\t\tif (exl[i] != -1) {\n\t\t\tlr = query2(exl[i], i, 0, 0, cop)-i;\n\t\t\tif (lr >= 0) {\n\t\t\t\tma = max(ma, min(lr, a[i]));\n\t\t\t}\n\t\t}\n\t\tcout <<i<<\" \"<< ma << endl;\n\t\tcnt += ma;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n+2, 0), a_max(n+2, 0);\n\tfor(int i=1; i<=n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tif(a[i]!=0) continue;\n\t\tfor(int d=-1; d<2; d+=2){\n\t\t\tint shut=0;\n\t\t\tint dist=0;\n\t\t\tfor(int j=i+d; a[j]!=0; j+=d){\n\t\t\t\tdist++;\n\t\t\t\tif(a[j]<0 && shut+dist<-a[j]){\n\t\t\t\t\tshut = -a[j];\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t\tif(a[j]>0){\n\t\t\t\t\tif(shut==0) a_max[j] = max(a_max[j], a[j]);\n\t\t\t\t\telse a_max[j] = max(a_max[j], min(a[j], shut-dist));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tans += a_max[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint main(){\n  int W;\n  cin >> W;\n  vector<int> a(W);\n  for (int i = 0; i < W; i++){\n    cin >> a[i];\n  }\n  vector<int> L(W, 0);\n  int t_max = -INF;\n  for (int i = 0; i < W; i++){\n    t_max--;\n    if (a[i] < 0){\n      t_max = min(t_max, - a[i]);\n    } else if (a[i] == 0){\n      t_max = INF;\n    } else {\n      L[i] = max(min(a[i], t_max), 0);\n    }\n  }\n  vector<int> R(W, 0);\n  int t_max2 = -INF;\n  for (int i = W - 1; i >= 0; i--){\n    t_max2--;\n    if (a[i] < 0){\n      t_max2 = min(t_max2, - a[i]);\n    } else if (a[i] == 0){\n      t_max2 = INF;\n    } else {\n      R[i] = max(min(a[i], t_max2), 0);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; i++){\n    ans += max(L[i], R[i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define p(s) cout<<(s)<<endl\nusing namespace std;\nconst int inf=1e9;\n\nint tmp[100010];\nint main() {\n\tint W, a[100010], ans=0;\n\tcin>>W;\n\tREP(i, 0, W) cin>>a[i];\n\n\tint t=0;\n\tREP(i,0,W){\n\t\tif(a[i]==0) t=inf;\n\t\telse if(a[i]<0) t=min(t,-a[i]);\n\t\telse tmp[i]=t;\n\t\tt--;\n\t}\n\tt=0;\n\tfor(int i=W-1;i>=0;i--){\n\t\tif(a[i]==0) t=inf;\n\t\telse if(a[i]<0) t=min(t,-a[i]);\n\t\telse ans+=max(0,min(a[i],max(tmp[i],t)));\n\t\tt--;\n\t}\n\n\tp(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n;\n\tcin>>n;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tint out=0,t=0;\n\trep(i,n){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse out+=max(0,min(in[i],t));\n\t}\n\tt=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tt--;\n\t\tif(in[i]==0)t=inf;\n\t\telse if(in[i]<0)t=min(t,-in[i]);\n\t\telse out+=max(0,min(in[i],t));\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int w;\n    cin >> w;\n    vector<int> a(w);\n    for (int i = 0; i < w; ++i) {\n        cin >> a[i];\n    }\n    vector<int> l(w);\n    int b = 0;\n    for (int i = 0; i < w; ++i) {\n        --b;\n        if (a[i] == 0)\n            b = M;\n        else if (a[i] < 0)\n            b = min(b, -a[i]);\n        else\n            l[i] = b;\n    }\n    vector<int> r(w);\n    b = 0;\n    for (int i = w - 1; i >= 0; --i) {\n        --b;\n        if (a[i] == 0)\n            b = M;\n        else if (a[i] < 0)\n            b = min(b, -a[i]);\n        else\n            r[i] = b;\n    }\n    int ans = 0;\n    for (int i = 0; i < w; ++i) {\n        if (a[i] > 0)\n            ans += min(max({l[i], r[i], 0}), a[i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint a[111111];\nint b[111111],c[111111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n;\n\trep(i,n)cin>>a[i];\n\tint cap=0;\n\trep(i,n){\n\t\tif(a[i]==0){\n\t\t\tcap=INF;\n\t\t}else if(a[i]>0){\n\t\t\tb[i]=min(cap,a[i]);\n\t\t}else{\n\t\t\tminch(cap,-a[i]);\n\t\t}\n\t\tif(cap>0)cap--;\n\t}\n\tcap=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(a[i]==0){\n\t\t\tcap=INF;\n\t\t}else if(a[i]>0){\n\t\t\tc[i]=min(cap,a[i]);\n\t\t}else{\n\t\t\tminch(cap,-a[i]);\n\t\t}\n\t\tif(cap>0)cap--;\n\t}\n\tll res=0;\n\trep(i,n){\n\t\tres+=max(b[i],c[i]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  int A[W], INF = 1000000;\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size(), s, t;\n  vector<int> ans(W,0);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = W+1;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = W+1;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1]+1;\n    t = INF;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s));\n      }\n    }\n    s = E[0]-1;\n    t = INF;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s));\n      }\n    }\n  }\n  long long int sum = 0LL; \n\n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    //cout << ans[i] << \" \";\n  }\n  //cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \nconst int INF = 1<<28;\n  \nint main() {\n    int W; cin >> W;\n    vector<int> a(W);\n    for(int i = 0; i < W; ++i) cin >> a[i];\n    vector<int> L(W+1), R(W+1);\n    L[0] = -1;\n    for(int i = 0; i < W; ++i) {\n        L[i+1] = L[i] - 1;\n        if(a[i] == 0){\n            L[i+1] = INF;\n        }else if(a[i] < 0){\n            L[i+1] = min(L[i+1], -a[i]-1);\n        }\n    }\n    R[W] = -1;\n    for(int i = W-1; i >= 0; --i) {\n        R[i] = R[i+1] - 1;\n        if(a[i] == 0){\n            R[i] = INF;\n        }else if(a[i] < 0){\n            R[i] = min(R[i], -a[i]-1);\n        }\n    }\n    int res = 0;\n    for(int i = 0; i < W; ++i) {\n        if(a[i] > 0); else continue;\n        int t = max(L[i+1], R[i]);\n        if(t < 0) continue;\n        res += min(a[i], t+1);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, A[100002];\n  int close[100002] = {};\n  \n  scanf(\"%d\", &W);\n  for(int i = 1; i <= W; i++) {\n    scanf(\"%d\", &A[i]);\n    if(A[i] == 0) close[i] = INF;\n  }\n  for(int i = 1; i <= W; i++) {\n    close[i] = max(close[i], close[i - 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  for(int i = W; i >= 1; i--) {\n    close[i] = max(close[i], close[i + 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  int ret = 0;\n  for(int i = 1; i <= W; i++) {\n    ret += max(0, min(close[i], A[i]));\n  }\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define INF (1<<30)\n \nint W;\nint A[100001];\n \nint Fa[100001];\nint Fb[100001];\nint main(){\n  cin >> W;\n  for(int i=0;i<W;i++) cin >> A[i];\n \n  for(int i=0;i<W;i++){\n    if( A[i] == 0 ) Fa[i] = INF;\n    else if( A[i] < 0 )\n      Fa[i] = min( Fa[i], -A[i] );\n    Fa[i+1] = Fa[i]-1;\n  }\n \n  for(int i=W-1;i>=0;i--){\n    if( A[i] == 0 ) Fb[i] = INF;\n    else if( A[i] < 0 )\n      Fb[i] = min( Fb[i], -A[i] );\n    if( i == 0 ) break;\n    Fb[i-1] = Fb[i]-1;\n  }\n   \n \n  long long res = 0;\n  for(int i=0;i<W;i++){\n    if( A[i] > 0 ){\n      int ret1=0, ret2=0;\n      if( Fa[i] >  0 ) ret1 = min( Fa[i], A[i] );\n      if( Fb[i] >  0 ) ret2 = min( Fb[i], A[i] );\n      res += (long long)max(ret1,ret2);     \n    }\n  }\n  cout << res << endl;\n   \n   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<30)\n\nint W;\nint A[100001];\n\nint Fa[100001];\nint Fb[100001];\nint main(){\n  cin >> W;\n  for(int i=0;i<W;i++) cin >> A[i];\n\n  for(int i=0;i<W;i++){\n    if( A[i] == 0 ) Fa[i] = INF;\n    else if( A[i] < 0 )\n      Fa[i] = min( Fa[i], -A[i] );\n    Fa[i+1] = Fa[i]-1;\n  }\n\n  for(int i=W-1;i>=0;i--){\n    if( A[i] == 0 ) Fb[i] = INF;\n    else if( A[i] < 0 )\n      Fb[i] = min( Fb[i], -A[i] );\n    if( i == 0 ) break;\n    Fb[i-1] = Fb[i]-1;\n  }\n  \n\n  long long res = 0;\n  for(int i=0;i<W;i++){\n    if( A[i] > 0 ){\n      int ret1=0, ret2=0;\n      if( Fa[i] >  0 ) ret1 = min( Fa[i], A[i] );\n      if( Fb[i] >  0 ) ret2 = min( Fb[i], A[i] ); \n      res += (long long)max(ret1,ret2);      \n    }\n  }\n  cout << res << endl;\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint l[131072],r[130172],a[131072];\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n) cin >> a[i+1];\n  REP(i,n) if(a[i+1]<0) l[i+1]=-a[i+1];\n  l[0]=16384;\n  REP(i,n) if(a[i+1]) l[i+1]=max(l[i]+1,l[i+1]);\n  r[n+1]=16384;\n  REP(i,n) if(a[n-i]) r[n-i]=max(r[n-i+1]+1,r[n-i]);\n  int answer=0;\n  FOR(i,1,n+1) l[i]=min(l[i],r[i])-1;\n  FOR(i,1,n+1) if(a[i]>0&&a[i]-l[i]>0) answer+=a[i]-l[i];\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#define REP(i,n,N) for(int i=(n);i<(int)N;i++)\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst ll inf = 1e15;\nconst int INF = 1e9;\n\nint main() {\n\tint  W, a[100010], ans = 0;\n\tcin >> W;\n\tREP(i, 0, W) cin >> a[i];\n\n\tvector<int> v, enter;\n\tREP(i, 0, W) {\n\t\tif (a[i] <= 0) v.push_back(i); // gate or exit\n\t\telse enter.push_back(i);       // entrance\n\t}\n\n\tfor (auto in : enter) {\n\t\tint left=a[in], right=a[in];\n\n\t\t// right\n\t\tauto itr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.end()) {\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tright = min(right, -a[*itr] - (*itr - in));\n\t\t\t\tif (itr == v.end()) {\n\t\t\t\t\tright = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tright = 0;\n\t\t}\n\n\t\t// left\n\t\titr = upper_bound(v.begin(), v.end(), in);\n\t\tif (itr != v.begin() && (itr - 1) != v.begin()) {\n\t\t\titr--;\n\t\t\twhile (a[*itr] != 0) {\n\t\t\t\tleft = min(left, -a[*itr] - (in - *itr));\n\t\t\t\t\n\t\t\t\tif (itr == v.begin()) {\n\t\t\t\t\tleft = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tleft = 0;\n\t\t}\n\n\t\tans += max(left, right);\n\t\t\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<29);\n\nstruct edge{int to, cap, cost, rev;};\n \nint V;\nvector<edge> G[300];\nint h[300];\nint dist[300];\nint prevv[300],preve[300];\n  \nvoid init(){\n  for(int i = 0 ; i < 300 ; i++){\n    G[i].clear();\n  }\n}\n  \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n  \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n  \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n          \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n  \n    if(dist[t] == INF){\n      return -1;\n    }\n  \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n        \n    int d = f;\n  \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n \nstruct result{\n  int x,y;\n  string s;\n};\n\nint N;\nint W[111][111];\nint E[111][111];\nchar M[111][111];\n\nint cost[111][111];\n\nvector<result> ans;\nvoid writer(int x,int y){\n  for(int k=0;k<N;k++){\n    if( x == k ){\n      if( M[k][y] == '.' )\n\tans.push_back( (result){k,y,\"write\"} );      \n    } else\n      if( M[k][y] == 'o' )\n\tans.push_back( (result){k,y,\"erase\"} );\n  }\n}\n \nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> W[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> E[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> M[j][i];\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      for(int k=0;k<N;k++){\n\tif( j == k ){\n\t  if( M[k][i] == '.' ) cost[j][i] += W[k][i];\n\t} else\n\t  if( M[k][i] == 'o' ) cost[j][i] += E[k][i];\n      }\n    }\n  }\n\n  for(int x=0;x<N;x++)\n    for(int y=0;y<N;y++)\n      add_edge(x,y+N,1,cost[x][y]);\n\n  for(int i=N;i<N+N;i++)\n    add_edge(i,N+N+1,1,0);\n  for(int i=0;i<N;i++)\n    add_edge(N+N,i,1,0);\n\n  V = N + N + 2;\n\n  cout << min_cost_flow(N+N,N+N+1,N) << endl;\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if( N <= G[i][j].to && G[i][j].to < N+N )\n\tif( G[i][j].cap == 0 )\n\t  writer(i,G[i][j].to-N);\n    }\n  }\n\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++){\n    cout << ans[i].y+1 << \" \" << ans[i].x+1 <<\" \" << ans[i].s<< endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t}\n\t}\n\treturn sum;\n}\n\nint sum2;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tcout << solve(W) << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,a[1<<17],L[1<<17],R[1<<17];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tL[0]=a[0]==0?1e9:0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tL[i]=a[i]==0?1e9:a[i]<0?min(-a[i],max(L[i-1]-1,0)):max(L[i-1]-1,0);\n\t}\n\tR[n-1]=a[n-1]==0?1e9:0;\n\tfor(int i=n-1;i--;)\n\t{\n\t\tR[i]=a[i]==0?1e9:a[i]<0?min(-a[i],max(R[i+1]-1,0)):max(R[i+1]-1,0);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(a[i]>0)\n\t\t{\n\t\t\tans+=min(a[i],max(L[i],R[i]));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<deque>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef deque<int> di;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\nsigned main(void) {\n    int i,j;\n    int n;\n    cin >> n;\n    vi a(n+2),dp(n+2);\n    loop(i,1,n+1){\n        cin >> a[i];\n        if(a[i] == 0) dp[i] = INF;\n    }\n    //rep(i,n+2)cout << \" \" << dp[i]; cout << endl;\n    loop(i,1,n+1){\n        dp[i] = max(dp[i], dp[i-1] - 1);\n        if(a[i] < 0)dp[i] = min(dp[i],-a[i]);\n    }\n    //rep(i,n+2)cout << \" \" << dp[i]; cout << endl;\n    for(int i = n; i >= 0; i--){\n        dp[i] = max(dp[i], dp[i+1] - 1);\n        if(a[i] < 0)dp[i] = min(dp[i],-a[i]);\n    }\n    //rep(i,n+2)cout << \" \" << dp[i]; cout << endl;\n    int ans = 0;\n    rep(i,n+2)if(a[i] > 0){\n        ans += min(max(dp[i],0LL), a[i]);\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1<<25;\n\nint main()\n{\n  int W; cin >> W;\n  vector<int> a(W), b(W, 0);\n  for(int i = 0; i < W; i++) cin >> a[i];\n  int cap = 0;\n  for(int i = 0; i < W; i++) {\n    cap--;\n    if(a[i] == 0) cap = inf;\n    else if(a[i] < 0) cap = min(cap, -a[i]);\n    b[i] = max(cap, b[i]);\n  }\n  cap = 0;\n  for(int i = W-1; i >= 0; i--) {\n    cap--;\n    if(a[i] == 0) cap = inf;\n    else if(a[i] < 0) cap = min(cap, -a[i]);\n    b[i] = max(cap, b[i]);\n  }\n  int ans = 0;\n  for(int i = 0; i < W; i++) {\n    if(a[i] > 0) ans += min(a[i], b[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n7\n2 0 -2 3 2 -2 0\n\n>> 4\n\n4\n1 1 1 1\n\n>> 0 \n\n9\n10 -10 10 -10 10 -10 10 -10 0 \n\n>>24\n\n\n */\n\n/*\nint subroutine(int w, int *a){\n\tint count = 0;\n\tint *c = new int[w];\n\n\tfor (int i=0;i<w;i++){\n\t\tif (a[i] == 0){\n\n\t\t}\n\t}\n\n\treturn count;\n}*/\n#include <iostream>\nusing namespace std;\n\n\nint mainroutine(int w, int *a){\n\tint count = 0;\n\tint c;\n\tint p_count,n_count,dist,v;\n\tbool exist_zero = false;\n\t\n\tfor (int i=0;i<w;i++){\n\t\tif (a[i]>0){\n\t\t\tc = a[i];\n\n\t\t\t//cout << \"---\" << endl;\n\t\t\t// ?????????~\n\t\t\tp_count = c;\n\t\t\tfor (int xp =i ; xp<w; xp++){\n\t\t\t\tif (a[xp] < 0){\n\t\t\t\t\tdist = xp - i;\n\t\t\t\t\tv = - (dist + a[xp]);\n\t\t\t\t\tif (p_count > v)\n\t\t\t\t\t\tp_count = v;\n\t\t\t\t\tif (p_count <= 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if (a[xp] == 0){\n\t\t\t\t\tif (c > 0){\n\t\t\t\t\t\tif (p_count <= c){\n\t\t\t\t\t\t\tc -= p_count;\n\t\t\t\t\t\t\tcount += p_count;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcount += c;\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// ?????????~\n\t\t\tn_count = c;\n\t\t\tif (c <= 0){continue;}\n\t\t\tfor (int xn =i ; xn>=0; xn--){\n\t\t\t\tif (a[xn] < 0){\n\t\t\t\t\tdist = i-xn;\n\t\t\t\t\tv = - (dist + a[xn]);\n\t\t\t\t\tif (n_count > v )\n\t\t\t\t\t\tn_count = v;\n\n\t\t\t\t\tif (n_count <= 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if (a[xn] == 0){\n\t\t\t\t\tif (c > 0){\n\t\t\t\t\t\tif (n_count <= c){\n\t\t\t\t\t\t\tc -= n_count;\n\t\t\t\t\t\t\tcount += n_count;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcount += c;\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\t//cout << c[i] << endl;\n\t\t}\n\t}\n\treturn count;\n}\n\n// ?????????????????????\n\nint main (int argc, char ** argv){\n\n\tint w;\n\tint *a;\n\n\tcin >> w;\n\ta = new int[w];\n\n\tfor (int i=0;i<w;i++){\n\t\tcin >> a[i];\n\t}\n\n\n\tint count = mainroutine(w,a);\n\n\tcout << count << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint exit_check(int ind, vector<int>& a) {\n\tint le,re,lw,rw;\n\tle = re = lw = rw = 0;\n\tfor (int i = ind-1; le == 0 && i >= 0; --i) {\n\t\tif (lw == 0 && a[i] < 0) {\n\t\t\tlw = -1;\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tle = -1;\n\t\t}\n\t}\n\tfor (int i = ind+1; re == 0 && i < a.size(); ++i) {\n\t\tif (rw == 0 && a[i] < 0) {\n\t\t\trw = 1;\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tre = 1;\n\t\t}\n\t}\n\n\tif (le == 1 && re == 1) {\n\t\treturn (lw + rw);\n\t}\n\telse {\n\t\treturn (le + re);\n\t}\n}\n\nint exit_search(int ind, vector<int>& a) {\n\tint mode = exit_check(ind,a);\n\tint res = 0;\n\tif (mode >= 0) {\n\t\tint p = a[ind];\n\t\tbool exit = false;\n\t\tfor (int i = ind+1; !exit && i < a.size(); ++i) {\n\t\t\tif (a[i] < 0) {\n\t\t\t\tp = (i - ind) + a[i];\n\t\t\t\tp = -p;\n\t\t\t}\n\t\t\tif (p <= 0 || a[i] == 0) {\n\t\t\t\texit = true;\n\t\t\t}\n\t\t}\n\t\tres = max(res,p);\n\t}\n\tif (mode <= 0) {\n\t\tint p = a[ind];\n\t\tbool exit = false;\n\t\tfor (int i = ind-1; !exit && i >= 0; --i) {\n\t\t\tif (a[i] < 0) {\n\t\t\t\tp = (ind - i) + a[i];\n\t\t\t\tp = -p;\n\t\t\t}\n\t\t\tif (p <= 0 || a[i] == 0) {\n\t\t\t\texit = true;\n\t\t\t}\n\t\t}\n\t\tres = max(res,p);\n\t}\n\n\treturn res;\n}\n\nint main(void) {\n\tint W;\n\tcin >> W;\n\tvector<int> a(W),s;\n\tbool exit = false;\n\tfor (int i = 0; i < W; ++i) {\n\t\tcin >> a[i];\n\t\tif (!exit && a[i] == 0) {\n\t\t\texit = true;\n\t\t}\n\t\tif (a[i] > 0) {\n\t\t\ts.push_back(i);\n\t\t}\n\t}\n\n\tint res = 0;\n\tif (exit) {\n\t\tfor (size_t i = 0; i < s.size(); ++i) {\n\t\t\tres += exit_search(s[i],a);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  int tt=0;\n  vector <int>uni(n,0);\n  for(int i=0;i<n;i++){\n    cin >> uni[i];\n  }\n  for(int i=0;i<n;i++){\n    int c;\n    int R=0;\n    int L=0;\n    if(uni[i]>0){\n      c=uni[i];\n      int co=0;\n      for(int j=i+1;j<n;j++){\n\tco++;\n\tif(uni[j]==0){\n\t  R=c;\n\t  break;\n\t}\n\tif(uni[j]<0){\n\t  c=min(c,uni[j]*-1-co);\n\t  if(c<=0)break;\n\t}\n      }\n      co=0;\n      c=uni[i];\n      for(int j=i-1;j>=0;j--){\n\tco++;\n\tif(uni[j]==0){\n\t  L=c;\n\t  break;\n\t}\n\tif(uni[j]<0){\n\t  c=min(c,uni[j]*-1-co);\n\t  if(c<=0)break;\n\t}\n      }\n      tt+=max(R,L);\n    }\n  }\n  cout << tt << endl;\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t\tif (loop >= 600000000) { return 999990000; }\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint main(){\n  int w;\n  scanf(\"%d\",&w);\n  vector<int> a(w),pop(w,0);\n  for(int i=0;i<w;i++)scanf(\"%d\",&a[i]);\n\n  int t = 0;\n  for(int i=0;i<w;i++){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else pop[i] = max(pop[i], t);\n    t--;\n  }\n\n  t = 0;\n  for(int i=w-1;i>=0;i--){\n    if(a[i]==0)t = INF;\n    else if(a[i]<0)t = min(t,-a[i]);\n    else pop[i] = max(pop[i], t);\n    t--;\n  }\n\n  int ans = 0;\n  for(int i=0;i<w;i++)ans += min(pop[i], abs(a[i]));\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconstexpr ll SIZE = 1LL << 17;\n\ntemplate <typename T>\nstruct LazySegtree {\n    T node[2*SIZE], lazy[2*SIZE];\n\n    // テ・ツ按敕ヲツ慊淌・ツ個?\n    LazySegtree() {}\n    LazySegtree(vector<T> v) {\n        for(size_t i=0; i<v.size(); ++i) {\n            node[SIZE-1+i] = v[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = node[2*i+1] + node[2*i+2];\n        }\n    }\n\n    // テゥツ??・ツサツカティツゥツ陛、ツセツ。\n    void lazyUpdate(int a, int b, int k) {\n        int rng = b - a;\n        node[k] += lazy[k];\n        if(rng > 1) {\n            lazy[2*k+1] += lazy[k];\n            lazy[2*k+2] += lazy[k];\n        }\n        lazy[k] = 0;\n    }\n\n    // テァツッツ?・ツ崢イ [a, b) テ」ツ?ォ x テ」ツつ津ィツカツウテ」ツ??\n    void add(int a, int b, T x, int l=0, int r=SIZE, int k=0) {\n        lazyUpdate(l, r, k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += x;\n            lazyUpdate(l, r, k);\n        }\n        else {\n            int mid = (l + r) / 2;\n            add(a, b, x, l, mid, 2*k+1);\n            add(a, b, x, mid, r, 2*k+2);\n            node[k] = min(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テァツッツ?・ツ崢イ [a, b) テ」ツ?ョテヲツ慊?・ツーツ湘・ツ?、\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazyUpdate(l, r, k);\n        if(b <= l || r <= a) return INF;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return min(vl, vr);\n    }\n};\n\nint W;\nint a[100010];\n\nsigned main() {\n    cin >> W;\n    vector<int> doors;\n    doors.push_back(-INF); // テァツ閉ェテ・ツ?オ\n    LazySegtree<int> seg(vector<int>(W, 0));\n    rep(i,0,W) {\n        cin >> a[i];\n        if(a[i] < 0) seg.add(i, i+1, -a[i]);\n        else seg.add(i, i+1, INF);\n\n        if(a[i] == 0) doors.push_back(i);\n    }\n    doors.push_back(INF); // テァツ閉ェテ・ツ?オ\n\n    rep(i,0,W) seg.add(i, i+1, -i);\n    int ans = 0;\n    rep(i,0,W) {\n        if(a[i] > 0) {\n            int l = upper_bound(doors.begin(), doors.end(), i) - doors.begin() - 1;\n            int r = l + 1;\n            int ad = 0;\n            if(abs(doors[l]) != INF) {\n                int val = seg.query(doors[l], i);\n                chmax(ad, val);\n            }\n            if(abs(doors[r]) != INF) {\n                int val = seg.query(i, doors[r]);\n                chmax(ad, val);\n            }\n            ans += min(a[i], ad);\n        }\n        seg.add(0, i+1, -1);\n        seg.add(i+1, W, 1);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,a[100001],t[100001]={};\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n\n  int f=0,m=1e9;\n  for(int i=0;i<w;i++,m--){\n    if(a[i]==0)f=1,m=1e9;\n    if(a[i]<0)m=min(m,-a[i]);\n    if(f&&a[i]>0)t[i]=min(a[i],m);\n  }\n\n\n  f=0,m=1e9;\n  for(int i=w-1;i>=0;i--,m--){\n    if(a[i]==0)f=1,m=1e9;\n    if(a[i]<0)m=min(m,-a[i]);\n    if(f&&a[i]>0)t[i]=max(t[i],min(a[i],m));\n  }\n  int ans=0;\n  for(int i=0;i<w;i++)ans+=t[i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define pii pair<int,int>\n#define INF 1000000000\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<int> node;\npublic:\n  SegmentTree(vector<int> v){\n    int sz = v.size();\n    n = 1;\n    while(n<sz) n *= 2;\n    node.resize(2*n-1,INF);\n    for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n    for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n  }\n\n  void update(int x, int val){\n    x += (n-1);\n    node[x] = val;\n    while(x>0){\n      x = (x-1)/2;\n      node[x] = min(node[2*x+1],node[2*x+2]);\n    }\n  }\n\n  int getmin(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    if(r<=a||b<=l) return INF;\n    if(a<=l&&r<=b) return node[k];\n    int vl = getmin(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmin(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  void show(){\n    for(int i=n-1;i<node.size()-1;i++){\n      cout << node[i] << \" \";\n    }\n    cout << node[node.size()-1] << endl;\n  }\n};\n\nint main(){\n\n  int w;\n  cin >> w;\n  vector<int> a(w);\n  rep(i,w)cin >> a[i];\n  int n_e=0;\n  vector<int> escape;\n  rep(i,w)if(a[i]==0){\n    n_e++;\n    escape.push_back(i);\n  }\n  if(n_e==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  // 各ユニットの最寄りの出口\n  vector<int> nearL(w,-INF),nearR(w,-INF);\n  vector<int> dd,dd2;\n  int ind = -1;\n  rep(i,w){\n    if(a[i]>0){\n      nearL[i] = ind;\n      nearR[i] = ind+1;\n      if(ind+1==n_e)nearR[i]=-1;\n      dd.push_back(INF);\n      dd2.push_back(INF);\n    }else if(a[i]==0){\n      ind++;\n      dd.push_back(INF/2);\n      dd2.push_back(INF/2);\n    }else{\n      dd.push_back(-a[i]+i);\n      dd2.push_back(-a[i]-i);\n    }\n  }\n\n  SegmentTree st1(dd),st2(dd2);\n\n  int sum = 0;\n  int el,er,flag,minl,minr;\n  int lflag=1,rflag=1;\n  rep(i,w){\n    if(a[i]>0){\n      if(nearL[i]>=0) {el = escape[nearL[i]];lflag=1;}\n      else lflag=0;\n      if(nearR[i]>=0) {er = escape[nearR[i]];rflag=1;}\n      else rflag=0;\n      flag = 0;\n      minl = -INF; minr = -INF;\n      if(lflag&&st1.getmin(el,i)<INF/2){minl = max(st1.getmin(el,i)-i,0);flag=1;}\n      else if(lflag&&st1.getmin(el,i)==INF/2){minl = a[i];}\n      if(rflag&&st2.getmin(i+1,er+1)<INF/2){minr = max(st2.getmin(i+1,er+1)+i,0);flag=1;}\n      else if(lflag&&st2.getmin(i+1,er+1)==INF/2){minr = a[i];}\n      int ret = min(max(minl,minr),a[i]);\n      if(flag)sum += ret;\n      else sum += a[i];\n    }\n  }\n  \n  cout << sum << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100000\n\nint table[NUM+2],left_table[NUM+2],right_table[NUM+2];\n\nint main(){\n\n\tint W;\n\tscanf(\"%d\",&W);\n\n\tfor(int i = 1; i <= W; i++)scanf(\"%d\",&table[i]);\n\n\tleft_table[0] = 0;\n\n\tfor(int i = 1; i <= W; i++){\n\t\tif(table[i] == 0){\n\t\t\tleft_table[i] = BIG_NUM;\n\t\t}else if(table[i] > 0){\n\t\t\tleft_table[i] = max(0,left_table[i-1]-1);\n\t\t}else{\n\t\t\tleft_table[i] = max(0,min(left_table[i-1]-1,abs(table[i])));\n\t\t}\n\t}\n\n\tright_table[W+1] = 0;\n\tfor(int i = W; i >= 1; i--){\n\t\tif(table[i] == 0){\n\t\t\tright_table[i] = BIG_NUM;\n\t\t}else if(table[i] > 0){\n\t\t\tright_table[i] = max(0,right_table[i+1]-1);\n\t\t}else{\n\t\t\tright_table[i] = max(0,min(right_table[i+1]-1,abs(table[i])));\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i = 1; i <= W; i++){\n\t\tif(table[i] > 0){\n\t\t\tans += min(table[i],max(left_table[i],right_table[i]));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tREP(i, n) {\n\t\tcin >> a[i];\n\t}\n\tvector<int> ma(n, 0);\n\tint limit = 1e9;;\n\tbool able=false;\n\tREP(i, n) {\n\t\tlimit--;\n\t\tif (a[i] < 0) {\n\t\t\tlimit = min(limit, abs(a[i]) );\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tlimit = 1e9;\n\t\t\table = true;\n\t\t}\n\t\tif (a[i] > 0&&able) {\n\t\t\tma[i] = max(ma[i], min(limit, a[i]));\n\t\t}\n\t}\n\tlimit = 1e9;;\n\table = false;\n\tfor (int i = n - 1; i >= 0;i--) {\n\t\tlimit--;\n\t\tif (a[i] < 0) {\n\t\t\tlimit = min(limit, abs(a[i]));\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tlimit = 1e9;\n\t\t\table = true;\n\t\t}\n\t\tif (a[i] > 0&&able) {\n\t\t\tma[i] = max(ma[i], min(limit, a[i]));\n\t\t}\n\t}\n\tint ans=0;\n\tREP(i, n)\n\t\tans += ma[i];\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nint W, A[100002];\nint close[100002];\n\nint main()\n{\n  cin >> W;\n  for(int i = 1; i <= W; i++) {\n    cin >> A[i];\n    if(A[i] == 0) close[i] = INF;\n  }\n  for(int i = 1; i <= W; i++) {\n    close[i] = max(close[i], close[i - 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  for(int i = W; i >= 1; i--) {\n    close[i] = max(close[i], close[i + 1] - 1);\n    if(A[i] < 0) close[i] = min(close[i], -A[i]);\n  }\n  int ret = 0;\n  for(int i = 1; i <= W; i++) {\n    ret += max(0, min(close[i], A[i]));\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(void){\n\tint w;\n\tcin>>w;\n\tvector<int> a(w+2),d1(w+2,-1e9),d2(w+2,-1e9);\n\tfor(int i=1;i<w+1;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1;i<w+1;i++){\n\t\tif(a[i]==0)d1[i]=1e9;\n\t\telse if(a[i]>0)d1[i]=d1[i-1]-1;\n\t\telse d1[i]=min(d1[i-1]-1,-a[i]);\n\t}\n\tfor(int i=w;i>0;i--){\n\t\tif(a[i]==0)d2[i]=1e9;\n\t\telse if(a[i]>0)d2[i]=d2[i+1]-1;\n\t\telse d2[i]=min(d2[i+1]-1,-a[i]);\n\t}\n\t\nint ans=0;\nfor(int i=1;i<w+2;i++){\n\tans+=max(0,min(a[i],max(d1[i],d2[i])));\n}\ncout<<ans<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(void){\n\tint w;\n\tcin>>w;\n\tvector<int> a(w+2),d1(w+2,-1e9),d2(w+2,-1e9);\n\tfor(int i=1;i<w+1;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1;i<w+1;i++){\n\t\tif(a[i]==0)d1[i]=1e9;\n\t\telse if(a[i]>0)d1[i]=d1[i-1]-1;\n\t\telse d1[i]=min(d1[i-1]-1,-a[i]);\n\t}\n\tfor(int i=w;i>0;i--){\n\t\tif(a[i]==0)d2[i]=1e9;\n\t\telse if(a[i]>0)d2[i]=d2[i+1]-1;\n\t\telse d2[i]=min(d2[i+1]-1,-a[i]);\n\t}\n\t\nint ans=0;\nfor(int i=1;i<w+2;i++){\n\tans+=max(0,min(a[i],max(d1[i],d2[i])));\n}\ncout<<ans<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& os, const pair<T1, T2>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& v) {\n    os << \"{\";\n    for(int i = 0; i < v.size(); i++)\n        os << v[i] << (i+1<v.size()?\", \":\"\");\n    os << \"}\";\n    return os;\n}\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n}\n//}}}\n\nvector<int> calc(vector<int> a) {\n    int n = a.size();\n    vector<int> res(n);\n    int val = 0;\n    for(int i = 0; i < n; i++) {\n        if(a[i] > 0) {\n            res[i] = val;\n            val = max(0, val-1);\n        } else if(a[i] == 0) {\n            val = INT_MAX;\n        } else {\n            int x = -a[i];\n            val = max(0, min(val-1, x-1));\n        }\n    }\n    return res;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n){\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        vector<int> b = a;\n        reverse(b.begin(), b.end());\n        vector<int> left = calc(a);\n        vector<int> right = calc(b);\n        reverse(right.begin(), right.end());\n        int ans = 0;\n        REP(i, n) {\n            if(a[i] > 0) {\n                int val = max(left[i], right[i]);\n                if(val >= a[i]) val = a[i];\n                ans += val;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - 11000);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + 11000);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint i,n,ans=0,gen=0;cin>>n;\n\tvector<int>a(n);\n\tvector<int>hi(n);\n\tfor(i=0;i<n;i++){cin>>a[i];}\n\tfor(i=0;i<n;i++){\n\t\tif(a[i]==0){gen=mod;}\n\t\tif(a[i]<0){mineq(gen,-a[i]);}\n\t\tmaxeq(hi[i],gen);\n\t\tgen--;\n\t}\n\tREV(a);REV(hi);\n\tfor(i=0;i<n;i++){\n\t\tif(a[i]==0){gen=mod;}\n\t\tif(a[i]<0){mineq(gen,-a[i]);}\n\t\tmaxeq(hi[i],gen);\n\t\tgen--;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(a[i]>0){ans+=min(hi[i],a[i]);}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main() {\n  int W; cin >> W;\n  vector<int> a(W);\n  for(int i = 0; i < W; ++i) cin >> a[i];\n  vector<int> L(W+1), R(W+1);\n  L[0] = -INF;\n  for(int i = 0; i < W; ++i) {\n    L[i+1] = abs(L[i]) == INF ? L[i] : L[i] - 1;\n    if(a[i] == 0) L[i+1] = INF;\n    else if(a[i] < 0) L[i+1] = min(L[i+1], -a[i]-1);\n  }\n  R[W] = -INF;\n  for(int i = W-1; i >= 0; --i) {\n    R[i] = abs(R[i+1]) == INF ? R[i+1] : R[i+1] - 1;\n    if(a[i] == 0) R[i] = INF;\n    else if(a[i] < 0) R[i] = min(R[i], -a[i]-1);\n  }\n  int res = 0;\n  for(int i = 0; i < W; ++i) {\n    if(a[i] > 0); else continue;\n    int t = max(L[i+1], R[i]);\n    if(t == -INF) continue;\n    res += min(a[i], t+1);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(void){\n\tint w;\n\tcin>>w;\n\tvector<int> a(w+2),d1(w+2,-1e9),d2(w+2,-1e9);\n\tfor(int i=1;i<w+1;i++){\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1;i<w+1;i++){\n\t\tif(a[i]==0)d1[i]=1e9;\n\t\telse if(a[i]>0)d1[i]=d1[i-1]-1;\n\t\telse d1[i]=min(d1[i-1]-1,-a[i]);\n\t}\n\tfor(int i=w;i>0;i--){\n\t\tif(a[i]==0)d2[i]=1e9;\n\t\telse if(a[i]>0)d2[i]=d2[i+1]-1;\n\t\telse d2[i]=min(d2[i+1]-1,-a[i]);\n\t}\n\t\nint ans=0;\nfor(int i=1;i<w+2;i++){\n\tans+=max(0,min(a[i],max(d1[i],d2[i])));\n}\ncout<<ans<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define FOR(i,n,m) for(ll i=(n);i<(m);++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main() {\n\tint w;\n\tcin>>w;\n\tvector<int> v(w);\n\tREP(i,w)cin>>v[i];\n\tvector<int> tmp(w,0);\n\tint t=0;\n\tint ans=0;\n\tREP(i,w){\n\t\tt--;\n\t\tif(v[i]==0){\n\t\t\tt = 1e9;\n\t\t}else if(v[i]<0){\n\t\t\tt=min(t,-v[i]);\n\t\t}else{\n\t\t\ttmp[i]=max(tmp[i],min(t,v[i]));\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=w-1;i>=0;--i){\n\t\tt--;\n\t\tif(v[i]==0){\n\t\t\tt = 1e9;\n\t\t}else if(v[i]<0){\n\t\t\tt=min(t,-v[i]);\n\t\t}else{\n\t\t\ttmp[i]=max(tmp[i],min(t,v[i]));\n\t\t}\n\t}\n\tREP(i,w)ans+=tmp[i];\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w;\nint a[100010],l[100010],r[100010];\n\nint main(void){\n\tcin >> w;\n\trep(i,w) cin  >> a[i];\n\tint num=0;\n\trep(i,w){\n\t\tif(a[i]==0)\n\t\t\tnum=inf;\n\t\telse if(a[i]>0)\n\t\t\tr[i]=min(a[i],num);\n\t\telse\n\t\t\tnum=min(num,abs(a[i]));\n\t\tnum=max(0,num-1);\n\t}\n\tnum=0;\n\tfor(int i=w-1;i>=0;--i){\n\t\tif(a[i]==0)\n\t\t\tnum=inf;\n\t\telse if(a[i]>0)\n\t\t\tl[i]=min(a[i],num);\n\t\telse\n\t\t\tnum=min(num,abs(a[i]));\n\t\tnum=max(0,num-1);\n\t}\n\tint ans=0;\n\trep(i,w) ans+=max(l[i],r[i]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint main() {\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tvector<int> l(n, -1), r(n, -1);\n\tint gl = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gl >= 0) gl--;\n\t\tif (a[i] == 0) gl = 999999999;\n\t\tif (a[i] < 0) gl = min(gl, -a[i]);\n\t\tif (a[i] > 0) l[i] = gl;\n\t}\n\tint gr = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr >= 0) gr--;\n\t\tif (a[i] == 0) gr = 999999999;\n\t\tif (a[i] < 0) gr = min(gr, -a[i]);\n\t\tif (a[i] > 0) r[i] = gr;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) ret += min(a[i], max(l[i], r[i]));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nint l[MAX_N],r[MAX_N];\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n){\n        cin >> a[i];\n    }\n    int ans = 0;\n    rep(i,n){\n        if(a[i] < 0){\n            if(i){\n                l[i] = min(max(0,l[i-1]-1),-a[i]);\n            }else{\n                l[0] = -a[0];\n            }\n        }else if(a[i] > 0){\n            if(i){\n                l[i] = max(l[i-1]-1,0);\n            }else{\n                l[0] = 0;\n            }\n        }else{\n            l[i] = INF;\n        }\n    }\n    for(int i=n-1;i>=0;i--){\n        if(a[i] < 0){\n            if(i < n-1){\n                r[i] = min(max(0,r[i+1]-1),-a[i]);\n            }else{\n                r[n-1] = -a[n-1];\n            }\n        }else if(a[i] > 0){\n            if(i < n-1){\n                r[i] = max(0,r[i+1]-1);\n            }else{\n                r[n-1] = 0;\n            }\n        }else{\n            r[i] = INF;\n        }\n    }\n    rep(i,n){\n        if(a[i] > 0) ans += min(a[i],max(l[i],r[i]));\n    }\n    cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e17;\n\nint main(){\n\t\n\tint W;\n\tcin >> W;\n\t\n\tlong long int a[11000], b[11000];\n\t\n\tlong long int S1 = 0;\n\t\n\tfor(int i = 0; i < W; i++){\n\t\tcin >> a[i];\n\t\tb[i] = a[i];\n\t\tif(a[i] > 0){\n\t\t\tS1 += a[i];\n\t\t}\n\t}\n\t\n\tlong long int cap = 0;\n\tfor(int i = 0; i < W; i++){\n\t\tif(a[i] > 0){\n\t\t\tb[i] += cap;\n\t\t\tcap++;\n\t\t}else if(a[i] == 0){\n\t\t\tcap = -INF;\n\t\t}else{\n\t\t\tcap = max(cap, a[i]);\n\t\t\tcap++;\n\t\t}\n\t\tcap = min(0LL, cap);\n\t}\n\t\n\tcap = 0;\n\tfor(int i = W - 1; i >= 0; i--){\n\t\tif(a[i] > 0){\n\t\t\tb[i] += cap;\n\t\t\tcap++;\n\t\t}else if(a[i] == 0){\n\t\t\tcap = -INF;\n\t\t}else{\n\t\t\tcap = max(cap, a[i]);\n\t\t\tcap++;\n\t\t}\n\t\tcap = min(0LL, cap);\n\t}\n\t\n\tlong long int S2 = 0;\n\tfor(int i = 0; i < W; i++){\n\t\tif(b[i] > 0){\n\t\t\tS2 += b[i];\n\t\t}\n\t\t//cout << b[i] << \" \";\n\t}\n\t//cout << endl;\n\t\n\tcout << S1 - S2 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  int A[W];\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size(), s, t;\n  vector<int> ans(W,0);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = W+1;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = W+1;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1];\n    t = W;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s+2));\n      }\n    }\n    s = E[0];\n    t = W;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s+2));\n      }\n    }\n  }\n  long long int sum = 0LL; \n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    //cout << ans[i] << \" \";\n  }\n  //cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \nint main(void){\n  \n  int n;\n  cin >> n;\n \n  vector<int>in(n),l(n),r(n);\n \n  for(int i=0;i<n;i++)cin >> in[i];\n \n  fill(all(l),0);\n  fill(all(r),0);\n  \n  int now=0;\n  for(int i=0;i<n;i++){\n    if(in[i]==0)now=INF;\n    if(in[i]<0)now=min(now,-in[i]);\n    if(in[i]>0)l[i]=min(now,in[i]);\n    if(now!=INF && now>0)now--;\n  }\n  \n  now=0;\n  for(int i=n-1;i>=0;i--){\n    if(in[i]==0)now=INF;\n    if(in[i]<0)now=min(now,-in[i]);\n    if(in[i]>0)r[i]=min(now,in[i]);\n    if(now!=INF && now>0)now--;\n  }\n \n  int ans=0;\n  for(int i=0;i<n;i++)ans+=max(l[i],r[i]);\n  cout << ans << endl;  \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main() {\n  int W; cin >> W;\n  vector<int> a(W);\n  for(int i = 0; i < W; ++i) cin >> a[i];\n  vector<int> L(W+1), R(W+1);\n  L[0] = -1;\n  for(int i = 0; i < W; ++i) {\n    L[i+1] = L[i] - 1;\n    if(a[i] == 0) L[i+1] = INF;\n    else if(a[i] < 0) L[i+1] = min(L[i+1], -a[i]-1);\n  }\n  R[W] = -1;\n  for(int i = W-1; i >= 0; --i) {\n    R[i] = R[i+1] - 1;\n    if(a[i] == 0) R[i] = INF;\n    else if(a[i] < 0) R[i] = min(R[i], -a[i]-1);\n  }\n  int res = 0;\n  for(int i = 0; i < W; ++i) {\n    if(a[i] > 0); else continue;\n    int t = max(L[i+1], R[i]);\n    if(t < 0) continue;\n    res += min(a[i], t+1);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  rep(i,n) cin >> a[i];\n  vector<int> time(n,-1);\n  priority_queue<pair<int,int>> heap;\n  rep(i,n){\n    if(a[i]==0){\n      heap.push({IINF,i});\n    }\n  }\n  while(!heap.empty()){\n    auto p = heap.top();\n    heap.pop();\n    if(time[p.second]!=-1) continue;\n    time[p.second]=p.first;\n    if(p.second>0){\n      if(time[p.second-1]==-1){\n        int k = p.first-1;\n        if(a[p.second-1]<0) k = min(k,-a[p.second-1]);\n        heap.push({k,p.second-1});\n      }\n    }\n    if(p.second<n-1){\n      if(time[p.second+1]==-1){\n        int k = p.first-1;\n        if(a[p.second+1]<0) k = min(k,-a[p.second+1]);\n        heap.push({k,p.second+1});\n      }\n    }\n  }\n  int ans=0;\n  rep(i,n){\n    if(a[i]>0&&time[i]!=-1) ans+=max(0,min(a[i],time[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\n//end of lib\nint main() {\n\tint w;\n\tcin >> w;\n\tvi a(w), t(w, 0);\n\trep(i, w)cin >> a[i];\n\trep(i, w) {\n\t\tif (a[i] == 0)t[i] = 1e5;\n\t\telse if (i == 0)continue;\n\t\telse if (a[i] < 0)cmax(t[i],min(t[i - 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i - 1] - 1);\n\t}\n\trrep(i, w) {\n\t\tif (a[i] == 0 || i == w - 1)continue;\n\t\tif (a[i] < 0)cmax(t[i],min(t[i + 1]-1, -a[i]));\n\t\telse cmax(t[i], t[i + 1] - 1);\n\t}\n\tll ans = 0;\n\trep(i, w) {\n\t\tif (a[i] > 0)ans += min(a[i], t[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint W; cin >> W;\n\tvector<int> a(W); for (int i = 0; i < W; i++) cin >> a[i];\n\tvector<int> dpl(W + 1, inf), dpr(W + 1, inf);\n\tdpl[0] = -inf;\n\tdpr[W] = -inf;\n\tfor (int i = 0; i < W; i++) {\n\t\tchmin(dpl[i + 1], dpl[i] - 1);\n\t\tif (a[i] < 0) {\n\t\t\tint t = -a[i];\n\t\t\tchmin(dpl[i + 1], t);\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tdpl[i + 1] = inf;\n\t\t}\n\t}\n\tfor (int i = W - 1; i >= 0; i--) {\n\t\tchmin(dpr[i], dpr[i + 1] - 1);\n\t\tif (a[i] < 0) {\n\t\t\tint t = -a[i];\n\t\t\tchmin(dpr[i], t);\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tdpr[i] = inf;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tif (a[i] > 0) {\n\t\t\tint t = max({ dpl[i + 1], dpr[i], 0 });\n\t\t\tres += min(t, a[i]);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint main(){\n\tint W;\n\tcin>>W;\n\tint i=0;\n\tint a[100000]={0};\n\twhile(i<W){\n\t\tcin>>a[i];\n\t\ti++;\n\t}\n\n\ti=0;\n\tint cnt=0;\n\twhile(i<W){\n\t\tif(a[i]>0){\n\t\t\tint n,v,p0,p1;\n\t\t\tv=a[i];\n\t\t\tp0=100000;\n\t\t\tfor(n=i-1;n>=0;n--){\n\t\t\t\tif(a[n]<0){\n\t\t\t\t\tif(abs(a[n])-(i-n)<p0){\n\t\t\t\t\t\t//cout<<\"a[n]=\"<<a[n]<<\",i=\"<<i<<\",n=\"<<n<<endl;\n\t\t\t\t\t\tp0=abs(a[n])-(i-n);\n\t\t\t\t\t\t//cout<<\"p0=\"<<p0<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[n]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n==-1)\n\t\t\t\tp0=0;\n\t\t\telse\n\t\t\t\tif(p0==100000) p0=a[i];\n\n\t\t\tp1=100000;\n\t\t\tfor(n=i+1;n<W;n++){\n\t\t\t\tif(a[n]<0){\n\t\t\t\t\tif(abs(a[n])-(n-i)<p1){\n\t\t\t\t\t\t//cout<<\"a[n]=\"<<a[n]<<\",i=\"<<i<<\",n=\"<<n<<endl;\n\t\t\t\t\t\tp1=abs(a[n])-(n-i);\n\t\t\t\t\t\t//cout<<\"p0=\"<<p1<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[n]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n==W)\n\t\t\t\tp1=0;\n\t\t\telse\n\t\t\t\tif(p1==100000) p1=a[i];\n\n\t\t\t//cout<<\"p0,p1:\"<<p0<<\",\"<<p1<<endl;\n\t\t\tcnt+=p0<p1?p1:p0;\n\t\t}\n\t\ti++;\n\t}\n\tcout<<cnt<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  long long int A[W], INF = 100000000000LL;\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size();\n  long long int s, t;\n  vector<long long int> ans(W,0LL);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = INF;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+(long long int)j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = INF;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1]+1;\n    t = INF;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s));\n      }\n    }\n    s = E[0]-1;\n    t = INF;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  //cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s));\n      }\n    }\n  }\n  long long int sum = 0LL; \n\n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    //cout << ans[i] << \" \";\n  }\n  //cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\nint main(){\n  int N, M, K;\n  cin >> N >> M >> K;\n  int D[M], V[N][K];\n  for(int i = 0; i < M; ++i){\n    cin >> D[i];\n    --D[i];\n  }\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < K; ++j){\n      cin >> V[i][j];\n      --V[i][j];\n    }\n  }\n  queue< pair<int,int> > que;\n  map<int,int> L;\n  int d = 0;\n  for(int i = 0; i < M; ++i){\n    d += (1<<D[i]);\n  }\n  que.push(make_pair(d,0));\n  while(!que.empty()){\n    int s = que.front().first, len = que.front().second;\n    que.pop();\n    for(int i = 0; i < K; ++i){\n      int t = 0;\n      for(int j = 0; j < M; ++j){\n\tif((s>>j)&1){\n\t  t += (1<<V[D[j]][i]);\n\t}\n      }\n      t &= d;\n      if(!t){\n\tcout << len+1 << endl;\n\treturn 0;\n      }\n      if(len+1 < L[t] || !L[t]){\n\tque.push(make_pair(t,len+1));\n\tL[t] = len+1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint w;\nvector<int> a(100000 + 5);\nvector<int> ex;\n\nstruct segtree {\n    int size;\n    vector<long long> node;\n\n    segtree (int n) : size(1) {\n        while (size < n) size *= 2;\n        node.resize(2 * size - 1, INFLL / 2);\n    }\n\n    void update(int k, int a) {\n        k += size - 1;\n        node[k] = a;\n        while (k > 0){\n            k = (k - 1) / 2;\n            node[k] = min(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    //[queryL: queryR)\n    long long get(int queryL, int queryR, int k = 0, int nodeL = 0, int nodeR = -1) {\n        if (nodeR == -1) nodeR = size;\n        if (nodeR <= queryL || queryR <= nodeL) return INFLL;//初期値より大きく\n        if (queryL <= nodeL && nodeR <= queryR) return node[k];\n        else{\n            int nodeM = (nodeL + nodeR) / 2;\n            long long vl = get(queryL, queryR, 2 * k + 1, nodeL, nodeM);\n            long long vr = get(queryL, queryR, 2 * k + 2, nodeM, nodeR);\n            return min(vl, vr);\n        }\n    }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> w;\n  segtree segr(w);\n  segtree segl(w);\n  vector<int> diff_sumr(w), diff_suml(w);\n  vector<int> minus_pos;\n  bool plus = false;\n  rep(i, w) {\n    cin >> a[i];\n    if (a[i] == 0) ex.push_back(i);\n    if (a[i] > 0) plus = true;\n    if (a[i] < 0) {\n      minus_pos.push_back(i);\n    }\n  }\n  if (ex.size() == 0 || !plus) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int ans = 0;\n  if (minus_pos.size() == 0) {\n    rep(i, w) {\n      if (a[i] > 0) ans += a[i];\n    }\n    cout << ans << endl;\n    return 0;\n  }\n  rep2(i, 1, minus_pos.size()) {\n    int cur = minus_pos[i];\n    int pre = minus_pos[i - 1];\n    diff_sumr[cur] = cur - pre;\n  }\n  rrep2(i, (int)minus_pos.size() - 2, -1) {\n    int cur = minus_pos[i];\n    int pre = minus_pos[i + 1];\n    diff_suml[cur] = pre - cur;\n  }\n  rep(i, w - 1) diff_sumr[i + 1] += diff_sumr[i];\n  rep(i, w) {\n    if (a[i] < 0) {\n      segr.update(i, -a[i] - diff_sumr[i]);\n    }\n  }\n  rrep2(i, w - 1, 0) diff_suml[i - 1] += diff_suml[i];\n  rrep2(i, w - 1, -1) {\n    if (a[i] < 0) {\n      segl.update(i, -a[i] - diff_suml[i]);\n    }\n  }\n\n  rep(i, w) {\n    if (a[i] <= 0) continue;\n    int exidx = lower_bound(all(ex), i) - ex.begin();\n    int exposl = -1;\n    int exposr = -1;\n    int minusidx = lower_bound(all(minus_pos), i) - minus_pos.begin();\n    int mnposl = -1;\n    int mnposr = -1;\n    if (minusidx == 0) {\n      mnposr = minus_pos[minusidx];\n    }\n    else if (minusidx == minus_pos.size()) {\n      mnposl = minus_pos[minusidx - 1];\n    }\n    else {\n      mnposl = minus_pos[minusidx - 1];\n      mnposr = minus_pos[minusidx];\n    }\n    if (exidx == 0) {\n      exposr = ex[exidx];\n      if (mnposr == -1 || mnposr > exposr) {\n         //cerr << \"1 : \" << i << \" \" << a[i] << endl;\n         ans += a[i];\n      }\n      else {\n        int cnt = segr.get(i, exposr + 1) + diff_sumr[mnposr] - (mnposr - i);\n        if (cnt < 0) continue;\n        //cerr << \"2 : \" << i << \" \" << min(a[i], cnt) << endl;\n        ans += min(a[i], cnt);\n      }\n    }\n    else if (exidx == ex.size()) {\n      exposl = ex[exidx - 1];\n      if (mnposl < exposl) {\n        ans += a[i];\n        //cerr << \"3 : \" << i << \" \" << a[i] << endl;\n      }\n      else {\n        int cnt = segl.get(exposl, i + 1) + diff_suml[mnposl] - (i - mnposl);\n        if (cnt < 0) continue;\n        //cerr << \"4 : \" << i << \" \" << min(a[i], cnt) << endl;\n        ans += min(a[i], cnt);\n      }\n    }\n    else {\n      exposl = ex[exidx - 1];\n      exposr = ex[exidx];\n      if (mnposl < exposl || exposr < mnposr || mnposr == -1) {\n        //cerr << \"5 : \" << i << \" \" << a[i] << endl;\n        ans += a[i];\n      }\n      else {\n        int cntl = segl.get(exposl, i + 1) + diff_suml[mnposl] - (i - mnposl);\n        int cntr = segr.get(i, exposr + 1) + diff_sumr[mnposr] - (mnposr - i);\n        if (cntl < 0 && cntr < 0) continue;\n        if (cntl < 0) {\n          //cerr << \"6 : \" << i <<  \" \" << min(a[i], cntr) << endl;\n          ans += min(a[i], cntr);\n        }\n        else if (cntr < 0) {\n          //cerr << \"7 : \" << i << \" \" << min(a[i], cntl) << endl;\n          ans += min(a[i],  cntl);\n        }\n        else {\n          //cerr << \"8 : \" << i << \" \" << min({a[i], max(cntl, cntr)}) << endl;\n          ans += min(a[i], max(cntl, cntr));\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nint l[MAX_N],r[MAX_N];\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n){\n        cin >> a[i];\n    }\n    int ans = 0;\n    rep(i,n){\n        if(a[i] < 0){\n            if(i){\n                l[i] = min(max(0,l[i-1]-1),-a[i]);\n            }else{\n                l[0] = 0;\n            }\n        }else if(a[i] > 0){\n            if(i){\n                l[i] = max(l[i-1]-1,0);\n            }else{\n                l[0] = 0;\n            }\n        }else{\n            l[i] = INF;\n        }\n    }\n    for(int i=n-1;i>=0;i--){\n        if(a[i] < 0){\n            if(i < n-1){\n                r[i] = min(max(0,r[i+1]-1),-a[i]);\n            }else{\n                r[n-1] = 0;\n            }\n        }else if(a[i] > 0){\n            if(i < n-1){\n                r[i] = max(0,r[i+1]-1);\n            }else{\n                r[n-1] = 0;\n            }\n        }else{\n            r[i] = INF;\n        }\n    }\n    rep(i,n){\n        if(a[i] > 0) ans += min(a[i],max(l[i],r[i]));\n    }\n    cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  int A[W];\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size(), s, t;\n  vector<int> ans(W,0);\n  for(int i = 1; i < N; ++i){\n    s = E[i-1], t = W+1;\n    for(int j = E[i-1]+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n  }\n\n  for(int i = N-2; i >= 0; --i){\n    s = E[i+1], t = W+1;\n    for(int j = E[i+1]-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    }\n  }\n  if(N){\n    s = E[N-1];\n    t = W;\n    for(int i = E[N-1]+1; i < W; ++i){\n      if(A[i] < 0){\n\tif(-A[i]-s+i < t){\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t-i+s+2));\n      }\n    }\n    s = E[0];\n    t = W;\n    for(int i = E[0]-1; i >= 0; --i){\n      if(A[i] < 0){\n\tif(-A[i]+s-i < t){\n\t  cout << s << \" \" << t << endl;\n\t  t = -A[i];\n\t  s = i;\n\t}\n      }else{\n\tans[i] = max(ans[i],min(A[i],t+i-s+2));\n      }\n    }\n  }\n  long long int sum = 0LL; \n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n    cout << ans[i] << \" \";\n  }\n  cout << endl;\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100003,INF=1<<30;\nint N;\nint A[MAX],can[MAX],memo[MAX];\n\nvoid BFS(){\n    queue<int> Q;\n    priority_queue<pair<int,int>> PQ;\n    \n    for(int i=0;i<N;i++){\n        if(A[i]==0){\n            Q.push(i);\n            can[i]=INF;\n        }\n    }\n    \n    while(!Q.empty()){\n        int a=Q.front();\n        Q.pop();\n        \n        if(a&&A[a-1]>0&&can[a-1]==0){\n            can[a-1]=INF;\n            Q.push(a-1);\n        }\n        if(a&&A[a-1]<0&&can[a-1]==0){\n            can[a-1]=-A[a-1];\n            PQ.push({-A[a-1],a-1});\n        }\n        \n        if(a<N-1&&A[a+1]>0&&can[a+1]==0){\n            can[a+1]=INF;\n            Q.push(a+1);\n        }\n        if(a<N-1&&A[a+1]<0&&can[a+1]==0){\n            can[a+1]=-A[a+1];\n            PQ.push({-A[a+1],a+1});\n        }\n    }\n    \n    while(!PQ.empty()){\n        int a=PQ.top().first,b=PQ.top().second;\n        PQ.pop();\n        \n        if(can[b]!=INF&&can[b]>a) continue;\n        if(memo[b]>a) continue;\n        \n        a--;\n        \n        if(a<=0) continue;\n        \n        if(b&&(can[b-1]<a||(can[b-1]==INF&&memo[b-1]<a))){\n            int x=a;\n            if(A[b-1]<0) x=min(x,-A[b-1]);\n            if(can[b-1]!=INF) can[b-1]=x;\n            memo[b-1]=x;\n            PQ.push({x,b-1});\n        }\n        if(b<N-1&&(can[b+1]<a||(can[b+1]==INF&&memo[b+1]<a))){\n            int x=a;\n            if(A[b+1]<0) x=min(x,-A[b+1]);\n            if(can[b+1]!=INF) can[b+1]=x;\n            memo[b+1]=x;\n            PQ.push({x,b+1});\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>N;\n    for(int i=0;i<N;i++) cin>>A[i];\n    \n    BFS();\n    \n    ll ans=0;\n    \n    for(int i=0;i<N;i++){\n        if(A[i]>0){\n            ans+=max(min(A[i],can[i]),0);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define W 100010\nusing namespace std;\ntypedef long long ll;\nll w,mp[W];\nll l[W],r[W];\n\nint main(){\n  cin>>w;\n  \n  for(int i=0;i<w+2;i++)l[i]=r[i]=-10000000;\n  l[0]=0;\n  r[w+1]=0;\n\n  for(int i=1;i<=w;i++) {\n    cin>>mp[i];\n    if(mp[i]<0) l[i]=r[i]=mp[i];\n    if(mp[i]==0)l[i]=r[i]=-10000000;\n  }\n  w+=2;\n  \n  for(int i=1;i<w;i++){\n    int j=w-i-1;\n    if(mp[i]!=0)l[i]=max(l[i],l[i-1]+1);\n    if(mp[j]!=0)r[j]=max(r[j],r[j+1]+1);\n  }\n\n  //  for(int i=0;i<w;i++)cout<<l[i]<<\" \";cout<<endl;\n  //for(int i=0;i<w;i++)cout<<r[i]<<\" \";cout<<endl;\n\n  ll ans=0;\n  for(int i=0;i<=w;i++){\n    if(mp[i]<=0)continue;\n    ll a=l[i]<0? min(mp[i],abs(l[i])):0;  \n    ll b=r[i]<0? min(mp[i],abs(r[i])):0;\n    \n    // cout <<a<<\" \"<<b<<endl;\n    ans+=max(0LL,max(a,b));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int n;\n    input(n);\n    vector<i64> a(n);\n    input(a);\n    i64 ans = 0;\n\n    // [, )\n    auto f = [&](int l, int r){\n        int len = r - l;\n        if(!len)\n            return ;\n        vector<i64> tim_min(len, -MOD);\n        if(l != 0){\n            vector<i64> time(len, MOD);\n            time[0] = (a[l] < 0 ? -a[l] : MOD);\n            for(int i = 1; i < len; ++i)\n                time[i] = min(time[i - 1] - 1, a[l + i] < 0 ? -a[l + i] : MOD);\n            for(int i = 0; i < len; ++i)\n                chmax(tim_min[i], time[i]);\n        }\n        if(r != n){\n            vector<i64> time(len, MOD);\n            time[len - 1] = (a[r - 1] < 0 ? -a[r - 1] : MOD);\n            for(int i = len - 2; i >= 0; --i)\n                time[i] = min(time[i + 1] - 1, a[l + i] < 0 ? -a[l + i] : MOD);\n            for(int i = 0; i < len; ++i)\n                chmax(tim_min[i], time[i]);\n        }\n        for(int i = 0; i < len; ++i)\n            if(a[l + i] > 0)\n                ans += max(0L, min(a[l + i], tim_min[i]));\n    };\n    int l = 0;\n    for(int i = 0; i < n; ++i)\n        if(a[i] == 0){\n            f(l, i);\n            l = i + 1;\n        }\n    f(l, n);\n\n    cout << ans << endl;\n\n    return false;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 2000000000\n#define f first\n#define s second\nusing namespace std;\n\nint w;\nint a[1000000],b[1000000],c[1000000];\n\nint main()\n{\n  pair<int,int> u;\n  cin>>w;\n  for(int i=0;i<w;i++)cin>>a[i];\n  for(int i=0;i<w;i++){\n    if(a[i]==0){\n      b[i]=0;\n      c[i]=0;\n    }\n    else {\n      b[i]=0;\n      c[i]=0;\n    }\n  }\n  u.f=inf;u.s=inf;\n  for(int i=0;i<w-1;i++){\n    if(a[i+1]==0){\n      u.f=inf;u.s=inf;\n      b[i+1]=inf;\n      continue;\n    }\n    u.s--;\n    if(u.s<0)u.s=0;\n    if(a[i+1]>0){\n      if(a[i]>0){\n\tif(a[i]==b[i])b[i+1]=max(0,min(a[i+1],u.s));\n        else b[i+1]=max(0,min(b[i]-1,a[i+1]));\n      }\n      if(a[i]<0){\n\tb[i+1]=max(0,min(b[i]-1,a[i+1]));\n      }\n      if(a[i]==0)b[i+1]=a[i+1];\n    }\n\n    if(a[i+1]<0){\n\n      if(a[i]>0){\n\tif(a[i]==b[i])b[i+1]=max(0,min(-a[i+1],u.s));\n\telse b[i+1]=max(0,min(b[i]-1,-a[i+1]));\n      }\n      if(a[i]<0){\n\tb[i+1]=max(0,min(b[i]-1,-a[i+1]));\n      }\n      if(a[i]==0)b[i+1]=-a[i+1];\n      u.f=-a[i+1];\n      u.s=b[i+1];\n    }\n  }\n  \n  u.f=inf;u.s=inf;\n  for(int i=w-1;i>=1;i--){\n    if(a[i-1]==0){\n      u.f=inf;u.s=inf;\n      c[i-1]=inf;\n      continue;\n    }\n    \n    u.s--;\n    if(u.s<0)u.s=0;\n    if(a[i-1]>0){\n      if(a[i]>0){\n\t\n\tif(a[i]==c[i])c[i-1]=max(0,min(a[i-1],u.s));\n        else c[i-1]=max(0,min(c[i]-1,a[i-1]));\n      }\n      if(a[i]<0){\n\tc[i-1]=max(0,min(c[i]-1,a[i-1]));\n      }\n      if(a[i]==0)c[i-1]=a[i-1];\n    }\n    \n    if(a[i-1]<0){\n      if(a[i]>0){\n\tif(a[i]==c[i])c[i-1]=max(0,min(-a[i-1],u.s));\n\telse c[i-1]=max(0,min(c[i]-1,-a[i-1]));\n      }\n      if(a[i]<0){\n\tc[i-1]=max(0,min(c[i]-1,-a[i-1]));\n\n      }\n      if(a[i]==0)c[i-1]=-a[i-1];\n\tu.f=-a[i-1];\n\tu.s=c[i-1];\n    }\n  }\n/*\n  for(int i=0;i<w;i++){\n  if(c[i]!=inf)cout<<c[i]<<\" \";\n  else cout<<\"I \";\n  }*/\n  int ans=0;\n  for(int i=0;i<w;i++){\n    if(a[i]>0)ans+=max(b[i],c[i]);\n    }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint W;\n\tcin >> W;\n\tvector<int> a(W+2),dp1(W+2,-1e9),dp2(W+2,-1e9);\n\tfor(int i = 1 ; i <= W ; i++) cin >> a[i];\n\t\n\tfor(int i = 1 ; i <= W ; i++){\n\t\tif( a[i] == 0 ) dp1[i] = 1e9;\n\t\telse if( a[i] < 0 ) dp1[i] = min(dp1[i-1]-1,-a[i]);\n\t\telse dp1[i] = dp1[i-1]-1;\n\t}\n\tfor(int i = W ; i >= 1 ; i--){\n\t\tif( a[i] == 0 ) dp2[i] = 1e9;\n\t\telse if( a[i] < 0 ) dp2[i] = min(dp2[i+1]-1,-a[i]);\n\t\telse dp2[i] = dp2[i+1]-1;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1 ; i <= W ; i++)\n\t\tans += max(0,min(max(dp1[i],dp2[i]),a[i]));\n\tcout << ans << endl;\n\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1e9\n\nusing namespace std;\n\nint n;\nint a[100005];\nint lmin[100005], rmin[100005];\n\nint main(void)\n{\n  cin >> n;\n  for(int i = 1; i <= n; i++) cin >> a[i];\n\n  lmin[0] = 0;\n  for(int i = 1; i <= n; i++){\n    if(a[i] == 0) lmin[i] = inf;\n    if(a[i] > 0) lmin[i] = lmin[i-1] - 1;\n    if(a[i] < 0) lmin[i] = min(lmin[i-1]-1, -a[i]-1);\n  }\n  rmin[n+1] = 0;\n  for(int i = n; i >= 1; i--){\n    if(a[i] == 0) rmin[i] = inf;\n    if(a[i] > 0) rmin[i] = rmin[i+1] - 1;\n    if(a[i] < 0) rmin[i] = min(rmin[i+1]-1, -a[i]-1);\n  }\n\n  //for(int i = 1; i <= n; i++) cout << lmin[i] << \" \"; cout << endl;\n  //for(int i = 1; i <= n; i++) cout << rmin[i] << \" \"; cout << endl;\n\n  int ans = 0;\n  for(int i = 1; i <= n; i++){\n    if(a[i] > 0) ans += max(0, min(a[i], max(lmin[i], rmin[i])+1));\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n\nint W;\nint A[101010];\nint dp[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> W)\n\t{\n\t\trep(i, 0, W) cin >> A[i];\n\t\trep(i, 0, W) dp[i] = 0;\n\t\trep(i, 0, W) if (A[i] == 0)\n\t\t{\n\t\t\tint m = INF;\n\n\t\t\trrep(j, i - 1, 0)\n\t\t\t{\n\t\t\t\tif (A[j] == 0) break;\n\t\t\t\tif (A[j] > 0)\n\t\t\t\t{\n\t\t\t\t\tdp[j] = max(dp[j], min(m, A[j]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm = min(m, -A[j]);\n\t\t\t\t}\n\n\t\t\t\tm--;\n\t\t\t\tif (m == 0) break;\n\t\t\t}\n\n\t\t\tm = INF;\n\t\t\trep(j, i + 1, W)\n\t\t\t{\n\t\t\t\tif (A[j] == 0) break;\n\t\t\t\tif (A[j] > 0)\n\t\t\t\t{\n\t\t\t\t\tdp[j] = max(dp[j], min(m, A[j]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm = min(m, -A[j]);\n\t\t\t\t}\n\n\t\t\t\tm--;\n\t\t\t\tif (m == 0) break;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, 0, W) ans += dp[i];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct segtree{\n    int n;\n    vector<int> dat;\n    segtree(int size,int x){\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,x);\n    }\n    // update k th element\n    void update(int k,int a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    // min [a, b)\n    int query(int a,int b) { return query(a,b,0,0,n); }\n    int query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return inf;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return min(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int w;\n    cin >> w;\n    vector<int> a(w);\n    rep(i,0,w) cin >> a[i];\n\n    vector<int> out;\n    segtree seg1(w,inf),seg2(w,inf);\n    out.emplace_back(-1);\n    rep(i,0,w){\n        if(a[i]==0) out.emplace_back(i);\n        if(a[i]<0){\n            seg1.update(i,-a[i]+i);\n            seg2.update(i,-a[i]-i);\n        }\n    }\n    out.emplace_back(inf);\n\n    int ans=0;\n    rep(i,0,w){\n        if(a[i]<=0) continue;\n        const int pos=i,num=a[i];\n        const int left_out=*(upper_bound(out.begin(),out.end(),pos)-1),right_out=*(upper_bound(out.begin(),out.end(),pos));\n        const int left_shutter=seg1.query(left_out,pos),right_shutter=seg2.query(pos,right_out);\n        auto ok=[&](const int x){\n            if(left_shutter==inf and left_out!=-1) return true;\n            if(right_shutter==inf and right_out!=inf) return true;\n            if(left_out!=-1 and x-1+pos<left_shutter) return true;\n            if(right_out!=inf and x-1-pos<right_shutter) return true;\n            return false;\n        };\n        int lb=0,ub=num+1;\n        while(ub-lb>1){\n            const int mid=(lb+ub)/2;\n            if(ok(mid)) lb=mid;\n            else ub=mid;\n        }\n        ans+=lb;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint l[131072],r[130172],a[131072];\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n) cin >> a[i+1];\n  REP(i,n) if(a[i+1]<0) l[i+1]=-a[i+1];\n  l[0]=16384;\n  REP(i,n) if(a[i+1]) l[i+1]=max(l[i]+1,l[i+1]);\n  r[n+1]=16384;\n  REP(i,n) if(a[n-i]) r[n-i]=max(r[n-i+1]+1,r[n-i]);\n  int answer=0;\n  FOR(i,1,n+1) l[i]=min(l[i],r[i]);\n  FOR(i,1,n+1){\n    if(a[i]>0&&a[i]-l[i]>=0) answer+=a[i]-l[i]+1;\n  }\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nint a[100010];\nint dp[100010];\n\nint main() {\n\n  cin >> N;\n  rep(i, N) {\n    cin >> a[i];\n  }\n\n  int x = 0;\n  rep(i, N) {\n    x --;\n    if(a[i] == 0)\n      x = inf;\n    if(a[i] < 0)\n      minimize(x, -a[i]);\n    maximize(dp[i], x);\n  }\n\n  x = 0;\n  for(int i=N-1; i>=0; i--) {\n    x --;\n    if(!a[i])\n      x = inf;\n    if(a[i] < 0)\n      minimize(x, -a[i]);\n    maximize(dp[i], x);\n  }\n\n  int ans = 0;\n  rep(i, N) {\n    if(a[i] > 0)\n      ans += min(dp[i], a[i]);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#define INF 1e7\nusing namespace std;\n\nvector<int> index;\n\nint w,n;\nint val[2][1<<18];\nvoid init(){\n\tn=1;\n\twhile(n<w)n*=2;\n\tfor(int i=0;i<2*n-1;i++)val[0][i]=val[1][i]=INF;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tval[0][k]=a-(k-(n-1));\n\tval[1][k]=a-(w-1-(k-(n-1)));\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tval[0][k]=min(val[0][k*2+1],val[0][k*2+2]);\n\t\tval[1][k]=min(val[1][k*2+1],val[1][k*2+2]);\n\t}\n}\n\nint query(int d,int a,int b,int k=0,int l=0,int r=n){\n\tif(a<=l && r<=b)return val[d][k];\n\tif(r<=a || b<=l)return INF;\n\tint vl=query(d,a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(d,a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n}\n\nint a[100001];\n\nint main(void){\n\tscanf(\"%d\",&w);\n\tinit();\n\tindex.push_back(-1);\n\tfor(int i=0;i<w;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]==0)index.push_back(i);\n\t\tif(a[i]<0){\n\t\t\tupdate(i,-a[i]);\n\t\t}\n\t}\n\tindex.push_back(w);\n\tint cnt=0;\n\tfor(int i=0;i<w;i++){\n\t\tif(a[i]>0){\n\t\t\tint num=0;\n\t\t\tint ld=lower_bound(index.begin(),index.end(),i)-index.begin();\n\t\t\tld--;\n\t\t\tint dat1=-INF,dat2=-INF;\n\t\t\tif(ld!=0){\n\t\t\t\tdat1=query(1,index[ld]+1,i);\n\t\t\t\tif(dat1>=-(w-1-i))num=max(num,min(dat1+(w-1-i),a[i]));\n\t\t\t}\n\t\t\tint rd=lower_bound(index.begin(),index.end(),i)-index.begin();\n\t\t\tif(rd!=index.size()-1){\n\t\t\t\tdat2=query(0,i+1,index[rd]);\n\t\t\t\tif(dat2>=-i)num=max(num,min(dat2+i,a[i]));\n\t\t\t}\n\t\t\tcnt+=num;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint INF = 1000000;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tpriority_queue<pair<int, int> > PQ;\n\tvector<int> X(N, -INF);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == 0) X[i] = INF, PQ.push({ INF, i });\n\t}\n\twhile (!PQ.empty()) {\n\t\tpair<int, int> P = PQ.top();\n\t\tPQ.pop();\n\t\tint Time = P.first, Now = P.second;\n\t\tif (Time < X[Now]) continue;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint Next = Now + (i * 2 - 1);\n\t\t\tif (0 <= Next && Next < N) {\n\t\t\t\tint NextTime;\n\t\t\t\tif (A[Next] < 0) NextTime = min(-A[Next], Time - 1);\n\t\t\t\telse NextTime = Time - 1;\n\t\t\t\tif (X[Next] < NextTime) {\n\t\t\t\t\tX[Next] = NextTime;\n\t\t\t\t\tPQ.push({ NextTime, Next });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ANS = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tANS += min(max(0, A[i]), max(0, X[i]));\n\t}\n\tcout << ANS << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint l[131072],r[130172],a[131072];\nint main(void)\n{\n  int n;\n  cin >> n;\n  FOR(i,1,n+1) cin >> a[i];\n  FOR(i,1,n+1)\n    if(a[i]<0){\n      l[i]=-a[i];\n      r[i]=-a[i];\n    }else{\n      l[i]=16384;\n      r[i]=16384;\n    }\n  l[0]=0;\n  REP(i,n) if(a[i+1]) l[i+1]=min(l[i]-1,l[i+1]);\n  r[n+1]=0;\n  REP(i,n) if(a[n-i]) r[n-i]=min(r[n-i+1]-1,r[n-i]);\n  int answer=0;\n  FOR(i,1,n+1) l[i]=max(l[i],r[i]);\n  FOR(i,1,n+1){\n    if(min(a[i],l[i])>0) answer+=min(a[i],l[i]);\n  }\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint main() {\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tvector<int> l(n, -1), r(n, -1);\n\tint gl = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gl > 0) gl--;\n\t\tif (a[i] == 0) gl = 999999999;\n\t\tif (a[i] < 0) gl = min(gl, -a[i]);\n\t\tif (a[i] > 0) l[i] = gl;\n\t}\n\tint gr = -1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr > 0) gr--;\n\t\tif (a[i] == 0) gr = 999999999;\n\t\tif (a[i] < 0) gr = min(gr, -a[i]);\n\t\tif (a[i] > 0) r[i] = gr;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) ret += min(a[i], max(l[i], r[i]));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint W,a[100000],l[100000],r[100000],inf=1e8;\nint main(){\n\tcin>>W;\n\trep(i,W) cin>>a[i];\n\tint t=0;\n\trep(i,W){\n\t\tif(a[i]==0){\n\t\t\tt=inf;\n\t\t}else if(a[i]<0){\n\t\t\tt=min(t-1,-a[i]);\n\t\t}else{\n\t\t\tt--;\n\t\t\tl[i]=max(0,min(a[i],t));\n\t\t}\n\t}\n\tt=0;\n\tfor(int i=W-1;i>=0;i--){\n\t\tif(a[i]==0){\n\t\t\tt=inf;\n\t\t}else if(a[i]<0){\n\t\t\tt=min(t-1,-a[i]);\n\t\t}else{\n\t\t\tt--;\n\t\t\tr[i]=max(0,min(a[i],t));\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,W) ans+=max(l[i],r[i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main() {\n  for(int W; cin >> W; ) {\n    vector<int> a(W);\n    for(int i = 0; i < W; ++i) cin >> a[i];\n    vector<int> A(W), B(W);\n    A[0] = a[0] == 0 ? INF : 0;\n    for(int i = 1; i < W; ++i) {\n      if(a[i] == 0) A[i] = INF;\n      else {\n        A[i] = max(0, A[i-1] - 1);\n        if(a[i] < 0) A[i] = min(A[i], -a[i]);\n      }\n    }\n    B[W-1] = a[W-1] == 0 ? INF : 0;\n    for(int i = W-2; i >= 0; --i) {\n      if(a[i] == 0) B[i] = INF;\n      else {\n        B[i] = max(0, B[i+1] - 1);\n        if(a[i] < 0) B[i] = min(B[i], -a[i]);\n      }\n    }\n    int res = 0;\n    for(int i = 0; i < W; ++i) {\n      if(a[i] > 0) {\n        res += min(a[i], max(A[i], B[i]));\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int W;\n  cin >> W;\n  int A[W];\n  for(int i = 0; i < W; ++i)\n    cin >> A[i];\n  \n  vector<int> E;\n  for(int i = 0; i < W; ++i){\n    if(!A[i]) E.push_back(i);\n  }\n\n  int N = (int)E.size(), k = -1;\n  vector<int> ans(W,0);\n  for(int i = 0; i < N; ++i){\n    int s = k+1, t = W;\n    for(int j = k+1; j < E[i]; ++j){\n      if(A[j] < 0){\n\tif(-A[j]-s+j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t-j+s));\n      }\n    }\n    k = E[i];\n  }\n  k = W;\n  for(int i = N-1; i >= 0; --i){\n    int s = k-1, t = W;\n    for(int j = k-1; j > E[i]; --j){\n      if(A[j] < 0){\n\tif(-A[j]+s-j < t){\n\t  t = -A[j];\n\t  s = j;\n\t}\n      }else{\n\tans[j] = max(ans[j],min(A[j],t+j-s));\n      }\n    } \n    k = E[i];\n  }\n  long long int sum = 0LL; \n  for(int i = 0; i < W; ++i){\n    sum += (long long int)ans[i];\n  }\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<28)\n#define MAX 100000\nint n;\nint t[MAX],l[MAX],r[MAX];\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&t[i]);\n    l[i]=r[i]=i;\n  }\n  int d=-1;\n  for(int i=0;i<n;i++){\n    if(t[i]==0){\n      d=INF;\n    }else if(t[i]<0){\n      d=min(d-1,-t[i]);\n    }else if(t[i]>0){\n      d--;\n      l[i]=d;\n    }\n  }\n  d=-1;\n  for(int i=n-1;i>=0;i--){\n    if(t[i]==0){\n      d=INF;\n    }else if(t[i]<0){\n      d=min(d-1,-t[i]);\n    }else if(t[i]>0){\n      d--;\n      r[i]=d;\n    }\n  }\n  \n  int ans=0,c;\n  for(int i=0;i<n;i++){\n    c=max(0,max(l[i],r[i]));\n    if(t[i]>0)ans+=min(t[i],c);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define WMAX 100000\n#define ESC_UNLIMITED 10001\nusing namespace std;\n\nint main() {\n  short a_list[WMAX], leftesc[WMAX] = {};\n  int w;\n  cin >> w;\n\n  short esc_limit = 0;\n  for (int i = 0; i < w; i++) {\n    cin >> a_list[i];\n    auto &a = a_list[i];\n    if (a == 0) {\n      esc_limit = ESC_UNLIMITED;\n    } else if (esc_limit > 0) {\n      if (a > 0) {\n        leftesc[i] = min(a, esc_limit);\n      } else {\n        esc_limit = min(esc_limit, (short)-a);\n      }\n      if (esc_limit != ESC_UNLIMITED) esc_limit--;\n    }\n  }\n\n  unsigned long r = 0;\n  esc_limit = 0;\n  for (int i = w - 1; i >= 0; i--) {\n    auto& a = a_list[i];\n    if (a == 0) {\n      esc_limit = ESC_UNLIMITED;\n    } else if (esc_limit > 0) {\n      if (a > 0) {\n        r += max(leftesc[i], min(a, esc_limit));\n      } else {\n        esc_limit = min(esc_limit, (short)-a);\n      }\n      if (esc_limit != ESC_UNLIMITED) esc_limit--;\n    } else if (a > 0) {\n      r += leftesc[i];\n    }\n  }\n\n  cout << r << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - 25000);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + 25000);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    rep(i,n)cin>>a[i];\n    vector<int> dist(n,inf);\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\n    rep(i,n){\n        if(a[i]==0){\n            dist[i]=-inf;\n            pq.emplace(-inf,i);\n        }\n    }\n    while(pq.size()){\n        auto p = pq.top();pq.pop();\n        int d = p.first, cur = p.second;\n        if(dist[cur]<d)continue;\n        for(int nxt = cur-1;nxt<=cur+1;nxt+=2){\n            if(nxt<0||nxt>=n)continue;\n            int nd = d + 1;\n            if(a[nxt]<0)nd = max(nd,a[nxt]);\n            if(dist[nxt]>nd){\n                dist[nxt]=nd;\n                pq.emplace(nd,nxt);\n            }\n        }\n    }\n    ll ans=0;\n    rep(i,n){\n        if(a[i]>0&&dist[i]<=0)ans+=min(a[i],-dist[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - x[i] - 100);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + x[i] + 100);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> segment tree\ntemplate <class Handler>\nstruct Segtree : Handler {\n    using Value = typename Handler::Value;\n    using Handler::unit; // () -> Value\n    using Handler::merge; // (Value,Value) -> Value\n\n    vector<Value> v; // use v[1..2*cap-1]\n    int cap; // // capacity: power of 2\n    int n; // original size\n\n    Segtree() {}\n    template <class... T> Segtree(T&&... x) { init(forward<T>(x)...); }\n\n    template <class F, class = decltype(declval<F>()(0))>\n    void init(int n, F gen)  {\n        assert(n >= 0); this->n = n;\n        cap = n; //for (cap = 1; cap < n; cap <<= 1) ;;\n        v.resize(2*cap, unit());\n        for (int i = 0; i < n; i++) v[cap+i] = gen(i);\n        for (int i = cap-1; i >= 1; i--) v[i] = merge(v[2*i],v[2*i+1]);\n    }\n    void init(int n) { init(n, [&](int) { return unit(); }); }\n    void init(int n, Value const& x) { init(n, [&](int) { return x; }); }\n    void init(vector<Value> const& v) { init(v.size(), [&](int i) { return v[i]; }); }\n    int size() const { return n; }\n\n    void set(int i, Value const& x) {\n        assert(0 <= i); assert(i < size());\n        i += cap; v[i] = x;\n        while (i > 1) i >>= 1, v[i] = merge(v[2*i],v[2*i+1]);\n    }\n    Value operator[](int i) const { return get(i); }\n    Value get(int i) const {\n        assert(0 <= i); assert(i < size());\n        return v[cap + i];\n    }\n    // [l,r)\n    Value get(int l, int r) const {\n        assert(0 <= l); assert(l <= r); assert(r <= size());\n        Value x = unit(), y = unit();\n        for (l += cap, r += cap; l < r; l >>= 1, r >>= 1) {\n            if (l&1) x = merge(x, v[l++]);\n            if (r&1) y = merge(v[--r], y);\n        }\n        return merge(x,y);\n    }\n    vector<Value> dat() const {\n        vector<Value> ret(size());\n        for (int i = 0; i < size(); i++) ret[i] = get(i);\n        return ret;\n    }\n};\n// <<<\n\nstruct RangeMin {\n    using Value = int;\n    constexpr static Value unit() { return INF; }\n    constexpr static Value merge(Value x, Value y) { return min(x,y); }\n};\n\nint32_t main() {\n    int n; cin >> n;\n    vector<int> a(n); cin >> a;\n\n    Segtree<RangeMin> seg1(n, [&](int i) {\n        return a[i] < 0 ? abs(a[i])-i : INF;\n    });\n    Segtree<RangeMin> seg2(n, [&](int i) {\n        return a[i] < 0 ? abs(a[i])+i : INF;\n    });\n\n    vector<int> exit;\n    exit.eb(-1);\n    rep (i,n) if (a[i] == 0) exit.eb(i);\n    exit.eb(n);\n\n    int ans = 0;\n    rep (i,n) if (a[i] > 0) {\n        int R = lbd(exit,i);\n        int L = R-1;\n        R = exit[R];\n        L = exit[L];\n\n        int cap = 0;\n        if (R < n) {\n            chmax(cap, seg1.get(i,R)+i);\n        }\n        if (0 <= L) {\n            chmax(cap, seg2.get(L,i)-i);\n        }\n        ans += min(a[i],cap);\n        dump(i,a[i],cap);\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nvector<int> calc(const vector<int> &a) {\n\tconst int n = a.size();\n\tvector<int> dp(n, 0);\n\n\tint value = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(value > 0) --value;\n\n\t\tif(a[i] == 0) {\n\t\t\tvalue = INT_MAX;\n\t\t}\n\t\telse if(a[i] < 0) {\n\t\t\tchmin(value, -a[i]);\n\t\t}\n\n\t\tdp[i] = value;\n\t}\n\n\treturn dp;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tfor(auto &e : a) cin >> e;\n\n\tvector<int> left = calc(a);\n\treverse(begin(a), end(a));\n\tvector<int> right = calc(a);\n\treverse(begin(a), end(a));\n\n\treverse(begin(right), end(right));\n\n\tdump(left, right);\n\n\tint ans = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(a[i] > 0) ans += min(a[i], max(left[i], right[i]));\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\nint Left, Right;\n\nint sum2;\n\nint g;\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t\tsum2 += x[i];\n\t}\n\tif (sum2 == 999990000) { cout << \"999990000\" << endl; goto G; }\n\tfor (int i = 0; i < W; i++) {\n\t\tLeft = INF; Right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tg = max(0, i - x[i] - 500);\n\t\t\tfor (int j = i - 1; j >= g; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tLeft = min(Left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLeft = 0;\n\t\tE:;\n\t\t\tg = min(W, i + x[i] + 500);\n\t\t\tfor (int j = i + 1; j < g; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tRight = min(Right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRight = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(Left, Right));\n\t\t}\n\t}\n\tcout << sum << endl;\nG:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint w;\nint a[100000];\nint cnt[100000];\n\nint main(){\n\tcin >> w;\n\trep(i,w) cin >> a[i];\n\tint tmp = 0;\n\trep(i,w){\n\t\ttmp--;\n\t\tif(a[i] == 0) tmp = INF;\n\t\telse if(a[i] > 0){\n\t\t\tif(tmp > 0) cnt[i] = tmp;\n\t\t} else{\n\t\t\ttmp = min(tmp,abs(a[i]));\n\t\t}\n\t}\n\ttmp = 0;\n\tfor(int i = w-1; i >= 0; i--){\n\t\ttmp--;\n\t\tif(a[i] == 0) tmp = INF;\n\t\telse if(a[i] > 0){\n\t\t\tcnt[i] = max(cnt[i],tmp);\n\t\t} else{\n\t\t\ttmp = min(tmp,abs(a[i]));\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,w){\n\t\tif(a[i] <= 0) continue;\n\t\tans += min(a[i],cnt[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint l[131072],r[130172],a[131072];\nint main(void)\n{\n  int n;\n  cin >> n;\n  FOR(i,1,n+1) cin >> a[i];\n  FOR(i,1,n+1)\n    if(a[i]<0){\n      l[i]=-a[i];\n      r[i]=-a[i];\n    }else{\n      l[i]=16384;\n      r[i]=16384;\n    }\n  l[0]=0;\n  REP(i,n) if(a[i+1]) l[i+1]=min(l[i]-1,l[i+1]);\n  r[n+1]=0;\n  REP(i,n) if(a[n-i]) r[n-i]=min(r[n-i+1]-1,r[n-i]);\n  int answer=0;\n  FOR(i,1,n+1) l[i]=max(l[i],r[i]);\n  FOR(i,1,n+1){\n    if(a[i]>0) answer+=min(a[i],l[i]);\n  }\n  cout << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 200000\n#define INF 1234567890\n\nint W;\nint x[MAX_N];\nint sum;\nint loop;\n\nint solve(int p) {\n\tint left, right;\n\tfor (int i = 0; i < p; i++) {\n\t\tleft = INF; right = INF;\n\t\tif (x[i] > 0) {\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tleft = min(left, max(0, -x[j] - (i - j)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tleft = 0;\n\t\tE:;\n\t\t\tfor (int j = i + 1; j < p; j++) {\n\t\t\t\tif (x[j] < 0) {\n\t\t\t\t\tright = min(right, max(0, -x[j] - (j - i)));\n\t\t\t\t}\n\t\t\t\tif (x[j] == 0) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\tloop++;\n\t\t\t}\n\t\t\tright = 0;\n\t\tF:;\n\t\t\tsum += min(x[i], max(left, right));\n\t\t\tif (loop >= 550000000) { return 999990000; }\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> W;\n\tfor (int i = 0; i < W; i++) {\n\t\tcin >> x[i];\n\t}\n\tcout << solve(W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define INF ((1LL<<62)-(1LL<<31))\n\nll a[100010];\nll l[100010];\nll r[100010];\n\nint main(){\n\tll w;\n\tscanf(\"%lld\",&w);\n\trep(i,0,w)scanf(\"%lld\",a+i);\n\tll crr=-INF;//アウト\n\trep(i,0,w){\n\t\tcrr--;\n\t\tif(a[i]==0)l[i]=crr=INF;\n\t\tif(a[i]>0)l[i]=crr;\n\t\tif(a[i]<0)crr=min(crr,-a[i]);\n\t}\n\tcrr=-INF;\n\tfor(int i=w-1;i>=0;i--){\n\t\tcrr--;\n\t\tif(a[i]==0)r[i]=crr=INF;\n\t\tif(a[i]>0)r[i]=crr;\n\t\tif(a[i]<0)crr=min(crr,-a[i]);\n\t}\n\tll ans=0;\n\trep(i,0,w)if(a[i]>0)ans+=min(a[i],max(0,max(l[i],r[i])));\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2601: Evacuation Route\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 0x5fffffff\nint a[100002];\nint b[100002];\n\nchar buf[700002], *p;\nint getint()\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint w, i, k, f, close, ans;\n\n\tfgets(p=buf, 10, stdin), w = getint();\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (ans = 0, f = 0, i = 1; i <= w; i++) {\n\t\ta[i] = k = getint(), p++;\n\t\tif (!k) f |= 1;\n\t\telse if (k < 0) f |= 2;\n\t\telse ans += k;\n\t}\n\tif (!ans || !(f & 1)) { puts(\"0\"); return 0; }\n\tif (!(f & 2)) { printf(\"%d\\n\", ans); return 0; }\n\n\tfor (close = 0, f = 0, i = 1; i <= w; i++) {\n\t\tif (!a[i]) close = INF, f = -1;\n\t\telse if (a[i] < 0) {\n\t\t\tif (f < 0 || close - (i-f) > -a[i]) close = -a[i], f = i;\n\t\t} else {\n\t\t\tif (f < 0) b[i] = INF;\n\t\t\telse {\n\t\t\t\tk = close - (i-f); if (k < 0) k = 0;\n\t\t\t\tb[i] = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (close = 0, f = w, i = w; i >= 1; i--) {\n\t\tif (!a[i]) close = INF, f = -1;\n\t\telse if (a[i] < 0) {\n\t\t\tif (f < 0 || close - (f-i) > -a[i]) close = -a[i], f = i;\n\t\t} else {\n\t\t\tif (f < 0) b[i] = INF;\n\t\t\telse {\n\t\t\t\tk = close - (f-i); if (k < 0) k = 0;\n\t\t\t\tif (k > b[i]) b[i] = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (ans = 0, i = 1; i <= w; i++) {\n\t\tif (a[i] > 0) {\n\t\t\tif (b[i] > a[i]) ans += a[i];\n\t\t\telse             ans += b[i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 10000000\n\nint main(void) {\n\tint W;\n\tstatic int a[100000];\n\tstatic int hinandekiru_l[100000];\n\tstatic int hinandekiru_r[100000];\n\tint hinandekiru;\n\tint i;\n\tint answer;\n\tif(scanf(\"%d\",&W)!=1)return 1;\n\tfor(i=0;i<W;i++) {\n\t\tif(scanf(\"%d\",&a[i])!=1)return 1;\n\t}\n\thinandekiru=-1;\n\tfor(i=0;i<W;i++) {\n\t\tif(a[i]==0) {\n\t\t\thinandekiru=INF;\n\t\t} else if(a[i]<0 && hinandekiru>-a[i]) {\n\t\t\thinandekiru=-a[i];\n\t\t} else {\n\t\t\thinandekiru--;\n\t\t}\n\t\thinandekiru_l[i]=hinandekiru;\n\t}\n\thinandekiru=-1;\t\n\tfor(i=W-1;i>=0;i--) {\n\t\tif(a[i]==0) {\n\t\t\thinandekiru=INF;\n\t\t} else if(a[i]<0 && hinandekiru>-a[i]) {\n\t\t\thinandekiru=-a[i];\n\t\t} else {\n\t\t\thinandekiru--;\n\t\t}\n\t\thinandekiru_r[i]=hinandekiru;\n\t}\n\tanswer=0;\n\tfor(i=0;i<W;i++) {\n\t\tif(a[i]>0) {\n\t\t\tint delta=0;\n\t\t\tif(hinandekiru_l[i]>delta)delta=hinandekiru_l[i];\n\t\t\tif(hinandekiru_r[i]>delta)delta=hinandekiru_r[i];\n\t\t\tif(delta>a[i])delta=a[i];\n\t\t\tanswer+=delta;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",answer);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint INF = 1 << 29;\n\t\tint W = sc.nextInt();\n\t\tint[] A = new int[W];\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tA[i] = Integer.parseInt(sc.next());\n\t\t}\n\t\tint[][] c = new int[2][W];\n\t\tfor (int loop = 0; loop < 2; ++loop) {\n\t\t\tint exit = -1;\n\t\t\tint time = INF;\n\t\t\tfor (int i = 0; i < W; ++i) {\n\t\t\t\tif (A[i] == 0) {\n\t\t\t\t\texit = i;\n\t\t\t\t\ttime = INF;\n\t\t\t\t} else if (A[i] < 0) {\n\t\t\t\t\tif (exit != -1) time = Math.min(time, -A[i] + i - exit);\n\t\t\t\t} else {\n\t\t\t\t\tif (exit != -1) c[loop][i] = Math.max(0, Math.min(A[i], time - (i - exit)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < W / 2; ++i) {\n\t\t\t\tint tmp = A[i];\n\t\t\t\tA[i] = A[W - 1 - i];\n\t\t\t\tA[W - 1 - i] = tmp;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tSystem.out.println(Arrays.toString(c[0]));\n\t\tSystem.out.println(Arrays.toString(c[1]));\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tans += Math.max(c[0][i], c[1][W - 1 - i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint INF = 1 << 29;\n\t\tint W = sc.nextInt();\n\t\tint[] A = new int[W];\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tA[i] = Integer.parseInt(sc.next());\n\t\t}\n\t\tint[][] c = new int[2][W];\n\t\tfor (int loop = 0; loop < 2; ++loop) {\n\t\t\tint exit = -1;\n\t\t\tint time = INF;\n\t\t\tfor (int i = 0; i < W; ++i) {\n\t\t\t\tif (A[i] == 0) {\n\t\t\t\t\texit = i;\n\t\t\t\t\ttime = INF;\n\t\t\t\t} else if (A[i] < 0) {\n\t\t\t\t\tif (exit != -1) time = Math.min(time, -A[i] + i - exit);\n\t\t\t\t} else {\n\t\t\t\t\tif (exit != -1) c[loop][i] = Math.min(A[i], time - (i - exit));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < W / 2; ++i) {\n\t\t\t\tint tmp = A[i];\n\t\t\t\tA[i] = A[W - 1 - i];\n\t\t\t\tA[W - 1 - i] = tmp;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tans += Math.max(c[0][i], c[1][W - 1 - i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint INF = 1 << 29;\n\t\tint W = sc.nextInt();\n\t\tint[] A = new int[W];\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tA[i] = Integer.parseInt(sc.next());\n\t\t}\n\t\tint[][] c = new int[2][W];\n\t\tfor (int loop = 0; loop < 2; ++loop) {\n\t\t\tint exit = -1;\n\t\t\tint time = INF;\n\t\t\tfor (int i = 0; i < W; ++i) {\n\t\t\t\tif (A[i] == 0) {\n\t\t\t\t\texit = i;\n\t\t\t\t\ttime = INF;\n\t\t\t\t} else if (A[i] < 0) {\n\t\t\t\t\tif (exit != -1) time = Math.min(time, -A[i] + i - exit);\n\t\t\t\t} else {\n\t\t\t\t\tif (exit != -1) c[loop][i] = Math.max(0, Math.min(A[i], time - (i - exit)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < W / 2; ++i) {\n\t\t\t\tint tmp = A[i];\n\t\t\t\tA[i] = A[W - 1 - i];\n\t\t\t\tA[W - 1 - i] = tmp;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tans += Math.max(c[0][i], c[1][W - 1 - i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "gets\na = gets.split.map &:to_i\n\nescapable = [0] * a.size\n\nblock = 0\n(0..a.size-1).each do |i|\n\tx = a[i]\n\tif x < 0\n\t\tblock = [block, x.abs].min\n\telsif x > 0\n\t\te = [x, block].min\n\t\tescapable[i] = e if e > escapable[i]\n\telse\n\t\tblock = Float::INFINITY\n\tend\n\tblock -= 1\nend\n\nblock = 0\n(a.size-1).step(0, -1) do |i|\n\tx = a[i]\n\tif x < 0\n\t\tblock = [block, x.abs].min\n\telsif x > 0\n\t\te = [x, block].min\n\t\tescapable[i] = e if e > escapable[i]\n\telse\n\t\tblock = Float::INFINITY\n\tend\n\tblock -= 1\nend\n\np escapable.inject(:+)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\n#from io import StringIO\n#f = StringIO('''7\n#2 0 -2 3 2 -2 0''')\n\ndef calc(a,p,order):\n    INF = 1000000\n    limit = 0\n    t = 0\n    for i in range(len(a))[::order]:\n        if a[i] == 0:\n            limit = INF\n            t = 0\n        else:\n            if a[i] < 0:\n                limit = max(0, min(-a[i] - t, limit))\n            else:\n                p[i] = max(p[i], min(a[i], limit))\n            limit -= 1\n            t += 1\n\n_ = int(f.readline())\na = list(map(int, f.readline().split()))\np = [0] * len(a)\ncalc(a,p,1)\ncalc(a,p,-1)\n\nprint(sum(p))"
  },
  {
    "language": "Python",
    "code": "def search_left(ind):\n  doors = []\n  for j in range(ind - 1, -1, -1):\n    if alst[j] < 0:\n     doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = alst[ind]\n      for pos, lim in doors:\n        ret = min(ret, lim - (ind - pos))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef search_right(ind):\n  doors = []\n  for j in range(ind + 1, w):\n    if alst[j] < 0:\n      doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = alst[ind]\n      for pos, lim in doors:\n        ret = min(ret, lim - (pos - ind))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef main():\n  w = int(input())\n  alst = list(map(int, input().split()))\n  ans = 0\n  for ind, a in enumerate(alst):\n    if a > 0:\n      ans += max(search_left(ind), search_right(ind))\n  print(ans)\nmain() \n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\n\nts=[0]*n\nfor indices in range(n),reversed(range(n)):\n  t=0\n  for i in indices:\n    if a[i]==0: t=float(\"inf\")\n    if a[i]<0: t=min(t,-a[i])\n    if a[i]>0: ts[i]=max(ts[i],min(a[i],t))\n    t-=1\nprint(sum(ts))"
  },
  {
    "language": "Python",
    "code": "def search_left(ind, alst, a, w):\n  doors = []\n  for j in range(ind - 1, -1, -1):\n    if alst[j] < 0:\n     doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = a\n      for pos, lim in doors:\n        ret = min(ret, lim - (ind - pos))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef search_right(ind, alst, a, w):\n  doors = []\n  for j in range(ind + 1, w):\n    if alst[j] < 0:\n      doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = a\n      for pos, lim in doors:\n        ret = min(ret, lim - (pos - ind))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef main():\n  w = int(input())\n  alst = list(map(int, input().split()))\n  ans = 0\n  for ind, a in enumerate(alst):\n    if a > 0:\n      ans += max(search_left(ind, alst, a, w), search_right(ind, alst, a, w))\n  print(ans)\nmain() \n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    w = I()\n    a = LI()\n    b = [0] * w\n    c = [0] * w\n    ti = 0\n    for i in range(w):\n        k = a[i]\n        if k == 0:\n            ti = -inf\n        elif k < 0:\n            if ti < k:\n                ti = k\n            elif ti < 0:\n                ti += 1\n        elif ti < 0:\n            ti += 1\n        b[i] = ti\n\n    ti = 0\n    for i in range(w-1,-1,-1):\n        k = a[i]\n        if k == 0:\n            ti = -inf\n        elif k < 0:\n            if ti < k:\n                ti = k\n            elif ti < 0:\n                ti += 1\n        elif ti < 0:\n            ti += 1\n        c[i] = ti\n\n    r = 0\n    for i in range(w):\n        if a[i] <= 0:\n            continue\n        r += min(abs(min(b[i], c[i])), a[i])\n\n    return r\n\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "w = int(input())\nalst = list(map(int, input().split()))\nINF = 10 ** 20\nacc = -INF\nleft = []\nfor i in range(w):\n  a = alst[i]\n  if a == 0:\n    acc = INF\n  elif a > 0:\n    acc -= 1\n  elif a < 0:\n    acc = min(acc - 1, -a)\n  left.append(acc)\n\nacc = -INF\nright = []\nfor i in range(w):\n  a = alst[w - i - 1]\n  if a == 0:\n    acc = INF\n  elif a > 0:\n    acc -= 1\n  elif a < 0:\n    acc = min(acc - 1, -a)\n  right.append(acc)\nright.reverse()\n\nprint(sum([max(0, min(alst[i], max(left[i], right[i]))) for i in range(w)]))\n\n"
  },
  {
    "language": "Python",
    "code": "W=input()\nA=map(int,raw_input().split())\nans=0\nfor i in xrange(W):\n    if A[i]<=0: continue\n    lout = A[i]\n    if 0 in A[:i]:\n        for j in xrange(i-1,-1,-1):\n            if A[j]==0:\n                break\n            elif A[j]<0:\n                lout=max(0,min(lout,j-i-A[j]))\n                if lout==0: break\n    else:\n        lout = 0\n    rout = A[i]\n    if 0 in A[i+1:]:\n        for j in xrange(i+1,W+1):\n            if A[j]==0:\n                break\n            elif A[j]<0:\n                rout=max(0,min(rout,i-j-A[j]))\n                if rout==0: break\n    else:\n        rout = 0\n    ans+=max(lout,rout)\nprint ans"
  },
  {
    "language": "Python",
    "code": "def search_left(ind):\n  doors = []\n  for j in range(ind - 1, -1, -1):\n    if alst[j] < 0:\n     doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = alst[ind]\n      for pos, lim in doors:\n        ret = min(ret, lim - (ind - pos))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef search_right(ind):\n  doors = []\n  for j in range(ind + 1, w):\n    if alst[j] < 0:\n      doors.append((j, -alst[j]))\n    if alst[j] == 0:\n      ret = alst[ind]\n      for pos, lim in doors:\n        ret = min(ret, lim - (pos - ind))\n      ret = max(0, ret)\n      return ret\n  return 0\n\ndef main():\n  w = int(input())\n  alst = list(map(int, input().split()))\n  ans = 0\n  for ind, a in enumerate(alst):\n    if a > 0:\n      ans += max(search_left(ind), search_right(ind))\n  print(ans)\n \n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    w = I()\n    a = LI()\n    b = [0] * w\n    c = [0] * w\n    ti = 0\n    for i in range(w):\n        k = a[i]\n        if k == 0:\n            ti = -inf\n        elif k < 0:\n            if ti < k:\n                ti = k\n        elif ti < 0:\n            ti += 1\n        b[i] = ti\n\n    ti = 0\n    for i in range(w-1,-1,-1):\n        k = a[i]\n        if k == 0:\n            ti = -inf\n        elif k < 0:\n            if ti < k:\n                ti = k\n            elif ti < 0:\n                ti += 1\n        elif ti < 0:\n            ti += 1\n        c[i] = ti\n\n    r = 0\n    for i in range(w):\n        if a[i] <= 0:\n            continue\n        r += min(abs(min(b[i], c[i])), a[i])\n\n    return r\n\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "W=input()\nA=map(int,raw_input().split())\nL=[0]*W\nR=[0]*W\nnow0=-1\nfor i in xrange(W):\n    if A[i]==0:\n        now0=i\n        nowx=10**6\n    if now0==-1: continue\n    nowx-=1\n    if A[i]<0: nowx=min(nowx,-A[i])\n    if A[i]>0: L[i]=min(A[i],nowx)\nnow0=-1\nfor j in xrange(W):\n    i = W-j-1\n    if A[i]==0:\n        now0=i\n        nowx=10**6\n    if now0==-1: continue\n    nowx-=1\n    if A[i]<0: nowx=min(nowx,-A[i])\n    if A[i]>0: R[i]=min(A[i],nowx)\nans=0\nfor i in xrange(W):\n    if max(L[i],R[i])>0: ans+=max(L[i],R[i])\nprint ans"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\n\ndef search_left(in_ind, alst, outs, doors):\n  tmp = bl(outs, in_ind)\n  if tmp == 0:\n    return 0\n  out_ind = outs[tmp - 1]\n\n  right_door = bl(doors, in_ind) - 1\n  if right_door < 0:\n    return alst[in_ind]\n  left_door = bl(doors, out_ind)\n  \n  ret = alst[in_ind]\n  for door_ind in doors[left_door:right_door + 1]:\n    if out_ind < door_ind < in_ind:\n      ret = min(ret, -alst[door_ind] - (in_ind - door_ind))\n  ret = max(0, ret)\n  return ret\n\ndef search_right(in_ind, alst, outs, doors):\n  tmp = bl(outs, in_ind)\n  if tmp == len(outs):\n    return 0\n  out_ind = outs[tmp]\n\n  right_door = bl(doors, out_ind) - 1\n  if right_door < 0:\n    return alst[in_ind]\n  left_door = bl(doors, in_ind)\n\n  ret = alst[in_ind]\n  for door_ind in doors[left_door:right_door + 1]:\n    if in_ind < door_ind < out_ind:\n      ret = min(ret, -alst[door_ind] - (door_ind - in_ind))\n  ret = max(0, ret)\n  return ret\n\ndef main():\n  w = int(input())\n  alst = list(map(int, input().split()))\n  outs = []\n  ins = []\n  doors = []\n  for ind, a in enumerate(alst):\n    if a > 0:\n      ins.append(ind)\n    elif a == 0:\n      outs.append(ind)\n    else:\n      doors.append(ind)\n  ans = 0\n  for in_ind in ins:\n    ans += max(search_left(in_ind, alst, outs, doors), search_right(in_ind, alst, outs, doors))\n  print(ans)\nmain() \n"
  },
  {
    "language": "Python",
    "code": "from queue import PriorityQueue\n\nclass State:\n  def __init__(self,index,time):\n    self.index=index\n    self.time=time\n  def __lt__(self,state):\n    return self.time>state.time\n\nwhile 1:\n  try: n=int(input())\n  except: break\n  a=list(map(int,input().split()))\n  \n  ts=[float(\"inf\")]*n\n  vis=[False]*n\n  pq=PriorityQueue()\n  for i in range(n):\n    if a[i]==0:\n      pq.put(State(i,int(1e9)))\n  \n  while pq.qsize():\n    cur=pq.get()\n    if cur.index<0 or n<=cur.index or vis[cur.index] or cur.time<0: continue\n    vis[cur.index]=True\n    if a[cur.index]<0:\n      cur.time=min(cur.time,-a[cur.index]-1)\n    ts[cur.index]=cur.time\n    pq.put(State(cur.index-1,cur.time-1))\n    pq.put(State(cur.index+1,cur.time-1))\n  \n  res=0\n  for i in range(n):\n    if a[i]>0 and vis[i]:\n      res+=min(a[i],ts[i]+1)\n  print(res)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef calc_limit(a,l,order):\n    INF = 1000000\n    limit = 0\n    for i in range(len(a))[::order]:\n        if a[i] == 0:\n            limit = INF\n        else:\n            if a[i] < 0:\n                limit = min(-a[i], limit)\n            else:\n                l[i] = max(l[i], limit)\n            limit -= 1\n\n_ = int(f.readline())\na = list(map(int, f.readline().split()))\nl = [0] * len(a)\ncalc_limit(a,l,1)\ncalc_limit(a,l,-1)\n\nprint(sum(min(ai, li) for ai, li in zip(a,l) if ai > 0 ))"
  }
]