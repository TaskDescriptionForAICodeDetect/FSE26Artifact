[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int a, b;\n} Pair;\n\nint compareSum(const void* a, const void* b) {\n    Pair* p1 = (Pair*)a;\n    Pair* p2 = (Pair*)b;\n    return (p1->a + p1->b) - (p2->a + p2->b);\n}\n\nint solve(Pair* pairs, int N, int A, int B) {\n    int operations = 0;\n    bool* removed = calloc(N, sizeof(bool));\n\n    qsort(pairs, N, sizeof(Pair), compareSum);\n\n    for (int i = 0; i < N; i++) {\n        if (removed[i]) continue;\n\n        for (int j = i + 1; j < N; j++) {\n            if (removed[j]) continue;\n\n            int diff_sum = abs((pairs[i].a + pairs[i].b) - (pairs[j].a + pairs[j].b));\n            int diff_elements = abs(pairs[i].a - pairs[j].a) + abs(pairs[i].b - pairs[j].b);\n\n            if ((diff_sum <= A) || \n                (B <= diff_elements && diff_elements <= 2 * A)) {\n                removed[i] = true;\n                removed[j] = true;\n                operations++;\n                break;\n            }\n        }\n\n        if (!removed[i]) {\n            int diff = abs(pairs[i].a - pairs[i].b);\n            if (diff <= A || B <= diff) {\n                removed[i] = true;\n                operations++;\n            }\n        }\n    }\n\n    free(removed);\n    return operations;\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    Pair* pairs = malloc(N * sizeof(Pair));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &pairs[i].a, &pairs[i].b);\n    }\n\n    int result = solve(pairs, N, A, B);\n    printf(\"%d\\n\", result);\n\n    free(pairs);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int a;\n    int b;\n} Pair;\n\nPair pairs[MAX_N];\nbool removed[MAX_N];\nint N, A, B;\n\nbool can_remove_single(int i) {\n    int diff = abs(pairs[i].a - pairs[i].b);\n    return (diff <= A) || (B <= diff && diff <= 2 * A);\n}\n\nbool can_remove_pair(int i, int j) {\n    int sum_i = pairs[i].a + pairs[i].b;\n    int sum_j = pairs[j].a + pairs[j].b;\n    int diff = abs(sum_i - sum_j);\n    return (diff <= A) || (B <= diff && diff <= 2 * A);\n}\n\nint max_operations() {\n    int operations = 0;\n    for (int i = 0; i < N; i++) {\n        removed[i] = false;\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!removed[i] && can_remove_single(i)) {\n            removed[i] = true;\n            operations++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (removed[i]) continue;\n        for (int j = i + 1; j < N; j++) {\n            if (removed[j]) continue;\n            if (can_remove_pair(i, j)) {\n                removed[i] = true;\n                removed[j] = true;\n                operations++;\n                break;\n            }\n        }\n    }\n\n    return operations;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &A, &B);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &pairs[i].a, &pairs[i].b);\n    }\n    printf(\"%d\\n\", max_operations());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxOperations(vector<pair<int, int>>& pairs, int A, int B) {\n    int operations = 0;\n    vector<bool> used(pairs.size(), false);\n\n    for (int i = 0; i < pairs.size(); ++i) {\n        if (used[i]) continue;\n        int a_i = pairs[i].first;\n        int b_i = pairs[i].second;\n        int diff = abs(a_i - b_i);\n        if ((diff <= A) || (B <= diff && diff <= 2 * A)) {\n            used[i] = true;\n            operations++;\n            continue;\n        }\n        for (int j = i + 1; j < pairs.size(); ++j) {\n            if (used[j]) continue;\n            int a_j = pairs[j].first;\n            int b_j = pairs[j].second;\n            int sum_i = a_i + b_i;\n            int sum_j = a_j + b_j;\n            int sum_diff = abs(sum_i - sum_j);\n            if ((sum_diff <= A) || (B <= sum_diff && sum_diff <= 2 * A)) {\n                used[i] = true;\n                used[j] = true;\n                operations++;\n                break;\n            }\n        }\n    }\n    return operations;\n}\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<pair<int, int>> pairs(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> pairs[i].first >> pairs[i].second;\n    }\n    cout << maxOperations(pairs, A, B) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int maxOperations(int[] a, int[] b, int A, int B) {\n        int n = a.length;\n        boolean[] removed = new boolean[n];\n        int operations = 0;\n\n        while (true) {\n            boolean operationPerformed = false;\n\n            // Check for single elements\n            for (int i = 0; i < n; i++) {\n                if (!removed[i]) {\n                    int diff = Math.abs(a[i] - b[i]);\n                    if (diff <= A || (B <= diff && diff <= 2 * A)) {\n                        removed[i] = true;\n                        operations++;\n                        operationPerformed = true;\n                    }\n                }\n            }\n\n            // Check for pairs\n            for (int i = 0; i < n; i++) {\n                if (removed[i]) continue;\n                for (int j = i + 1; j < n; j++) {\n                    if (removed[j]) continue;\n                    int sumI = a[i] + b[i];\n                    int sumJ = a[j] + b[j];\n                    int diff = Math.abs(sumI - sumJ);\n                    if (diff <= A || (B <= diff && diff <= 2 * A)) {\n                        removed[i] = true;\n                        removed[j] = true;\n                        operations++;\n                        operationPerformed = true;\n                        break;\n                    }\n                }\n                if (operationPerformed) break;\n            }\n\n            if (!operationPerformed) break;\n        }\n\n        return operations;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n            b[i] = scanner.nextInt();\n        }\n        System.out.println(maxOperations(a, b, A, B));\n    }\n}",
    "timestamp": "2025-08-05 22:08:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxOperations(int[][] pairs, int A, int B) {\n        int n = pairs.length;\n        int operations = 0;\n        boolean[] removed = new boolean[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (removed[i]) continue;\n            \n            for (int j = i + 1; j < n; j++) {\n                if (removed[j]) continue;\n                \n                int diff1 = Math.abs(pairs[i][0] - pairs[i][1]);\n                int diff2 = Math.abs(pairs[j][0] - pairs[j][1]);\n                int sumDiff = Math.abs((pairs[i][0] + pairs[i][1]) - (pairs[j][0] + pairs[j][1]));\n                \n                if ((diff1 <= A || diff1 <= B) && \n                    (diff2 <= A || diff2 <= B) && \n                    (sumDiff <= A || (B <= sumDiff && sumDiff <= 2 * A))) {\n                    removed[i] = true;\n                    removed[j] = true;\n                    operations++;\n                    break;\n                }\n            }\n        }\n        \n        return operations;\n    }\n}",
    "timestamp": "2025-08-05 22:08:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxOperations(vector<pair<int, int>>& pairs, int A, int B) {\n        int n = pairs.size();\n        int operations = 0;\n        vector<bool> used(n, false);\n        \n        // Try removing individual pairs\n        for (int i = 0; i < n; i++) {\n            if (used[i]) continue;\n            \n            if (abs(pairs[i].first - pairs[i].second) <= A || \n                (B <= abs(pairs[i].first - pairs[i].second) && \n                 abs(pairs[i].first - pairs[i].second) <= 2 * A)) {\n                used[i] = true;\n                operations++;\n            }\n        }\n        \n        // Try removing pairs of elements\n        for (int i = 0; i < n; i++) {\n            if (used[i]) continue;\n            \n            for (int j = i + 1; j < n; j++) {\n                if (used[j]) continue;\n                \n                int sum1 = pairs[i].first + pairs[i].second;\n                int sum2 = pairs[j].first + pairs[j].second;\n                \n                if (abs(sum1 - sum2) <= A || \n                    (B <= abs(sum1 - sum2) && \n                     abs(sum1 - sum2) <= 2 * A)) {\n                    used[i] = true;\n                    used[j] = true;\n                    operations++;\n                    break;\n                }\n            }\n        }\n        \n        return operations;\n    }\n};",
    "timestamp": "2025-08-05 22:08:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_operations(pairs, A, B):\n    import itertools\n\n    def can_remove(pair):\n        a_i, b_i = pair\n        diff = abs(a_i - b_i)\n        return diff <= A or (B <= diff <= 2 * A)\n\n    def can_remove_two(pair1, pair2):\n        a_i, b_i = pair1\n        a_j, b_j = pair2\n        sum_i = a_i + b_i\n        sum_j = a_j + b_j\n        diff = abs(sum_i - sum_j)\n        return diff <= A or (B <= diff <= 2 * A)\n\n    def helper(pairs, used):\n        max_removals = 0\n        n = len(pairs)\n\n        for i in range(n):\n            if not used[i] and can_remove(pairs[i]):\n                used[i] = True\n                max_removals = max(max_removals, 1 + helper(pairs, used))\n                used[i] = False\n        \n        for i, j in itertools.combinations(range(n), 2):\n            if not used[i] and not used[j] and can_remove_two(pairs[i], pairs[j]):\n                used[i] = used[j] = True\n                max_removals = max(max_removals, 2 + helper(pairs, used))\n                used[i] = used[j] = False\n\n        return max_removals\n\n    used = [False] * len(pairs)\n    return helper(pairs, used)\n\n# Example usage:\npairs = [(1, 2), (7, 5), (3, 9), (8, 8)]\nA = 3\nB = 2\nprint(max_operations(pairs, A, B))",
    "timestamp": "2025-08-13 09:02:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxOperations {\n    public static int maxOperations(int[][] pairs, int A, int B) {\n        int n = pairs.length;\n        int operations = 0;\n\n        // Function to calculate difference\n        int diff(int[] pair) {\n            return Math.abs(pair[0] - pair[1]);\n        }\n\n        int sum(int[] pair) {\n            return pair[0] + pair[1];\n        }\n\n        // Try removing individual pairs\n        List<int[]> list = new ArrayList<>();\n        for (int[] pair : pairs) {\n            int difference = diff(pair);\n            if (difference <= A || (B <= difference && difference <= 2 * A)) {\n                operations++;\n            } else {\n                list.add(pair);\n            }\n        }\n\n        // Try removing groups of pairs\n        int m = list.size();\n        boolean[] removed = new boolean[m];\n        for (int i = 0; i < m; i++) {\n            if (removed[i]) continue;\n            for (int j = i + 1; j < m; j++) {\n                if (removed[j]) continue;\n                int sumDiff = Math.abs(sum(list.get(i)) - sum(list.get(j)));\n                if (sumDiff <= A || (B <= sumDiff && sumDiff <= 2 * A)) {\n                    operations += 2;\n                    removed[i] = true;\n                    removed[j] = true;\n                    break;\n                }\n            }\n        }\n\n        return operations;\n    }\n\n    public static void main(String[] args) {\n        int[][] pairs = {{1, 3}, {4, 4}, {5, 7}, {2, 2}};\n        int A = 2;\n        int B = 3;\n        System.out.println(maxOperations(pairs, A, B));  // Output your result here\n    }\n}",
    "timestamp": "2025-08-13 09:02:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int a;\n    int b;\n} Pair;\n\nint customComparator(const void *v1, const void *v2) {\n    const Pair *p1 = (const Pair *)v1;\n    const Pair *p2 = (const Pair *)v2;\n    int diff1 = abs(p1->a - p1->b);\n    int diff2 = abs(p2->a - p2->b);\n    return diff1 - diff2;\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    Pair *pairs = (Pair *)malloc(N * sizeof(Pair));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &pairs[i].a, &pairs[i].b);\n    }\n\n    qsort(pairs, N, sizeof(Pair), customComparator);\n\n    int operations = 0;\n    int *used = (int *)calloc(N, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int diff_i = abs(pairs[i].a - pairs[i].b);\n        if (diff_i <= A || (B <= diff_i && diff_i <= 2 * A)) {\n            operations++;\n            used[i] = 1;\n            continue;\n        }\n\n        for (int j = i + 1; j < N; j++) {\n            if (used[j]) continue;\n            int sum1 = pairs[i].a + pairs[i].b;\n            int sum2 = pairs[j].a + pairs[j].b;\n            int sum_diff = abs(sum1 - sum2);\n\n            if (sum_diff <= A || (B <= sum_diff && sum_diff <= 2 * A)) {\n                operations++;\n                used[i] = used[j] = 1;\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", operations);\n\n    free(pairs);\n    free(used);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:02:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_operations(pairs, A, B):\n    def can_remove(x, y, A, B):\n        diff = abs(x[0] - x[1])\n        return (diff <= A) or (B <= diff <= 2*A)\n    \n    def can_remove_pair(x, y, A, B):\n        diff = abs(x[0] + x[1] - (y[0] + y[1]))\n        return (diff <= A) or (B <= diff <= 2*A)\n    \n    n = len(pairs)\n    operations = 0\n    used = [False] * n\n    \n    # Single pair removals\n    for i in range(n):\n        if not used[i] and can_remove(pairs[i], pairs[i], A, B):\n            used[i] = True\n            operations += 1\n    \n    # Pair removals\n    for i in range(n):\n        if used[i]:\n            continue\n        for j in range(i+1, n):\n            if not used[j] and (can_remove_pair(pairs[i], pairs[j], A, B) or \n                                can_remove(pairs[i], pairs[j], A, B)):\n                used[i] = used[j] = True\n                operations += 1\n                break\n    \n    return operations",
    "timestamp": "2025-08-13 09:03:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_operations(pairs, A, B):\n    operations = 0\n    n = len(pairs)\n    used = [False] * n\n    \n    for i in range(n):\n        if not used[i]:\n            a_i, b_i = pairs[i]\n            diff = abs(a_i - b_i)\n            if diff <= A or (B <= diff <= 2 * A):\n                operations += 1\n                used[i] = True\n            else:\n                for j in range(i + 1, n):\n                    if not used[j]:\n                        a_j, b_j = pairs[j]\n                        sum_i = a_i + b_i\n                        sum_j = a_j + b_j\n                        diff_sum = abs(sum_i - sum_j)\n                        if diff_sum <= A or (B <= diff_sum <= 2 * A):\n                            operations += 1\n                            used[i] = True\n                            used[j] = True\n                            break\n    return operations",
    "timestamp": "2025-08-13 09:03:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nbool canRemovePair(int ai, int bi, int A, int B) {\n    int diff = abs(ai - bi);\n    return diff <= A || (B <= diff && diff <= 2 * A);\n}\n\nbool canRemoveTwoPairs(int ai, int bi, int aj, int bj, int A, int B) {\n    int sum_i = ai + bi;\n    int sum_j = aj + bj;\n    int sum_diff = abs(sum_i - sum_j);\n    return sum_diff <= A || (B <= sum_diff && sum_diff <= 2 * A);\n}\n\nint maxOperations(vector<pair<int, int>>& pairs, int A, int B) {\n    int n = pairs.size();\n    vector<bool> removed(n, false);\n    int operations = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!removed[i] && canRemovePair(pairs[i].first, pairs[i].second, A, B)) {\n            removed[i] = true;\n            operations++;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (!removed[i]) {\n            for (int j = i + 1; j < n; ++j) {\n                if (!removed[j] && canRemoveTwoPairs(pairs[i].first, pairs[i].second, pairs[j].first, pairs[j].second, A, B)) {\n                    removed[i] = true;\n                    removed[j] = true;\n                    operations += 2;\n                    break;\n                }\n            }\n        }\n    }\n\n    return operations;\n}\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<pair<int, int>> pairs(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> pairs[i].first >> pairs[i].second;\n    }\n\n    int result = maxOperations(pairs, A, B);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:15"
  }
]