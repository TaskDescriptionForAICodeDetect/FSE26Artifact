[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.io.StdIn._\n\nobject Main extends App {\n\n  val Array(n, a, b) = readLine.trim.split(' ').map(_.toInt)\n  val pairs = Array.tabulate(n){_ ⇒\n    val Array(a, b) = readLine.trim.split(' ').map(_.toInt)\n    (a, b)\n  }\n  val (removable, rest) = pairs.partition{case (ai, bi) ⇒ math.abs(ai - bi) <= a || (b to 2 * a).contains(math.abs(ai - bi))}\n\n  val (positive, negative) = rest.partition{case (ai, bi) ⇒ ai > bi}\n  println(calMaxFlow(makeNetwork(positive, negative)) + removable.length)\n  def makeNetwork(positive: Array[(Int, Int)], negative: Array[(Int, Int)]): Array[List[Edge]] = {\n    val node = Array.fill(positive.length + negative.length + 2){Nil: List[Edge]}\n    val source = 0\n    val sink = node.length - 1\n    for (i ← positive.indices) {\n      node(source) ::= Edge(i + 1, 1)\n      node(i + 1) ::= Edge(source, 0)\n      node(source).head.pair = node(i + 1).head\n      node(i + 1).head.pair = node(source).head\n      for (j ← negative.indices if math.abs(positive(i)._1 + negative(j)._1 - positive(i)._2 - negative(j)._2) <= a || (b to 2 * a).contains(math.abs(positive(i)._1 + negative(j)._1 - positive(i)._2 - negative(j)._2))) {\n        node(i + 1) ::= Edge(j + positive.length + 1, 1)\n        node(j + positive.length + 1) ::= Edge(i + 1, 0)\n        node(i + 1).head.pair = node(j + positive.length + 1).head\n        node(j + positive.length + 1).head.pair = node(i + 1).head\n      }\n    }\n    for (j ← negative.indices) {\n      node(sink) ::= Edge(j + positive.length + 1, 0)\n      node(j + positive.length + 1) ::= Edge(sink, 1)\n      node(sink).head.pair = node(j + positive.length + 1).head\n      node(j + positive.length + 1).head.pair = node(sink).head\n    }\n    node\n  }\n  def calMaxFlow(nodes: Array[List[Edge]]): Int = {\n    val depth = Array.fill(nodes.length){0}\n    val searching = Array.tabulate(nodes.length)(nodes)\n    def bfs(): Unit = {\n      val queue = mutable.Queue[Int]()\n      for (i ← nodes.indices) {\n        depth(i) = -1\n        searching(i) = nodes(i)\n      }\n      depth(0) = 0\n      queue.enqueue(0)\n      while(queue.nonEmpty) {\n        val current = queue.dequeue()\n        if (current != nodes.length - 1) for (edge ← nodes(current) if edge.flow > 0 && depth(edge.to) == -1) {\n          depth(edge.to) = depth(current) + 1\n          queue.enqueue(edge.to)\n        }\n      }\n    }\n    def dfs(current: Int): Boolean = {\n      if (current == nodes.length - 1) true\n      else {\n        var result = false\n        while (!result && searching(current).nonEmpty) {\n          if (searching(current).head.flow > 0 && depth(current) < depth(searching(current).head.to) && dfs(searching(current).head.to)) {\n            searching(current).head.flow -= 1\n            searching(current).head.pair.flow += 1\n            result = true\n          }\n          searching(current) = searching(current).tail\n        }\n        result\n      }\n    }\n    var flow = 0\n    var hasFlow = true\n    while (hasFlow) {\n      hasFlow = false\n      bfs()\n      while(dfs(0)) {\n        hasFlow = true\n        flow += 1\n      }\n    }\n    flow\n  }\n  case class Edge(to: Int, var flow: Int) {\n    private var mPair = None: Option[Edge]\n    def pair = mPair.get\n    def pair_=(edge: Edge) = mPair = Some(edge)\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<typename T>\nstruct Max_Flow{\n    struct edge{\n        int to; T cap; int rev;\n        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> es;\n    vector<bool> used;\n    const T INF_T;\n\n    Max_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), used.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap, bool directed = true){\n        es[from].eb(to, cap, sz(es[to]));\n        es[to].eb(from, directed? 0 : cap, sz(es[from])-1);\n    }\n\n    T dfs(int now, int t, T flow){\n        if(now == t) return flow;\n        used[now] = true;\n        for(auto &e: es[now]){\n            if(!used[e.to] && e.cap > 0){\n                T f = dfs(e.to, t, min(flow, e.cap));\n                if(f > 0){\n                    e.cap -= f;\n                    es[e.to][e.rev].cap += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t){\n        T flow = 0;\n        for(;;){\n            fill(all(used), false);\n            T f = dfs(s, t, INF_T);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    int N, A, B;\n    cin >> N >> A >> B;\n    int a[N], b[N];\n    bool used[N];\n    fill(used, used+N, false);\n    int ans = 0;\n    rep(i, N){\n        cin >> a[i] >> b[i];\n        a[i] -= b[i];\n        int tmp = abs(a[i]);\n        if(tmp <= A || (B <= tmp && tmp <= 2*A)) ans++, used[i] = true;\n    }\n    Max_Flow<int> G(2*N+2);\n    int s = 2*N, t = 2*N+1;\n    rep(i, N) G.add_edge(s, i, 1), G.add_edge(N+i, t, 1);\n    rep(i, N){\n        if(used[i] || a[i] < 0) continue;\n        rep(j, N){\n            if(used[j]) continue;\n            int tmp = abs(a[i]+a[j]);\n            if(tmp <= A || (B <= tmp && tmp <= 2*A)) G.add_edge(i, N+j, 1);\n        }\n    }\n    cout << ans+G.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(ll v) {\n    used[v] = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        ll u = G[v][i], w = match[u];\n        if (w < 0 || ((used[w] == 0) && dfs(w))) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nll bipartite_matching() {\n    ll res = 0;\n    for (int i = 0; i < (int)match.size();i++)match[i] = -1;\n    for (int v = 0;v < V;v++) {\n        if (match[v] < 0) {\n            for (int i = 0; i < (int)used.size();i++)used[i] = 0;\n            if (dfs(v))res++;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<ll> a(N),b(N);\n    for(int i = 0; i < N;i++) cin >> a[i] >>b[i];\n    \n    vector<int> f(N,0);\n    for(int i = 0; i < N;i++){\n        ll Abs = abs(a[i]-b[i]);\n        if(Abs <= A || (B <= Abs && Abs <= 2*A)){\n            f[i] = -1;\n        }\n    }\n    ll cnt = -accumulate(f.begin(),f.end(),0LL);\n    V = 0;\n    for(int i = 0; i < N;i++){\n        if(f[i] == 0){\n            f[i] = V;\n            V++;\n        }\n    }\n    G.resize(V);\n    match.resize(V);\n    used.resize(V);\n    \n    for(int i = 0; i < N;i++){\n        for(int j = 0; j < N;j++){\n            if(f[i] == -1 || f[j] == -1) continue;\n            ll Absdayo = abs(a[i]+a[j]-b[i]-b[j]);\n            if(Absdayo <= A || (B <= Absdayo && Absdayo <= 2*A )){\n                 add_edge(f[i],f[j]);\n            }\n        }\n    }\n//    cout << cnt << \" \" << bipartite_matching() << endl;\n    cout << cnt + bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n#define each(it,o) for(auto it = (o).begin(); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src_, int dst_, Weight weight_) : src(src_), dst(dst_), weight(weight_) { }\n\tEdge() {};\n};\ntypedef vector<Edge> Edges;\nstruct MaxWeightMatching {\n\tint nEdge, nVertex;\n\tWeight maxWeight;\n\tvi endPoint, mate, label, labelEdge,\n\t\tinBlossom, blossomParent, blossomBase,\n\t\tbestEdge, unusedBlossoms, allowEdge,\n\t\tblossomBestEdgesUsed,\n\t\tsVerteices;\n\tvector<Weight> dualVar;\n\tvector<vi> neighbEnd, blossomChilds, blossomEdges,\n\t\tblossomBestEdges;\n\tEdges edges;\n\tbool maxCardinality;\n\n\tWeight slack(int k) {\n\t\tEdge &e = edges[k];\n\t\treturn dualVar[e.src] + dualVar[e.dst] - 2 * e.weight;\n\t}\n\tstruct BlossomLeaves {\n\t\tint b;\n\t\tMaxWeightMatching *mw;\n\t\tenum { INITAL, END, NEXT, THIRD } state;\n\t\tvi::const_iterator iter, endi;\n\t\tBlossomLeaves *bl;\n\t\tBlossomLeaves(MaxWeightMatching *mw_, int b_) :\n\t\t\tmw(mw_), b(b_), state(INITAL), bl(NULL) {}\n\t\tbool next(int &r) {\n\t\t\tint t;\n\t\t\tswitch (state) {\n\t\t\tcase INITAL:\n\t\t\t\tif (b < mw->nVertex) {\n\t\t\t\t\tr = b;\n\t\t\t\t\tstate = END;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titer = mw->blossomChilds[b].begin();\n\t\t\t\t\tendi = mw->blossomChilds[b].end();\n\t\t\t\t\tstate = NEXT;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\tcase END:\n\t\t\t\treturn false;\n\t\t\tcase NEXT:\n\t\t\t\tif (iter == endi)\n\t\t\t\t\treturn false;\n\t\t\t\tt = *iter;\n\t\t\t\t++iter;\n\t\t\t\tif (t < mw->nVertex) {\n\t\t\t\t\tr = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbl = new BlossomLeaves(mw, t);\n\t\t\t\t\tstate = THIRD;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\tcase THIRD:\n\t\t\t\tif (!bl->next(t)) {\n\t\t\t\t\tstate = NEXT;\n\t\t\t\t\tdelete bl; bl = NULL;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tr = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\tvoid assignLabel(int w, int t, int p) {\n\t\tint b = inBlossom[w];\n\t\tlabel[w] = label[b] = t;\n\t\tlabelEdge[w] = labelEdge[b] = p;\n\t\tbestEdge[w] = bestEdge[b] = -1;\n\t\tif (t == 1) {\n\t\t\tBlossomLeaves bl(this, b);\n\t\t\tfor (int r; bl.next(r); ) sVerteices.push_back(r);\n\t\t}\n\t\telse if (t == 2) {\n\t\t\tint base = blossomBase[b];\n\t\t\tassignLabel(endPoint[mate[base]], 1, mate[base] ^ 1);\n\t\t}\n\t}\n\tint scanBlossom(int v, int w) {\n\t\tvi path;\n\t\tint base = -1;\n\t\twhile (v != -1) {\n\t\t\tint b = inBlossom[v];\n\t\t\tif (label[b] & 4) {\n\t\t\t\tbase = blossomBase[b];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.push_back(b);\n\t\t\tlabel[b] = 5;\n\t\t\tif (labelEdge[b] == -1) {\n\t\t\t\tv = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv = endPoint[labelEdge[b]];\n\t\t\t\tb = inBlossom[v];\n\t\t\t\tv = endPoint[labelEdge[b]];\n\t\t\t}\n\t\t\tif (w != -1)\n\t\t\t\tswap(v, w);\n\t\t}\n\t\teach(it, path)\n\t\t\tlabel[*it] = 1;\n\t\treturn base;\n\t}\n\tvoid addBlossom(int base, int k) {\n\t\tEdge &e = edges[k];\n\t\tint bb = inBlossom[base],\n\t\t\tbv = inBlossom[e.src],\n\t\t\tbw = inBlossom[e.dst];\n\t\tint b = unusedBlossoms.back(); unusedBlossoms.pop_back();\n\t\tblossomBase[b] = base;\n\t\tblossomParent[b] = -1;\n\t\tblossomParent[bb] = b;\n\t\tblossomChilds[b].clear();\n\t\tblossomEdges[b].clear();\n\t\tvi &bChilds = blossomChilds[b];\n\t\tvi &bEdges = blossomEdges[b];\n\t\twhile (bv != bb) {\n\t\t\tblossomParent[bv] = b;\n\t\t\tbChilds.push_back(bv);\n\t\t\tbEdges.push_back(labelEdge[bv]);\n\t\t\tbv = inBlossom[endPoint[labelEdge[bv]]];\n\t\t}\n\t\tbChilds.push_back(bb);\n\t\treverse(all(bChilds));\n\t\treverse(all(bEdges));\n\t\tbEdges.push_back(2 * k);\n\t\twhile (bw != bb) {\n\t\t\tblossomParent[bw] = b;\n\t\t\tbChilds.push_back(bw);\n\t\t\tbEdges.push_back(labelEdge[bw] ^ 1);\n\t\t\tbw = inBlossom[endPoint[labelEdge[bw]]];\n\t\t}\n\t\tlabel[b] = 1;\n\t\tlabelEdge[b] = labelEdge[bb];\n\t\tdualVar[b] = 0;\n\t\tBlossomLeaves bl(this, b);\n\t\tfor (int v; bl.next(v); ) {\n\t\t\tif (label[inBlossom[v]] == 2)\n\t\t\t\tsVerteices.push_back(v);\n\t\t\tinBlossom[v] = b;\n\t\t}\n\t\tvi bestEdgeTo(2 * nVertex, -1);\n\t\teach(it, bChilds) {\n\t\t\tint bv2 = *it;\n\t\t\tvector<vi> nbLists;\n\t\t\tif (!blossomBestEdgesUsed[bv2]) {\n\t\t\t\tBlossomLeaves bl2(this, bv2);\n\t\t\t\tfor (int v2; bl2.next(v2); ) {\n\t\t\t\t\tnbLists.push_back(neighbEnd[v2]);\n\t\t\t\t\tvi &vv = nbLists.back();\n\t\t\t\t\teach(i, vv)\n\t\t\t\t\t\t*i /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnbLists.push_back(blossomBestEdges[bv2]);\n\t\t\t}\n\t\t\teach(itt, nbLists) {\n\t\t\t\teach(ittt, *itt) {\n\t\t\t\t\tint k2 = *ittt;\n\t\t\t\t\tEdge &e2 = edges[k2];\n\t\t\t\t\tint i = e2.src, j = e2.dst;\n\t\t\t\t\tif (inBlossom[j] == b)\n\t\t\t\t\t\tswap(i, j);\n\t\t\t\t\tint bj = inBlossom[j];\n\t\t\t\t\tif (bj != b && label[bj] == 1 &&\n\t\t\t\t\t\t(bestEdgeTo[bj] == -1 ||\n\t\t\t\t\t\t\tslack(k2) < slack(bestEdgeTo[bj]))) {\n\t\t\t\t\t\tbestEdgeTo[bj] = k2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tblossomBestEdgesUsed[bv2] = false;\n\t\t\tblossomBestEdges[bv2].clear();\n\t\t\tbestEdge[bv2] = -1;\n\t\t}\n\t\tblossomBestEdgesUsed[b] = true;\n\t\tblossomBestEdges[b].clear();\n\t\teach(it, bestEdgeTo)\n\t\t\tif (*it != -1)\n\t\t\t\tblossomBestEdges[b].push_back(*it);\n\t\tbestEdge[b] = -1;\n\t\teach(it, blossomBestEdges[b])\n\t\t\tif (bestEdge[b] == -1 || slack(*it) < slack(bestEdge[b]))\n\t\t\t\tbestEdge[b] = *it;\n\t}\n\tvoid expandBlossom(int b, bool endStage) {\n\t\tint cSize = blossomChilds[b].size();\n\t\teach(it, blossomChilds[b]) {\n\t\t\tint s = *it;\n\t\t\tblossomParent[s] = -1;\n\t\t\tif (s < nVertex)\n\t\t\t\tinBlossom[s] = s;\n\t\t\telse if (endStage && dualVar[s] == 0)\n\t\t\t\texpandBlossom(s, endStage);\n\t\t\telse {\n\t\t\t\tBlossomLeaves bl(this, s);\n\t\t\t\tfor (int v; bl.next(v); )\n\t\t\t\t\tinBlossom[v] = s;\n\t\t\t}\n\t\t}\n\t\tif (!endStage && label[b] == 2) {\n\t\t\tint entryChild = inBlossom[endPoint[labelEdge[b] ^ 1]];\n\t\t\tint j = find(all(blossomChilds[b]), entryChild) - blossomChilds[b].begin();\n\t\t\tint jStep, evenOdd;\n\t\t\tif (j & 1)\n\t\t\t\tjStep = 1, evenOdd = 0;\n\t\t\telse\n\t\t\t\tjStep = -1, evenOdd = 1;\n\t\t\tint p = labelEdge[b];\n\t\t\twhile (j != 0) {\n\t\t\t\tlabel[endPoint[p ^ 1]] = 0;\n\t\t\t\tlabel[endPoint[blossomEdges[b][j - evenOdd] ^ evenOdd ^ 1]] = 0;\n\t\t\t\tassignLabel(endPoint[p ^ 1], 2, p);\n\t\t\t\tallowEdge[blossomEdges[b][j - evenOdd] / 2] = true;\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t\tp = blossomEdges[b][j - evenOdd] ^ evenOdd;\n\t\t\t\tallowEdge[p / 2] = true;\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t}\n\t\t\tint bv = blossomChilds[b][j];\n\t\t\tlabel[endPoint[p ^ 1]] = label[bv] = 2;\n\t\t\tlabelEdge[endPoint[p ^ 1]] = labelEdge[bv] = p;\n\t\t\tbestEdge[bv] = -1;\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\twhile (blossomChilds[b][j] != entryChild) {\n\t\t\t\tbv = blossomChilds[b][j];\n\t\t\t\tif (label[bv] == 1) {\n\t\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBlossomLeaves bl(this, bv);\n\t\t\t\tint v;\n\t\t\t\twhile (bl.next(v))\n\t\t\t\t\tif (label[v] != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (label[v] != 0) {\n\t\t\t\t\tlabel[v] = 0;\n\t\t\t\t\tlabel[endPoint[mate[blossomBase[bv]]]] = 0;\n\t\t\t\t\tassignLabel(v, 2, labelEdge[v]);\n\t\t\t\t}\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t}\n\t\t}\n\t\tlabel[b] = labelEdge[b] = -1;\n\t\tblossomChilds[b].clear();\n\t\tblossomEdges[b].clear();\n\t\tblossomBestEdgesUsed[b] = false;\n\t\tblossomBestEdges[b].clear();\n\t\tbestEdge[b] = -1;\n\t\tunusedBlossoms.push_back(b);\n\t}\n\tvoid augmentBlossom(int b, int v) {\n\t\tint cSize = blossomChilds[b].size();\n\t\tint t = v;\n\t\twhile (blossomParent[t] != b)\n\t\t\tt = blossomParent[t];\n\t\tif (t >= nVertex)\n\t\t\taugmentBlossom(t, v);\n\t\tint i, j, jStep, evenOdd;\n\t\ti = j = find(all(blossomChilds[b]), t) - blossomChilds[b].begin();\n\t\tif (i & 1)\n\t\t\tjStep = 1, evenOdd = 0;\n\t\telse\n\t\t\tjStep = -1, evenOdd = 1;\n\t\twhile (j != 0) {\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\tt = blossomChilds[b][j];\n\t\t\tint p = blossomEdges[b][j - evenOdd] ^ evenOdd;\n\t\t\tif (t >= nVertex)\n\t\t\t\taugmentBlossom(t, endPoint[p]);\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\tt = blossomChilds[b][j];\n\t\t\tif (t >= nVertex)\n\t\t\t\taugmentBlossom(t, endPoint[p ^ 1]);\n\t\t\tmate[endPoint[p]] = p ^ 1;\n\t\t\tmate[endPoint[p ^ 1]] = p;\n\t\t}\n\t\trotate(blossomChilds[b].begin(), blossomChilds[b].begin() + i, blossomChilds[b].end());\n\t\trotate(blossomEdges[b].begin(), blossomEdges[b].begin() + i, blossomEdges[b].end());\n\t\tblossomBase[b] = blossomBase[blossomChilds[b][0]];\n\t}\n\tvoid augmentMatching(int k) {\n\t\tEdge &e = edges[k];\n\t\tint v = e.src, w = e.dst;\n\t\trep(ii, 2) {\n\t\t\tint s = ii == 0 ? v : w, p = ii == 0 ? 2 * k + 1 : 2 * k;\n\t\t\twhile (true) {\n\t\t\t\tint bs = inBlossom[s];\n\t\t\t\tif (bs >= nVertex)\n\t\t\t\t\taugmentBlossom(bs, s);\n\t\t\t\tmate[s] = p;\n\t\t\t\tif (labelEdge[bs] == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tint bt = inBlossom[endPoint[labelEdge[bs]]];\n\t\t\t\ts = endPoint[labelEdge[bt]];\n\t\t\t\tint j = endPoint[labelEdge[bt] ^ 1];\n\t\t\t\tif (bt >= nVertex)\n\t\t\t\t\taugmentBlossom(bt, j);\n\t\t\t\tmate[j] = labelEdge[bt];\n\t\t\t\tp = labelEdge[bt] ^ 1;\n\t\t\t}\n\t\t}\n\t}\n\tvoid mainLoop() {\n\t\trep(t, nVertex) {\n\t\t\tlabel.assign(2 * nVertex, 0);\n\t\t\tbestEdge.assign(2 * nVertex, -1);\n\t\t\tfill(blossomBestEdgesUsed.begin() + nVertex, blossomBestEdgesUsed.end(), false);\n\t\t\tallowEdge.assign(nEdge, false);\n\t\t\tsVerteices.clear();\n\t\t\trep(v, nVertex)\n\t\t\t\tif (mate[v] == -1 && label[inBlossom[v]] == 0)\n\t\t\t\t\tassignLabel(v, 1, -1);\n\t\t\tbool augmented = false;\n\t\t\twhile (true) {\n\t\t\t\tWeight kSlack;\n\t\t\t\twhile (!sVerteices.empty() && !augmented) {\n\t\t\t\t\tint v = sVerteices.back(); sVerteices.pop_back();\n\t\t\t\t\teach(it, neighbEnd[v]) {\n\t\t\t\t\t\tint p = *it;\n\t\t\t\t\t\tint k = p / 2, w = endPoint[p];\n\t\t\t\t\t\tif (inBlossom[v] == inBlossom[w])\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!allowEdge[k]) {\n\t\t\t\t\t\t\tkSlack = slack(k);\n\t\t\t\t\t\t\tif (kSlack <= 0)\n\t\t\t\t\t\t\t\tallowEdge[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (allowEdge[k]) {\n\t\t\t\t\t\t\tif (label[inBlossom[w]] == 0) {\n\t\t\t\t\t\t\t\tassignLabel(w, 2, p ^ 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (label[inBlossom[w]] == 1) {\n\t\t\t\t\t\t\t\tint base = scanBlossom(v, w);\n\t\t\t\t\t\t\t\tif (base >= 0) {\n\t\t\t\t\t\t\t\t\taddBlossom(base, k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\taugmentMatching(k);\n\t\t\t\t\t\t\t\t\taugmented = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (label[w] == 0) {\n\t\t\t\t\t\t\t\tlabel[w] = 2;\n\t\t\t\t\t\t\t\tlabelEdge[w] = p ^ 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[inBlossom[w]] == 1) {\n\t\t\t\t\t\t\tint b = inBlossom[v];\n\t\t\t\t\t\t\tif (bestEdge[b] == -1 || kSlack < slack(bestEdge[b]))\n\t\t\t\t\t\t\t\tbestEdge[b] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[w] == 0) {\n\t\t\t\t\t\t\tif (bestEdge[w] == -1 || kSlack < slack(bestEdge[w]))\n\t\t\t\t\t\t\t\tbestEdge[w] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (augmented)\n\t\t\t\t\tbreak;\n\t\t\t\tint deltaType = -1;\n\t\t\t\tWeight delta;\n\t\t\t\tint deltaEdge, deltaBlossom;\n\t\t\t\tif (!maxCardinality) {\n\t\t\t\t\tdeltaType = 1;\n\t\t\t\t\tdelta = *min_element(dualVar.begin(), dualVar.begin() + nVertex);\n\t\t\t\t}\n\t\t\t\trep(v, nVertex) {\n\t\t\t\t\tif (label[inBlossom[v]] == 0 && bestEdge[v] != -1) {\n\t\t\t\t\t\tWeight d = slack(bestEdge[v]);\n\t\t\t\t\t\tif (deltaType == -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltaType = 2;\n\t\t\t\t\t\t\tdeltaEdge = bestEdge[v];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(b, 2 * nVertex) {\n\t\t\t\t\tif (blossomParent[b] == -1 && label[b] == 1 && bestEdge[b] != -1) {\n\t\t\t\t\t\tkSlack = slack(bestEdge[b]);\n\t\t\t\t\t\tWeight d = kSlack / 2;\n\t\t\t\t\t\tif (deltaType == -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltaType = 3;\n\t\t\t\t\t\t\tdeltaEdge = bestEdge[b];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treu(b, nVertex, 2 * nVertex) {\n\t\t\t\t\tif (blossomBase[b] >= 0 && blossomParent[b] == -1 &&\n\t\t\t\t\t\tlabel[b] == 2 &&\n\t\t\t\t\t\t(deltaType == -1 || dualVar[b] < delta)) {\n\t\t\t\t\t\tdelta = dualVar[b];\n\t\t\t\t\t\tdeltaType = 4;\n\t\t\t\t\t\tdeltaBlossom = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deltaType == -1) {\n\t\t\t\t\tdeltaType = 1;\n\t\t\t\t\tdelta = max((Weight)0, *min_element(dualVar.begin(), dualVar.begin() + nVertex));\n\t\t\t\t}\n\t\t\t\trep(v, nVertex) {\n\t\t\t\t\tif (label[inBlossom[v]] == 1) {\n\t\t\t\t\t\tdualVar[v] -= delta;\n\t\t\t\t\t}\n\t\t\t\t\telse if (label[inBlossom[v]] == 2) {\n\t\t\t\t\t\tdualVar[v] += delta;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treu(b, nVertex, 2 * nVertex) {\n\t\t\t\t\tif (blossomBase[b] >= 0 && blossomParent[b] == -1) {\n\t\t\t\t\t\tif (label[b] == 1) {\n\t\t\t\t\t\t\tdualVar[b] += delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[b] == 2) {\n\t\t\t\t\t\t\tdualVar[b] -= delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deltaType == 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 2) {\n\t\t\t\t\tallowEdge[deltaEdge] = true;\n\t\t\t\t\tEdge &e = edges[deltaEdge];\n\t\t\t\t\tint i = e.src, j = e.dst;\n\t\t\t\t\tif (label[inBlossom[i]] == 0)\n\t\t\t\t\t\tswap(i, j);\n\t\t\t\t\tsVerteices.push_back(i);\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 3) {\n\t\t\t\t\tallowEdge[deltaEdge] = true;\n\t\t\t\t\tEdge &e = edges[deltaEdge];\n\t\t\t\t\tint i = e.src;\n\t\t\t\t\tsVerteices.push_back(i);\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 4) {\n\t\t\t\t\texpandBlossom(deltaBlossom, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!augmented)\n\t\t\t\tbreak;\n\t\t\treu(b, nVertex, 2 * nVertex)\n\t\t\t\tif (blossomParent[b] == -1 && blossomBase[b] >= 0 &&\n\t\t\t\t\tlabel[b] == 1 && dualVar[b] == 0)\n\t\t\t\t\texpandBlossom(b, true);\n\t\t}\n\t}\n\tvi matching(const Edges& edges_, bool maxCardinality_ = false) {\n\t\tedges = edges_; maxCardinality = maxCardinality_;\n\t\tnEdge = edges.size();\n\t\tnVertex = 0;\n\t\teach(i, edges) {\n\t\t\tif (i->src >= nVertex) nVertex = i->src + 1;\n\t\t\tif (i->dst >= nVertex) nVertex = i->dst + 1;\n\t\t}\n\t\tmaxWeight = 0;\n\t\tendPoint.clear();\n\t\tneighbEnd.assign(nVertex, vi());\n\t\trep(i, nEdge) {\n\t\t\tEdge &e = edges[i];\n\t\t\tmaxWeight = max(maxWeight, e.weight);\n\t\t\tendPoint.push_back(e.src);\n\t\t\tendPoint.push_back(e.dst);\n\t\t\tneighbEnd[e.src].push_back(2 * i + 1);\n\t\t\tneighbEnd[e.dst].push_back(2 * i);\n\t\t}\n\t\tmate.assign(nVertex, -1);\n\t\tlabel.assign(2 * nVertex, 0);\n\t\tlabelEdge.assign(2 * nVertex, -1);\n\t\tinBlossom.clear();\n\t\tblossomBase.clear();\n\t\tblossomParent.assign(2 * nVertex, -1);\n\t\tblossomChilds.assign(2 * nVertex, vi());\n\t\tblossomEdges.assign(2 * nVertex, vi());\n\t\tbestEdge.assign(2 * nVertex, -1);\n\t\tblossomBestEdgesUsed.assign(2 * nVertex, false);\n\t\tblossomBestEdges.assign(2 * nVertex, vi());\n\t\tunusedBlossoms.clear();\n\t\tdualVar.clear();\n\t\trep(i, nVertex)\n\t\t\tinBlossom.push_back(i),\n\t\t\tblossomBase.push_back(i),\n\t\t\tunusedBlossoms.push_back(nVertex + i),\n\t\t\tdualVar.push_back(maxWeight);\n\t\trep(i, nVertex)\n\t\t\tblossomBase.push_back(-1),\n\t\t\tdualVar.push_back(0);\n\t\tallowEdge.assign(nEdge, 0);\n\t\tsVerteices = vi();\n\t\tmainLoop();\n\t\trep(v, nVertex)\n\t\t\tif (mate[v] >= 0)\n\t\t\t\tmate[v] = endPoint[mate[v]];\n\t\treturn mate;\n\t}\n\tWeight getWeight(const Edges& e, bool maxCardinality_ = false) {\n\t\tvector<int> v = matching(e, maxCardinality_);\n\t\tWeight w = 0;\n\t\trep(i, v.size()) if (v[i] != -1)\n\t\t\teach(j, e) if (i == j->src && j->dst == v[i]) w += j->weight;\n\t\treturn w;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, A, B; cin >> N >> A >> B;\n\tvector<int> a(N), b(N); for (int i = 0; i < N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t}\n\n\tint ans = 0;\n\tvector<bool> used(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (abs(a[i] - b[i]) <= A || (abs(a[i] - b[i]) >= B&&abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tans++;\n\t\t\tused[i] = true;\n\t\t\tdump(i);\n\t\t}\n\t}\n\tEdges edges;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (used[i])continue;\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (used[j])continue;\n\t\t\tdump(i, j, abs(a[i] + a[j] - b[i] - b[j]));\n\t\t\tif (abs(a[i] + a[j] - b[i] - b[j]) <= A || (abs(a[i] + a[j] - b[i] - b[j]) >= B&&abs(a[i] + a[j] - b[i] - b[j]) <= 2 * A)) {\n\t\t\t\tedges.emplace_back(i, j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tMaxWeightMatching mwm;\n\tans += mwm.getWeight(edges);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V;\nint N;\nvector<int> G[NUM];\nint match[NUM];\nbool used[NUM];\nInfo info[800];\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)||\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1;\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\tbool check[N];\n\tint tmp,ans = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tcheck[i] = false;\n\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tans++;\n\t\t\tcheck[i] = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(check[i])continue;\n\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tif(k == i || check[k] == true)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = N;\n\n\tprintf(\"%d\\n\", ans+bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,A,B;\nint a[888],b[888];\nvector<int>G[4444];\nbool g(int a)\n{\n\treturn abs(a)<=A||(B<=abs(a)&&abs(a)<=2*A);\n}\nint match[8888],used[8888];\nbool dfs(int v)\n{\n\tused[v]=1;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i];\n\t\tif(match[u]<0||!used[match[u]]&&dfs(match[u]))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint matching()\n{\n\tint res=0;\n\tfor(int i=0;i<2*n;i++)match[i]=-1;\n\tfor(int v=0;v<2*n;v++)\n\t{\n\t\tfor(int i=0;i<2*n;i++)used[i]=0;\n\t\tif(dfs(v))res++;\n\t}\n\treturn res;\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tint f=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\tif(g(a[i]-b[i]))f++;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i!=j&&g(a[i]+a[j]-(b[i]+b[j])))\n\t\t\t{\n\t\t\t\tG[i].push_back(n+j);\n\t\t\t\tG[n+j].push_back(i);\n\t\t\t\tG[j].push_back(n+i);\n\t\t\t\tG[n+i].push_back(j);\n\t\t\t}\n\t\t\telse if(i==j&&g(a[i]-b[i]))\n\t\t\t{\n\t\t\t\tG[i].push_back(n+i);\n\t\t\t\tG[n+i].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=matching();\n\tcout<<(f+(ans-f)/2)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V; //頂点数\nint N;\nvector<int> G[NUM]; //グラフの隣接リスト表現\nint match[NUM]; //マッチングのペア\nbool used[NUM]; //DFSですでに調べたかのフラグ\nbool have_pair[NUM]; //ペアを既に作ったかのフラグ\nInfo info[800];\n\n//fromとtoを結ぶ辺をグラフに追加する\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\n//増加パスをDFSで探す(node_idのペアを探す)\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif(have_pair[adj_node_id])continue;\n\t\tif((pair_id < 0)|| //隣接するノードに、まだペアが存在しない\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\tif(node_id >= N){\n\t\t\t\thave_pair[node_id-N] = true;\n\t\t\t}else{\n\t\t\t\thave_pair[node_id] = true;\n\t\t\t}\n\n\t\t\tif(adj_node_id >= N){\n\t\t\t\thave_pair[adj_node_id-N] = true; //★ペアに使ったノードを、別のペアにしないようにする★\n\t\t\t}else{\n\t\t\t\thave_pair[adj_node_id] = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1; //ペアなしにしておく\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0 && have_pair[node_id] == false){ //node_idにペアがいない場合\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){ //増加パスが存在する場合\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\tint from_index[N],to_index[N];\n\n\tint index = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfrom_index[i] = index++;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tto_index[i] = index++;\n\t}\n\n\t//N件のデータを読み込む\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t}\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tadd_edge(from_index[i],to_index[i]);\n\t\t}\n\t\tfor(int k = i+1; k < N; k++){ //2重計上を防ぐため、自分よりインデックスが大きいもののみ走査\n\t\t\tif(k == i)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(from_index[i],to_index[k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = index;\n\tfor(int i = 0; i < V; i++)have_pair[i] = false;\n\n\tprintf(\"%d\\n\", bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int atmp=0,btmp=0,N=0, A=0, B=0, ans=0;\n    vector<int> a;\n    vector<int> b;\n    vector<int> confirm;\n\n    cin>>N>>A>>B;\n\n    for(int i=0;i<N;i++){\n        cin>>atmp;\n        a.push_back(atmp);\n        cin>>btmp;\n        b.push_back(btmp);\n        confirm.push_back(1);\n    }\n\n    for(int i=0;i<N;i++){\n        if((abs(a[i]-b[i])<=A) || (B<=abs(a[i]-b[i])&&abs(a[i]-b[i])<=2*A)){\n            ans++;\n            confirm[i]=0;\n        }\n    }\n\n    for(int i=0;i<N-1;i++){\n        if(confirm[i]){ \n            for(int j=i+1;j<a.size();j++){\n                if((abs(a[i]+a[j]-b[i]-b[j])<=A&&confirm[j]) || (B<=abs(a[i]+a[j]-b[i]-b[j])&&abs(a[i]+a[j]-b[i]-b[j])<=2*A&&confirm[j]) ){ \n                    ans++;\n                    confirm[i]=0;\n                    confirm[j]=0;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout<<ans<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day2/problems/G>\n問題文============================================================\n\n N個の非負整数のペア(ai,bi)と非負整数A, B が与えられる。\n 以下のいずれかの操作をできるだけたくさん行いたい。\n \n (1) |ai−bi|≤A または B≤|ai−bi|≤2Aを満たす要素iを取り出し、削除する\n (2) |(ai+aj)−(bi+bj)|≤A または B≤|(ai+aj)−(bi+bj)|≤2A を満たす要素iと要素j (i≠j)の組を取り出し、削除する\n \n 最大の操作回数を求めよ。\n \n=================================================================\n\n解説=============================================================\n\n 出来うる限り　操作(1)を行う\n その後、余った要素ペアに関して操作(2)の条件を満たすペアとの二部マッチングを解く\n \n================================================================\n*/\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(ll v) {\n    used[v] = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        ll u = G[v][i], w = match[u];\n        if (w < 0 || ((used[w] == 0) && dfs(w))) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nll bipartite_matching() {\n    ll res = 0;\n    for (int i = 0; i < (int)match.size();i++)match[i] = -1;\n    for (int v = 0;v < V;v++) {\n        if (match[v] < 0) {\n            for (int i = 0; i < (int)used.size();i++)used[i] = 0;\n            if (dfs(v))res++;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<ll> a(N),b(N);\n    for(int i = 0; i < N;i++) cin >> a[i] >>b[i];\n    \n    vector<int> f(N,0);\n    for(int i = 0; i < N;i++){\n        ll Abs = abs(a[i]-b[i]);\n        if(Abs <= A || (B <= Abs && Abs <= 2*A)){\n            f[i] = -1;\n        }\n    }\n    ll cnt = -accumulate(f.begin(),f.end(),0LL);\n    V = 0;\n    for(int i = 0; i < N;i++){\n        if(f[i] == 0){\n            f[i] = V;\n            V++;\n        }\n    }\n    G.resize(V);\n    match.resize(V);\n    used.resize(V);\n    \n    for(int i = 0; i < N;i++){\n        for(int j = 0; j < N;j++){\n            if(f[i] == -1 || f[j] == -1) continue;\n            ll Absdayo = abs(a[i]+a[j]-b[i]-b[j]);\n            if(Absdayo <= A || (B <= Absdayo && Absdayo <= 2*A )){\n                 add_edge(f[i],f[j]);\n            }\n        }\n    }\n//    cout << cnt << \" \" << bipartite_matching() << endl;\n    cout << cnt + bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, A, B;\nvector<pii> pl, mn;\n\nconst int MAX_V = 805;\n\nstruct edge {\n    int to, cap, rev;\n    edge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n};\n\nvector<vector<edge>> g(MAX_V);\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    g[from].emplace_back(to, cap, g[to].size());\n    g[to].emplace_back(from, 0, g[from].size() - 1);\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n        int now = q.front(); q.pop();\n        for (auto e : g[now]) {\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[now] + 1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int now, int t, int f) {\n    if (now == t) return f;\n    for (int &i = iter[now]; i < g[now].size(); i++) {\n        edge &e = g[now][i];\n        if (e.cap > 0 && level[now] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    int ans = 0;\n    rep(i, n) {\n      int a, b;\n      cin >> a >> b;\n      if (abs(a - b) <= A || (B <= abs(a - b) && abs(a - b) <= 2 * A)) {\n        ans++;\n        continue;\n      }\n      if (a - b > 0) pl.push_back({a, b});\n      else mn.push_back({a, b});\n    }\n    int ps = pl.size();\n    int ms = mn.size();\n    int s = ps + ms;\n    int t = s + 1;\n    rep(i, ps) {\n      int a = pl[i].fi;\n      int b = pl[i].se;\n      rep(j, ms) {\n        int c = mn[j].fi;\n        int d = mn[j].se;\n        if (abs(a + c - b - d) <= A || (B <= abs(a + c - b - d) && abs(a + c - b - d) <= 2 * A)) {\n          add_edge(i, j + ps, 1);\n        }\n      }\n    }\n    rep(i, ps) add_edge(s, i, 1);\n    rep(j, ms) add_edge(j + ps, t, 1);\n    cout << ans + max_flow(s, t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\ntypedef long long ll;\n\nint N,A,B;\nint a[830], b[830];\nint c[830];\n\nbool g[830][830];\n\nint main(){\n  scanf(\"%d%d%d\",&N,&A,&B);\n  REP(i,N)scanf(\"%d%d\",a+i,b+i);\n  REP(i,N)c[i] = a[i]-b[i];\n  int ans = 0;\n  vector<int> pos, neg;\n  REP(i,N){\n    if(abs(c[i])<=A || (B<=abs(c[i]) && abs(c[i])<=2*A)){\n      ans++;\n    }else{\n      (c[i]<0 ? neg : pos).push_back(c[i]);\n    }\n  }\n  int n = pos.size(), m = neg.size();\n  REP(i,n)REP(j,m){\n    int x = pos[i] + neg[j];\n    if(abs(x)<=A || (B<=abs(x) && abs(x)<=2*A)){\n      g[i][n+j] = true;\n    }else{\n      g[i][n+j] = false;\n    }\n  }\n  int s = n+m;\n  int t = n+m+1;\n  REP(i,n)g[s][i] = true;\n  REP(j,m)g[n+j][t] = true;\n  while(true){\n    vector<int> bef(n+m+2, -1);\n    vector<bool> used(n+m+2, false);\n    stack<int> S;\n    S.push(s);\n    used[s] = true;\n    while(!S.empty()){\n      int p = S.top(); S.pop();\n      REP(to,n+m+2)if(!used[to]){\n        if(!g[p][to])continue;\n        used[to] = true;\n        bef[to] = p;\n        S.push(to);\n      }\n    }\n    if(!used[t])break;\n    int cur = t;\n    while(cur != s){\n      int b = bef[cur];\n      g[b][cur] = false;\n      g[cur][b] = true;\n      cur = b;\n    }\n    ans++;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Dinic{\n  const int INF=1<<28;\n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n       if(d>0){\n         e.cap-=d;\n         G[e.to][e.rev].cap+=d;\n         return d;\n       }\n      }\n    }\n    return 0;\n  }\n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n       fl+=f;\n       lim-=f;\n      }\n    }\n  }\n};\n\nint N,A,B,ans,a,b;\nvector<P>C1,C2;\n\nbool check(int a,int b){\n  int X=abs(a-b);\n  return X<=A||(B<=X&&X<=2*A);\n}\n\nint main(){\n\n  cin>>N>>A>>B;\n\n  for(int i=0;i<N;i++){\n    cin>>a>>b;\n    if(check(a,b))ans++;\n    else{\n      if(a==b)continue;\n      if(a>b)C1.push_back(P(a,b));\n      else C2.push_back(P(a,b));\n    }\n  }\n\n  int c1=C1.size(),c2=C2.size();\n\n  Dinic D(c1+c2+2);\n\n  for(int i=0;i<C1.size();i++){\n    for(int j=0;j<C2.size();j++){\n      int a=C1[i].first+C2[j].first;\n      int b=C1[i].second+C2[j].second;\n      if(check(a,b)){\n        D.add_edge(i,C1.size()+j,1);\n      }\n    }\n  }\n\n  for(int i=0;i<C1.size();i++)D.add_edge(c1+c2,i,1);\n  for(int i=0;i<C2.size();i++)D.add_edge(c1+i,c1+c2+1,1);\n\n  cout<<ans+D.flow(c1+c2,c1+c2+1,1e8)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nsigned main() \n{\n  int n,A,B;\n  cin>>n>>A>>B;\n  int a[801],b[801],c[801]={};\n  int cnt=0;\n  rep(i,n)\n  {\n    cin>>a[i]>>b[i];\n    int tmp=a[i]-b[i];\n    if(abs(tmp)<=A||(B<=abs(tmp)&&abs(tmp)<=2*A)) cnt++;\n    else c[i]=tmp;\n  }\n  priority_queue<int, vector<int>, greater<int> > nc;\n  priority_queue<int> pc;\n  rep(i,n)\n  {\n    if(c[i]>0) pc.push(c[i]);\n    else if(c[i]<0) nc.push(c[i]);\n  }\n  \n  while((!pc.empty())&&(!nc.empty()))\n  {\n    int p=pc.top(),n=nc.top();\n    int diff=abs(p+n);\n    if(diff <= A || (B <= diff && diff <= 2 * A)) \n    {\n      cnt++;\n      pc.pop();\n      nc.pop();\n      \n    }\n    else \n    {\n      if(n<p) nc.pop();\n      else pc.pop();\n    }\n  }\n  print(cnt);\n  \n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing namespace std;\ntemplate <typename T> using vec = vector<T>;\nusing V = vec<int>;\n\nusing flow_type = int;\n\nstruct dinic {\n    struct edge {\n        int src, dst;\n        flow_type cap, flow;\n        int rev_idx;\n        bool is_rev;\n    };\n    int n, s, t;\n    std::vector<std::vector<edge>> g;\n    std::vector<int> level, prog, que;\n    std::vector<std::pair<std::pair<int, int>, flow_type>> edges;\n\n    dinic(int n_ = 0) : n(n_) {}\n\n    // Compute the maximum-flow from `s_` to `t_` by Dinic's algorithm.\n    flow_type maximum_flow(int s_, int t_) {\n        s = s_;\n        t = t_;\n        make_graph();\n        que.resize(n);\n        flow_type res = 0;\n        while (levelize()) {\n            prog.assign(n, 0);\n            res += augment(s, std::numeric_limits<flow_type>::max());\n        }\n        return res;\n    }\n\n    // Add an edge from `u` to `v` with capacity `c`. Note that it will be added\n    // to `g` when `make_graph` is called instead of just after calling this\n    // function.\n    void add_edge(int u, int v, flow_type c) {\n        // cout << u << ' ' << v << endl;\n        if (u != v && c != 0) {\n            edges.emplace_back(std::make_pair(u, v), c);\n        }\n    }\n\n    void make_graph() {\n        g.assign(n, {});\n        if (true) {\n            std::sort(edges.begin(), edges.end());\n            for (auto it = edges.begin(); it != edges.end();) {\n                flow_type c = 0;\n                auto uv = it->first;\n                while (it != edges.end() && it->first == uv) {\n                    c += it->second;\n                    ++it;\n                }\n                int u = uv.first, v = uv.second;\n                g[u].push_back({u, v, c, 0, (int)g[v].size(), false});\n                g[v].push_back({v, u, c, c, (int)g[u].size() - 1, true});\n            }\n        } else {\n            for (auto &e : edges) {\n                auto uv = e.first;\n                int u = uv.first, v = uv.second;\n                flow_type c = e.second;\n                g[u].push_back({u, v, c, 0, (int)g[v].size(), false});\n                g[v].push_back({v, u, c, c, (int)g[u].size() - 1, true});\n            }\n        }\n    }\n\n    bool levelize() {\n        int fst = 0, lst = 0;\n        que[lst++] = s;\n        level.assign(n, -1);\n        level[s] = 0;\n        while (fst != lst) {\n            int v = que[fst++];\n            if (v == t) break;\n            for (auto &e : g[v]) {\n                if (level[e.dst] == -1 && residue(e) != 0) {\n                    level[e.dst] = level[v] + 1;\n                    que[lst++] = e.dst;\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    flow_type augment(int v, flow_type lim) {\n        flow_type res = 0;\n        if (v == t) return lim;\n        for (int &i = prog[v]; i < (int)g[v].size(); ++i) {\n            if (lim == 0) break;\n            auto &e = g[v][i];\n            if (level[v] < level[e.dst] && residue(e) != 0) {\n                flow_type aug = augment(e.dst, std::min(lim, residue(e)));\n                if (aug == 0) continue;\n                e.flow += aug;\n                reverse(e).flow -= aug;\n                res += aug;\n                lim -= aug;\n            }\n        }\n        return res;\n    }\n\n    flow_type residue(const edge &e) { return e.cap - e.flow; }\n\n    edge &reverse(const edge &e) { return g[e.dst][e.rev_idx]; }\n\n    // Output current flow by graphviz dot language.\n    // Run `dot $filename -o out.png -T png` on shell.\n    void show(const std::string &filename = \"out.dot\") {\n        int fst = 0, lst = 0;\n        que[lst++] = s;\n        level.assign(n, -1);\n        level[s] = 0;\n        while (fst != lst) {\n            int v = que[fst++];\n            for (auto &e : g[v]) {\n                if (!e.is_rev && level[e.dst] == -1 && e.flow) {\n                    level[e.dst] = level[v] + 1;\n                    que[lst++] = e.dst;\n                }\n            }\n        }\n        std::map<int, std::vector<int>> rank_to_vertices;\n        for (int i = 0; i < n; ++i) {\n            rank_to_vertices[level[i]].push_back(i);\n        }\n\n        std::ostringstream oss;\n        oss << \"digraph {\" << '\\n';\n        for (int i = 0; i < n; ++i) {\n            oss << \"\\t\" << i;\n            if (i == s || i == t) {\n                oss << \" [ peripheries = 2 ]\";\n            }\n            oss << \";\\n\";\n            for (auto &e : g[i]) {\n                if (!e.is_rev) {\n                    const char *color = e.flow ? \"black\" : \"gray\";\n                    oss << \"\\t\" << e.src << \" -> \" << e.dst << \"\\t[ \"\n                        << \"label = \\\"\" << e.flow << \"/\" << e.cap << \"\\\", \"\n                        << \"color = \\\"\" << color << \"\\\", \"\n                        << \"fontcolor = \\\"\" << color << \"\\\"];\\n\";\n                }\n            }\n        }\n\n        for (auto &p : rank_to_vertices) {\n            const char *rank = p.first != -1 ? \"same\" : \"sink\";\n            oss << \"\\t{ rank = \" << rank << \"; \";\n            for (int v : p.second) {\n                if (v != s && v != t) {\n                    oss << v << \"; \";\n                }\n            }\n            oss << \"}\\n\";\n        }\n        oss << \"\\t{ rank = same; \" << s << \"; }\\n\";\n        oss << \"\\t{ rank = same; \" << t << \"; }\\n\";\n        oss << \"}\\n\";\n\n        std::ofstream ofs(filename);\n        ofs << oss.str();\n    }\n};\n\nint N, A, B;\nint a[1000], b[1000];\n\nbool range(int x) {\n    return abs(x) <= A || (B <= abs(x) && abs(x) <= 2 * A);\n}\n\nbool check(int i) {\n    return range(a[i] - b[i]);\n}\n\nbool check(int i, int j) {\n    return range(a[i] + a[j] - b[i] - b[j]);\n}\n\nint pnode(int i, int j) {\n    assert(i <= j);\n    return N + i * N + j;\n}\n\nint main() {\n    while (cin >> N >> A >> B) {\n        rep(i, N) cin >> a[i] >> b[i];\n        dinic dn(N * N + N + 2);\n        rep(i, N) {\n            for (int j = i; j < N; ++j) {\n                bool ok = i == j ? check(i) : check(i, j);\n                if (ok) {\n                    dn.add_edge(i, pnode(i, j), 1);\n                }\n            }\n        }\n        int S = N + N * N;\n        int T = S + 1;\n        rep(i, N) dn.add_edge(S, i, 1);\n        rep(i, N) for (int j = i; j < N; ++j) dn.add_edge(pnode(i, j), T, 1);\n        cout << dn.maximum_flow(S, T) << endl;\n        dn.show();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n \n#define even(x) (mu[x] == x or phi[mu[x]] != mu[x])\n#define out(x) (mu[x] != x and phi[mu[x]] == mu[x] and phi[x] == x)\nint maximum_matching(const vector<vector<int>>& G, vector<pair<int, int>>& ret) {\n    const int n = G.size();\n    vector<int> mu(n), phi(n), rho(n), done(n);\n    rep(v, n) mu[v] = phi[v] = rho[v] = v;\n    for (int x = -1; ; ) {\n        if (x < 0) {\n            for (x = 0; x < n and (done[x] or !even(x)); ++x);\n            if (x == n) break;\n        }\n        int y = -1;\n        for (int v : G[x]) if (out(v) or (even(v) and rho[v] != rho[x])) y = v;\n        if (y == -1) {\n            done[x] = true, x = -1;\n        }\n        else if (out(y)) {\n            phi[y] = x;\n        }\n        else {\n            vector<int> dx(n, -2), dy(n, -2); // x % 2 --> x >= 0\n            for (int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n            for (int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n            bool disjoint = true;\n            rep(v, n) if (dx[v] >= 0 and dy[v] > 0) disjoint = false;\n            if (disjoint) {\n                rep(v, n) if (dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n                rep(v, n) if (dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n                mu[x] = y; mu[y] = x; x = -1;\n                rep(v, n) phi[v] = rho[v] = v, done[v] = false;\n            }\n            else {\n                int r = x, d = n;\n                rep(v, n) if (dx[v] >= 0 and dy[v] >= 0 and rho[v] == v and d > dx[v]) d = dx[v], r = v;\n                rep(v, n) if (dx[v] <= d and dx[v] % 2 and rho[phi[v]] != r) phi[phi[v]] = v;\n                rep(v, n) if (dy[v] <= d and dy[v] % 2 and rho[phi[v]] != r) phi[phi[v]] = v;\n                if (rho[x] != r) phi[x] = y;\n                if (rho[y] != r) phi[y] = x;\n                rep(v, n) if (dx[rho[v]] >= 0 or dy[rho[v]] >= 0) rho[v] = r;\n            }\n        }\n    }\n    ret.clear();\n    rep(v, n) if (v < mu[v]) ret.emplace_back(v, mu[v]);\n    return ret.size();\n}\n \nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> a(N);\n    vector<int> b(N);\n    vector<bool> c(N);\n    int cnt = 0;\n    rep(i, N) {\n        cin >> a[i] >> b[i];\n        int d = abs(a[i] - b[i]);\n        if (d <= A || (B <= d && d <= 2 * A)) {\n            cnt++;\n            c[i] = true;\n        }\n    }\n     \n    vector<vector<int>> G(N);\n \n    rep(i, N){\n        if (c[i]) continue;\n        //cout << i << \":\";\n        repi(j, i + 1, N) {\n            if (c[j])continue;\n            int d = abs(a[i] + a[j] - b[i] - b[j]);\n            if (d <= A || (B <= d && d <= 2 * A)) {\n                G[i].emplace_back(j);\n                G[j].emplace_back(i);\n                //cout << \"  \" << j;\n            }\n        }\n        //cout << endl;\n    }\n    vector<pair<int, int>> R;\n    int ans = cnt + maximum_matching(G, R);\n \n    //cerr << cnt << \" \" << R.size() << endl;\n    //for (int i = 0; i < R.size(); i++)\n    //{\n    //  cerr << \" \" << R[i].first << \" \" << R[i].second << endl;\n    //}\n \n    cout << ans << endl;\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V; //頂点数\nint N;\nvector<int> G[NUM]; //グラフの隣接リスト表現\nint match[NUM]; //マッチングのペア\nbool used[NUM]; //DFSですでに調べたかのフラグ\nbool have_pair[NUM]; //ペアを既に作ったかのフラグ\nInfo info[800];\n\n//fromとtoを結ぶ辺をグラフに追加する\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\n//増加パスをDFSで探す(node_idのペアを探す)\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((adj_node_id < N && have_pair[adj_node_id] == true) || (adj_node_id >= N && have_pair[adj_node_id-N] == true))continue;\n\t\tif((pair_id < 0)|| //隣接するノードに、まだペアが存在しない\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\tif(node_id >= N){\n\t\t\t\thave_pair[node_id-N] = true;\n\t\t\t}else{\n\t\t\t\thave_pair[node_id] = true;\n\t\t\t}\n\n\t\t\tif(adj_node_id >= N){\n\t\t\t\thave_pair[adj_node_id-N] = true; //★ペアに使ったノードを、別のペアにしないようにする★\n\t\t\t}else{\n\t\t\t\thave_pair[adj_node_id] = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1; //ペアなしにしておく\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0 && have_pair[node_id] == false){ //node_idにペアがいない場合\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){ //増加パスが存在する場合\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\tint from_index[N],to_index[N];\n\n\tint index = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfrom_index[i] = index++;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tto_index[i] = index++;\n\t}\n\n\t//N件のデータを読み込む\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t}\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tadd_edge(from_index[i],to_index[i]);\n\t\t}\n\t\tfor(int k = i+1; k < N; k++){ //2重計上を防ぐため、自分よりインデックスが大きいもののみ走査\n\t\t\tif(k == i)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(from_index[i],to_index[k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = index;\n\tfor(int i = 0; i < V; i++)have_pair[i] = false;\n\n\tprintf(\"%d\\n\", bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,A,B;\nint a[888],b[888];\nint f;\nint ans;\nvector<int>G[4444];\nbool g(int a)\n{\n\treturn abs(a)<=A||(B<=abs(a)&&abs(a)<=2*A);\n}\nint match[8888],used[8888];\nbool dfs(int v)\n{\n\tused[v]=1;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i];\n\t\tif(match[u]<0||!used[match[u]]&&dfs(match[u]))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint c[8888];\nint matching(int col)\n{\n\tint res=0;\n\tfor(int i=0;i<2*f;i++)match[i]=-1;\n\tfor(int v=0;v<2*f;v++)\n\t{\n\t\tfor(int i=0;i<2*f;i++)used[i]=0;\n\t\tif(c[v]==col&&dfs(v))res++;\n\t}\n\treturn res/2;\n}\nvoid ddfs(int u,int co)\n{\n\tused[u]=1;\n\tc[u]=co;\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(!used[G[u][i]])ddfs(G[u][i],co);\n\t}\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tif(g(u-v))ans++;\n\t\telse\n\t\t{\n\t\t\ta[f]=u,b[f]=v;f++;\n\t\t}\n\t}\n\tfor(int i=0;i<f;i++)\n\t{\n\t\tfor(int j=i+1;j<f;j++)\n\t\t{\n\t\t\tif(g(a[i]+a[j]-(b[i]+b[j])))\n\t\t\t{\n\t\t\t\tG[i].push_back(f+j);\n\t\t\t\tG[f+j].push_back(i);\n\t\t\t\tG[j].push_back(f+i);\n\t\t\t\tG[f+i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cm=1;\n\tfor(int i=0;i<2*f;i++)\n\t{\n\t\tif(!used[i])\n\t\t{\n\t\t\tddfs(i,cm);\n\t\t\tddfs(i+f,cm);\n\t\t\tcm++;\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<cm;i++)\n\t{\n\t\tres+=matching(i);\n\t}\n\tcout<<(ans+res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nsigned main() \n{\n  int n,A,B;\n  cin>>n>>A>>B;\n  int a[801],b[801],c[801];\n  int cnt=0;\n  rep(i,n)\n  {\n    cin>>a[i]>>b[i];\n    int tmp=a[i]-b[i];\n    if(abs(tmp)<=A||(B<=abs(tmp)&&abs(tmp)<=2*A)) cnt++;\n    else c[i]=tmp;\n  }\n  priority_queue<int> nc;\n  priority_queue<int, vector<int>, greater<int> > pc;\n  rep(i,n)\n  {\n    if(c[i]>=0) pc.push(c[i]);\n    else nc.push(c[i]);\n  }\n  \n  while((!pc.empty())&&(!nc.empty()))\n  {\n    int p=pc.top(),n=nc.top();\n    int diff=p+n;\n    if(diff<=A||(B<=diff&&diff<=2*A)) \n    {\n      cnt++;\n      pc.pop();\n      nc.pop();\n    }\n    else \n    {\n      if(p>=n) pc.pop();\n      else nc.pop();\n    }\n  }\n  print(cnt);\n  \n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define REP(i, n) for(int i=0;i<(int)n;++i)\n#define FOR(i, c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\n\nstruct Edge {\n  int dst;\n  Weight weight;\n\n  Edge(int dst, Weight weight) :\n      dst(dst), weight(weight) {}\n};\n\ntypedef vector< Edge > Edges;\ntypedef vector< Edges > Graph;\n\ntypedef vector< Weight > Array;\ntypedef vector< Array > Matrix;\n\n#define EVEN(x) (mu[x] == x || (mu[x] != x && phi[mu[x]] != mu[x]))\n#define ODD(x)  (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] != x)\n#define OUTER(x) (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] == x)\n\nint maximumMatching(const Graph &g, Edges &matching) {\n  int n = g.size();\n  vector< int > mu(n), phi(n), rho(n), scanned(n);\n  REP(v, n) mu[v] = phi[v] = rho[v] = v; // (1) initialize\n  for(int x = -1;;) {\n    if(x < 0) {                        // (2) select even\n      for(x = 0; x < n && (scanned[x] || !EVEN(x)); ++x);\n      if(x == n) break;\n    }\n    int y = -1;                         // (3) select incident\n    FOR(e, g[x]) if(OUTER(e->dst) || (EVEN(e->dst) && rho[e->dst] != rho[x])) y = e->dst;\n    if(y == -1) scanned[x] = true, x = -1;\n    else if(OUTER(y)) phi[y] = x;      // (4) growth\n    else {\n      vector< int > dx(n, -2), dy(n, -2); // (5,6), !TRICK! x % 2 --> x >= 0\n      for(int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n      for(int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n      bool vertex_disjoint = true;\n      REP(v, n) if(dx[v] >= 0 && dy[v] > 0) vertex_disjoint = false;\n      if(vertex_disjoint) {            // (5) augment\n        REP(v, n) if(dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n        REP(v, n) if(dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n        mu[x] = y;\n        mu[y] = x;\n        x = -1;\n        REP(v, n) phi[v] = rho[v] = v, scanned[v] = false;\n      } else {                          // (6) shrink\n        int r = x, d = n;\n        REP(v, n) if(dx[v] >= 0 && dy[v] >= 0 && rho[v] == v && d > dx[v]) d = dx[v], r = v;\n        REP(v, n) if(dx[v] <= d && dx[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n        REP(v, n) if(dy[v] <= d && dy[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n        if(rho[x] != r) phi[x] = y;\n        if(rho[y] != r) phi[y] = x;\n        REP(v, n) if(dx[rho[v]] >= 0 || dy[rho[v]] >= 0) rho[v] = r;\n      }\n    }\n  }\n  matching.clear();\n  REP(u, n) if(u < mu[u]) matching.push_back(Edge(u, mu[u]));\n  return matching.size(); // make explicit matching\n}\n\n\nint n, a, b;\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair< int, int > P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint N, K;\n\nbool can[1000][1000];\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> a >> b;\n  N = n;\n  K = n;\n  vector< int > c(n);\n  for(int i = 0; i < n; i++) {\n    int p, q;\n    cin >> p >> q;\n    c[i] = p - q;\n  }\n  int ans = 0;\n  vector< bool > f(n);\n  for(int i = 0; i < n; i++) {\n    if(abs(c[i]) <= a || (b <= abs(c[i]) && abs(c[i]) <= 2 * a)) {\n      can[i][i] = true;\n      ans++;\n      f[i] = true;\n    }\n  }\n\n  Graph g(n);\n  for(int i = 0; i < n; i++) {\n    if(f[i]) continue;\n    for(int j = i + 1; j < n; j++) {\n      if(f[j]) continue;\n      if(abs(c[i] + c[j]) <= a || (b <= abs(c[i] + c[j]) && abs(c[i] + c[j]) <= 2 * a)) {\n        g[i].push_back(Edge(j, 1));\n        g[j].push_back(Edge(i, 1));\n      }\n    }\n  }\n  vector< Edge > e;\n  cout << maximumMatching(g, e) + ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n#define each(it,o) for(auto it = (o).begin(); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src_, int dst_, Weight weight_) : src(src_), dst(dst_), weight(weight_) { }\n\tEdge() {};\n};\ntypedef vector<Edge> Edges;\nstruct MaxWeightMatching {\n\tint nEdge, nVertex;\n\tWeight maxWeight;\n\tvi endPoint, mate, label, labelEdge,\n\t\tinBlossom, blossomParent, blossomBase,\n\t\tbestEdge, unusedBlossoms, allowEdge,\n\t\tblossomBestEdgesUsed,\n\t\tsVerteices;\n\tvector<Weight> dualVar;\n\tvector<vi> neighbEnd, blossomChilds, blossomEdges,\n\t\tblossomBestEdges;\n\tEdges edges;\n\tbool maxCardinality;\n\n\tWeight slack(int k) {\n\t\tEdge &e = edges[k];\n\t\treturn dualVar[e.src] + dualVar[e.dst] - 2 * e.weight;\n\t}\n\tstruct BlossomLeaves {\n\t\tint b;\n\t\tMaxWeightMatching *mw;\n\t\tenum { INITAL, END, NEXT, THIRD } state;\n\t\tvi::const_iterator iter, endi;\n\t\tBlossomLeaves *bl;\n\t\tBlossomLeaves(MaxWeightMatching *mw_, int b_) :\n\t\t\tmw(mw_), b(b_), state(INITAL), bl(NULL) {}\n\t\tbool next(int &r) {\n\t\t\tint t;\n\t\t\tswitch (state) {\n\t\t\tcase INITAL:\n\t\t\t\tif (b < mw->nVertex) {\n\t\t\t\t\tr = b;\n\t\t\t\t\tstate = END;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titer = mw->blossomChilds[b].begin();\n\t\t\t\t\tendi = mw->blossomChilds[b].end();\n\t\t\t\t\tstate = NEXT;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\tcase END:\n\t\t\t\treturn false;\n\t\t\tcase NEXT:\n\t\t\t\tif (iter == endi)\n\t\t\t\t\treturn false;\n\t\t\t\tt = *iter;\n\t\t\t\t++iter;\n\t\t\t\tif (t < mw->nVertex) {\n\t\t\t\t\tr = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbl = new BlossomLeaves(mw, t);\n\t\t\t\t\tstate = THIRD;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\tcase THIRD:\n\t\t\t\tif (!bl->next(t)) {\n\t\t\t\t\tstate = NEXT;\n\t\t\t\t\tdelete bl; bl = NULL;\n\t\t\t\t\treturn next(r);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tr = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\tvoid assignLabel(int w, int t, int p) {\n\t\tint b = inBlossom[w];\n\t\tlabel[w] = label[b] = t;\n\t\tlabelEdge[w] = labelEdge[b] = p;\n\t\tbestEdge[w] = bestEdge[b] = -1;\n\t\tif (t == 1) {\n\t\t\tBlossomLeaves bl(this, b);\n\t\t\tfor (int r; bl.next(r); ) sVerteices.push_back(r);\n\t\t}\n\t\telse if (t == 2) {\n\t\t\tint base = blossomBase[b];\n\t\t\tassignLabel(endPoint[mate[base]], 1, mate[base] ^ 1);\n\t\t}\n\t}\n\tint scanBlossom(int v, int w) {\n\t\tvi path;\n\t\tint base = -1;\n\t\twhile (v != -1) {\n\t\t\tint b = inBlossom[v];\n\t\t\tif (label[b] & 4) {\n\t\t\t\tbase = blossomBase[b];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.push_back(b);\n\t\t\tlabel[b] = 5;\n\t\t\tif (labelEdge[b] == -1) {\n\t\t\t\tv = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv = endPoint[labelEdge[b]];\n\t\t\t\tb = inBlossom[v];\n\t\t\t\tv = endPoint[labelEdge[b]];\n\t\t\t}\n\t\t\tif (w != -1)\n\t\t\t\tswap(v, w);\n\t\t}\n\t\teach(it, path)\n\t\t\tlabel[*it] = 1;\n\t\treturn base;\n\t}\n\tvoid addBlossom(int base, int k) {\n\t\tEdge &e = edges[k];\n\t\tint bb = inBlossom[base],\n\t\t\tbv = inBlossom[e.src],\n\t\t\tbw = inBlossom[e.dst];\n\t\tint b = unusedBlossoms.back(); unusedBlossoms.pop_back();\n\t\tblossomBase[b] = base;\n\t\tblossomParent[b] = -1;\n\t\tblossomParent[bb] = b;\n\t\tblossomChilds[b].clear();\n\t\tblossomEdges[b].clear();\n\t\tvi &bChilds = blossomChilds[b];\n\t\tvi &bEdges = blossomEdges[b];\n\t\twhile (bv != bb) {\n\t\t\tblossomParent[bv] = b;\n\t\t\tbChilds.push_back(bv);\n\t\t\tbEdges.push_back(labelEdge[bv]);\n\t\t\tbv = inBlossom[endPoint[labelEdge[bv]]];\n\t\t}\n\t\tbChilds.push_back(bb);\n\t\treverse(all(bChilds));\n\t\treverse(all(bEdges));\n\t\tbEdges.push_back(2 * k);\n\t\twhile (bw != bb) {\n\t\t\tblossomParent[bw] = b;\n\t\t\tbChilds.push_back(bw);\n\t\t\tbEdges.push_back(labelEdge[bw] ^ 1);\n\t\t\tbw = inBlossom[endPoint[labelEdge[bw]]];\n\t\t}\n\t\tlabel[b] = 1;\n\t\tlabelEdge[b] = labelEdge[bb];\n\t\tdualVar[b] = 0;\n\t\tBlossomLeaves bl(this, b);\n\t\tfor (int v; bl.next(v); ) {\n\t\t\tif (label[inBlossom[v]] == 2)\n\t\t\t\tsVerteices.push_back(v);\n\t\t\tinBlossom[v] = b;\n\t\t}\n\t\tvi bestEdgeTo(2 * nVertex, -1);\n\t\teach(it, bChilds) {\n\t\t\tint bv2 = *it;\n\t\t\tvector<vi> nbLists;\n\t\t\tif (!blossomBestEdgesUsed[bv2]) {\n\t\t\t\tBlossomLeaves bl2(this, bv2);\n\t\t\t\tfor (int v2; bl2.next(v2); ) {\n\t\t\t\t\tnbLists.push_back(neighbEnd[v2]);\n\t\t\t\t\tvi &vv = nbLists.back();\n\t\t\t\t\teach(i, vv)\n\t\t\t\t\t\t*i /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnbLists.push_back(blossomBestEdges[bv2]);\n\t\t\t}\n\t\t\teach(itt, nbLists) {\n\t\t\t\teach(ittt, *itt) {\n\t\t\t\t\tint k2 = *ittt;\n\t\t\t\t\tEdge &e2 = edges[k2];\n\t\t\t\t\tint i = e2.src, j = e2.dst;\n\t\t\t\t\tif (inBlossom[j] == b)\n\t\t\t\t\t\tswap(i, j);\n\t\t\t\t\tint bj = inBlossom[j];\n\t\t\t\t\tif (bj != b && label[bj] == 1 &&\n\t\t\t\t\t\t(bestEdgeTo[bj] == -1 ||\n\t\t\t\t\t\t\tslack(k2) < slack(bestEdgeTo[bj]))) {\n\t\t\t\t\t\tbestEdgeTo[bj] = k2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tblossomBestEdgesUsed[bv2] = false;\n\t\t\tblossomBestEdges[bv2].clear();\n\t\t\tbestEdge[bv2] = -1;\n\t\t}\n\t\tblossomBestEdgesUsed[b] = true;\n\t\tblossomBestEdges[b].clear();\n\t\teach(it, bestEdgeTo)\n\t\t\tif (*it != -1)\n\t\t\t\tblossomBestEdges[b].push_back(*it);\n\t\tbestEdge[b] = -1;\n\t\teach(it, blossomBestEdges[b])\n\t\t\tif (bestEdge[b] == -1 || slack(*it) < slack(bestEdge[b]))\n\t\t\t\tbestEdge[b] = *it;\n\t}\n\tvoid expandBlossom(int b, bool endStage) {\n\t\tint cSize = blossomChilds[b].size();\n\t\teach(it, blossomChilds[b]) {\n\t\t\tint s = *it;\n\t\t\tblossomParent[s] = -1;\n\t\t\tif (s < nVertex)\n\t\t\t\tinBlossom[s] = s;\n\t\t\telse if (endStage && dualVar[s] == 0)\n\t\t\t\texpandBlossom(s, endStage);\n\t\t\telse {\n\t\t\t\tBlossomLeaves bl(this, s);\n\t\t\t\tfor (int v; bl.next(v); )\n\t\t\t\t\tinBlossom[v] = s;\n\t\t\t}\n\t\t}\n\t\tif (!endStage && label[b] == 2) {\n\t\t\tint entryChild = inBlossom[endPoint[labelEdge[b] ^ 1]];\n\t\t\tint j = find(all(blossomChilds[b]), entryChild) - blossomChilds[b].begin();\n\t\t\tint jStep, evenOdd;\n\t\t\tif (j & 1)\n\t\t\t\tjStep = 1, evenOdd = 0;\n\t\t\telse\n\t\t\t\tjStep = -1, evenOdd = 1;\n\t\t\tint p = labelEdge[b];\n\t\t\twhile (j != 0) {\n\t\t\t\tlabel[endPoint[p ^ 1]] = 0;\n\t\t\t\tlabel[endPoint[blossomEdges[b][j - evenOdd] ^ evenOdd ^ 1]] = 0;\n\t\t\t\tassignLabel(endPoint[p ^ 1], 2, p);\n\t\t\t\tallowEdge[blossomEdges[b][j - evenOdd] / 2] = true;\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t\tp = blossomEdges[b][j - evenOdd] ^ evenOdd;\n\t\t\t\tallowEdge[p / 2] = true;\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t}\n\t\t\tint bv = blossomChilds[b][j];\n\t\t\tlabel[endPoint[p ^ 1]] = label[bv] = 2;\n\t\t\tlabelEdge[endPoint[p ^ 1]] = labelEdge[bv] = p;\n\t\t\tbestEdge[bv] = -1;\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\twhile (blossomChilds[b][j] != entryChild) {\n\t\t\t\tbv = blossomChilds[b][j];\n\t\t\t\tif (label[bv] == 1) {\n\t\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBlossomLeaves bl(this, bv);\n\t\t\t\tint v;\n\t\t\t\twhile (bl.next(v))\n\t\t\t\t\tif (label[v] != 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (label[v] != 0) {\n\t\t\t\t\tlabel[v] = 0;\n\t\t\t\t\tlabel[endPoint[mate[blossomBase[bv]]]] = 0;\n\t\t\t\t\tassignLabel(v, 2, labelEdge[v]);\n\t\t\t\t}\n\t\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\t}\n\t\t}\n\t\tlabel[b] = labelEdge[b] = -1;\n\t\tblossomChilds[b].clear();\n\t\tblossomEdges[b].clear();\n\t\tblossomBestEdgesUsed[b] = false;\n\t\tblossomBestEdges[b].clear();\n\t\tbestEdge[b] = -1;\n\t\tunusedBlossoms.push_back(b);\n\t}\n\tvoid augmentBlossom(int b, int v) {\n\t\tint cSize = blossomChilds[b].size();\n\t\tint t = v;\n\t\twhile (blossomParent[t] != b)\n\t\t\tt = blossomParent[t];\n\t\tif (t >= nVertex)\n\t\t\taugmentBlossom(t, v);\n\t\tint i, j, jStep, evenOdd;\n\t\ti = j = find(all(blossomChilds[b]), t) - blossomChilds[b].begin();\n\t\tif (i & 1)\n\t\t\tjStep = 1, evenOdd = 0;\n\t\telse\n\t\t\tjStep = -1, evenOdd = 1;\n\t\twhile (j != 0) {\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\tt = blossomChilds[b][j];\n\t\t\tint p = blossomEdges[b][j - evenOdd] ^ evenOdd;\n\t\t\tif (t >= nVertex)\n\t\t\t\taugmentBlossom(t, endPoint[p]);\n\t\t\tj = (j + jStep + cSize) % cSize;\n\t\t\tt = blossomChilds[b][j];\n\t\t\tif (t >= nVertex)\n\t\t\t\taugmentBlossom(t, endPoint[p ^ 1]);\n\t\t\tmate[endPoint[p]] = p ^ 1;\n\t\t\tmate[endPoint[p ^ 1]] = p;\n\t\t}\n\t\trotate(blossomChilds[b].begin(), blossomChilds[b].begin() + i, blossomChilds[b].end());\n\t\trotate(blossomEdges[b].begin(), blossomEdges[b].begin() + i, blossomEdges[b].end());\n\t\tblossomBase[b] = blossomBase[blossomChilds[b][0]];\n\t}\n\tvoid augmentMatching(int k) {\n\t\tEdge &e = edges[k];\n\t\tint v = e.src, w = e.dst;\n\t\trep(ii, 2) {\n\t\t\tint s = ii == 0 ? v : w, p = ii == 0 ? 2 * k + 1 : 2 * k;\n\t\t\twhile (true) {\n\t\t\t\tint bs = inBlossom[s];\n\t\t\t\tif (bs >= nVertex)\n\t\t\t\t\taugmentBlossom(bs, s);\n\t\t\t\tmate[s] = p;\n\t\t\t\tif (labelEdge[bs] == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tint bt = inBlossom[endPoint[labelEdge[bs]]];\n\t\t\t\ts = endPoint[labelEdge[bt]];\n\t\t\t\tint j = endPoint[labelEdge[bt] ^ 1];\n\t\t\t\tif (bt >= nVertex)\n\t\t\t\t\taugmentBlossom(bt, j);\n\t\t\t\tmate[j] = labelEdge[bt];\n\t\t\t\tp = labelEdge[bt] ^ 1;\n\t\t\t}\n\t\t}\n\t}\n\tvoid mainLoop() {\n\t\trep(t, nVertex) {\n\t\t\tlabel.assign(2 * nVertex, 0);\n\t\t\tbestEdge.assign(2 * nVertex, -1);\n\t\t\tfill(blossomBestEdgesUsed.begin() + nVertex, blossomBestEdgesUsed.end(), false);\n\t\t\tallowEdge.assign(nEdge, false);\n\t\t\tsVerteices.clear();\n\t\t\trep(v, nVertex)\n\t\t\t\tif (mate[v] == -1 && label[inBlossom[v]] == 0)\n\t\t\t\t\tassignLabel(v, 1, -1);\n\t\t\tbool augmented = false;\n\t\t\twhile (true) {\n\t\t\t\tWeight kSlack;\n\t\t\t\twhile (!sVerteices.empty() && !augmented) {\n\t\t\t\t\tint v = sVerteices.back(); sVerteices.pop_back();\n\t\t\t\t\teach(it, neighbEnd[v]) {\n\t\t\t\t\t\tint p = *it;\n\t\t\t\t\t\tint k = p / 2, w = endPoint[p];\n\t\t\t\t\t\tif (inBlossom[v] == inBlossom[w])\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!allowEdge[k]) {\n\t\t\t\t\t\t\tkSlack = slack(k);\n\t\t\t\t\t\t\tif (kSlack <= 0)\n\t\t\t\t\t\t\t\tallowEdge[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (allowEdge[k]) {\n\t\t\t\t\t\t\tif (label[inBlossom[w]] == 0) {\n\t\t\t\t\t\t\t\tassignLabel(w, 2, p ^ 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (label[inBlossom[w]] == 1) {\n\t\t\t\t\t\t\t\tint base = scanBlossom(v, w);\n\t\t\t\t\t\t\t\tif (base >= 0) {\n\t\t\t\t\t\t\t\t\taddBlossom(base, k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\taugmentMatching(k);\n\t\t\t\t\t\t\t\t\taugmented = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (label[w] == 0) {\n\t\t\t\t\t\t\t\tlabel[w] = 2;\n\t\t\t\t\t\t\t\tlabelEdge[w] = p ^ 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[inBlossom[w]] == 1) {\n\t\t\t\t\t\t\tint b = inBlossom[v];\n\t\t\t\t\t\t\tif (bestEdge[b] == -1 || kSlack < slack(bestEdge[b]))\n\t\t\t\t\t\t\t\tbestEdge[b] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[w] == 0) {\n\t\t\t\t\t\t\tif (bestEdge[w] == -1 || kSlack < slack(bestEdge[w]))\n\t\t\t\t\t\t\t\tbestEdge[w] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (augmented)\n\t\t\t\t\tbreak;\n\t\t\t\tint deltaType = -1;\n\t\t\t\tWeight delta;\n\t\t\t\tint deltaEdge, deltaBlossom;\n\t\t\t\tif (!maxCardinality) {\n\t\t\t\t\tdeltaType = 1;\n\t\t\t\t\tdelta = *min_element(dualVar.begin(), dualVar.begin() + nVertex);\n\t\t\t\t}\n\t\t\t\trep(v, nVertex) {\n\t\t\t\t\tif (label[inBlossom[v]] == 0 && bestEdge[v] != -1) {\n\t\t\t\t\t\tWeight d = slack(bestEdge[v]);\n\t\t\t\t\t\tif (deltaType == -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltaType = 2;\n\t\t\t\t\t\t\tdeltaEdge = bestEdge[v];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(b, 2 * nVertex) {\n\t\t\t\t\tif (blossomParent[b] == -1 && label[b] == 1 && bestEdge[b] != -1) {\n\t\t\t\t\t\tkSlack = slack(bestEdge[b]);\n\t\t\t\t\t\tWeight d = kSlack / 2;\n\t\t\t\t\t\tif (deltaType == -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltaType = 3;\n\t\t\t\t\t\t\tdeltaEdge = bestEdge[b];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treu(b, nVertex, 2 * nVertex) {\n\t\t\t\t\tif (blossomBase[b] >= 0 && blossomParent[b] == -1 &&\n\t\t\t\t\t\tlabel[b] == 2 &&\n\t\t\t\t\t\t(deltaType == -1 || dualVar[b] < delta)) {\n\t\t\t\t\t\tdelta = dualVar[b];\n\t\t\t\t\t\tdeltaType = 4;\n\t\t\t\t\t\tdeltaBlossom = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deltaType == -1) {\n\t\t\t\t\tdeltaType = 1;\n\t\t\t\t\tdelta = max((Weight)0, *min_element(dualVar.begin(), dualVar.begin() + nVertex));\n\t\t\t\t}\n\t\t\t\trep(v, nVertex) {\n\t\t\t\t\tif (label[inBlossom[v]] == 1) {\n\t\t\t\t\t\tdualVar[v] -= delta;\n\t\t\t\t\t}\n\t\t\t\t\telse if (label[inBlossom[v]] == 2) {\n\t\t\t\t\t\tdualVar[v] += delta;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treu(b, nVertex, 2 * nVertex) {\n\t\t\t\t\tif (blossomBase[b] >= 0 && blossomParent[b] == -1) {\n\t\t\t\t\t\tif (label[b] == 1) {\n\t\t\t\t\t\t\tdualVar[b] += delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (label[b] == 2) {\n\t\t\t\t\t\t\tdualVar[b] -= delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deltaType == 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 2) {\n\t\t\t\t\tallowEdge[deltaEdge] = true;\n\t\t\t\t\tEdge &e = edges[deltaEdge];\n\t\t\t\t\tint i = e.src, j = e.dst;\n\t\t\t\t\tif (label[inBlossom[i]] == 0)\n\t\t\t\t\t\tswap(i, j);\n\t\t\t\t\tsVerteices.push_back(i);\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 3) {\n\t\t\t\t\tallowEdge[deltaEdge] = true;\n\t\t\t\t\tEdge &e = edges[deltaEdge];\n\t\t\t\t\tint i = e.src;\n\t\t\t\t\tsVerteices.push_back(i);\n\t\t\t\t}\n\t\t\t\telse if (deltaType == 4) {\n\t\t\t\t\texpandBlossom(deltaBlossom, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!augmented)\n\t\t\t\tbreak;\n\t\t\treu(b, nVertex, 2 * nVertex)\n\t\t\t\tif (blossomParent[b] == -1 && blossomBase[b] >= 0 &&\n\t\t\t\t\tlabel[b] == 1 && dualVar[b] == 0)\n\t\t\t\t\texpandBlossom(b, true);\n\t\t}\n\t}\n\tvi matching(const Edges& edges_, bool maxCardinality_ = false) {\n\t\tedges = edges_; maxCardinality = maxCardinality_;\n\t\tnEdge = edges.size();\n\t\tnVertex = 0;\n\t\teach(i, edges) {\n\t\t\tif (i->src >= nVertex) nVertex = i->src + 1;\n\t\t\tif (i->dst >= nVertex) nVertex = i->dst + 1;\n\t\t}\n\t\tmaxWeight = 0;\n\t\tendPoint.clear();\n\t\tneighbEnd.assign(nVertex, vi());\n\t\trep(i, nEdge) {\n\t\t\tEdge &e = edges[i];\n\t\t\tmaxWeight = max(maxWeight, e.weight);\n\t\t\tendPoint.push_back(e.src);\n\t\t\tendPoint.push_back(e.dst);\n\t\t\tneighbEnd[e.src].push_back(2 * i + 1);\n\t\t\tneighbEnd[e.dst].push_back(2 * i);\n\t\t}\n\t\tmate.assign(nVertex, -1);\n\t\tlabel.assign(2 * nVertex, 0);\n\t\tlabelEdge.assign(2 * nVertex, -1);\n\t\tinBlossom.clear();\n\t\tblossomBase.clear();\n\t\tblossomParent.assign(2 * nVertex, -1);\n\t\tblossomChilds.assign(2 * nVertex, vi());\n\t\tblossomEdges.assign(2 * nVertex, vi());\n\t\tbestEdge.assign(2 * nVertex, -1);\n\t\tblossomBestEdgesUsed.assign(2 * nVertex, false);\n\t\tblossomBestEdges.assign(2 * nVertex, vi());\n\t\tunusedBlossoms.clear();\n\t\tdualVar.clear();\n\t\trep(i, nVertex)\n\t\t\tinBlossom.push_back(i),\n\t\t\tblossomBase.push_back(i),\n\t\t\tunusedBlossoms.push_back(nVertex + i),\n\t\t\tdualVar.push_back(maxWeight);\n\t\trep(i, nVertex)\n\t\t\tblossomBase.push_back(-1),\n\t\t\tdualVar.push_back(0);\n\t\tallowEdge.assign(nEdge, 0);\n\t\tsVerteices = vi();\n\t\tmainLoop();\n\t\trep(v, nVertex)\n\t\t\tif (mate[v] >= 0)\n\t\t\t\tmate[v] = endPoint[mate[v]];\n\t\treturn mate;\n\t}\n\tWeight getWeight(const Edges& e, bool maxCardinality_ = false) {\n\t\tvector<int> v = matching(e, maxCardinality_);\n\t\tWeight w = 0;\n\t\trep(i, v.size()) if (v[i] != -1)\n\t\t\teach(j, e) if (i == j->src && j->dst == v[i]) w += j->weight;\n\t\treturn w;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, A, B; cin >> N >> A >> B;\n\tvector<int> a(N), b(N); for (int i = 0; i < N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t}\n\n\tint ans = 0;\n\tvector<bool> used(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (abs(a[i] - b[i]) <= A || (abs(a[i] - b[i]) >= B&&abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tans++;\n\t\t\tused[i] = true;\n\t\t\tdump(i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\tEdges edges;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (used[i])continue;\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (used[j])continue;\n\t\t\tdump(i, j, abs(a[i] + a[j] - b[i] - b[j]));\n\t\t\tif (abs(a[i] + a[j] - b[i] - b[j]) <= A || (abs(a[i] + a[j] - b[i] - b[j]) >= B&&abs(a[i] + a[j] - b[i] - b[j]) <= 2 * A)) {\n\t\t\t\tedges.emplace_back(i, j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tMaxWeightMatching mwm;\n\tans += mwm.getWeight(edges);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MOD = 10007;\nlong long mod(long long a, int m) {\n    return (a % m + m) % m;\n}\ninline long long inv(long long a, int m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    return mod(u, m);\n}\n\ntemplate<class T> struct Matrix {\n    vector<vector<T> > val;\n    Matrix(int n = 1, int m = 1) {val.clear(); val.resize(n, vector<T>(m));}\n    Matrix(int n, int m, T x) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void init(int n, int m, T x = 0) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void resize(int n, int m, T x = 0) {val.resize(n); for (int i = 0; i < n; ++i) val[i].resize(m, x);}\n    int size() {return val.size();}\n    inline vector<T>& operator [] (int i) {return val[i];}\n    friend ostream& operator << (ostream& s, Matrix<T> M) {s << endl; \n        for (int i = 0; i < M.val.size(); ++i) s << M[i] << endl; return s;}\n};\n\ntemplate<class T> int Rank(Matrix<T> A, int p) {\n\tint rank = 0;\n\t/*\n    for (int i = 0; i < A.size(); ++i) \n        for (int j = 0; j < A[0].size(); ++j)\n            A[i][j] = mod(A[i][j], p);\n\t*/\n    \n\tT res = 1;\n\tfor (int i = 0; i < A[0].size(); ++i) {\n\t\tint pivot = rank;\n        bool exist = false;\n        for (int j = rank; j < A.size(); ++j) {\n            if (A[j][i] != 0) {\n                pivot = j;\n                exist = true;\n                break;\n            }\n        }\n\t\tif (exist) {\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tres = mod(res * A[rank][i], p);\n            T ainv = inv(A[rank][i], p);\n\t\t\tvector<T> tmp(A[0].size());\n            for (int j = 0; j < A[0].size(); ++j) {\n                tmp[j] = mod(A[rank][j] * ainv, p);\n            }\n\t\t\tfor (int j = 0; j < A.size(); ++j) {\n\t\t\t\tif (j != rank && A[j][i] != 0) {\n                    T fac = A[j][i];\n\t\t\t\t\tfor (int k = 0; k < A[0].size(); ++k) {\n                        A[j][k] = mod(A[j][k] - tmp[k] * fac, p);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rank;\n        }\n        //else return 0;\n\t}\n\n    return rank;\n};\n\n\nunsigned int randInt() {\n    static unsigned int tx = 123456789, ty=362436069, tz=521288629, tw=88675123;\n    unsigned int tt = (tx^(tx<<11));\n    tx = ty; ty = tz; tz = tw;\n    return ( tw=(tw^(tw>>19))^(tt^(tt>>8)) );\n}  \n\nint randInt(int minv, int maxv) {\n    return randInt() % (maxv - minv + 1) + minv;\n}\n\n\nint N, A, B;\nint a[2100], b[2100];\n\nint main() {\n  while (cin >> N >> A >> B) {\n\tfor (int i = 0; i < N; ++i) cin >> a[i] >> b[i];\n\n\tvector<int> dame;\n\tfor (int i = 0; i < N; ++i) {\n\t  if (abs(a[i] - b[i]) <= A\n\t\t  || (abs(a[i]-b[i]) >= B && abs(a[i]-b[i]) <= A*2))\n\t\tcontinue;\n\t  dame.push_back(i);\n\t}\n\n\tif (dame.empty()) {\n\t  cout << N << endl;\n\t  continue;\n\t}\n\n\tint V = dame.size();\n\n\tMatrix<int> M(V, V, 0);\n\tint iter = 0;\n\tfor (int i = 0; i < dame.size(); ++i) {\n\t  for (int j = i + 1; j < dame.size(); ++j) {\n\t\tint u = dame[i], v = dame[j];\n\t\tint dist = abs(a[u] + a[v] - b[u] - b[v]);\n\t\tif (dist <= A || (dist >= B && dist <= A*2)) {\n\t\t  int ran = randInt(1, MOD-1);\n\t\t  M[i][j] = ran;\n\t\t  M[j][i] = MOD - ran;\n\t\t}\n\t  }\n\t}\n\n\t/*\n\tCOUT(dame);\n\tCOUT(M);\n\t*/\n\n\tint rank = Rank(M, MOD);\n\n\t//COUT(rank);\n\t\n\tint res = rank/2 + (N - (int)dame.size());\n\tcout << res << endl;\n\t//COUT(single); \n\n\t/*\n\tMatrix<int> M(V, V, 0);\n\tfor (int i = 0; i < single.size(); ++i) {\n\t  int u = single[i];\n\t  int v = N + i;\n\t  int ran = randInt(1, MOD-1);\n\t  M[u][v] = ran;\n\t  M[v][u] = MOD - ran;\n\t}\n\t\n\t\n\t//Matrix<int> M(N, N, 0);\n\tfor (int i = 0; i < N; ++i) {\n\t  for (int j = i+1; j < N; ++j) {\n\t\tint dist = abs(a[i] + a[j] - b[i] - b[j]);\n\t\tif (dist <= A || (dist >= B && dist <= A*2)) {\n\t\t  int ran = randInt(1, MOD-1);\n\t\t  M[i][j] = ran;\n\t\t  M[j][i] = MOD - ran;\n\t\t}\n\t  }\n\t}\n\t\n\n\t//COUT(M);\n\n\tint res = Rank(M, MOD);\n\t//COUT(res);\n\n\t*/\n  }\n   \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\n//最大フロー\nconst int MAX_N = 810, MAX_K = 810;\nconst int MAX_V = 810 * 810;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n//vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//二部マッチング\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nint n, a, b;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> a >> b;\n    N = n; K = n;\n    vector<int> c(n);\n    rep(i, 0, n){\n        int p, q;\n        cin >> p >> q;\n        c[i] = p - q;\n    }\n    int ans = 0;\n    vector<bool> f(n); \n    rep(i, 0, n){\n        if(abs(c[i]) <= a || (b <= abs(c[i]) && abs(c[i]) <= 2 * a)){\n            can[i][i] = true;\n            ans++;\n            f[i] = true;\n        }\n        rep(j, i + 1, n){\n            if(abs(c[i] + c[j]) <= a || (b <= abs(c[i] + c[j]) && abs(c[i] + c[j]) <= 2 * a)){\n                can[i][j] = true;\n                can[j][i] = true;                \n            }\n        }\n    }\n    // rep(i, 0, n){\n    //     rep(j, 0, n){\n    //         cout << can[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    rep(i, 0, n){\n        rep(j, 0, n){\n            if(f[i]){\n                can[i][j] = false;\n            }\n        }\n    }\n    int tmp = solve();\n    ans += tmp / 2;\n    cout << ans << endl;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nclass MaximumMatching {\n  /*\n  Maximum Matching in General Graphs\n  - O(nm \\log_{\\max\\{2, 1 + m/n\\}} n) time\n  - O(n + m) space\n  Note: each vertex is 1-indexed.\n  */\n\npublic:\n    struct Edge { int from, to; Edge() {} Edge(int a, int b) : from(a), to(b) {} };\n\n  MaximumMatching(int N, const vector<Edge>& raw_edges) : n(N) {\n    ofs.assign(N + 2, 0);\n    for (auto& e : raw_edges) ++ofs[e.from + 1], ++ofs[e.to + 1];\n    for (int i = 1; i <= N + 1; ++i) ofs[i] += ofs[i - 1];\n    edges.resize(2 * raw_edges.size());\n    for (auto& e : raw_edges) {\n      edges[ofs[e.from]++] = {e.from, e.to};\n      edges[ofs[e.to]++] = {e.to, e.from};\n    }\n    for (int i = N + 1; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  int maximum_matching() {\n    vector<int> label(n + 1, -1), mate(n + 1, 0), first(n + 1, 0);\n    vector<int> que(n);\n    int qh = 0, qt = 0;\n\n    auto enqueue = [&] (int v) { que[qt++] = v; };\n    auto dequeue = [&] { return que[qh++]; };\n    auto encode = [&] (int eid) { return (n + 1) + eid; };\n    auto decode = [&] (int h) { return h - (n + 1); };\n\n    function< int(int) > find_first = [&] (int v) {\n      return label[first[v]] < 0 ? first[v] : first[v] = find_first(first[v]);\n    };\n\n    function< void(int, int) > rematch = [&] (int v, int w) {\n      auto t = mate[v]; mate[v] = w;\n      if (mate[t] != v) return;\n      if (label[v] <= n) {\n        mate[t] = label[v];\n        rematch(label[v], t);\n      } else {\n        auto& e = edges[decode(label[v])];\n        int x = e.from, y = e.to;\n        rematch(x, y); rematch(y, x);\n      }\n    };\n\n    auto contract = [&] (int x, int y, int eid) {\n      int r = find_first(x), s = find_first(y);\n      if (r == s) return;\n      auto h = encode(eid);\n      label[r] = label[s] = -h;\n      int join = -1; // mate[lca]\n      while (1) {\n        if (s != 0) swap(r, s);\n        r = find_first(label[mate[r]]);\n        if (label[r] == -h) {\n          join = r;\n          break;\n        } else label[r] = -h;\n      }\n      for (auto v : { first[x], first[y] }) {\n        for (; v != join; v = first[label[mate[v]]]) {\n          label[v] = h;\n          first[v] = join;\n          enqueue(v);\n        }\n      }\n    };\n\n    auto augmented = [&] (int u) {\n      label[u] = first[u] = 0;\n      for (qh = qt = 0, enqueue(u); qh < qt; ) {\n        auto x = dequeue();\n        for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n          auto y = edges[eid].to;\n          if (mate[y] == 0 && y != u) {\n            mate[y] = x;\n            rematch(x, y);\n            return true;\n          } else if (label[y] >= 0) {\n            contract(x, y, eid);\n          } else if (label[mate[y]] < 0) {\n            label[mate[y]] = x;\n            first[mate[y]] = y;\n            enqueue(mate[y]);\n          }\n        }\n      }\n      return false;\n    };\n\n    int match = 0;\n    for (int u = 1; u <= n; ++u) if (mate[u] == 0 && augmented(u)) {\n      match += 1;\n      if (n - 2 * match <= 1) break;\n      if (10 * qt < n) {\n        label[0] = -1;\n        for (int qi = 0; qi < qt; ++qi) {\n          label[que[qi]] = label[mate[que[qi]]] = -1;\n        }\n      } else fill(label.begin(), label.end(), -1);\n    }\n\n    /*\n    vector< pair<int, int> > matching(match);\n    match = 0;\n    rep(u, 1, N + 1) if (mate[u] > u) {\n      matching[match++] = {u, mate[u]};\n    }\n    */\n\n    return match;\n  }\n\nprivate:\n  int n;\n  vector<int> ofs;\n  vector<Edge> edges;\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, A, B, a[808], b[808];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> A >> B;\n    rep(i, 0, N) cin >> a[i] >> b[i];\n\n    int ans = 0;\n    vector<int> v;\n    \n    // 操作1\n    rep(i, 0, N) {\n        int d = abs(a[i] - b[i]);\n        if (d <= A or (B <= d and d <= 2 * A)) ans++;\n        else v.push_back(i);\n    }\n\n    int n = v.size();\n    if (0 < n) {\n        // 操作2\n        vector<MaximumMatching::Edge> edges;\n        rep(_i, 0, n) rep(_j, 0, n) {\n            int i = v[_i];\n            int j = v[_j];\n            if (i != j) {\n                int d = abs(a[i] + a[j] - b[i] - b[j]);\n                if (d <= A or (B <= d and d <= 2 * A)) {\n                    edges.push_back(MaximumMatching::Edge(_i + 1, _j + 1));\n                }\n            }\n        }\n\n        MaximumMatching bm(n, edges);\n\n        ans += bm.maximum_matching();\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n\n//2部最大マッチング verified AOJ GRL_7_A\n#define MAX_V 800\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// 増大路をDFSで探す\nbool dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i],w=match[u];           //u:vからの移動先の頂点 , w:uとマッチングしている頂点\n        if(w<0 || (!used[w] && dfs(w))){    //uがフリーか、このdfsではwを使っておらず かつwの別のペアが見つかった(=増大路発見) 場合\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int V){\n    int res=0;\n    rep(i,MAX_V)match[i]=-1;\n    rep(v,V){\n        if(match[v]<0){\n            rep(i,MAX_V)used[i]=0;\n            if( dfs(v) ) res++;       //増大路が見つかればres+=1\n        }\n    }\n    return res;\n}\n\nint main(){\n    int ans = 0;\n    int v,a,b;\n    cin>>v>>a>>b;\n    \n    vector<int> s(v),t(v);\n    rep(i,v){\n        cin>>s[i]>>t[i];\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))ans++;\n    }\n    \n    auto g = [](int ai,int bi, int aj, int bj){\n        return abs((ai+aj)-(bi+bj));\n    };\n    \n    rep(i,v){\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))continue;\n        rep(j,v){\n            if(abs(s[j]-t[j])<=a or (b<=abs(s[j]-t[j]) and abs(s[j]-t[j])<=2*a))continue;\n            \n            if(g(s[i],t[i],s[j],t[j])<=a or (b<=g(s[i],t[i],s[j],t[j]) and g(s[i],t[i],s[j],t[j])<=2*a) ){\n                G[i].pb(j);\n            }\n        }\n    }\n    cout<<bipartite_matching(v)+ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// {U}{INT,LONG,LLONG}_{MAX,MIN}\n#define INF         INT_MAX/3\n#define LLINF       LLONG_MAX/3\n#define MOD         (1000000007LL)\n#define MODA(a, b)  a=((a)+(b))%MOD\n#define MODP(a, b)  a=((a)*(b))%MOD\n#define inc(i, l, r)   for(int i=(l);i<(r);i++)\n#define dec(i, l, r)   for(int i=(r)-1;i>=(l);i--)\n#define pb          push_back\n#define se          second\n#define fi          first\n#define mset(a, b)  memset(a, b, sizeof(a))\n\nusing LL  = long long;\nusing G   = vector<vector<int>>;\n\nint di[] = {0, -1, 0, 1};\nint dj[] = {1, 0, -1, 0};\n// }}}\n\n// graph flow {{{\ntemplate<class T>\nstruct GF {\n    struct EF {\n        int to;\n        T cap;\n        int rev;\n    };\n\n    int n;\n    vector<vector<EF>> e;\n\n    GF() {}\n    GF(int n) {\n        this->n = n;\n        e.resize(n);\n    }\n\n    void add(int from, int to, T cap) {\n        e[from].push_back({to, cap, int(e[to].size())});\n        e[to].push_back({from, 0, int(e[from].size()-1)});\n    }\n};\n\n\n// 最大流 (Ford-Fulkerson) {{{\n// O(FE)\n// verified AOJ GRL_6_A\ntemplate<class T>\nstruct MF {\n    GF<T> g;\n    vector<bool> visited;\n\n    MF() {}\n    MF(const GF<T> &g) {\n        this->g = g;\n        visited.resize(g.n, false);\n    };\n\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        visited[v] = true;\n        for(auto &e : g.e[v]){\n            if(!visited[e.to] && e.cap > 0){\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    g.e[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T query(int from, int to) {\n        T flow = 0;\n        while(true){\n            fill(visited.begin(), visited.end(), false);\n            T f = dfs(from, to, INF);\n            if(f == 0) break;\n            flow += f;\n        }\n        return flow;\n    }\n};//}}}\n//}}}\n\nint main() {\n    cin.tie(0);ios::sync_with_stdio(false);\n    int n, A, B;\n    cin >> n >> A >> B;\n    vector<int> a(n), b(n);\n    inc(i, 0, n){\n        cin >> a[i] >> b[i];\n    }\n\n    vector<bool> used(n, false);\n    int ans1 = 0;\n\n    inc(i, 0, n){\n        int d = abs(a[i]-b[i]);\n        if(d <= A || (B <= d && d <= 2*A)){\n            //gf.add(i, n+i, 1);\n            used[i] = true;\n            ans1++;\n        }\n    }\n\n\n    GF<int> gf(2*n+2);\n    inc(i, 0, n){\n        inc(j, 0, n){\n            if(used[i] || used[j]) continue;\n            if(i == j) continue;\n            int d = abs((a[i]+a[j])-(b[i]+b[j]));\n            if(d <= A || (B <= d && d <= 2*A)){\n                gf.add(i, n+j, 1);\n            }\n        }\n    }\n    inc(i, 0, n){\n        gf.add(2*n, i, 1);\n        gf.add(n+i, 2*n+1, 1);\n    }\n    MF<int> mf(gf);\n    int ans2 = mf.query(2*n, 2*n+1)/2;\n\n    cout << ans1+ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nclass BipartiteMatching {\nprivate:\n  int n;\n  vector<vector<int>> graph;\n  vector<int> match;\n  vector<bool> used;\n  bool dfs(int v){\n    used[v] = true;\n    for(int u : graph[v]){\n      int w = match[u];\n      if(w<0 || (!used[w] && dfs(w))){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\npublic:\n  BipartiteMatching(int _n) : n(_n){\n    graph.resize(n);\n    match.resize(n);\n    used.resize(n);\n  }\n  void add_edge(int u, int v){ // 0-indexed\n    graph[u].pb(v);\n    graph[v].pb(u);\n  }\n  int matching(){ // matching size\n    int res = 0;\n    fill(begin(match), end(match), -1);\n    rep(v, n){\n      if(match[v] < 0){\n        fill(begin(used), end(used), false);\n        if(dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,a,b;\n  cin>>n>>a>>b;\n\n  vector<int> c(n);\n  vector<bool> used(n, false);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    c[i] = x-y;\n  }\n\n  auto ok = [&](int x){\n    x = abs(x);\n    return x<=a || (b<=x && x<=2*a);\n  };\n\n  int ans = 0;\n  rep(i,n) if(ok(c[i])) {\n    ans++;\n    used[i] = true;\n  }\n\n  BipartiteMatching match(n);\n  rep(i,n) if(!used[i]) rep(j,i+1,n) if(!used[j]){\n    if(ok(c[i]+c[j])) match.add_edge(i,j);\n  }\n// dbg(ans);\n  cout << ans + match.matching() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n#define MAX_V 1000\nint V;\nVI G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].PB(v);\n  G[v].PB(u);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  REP(i, G[v].size()) {\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V) {\n    if(match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nbool use[805];\nint x[805], y[805];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, a, b;\n  cin >> n >> a >> b;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  int ans = 0;\n  REP(i, n) {\n    if(abs(x[i]-y[i]) <= a || (b <= abs(x[i]-y[i]) && abs(x[i]-y[i]) <= 2*a)) {\n      use[i] = true;\n      ans++;\n      // cout << i << endl;\n    }\n  }\n\n  vector<PII> e;\n  VI v;\n  REP(i, n) FOR(j, i+1, n) {\n    if(use[i] || use[j]) continue;\n    int diff = abs(x[i]+x[j]-y[i]-y[j]);\n    if(diff <= a || (b <= diff && diff <= 2*a)) {\n      e.PB({i, j});\n      v.PB(i); v.PB(j);\n    }\n  }\n\n  VI vv = v;\n  VI trans(n+5);\n  sort(ALL(vv)); vv.erase(unique(ALL(vv)), vv.end());\n  REP(i, v.size()) {\n    v[i] = lower_bound(ALL(vv), vv[i]) - vv.begin();\n    trans[vv[i]] = v[i];\n  }\n\n  V = vv.size();\n  REP(i, e.size()) add_edge(trans[e[i].first], trans[e[i].second]);\n\n  cout << ans + bipartite_matching() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\n//最大フロー\nconst int MAX_N = 510, MAX_K = 510;\nconst int MAX_V = 510 * 510;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n//vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//二部マッチング\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nint n, a, b;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> a >> b;\n    N = n; K = n;\n    vector<int> c(n);\n    rep(i, 0, n){\n        int p, q;\n        cin >> p >> q;\n        c[i] = p - q;\n    }\n    int ans = 0;\n    vector<bool> f(n); \n    rep(i, 0, n){\n        if(abs(c[i]) <= a || (b <= abs(c[i]) && abs(c[i]) <= 2 * a)){\n            can[i][i] = true;\n            ans++;\n            f[i] = true;\n        }\n        rep(j, i + 1, n){\n            if(abs(c[i] + c[j]) <= a || (b <= abs(c[i] + c[j]) && abs(c[i] + c[j]) <= 2 * a)){\n                can[i][j] = true;\n                can[j][i] = true;                \n            }\n        }\n    }\n    // rep(i, 0, n){\n    //     rep(j, 0, n){\n    //         cout << can[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    rep(i, 0, n){\n        rep(j, 0, n){\n            if(f[i]){\n                can[i][j] = false;\n            }\n        }\n    }\n    int tmp = solve();\n    ans += tmp / 2;\n    cout << ans << endl;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct edge { int to, rev; long long cap; };\n\nbool vis[809]; vector<edge>g[809]; int V, inf = 1000000007;\n\nvoid add_edge(int v1, int v2, long long cost) {\n\tg[v1].push_back(edge{ v2, (int)g[v2].size(), cost });\n\tg[v2].push_back(edge{ v1, (int)g[v1].size() - 1, 0LL });\n}\nlong long find_augment(int pos, int tar, long long curflow) {\n\tif (pos == tar) return curflow;\n\tvis[pos] = true;\n\tfor (edge &e : g[pos]) {\n\t\tif (!vis[e.to] && e.cap > 0) {\n\t\t\tlong long newflow = find_augment(e.to, tar, min(e.cap, curflow));\n\t\t\tif (newflow > 0) {\n\t\t\t\te.cap -= newflow;\n\t\t\t\tg[e.to][e.rev].cap += newflow;\n\t\t\t\treturn newflow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nlong long max_flow(int src, int dst) {\n\tlong long ret = 0;\n\twhile (true) {\n\t\tfill(vis, vis + V, false);\n\t\tlong long res = find_augment(src, dst, inf);\n\t\tif (res == 0) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\n\nint N, A, B, a[810], b[810], cnt; vector<int>X, Y;\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tif (abs(a[i] - b[i]) <= A || (B <= abs(a[i] - b[i]) && abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] - b[i] >= 0) X.push_back(a[i] - b[i]);\n\t\telse Y.push_back(a[i] - b[i]);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (abs(X[i] + Y[j]) <= A || (B <= abs(X[i] + Y[j]) && abs(X[i] + Y[j]) <= 2 * A)) {\n\t\t\t\tadd_edge(i, j + X.size(), 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) add_edge(X.size() + Y.size(), i, 1);\n\tfor (int i = 0; i < Y.size(); i++) add_edge(i + X.size(), X.size() + Y.size() + 1, 1);\n\tV = X.size() + Y.size() + 2;\n\n\tint cnt2 = max_flow(X.size() + Y.size(), X.size() + Y.size() + 1);\n\n\tcout << cnt + cnt2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// General Graph Matching (Gabow-Edmonds)\n//\n// Description:\n//   \n//   For a graph G = (V, E), a matching M is a set of edges\n//   such that any vertex is contained in M at most once.\n//   The matching with maximum cardinality is computed by\n//   the Edmonds blossom algorithm.\n//\n//   This implementation is the Gabow's simplified version\n//   with the lazy update technique to improve the complexity\n//   in sparse graphs.\n//\n//\n// Complexity:\n//\n//   O(n m log n)\n//\n//\n// Verified:\n//\n//   SPOJ ADABLOOM\n//\n//\n// References:\n//   H.Gabow (1976):\n//   An efficient implementation of Edmonds' algorithm for maximum matching on graphs.\n//   Journal of the ACM, vol.23, no.2, pp.221-234.\n//\n//   http://min-25.hatenablog.com/entry/2016/11/21/222625\n//\n//\n\n// g++ -std=c++17 -O3 -fmax-errors=1 -fsanitize=undefined\n#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\nstruct Graph {\n  int n;\n  vector< vector<int> > adj;\n  Graph(int n) : n(n), adj(n) { };\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  vector<int> mate;\n  int maximumMatching() {\n    mate.assign(n+1, n);\n    vector<int> first(n+1, n), que(n);\n    vector<pair<int,int>> label(n+1, make_pair(-1,-1));\n    int head = 0, tail = 0;\n\n    function<void(int,int)> rematch = [&](int v, int w) {\n      int t = mate[v]; mate[v] = w;\n      if (mate[t] != v) return;\n      if (label[v].snd == -1) {\n        mate[t] = label[v].fst;\n        rematch(mate[t], t);\n      } else {\n        int x, y; tie(x, y) = label[v];\n        rematch(x, y); rematch(y, x);\n      }\n    };\n    auto relabel = [&](int x, int y) {\n      function<int(int)> findFirst = [&](int u) {\n        return label[first[u]].fst < 0 ? first[u] :\n               first[u] = findFirst(first[u]);\n      };\n      int r = findFirst(x), s = findFirst(y);\n      if (r == s) return; \n      auto h = make_pair(~x, y);\n      label[r] = label[s] = h;\n      int join;\n      while (1) {\n        if (s != n) swap(r, s);\n        r = findFirst(label[mate[r]].fst);\n        if (label[r] == h) {\n          join = r;\n          break;\n        } else {\n          label[r] = h;\n        }\n      }\n      for (int v: {first[x], first[y]}) {\n        for (; v != join; v = first[label[mate[v]].fst]) {\n          label[v] = make_pair(x, y);\n          first[v] = join;\n          que[tail++] = v;\n        }\n      }\n    };\n    auto augment = [&](int u) {\n      label[u] = make_pair(n, -1);\n      first[u] = n;\n      head = tail = 0;\n      for (que[tail++] = u; head < tail;) {\n        int x = que[head++];\n        for (int y: adj[x]) {\n          if (mate[y] == n && y != u) {\n            mate[y] = x;\n            rematch(x, y);\n            return true; \n          } else if (label[y].fst >= 0) {\n            relabel(x, y);\n          } else if (label[mate[y]].fst == -1) {\n            label[mate[y]].fst = x;\n            first[mate[y]] = y;\n            que[tail++] = mate[y];\n          } \n        }\n      }\n      return false;\n    };\n    int matching = 0;\n    for (int u = 0; u < n; ++u) {\n      if (mate[u] < n || !augment(u)) continue;\n      ++matching;\n      for (int i = 0; i < tail; ++i) \n        label[que[i]] = label[mate[que[i]]] = make_pair(-1,-1);\n      label[n] = make_pair(-1, -1);\n    }\n    return matching;\n  }\n};\n\nvoid SPOJ_ADABLOOM() {\n  int ncase; scanf(\"%d\", &ncase);\n  for (int icase; icase < ncase; ++icase) {\n    int n; scanf(\"%d\", &n);\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) \n      scanf(\"%lld\", &a[i]);\n    random_shuffle(all(a));\n    Graph g(n);\n    for (int i = 0; i < n; ++i) { \n      for (int j = 0; j < n; ++j) {\n        if (a[i] < (a[i] ^ a[j]) && (a[i] ^ a[j]) < a[j]) g.addEdge(i, j);\n      }\n    }\n    cout << g.maximumMatching() << endl;\n  }\n}\n\nint main() {\n    int n,a,b;\n    cin>>n>>a>>b;\n    vp vec;\n    int ans=0;\n    REP(i,n){\n        int x,y;\n        cin>>x>>y;\n        if(abs(x-y)<=a||b<=abs(x-y)&&abs(x-y)<=a*2){\n            ans++;\n        }else{\n            vec.pb(P(x,y));\n        }\n    }\n    int siz=vec.size();\n    Graph g(siz);\n    REP(i,siz){\n        REP(j,i){\n            int t=abs(vec[i].fi+vec[j].fi-vec[i].se-vec[j].se);\n            if(t<=a||b<=t&&t<=a*2){\n                g.addEdge(i,j);\n            }\n        }\n    }\n    cout<<ans+g.maximumMatching()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tvoid init(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint N,A,B;\nint main(){\n\tcin>>N>>A>>B;\n\tvector<int> cs;\n\tint res = 0;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tint c = x-y;\n\t\tif(abs(c)<=A || (B<=abs(c) && abs(c)<=2*A)) res++;\n\t\telse cs.pb(c);\n\t}\n\tN = cs.size();\n\n\tBipartite_matching BM;\n\tBM.init(N);\n\trep(i,N) rep(j,i){\n\t\tint x = abs(cs[i]+cs[j]);\n\t\tif(x<=A || (B<=x&&x<=2*A)) BM.add_edge(i,j);\n\t}\n\tcout<<res+BM.max_matching()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tlong n,a,b,x[10000],y[10000],d[10000];\n\tlong co = 0;\n\n\tcin >> n >> a >> b;\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tint u = 0;\n\t\tu = x[i] - y[i];\n\n\t\tif (u < 0)\n\t\t{\n\t\t\tu = u - u - u;\n\t\t}\n\n\t\tif (u <= a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t\telse if (u >= b && u <= 2 * a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t}\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = 0; j < n; j++)\n\t\t{\n\t\t\tlong u = 0;\n\t\t\tu = (x[i] + x[j]) - (y[i] + y[j]);\n\t\t\tif (u < 0)\n\t\t\t{\n\t\t\t\tu = u - u - u;\n\t\t\t}\n\n\t\t\tif (i != j && d[i] != -1)\n\t\t\t{\n\t\t\t\tif (d[j] != -1)\n\t\t\t\t{\n\t\t\t\t\tif (u <= a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (u >= b && u <= 2 * a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << co << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    VI d;\n    int ans = 0;\n    REP(i,n){\n        int x = in(), y = in();\n        int p = x - y;\n        if (abs(p) <= a || (abs(p) >= b && abs(p) <= 2 * a)) ans++;\n        else d.push_back(p);\n    }\n\n    int m = d.size();\n    bipartite_matching match;\n    match.init(m, m);\n    REP(i,m) REP(j,m) {\n        if (d[i] < 0) continue;\n        if (d[j] > 0) continue;\n        int p = d[i] + d[j];\n        if (abs(p) <= a || (abs(p) >= b && abs(p) <= 2 * a)){\n            match.add_edge(i, j);\n        }\n    }\n\n    // REP(i,m) cout << d[i] << endl;\n\n    ans += match.calc_matching();\n    cout << ans << endl;\n\n    // REP(i,m){\n    //     cout << match.match[i] - m << endl;\n    // }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nsigned main() \n{\n  int n,A,B;\n  cin>>n>>A>>B;\n  int a[801],b[801],c[801];\n  int cnt=0;\n  rep(i,n)\n  {\n    cin>>a[i]>>b[i];\n    int tmp=a[i]-b[i];\n    if(abs(tmp)<=A||(B<=abs(tmp)&&abs(tmp)<=2*A)) cnt++;\n    else c[i]=tmp;\n  }\n  priority_queue<int> nc;\n  priority_queue<int, vector<int>, greater<int> > pc;\n  rep(i,n)\n  {\n    if(c[i]>=0) pc.push(c[i]);\n    else nc.push(c[i]);\n  }\n  \n  while((!pc.empty())&&(!nc.empty()))\n  {\n    int p=pc.top(),n=nc.top();\n    int diff=abs(p+n);\n    if(diff<=A||(B<=diff&&diff<=2*A)) \n    {\n      cnt++;\n      pc.pop();\n      nc.pop();\n    }\n    else \n    {\n      if(p>=n) pc.pop();\n      else nc.pop();\n    }\n  }\n  print(cnt);\n  \n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint match[809], c; bool p[10000009], used[809]; vector<int> g[809];\n\nbool augment(int pos) {\n\tused[pos] = true;\n\tfor (int i : g[pos]) {\n\t\tif (match[i] < 0 || !used[match[i]] && augment(match[i])) {\n\t\t\tmatch[pos] = i;\n\t\t\tmatch[i] = pos;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching() {\n\tint res = 0;\n\tfill(match, match + c, -1);\n\tfor (int i = 0; i < c; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used, used + c, false);\n\t\t\tif (augment(i)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N, A, B, a[810], b[810], cnt; vector<int>X, Y;\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tif (abs(a[i] - b[i]) <= A || (B <= abs(a[i] - b[i]) && abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] - b[i] >= 0) X.push_back(a[i] - b[i]);\n\t\telse Y.push_back(a[i] - b[i]);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (abs(X[i] + Y[j]) <= A || (B <= abs(X[i] + Y[j]) && abs(X[i] + Y[j]) <= 2 * A)) {\n\t\t\t\tg[i].push_back(j + X.size());\n\t\t\t\tg[j + X.size()].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tc = X.size() + Y.size();\n\n\tint cnt2 = bipartite_matching();\n\n\tcout << cnt + cnt2 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  Int x=0;\n  while((1LL<<(x+1))-1<=n) x++;\n  cout<<x<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass Edge {\npublic:\n\tlong long int to;\n\tlong long int max_flow;\n\tlong long int rev;\n};\n\nclass Dinic {\n\tint V;\npublic:\n\tvector<vector<Edge>>edge;\n\tvector<int>depth;\n\tvector<int>index;\n\tDinic(int n) {\n\t\tn++;\n\t\tV = n;\n\t\tedge.resize(V);\n\t\tdepth.resize(V);\n\t\tindex.resize(V);\n\t\treturn;\n\t}\n\tvoid Add_Edge(int l, int r, int max_flow) {\n\t\tedge[l].push_back({ r,max_flow,(int)edge[r].size() });\n\t\tedge[r].push_back({ l,0,(int)edge[l].size() - 1 });\n\t\treturn;\n\t}\n\tvoid Check_Depth(int s) {\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tdepth[i] = INT_MAX;\n\t\t}\n\t\tdepth[s] = 0;\n\t\tqueue<int>Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (auto i : edge[cn]) {\n\t\t\t\tif (i.max_flow > 0 && depth[i.to] == INT_MAX) {\n\t\t\t\t\tdepth[i.to] = depth[cn] + 1;\n\t\t\t\t\tQ.push(i.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tlong long int max_flow(int v, int g, long long int ret) {\n\t\tif (v == g) {\n\t\t\treturn ret;\n\t\t}\n\t\tfor (int i = index[v]; i < edge[v].size(); i++) {\n\t\t\tif (edge[v][i].max_flow > 0 && depth[v] < depth[edge[v][i].to]) {\n\t\t\t\tlong long int d = max_flow(edge[v][i].to, g, min(ret, edge[v][i].max_flow));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tedge[v][i].max_flow -= d;\n\t\t\t\t\tedge[edge[v][i].to][edge[v][i].rev].max_flow += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tlong long Solve(int s, int g) {\n\t\tlong long int ret = 0;\n\t\twhile (1) {\n\t\t\tCheck_Depth(s);\n\t\t\tif (depth[g] == INT_MAX) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tindex[i] = 0;\n\t\t\t}\n\t\t\tlong long int add = 0;\n\t\t\twhile ((add = max_flow(s, g, INT_MAX)) > 0) {\n\t\t\t\tret += add;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tint ans = 0;\n\tvector<int>a(N);\n\tvector<int>b(N);\n\tvector<bool>flag(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tif (abs(a[i] - b[i]) <= M || (abs(a[i] - b[i]) >= K&&abs(a[i] - b[i]) <= M * 2)) {\n\t\t\tflag[i] = false;\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tflag[i] = true;\n\t\t}\n\t}\n\tDinic d(N + 2);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!flag[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] - b[i] < 0) {\n\t\t\td.Add_Edge(N, i, 1);\n\t\t}\n\t\telse {\n\t\t\td.Add_Edge(i, N + 1, 1);\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (!flag[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint box = abs(a[i] - b[i] + a[j] - b[j]);\n\t\t\tif (box <= M || (box >= K&&box <= M * 2)) {\n\t\t\t\tif (a[i] - b[i] < 0) {\n\t\t\t\t\td.Add_Edge(i, j, 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td.Add_Edge(j, i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += d.Solve(N, N + 1);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MOD = 1000000007;\nlong long mod(long long a, int m) {\n    return (a % m + m) % m;\n}\ninline long long inv(long long a, int m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    return mod(u, m);\n}\n\ntemplate<class T> struct Matrix {\n    vector<vector<T> > val;\n    Matrix(int n = 1, int m = 1) {val.clear(); val.resize(n, vector<T>(m));}\n    Matrix(int n, int m, T x) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void init(int n, int m, T x = 0) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void resize(int n, int m, T x = 0) {val.resize(n); for (int i = 0; i < n; ++i) val[i].resize(m, x);}\n    int size() {return val.size();}\n    inline vector<T>& operator [] (int i) {return val[i];}\n    friend ostream& operator << (ostream& s, Matrix<T> M) {s << endl; \n        for (int i = 0; i < M.val.size(); ++i) s << M[i] << endl; return s;}\n};\n\ntemplate<class T> int Rank(Matrix<T> A, int p) {\n\tint rank = 0;\n    for (int i = 0; i < A.size(); ++i) \n        for (int j = 0; j < A[0].size(); ++j)\n            A[i][j] = mod(A[i][j], p);\n    \n\tT res = 1;\n\tfor (int i = 0; i < A[0].size(); ++i) {\n\t\tint pivot = rank;\n        bool exist = false;\n        for (int j = rank; j < A.size(); ++j) {\n            if (A[j][i] != 0) {\n                pivot = j;\n                exist = true;\n                break;\n            }\n        }\n\t\tif (exist) {\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tres = mod(res * A[rank][i], p);\n            T ainv = inv(A[rank][i], p);\n\t\t\tvector<T> tmp(A[0].size());\n            for (int j = 0; j < A[0].size(); ++j) {\n                tmp[j] = mod(A[rank][j] * ainv, p);\n            }\n\t\t\tfor (int j = 0; j < A.size(); ++j) {\n\t\t\t\tif (j != rank && A[j][i] != 0) {\n                    T fac = A[j][i];\n\t\t\t\t\tfor (int k = 0; k < A[0].size(); ++k) {\n                        A[j][k] = mod(A[j][k] - tmp[k] * fac, p);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rank;\n        }\n        //else return 0;\n\t}\n\n    return rank;\n};\n\n\nunsigned int randInt() {\n    static unsigned int tx = 123456789, ty=362436069, tz=521288629, tw=88675123;\n    unsigned int tt = (tx^(tx<<11));\n    tx = ty; ty = tz; tz = tw;\n    return ( tw=(tw^(tw>>19))^(tt^(tt>>8)) );\n}  \n\nint randInt(int minv, int maxv) {\n    return randInt() % (maxv - minv + 1) + minv;\n}\n\n\nint N, A, B;\nint a[2100], b[2100];\n\nint main() {\n  while (cin >> N >> A >> B) {\n\tfor (int i = 0; i < N; ++i) cin >> a[i] >> b[i];\n\n\tvector<int> single;\n\tfor (int i = 0; i < N; ++i) {\n\t  if (abs(a[i] - b[i]) <= A\n\t\t  || (abs(a[i]-b[i]) >= B && abs(a[i]-b[i]) <= A*2))\n\t\tsingle.push_back(i);\n\t}\n\n\tint add = single.size();\n\tint V = N + add;\n\n\t//COUT(single); \n\n\tMatrix<long long> M(V, V, 0);\n\tfor (int i = 0; i < single.size(); ++i) {\n\t  int u = single[i];\n\t  int v = N + i;\n\t  int ran = randInt(1, MOD-1);\n\t  M[u][v] = ran;\n\t  M[v][u] = MOD - ran;\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t  for (int j = i+1; j < N; ++j) {\n\t\tint dist = abs(a[i] + a[j] - b[i] - b[j]);\n\t\tif (dist <= A || (dist >= B && dist <= A*2)) {\n\t\t  int ran = randInt(1, MOD-1);\n\t\t  M[i][j] = ran;\n\t\t  M[j][i] = MOD - ran;\n\t\t}\n\t  }\n\t}\n\n\t//COUT(M);\n\n\tint res = Rank(M, MOD);\n\t//COUT(res);\n\t\n\tcout << res/2 << endl;\n  }\n   \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n) {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\n\nint main() {\n  int N, A, B, X[800];\n  bool v[800] = {};\n  int ret = 0;\n  cin >> N >> A >> B;\n  for(int i = 0; i < N; i++) {\n    int y;\n    cin >> X[i] >> y;\n    X[i] -= y;\n    if(abs(X[i]) <= A || (B <= abs(X[i]) && abs(X[i]) <= 2 * A)) {\n      v[i] = true;\n      ++ret;\n    }\n  }\n  Bipartite_Matching flow(N);\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    for(int j = 0; j < i; j++) {\n      if(v[j]) continue;\n      if(abs(X[i] + X[j]) <= A || (B <= abs(X[i] + X[j]) && abs(X[i] + X[j]) <= 2 * A)) {\n        flow.add_edge(i, j);\n      }\n    }\n  }\n  cout << flow.bipartite_matching() + ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n////フォード - ファルカーソン法 O(Flow|E|)\n\ntypedef int Weight;\n\nconst Weight INF = 1e9;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int rev_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), rev(rev_), id(id_) { }\n\tEdge(int src_, int dst_, Weight weight_, const int rev_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), rev(rev_) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph&g, int from, int to, int cap)\n{\n\tg[from].push_back(Edge(from, to, cap, (int)g[to].size()));\n\tg[to].push_back(Edge(to, from, 0, (int)g[from].size() - 1));\n}\n//二つを繋ぐ線を完全に消す\nvoid erase_edge(Graph&g, const  int from, const int to) {\n\tg[from].erase(remove_if(g[from].begin(), g[from].end(), [=](const Edge&e) {return e.dst == to; }), g[from].end());\n\tg[to].erase(remove_if(g[to].begin(), g[to].end(), [=](const Edge&e) {return e.dst == from; }), g[to].end());\n}\nint dfs(vector<int>&used, Graph&g, int now, int t, int f)\n{\n\tif (now == t) {\n\t\treturn f;\n\t}\n\tused[now] = true;\n\tfor (int i = 0; i<g[now].size(); ++i) {\n\t\tEdge &e = g[now][i];\n\t\tif (!used[e.dst] && e.weight>0) {\n\t\t\tint d = dfs(used, g, e.dst, t, min(f, e.weight));\n\t\t\tif (d > 0) {\n\t\t\t\te.weight -= d;\n\t\t\t\tg[e.dst][e.rev].weight += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nWeight fold_falc(Graph g, const int start, const int goal) {\n\tWeight ans = 0;\n\twhile (1) {\n\t\tvector<int>used(g.size());\n\t\tint flow = dfs(used, g, start, goal, INF);\n\t\tif (!flow)return ans;\n\t\telse ans += flow;\n\t}\n}\n\nint main() {\n\tint N,A,B;cin>>N>>A>>B;\n\tvector<vector<int>>sas(2);\n\tint ans=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a, b;cin>>a>>b;\n\t\tint num=a-b;\n\t\tif ( abs(num)<=A || (B <= abs(num) && abs(num) <= 2 * A)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tif(num>0)sas[0].push_back(num);\n\t\t\telse sas[1].push_back(-num);\n\t\t}\n\t}\n\tconst int start=0;\n\tconst int zero=1;\n\tconst int one=zero+sas[0].size();\n\tconst int goal=one+sas[1].size();\n\tGraph g(goal+1);\n\n\tfor (int i = 0; i < sas[0].size(); ++i) {\n\t\tadd_edge(g,start,zero+i,1);\n\t}\n\tfor (int i = 0; i < sas[0].size(); ++i) {\n\t\tfor (int j = 0; j < sas[1].size(); ++j) {\n\t\t\tint x=zero+i;\n\t\t\tint y=one+j;\n\t\t\tint num=i-j;\n\n\t\t\tif ( abs(num)<=A || (B <= (abs(num)) && (abs(num)) <= 2 * A)) {\n\t\t\t\tadd_edge(g,x,y,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < sas[1].size(); ++i) {\n\t\tadd_edge(g, one+i, goal, 1);\n\t}\n\n\tans+=fold_falc(g,start,goal);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n\n//2部最大マッチング verified AOJ GRL_7_A\n#define MAX_V 800\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// 増大路をDFSで探す\nbool dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i],w=match[u];           //u:vからの移動先の頂点 , w:uとマッチングしている頂点\n        if(w<0 || (!used[w] && dfs(w))){    //uがフリーか、このdfsではwを使っておらず かつwの別のペアが見つかった(=増大路発見) 場合\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int V){\n    int res=0;\n    rep(i,MAX_V)match[i]=-1;\n    rep(v,V){\n        if(match[v]<0){\n            rep(i,MAX_V)used[i]=0;\n            if( dfs(v) ) res++;       //増大路が見つかればres+=1\n        }\n    }\n    return res;\n}\n\nint main(){\n    int ans = 0;\n    int v,a,b;\n    cin>>v>>a>>b;\n    \n    vector<int> s(v),t(v);\n    rep(i,v){\n        cin>>s[i]>>t[i];\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))ans++;\n    }\n    \n    auto g = [](int ai,int bi, int aj, int bj){\n        return abs((ai+aj)-(bi+bj));\n    };\n    \n    rep(i,v){\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))continue;\n        rep(j,v){\n            if(abs(s[j]-t[j])<=a or (b<=abs(s[j]-t[j]) and abs(s[j]-t[j])<=2*a))continue;\n            \n            if(g(s[i],t[i],s[j],t[j])<=a or (b<=g(s[i],t[i],s[j],t[j]) and g(s[i],t[i],s[j],t[j])<=2*a) ){\n                G[i].pb(j);\n            }\n        }\n    }\n    cout<<bipartite_matching(v)+ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint main(){\n  int N,A,B;\n  int a,b;\n  int ans=0;\n  vector<int> v;\n  cin>>N>>A>>B;\n  rep(i,N){\n    cin>>a>>b;\n    if(abs(a-b)<=A||(B<=abs(a-b)&&abs(a-b)<=2*A))ans++;\n    else v.pb(a-b);\t\t\t\t   \n  }\n  rep(i,v.size()){\n    if(v[i]==INF)continue;\n    int x=INF,x_index=INF,y=INF,y_index=INF;\n    REP(j,i+1,v.size()){\n      if(v[j]==INF)continue;\n      int c=abs(v[i]+v[j]);\n      if(c<=A&&c<x){\n\tx=c;\n\tx_index=j;\n      }\n      if(B<=c&&c<=2*A&&c<y){\n\ty=c;\n\ty_index=j;\n      }\n    }\n    if(x!=INF){\n      ans++;\n      v[i]=INF;\n      v[x_index]=INF;\n    }else if(y!=INF){\n      ans++;\n      v[i]=INF;\n      v[y_index]=INF;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\nvector<P> v[2];\nint main() {\n\tint n, a, b; cin >> n >> a >> b;\n\tint cnt = 0;\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tint z = abs(x - y);\n\t\tif (z <= a || (b <= z && z <= 2 * a))cnt++;\n\t\telse {\n\t\t\tif (x-y>0) {\n\t\t\t\tv[0].push_back({ x,y });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[1].push_back({ x,y });\n\t\t\t}\n\t\t}\n\t}\n\tint m = v[0].size(); int len = v[1].size();\n\tint sta = m + len, goa = m + len + 1;\n\trep(i, m)add_edge(sta, i, 1);\n\trep(i, len)add_edge(i + m, goa, 1);\n\trep(i, m) {\n\t\trep(j, len) {\n\t\t\tint z = v[0][i].first - v[0][i].second + v[1][j].first - v[1][j].second;\n\t\t\tz = abs(z);\n\t\t\tif (z <= a || (b <= z && z <= 2 * a)) {\n\t\t\t\tadd_edge(i, m + j,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = cnt + max_flow(sta,goa);\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V; //頂点数\nint N;\nvector<int> G[NUM]; //グラフの隣接リスト表現\nint match[NUM]; //マッチングのペア\nbool used[NUM]; //DFSですでに調べたかのフラグ\n//bool have_pair[NUM]; //ペアを既に作ったかのフラグ\nInfo info[800];\n\n//fromとtoを結ぶ辺をグラフに追加する\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\n//増加パスをDFSで探す(node_idのペアを探す)\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)|| //隣接するノードに、まだペアが存在しない\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1; //ペアなしにしておく\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){ //node_idにペアがいない場合\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){ //増加パスが存在する場合\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\tbool check[N];\n\tint tmp,ans = 0;\n\n\t//N件のデータを読み込む\n\tfor(int i = 0; i < N; i++){\n\t\tcheck[i] = false;\n\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tans++;\n\t\t\tcheck[i] = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(check[i])continue;\n\n\t\tfor(int k = i+1; k < N; k++){ //2重計上を防ぐため、自分よりインデックスが大きいもののみ走査\n\t\t\tif(k == i || check[k] == true)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = N;\n\n\tprintf(\"%d\\n\", ans+bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MOD = 10007;\nlong long mod(long long a, int m) {\n    return (a % m + m) % m;\n}\ninline long long inv(long long a, int m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    return mod(u, m);\n}\n\ntemplate<class T> struct Matrix {\n    vector<vector<T> > val;\n    Matrix(int n = 1, int m = 1) {val.clear(); val.resize(n, vector<T>(m));}\n    Matrix(int n, int m, T x) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void init(int n, int m, T x = 0) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void resize(int n, int m, T x = 0) {val.resize(n); for (int i = 0; i < n; ++i) val[i].resize(m, x);}\n    int size() {return val.size();}\n    inline vector<T>& operator [] (int i) {return val[i];}\n    friend ostream& operator << (ostream& s, Matrix<T> M) {s << endl; \n        for (int i = 0; i < M.val.size(); ++i) s << M[i] << endl; return s;}\n};\n\ntemplate<class T> int Rank(Matrix<T> A, int p) {\n\tint rank = 0;\n    for (int i = 0; i < A.size(); ++i) \n        for (int j = 0; j < A[0].size(); ++j)\n            A[i][j] = mod(A[i][j], p);\n    \n\tT res = 1;\n\tfor (int i = 0; i < A[0].size(); ++i) {\n\t\tint pivot = rank;\n        bool exist = false;\n        for (int j = rank; j < A.size(); ++j) {\n            if (A[j][i] != 0) {\n                pivot = j;\n                exist = true;\n                break;\n            }\n        }\n\t\tif (exist) {\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tres = mod(res * A[rank][i], p);\n            T ainv = inv(A[rank][i], p);\n\t\t\tvector<T> tmp(A[0].size());\n            for (int j = 0; j < A[0].size(); ++j) {\n                tmp[j] = mod(A[rank][j] * ainv, p);\n            }\n\t\t\tfor (int j = 0; j < A.size(); ++j) {\n\t\t\t\tif (j != rank && A[j][i] != 0) {\n                    T fac = A[j][i];\n\t\t\t\t\tfor (int k = 0; k < A[0].size(); ++k) {\n                        A[j][k] = mod(A[j][k] - tmp[k] * fac, p);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rank;\n        }\n        //else return 0;\n\t}\n\n    return rank;\n};\n\n\nunsigned int randInt() {\n    static unsigned int tx = 123456789, ty=362436069, tz=521288629, tw=88675123;\n    unsigned int tt = (tx^(tx<<11));\n    tx = ty; ty = tz; tz = tw;\n    return ( tw=(tw^(tw>>19))^(tt^(tt>>8)) );\n}  \n\nint randInt(int minv, int maxv) {\n    return randInt() % (maxv - minv + 1) + minv;\n}\n\n\nint N, A, B;\nint a[2100], b[2100];\n\nint main() {\n  while (cin >> N >> A >> B) {\n\tfor (int i = 0; i < N; ++i) cin >> a[i] >> b[i];\n\n\tvector<int> single;\n\tfor (int i = 0; i < N; ++i) {\n\t  if (abs(a[i] - b[i]) <= A\n\t\t  || (abs(a[i]-b[i]) >= B && abs(a[i]-b[i]) <= A*2))\n\t\tsingle.push_back(i);\n\t}\n\n\tint add = single.size();\n\tint V = N + add;\n\n\t//COUT(single); \n\n\tMatrix<int> M(V, V, 0);\n\tfor (int i = 0; i < single.size(); ++i) {\n\t  int u = single[i];\n\t  int v = N + i;\n\t  int ran = randInt(1, MOD-1);\n\t  M[u][v] = ran;\n\t  M[v][u] = MOD - ran;\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t  for (int j = i+1; j < N; ++j) {\n\t\tint dist = abs(a[i] + a[j] - b[i] - b[j]);\n\t\tif (dist <= A || (dist >= B && dist <= A*2)) {\n\t\t  int ran = randInt(1, MOD-1);\n\t\t  M[i][j] = ran;\n\t\t  M[j][i] = MOD - ran;\n\t\t}\n\t  }\n\t}\n\n\t//COUT(M);\n\n\tint res = Rank(M, MOD);\n\t//COUT(res);\n\t\n\tcout << res/2 << endl;\n  }\n   \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nsigned main() \n{\n  int n,A,B;\n  cin>>n>>A>>B;\n  int a[801],b[801],c[801]={};\n  int cnt=0;\n  rep(i,n)\n  {\n    cin>>a[i]>>b[i];\n    int tmp=a[i]-b[i];\n    if(abs(tmp)<=A||(B<=abs(tmp)&&abs(tmp)<=2*A)) cnt++;\n    else c[i]=tmp;\n  }\n  priority_queue<int, vector<int>, greater<int> > nc;\n  priority_queue<int> pc;\n  rep(i,n)\n  {\n    if(c[i]>0) pc.push(c[i]);\n    else if(c[i]<0) nc.push(c[i]);\n  }\n  \n  while((!pc.empty())&&(!nc.empty()))\n  {\n    int p=pc.top(),n=nc.top();\n    int diff=abs(p+n);\n    if(diff <= A || (B <= diff && diff <= 2 * A)) \n    {\n      cnt++;\n      pc.pop();\n      nc.pop();\n      \n    }\n    else \n    {\n      if(abs(n)<abs(p)) nc.pop();\n      else pc.pop();\n    }\n  }\n  print(cnt);\n  \n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvi g;\n\tpublic:\n\tvi match,used;\n\tbool BM_dfs(int v){\n\t\tused[v]=1;\n\t\tfor(auto u:g[v]){\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&BM_dfs(w)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint BM(){\n\t\tint res=0;\n\t\tmatch=vi(n,-1);\n\t\tfor(int i=0;i<n;i++) if(match[i]<0){\n\t\t\tused=vi(n);\n\t\t\tif(BM_dfs(i)) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n};\n\nint n,A,B;\nvi a,b;\n\nint main(){\n\tcin>>n>>A>>B;\n\ta=b=vi(n);\n\tGraph g(n);\n\tfor(int i=0;i<n;i++) cin>>a[i]>>b[i];\n\tint res=0;\n\tvi c(n);\n\tfor(int i=0;i<n;i++){\n\t\tint t=abs(a[i]-b[i]);\n\t\tif(t<=A||B<=t&&t<=2*A) res++,c[i]++; \n\t}\n\tfor(int i=0;i<n;i++) for(int j=0;j<i;j++) if(!c[i]&&!c[j]){\n\t\tint t=abs(a[i]+a[j]-b[i]-b[j]);\n\t\tif(t<=A||B<=t&&t<=2*A) g.add_edge(i,j);\n\t}\n\tcout<<res+g.BM()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sys/time.h>\n#include <cmath>\n#include <tuple>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\ntemplate<typename T>\nclass Dinic {\n    struct edge {\n        int to;\n        T cap;\n        int rev;\n    };\n\n    const T INF;\n    vector< vector<edge> > graph;\n    vector<T> min_cost;\n    vector<int> iter;\n\n    bool bfs(int s, int t) {\n        min_cost.assign(graph.size(), -1);\n        queue<int> que;\n        min_cost[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int q = que.front();\n            que.pop();\n            for (edge &e : graph[q]) {\n                if (e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[q] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return (min_cost[t] != -1);\n    }\n\n    T dfs(int idx, const int t, T flow) {\n        if (idx == t) return flow;\n        for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    public:\n    Dinic(int n) : INF(numeric_limits<T>::max()/100) {\n        graph.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back((edge){to, cap, static_cast<int>(graph[to].size())});\n        graph[to].push_back((edge){from, 0, static_cast<int>(graph[from].size())-1}); //add reverse edge\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            T f = 0;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n        return flow;\n    }\n};\n\nvoid coloring(vector<int>& c, int n, vector< vector<int> >& es, int nc) {\n    if (c[n] == -1) {\n        c[n] = nc;\n    } else {\n        return;\n    }\n    for (auto&& var : es[n]) {\n        coloring(c, var, es, nc==1 ? 0 : 1);\n    }\n    return;\n}\n\nvoid solve(int N, int A, int B, vector<int> a, vector<int> b) {\n    int ans = 0;\n    vector<bool> used(N, false);\n    for (int i = 0; i < N; i++) {\n        int x = abs(a[i] - b[i]);\n        if ((x<=A) || ((B<=x) && (x<=2*A))) {\n            ans++;\n            used[i] = true;\n        }\n    }\n    /*\n    Dinic<long long> G(N*2 + 2);\n    std::cout << \"2rule\" << std::endl;\n    for (int i = 0; i < N; i++) {\n        G.add_edge(2*N, i, 1);\n        G.add_edge(N+i, 2*N+1, 1);\n    }\n    for (int i = 0; i < N-1; i++) {\n        if (used[i]) {\n            continue;\n        }\n        for (int j = i+1; j < N; j++) {\n            if (used[j]) {\n                continue;\n            }\n            int x = abs(a[i]+a[j]-b[i]-b[j]);\n            if ((x<=A) || ((B<=x)&&(x<=2*A))) {\n                std::cout << a[i] << ' ' << b[i] << ' ' << a[j] << ' ' << b[j] << std::endl;\n                G.add_edge(i, N+j, 1);\n            }\n        }\n    }\n    */\n    Dinic<long long> G(N + 2);\n    vector< vector<int> > es(N);\n    vector< pair<int, int> > g;\n    vector<int> c(N, -1);\n    for (int i = 0; i < N-1; i++) {\n        if (used[i]) {\n            continue;\n        }\n        for (int j = i+1; j < N; j++) {\n            if (used[j]) {\n                continue;\n            }\n            int x = abs(a[i]+a[j]-b[i]-b[j]);\n            if ((x<=A) || ((B<=x)&&(x<=2*A))) {\n                es[i].push_back(j);\n                es[j].push_back(i);\n                g.push_back(make_pair(i, j));\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        coloring(c, i, es, 1);\n    }\n    for (int i = 0; i < g.size(); i++) {\n        if (c[g[i].first] == 1) {\n            G.add_edge(g[i].first, g[i].second, 1);\n        } else {\n            G.add_edge(g[i].second, g[i].first, 1);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        if (c[i] == 1) {\n            G.add_edge(N, i, 1);\n        } else {\n            G.add_edge(i, N+1, 1);\n        }\n    }\n    ans += G.max_flow(N, N+1);\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    int N, A, B;\n\n    std::cin >> N;\n    std::cin >> A;\n    std::cin >> B;\n    vector<int> a(N);\n    vector<int> b(N);\n    for (int i = 0; i < N; i++) {\n        std::cin >> a[i] >> b[i];\n    }\n    solve(N, A, B, a, b);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V; //頂点数\nint N;\nvector<int> G[NUM]; //グラフの隣接リスト表現\nint match[NUM]; //マッチングのペア\nbool used[NUM]; //DFSですでに調べたかのフラグ\n//bool have_pair[NUM]; //ペアを既に作ったかのフラグ\nInfo info[800];\n\n//fromとtoを結ぶ辺をグラフに追加する\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\n//増加パスをDFSで探す(node_idのペアを探す)\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)|| //隣接するノードに、まだペアが存在しない\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1; //ペアなしにしておく\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){ //node_idにペアがいない場合\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){ //増加パスが存在する場合\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\t//N件のデータを読み込む\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t}\n\n\tint tmp,ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tans++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int k = i+1; k < N; k++){ //2重計上を防ぐため、自分よりインデックスが大きいもののみ走査\n\t\t\tif(k == i)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = N;\n\n\tprintf(\"%d\\n\", ans+bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------\n#define FOR(i,j,n) for (int i=(j);i<(n);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REPN(i,n) for (int i=(n);i>=0;i--)\n#define I(n) scanf(\"%d\", &(n))\n#define LL(n) scanf(\"%lld\", &(n))\n#define pb(n) push_back((n))\n#define mp(i,j) make_pair((i),(j))\n#include <bits/stdc++.h>\nusing namespace std;\n\n//------------------------------typedef集\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vpi> vvpi;\ntypedef vector<vvi> vvvi;\ntypedef long long ll;\n\n// dinic\nstruct max_flow {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INT_MAX)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint n,A,B,ai,bi,val,ret;\n//vector<pair<int,pi> > list;\nvi lst;\n\nint main(){\n    I(n); I(A); I(B);\n    REP(i,n){\n        I(ai); I(bi);\n        val = abs(ai-bi);\n        if (val <= A || (B <= val && val <= 2*A) ){\n            ret++;\n        } else {\n            //list.pb( mp (ai-bi, mp(ai,bi) ) ) ;\n            lst.pb(ai-bi);\n        }\n    }\n    sort(lst.begin(),lst.end());\n    int ln = lst.size();\n    int zero = upper_bound(lst.begin(),lst.end(),0) - lst.begin();\n\n    max_flow pair_vanish = max_flow(ln+2);\n    REP(i,zero) pair_vanish.add_edge(0,i+1,1);\n    FOR(i,zero,ln) pair_vanish.add_edge(i+1,ln+1,1);\n\n    REP(i,zero) { FOR(j,zero,ln){\n        val = abs(lst[i]+lst[j]);\n        if (val <= A || (B <= val && val <= 2*A) ) pair_vanish.add_edge(i+1,j+1,1);\n    } }\n\n    cout << ret + pair_vanish.run(0,ln+1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvector<bool>used;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge q={to,cap,int(G[to].size())};\n\t\tG[from].push_back(q);\n\t\tq={from,0,int(G[from].size()-1)};\n\t\tG[to].push_back(q);\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(used[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(int s,int t) {//from s to t,ford_fulkerson\n\t\tint flow=0,f;\n\t\twhile(1){\n\t\t\tused=vector<bool>(n,false);\n\t\t\tf=dfs(s,t,inf);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,a,b;\n\tcin>>n>>a>>b;\n\tvi A,B,in(n);\n\trep(i,n){\n\t\tint q,w;\n\t\tcin>>q>>w;\n\t\tin[i]=q-w;\n\t}\n\tint out=0;\n\trep(i,n)if(abs(in[i])<=a||b<=abs(in[i])&&abs(in[i])<=2*a)out++;\n\telse if(in[i]>0)A.pb(in[i]);\n\telse B.pb(in[i]);\n\t\n\tn=A.size(),m=B.size();\n\tMF mf(2+n+m);\n\tint s=n+m,t=s+1;\n\trep(i,n)mf.add_edge(s,i,1);\n\trep(i,m)mf.add_edge(n+i,t,1);\n\trep(i,n)rep(j,m){\n\t\tint w=abs(A[i]+B[j]);\n\t\tif(w<=a||b<=w&&w<=2*a)mf.add_edge(i,n+j,1);\n\t}\n\tout+=mf.mf(s,t);\n\tcout<<out<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tlong n,a,b,x[100000],y[100000],d[100000];\n\tlong co = 0;\n\n\tcin >> n >> a >> b;\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tint u = 0;\n\t\tu = x[i] - y[i];\n\n\t\tif (u < 0)\n\t\t{\n\t\t\tu = u - u - u;\n\t\t}\n\n\t\tif (u <= a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t\telse if (u >= b && u <= 2 * a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t}\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = 0; j < n; j++)\n\t\t{\n\t\t\tlong u = 0;\n\t\t\tu = (x[i] + x[j]) - (y[i] + y[j]);\n\t\t\tif (u < 0)\n\t\t\t{\n\t\t\t\tu = u - u - u;\n\t\t\t}\n\n\t\t\tif (i != j && d[i] != -1)\n\t\t\t{\n\t\t\t\tif (d[j] != -1)\n\t\t\t\t{\n\t\t\t\t\tif (u <= a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (u >= b && u <= 2 * a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << co << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\n/*\nvector<PII> G[110][1010];\nint main(void){\n\tint32 W, H, N;\n\tcin >> W >> H >> N;\n\tvector<PII> vs(N+1);\n\tvs[0] = {1, 1};\n\tREP(i, N){\n\t\tcin >> vs[i+1].fs >> vs[i+1].sc;\n\t}\n\tvector<vector<int32>> d(110, vector<int32>(1010, INF));\n\td[0][0] = 0;\n\tusing tup = tuple<int32, int32, int32>;\n\tpriority_queue<tup, vector<tup>, greater<tup>> pq;\n\tpq.push(tup(0, 0, 0));\n\tfunction<int32(int32,int32)> dis = [&](int32 a, int32 b){\n\t\treturn abs(vs[a].fs-vs[b].fs)+abs(vs[a].sc-vs[b].sc);\n\t};\n\twhile(pq.size()){\n\t\tint32 v, dd, r;\n\t\ttie(dd, v, r) = pq.top(); pq.pop();\n\t\tif(d[v][r] < dd) continue;\n\t\tREP(i, vs.size()){\n\t\t\tif(i == v) continue;\n\t\t\tint32 rr = max((int32)0, dis(i, v)-r);\n\t\t\tif(d[i][rr] > d[v][r]+rr){\n\t\t\t\td[i][rr] = d[v][r]+rr;\n\t\t\t\tpq.push(tup(d[i][rr], i, rr));\n\t\t\t}\n\t\t}\n\t}\n\tvs.push_back({W, H});\n\tint32 res = INF;\n\tFOR(i, 1, vs.size()-1){\n\t\tREP(j, 1010){\n\t\t\tchmin(res, d[i][j]+max(dis(i, vs.size()-1)-j, (int64)0));\n\t\t}\n\t}\n\tcout << res << endl;\n}\n*/\n\nstruct BiMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n  \n  BiMatch(){}\n  BiMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\nint main(void){\n\tint32 N, A, B;\n\tvector<int32> ele;\n\tcin >> N >> A >> B;\n\tint32 res = 0;\n\tREP(i, N){\n\t\tint32 a, b;\n\t\tcin >> a >> b;\n\t\tif(abs(a-b) <= A || (B<=abs(a-b) && abs(a-b) <= 2*A)){\n\t\t\tres++;\n\t\t}else{\n\t\t\tele.push_back(a-b);\n\t\t}\n\t}\n\tBiMatch bi(ele.size());\n\tREP(i, ele.size()){\n\t\tFOR(j, i+1, ele.size()){\n\t\t\tif(abs(ele[i]+ele[j]) <= A || (B <= abs(ele[i]+ele[j]) && abs(ele[i]+ele[j]) <= 2*A)){\n\t\t\t\tbi.add_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res+bi.build() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct BiMatch{\n  Int L,R;\n  vector<vector<Int> > G;\n  vector<Int> match,level;\n  \n  BiMatch(){}\n  BiMatch(Int L,Int R):L(L),R(R),G(L+R),match(L+R,-1),level(L){}\n  \n  void add_edge(Int u,Int v){\n    G[u].push_back(v+L);\n    G[v+L].push_back(u);\n  }\n  \n  bool bfs(){\n    queue<Int> q;\n    for(Int i=0;i<L;i++){\n      level[i]=-1;\n      if(match[i]<0){\n\tlevel[i]=0;\n\tq.emplace(i);\n      }\n    }\n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      for(Int u:G[v]){\n\tInt w=match[u];\n\tif(w<0) return true;\n\tif(level[w]<0){\n\t  level[w]=level[v]+1;\n\t  q.emplace(w);\n\t}\n      }\n    }\n    return false;\n  }\n\n  bool dfs(Int v){\n    for(Int u:G[v]){\n      Int w=match[u];\n      if(w<0||(level[w]>level[v]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  \n  Int build(){\n    Int res=0;\n    while(bfs())\n      for(Int i=0;i<L;i++)\n\tif(match[i]<0&&dfs(i))\n\t  res++;\n    return res;\n  }\n  \n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,x,y;\n  cin>>n>>x>>y;\n  \n  vector<Int> cn,cp;\n  auto check=[&](Int c){\n    return (abs(c)<=x||(y<=abs(c)&&abs(c)<=x*2));\n  };\n  \n  Int ans=0;\n  for(Int i=0;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    Int c=a-b;\n    if(check(c)){\n      ans++;\n      continue;\n    }\n    if(c<0) cn.emplace_back(c);\n    if(c>0) cp.emplace_back(c);\n  }\n\n  \n  Int p=cn.size(),q=cp.size();\n  BiMatch bm(p,q);\n  for(Int i=0;i<p;i++)\n    for(Int j=0;j<q;j++)\n      if(check(cn[i]+cp[j]))\n\tbm.add_edge(i,j);\n  \n  ans+=bm.build();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct b_match {\n  static const int MAX_V = 1000;\n  int V;\n  VI G[MAX_V], match;\n  vector<bool> used;\n\n  // V要素で初期化\n  b_match(int v_=MAX_V) : V(v_) { match.resize(v_); used.resize(v_); }\n  // 辺u-vを追加する\n  void add_edge(int u, int v) { G[u].PB(v); G[v].PB(u); }\n  // 増加パスの探索\n  bool dfs(int v) {\n    used[v] = true;\n    REP(i, G[v].size()) {\n      int u = G[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  // 二部マッチングを計算\n  int matching() {\n    int res = 0;\n    match.assign(V, -1);\n    REP(v, V) {\n      if(match[v] < 0) {\n        used.assign(V, false);\n        if(dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nbool use[805];\nint x[805], y[805];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, a, b;\n  cin >> n >> a >> b;\n  REP(i, n) cin >> x[i] >> y[i];\n\n  int ans = 0;\n  REP(i, n) {\n    if(abs(x[i]-y[i]) <= a || (b <= abs(x[i]-y[i]) && abs(x[i]-y[i]) <= 2*a)) {\n      use[i] = true;\n      ans++;\n    }\n  }\n\n  b_match m(n);\n  vector<PII> e;\n  VI v;\n  REP(i, n) FOR(j, i+1, n) {\n    if(use[i] || use[j]) continue;\n    int diff = abs(x[i]+x[j]-y[i]-y[j]);\n    if(diff <= a || (b <= diff && diff <= 2*a)) {\n      m.add_edge(i, j);\n    }\n  }\n\n  cout << ans + m.matching() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <vector>\n\nusing namespace std;\n\nclass MaximumMatching {\n  /*\n    Maximum Cardinality Matching in General Graphs.\n    - O(\\sqrt{n} m \\log_{\\max\\{2, 1 + m/n\\}} n) time\n    - O(n + m) space \n    Note: each vertex is 1-indexed.\n    Ref: \n      Harold N. Gabow,\n      \"The Weighted Matching Approach to Maximum Cardinality Matching\" (2017)\n      (https://arxiv.org/abs/1703.03998)\n  */\npublic:\n  struct Edge { int from, to; };\n  static constexpr int Inf = 1 << 30;\n\nprivate:\n  enum Label { \n    kInner = -1, // should be < 0\n    kFree = 0    // should be 0\n  };\n  struct Link { int from, to; };\n  struct Log { int v, par; };\n\n  struct LinkedList {\n    LinkedList() {}\n    LinkedList(int N, int M) : N(N), next(M) { clear(); }\n    void clear() { head.assign(N, -1); }\n    void push(int h, int u) { next[u] = head[h], head[h] = u; }\n    int N;\n    vector<int> head, next;\n  };\n\n  template <typename T>\n  struct Queue {\n    Queue() {}\n    Queue(int N) : qh(0), qt(0), data(N) {}\n    T operator [] (int i) const { return data[i]; }\n    void enqueue(int u) { data[qt++] = u; }\n    int dequeue() { return data[qh++]; }\n    bool empty() const { return qh == qt; }\n    void clear() { qh = qt = 0; }\n    int size() const { return qt; }\n    int qh, qt;\n    vector<T> data;\n  };\n\n  struct DisjointSetUnion {\n    DisjointSetUnion() {}\n    DisjointSetUnion(int N) : par(N) {\n      for (int i = 0; i < N; ++i) par[i] = i;\n    }\n    int find(int u) { return par[u] == u ? u : (par[u] = find(par[u])); }\n    void unite(int u, int v) {\n      u = find(u), v = find(v);\n      if (u != v) par[v] = u;\n    }\n    vector<int> par;\n  };\n\npublic:\n  MaximumMatching(int N, const vector<Edge>& in)\n      : N(N), NH(N >> 1), ofs(N + 2, 0), edges(in.size() * 2) {\n\n    for (auto& e : in) ofs[e.from + 1] += 1, ofs[e.to + 1] += 1;\n    for (int i = 1; i <= N + 1; ++i) ofs[i] += ofs[i - 1];\n    for (auto& e : in) {\n      edges[ofs[e.from]++] = e; edges[ofs[e.to]++] = {e.to, e.from};\n    }\n    for (int i = N + 1; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  int maximum_matching() {\n    initialize();\n    int match = 0;\n    while (match * 2 + 1 < N) {\n      reset_count();\n      bool has_augmenting_path = do_edmonds_search();\n      if (!has_augmenting_path) break;\n      match += find_maximal();\n      clear();\n    }\n    return match;\n  }\n\nprivate:\n  void reset_count() {\n    time_current_ = 0; time_augment_ = Inf;\n    contract_count_ = 0; outer_id_ = 1;\n    dsu_changelog_size_ = dsu_changelog_last_ = 0;\n  }\n\n  void clear() {\n    que.clear();\n    for (int u = 1; u <= N; ++u) potential[u] = 1;\n    for (int u = 1; u <= N; ++u) dsu.par[u] = u;\n    for (int t = time_current_; t <= N / 2; ++t) list.head[t] = -1;\n    for (int u = 1; u <= N; ++u) blossom.head[u] = -1;\n  }\n\n  // first phase\n\n  inline void grow(int x, int y, int z) {\n    label[y] = kInner;\n    potential[y] = time_current_; // visited time\n    link[z] = {x, y}; label[z] = label[x];\n    potential[z] = time_current_ + 1;\n    que.enqueue(z);\n  }\n\n  void contract(int x, int y) {\n    int bx = dsu.find(x), by = dsu.find(y);\n    const int h = -(++contract_count_) + kInner;\n    label[mate[bx]] = label[mate[by]] = h;\n    int lca = -1;\n    while (1) {\n      if (mate[by] != 0) swap(bx, by);\n      bx = lca = dsu.find(link[bx].from);\n      if (label[mate[bx]] == h) break;\n      label[mate[bx]] = h;\n    }\n    for (auto bv : {dsu.par[x], dsu.par[y]}) {\n      for (; bv != lca; bv = dsu.par[link[bv].from]) {\n        int mv = mate[bv];\n        link[mv] = {x, y}; label[mv] = label[x];\n        potential[mv] = 1 + (time_current_ - potential[mv]) + time_current_;\n        que.enqueue(mv);\n        dsu.par[bv] = dsu.par[mv] = lca;\n        dsu_changelog[dsu_changelog_last_++] = {bv, lca};\n        dsu_changelog[dsu_changelog_last_++] = {mv, lca};\n      }\n    }\n  }\n\n  bool find_augmenting_path() {\n    while (!que.empty()) {\n      int x = que.dequeue(), lx = label[x], px = potential[x], bx = dsu.find(x);\n      for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n        int y = edges[eid].to;\n        if (label[y] > 0) { // outer blossom/vertex\n          int time_next = (px + potential[y]) >> 1;\n          if (lx != label[y]) {\n            if (time_next == time_current_) return true;\n            time_augment_ = min(time_next, time_augment_);\n          } else {\n            if (bx == dsu.find(y)) continue;\n            if (time_next == time_current_) {\n              contract(x, y); bx = dsu.find(x);\n            } else if (time_next <= NH) list.push(time_next, eid);\n          }\n        } else if (label[y] == kFree) { // free vertex\n          int time_next = px + 1;\n          if (time_next == time_current_) grow(x, y, mate[y]);\n          else if (time_next <= NH) list.push(time_next, eid);\n        }\n      }\n    }\n    return false;\n  }\n\n  bool adjust_dual_variables() {\n    // Return true if the current matching is maximum.\n    const int time_lim = min(NH + 1, time_augment_);\n    for (++time_current_; time_current_ <= time_lim; ++time_current_) {\n      dsu_changelog_size_ = dsu_changelog_last_;\n      if (time_current_ == time_lim) break;\n      bool updated = false;\n      for (int h = list.head[time_current_]; h >= 0; h = list.next[h]) {\n        auto& e = edges[h]; int x = e.from, y = e.to;\n        if (label[y] > 0) {\n          // Case: outer -- (free => inner => outer)\n          if (potential[x] + potential[y] != (time_current_ << 1)) continue;\n          if (dsu.find(x) == dsu.find(y)) continue;\n          if (label[x] != label[y]) { time_augment_ = time_current_; return false; }\n          contract(x, y); updated = true;\n        } else if (label[y] == kFree) {\n          grow(x, y, mate[y]); updated = true;\n        }\n      }\n      list.head[time_current_] = -1;\n      if (updated) return false;\n    }\n    return time_current_ > NH;\n  }\n\n  bool do_edmonds_search() {\n    label[0] = kFree;\n    for (int u = 1; u <= N; ++u) {\n      if (mate[u] == 0) {\n        que.enqueue(u); label[u] = u; // component id\n      } else label[u] = kFree;\n    }\n    while (1) {\n      if (find_augmenting_path()) break;\n      bool maximum = adjust_dual_variables();\n      if (maximum) return false;\n      if (time_current_ == time_augment_) break;\n    }\n    for (int u = 1; u <= N; ++u) {\n      if (label[u] > 0) potential[u] -= time_current_;\n      else if (label[u] < 0) potential[u] = 1 + (time_current_ - potential[u]);\n    }\n    return true;\n  }\n\n  // second phase\n\n  void rematch(int v, int w) {\n    int t = mate[v]; mate[v] = w;\n    if (mate[t] != v) return;\n    if (link[v].to == dsu.find(link[v].to)) {\n      mate[t] = link[v].from;\n      rematch(mate[t], t);\n    } else {\n      int x = link[v].from, y = link[v].to;\n      rematch(x, y); rematch(y, x);\n    }\n  }\n\n  bool dfs_augment(int x, int bx) {\n    int px = potential[x], lx = label[bx];\n    for (int eid = ofs[x]; eid < ofs[x + 1]; ++eid) {\n      int y = edges[eid].to;\n      if (px + potential[y] != 0) continue;\n      int by = dsu.find(y), ly = label[by];\n      if (ly > 0) { // outer\n        if (lx >= ly) continue;\n        int stack_beg = stack_last_;\n        for (int bv = by; bv != bx; bv = dsu.find(link[bv].from)) {\n          int bw = dsu.find(mate[bv]);\n          stack[stack_last_++] = bw; link[bw] = {x, y};\n          dsu.par[bv] = dsu.par[bw] = bx;\n        }\n        while (stack_last_ > stack_beg) {\n          int bv = stack[--stack_last_];\n          for (int v = blossom.head[bv]; v >= 0; v = blossom.next[v]) {\n            if (!dfs_augment(v, bx)) continue;\n            stack_last_ = stack_beg;\n            return true;\n          }\n        }\n      } else if (ly == kFree) {\n        label[by] = kInner; int z = mate[by];\n        if (z == 0) { rematch(x, y); rematch(y, x); return true; }\n        int bz = dsu.find(z);\n        link[bz] = {x, y}; label[bz] = outer_id_++;\n        for (int v = blossom.head[bz]; v >= 0; v = blossom.next[v]) {\n          if (dfs_augment(v, bz)) return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  int find_maximal() {\n    // discard blossoms whose potential is 0.\n    for (int u = 1; u <= N; ++u) dsu.par[u] = u;\n    for (int i = 0; i < dsu_changelog_size_; ++i) {\n      dsu.par[dsu_changelog[i].v] = dsu_changelog[i].par;\n    }\n    for (int u = 1; u <= N; ++u) {\n      label[u] = kFree; blossom.push(dsu.find(u), u);\n    }\n    int ret = 0;\n    for (int u = 1; u <= N; ++u) if (!mate[u]) {\n      int bu = dsu.par[u];\n      if (label[bu] != kFree) continue;\n      label[bu] = outer_id_++;\n      for (int v = blossom.head[bu]; v >= 0; v = blossom.next[v]) {\n        if (!dfs_augment(v, bu)) continue;\n        ret += 1;\n        break;\n      }\n    }\n    assert(ret >= 1);\n    return ret;\n  }\n\n  // init\n\n  void initialize() {\n    que = Queue<int>(N);\n\n    mate.assign(N + 1, 0);\n    potential.assign(N + 1, 1);\n    label.assign(N + 1, kFree);\n    link.assign(N + 1, {0, 0});\n\n    dsu_changelog.resize(N);\n\n    dsu = DisjointSetUnion(N + 1);\n    list = LinkedList(NH + 1, edges.size());\n\n    blossom = LinkedList(N + 1, N + 1);\n    stack.resize(N); stack_last_ = 0;\n  }\n\nprivate:\n  const int N, NH;\n  vector<int> ofs; vector<Edge> edges;\n\n  Queue<int> que;\n\n  vector<int> mate, potential;\n  vector<int> label; vector<Link> link;\n\n  vector<Log> dsu_changelog; int dsu_changelog_last_, dsu_changelog_size_;\n\n  DisjointSetUnion dsu;\n  LinkedList list, blossom;\n  vector<int> stack; int stack_last_;\n  \n  int time_current_, time_augment_;\n  int contract_count_, outer_id_;\n};\n\nusing Edge = MaximumMatching::Edge;\n\n// main function\n#include <iostream>\n#include <set>\n#include <random>\nvector<pair<int,int> >ve;\nint a[1000],b[1000];\nint main() {\n\n\tint n,aa,bb;\n\tcin>>n>>aa>>bb;\n\tfor(int i=1;i<=n;i++)cin>>a[i]>>b[i];\n\n\t\n\tfor(int i=1;i<=n;i++)if(abs(a[i]-b[i])<=aa || (bb<=abs(a[i]-b[i]) && abs(a[i]-b[i])<=2*aa)){\n\t\t\n\t\tve.push_back(make_pair(i,i+n));\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++){\n\t\tint f=abs(a[i]+a[j]-b[i]-b[j]);\n\t\tif(f<=aa || (bb<=f && f<=2*aa)) {\n\t\t\tve.push_back(make_pair(i,j));\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tmt19937 mt(12345);\n\n  auto run = [] (int N, const vector<Edge>& edges) {\n    clock_t beg = clock();\n    auto mm = MaximumMatching(N, edges);\n    auto ans = mm.maximum_matching();\n    clock_t end = clock();\n   cout<<ans<<endl;\n  };\n\n  const int K = 2000;\n\n  // random\n  {\n  \tconst int N = K, M = ve.size();\n  //  uniform_int_distribution<int> urand(1, N);\n    vector<Edge> edges(M);\n    for (int i = 0; i < M; ++i) {\n    \tint u =ve[i].first, v = ve[i].second;\n      edges[i] = {u, v};\n    }\n    run(N, edges);\n  }\n\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP0(i,n) for (ll i = 0; i <= (ll)(n); ++i)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) is >> x;\n  //for(int i=0; i<vec.size(); i++) is >> x[i]; とかでもいいです。\n  return is;\n}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){\n  for(int i=0; i<vec.size(); i++){\n    os << vec[i] << ( i+1 == vec.size() ? \"\" : \" \" );\n  }\n  return os;\n}\n/* }}} */\n\nvector<long long int> dijkstra(int s,int v, vector<vector<pii>> G)\n{\n  //s: 始点, v: 頂点数, G: 隣接リスト\n  PQ<pair<long long int,int>> wait;\n  vector<long long int> result(v,INF);\n  result[s]=0;\n  wait.push(mp(0,s));\n  while(!wait.empty())\n  {\n    long long int nowpoint=wait.top().Se;\n    long long int nowcost=wait.top().Fi;\n    wait.pop();\n    if(nowcost<=result[nowpoint])\n    {\n      rep(i,G[nowpoint].size())\n      {\n        long long int nextpoint=G[nowpoint][i].Se;\n        long long int nextcost= G[nowpoint][i].Fi-nowcost;\n        if(nextcost<result[nextpoint])\n        {\n          wait.push(mp(-nextcost,nextpoint));\n          result[nextpoint]=nextcost;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nsigned main() \n{\n  int n,A,B;\n  cin>>n>>A>>B;\n  int a[801],b[801],c[801]={};\n  int cnt=0;\n  rep(i,n)\n  {\n    cin>>a[i]>>b[i];\n    int tmp=a[i]-b[i];\n    if(abs(tmp)<=A||(B<=abs(tmp)&&abs(tmp)<=2*A)) cnt++;\n    else c[i]=tmp;\n  }\n  priority_queue<int, vector<int>, greater<int> > nc;\n  priority_queue<int> pc;\n  rep(i,n)\n  {\n    if(c[i]>0) pc.push(c[i]);\n    else if(c[i]<0) nc.push(c[i]);\n  }\n  \n  while((!pc.empty())&&(!nc.empty()))\n  {\n    int p=pc.top(),n=nc.top();\n    int diff=abs(p+n);\n    if(diff <= A || (B <= diff && diff <= 2 * A)) \n    {\n      cnt++;\n      pc.pop();\n      nc.pop();\n      \n    }\n    else \n    {\n      if(abs(n)<abs(p)) nc.pop();\n      else pc.pop();\n    }\n  }\n  print(cnt);\n  \n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> a(N), b(N);\n  REP(i, 0, N) cin >> a[i] >> b[i];\n\n  ll ans = 0;\n  vector<bool> used(N, false);\n  REP(i, 0, N) {\n    ll d = abs(a[i] - b[i]);\n    if(d <= A || (B <= d && d <= 2 * A)) {\n      used[i] = true;\n      ans++;\n    }\n  }\n\n  const ll s = N, t = N + 1;\n  MaxFlow flow(N + 2);\n  REP(i, 0, N) if(!used[i]) {\n    ll d = a[i] - b[i];\n    if(d > 0) flow.add_directed_edge(s, i, 1);\n    if(d < 0) flow.add_directed_edge(i, t, 1);\n  }\n  REP(i, 0, N) REP(j, 0, N) if(!used[i] && !used[j]) {\n    ll di = a[i] - b[i];\n    ll dj = a[j] - b[j];\n    ll d = di + dj;\n    if(d <= A || (B <= d && d <= 2 * A)) {\n      if(di > 0 && dj < 0) flow.add_directed_edge(i, j, 1);\n      if(di < 0 && dj > 0) flow.add_directed_edge(j, i, 1);\n    }\n  }\n  ans += flow.max_flow(s, t);\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\nvector<P> v[2];\nint main() {\n\tint n, a, b; cin >> n >> a >> b;\n\tint cnt = 0;\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tint z = abs(x - y);\n\t\tif (z <= a || (b <= z && z <= 2 * a))cnt++;\n\t\telse {\n\t\t\tif (x-y>0) {\n\t\t\t\tv[0].push_back({ x,y });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[1].push_back({ x,y });\n\t\t\t}\n\t\t}\n\t}\n\tint m = v[0].size(); int len = v[1].size();\n\tint sta = m + len, goa = m + len + 1;\n\trep(i, m)add_edge(sta, i, 1);\n\trep(i, len)add_edge(i + m, goa, 1);\n\trep(i, m) {\n\t\trep(j, len) {\n\t\t\tint z = v[0][i].first - v[0][i].second + v[1][j].first - v[1][j].second;\n\t\t\tz = abs(z);\n\t\t\tif (z <= a || (b <= z && z <= 2 * a)) {\n\t\t\t\tadd_edge(i, m + j,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = cnt + max_flow(sta,goa);\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n////フォード - ファルカーソン法 O(Flow|E|)\n\ntypedef int Weight;\n\nconst Weight INF = 1e9;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int rev_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), rev(rev_), id(id_) { }\n\tEdge(int src_, int dst_, Weight weight_, const int rev_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), rev(rev_) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph&g, int from, int to, int cap)\n{\n\tg[from].push_back(Edge(from, to, cap, (int)g[to].size()));\n\tg[to].push_back(Edge(to, from, 0, (int)g[from].size() - 1));\n}\n//二つを繋ぐ線を完全に消す\nvoid erase_edge(Graph&g, const  int from, const int to) {\n\tg[from].erase(remove_if(g[from].begin(), g[from].end(), [=](const Edge&e) {return e.dst == to; }), g[from].end());\n\tg[to].erase(remove_if(g[to].begin(), g[to].end(), [=](const Edge&e) {return e.dst == from; }), g[to].end());\n}\nint dfs(vector<int>&used, Graph&g, int now, int t, int f)\n{\n\tif (now == t) {\n\t\treturn f;\n\t}\n\tused[now] = true;\n\tfor (int i = 0; i<g[now].size(); ++i) {\n\t\tEdge &e = g[now][i];\n\t\tif (!used[e.dst] && e.weight>0) {\n\t\t\tint d = dfs(used, g, e.dst, t, min(f, e.weight));\n\t\t\tif (d > 0) {\n\t\t\t\te.weight -= d;\n\t\t\t\tg[e.dst][e.rev].weight += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nWeight fold_falc(Graph g, const int start, const int goal) {\n\tWeight ans = 0;\n\twhile (1) {\n\t\tvector<int>used(g.size());\n\t\tint flow = dfs(used, g, start, goal, INF);\n\t\tif (!flow)return ans;\n\t\telse ans += flow;\n\t}\n}\n\nint main() {\n\tint N,A,B;cin>>N>>A>>B;\n\tvector<vector<int>>sas(2);\n\tint ans=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a, b;cin>>a>>b;\n\t\tint num=a-b;\n\t\tif ( abs(num)<=A || (B <= abs(num) && abs(num) <= 2 * A)) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tif(num>0)sas[0].push_back(num);\n\t\t\telse sas[1].push_back(-num);\n\t\t}\n\t}\n\tconst int start=0;\n\tconst int zero=1;\n\tconst int one=zero+sas[0].size();\n\tconst int goal=one+sas[1].size();\n\tGraph g(goal+1);\n\n\tfor (int i = 0; i < sas[0].size(); ++i) {\n\t\tadd_edge(g,start,zero+i,1);\n\t}\n\tfor (int i = 0; i < sas[0].size(); ++i) {\n\t\tfor (int j = 0; j < sas[1].size(); ++j) {\n\t\t\tint x=zero+i;\n\t\t\tint y=one+j;\n\t\t\tint num=sas[0][i]-sas[1][j];\n\n\t\t\tif ( abs(num)<=A || (B <= (abs(num)) && (abs(num)) <= 2 * A)) {\n\t\t\t\tadd_edge(g,x,y,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < sas[1].size(); ++i) {\n\t\tadd_edge(g, one+i, goal, 1);\n\t}\n\n\tans+=fold_falc(g,start,goal);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n\nusing namespace std;\n\n#define IINF INT_MAX\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef VVI matrix;\n\n#define MAX 810\ndouble A[MAX][MAX],B[MAX][MAX];\n\nint rnk(int n){\n  int res = 0;\n  //matrix B(n,VI(n+1,1));\n  rep(i,n) rep(j,n+1) B[i][j] = 1;\n \n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) B[i][j] = A[i][j];\n   \n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n \n     \n    if(abs(B[i][i]) > EPS){\n      for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(int j=0;j<n;j++){\n        if(i != j){\n          for(int k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n        }\n      }\n    }\n  }\n  return res;\n}\n\n\n\nint main() {\n  srand((unsigned int)time(NULL));\n  int N,a,b,c,d,e,n,cnt=0;\n  cin >> N >> a >> b;\n  vector<int> s,t;\n  rep(i,N) {\n    cin >> c >> d;\n    e = abs(c-d);\n    if( e <= a || ( b <= e && e <= 2 * a ) ) ++cnt;\n    else s.push_back(c), t.push_back(d);\n  }\n  n = (int)s.size();\n  rep(i,n) {\n    REP(j,i+1,n) {\n      e = abs( ( s[i] + s[j] ) - ( t[i] + t[j] ) );\n      if( e <= a || ( b <= e && e <= 2 * a ) ) {\n\tA[i][j] = rand() % 1000000;\n\tA[j][i] = -A[i][j];\n      }\n    }\n  }\n  cout << cnt + (int)(rnk(n)/2) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <sstream>\n\nusing namespace std;\n\nint main (void)\n{\n\tint n,a,b,x[100],y[100],d[100];\n\tint co = 0;\n\n\tcin >> n >> a >> b;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint u = 0;\n\t\tu = x[i] - y[i];\n\n\t\tif (u < 0)\n\t\t{\n\t\t\tu = u - u - u;\n\t\t}\n\n\t\tif (u <= a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t\telse if (u >= b && u <= 2 * a)\n\t\t{\n\t\t\tco += 1;\n\t\t\td[i] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tint u = 0;\n\t\t\tu = (x[i] + x[j]) - (y[i] + y[j]);\n\t\t\tif (u < 0)\n\t\t\t{\n\t\t\t\tu = u - u - u;\n\t\t\t}\n\n\t\t\tif (i != j && d[i] != -1)\n\t\t\t{\n\t\t\t\tif (d[j] != -1)\n\t\t\t\t{\n\t\t\t\t\tif (u <= a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (u >= b && u <= 2 * a)\n\t\t\t\t\t{\n\t\t\t\t\t\tco += 1;\n\t\t\t\t\t\td[i] = -1;\n\t\t\t\t\t\td[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << co << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint n,a,b;\nbool sat(int x){\n  x=abs(x);\n  return x<=a||(b<=x&&x<=2*a);\n}\n\nint main(){\n  cin>>n>>a>>b;\n  vi c(n);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    c[i]=x-y;\n  }\n  int ans=0;\n  vi neg,pos;\n  rep(i,n){\n    if(sat(c[i]))\n      ans++;\n    else{\n      if(c[i]<0)neg.push_back(c[i]);\n      else pos.push_back(c[i]);\n    }\n  }\n  Graph g(neg.size()+pos.size());\n  rep(i,neg.size()){\n    rep(j,pos.size()){\n      if(sat(neg[i]+pos[j])){\n\tg[i].push_back(Edge(i,neg.size()+j));\n      }\n    }\n  }\n  Edges e;\n  cout<<ans+bipartiteMatching(g,neg.size(),e)<<endl;\n      \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define FOR(e, c) for (auto e = c.begin(); e != c.end(); ++e)\nusing namespace std;\ntemplate <typename T> using vec = vector<T>;\nusing V = vec<int>;\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Flow cap;\n    Edge() : src(0), dst(0) {}\n    Edge(int s, int d) : src(s), dst(d) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b) {\n    g[a].emplace_back(a, b);\n    g[b].emplace_back(b, a);\n}\nvoid add_arc(Graph &g, int a, int b) { g[a].emplace_back(a, b); }\n\n\n#define EVEN(x) (mu[x] == x || (mu[x] != x && phi[mu[x]] != mu[x]))\n#define ODD(x)  (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] != x)\n#define OUTER(x) (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] == x)\nint maximumMatching(const Graph &g, Edges &matching) {\n    int n = g.size();\n    vector<int> mu(n), phi(n), rho(n), scanned(n);\n    REP(v,n) mu[v] = phi[v] = rho[v] = v; // (1) initialize\n    for (int x = -1; ; ) {\n        if (x < 0) {                        // (2) select even\n            for (x = 0; x < n && (scanned[x] || !EVEN(x)); ++x);\n            if (x == n) break;\n        }\n        int y = -1;                         // (3) select incident\n        FOR(e, g[x]) if (OUTER(e->dst) || (EVEN(e->dst) && rho[e->dst] != rho[x])) y = e->dst;\n        if (y == -1) scanned[x] = true, x = -1;\n        else if (OUTER(y)) phi[y] = x;      // (4) growth\n        else {\n            vector<int> dx(n, -2), dy(n, -2); // (5,6), !TRICK! x % 2 --> x >= 0\n            for (int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n            for (int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n            bool vertex_disjoint = true;\n            REP(v,n) if (dx[v] >= 0 && dy[v] > 0) vertex_disjoint = false;\n            if (vertex_disjoint) {            // (5) augment\n                REP(v,n) if (dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n                REP(v,n) if (dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n                mu[x] = y; mu[y] = x; x = -1;\n                REP(v,n) phi[v] = rho[v] = v, scanned[v] = false;\n            } else {                          // (6) shrink\n                int r = x, d = n;\n                REP(v,n) if (dx[v] >= 0 && dy[v] >= 0 && rho[v] == v && d > dx[v]) d = dx[v], r = v;\n                REP(v,n) if (dx[v] <= d && dx[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n                REP(v,n) if (dy[v] <= d && dy[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n                if (rho[x] != r) phi[x] = y;\n                if (rho[y] != r) phi[y] = x;\n                REP(v,n) if (dx[rho[v]] >= 0 || dy[rho[v]] >= 0) rho[v] = r;\n            }\n        }\n    }\n    matching.clear();\n    REP(u,n) if (u < mu[u]) matching.push_back( Edge(u, mu[u]) );\n    return matching.size(); // make explicit matching\n}\n\n\nint N, A, B;\nint a[1000], b[1000];\n\nbool range(int x) {\n    return abs(x) <= A || (B <= abs(x) && abs(x) <= 2 * A);\n}\n\nbool check(int i) {\n    return range(a[i] - b[i]);\n}\n\nbool check(int i, int j) {\n    return range(a[i] + a[j] - b[i] - b[j]);\n}\n\nint pnode(int i, int j) {\n    assert(i <= j);\n    return N + i * N + j;\n}\n\nint main() {\n    while (cin >> N >> A >> B && N) {\n        REP(i, N) cin >> a[i] >> b[i];\n        vec<int> use(N);\n        int cnt = 0;\n        REP(i, N) if (check(i)) use[i] = true, cnt++;\n        Graph g(N);\n        REP(i, N) REP(j, i) {\n            if (use[i] || use[j]) continue;\n            if (check(i, j)) {\n                add_edge(g, i, j);\n            }\n        }\n        vec<Edge> m;\n        cout << cnt + maximumMatching(g, m) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,A,B;\nint a[888],b[888];\nint f;\nint ans;\nvector<int>G[4444];\nbool g(int a)\n{\n\treturn abs(a)<=A||(B<=abs(a)&&abs(a)<=2*A);\n}\nint match[8888],used[8888];\nbool dfs(int v)\n{\n\tused[v]=1;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i];\n\t\tif(match[u]<0||!used[match[u]]&&dfs(match[u]))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tif(g(u-v))ans++;\n\t\telse\n\t\t{\n\t\t\ta[f]=u,b[f]=v;f++;\n\t\t}\n\t}\n\tfor(int i=0;i<f;i++)\n\t{\n\t\tfor(int j=i+1;j<f;j++)\n\t\t{\n\t\t\tif(g(a[i]+a[j]-(b[i]+b[j])))\n\t\t\t{\n\t\t\t\tG[i].push_back(f+j);\n\t\t\t\tG[f+j].push_back(i);\n\t\t\t\tG[j].push_back(f+i);\n\t\t\t\tG[f+i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=0;i<2*f;i++)match[i]=-1;\n\tfor(int v=0;v<2*f;v++)\n\t{\n\t\tfor(int i=0;i<2*f;i++)used[i]=0;\n\t\tif(dfs(v))res++;\n\t}\n\tcout<<(ans+res/2)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <functional>\n#include <algorithm>\n\nstruct edge {\n  int to;\n  int label;\n};\n\n\n::std::vector<::std::pair<int,int>> gabow_edmonds(const ::std::vector<::std::vector<int>>& gra){\n  int N = gra.size();\n  ::std::vector<::std::vector<edge>> g(N + 1);\n  ::std::vector<::std::pair<int,int>> edges;\n  {\n    int cnt = N + 1;\n    for(int i = 0;i < N;i++){\n      for(auto to : gra[i]){\n        if(i < to){\n          g[to + 1].push_back({i + 1,cnt});\n          g[i + 1].push_back({to + 1,cnt++});\n          edges.push_back({i + 1, to + 1});\n        }\n      }\n    }\n  }\n  ::std::vector<int> mate(N + 1 , 0);\n  ::std::vector<int> label(N + 1 , -1);\n  ::std::vector<int> first(N + 1 , 0);\n\n  ::std::function<int(int)> eval_first = [&](int x){\n    if(label[first[x]] < 0) return first[x];\n    first[x] = eval_first(first[x]);\n    return first[x];\n  };\n\n  ::std::function<void(int,int)> rematch = [&](int v,int w){\n    int t = mate[v];\n    mate[v] = w;\n    if(mate[t] != v) return;\n    if(label[v] <= N){\n      mate[t] = label[v];\n      rematch(label[v] , t);\n    }\n    else{\n      int x = edges[label[v] - N + 1].first;\n      int y = edges[label[v] - N + 1].second;\n      rematch(x , y);\n      rematch(y , x);\n    }\n  };\n\n  ::std::function<void(int,int,int)> assignLabel = [&](int x, int y,int num){\n    int r = eval_first(x);\n    int s = eval_first(y);\n    int join = 0;\n    if(r == s) return;\n    label[r] = -num;\n    label[s] = -num;\n    while(true){\n      if(s != 0) ::std::swap(r , s);\n      r = eval_first(label[mate[r]]);\n      if(label[r] == -num){\n        join = r;\n        break;\n      }\n      label[r] = -num;\n    }\n    int v = first[x];\n    while(v != join){\n      label[v] = num;\n      first[v] = join;\n      v = first[label[mate[v]]];\n    }\n    v = first[y];\n    while(v != join){\n      label[v] = num;\n      first[v] = join;\n      v = first[label[mate[v]]];\n    }\n    return;\n  };\n\n  ::std::function<bool(int)> augment_check = [&](int u){\n    first[u] = 0;\n    label[u] = 0;\n    ::std::queue<int> que;\n    que.push(u);\n    while(!que.empty()){\n      int x = que.front();\n      que.pop();\n      for(auto e : g[x]){\n        int y = e.to;\n        if(mate[y] == 0 && y != u){\n          mate[y] = x;\n          rematch(x , y);\n          return true;\n        }\n        else if(label[y] >= 0){\n          assignLabel(x , y , e.label);\n        }\n        else if(label[mate[y]] < 0){\n          label[mate[y]] = x;\n          first[mate[y]] = y;\n          que.push(mate[y]);\n        }\n      }\n    }\n    return false;\n  };\n\n  for(int i = 1;i <= N;i++){\n    if(mate[i] != 0) continue;\n    if(augment_check(i)){\n      ::std::fill(label.begin() , label.end() , -1);\n    }\n  }\n\n  ::std::vector<::std::pair<int,int>> ans;\n  for(int i = 1;i <= N;i++){\n    if(i < mate[i]){\n      ans.push_back({i , mate[i]});\n    }\n  }\n  return ans;\n}\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\nint main(){\n  int N,A,B;\n  cin >> N >> A >> B;\n  vector<int> a(N),b(N);\n  for(int i = 0;i < N;i++){\n    cin >> a[i] >> b[i];\n  }\n  vector<vector<int>> g(N * 2);\n  for(int i = 0;i < N;i++){\n    int t = abs(a[i] - b[i]);\n    if(t <= A || (B <= t && t <= 2 * A)){\n      g[i].push_back(i + N);\n      g[i + N].push_back(i);\n    }\n  }\n  for(int i = 0;i < N;i++){\n    for(int j = i + 1;j < N;j++){\n      int t = abs(a[i] + a[j] - b[i] - b[j]);\n      if(t <= A || (B <= t && t <= 2 * A)){\n        g[i].push_back(j);\n        g[j].push_back(i);\n      }\n    }\n  }\n\n  cout << gabow_edmonds(g).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint V;\nvector<int> G[801];\nint match[810];\nbool used[810];\n\nvoid init(int v){\n  V=v;\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0; i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nll n,A,B;\nll a[810],b[810],d[810];\nbool usedd[810];\n\nint main(){\n  cin>>n>>A>>B;\n  rep(i,n){\n    cin>>a[i]>>b[i];\n    d[i]=a[i]-b[i];\n  }\n  ll res=0;\n  rep(i,n){\n    if(abs(d[i])<=A||(B<=abs(d[i])&&abs(d[i])<=2*A)){\n      usedd[i]=true;\n      res++;\n    }\n  }\n  init(n);\n  rep(i,n)rep(j,i){\n    if(usedd[i]||usedd[j])continue;\n    if(abs(d[i]+d[j])<=A||(B<=abs(d[i]+d[j])&&abs(d[i]+d[j])<=2*A))\n    add_edge(i,j);\n  }\n  res+=bipartite_match();\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <bitset>\n#include <limits.h>\n#define REP(i, n) for(LL i = 0;i < n;i++)\n#define REPR(i, n) for(LL i = n;i >= 0;i--)\n#define FOR(i, m, n) for(LL i = m;i < n;i++)\n#define FORR(i, m, n) for(LL i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define INF (int)1e9\n#define MOD 1000000007\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> LP;\ntypedef pair<int, P> PP;\ntypedef pair<LL, LP> LPP;\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\n\n/*************** using variables ***************/\nvector<bool> close;\nint ans = 0;\n/**********************************************/\nstruct max_flow {\n    struct edge { int to, cap, rev; }; // {行き先, 容量, 逆辺}\nint V;\nvector<vector<edge>> G;\nvector<int> itr, level;\n\nmax_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n}\n\nvoid bfs(int s) {\n    level.assign(V,-1);\n    queue<int> q;\n    level[s] = 0; q.push(s);\n    while (!q.empty()) {\n        int v = q.front(); q.pop();\n        for(auto &e: G[v]){\n            if (e.cap > 0 and level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = itr[v]; i < (int) G[v].size(); ++i) {\n        edge &e = G[v][i];\n        if (e.cap > 0 and level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint run(int s, int t) {\n    int ret = 0, f;\n    while (bfs(s), level[t] >= 0) {\n        itr.assign(V,0);\n        while ((f = dfs(s, t, INF)) > 0) ret += f;\n    }\n    return ret;\n}\n};\nsigned main(){\n    int n, A, B;\n    cin >> n >> A >> B;\n    vector<P> vec;\n    REP(i, n){\n        int a, b;\n        cin >> a >> b;\n        if(a - b <= A || (a - b >= B && a - b <= 2*A)) ans++;\n        else vec.pb(P(a, b));\n    }\n\n    max_flow mf(vec.size()*2+2);\n    REP(i, vec.size()){\n        mf.add_edge(0, i, 1);\n        mf.add_edge(vec.size()+i, vec.size()*2+1, 1);\n    }\n\n    REP(i, vec.size()){\n        REP(j, vec.size()){\n            if(i == j) continue;\n            int a1 = vec[i].first;\n            int a2 = vec[j].first;\n            int b1 = vec[i].second;\n            int b2 = vec[j].second;\n            if((a1+a2)- (b1+b2) <= A || ((a1+a2) - (b1+b2) >= B && (a1+a2) - (b1+b2) <= 2*A)){\n                mf.add_edge(i, vec.size()+j, 1);\n            }\n        }\n    }\n    cout << ans+mf.run(0, vec.size()*2+1)/2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1700\n\nstruct Info{\n\tint a,b;\n};\n\nint V; //頂点数\nint N;\nvector<int> G[NUM]; //グラフの隣接リスト表現\nint match[NUM]; //マッチングのペア\nbool used[NUM]; //DFSですでに調べたかのフラグ\n//bool have_pair[NUM]; //ペアを既に作ったかのフラグ\nInfo info[800];\n\n//fromとtoを結ぶ辺をグラフに追加する\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\n//増加パスをDFSで探す(node_idのペアを探す)\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)|| //隣接するノードに、まだペアが存在しない\n\t\t\t\t(used[pair_id] == false && dfs(pair_id) == true)){\n\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1; //ペアなしにしておく\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){ //node_idにペアがいない場合\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){ //増加パスが存在する場合\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint A,B;\n\tscanf(\"%d %d %d\",&N,&A,&B);\n\n\t//N件のデータを読み込む\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].a,&info[i].b);\n\t}\n\n\tint tmp;\n\tfor(int i = 0; i < N; i++){\n\t\ttmp = abs(info[i].a-info[i].b);\n\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\tadd_edge(i,i);\n\t\t}\n\t\tfor(int k = i+1; k < N; k++){ //2重計上を防ぐため、自分よりインデックスが大きいもののみ走査\n\t\t\tif(k == i)continue;\n\t\t\ttmp = abs((info[i].a+info[k].a)-(info[i].b+info[k].b));\n\t\t\tif(tmp <= A || (tmp >= B && tmp <= 2*A)){\n\t\t\t\tadd_edge(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = N;\n\n\tprintf(\"%d\\n\", bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> a(N), b(N);\n  REP(i, 0, N) cin >> a[i] >> b[i];\n\n  ll ans = 0;\n  vector<bool> used(N, false);\n  REP(i, 0, N) {\n    ll d = abs(a[i] - b[i]);\n    if(d <= A || (B <= d && d <= 2 * A)) {\n      used[i] = true;\n      ans++;\n    }\n  }\n\n  const ll s = N, t = N + 1;\n  MaxFlow flow(N + 2);\n  REP(i, 0, N) if(!used[i]) {\n    ll d = a[i] - b[i];\n    if(d > 0) flow.add_directed_edge(s, i, 1);\n    if(d < 0) flow.add_directed_edge(i, t, 1);\n  }\n  REP(i, 0, N) REP(j, 0, N) if(!used[i] && !used[j]) {\n    ll di = a[i] - b[i];\n    ll dj = a[j] - b[j];\n    if(di > 0 && dj < 0) flow.add_directed_edge(i, j, 1);\n    if(di < 0 && dj > 0) flow.add_directed_edge(j, i, 1);\n  }\n  ans += flow.max_flow(s, t);\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n\n//2部最大マッチング verified AOJ GRL_7_A\n#define MAX_V 800\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// 増大路をDFSで探す\nbool dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i],w=match[u];           //u:vからの移動先の頂点 , w:uとマッチングしている頂点\n        if(w<0 || (!used[w] && dfs(w))){    //uがフリーか、このdfsではwを使っておらず かつwの別のペアが見つかった(=増大路発見) 場合\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int V){\n    int res=0;\n    rep(i,MAX_V)match[i]=-1;\n    rep(v,V){\n        if(match[v]<0){\n            rep(i,MAX_V)used[i]=0;\n            if( dfs(v) ) res++;       //増大路が見つかればres+=1\n        }\n    }\n    return res;\n}\n\nint main(){\n    int ans = 0;\n    int v,a,b;\n    cin>>v>>a>>b;\n    \n    vector<int> s(v),t(v);\n    rep(i,v){\n        cin>>s[i]>>t[i];\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))ans++;\n    }\n    \n    auto g = [](int ai,int bi, int aj, int bj){\n        return abs((ai+aj)-(bi+bj));\n    };\n    \n    rep(i,v){\n        if(abs(s[i]-t[i])<=a or (b<=abs(s[i]-t[i]) and abs(s[i]-t[i])<=2*a))continue;\n        rep(j,v){\n            if(abs(s[j]-t[j])<=a or (b<=abs(s[j]-t[j]) and abs(s[j]-t[j])<=2*a))continue;\n            \n            if(g(s[i],t[i],s[j],t[j])<=a or (b<=g(s[i],t[i],s[j],t[j]) and g(s[i],t[i],s[j],t[j])<=2*a) ){\n                G[i].pb(j);\n            }\n        }\n    }\n    cout<<bipartite_matching(v)+ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint match[809], c; bool p[10000009], used[809]; vector<int> g[809];\n\nbool augment(int pos) {\n\tused[pos] = true;\n\tfor (int i : g[pos]) {\n\t\tif (match[i] < 0 || !used[match[i]] && augment(match[i])) {\n\t\t\tmatch[pos] = i;\n\t\t\tmatch[i] = pos;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching() {\n\tint res = 0;\n\tfill(match, match + c, -1);\n\tfor (int i = 0; i < c; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used, used + c, false);\n\t\t\tif (augment(i)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N, A, B, a[810], b[810], cnt; vector<int>X, Y;\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tif (abs(a[i] - b[i]) <= A || (B <= abs(a[i] - b[i]) && abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] - b[i] >= 0) X.push_back(a[i] - b[i]);\n\t\telse Y.push_back(a[i] - b[i]);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (abs(X[i] + Y[j]) <= A || (B <= abs(X[i] + Y[j]) && abs(X[i] + Y[j]) <= 2 * A)) {\n\t\t\t\tg[i].push_back(j + X.size());\n\t\t\t\tg[j + X.size()].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tc = X.size() + Y.size();\n\n\tint cnt2 = bipartite_matching();\n\n\tcout << cnt + cnt2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  void add_undirected_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, cap, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> a(N), b(N);\n  REP(i, 0, N) cin >> a[i] >> b[i];\n\n  ll ans = 0;\n  vector<bool> used(N, false);\n  REP(i, 0, N) {\n    ll d = abs(a[i] - b[i]);\n    if(d <= A || (B <= d && d <= 2 * A)) {\n      used[i] = true;\n      ans++;\n    }\n  }\n\n  const ll s = N, t = N + 1;\n  MaxFlow flow(N + 2);\n  REP(i, 0, N) if(!used[i]) {\n    ll d = a[i] - b[i];\n    if(d > 0) flow.add_directed_edge(s, i, 1);\n    if(d < 0) flow.add_directed_edge(i, t, 1);\n  }\n  REP(i, 0, N) REP(j, 0, N) if(!used[i] && !used[j]) {\n    ll di = a[i] - b[i];\n    ll dj = a[j] - b[j];\n    ll d = abs(di + dj);\n    if(d <= A || (B <= d && d <= 2 * A)) {\n      if(di > 0 && dj < 0) flow.add_directed_edge(i, j, 1);\n      if(di < 0 && dj > 0) flow.add_directed_edge(j, i, 1);\n    }\n  }\n  ans += flow.max_flow(s, t);\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int atmp=0,btmp=0,N=0, A=0, B=0, ans=0;\n    vector<int> a;\n    vector<int> b;\n    vector<int> confirm;\n\n    cin>>N>>A>>B;\n\n    for(int i=0;i<N;i++){\n        cin>>atmp;\n        a.push_back(atmp);\n        cin>>btmp;\n        b.push_back(btmp);\n        confirm.push_back(1);\n    }\n\n    for(int i=0;i<N;i++){\n        if((abs(a[i]-b[i])<=A) || (B<=abs(a[i]-b[i])&&abs(a[i]-b[i])<=2*A)){\n            ans++;\n            confirm[i]=0;\n        }\n    }\n\n    for(int i=0;i<N-1;i++){\n        if(confirm[i]){ \n            for(int j=i+1;j<a.size();j++){\n                if(confirm[j]){                 \n                    if((abs(a[i]+a[j]-b[i]-b[j])<=A ) || (B<=abs(a[i]+a[j]-b[i]-b[j])&&abs(a[i]+a[j]-b[i]-b[j])<=2*A ) ){ \n                        ans++;\n                        confirm[i]=0;\n                        confirm[j]=0;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<ans<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass bipartite_matching {\npublic:\n    int n;\n    std::vector<std::vector<int>> g;\n    std::vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    std::vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n\n    vector<int> apos, bpos, aneg, bneg;\n    int ans = 0;\n    for (int i = 0; i < N; i++) {\n        int a_, b_;\n        cin >> a_ >> b_;\n\n        int x = a_ - b_;\n\n        if (abs(x) <= A or (B <= abs(x) and abs(x) <= 2 * A)) {\n            ans++;\n        } else {\n            if (x > 0) {\n                apos.push_back(a_);\n                bpos.push_back(b_);\n            } else {\n                aneg.push_back(a_);\n                bneg.push_back(b_);\n            }\n        }\n    }\n\n    /*\n    cerr << \"a: \";\n    for (int x : a) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n\n    cerr << \"b: \";\n    for (int x : b) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n    */\n\n    // cerr << \"totyu: \" << ans << endl;\n\n    int S = apos.size(),\n        T = aneg.size();\n    auto bm = bipartite_matching(S + T);\n    for (int i = 0; i < S; i++) {\n        for (int j = 0; j < T; j++) {\n            int x = abs(apos[i] - bpos[i] + aneg[j] - bneg[j]);\n            if (x <= A or (B <= abs(x) and abs(x) <= 2 * A)) {\n                bm.add_edge(i, S + j);\n                // cerr << \"aaa\" << endl;\n            }\n        }\n    }\n    ans += bm.maximum_matching();\n\n    cout << ans << endl;\n\n    /*\n    for (int i = 0; i < m; i++) {\n        cerr << \"i: \" << i << \" a: \" << a[i] << \" b: \" << b[i] << \" => \";\n        int next = bm.match[i] - m;\n        if (next < 0) {\n            cerr << endl;\n            continue;\n        }\n        cerr << \"a: \" << a[next] << \" b: \" << b[next] << endl;\n    }\n    */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct edge { int to, rev; long long cap; };\n\nbool vis[809]; vector<edge>g[809]; int V, inf = 1000000007;\n\nvoid add_edge(int v1, int v2, long long cost) {\n\tg[v1].push_back(edge{ v2, (int)g[v2].size(), cost });\n\tg[v2].push_back(edge{ v1, (int)g[v1].size() - 1, 0LL });\n}\nlong long find_augment(int pos, int tar, long long curflow) {\n\tif (pos == tar) return curflow;\n\tvis[pos] = true;\n\tfor (edge &e : g[pos]) {\n\t\tif (!vis[e.to] && e.cap > 0) {\n\t\t\tlong long newflow = find_augment(e.to, tar, min(e.cap, curflow));\n\t\t\tif (newflow > 0) {\n\t\t\t\te.cap -= newflow;\n\t\t\t\tg[e.to][e.rev].cap += newflow;\n\t\t\t\treturn newflow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nlong long max_flow(int src, int dst) {\n\tlong long ret = 0;\n\twhile (true) {\n\t\tfill(vis, vis + V, false);\n\t\tlong long res = find_augment(src, dst, inf);\n\t\tif (res == 0) break;\n\t\tret += res;\n\t}\n\treturn ret;\n}\n\nint N, A, B, a[810], b[810], cnt; vector<int>X, Y;\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tif (abs(a[i] - b[i]) <= A || (B <= abs(a[i] - b[i]) && abs(a[i] - b[i]) <= 2 * A)) {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] - b[i] >= 0) X.push_back(a[i] - b[i]);\n\t\telse Y.push_back(a[i] - b[i]);\n\t}\n\tsort(X.begin(), X.end());\n\tsort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (abs(X[i] + Y[j]) <= A || (B <= abs(X[i] + Y[j]) && abs(X[i] + Y[j]) <= 2 * A)) {\n\t\t\t\tadd_edge(i, j + X.size(), 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < X.size(); i++) add_edge(X.size() + Y.size(), i, 1);\n\tfor (int i = 0; i < Y.size(); i++) add_edge(i + X.size(), X.size() + Y.size() + 1, 1);\n\tV = X.size() + Y.size() + 2;\n\n\tint cnt2 = max_flow(X.size() + Y.size(), X.size() + Y.size() + 1);\n\n\tcout << cnt + cnt2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int atmp=0,btmp=0,N=0, A=0, B=0, ans=0;\n    vector<int> a;\n    vector<int> b;\n    vector<int> confirm;\n\n    cin>>N>>A>>B;\n\n    for(int i=0;i<N;i++){\n        cin>>atmp;\n        a.push_back(atmp);\n        cin>>btmp;\n        b.push_back(btmp);\n        confirm.push_back(1);\n    }\n\n    for(int i=0;i<N;i++){\n        if(abs(a[i]-b[i])<=A||B<=abs(a[i]-b[i])&&abs(a[i]-b[i])<=2*A){\n            ans++;\n//            a.erase(a.begin()+i);\n//            b.erase(b.begin()+i);\n            confirm[i]=0;\n            //i--;\n        }\n    }\n\n    for(int i=0;i<N-1;i++){\n        if(confirm[i]){ \n            for(int j=i+1;j<a.size();j++){\n                if(abs(a[i]+a[j]-b[i]-b[j])<=A&&confirm[j]||B<=abs(a[i]+a[j]-b[i]-b[j])&&abs(a[i]+a[j]-b[i]-b[j])<=2*A&&confirm[j]){ \n                    ans++;\n    //                a.erase(a.begin()+i);\n    //                b.erase(b.begin()+i);\n    //                a.erase(a.begin()+j);\n    //                b.erase(b.begin()+j); \n                    confirm[i]=0;\n                    confirm[j]=0;\n              //      i--;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout<<ans<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 3032 Combine Two Elements\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\t/* 整数値の入力 */\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX 1604\nint  hi[MAX], to[MAX][MAX];\nchar seen[MAX];\nint  match[MAX];\n\nint bpm(int u);\nint bipartiteMatching(int m, int n)\n{\n\tint u, max;\n\n\tmemset(match, -1, (m+n)*sizeof(int));\n\tmax = 0;\n\tfor (u = 0; u < m; u++) {\n\t\tmemset(seen, 0, m+n);\n\t\tif (bpm(u)) max++;\n\t}\n\treturn max;\n}\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define ABS(a)  ((a)>=0?(a):-(a))\n\ntypedef struct { int a, b; } T;\nT u[802]; int us;\nT v[802]; int vs;\n\nint main()\n{\n\tint N, A, B, A2, i, j, a, b, d, ans;\n\n\tN = in(), A = in(), B = in(), A2 = A<<1;\n\tans = 0, us = vs = 0;\n\tfor (i = 0; i < N; i++) {\n\t\ta = in(), b = in();\n\t\td = ABS(a-b);\n\t\tif (d <= A || (B <= d && d <= A2)) { ans++; continue; }\n\t\tif (a >= b) u[us].a = a, u[us++].b = b;\n\t\telse        v[vs].a = a, v[vs++].b = b;\n\t}\n\n\tfor (i = 0; i < us; i++) for (j = 0; j < vs; j++) {\n\t\ta = u[i].a + v[j].a;\n\t\tb = u[i].b + v[j].b;\n\t\td = ABS(a-b);\n\t\tif (d <= A || (B <= d && d <= A2)) to[i][hi[i]++] = us+j;\n\t}\n\n\tans += bipartiteMatching(us, vs);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[2000010],nt[2000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//sからtへの最大流を求める　ノード数v辺の数e　aからbへキャパcのフローが流れる\nint maxf(int s,int t,int v,int e,int *a,int *b,int *c){\n  int i,f,r;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];\n    co[ta[b[i]]=i+e]=0;\n  }\n  for(f=0;r=MF(s,t,e,1000000000);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n  }\n  return f;\n}\nint main(){\n  int n,s,t,i,j,l,u,v,f[100010]={};\n  int a[200010],b[200010],c[200010],e=0,ans=0,d[100010];\n  scanf(\"%d %d %d\",&n,&s,&t);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&u,&v);\n    d[i]=u-v;\n    if(abs(d[i])<=s||t<=abs(d[i])&&abs(d[i])<=s*2){\n      ans++;//printf(\"%d %d\",u,v);\n      f[i]=1;\n    }\n  }//printf(\"%d\\n\",ans);\n  for(i=0;i<n;i++){\n    if(f[i]||d[i]>0)continue;\n    for(j=0;j<n;j++){\n      if(f[j]||d[j]<0)continue;\n      l=abs(d[i]+d[j]);\n      if(l<=s||t<=l&&l<=s*2){\n\ta[e  ]=i;\n\tb[e  ]=j;\n\tc[e++]=1;\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    if(f[i])continue;\n    if(d[i]<0){\n      a[e  ]=n;\n      b[e  ]=i;\n      c[e++]=1;\n    }\n    else{\n      a[e  ]=i;\n      b[e  ]=n+1;\n      c[e++]=1;\n    }\n  }\n  //for(i=0;i<e;i++)printf(\"%d %d\\n\",a[i],b[i]);\n  printf(\"%d\\n\",maxf(n,n+1,n+2,e,a,b,c)+ans);\n  return 0;\n}\n  \n      \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n#define min(p,q)((p)<(q)?(p):(q))\n\nint a,b;\nint m[900],mm;\n\n\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[400010];//適宜変える(ecnt)\n\tint inv[400010];//逆辺のindex(ecnt)\n\tint id[900];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nint csort(const void*a,const void*b){\n\tll p=(*(E*)a).c,q=(*(E*)b).c;\n\treturn p<q?-1:p>q?1:0;\n}\n//*\nvoid makeinvedge(){\n\t//逆辺とidx\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tif(g.e[l].s!=g.e[i].g||g.e[l].g!=g.e[i].s){\n\t\t\tg.e[g.ecnt].s=g.e[i].g;\n\t\t\tg.e[g.ecnt].g=g.e[i].s;\n\t\t\tg.e[g.ecnt].c=0;\n\t\t\tg.ecnt++;\n\t\t}\n\t}\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tg.inv[i]=l;\n\t}\n}\n//*/\nvoid readgraph(){\n\t//適宜変える\n\tg.vcnt=mm+2;\n\trep(i,0,mm){\n\t\tif(m[i]<0){\n\t\t\tg.e[g.ecnt].s=mm;\n\t\t\tg.e[g.ecnt].g=i;\n\t\t\tg.e[g.ecnt].c=1;\n\t\t\tg.ecnt++;\n\t\t}else{\n\t\t\tg.e[g.ecnt].s=i;\n\t\t\tg.e[g.ecnt].g=mm+1;\n\t\t\tg.e[g.ecnt].c=1;\n\t\t\tg.ecnt++;\n\t\t}\n\t\trep(j,i+1,mm){\n\t\t\tint t=abs(m[i]+m[j]);\n\t\t\t//正のやつと負のやつをマッチングするしかないので二部グラフ\n\t\t\tif(t<=a||(b<=t&&t<=a+a)){\n\t\t\t\tg.e[g.ecnt].s=m[i]<0?i:j;\n\t\t\t\tg.e[g.ecnt].g=m[i]<0?j:i;\n\t\t\t\tg.e[g.ecnt].c=1;\n\t\t\t\tg.ecnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n//\tqsort(g.e,g.ecnt,sizeof(E),csort);\n\tmakeinvedge();\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n\n//dinic O(VVE)\n//ソースs,シンクtを引いてsからtへの最大流を返す\n//*\nint dist[1010];//ソースからの距離\nint checked[1010];//dfsの行き止まりフラグ\nvoid dinicbfs(int s){\n\trep(i,0,g.vcnt)dist[i]=-1;\n\tdist[s]=0;\n\t//まだ流せる辺だけを使ってbfs\n\tint que[1010],qcnt=0;\n\tque[qcnt++]=s;\n\trep(q,0,qcnt){\n\t\tint v=que[q];\n\t\trep(i,g.id[v],g.id[v+1])if(g.e[i].c>0&&dist[g.e[i].g]==-1){\n\t\t\tdist[g.e[i].g]=dist[v]+1;\n\t\t\tque[qcnt++]=g.e[i].g;\n\t\t}\n\t}\n}\nll dinicdfs(int a,int t,ll m){\n\t//aはm受け取ってる(⇔aから最大m流せる)\n\t//いくら流せるかを返す\n\tif(a==t)return m;\n\tif(checked[a])return 0;\n\tll ans=0;\n\tchecked[a]=1;\n\trep(i,g.id[a],g.id[a+1])if(g.e[i].c>0&&dist[g.e[i].g]>dist[a]){\n\t\tint b=g.e[i].g;\n\t\tll addedflow=dinicdfs(b,t,min(m,g.e[i].c));\n\t\tif(addedflow){\n\t\t\tg.e[i].c-=addedflow;\n\t\t\tg.e[g.inv[i]].c+=addedflow;\n\t\t\tchecked[a]=0;\n\t\t\tans+=addedflow;\n\t\t\tm-=addedflow;\n\t\t\tif(m<=0)break;\n\t\t}\n\t}\n\treturn ans;\n}\n//ソース,シンク\nll dinic(int s,int t){\n\tll ans=0;\n\tint flag=1;\n\twhile(flag){\n\t\tflag=0;//更新フラグ\n\t\tdinicbfs(s);\n\t\twhile(!checked[s]){\n\t\t\tll addedflow=dinicdfs(s,t,INF);\n\t\t\tans+=addedflow;\n\t\t\tif(addedflow)flag=1;\n\t\t}\n\t\trep(i,0,g.vcnt)checked[i]=0;\n\t}\n\treturn ans;\n}\n//*/\n\n\n\n\nint main(){\n\tint n;\n\tint ans=0;\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,0,n){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tint t=abs(p-q);\n\t\tif(t<=a||(b<=t&&t<=a+a))ans++;\n\t\telse m[mm++]=p-q;\n\t}\n\treadgraph();\n\tprintf(\"%d\\n\",ans+dinic(mm,mm+1));\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MIN(int a,int b){return a<b?a:b;}\nint ta[1010],to[2000010],nt[2000010],co[1000010],F[1010];\nint MF(int s,int t,int e,int min){\n  if(s==t||min==0)return min;\n  int i,r;\n  F[s]=1;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(F[to[i]])continue;\n    r=MF(to[i],t,e,MIN(min,co[i]));\n    co[i]-=r;\n    co[(i+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//sからtへの最大流を求める　ノード数v辺の数e　aからbへキャパcのフローが流れる\nint maxf(int s,int t,int v,int e,int *a,int *b,int *c){\n  int i,f,r;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];\n    co[ta[b[i]]=i+e]=0;\n  }\n  for(f=0;r=MF(s,t,e,1000000000);f+=r){\n    for(i=0;i<v;i++)F[i]=0;\n  }\n  return f;\n}\nint main(){\n  int n,s,t,i,j,l,u,v,f[100010]={};\n  int a[200010],b[200010],c[200010],e=0,ans=0,d[100010];\n  scanf(\"%d %d %d\",&n,&s,&t);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d\",&u,&v);\n    d[i]=u-v;\n    if(abs(d[i])<=s||t<=d[i]&&d[i]<=s*2){\n      ans++;//printf(\"%d %d\",u,v);\n      f[i]=1;\n    }\n  }//printf(\"%d\\n\",ans);\n  for(i=0;i<n;i++){\n    if(f[i]||d[i]>0)continue;\n    for(j=0;j<n;j++){\n      if(f[j]||d[j]<0)continue;\n      l=abs(d[i]+d[j]);\n      if(l<=s||t<=l&&l<=s*2){\n\ta[e  ]=i;\n\tb[e  ]=j;\n\tc[e++]=1;\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    if(f[i])continue;\n    if(d[i]<0){\n      a[e  ]=n;\n      b[e  ]=i;\n      c[e++]=1;\n    }\n    else{\n      a[e  ]=i;\n      b[e  ]=n+1;\n      c[e++]=1;\n    }\n  }\n  //for(i=0;i<e;i++)printf(\"%d %d\\n\",a[i],b[i]);\n  printf(\"%d\\n\",maxf(n,n+1,n+2,e,a,b,c)+ans);\n  return 0;\n}\n  \n      \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tint solve(int N, int[][] cap, int s, int t) {\n\t\tint tot = 0;\n\t\tint[][] flow = new int[N][N];\n\t\twhile (true) {\n\t\t\tint[] pre = new int[N];\n\t\t\tArrays.fill(pre, -1);\n\t\t\tArrayDeque<Integer> que = new ArrayDeque();\n\t\t\tque.add(s);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint cur = que.pollFirst();\n\t\t\t\tfor (int dst = 0; dst < N; ++dst) {\n\t\t\t\t\tif (res(cur, dst, flow, cap) <= 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dst == s || pre[dst] != -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpre[dst] = cur;\n\t\t\t\t\tque.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pre[t] == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint inc = Integer.MAX_VALUE / 3;\n\t\t\tfor (int i = t; pre[i] != -1; i = pre[i]) {\n\t\t\t\tinc = Math.min(inc, res(pre[i], i, flow, cap));\n\t\t\t}\n\t\t\tfor (int i = t; pre[i] != -1; i = pre[i]) {\n\t\t\t\tflow[pre[i]][i] += inc;\n\t\t\t\tflow[i][pre[i]] -= inc;\n\t\t\t}\n\t\t\ttot += inc;\n\t\t}\n\t\treturn tot;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tint N = sc.nextInt();\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint[] b = new int[N];\n\t\tint[] c = new int[N];\n\t\tint ans = 0;\n\t\tboolean[] used = new boolean[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\tc[i] = a[i] - b[i];\n\t\t\tif (Math.abs(c[i]) <= A || (B <= Math.abs(c[i]) && Math.abs(c[i]) <= 2 * A)) {\n\t\t\t\t++ans;\n\t\t\t\tused[i] = true;\n\t\t\t}\n\t\t}\n\t\tint[][] cap = new int[N + 2][N + 2];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (used[i] || used[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Math.abs(c[i] + c[j]) <= A || (B <= Math.abs(c[i] + c[j]) && Math.abs(c[i] + c[j]) <= 2 * A)) {\n\t\t\t\t\tcap[i][j] = 1;\n\t\t\t\t\tcap[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (used[i])\n\t\t\t\tcontinue;\n\t\t\tif (c[i] > 0) {\n\t\t\t\tcap[N][i] = 1;\n\t\t\t} else {\n\t\t\t\tcap[i][N + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tans += solve(N + 2, cap, N, N + 1);\n\t\tSystem.out.println(ans);\n\t}\n\n\t//src->dstにあとどれだけ流せるか。\n\tint res(int src, int dst, int[][] flow, int[][] cap) {\n\t\treturn cap[src][dst] - flow[src][dst];\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "N, A, B = map(int, input().split())\nP = []\nQ = []\nans = 0\nfor i in range(N):\n    a, b = map(int, input().split())\n    v = abs(a-b)\n    if v <= A or B <= v <= 2*A:\n        ans += 1\n        continue\n    if a > b:\n        P.append(a-b)\n    else:\n        Q.append(a-b)\n\nimport collections\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n    def add_edge(self, fr, to, cap):\n        self.g[fr].append([to, cap, len(self.g[to])])\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        self.g[v1].append([v2, cap1, len(self.g[v2])])\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\n    def bfs(self, s):\n        level = [-1]*self.n\n        deq = collections.deque()\n        level[s] = 0\n        deq.append(s)\n        while deq:\n            v = deq.popleft()\n            for e in self.g[v]:\n                if e[1]>0 and level[e[0]]<0:\n                    level[e[0]] = level[v] + 1\n                    deq.append(e[0])\n        self.level = level\n    def dfs(self, v, t, f):\n        if v==t: return f\n        es = self.g[v]\n        level = self.level\n        for i in range(self.it[v], len(self.g[v])):\n            e = es[i]\n            if e[1]>0 and level[v]<level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d\n                    self.g[e[0]][e[2]][1] += d\n                    self.it[v] = i\n                    return d\n        self.it[v] = len(self.g[v])\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0: break\n            self.it = [0]*self.n\n            while True:\n                f = self.dfs(s, t, 10**9+7)\n                if f>0:\n                    flow += f\n                else:\n                    break\n        return flow\n\ndinic = Dinic(2+len(P)+len(Q))\nLP = len(P)\nfor i in range(len(P)):\n    dinic.add_edge(0, 2+i, 1)\nfor j in range(len(Q)):\n    dinic.add_edge(2+LP+j, 1, 1)\nfor i, p in enumerate(P):\n    for j, q in enumerate(Q):\n        v = abs(p+q)\n        if v <= A or B <= v <= 2*A:\n            dinic.add_edge(2+i, 2+LP+j, 1)\nans += dinic.max_flow(0, 1)\nprint(ans)\n"
  }
]