[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 500\n#define MAX_M 250000\n\nint graph[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nvoid floyd_warshall(int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] && dist[k][j] && dist[i][k] + dist[k][j] <= 3) {\n                    if (dist[i][j] == 0 || dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint count_max_edges(int n) {\n    int max_edges = 0;\n    for (int u = 0; u < n; u++) {\n        for (int v = u + 1; v < n; v++) {\n            if (dist[u][v] == 3 && !graph[u][v]) {\n                max_edges++;\n            }\n        }\n    }\n    return max_edges;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    memset(graph, 0, sizeof(graph));\n    memset(dist, 0, sizeof(dist));\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        graph[a][b] = 1;\n        graph[b][a] = 1;\n    }\n\n    floyd_warshall(n);\n    printf(\"%d\\n\", count_max_edges(n));\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n\nint N, M;\nint adj[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nvoid floydWarshall() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) dist[i][j] = 0;\n            else if (adj[i][j]) dist[i][j] = 1;\n            else dist[i][j] = MAX_N + 1;\n        }\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    memset(adj, 0, sizeof(adj));\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        adj[a][b] = adj[b][a] = 1;\n    }\n\n    floydWarshall();\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (!adj[i][j] && dist[i][j] == 3) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N);\n    vector<unordered_set<int>> adj_set(N);\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        A--; B--;\n        adj[A].push_back(B);\n        adj[B].push_back(A);\n        adj_set[A].insert(B);\n        adj_set[B].insert(A);\n    }\n\n    int res = 0;\n    for (int u = 0; u < N; ++u) {\n        vector<int> dist(N, -1);\n        queue<int> q;\n        dist[u] = 0;\n        q.push(u);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            if (dist[v] == 3) continue;\n            for (int w : adj[v]) {\n                if (dist[w] == -1) {\n                    dist[w] = dist[v] + 1;\n                    q.push(w);\n                }\n            }\n        }\n        for (int v = 0; v < N; ++v) {\n            if (dist[v] == 3 && adj_set[u].count(v) == 0) {\n                res++;\n                adj_set[u].insert(v);\n                adj_set[v].insert(u);\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        boolean[][] adj = new boolean[N][N];\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj[a][b] = true;\n            adj[b][a] = true;\n        }\n\n        boolean[][] adj2 = new boolean[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (adj[i][j]) {\n                    for (int k = 0; k < N; k++) {\n                        if (adj[j][k] && k != i) {\n                            adj2[i][k] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        boolean[][] adj3 = new boolean[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (adj2[i][j]) {\n                    for (int k = 0; k < N; k++) {\n                        if (adj[j][k] && k != i) {\n                            adj3[i][k] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (!adj[i][j] && adj3[i][j]) {\n                    count++;\n                }\n            }\n        }\n        System.out.println(count);\n    }\n}",
    "timestamp": "2025-08-05 23:14:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int maxEdges(int N, int M, int[][] edges) {\n        // Adjacency list representation of the graph\n        List<Set<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new HashSet<>());\n        }\n\n        // Add existing edges to the graph\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int newEdges = 0;\n        // Check for potential new edges\n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (u == v) continue;\n                \n                // Find all vertices reachable in exactly 3 steps\n                if (isReachableInThreeSteps(graph, u, v) && !graph.get(u).contains(v)) {\n                    newEdges++;\n                }\n            }\n        }\n\n        return newEdges;\n    }\n\n    private static boolean isReachableInThreeSteps(List<Set<Integer>> graph, int start, int end) {\n        Set<Integer> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start, 0});\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int vertex = current[0];\n            int steps = current[1];\n\n            if (steps == 3 && vertex == end) {\n                return true;\n            }\n\n            if (steps >= 3) continue;\n\n            for (int neighbor : graph.get(vertex)) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(new int[]{neighbor, steps + 1});\n                    visited.add(neighbor);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        \n        int[][] edges = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            edges[i][0] = sc.nextInt();\n            edges[i][1] = sc.nextInt();\n        }\n\n        System.out.println(maxEdges(N, M, edges));\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 23:14:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 505;\n\nint n, m;\nvector<int> graph[MAXN];\nbool visited[MAXN];\nbool adj[MAXN][MAXN];\n\nvoid dfs(int u, int depth, int start, set<int>& reachable) {\n    if (depth > 3) return;\n    \n    if (depth == 3) {\n        reachable.insert(u);\n        return;\n    }\n    \n    visited[u] = true;\n    \n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            dfs(v, depth + 1, start, reachable);\n        }\n    }\n    \n    visited[u] = false;\n}\n\nint main() {\n    cin >> n >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        adj[a][b] = adj[b][a] = true;\n    }\n    \n    int additional_edges = 0;\n    \n    for (int u = 1; u <= n; u++) {\n        set<int> reachable_vertices;\n        \n        for (int v : graph[u]) {\n            dfs(v, 1, u, reachable_vertices);\n        }\n        \n        for (int v : reachable_vertices) {\n            if (!adj[u][v] && u != v) {\n                additional_edges++;\n                adj[u][v] = adj[v][u] = true;\n            }\n        }\n    }\n    \n    cout << additional_edges << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_edges_to_add(N, M, edges):\n    from collections import defaultdict, deque\n\n    # Create the adjacency list for the given graph\n    adj_list = defaultdict(list)\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    # Function to perform BFS and calculate 3-edge reachable nodes\n    def bfs_three_edges(u):\n        level = {u: 0}\n        q = deque([u])\n        while q:\n            node = q.popleft()\n            current_level = level[node]\n            if current_level == 3:\n                continue\n            for neighbor in adj_list[node]:\n                if neighbor not in level:\n                    level[neighbor] = current_level + 1\n                    q.append(neighbor)\n        return {node for node, lvl in level.items() if lvl == 3}\n\n    # Finding all pairs (u, v) such that v is 3 edges away from u\n    possible_edges = set()\n    for u in range(1, N + 1):\n        three_edge_neighbors = bfs_three_edges(u)\n        for v in three_edge_neighbors:\n            if u < v and (u, v) not in existing_edges:\n                possible_edges.add((u, v))\n\n    # Convert given edges to a set for quick checking\n    existing_edges = set()\n    for a, b in edges:\n        if a > b:\n            a, b = b, a\n        existing_edges.add((a, b))\n    \n    # Calculate the number of possible new edges\n    return len(possible_edges)\n\n# Example usage\nN = 5\nM = 4\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nprint(max_edges_to_add(N, M, edges))",
    "timestamp": "2025-08-13 14:12:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Graph {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        List<Set<Integer>> graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new HashSet<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int A = scanner.nextInt() - 1;\n            int B = scanner.nextInt() - 1;\n            graph.get(A).add(B);\n            graph.get(B).add(A);\n        }\n\n        scanner.close();\n        \n        int maxEdges = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (!graph.get(i).contains(j) && hasPathOfLengthThree(graph, i, j, N)) {\n                    maxEdges++;\n                }\n            }\n        }\n\n        System.out.println(maxEdges);\n    }\n\n    private static boolean hasPathOfLengthThree(List<Set<Integer>> graph, int u, int v, int N) {\n        // BFS to find path of exactly 3 edges\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[N];\n        int[] dist = new int[N];\n\n        queue.add(u);\n        visited[u] = true;\n        dist[u] = 0;\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n\n            if (dist[node] == 3 && node == v) {\n                return true;\n            } else if (dist[node] < 3) {\n                for (int neighbor : graph.get(node)) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        dist[neighbor] = dist[node] + 1;\n                        queue.add(neighbor);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 14:12:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n\nint n, m;\nint adj[MAX_N][MAX_N];\nbool visited[MAX_N];\nint dist[MAX_N];\n\nvoid bfs(int start) {\n    for (int i = 0; i < n; i++) {\n        visited[i] = false;\n        dist[i] = -1;\n    }\n    int queue[MAX_N];\n    int front = 0, rear = 0;\n    \n    visited[start] = true;\n    dist[start] = 0;\n    queue[rear++] = start;\n    \n    while (front < rear) {\n        int u = queue[front++];\n        for (int v = 0; v < n; v++) {\n            if (adj[u][v] && !visited[v]) {\n                visited[v] = true;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint find_max_edges() {\n    int max_edges = 0;\n    for (int u = 0; u < n; u++) {\n        bfs(u);\n        for (int v = 0; v < n; v++) {\n            if (dist[v] == 3 && !adj[u][v]) {\n                max_edges++;\n                adj[u][v] = adj[v][u] = 1;  // Simulate adding the edge\n            }\n        }\n    }\n    return max_edges;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            adj[i][j] = 0;\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;  // Assuming zero-indexed vertices\n        adj[a][b] = adj[b][a] = 1;\n    }\n    \n    printf(\"%d\\n\", find_max_edges());\n    return 0;\n}",
    "timestamp": "2025-08-13 14:12:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> adj(N + 1);\n\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        adj[A].push_back(B);\n        adj[B].push_back(A);\n    }\n\n    set<pair<int, int>> existingEdges;\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j : adj[i]) {\n            existingEdges.insert({min(i, j), max(i, j)});\n        }\n    }\n\n    set<pair<int, int>> possibleEdges;\n\n    for (int start = 1; start <= N; ++start) {\n        vector<int> distance(N + 1, -1);\n        distance[start] = 0;\n        queue<int> q;\n        q.push(start);\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            if (distance[u] == 3) {\n                possibleEdges.insert({min(start, u), max(start, u)});\n                continue;\n            }\n\n            for (int v : adj[u]) {\n                if (distance[v] == -1) {\n                    distance[v] = distance[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n\n    int additionalEdges = 0;\n\n    for (const auto& edge : possibleEdges) {\n        if (!existingEdges.count(edge)) {\n            ++additionalEdges;\n        }\n    }\n\n    cout << additionalEdges << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:13:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef find_possible_edges(N, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    possible_new_edges = set()\n    \n    for u in range(1, N+1):\n        visited = set()\n        queue = deque([(u, 0)])\n        \n        while queue:\n            curr, dist = queue.popleft()\n            \n            if dist == 3:\n                if curr != u and curr not in graph[u]:\n                    possible_new_edges.add(tuple(sorted((u, curr))))\n                continue\n            \n            if dist > 3:\n                break\n            \n            for neighbor in graph[curr]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist+1))\n    \n    return len(possible_new_edges)\n\ndef main():\n    N, M = map(int, input().split())\n    edges = []\n    \n    for _ in range(M):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    \n    print(find_possible_edges(N, edges))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 14:13:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    existing_edges = set()\n    \n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n        if a > b:\n            a, b = b, a\n        existing_edges.add((a, b))\n    \n    count = 0\n    \n    for u in range(1, N+1):\n        # BFS to find nodes at distance 3\n        visited = [-1] * (N+1)\n        q = deque()\n        q.append(u)\n        visited[u] = 0\n        \n        while q:\n            current = q.popleft()\n            if visited[current] == 3:\n                continue\n            for neighbor in adj[current]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[current] + 1\n                    q.append(neighbor)\n        \n        for v in range(1, N+1):\n            if u == v:\n                continue\n            if visited[v] == 3:\n                a, b = min(u, v), max(u, v)\n                if (a, b) not in existing_edges:\n                    existing_edges.add((a, b))\n                    count += 1\n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 14:13:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxEdgesToAdd(N, M, edges) {\n  const graph = Array.from({ length: N + 1 }, () => []);\n  \n  edges.forEach(([A, B]) => {\n    graph[A].push(B);\n    graph[B].push(A);\n  });\n\n  let count = 0;\n\n  for (let u = 1; u <= N; u++) {\n    const visited = new Set();\n    const queue = [[u, 0]];\n    \n    while (queue.length) {\n      const [current, depth] = queue.shift();\n      \n      if (depth >= 3) continue;\n      \n      for (let v of graph[current]) {\n        if (!visited.has(v)) {\n          visited.add(v);\n          if (depth === 2 && !graph[u].includes(v)) {\n            count++;\n          } else {\n            queue.push([v, depth + 1]);\n          }\n        }\n      }\n    }\n  }\n\n  return count / 2;\n}",
    "timestamp": "2025-08-13 14:13:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const edgeSet = new Set();\n\n    // Build adjacency list\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n        edgeSet.add(`${Math.min(u, v)},${Math.max(u, v)}`);\n    }\n\n    let newEdges = 0;\n\n    // Check 3-edge paths for potential new edges\n    for (let u = 1; u <= N; u++) {\n        for (const mid1 of graph[u]) {\n            if (mid1 === u) continue;\n            for (const mid2 of graph[mid1]) {\n                if (mid2 === u || mid2 === mid1) continue;\n                for (const v of graph[mid2]) {\n                    if (v === u || v === mid1 || v === mid2) continue;\n                    \n                    // Check if new edge doesn't already exist\n                    const newEdge = `${Math.min(u, v)},${Math.max(u, v)}`;\n                    if (!edgeSet.has(newEdge)) {\n                        newEdges++;\n                        edgeSet.add(newEdge);\n                    }\n                }\n            }\n        }\n    }\n\n    return newEdges;\n}",
    "timestamp": "2025-08-13 14:13:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const [N, M] = readInts();\n    const adj = Array.from({ length: N + 1 }, () => new Set());\n    const adjMatrix = Array.from({ length: N + 1 }, () => new Array(N + 1).fill(false));\n\n    for (let i = 0; i < M; i++) {\n        const [a, b] = readInts();\n        adj[a].add(b);\n        adj[b].add(a);\n        adjMatrix[a][b] = true;\n        adjMatrix[b][a] = true;\n    }\n\n    let count = 0;\n    for (let u = 1; u <= N; u++) {\n        const visited = new Array(N + 1).fill(-1);\n        const queue = [];\n        queue.push(u);\n        visited[u] = 0;\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (visited[current] === 3) {\n                if (!adjMatrix[u][current]) {\n                    count++;\n                    adjMatrix[u][current] = true;\n                    adjMatrix[current][u] = true;\n                }\n                continue;\n            }\n\n            for (const neighbor of adj[current]) {\n                if (visited[neighbor] === -1) {\n                    visited[neighbor] = visited[current] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n\n    console.log(count);\n};\n\nconst readInts = () => {\n    const input = readline().split(' ').map(Number);\n    return input;\n};\n\n// For testing purposes, replace readline() with actual input reading\n// Example:\n// const readline = () => {\n//     return inputLines.shift();\n// };\n// const inputLines = ['4 1', '1 2'];\n// solve();",
    "timestamp": "2025-08-13 14:13:48"
  }
]