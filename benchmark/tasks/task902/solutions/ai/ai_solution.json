[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nint n, m;\nEdge edges[MAX_N * 2];\nint head[MAX_N], edge_cnt;\nint deg[MAX_N];\nint value[MAX_N];\nbool vis[MAX_N];\n\nvoid add_edge(int u, int v) {\n    edges[edge_cnt].to = v;\n    edges[edge_cnt].next = head[u];\n    head[u] = edge_cnt++;\n    deg[u]++;\n    deg[v]++;\n}\n\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (!vis[v]) {\n            dfs(v);\n        }\n    }\n}\n\nbool check_connectivity() {\n    memset(vis, 0, sizeof(vis));\n    int start = 1;\n    dfs(start);\n    \n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) return false;\n    }\n    return true;\n}\n\nbool solve() {\n    if (!check_connectivity()) return false;\n    \n    for (int i = 1; i <= n; i++) {\n        bool used[MAX_N] = {0};\n        for (int j = head[i]; j != -1; j = edges[j].next) {\n            int v = edges[j].to;\n            if (value[v] != -1) {\n                used[value[v]] = true;\n            }\n        }\n        \n        int val = 0;\n        while (used[val]) val++;\n        \n        if (val > n) return false;\n        value[i] = val;\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        bool cover[MAX_N] = {0};\n        for (int j = head[i]; j != -1; j = edges[j].next) {\n            int v = edges[j].to;\n            if (value[v] <= value[i]) {\n                cover[value[v]] = true;\n            }\n        }\n        \n        for (int x = 0; x <= value[i]; x++) {\n            if (!cover[x]) return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    memset(head, -1, sizeof(head));\n    memset(value, -1, sizeof(value));\n    memset(deg, 0, sizeof(deg));\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n    \n    printf(\"%s\\n\", solve() ? \"YES\" : \"NO\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 100000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* adj[MAX_N + 1];\nint color[MAX_N + 1];\nbool visited[MAX_N + 1];\nbool is_possible = true;\n\nvoid add_edge(int u, int v) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    new_node->vertex = v;\n    new_node->next = adj[u];\n    adj[u] = new_node;\n}\n\nvoid dfs(int u) {\n    visited[u] = true;\n    int max_color = -1;\n    int count = 0;\n    Node* current = adj[u];\n    while (current != NULL) {\n        int v = current->vertex;\n        if (!visited[v]) {\n            dfs(v);\n        }\n        if (color[v] > max_color) {\n            max_color = color[v];\n            count = 1;\n        } else if (color[v] == max_color) {\n            count++;\n        }\n        current = current->next;\n    }\n    if (max_color == -1) {\n        color[u] = 0;\n    } else {\n        if (count > 1) {\n            is_possible = false;\n        }\n        color[u] = max_color + 1;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        adj[i] = NULL;\n        visited[i] = false;\n    }\n    for (int i = 1; i <= N; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        add_edge(a, i);\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    if (is_possible) {\n        printf(\"POSSIBLE\\n\");\n    } else {\n        printf(\"IMPOSSIBLE\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool solve() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N + 1);\n    vector<int> in_degree(N + 1, 0);\n    \n    for (int i = 0; i < N; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    vector<int> roots;\n    for (int i = 1; i <= N; ++i) {\n        if (in_degree[i] == 0) {\n            roots.push_back(i);\n        }\n    }\n    \n    if (roots.size() != 1) {\n        return false;\n    }\n    \n    int root = roots[0];\n    vector<int> value(N + 1, -1);\n    vector<bool> visited(N + 1, false);\n    vector<int> stack;\n    \n    stack.push_back(root);\n    visited[root] = true;\n    value[root] = 0;\n    \n    while (!stack.empty()) {\n        int u = stack.back();\n        stack.pop_back();\n        \n        for (int v : adj[u]) {\n            if (visited[v]) {\n                if (value[v] == value[u]) {\n                    return false;\n                }\n                continue;\n            }\n            visited[v] = true;\n            value[v] = value[u] + 1;\n            stack.push_back(v);\n        }\n    }\n    \n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            return false;\n        }\n        for (int x = 0; x < value[i]; ++x) {\n            bool found = false;\n            for (int neighbor : adj[i]) {\n                if (value[neighbor] == x) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    if (solve()) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphAssignment {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 1; i <= N; i++) {\n            int a = scanner.nextInt();\n            adj.get(i).add(a);\n            adj.get(a).add(i);\n        }\n\n        int[] color = new int[N + 1];\n        Arrays.fill(color, -1);\n        boolean possible = true;\n\n        for (int i = 1; i <= N; i++) {\n            if (color[i] == -1) {\n                if (!bfs(i, adj, color)) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n\n    private static boolean bfs(int start, List<List<Integer>> adj, int[] color) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        color[start] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            int currentColor = color[u];\n            Set<Integer> neighborColors = new HashSet<>();\n\n            for (int v : adj.get(u)) {\n                if (color[v] == -1) {\n                    color[v] = currentColor + 1;\n                    queue.add(v);\n                } else if (color[v] == currentColor) {\n                    return false;\n                }\n                neighborColors.add(color[v]);\n            }\n\n            for (int x = 0; x < currentColor; x++) {\n                if (!neighborColors.contains(x)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:18:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphVertexAssignment {\n    public static boolean canAssignValues(int N, List<List<Integer>> edges) {\n        // Create adjacency list representation\n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Populate graph\n        for (List<Integer> edge : edges) {\n            int u = edge.get(0);\n            int v = edge.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        // Track visited vertices\n        boolean[] visited = new boolean[N + 1];\n        \n        // Perform DFS to check connectivity and detect components\n        List<Set<Integer>> components = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                Set<Integer> component = new HashSet<>();\n                dfs(i, graph, visited, component);\n                components.add(component);\n            }\n        }\n        \n        // Try assigning values for each component\n        for (Set<Integer> component : components) {\n            if (!assignValuesForComponent(component, graph)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private static void dfs(int vertex, List<List<Integer>> graph, boolean[] visited, Set<Integer> component) {\n        visited[vertex] = true;\n        component.add(vertex);\n        \n        for (int neighbor : graph.get(vertex)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, graph, visited, component);\n            }\n        }\n    }\n    \n    private static boolean assignValuesForComponent(Set<Integer> component, List<List<Integer>> graph) {\n        int[] values = new int[graph.size()];\n        Arrays.fill(values, -1);\n        \n        for (int start : component) {\n            if (values[start] == -1) {\n                if (!dfsAssignValues(start, graph, values, 0)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    private static boolean dfsAssignValues(int vertex, List<List<Integer>> graph, int[] values, int currentValue) {\n        // Assign value if not already assigned\n        if (values[vertex] == -1) {\n            values[vertex] = currentValue;\n        } else if (values[vertex] != currentValue) {\n            return false;\n        }\n        \n        // Check neighbors and create value constraints\n        for (int neighbor : graph.get(vertex)) {\n            // Different values for connected vertices\n            if (values[neighbor] != -1 && values[neighbor] == values[vertex]) {\n                return false;\n            }\n            \n            // Attempt value assignment for neighbors\n            if (values[neighbor] == -1) {\n                // Try to find a suitable value for neighbor\n                boolean found = false;\n                for (int x = 0; x <= currentValue; x++) {\n                    if (!dfsAssignValues(neighbor, graph, values, x)) {\n                        continue;\n                    }\n                    found = true;\n                    break;\n                }\n                \n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int N = 4;\n        List<List<Integer>> edges = Arrays.asList(\n            Arrays.asList(1, 2),\n            Arrays.asList(2, 3),\n            Arrays.asList(3, 4),\n            Arrays.asList(4, 1)\n        );\n        \n        boolean result = canAssignValues(N, edges);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:18:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPossibleAssignment(int N, vector<pair<int, int>>& edges) {\n        // Create adjacency list representation\n        vector<vector<int>> graph(N + 1);\n        vector<int> inDegree(N + 1, 0);\n        \n        for (auto& edge : edges) {\n            graph[edge.first].push_back(edge.second);\n            graph[edge.second].push_back(edge.first);\n            inDegree[edge.first]++;\n            inDegree[edge.second]++;\n        }\n        \n        // Topological sort to check connectivity\n        vector<bool> visited(N + 1, false);\n        queue<int> q;\n        \n        // Start from a vertex with in-degree > 0\n        for (int i = 1; i <= N; i++) {\n            if (inDegree[i] > 0) {\n                q.push(i);\n                visited[i] = true;\n                break;\n            }\n        }\n        \n        int visitedCount = 0;\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            visitedCount++;\n            \n            for (int neighbor : graph[curr]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        \n        // If not all vertices are visited, graph is not weakly connected\n        if (visitedCount != N) return false;\n        \n        // Assign values greedily\n        vector<int> values(N + 1, -1);\n        vector<unordered_set<int>> possibleValues(N + 1);\n        \n        for (int i = 1; i <= N; i++) {\n            // First vertex can have value 0\n            if (values[i] == -1) {\n                values[i] = 0;\n                possibleValues[i].insert(0);\n            }\n            \n            // Check neighbors\n            for (int neighbor : graph[i]) {\n                // Ensure different values for connected vertices\n                if (values[i] == values[neighbor]) {\n                    if (values[neighbor] == -1) {\n                        values[neighbor] = values[i] + 1;\n                        possibleValues[neighbor].insert(values[neighbor]);\n                    } else {\n                        values[i]++;\n                        possibleValues[i].insert(values[i]);\n                    }\n                }\n                \n                // Propagate possible values\n                for (int x = 0; x <= values[i]; x++) {\n                    possibleValues[neighbor].insert(x);\n                }\n            }\n        }\n        \n        // Verify condition 2\n        for (int i = 1; i <= N; i++) {\n            for (int x = 0; x <= values[i]; x++) {\n                bool found = false;\n                for (int neighbor : graph[i]) {\n                    if (possibleValues[neighbor].count(x)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) return false;\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<pair<int, int>> edges(M);\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n    \n    Solution solution;\n    cout << (solution.isPossibleAssignment(N, edges) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def assign_values(N, edges):\n    from collections import defaultdict\n    \n    def dfs(node, graph, visited, assigned, current_value):\n        visited[node] = True\n        assigned[node] = current_value\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, graph, visited, assigned, current_value + 1)\n    \n    # Create adjacency list for undirected graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Assignment and visitation tracking\n    assigned = [None] * (N + 1)\n    visited = [False] * (N + 1)\n\n    # Start DFS from vertex 1 (or any vertex)\n    dfs(1, graph, visited, assigned, 0)\n    \n    # Check if all vertices have assigned values\n    for i in range(1, N + 1):\n        if assigned[i] is None:\n            return False\n    \n    # Verify conditions\n    for u, v in edges:\n        if assigned[u] == assigned[v]:\n            return False\n        if not all(x in [assigned[v2] for v2 in graph[u]] for x in range(assigned[u])):\n            return False\n    \n    return assigned[1:]\n\n# Example usage:\nN = 4\nedges = [(1, 2), (2, 3), (3, 4), (4, 1)]\nprint(assign_values(N, edges))",
    "timestamp": "2025-08-13 14:27:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphAssignment {\n\n    public static boolean assignValues(int N, int[][] edges) {\n        List<Integer>[] adj = new ArrayList[N + 1];\n        int[] inDegree = new int[N + 1];\n        Arrays.fill(inDegree, 0);\n        \n        for (int i = 1; i <= N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        \n        for (int[] edge : edges) {\n            adj[edge[0]].add(edge[1]);\n            inDegree[edge[1]]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            if (inDegree[i] == 0) queue.add(i);\n        }\n        \n        int[] values = new int[N + 1];\n        Arrays.fill(values, -1);\n        \n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            Set<Integer> neighborValues = new HashSet<>();\n            for (int v : adj[u]) {\n                if (values[v] != -1) neighborValues.add(values[v]);\n            }\n            int assignValue = 0;\n            while (neighborValues.contains(assignValue)) {\n                assignValue++;\n            }\n            values[u] = assignValue;\n            \n            for (int v : adj[u]) {\n                if (--inDegree[v] == 0) {\n                    queue.add(v);\n                }\n            }\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (values[i] == -1) return false; \n            Set<Integer> requiredValues = new HashSet<>();\n            for (int v : adj[i]) {\n                requiredValues.add(values[v]);\n            }\n            for (int x = 0; x < values[i]; x++) {\n                if (!requiredValues.contains(x)) return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        int N = 4;\n        int[][] edges = {\n            {1, 2},\n            {2, 3},\n            {3, 4},\n            {4, 1}\n        };\n        \n        System.out.println(assignValues(N, edges));\n    }\n}",
    "timestamp": "2025-08-13 14:27:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAXN 1000\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nint head[MAXN + 1], edgeCount;\nEdge edges[MAXN + 1];\nint values[MAXN + 1];\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nbool assignValues(int N) {\n    memset(values, -1, sizeof(values));\n    for (int i = 1; i <= N; ++i) {\n        int maxValue = 0;\n        for (int e = head[i]; e != -1; e = edges[e].next) {\n            int v = edges[e].to;\n            if (values[v] != -1 && values[v] > maxValue)\n                maxValue = values[v];\n        }\n        values[i] = maxValue + 1;\n        for (int x = 0; x < values[i]; ++x) {\n            bool found = false;\n            for (int e = head[i]; e != -1; e = edges[e].next) {\n                int v = edges[e].to;\n                if (values[v] == x) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    memset(head, -1, sizeof(head));\n    edgeCount = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    \n    if (assignValues(N)) {\n        for (int i = 1; i <= N; ++i) {\n            printf(\"%d\\n\", values[i]);\n        }\n    } else {\n        printf(\"No assignment possible\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:27:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function assignValues(N, edges) {\n    const graph = new Map();\n    const indegree = Array(N + 1).fill(0);\n    const value = Array(N + 1).fill(-1);\n\n    // Construct Graph and Indegree Array\n    for (const [u, v] of edges) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push(v);\n        indegree[v]++;\n    }\n\n    // Perform Topological Sort\n    const queue = [];\n    for (let i = 1; i <= N; i++) {\n        if (indegree[i] === 0) queue.push(i);\n    }\n    \n    let index = 0;\n    while (queue.length) {\n        const u = queue.shift();\n        value[u] = index++;\n        if (!graph.has(u)) continue;\n        \n        for (const v of graph.get(u)) {\n            indegree[v]--;\n            if (indegree[v] === 0) queue.push(v);\n        }\n    }\n\n    // Validate Value Assignment\n    for (let i = 1; i <= N; i++) {\n        if (!graph.has(i)) continue;\n        \n        const childValues = new Set();\n        for (const v of graph.get(i)) {\n            if (childValues.has(value[v])) return false; // Condition 1\n            childValues.add(value[v]);\n        }\n\n        for (let x = 0; x < value[i]; x++) {\n            if (!childValues.has(x)) return false; // Condition 2\n        }\n    }\n\n    return true;\n}\n\n// Example to test: \nconst N = 4;\nconst edges = [[1, 2], [2, 3], [3, 4], [4, 1]];\nconsole.log(assignValues(N, edges)); // Returns value assignment validity",
    "timestamp": "2025-08-13 14:27:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_vertex_assignment(N, edges):\n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        in_degree[u] += 1\n        in_degree[v] += 1\n    \n    # Find a vertex with the minimum in-degree to start\n    start_vertex = in_degree.index(min(in_degree[1:]))\n    \n    # BFS to check and assign values\n    values = [0] * (N + 1)\n    visited = [False] * (N + 1)\n    \n    queue = deque([start_vertex])\n    visited[start_vertex] = True\n    \n    while queue:\n        current = queue.popleft()\n        max_neighbor_value = 0\n        \n        # Find max value among neighbors\n        for neighbor in graph[current]:\n            if values[neighbor] is not None:\n                max_neighbor_value = max(max_neighbor_value, values[neighbor])\n        \n        # Assign value to current vertex\n        values[current] = max_neighbor_value + 1\n        \n        # Process unvisited neighbors\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                queue.append(neighbor)\n                visited[neighbor] = True\n    \n    # Verify condition (2)\n    for i in range(1, N + 1):\n        max_value = values[i]\n        found_all_values = all(\n            any(values[j] == x for j in graph[i])\n            for x in range(max_value + 1)\n        )\n        \n        if not found_all_values:\n            return False\n    \n    return True\n\n# Example usage\nN = int(input())\nedges = []\nfor _ in range(N):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\nresult = solve_vertex_assignment(N, edges)\nprint(\"Possible\" if result else \"Impossible\")",
    "timestamp": "2025-08-13 14:27:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function assignVertexValues(N, edges) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const inDegree = new Array(N + 1).fill(0);\n    \n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n        inDegree[u]++;\n        inDegree[v]++;\n    }\n    \n    const values = new Array(N + 1).fill(-1);\n    const queue = [];\n    \n    for (let i = 1; i <= N; i++) {\n        if (inDegree[i] === 1) {\n            queue.push(i);\n        }\n    }\n    \n    let maxValue = 0;\n    \n    while (queue.length > 0) {\n        const curr = queue.shift();\n        \n        if (values[curr] !== -1) continue;\n        \n        let possibleValue = 0;\n        let neighborValue = -1;\n        \n        for (const neighbor of graph[curr]) {\n            if (values[neighbor] !== -1) {\n                neighborValue = values[neighbor];\n                break;\n            }\n        }\n        \n        if (neighborValue === -1) {\n            values[curr] = 0;\n            maxValue = 0;\n        } else {\n            while (neighborValue === possibleValue) {\n                possibleValue++;\n            }\n            values[curr] = possibleValue;\n            maxValue = Math.max(maxValue, possibleValue);\n        }\n        \n        for (const neighbor of graph[curr]) {\n            if (values[neighbor] === -1) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] === 1) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    for (let i = 1; i <= N; i++) {\n        if (values[i] === -1) {\n            values[i] = maxValue + 1;\n        }\n    }\n    \n    return values.slice(1);\n}",
    "timestamp": "2025-08-13 14:28:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    in_degree = [0]*(N+1)\n    \n    for i in range(1, N+1):\n        a = int(sys.stdin.readline())\n        adj[i].append(a)\n        in_degree[a] += 1\n    \n    # Kahn's algorithm for topological sorting\n    q = deque()\n    for i in range(1, N+1):\n        if in_degree[i] == 0:\n            q.append(i)\n    \n    topo_order = []\n    while q:\n        u = q.popleft()\n        topo_order.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                q.append(v)\n    \n    # Check if the graph is a DAG (impossible since it's weakly connected and N edges)\n    # So it must have exactly one cycle\n    \n    # Find the cycle\n    visited = [False]*(N+1)\n    cycle = []\n    for u in range(1, N+1):\n        if not visited[u]:\n            path = []\n            current = u\n            while True:\n                if visited[current]:\n                    if current in path:\n                        idx = path.index(current)\n                        cycle = path[idx:]\n                    break\n                visited[current] = True\n                path.append(current)\n                if len(adj[current]) == 0:\n                    break\n                current = adj[current][0]\n            if cycle:\n                break\n    \n    # Check the cycle\n    m = len(cycle)\n    if m == 1:\n        print(-1)\n        return\n    \n    # Assign values to the cycle\n    # The cycle must be a directed cycle where each node points to the next\n    # We need to assign values such that for each node, all 0..x-1 are present in neighbors\n    # For a cycle of length m, the minimal possible is m-1 (0..m-2)\n    # Check if m-1 is possible\n    # The cycle must be able to be assigned 0,1,...,m-1 with each consecutive differing by 1 mod m\n    # So the cycle must be a directed cycle where each node points to the next\n    # Verify that the cycle is indeed a directed cycle\n    is_directed_cycle = True\n    for i in range(m):\n        u = cycle[i]\n        v = cycle[(i+1)%m]\n        if v not in adj[u]:\n            is_directed_cycle = False\n            break\n    \n    if not is_directed_cycle:\n        print(-1)\n        return\n    \n    # Now assign values to the cycle\n    # The minimal possible is m-1\n    # Assign 0,1,...,m-1 in order\n    # Check if this works\n    # For each node, the next node must have value (current + 1) mod m\n    # So for node with value x, the next node must have (x+1) mod m\n    # So the values must be consecutive in the cycle\n    # This is satisfied by assigning 0,1,...,m-1 in order\n    \n    # Now assign values to the rest of the nodes (non-cycle nodes)\n    # The non-cycle nodes form a DAG pointing towards the cycle\n    # We can process them in topological order and assign values accordingly\n    value = [0]*(N+1)\n    for u in cycle:\n        value[u] = -1  # mark as unassigned\n    \n    # Assign cycle values\n    for i in range(m):\n        u = cycle[i]\n        value[u] = i\n    \n    # Process nodes in reverse topological order (leaves first)\n    # So we can use the original topo_order (which is in topological order)\n    # Process them in reverse\n    for u in reversed(topo_order):\n        if value[u] != -1:\n            continue\n        # u is not in the cycle\n        # The value of u must be mex of its neighbors\n        neighbors = adj[u]\n        mex = 0\n        neighbor_values = set()\n        for v in neighbors:\n            neighbor_values.add(value[v])\n        while mex in neighbor_values:\n            mex += 1\n        value[u] = mex\n    \n    # Verify the assignment\n    possible = True\n    for u in range(1, N+1):\n        neighbors = adj[u]\n        # Check condition 1: connected vertices have different values\n        for v in neighbors:\n            if value[u] == value[v]:\n                possible = False\n                break\n        if not possible:\n            break\n        # Check condition 2: all 0..value[u]-1 must be present in neighbors\n        neighbor_values = set()\n        for v in neighbors:\n            neighbor_values.add(value[v])\n        for x in range(value[u]):\n            if x not in neighbor_values:\n                possible = False\n                break\n        if not possible:\n            break\n    \n    if possible:\n        print(\" \".join(map(str, value[1:N+1])))\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 14:28:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveGraphAssignment(N, edges) {\n    const adj = Array.from({ length: N + 1 }, () => []);\n    const reverseAdj = Array.from({ length: N + 1 }, () => []);\n    const inDegree = new Array(N + 1).fill(0);\n    \n    for (const [u, v] of edges) {\n        adj[u].push(v);\n        reverseAdj[v].push(u);\n        inDegree[v]++;\n    }\n    \n    const queue = [];\n    for (let i = 1; i <= N; i++) {\n        if (inDegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n    \n    if (queue.length === 0) {\n        return true;\n    }\n    \n    const visited = new Array(N + 1).fill(false);\n    const values = new Array(N + 1).fill(0);\n    \n    function dfs(u) {\n        visited[u] = true;\n        const mexSet = new Set();\n        for (const v of adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n            mexSet.add(values[v]);\n        }\n        let mex = 0;\n        while (mexSet.has(mex)) {\n            mex++;\n        }\n        values[u] = mex;\n    }\n    \n    for (let i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    \n    for (let u = 1; u <= N; u++) {\n        const mexSet = new Set();\n        for (const v of adj[u]) {\n            mexSet.add(values[v]);\n        }\n        let mex = 0;\n        while (mexSet.has(mex)) {\n            mex++;\n        }\n        if (values[u] !== mex) {\n            return false;\n        }\n    }\n    \n    return true;\n}",
    "timestamp": "2025-08-13 14:28:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 1005;\nvector<int> graph[MAXN];\nint values[MAXN];\nint in_degree[MAXN];\n\nvoid topologicalSort(int N) {\n    queue<int> zeroDegree;\n    for (int i = 1; i <= N; ++i) {\n        if (in_degree[i] == 0) {\n            zeroDegree.push(i);\n        }\n    }\n    int processed = 0;\n    while (!zeroDegree.empty()) {\n        int u = zeroDegree.front();\n        zeroDegree.pop();\n        \n        values[u] = in_degree[u];\n        \n        processed++;\n        \n        for (int v : graph[u]) {\n            if (--in_degree[v] == 0) {\n                zeroDegree.push(v);\n            }\n        }\n    }\n    \n    if (processed < N) {\n        cout << \"No valid assignment exists\" << endl;\n        exit(0);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    memset(in_degree, 0, sizeof(in_degree));\n    for (int i = 0; i < N; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    topologicalSort(N);\n    \n    for (int i = 1; i <= N; ++i) {\n        cout << \"Vertex \" << i << \": \" << values[i] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:30"
  }
]