[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_EXPR 105\n\nint calculate(char *expr, int precedence[3]) {\n    int len = strlen(expr);\n    char *postfix = malloc(MAX_EXPR * sizeof(char));\n    int *stack = malloc(MAX_EXPR * sizeof(int));\n    char *ops = malloc(MAX_EXPR * sizeof(char));\n    int top_stack = -1, top_ops = -1, top_postfix = -1;\n\n    int op_prec[256] = {0};\n    op_prec['+'] = precedence[0];\n    op_prec['-'] = precedence[1];\n    op_prec['*'] = precedence[2];\n\n    for (int i = 0; i < len; i++) {\n        if (expr[i] >= '0' && expr[i] <= '9') {\n            postfix[++top_postfix] = expr[i];\n        } else if (expr[i] == '(') {\n            ops[++top_ops] = expr[i];\n        } else if (expr[i] == ')') {\n            while (top_ops >= 0 && ops[top_ops] != '(') {\n                postfix[++top_postfix] = ops[top_ops--];\n            }\n            if (top_ops >= 0 && ops[top_ops] == '(') {\n                top_ops--;\n            }\n        } else {\n            while (top_ops >= 0 && ops[top_ops] != '(' && \n                   op_prec[ops[top_ops]] >= op_prec[expr[i]]) {\n                postfix[++top_postfix] = ops[top_ops--];\n            }\n            ops[++top_ops] = expr[i];\n        }\n    }\n\n    while (top_ops >= 0) {\n        postfix[++top_postfix] = ops[top_ops--];\n    }\n\n    for (int i = 0; i <= top_postfix; i++) {\n        if (postfix[i] >= '0' && postfix[i] <= '9') {\n            stack[++top_stack] = postfix[i] - '0';\n        } else {\n            int b = stack[top_stack--];\n            int a = stack[top_stack--];\n            \n            switch(postfix[i]) {\n                case '+': stack[++top_stack] = a + b; break;\n                case '-': stack[++top_stack] = a - b; break;\n                case '*': stack[++top_stack] = a * b; break;\n            }\n        }\n    }\n\n    int result = stack[top_stack];\n    free(postfix);\n    free(stack);\n    free(ops);\n    return result;\n}\n\nint main() {\n    char expr[MAX_EXPR];\n    scanf(\"%s\", expr);\n\n    int max_result = -2147483648;\n    for (int i = 0; i < 6; i++) {\n        for (int j = 0; j < 6; j++) {\n            for (int k = 0; k < 6; k++) {\n                int precedence[3] = {i, j, k};\n                int result = calculate(expr, precedence);\n                max_result = (result > max_result) ? result : max_result;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\ntypedef struct {\n    long long *data;\n    int top;\n} Stack;\n\nvoid initStack(Stack *s, int size) {\n    s->data = (long long *)malloc(size * sizeof(long long));\n    s->top = -1;\n}\n\nvoid push(Stack *s, long long val) {\n    s->data[++s->top] = val;\n}\n\nlong long pop(Stack *s) {\n    return s->data[s->top--];\n}\n\nlong long eval(char *expr, int precedence[]) {\n    Stack values;\n    Stack ops;\n    initStack(&values, strlen(expr));\n    initStack(&ops, strlen(expr));\n\n    for (int i = 0; expr[i]; ) {\n        if (expr[i] == ' ') {\n            i++;\n            continue;\n        }\n        if (expr[i] == '(') {\n            push(&ops, '(');\n            i++;\n        } else if (expr[i] == ')') {\n            while (ops.top != -1 && ops.data[ops.top] != '(') {\n                long long b = pop(&values);\n                long long a = pop(&values);\n                char op = pop(&ops);\n                if (op == '+') push(&values, a + b);\n                else if (op == '-') push(&values, a - b);\n                else if (op == '*') push(&values, a * b);\n            }\n            pop(&ops);\n            i++;\n        } else if (isdigit(expr[i])) {\n            long long val = 0;\n            while (expr[i] && isdigit(expr[i])) {\n                val = val * 10 + (expr[i] - '0');\n                i++;\n            }\n            push(&values, val);\n        } else {\n            while (ops.top != -1 && ops.data[ops.top] != '(' && \n                   precedence[(int)ops.data[ops.top]] >= precedence[(int)expr[i]]) {\n                long long b = pop(&values);\n                long long a = pop(&values);\n                char op = pop(&ops);\n                if (op == '+') push(&values, a + b);\n                else if (op == '-') push(&values, a - b);\n                else if (op == '*') push(&values, a * b);\n            }\n            push(&ops, expr[i]);\n            i++;\n        }\n    }\n\n    while (ops.top != -1) {\n        long long b = pop(&values);\n        long long a = pop(&values);\n        char op = pop(&ops);\n        if (op == '+') push(&values, a + b);\n        else if (op == '-') push(&values, a - b);\n        else if (op == '*') push(&values, a * b);\n    }\n\n    long long res = pop(&values);\n    free(values.data);\n    free(ops.data);\n    return res;\n}\n\nlong long max_result(char *expr) {\n    long long max = -1LL << 60;\n    int precedence[256] = {0};\n    char ops[] = {'+', '-', '*'};\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                precedence['+'] = i;\n                precedence['-'] = j;\n                precedence['*'] = k;\n                long long res = eval(expr, precedence);\n                if (res > max) max = res;\n            }\n        }\n    }\n    return max;\n}\n\nint main() {\n    char expr[101];\n    fgets(expr, sizeof(expr), stdin);\n    expr[strcspn(expr, \"\\n\")] = 0;\n    printf(\"%lld\\n\", max_result(expr));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <climits>\n#include <map>\n\nusing namespace std;\n\nvector<int> numbers;\nvector<char> ops;\n\nlong long calculate(long long a, long long b, char op) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n    }\n    return 0;\n}\n\nlong long evaluate(const vector<char>& precedence) {\n    vector<long long> nums(numbers.begin(), numbers.end());\n    vector<char> opers(ops.begin(), ops.end());\n    \n    for (char op : precedence) {\n        for (int i = 0; i < opers.size(); ) {\n            if (opers[i] == op) {\n                long long res = calculate(nums[i], nums[i+1], opers[i]);\n                nums[i] = res;\n                nums.erase(nums.begin() + i + 1);\n                opers.erase(opers.begin() + i);\n            } else {\n                i++;\n            }\n        }\n    }\n    return nums[0];\n}\n\nlong long solve(const string& expr) {\n    numbers.clear();\n    ops.clear();\n    \n    int num = 0;\n    for (char c : expr) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            numbers.push_back(num);\n            ops.push_back(c);\n            num = 0;\n        }\n    }\n    numbers.push_back(num);\n    \n    vector<char> operators = {'+', '-', '*'};\n    long long max_val = LLONG_MIN;\n    \n    do {\n        long long val = evaluate(operators);\n        if (val > max_val) {\n            max_val = val;\n        }\n    } while (next_permutation(operators.begin(), operators.end()));\n    \n    return max_val;\n}\n\nint main() {\n    string expr;\n    cin >> expr;\n    cout << solve(expr) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    private static List<Character> ops;\n    private static List<Long> nums;\n    private static long maxResult;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        scanner.close();\n\n        parseExpression(expression);\n        maxResult = Long.MIN_VALUE;\n        permutePrecedence(new ArrayList<>(), new boolean[3]);\n        System.out.println(maxResult);\n    }\n\n    private static void parseExpression(String expression) {\n        ops = new ArrayList<>();\n        nums = new ArrayList<>();\n        StringBuilder num = new StringBuilder();\n        for (char c : expression.toCharArray()) {\n            if (c == '+' || c == '-' || c == '*') {\n                ops.add(c);\n                nums.add(Long.parseLong(num.toString()));\n                num = new StringBuilder();\n            } else {\n                num.append(c);\n            }\n        }\n        nums.add(Long.parseLong(num.toString()));\n    }\n\n    private static void permutePrecedence(List<Character> current, boolean[] used) {\n        if (current.size() == 3) {\n            evaluatePrecedence(current);\n            return;\n        }\n        for (int i = 0; i < 3; i++) {\n            if (!used[i]) {\n                char op;\n                if (i == 0) op = '+';\n                else if (i == 1) op = '-';\n                else op = '*';\n                used[i] = true;\n                current.add(op);\n                permutePrecedence(current, used);\n                current.remove(current.size() - 1);\n                used[i] = false;\n                // Allow same precedence by skipping marking as used\n                permutePrecedence(current, used);\n                return;\n            }\n        }\n    }\n\n    private static void evaluatePrecedence(List<Character> precedenceOrder) {\n        List<Long> currentNums = new ArrayList<>(nums);\n        List<Character> currentOps = new ArrayList<>(ops);\n\n        for (char op : precedenceOrder) {\n            for (int i = 0; i < currentOps.size(); ) {\n                if (currentOps.get(i) == op) {\n                    long a = currentNums.get(i);\n                    long b = currentNums.get(i + 1);\n                    long res = compute(a, b, op);\n                    currentNums.set(i, res);\n                    currentNums.remove(i + 1);\n                    currentOps.remove(i);\n                } else {\n                    i++;\n                }\n            }\n        }\n        long result = currentNums.get(0);\n        if (result > maxResult) {\n            maxResult = result;\n        }\n    }\n\n    private static long compute(long a, long b, char op) {\n        switch (op) {\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;\n            case '*':\n                return a * b;\n            default:\n                return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:51:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxExpressionValue {\n    public static long maxValue(String expression) {\n        long maxResult = Long.MIN_VALUE;\n        \n        for (int mul = 0; mul <= 2; mul++) {\n            for (int add = 0; add <= 2; add++) {\n                for (int sub = 0; sub <= 2; sub++) {\n                    if (mul != add && mul != sub && add != sub) {\n                        long result = calculate(expression, mul, add, sub);\n                        maxResult = Math.max(maxResult, result);\n                    }\n                }\n            }\n        }\n        \n        return maxResult;\n    }\n    \n    private static long calculate(String expression, int mulPrecedence, int addPrecedence, int subPrecedence) {\n        List<String> tokens = tokenize(expression);\n        return evaluateExpression(tokens, mulPrecedence, addPrecedence, subPrecedence);\n    }\n    \n    private static List<String> tokenize(String expression) {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder num = new StringBuilder();\n        \n        for (char c : expression.toCharArray()) {\n            if (Character.isDigit(c)) {\n                num.append(c);\n            } else {\n                if (num.length() > 0) {\n                    tokens.add(num.toString());\n                    num.setLength(0);\n                }\n                tokens.add(String.valueOf(c));\n            }\n        }\n        \n        if (num.length() > 0) {\n            tokens.add(num.toString());\n        }\n        \n        return tokens;\n    }\n    \n    private static long evaluateExpression(List<String> tokens, int mulPrecedence, int addPrecedence, int subPrecedence) {\n        Stack<Long> numbers = new Stack<>();\n        Stack<String> operators = new Stack<>();\n        \n        for (String token : tokens) {\n            if (isNumber(token)) {\n                numbers.push(Long.parseLong(token));\n            } else if (token.equals(\"(\")) {\n                operators.push(token);\n            } else if (token.equals(\")\")) {\n                while (!operators.peek().equals(\"(\")) {\n                    processOperator(numbers, operators);\n                }\n                operators.pop();\n            } else {\n                while (!operators.isEmpty() && !operators.peek().equals(\"(\") && \n                       hasPrecedence(token, operators.peek(), mulPrecedence, addPrecedence, subPrecedence)) {\n                    processOperator(numbers, operators);\n                }\n                operators.push(token);\n            }\n        }\n        \n        while (!operators.isEmpty()) {\n            processOperator(numbers, operators);\n        }\n        \n        return numbers.pop();\n    }\n    \n    private static boolean hasPrecedence(String currentOp, String topOp, int mulPrecedence, int addPrecedence, int subPrecedence) {\n        if (topOp.equals(\"(\") || topOp.equals(\")\")) return false;\n        \n        int currentPrecedence = getPrecedence(currentOp, mulPrecedence, addPrecedence, subPrecedence);\n        int topPrecedence = getPrecedence(topOp, mulPrecedence, addPrecedence, subPrecedence);\n        \n        return topPrecedence >= currentPrecedence;\n    }\n    \n    private static int getPrecedence(String op, int mulPrecedence, int addPrecedence, int subPrecedence) {\n        switch (op) {\n            case \"*\": return mulPrecedence;\n            case \"+\": return addPrecedence;\n            case \"-\": return subPrecedence;\n            default: return -1;\n        }\n    }\n    \n    private static void processOperator(Stack<Long> numbers, Stack<String> operators) {\n        long b = numbers.pop();\n        long a = numbers.pop();\n        String op = operators.pop();\n        \n        switch (op) {\n            case \"*\":\n                numbers.push(a * b);\n                break;\n            case \"+\":\n                numbers.push(a + b);\n                break;\n            case \"-\":\n                numbers.push(a - b);\n                break;\n        }\n    }\n    \n    private static boolean isNumber(String token) {\n        return token.matches(\"\\\\d+\");\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        System.out.println(maxValue(expression));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:51:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nlong long evaluateExpression(string expr, vector<int>& precedence) {\n    vector<string> tokens;\n    string num;\n    for (char c : expr) {\n        if (isdigit(c)) {\n            num += c;\n        } else {\n            if (!num.empty()) {\n                tokens.push_back(num);\n                num.clear();\n            }\n            tokens.push_back(string(1, c));\n        }\n    }\n    if (!num.empty()) tokens.push_back(num);\n\n    stack<long long> values;\n    stack<string> ops;\n\n    for (string token : tokens) {\n        if (isdigit(token[0])) {\n            values.push(stoll(token));\n        } else {\n            while (!ops.empty() && \n                   ((token == \"*\" && precedence[2] >= precedence[ops.top()[0] == '*' ? 2 : ops.top()[0] == '+' ? 0 : 1]) ||\n                    (token == \"+\" && precedence[0] >= precedence[ops.top()[0] == '*' ? 2 : ops.top()[0] == '+' ? 0 : 1]) ||\n                    (token == \"-\" && precedence[1] >= precedence[ops.top()[0] == '*' ? 2 : ops.top()[0] == '+' ? 0 : 1]))) {\n                long long b = values.top(); values.pop();\n                long long a = values.top(); values.pop();\n                string op = ops.top(); ops.pop();\n\n                if (op == \"+\") values.push(a + b);\n                else if (op == \"-\") values.push(a - b);\n                else values.push(a * b);\n            }\n            ops.push(token);\n        }\n    }\n\n    while (!ops.empty()) {\n        long long b = values.top(); values.pop();\n        long long a = values.top(); values.pop();\n        string op = ops.top(); ops.pop();\n\n        if (op == \"+\") values.push(a + b);\n        else if (op == \"-\") values.push(a - b);\n        else values.push(a * b);\n    }\n\n    return values.top();\n}\n\nint main() {\n    string expr;\n    cin >> expr;\n\n    long long maxResult = LLONG_MIN;\n    for (int i = 0; i < 6; i++) {\n        vector<int> precedence(3);\n        switch(i) {\n            case 0: precedence = {0, 1, 2}; break;\n            case 1: precedence = {0, 2, 1}; break;\n            case 2: precedence = {1, 0, 2}; break;\n            case 3: precedence = {1, 2, 0}; break;\n            case 4: precedence = {2, 0, 1}; break;\n            case 5: precedence = {2, 1, 0}; break;\n        }\n        maxResult = max(maxResult, evaluateExpression(expr, precedence));\n    }\n\n    cout << maxResult << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef calc(expr, precedence):\n    def eval_expr(tokens):\n        stack = []\n        num = 0\n        sign = \"+\"\n        i = 0\n        n = len(tokens)\n        while i < n:\n            token = tokens[i]\n            if token.isdigit():\n                num = int(token)\n            if token == \"(\":\n                j = i\n                balance = 0\n                while i < n:\n                    if tokens[i] == \"(\":\n                        balance += 1\n                    if tokens[i] == \")\":\n                        balance -= 1\n                    if balance == 0:\n                        break\n                    i += 1\n                num = eval_expr(tokens[j+1:i])\n            if token in \"+-* \" or i == n-1:\n                if precedence[sign] > precedence.get(stack[-1] if stack else \"\", -1):\n                    while stack and precedence[sign] > precedence[stack[-1]]:\n                        top_op = stack.pop()\n                        top_num = stack.pop()\n                        if top_op == '+':\n                            num = top_num + num\n                        elif top_op == '-':\n                            num = top_num - num\n                        elif top_op == '*':\n                            num = top_num * num\n                stack.append(num)\n                stack.append(sign)\n                sign = token\n            i += 1\n        return stack[0] if stack else num\n\n    tokens = []\n    value = ''\n    for ch in expr:\n        if ch.isdigit():\n            value += ch\n        else:\n            if value:\n                tokens.append(value)\n                value = ''\n            if ch in '()+-*':\n                tokens.append(ch)\n    if value:\n        tokens.append(value)\n    precedence[''] = -1\n    return eval_expr(tokens)\n\ndef max_result(expression):\n    max_value = float('-inf')\n    ops = ['+', '-', '*']\n    precedence_levels = list(itertools.permutations(range(len(ops))))\n    precedence_levels.extend([(1, 1, 1)])\n    for levels in precedence_levels:\n        precedence = {op: level for op, level in zip(ops, levels)}\n        max_value = max(max_value, calc(expression, precedence))\n    return max_value\n\n# Example usage\nexpr = \"1+2*3-4\"\nprint(max_result(expr))",
    "timestamp": "2025-08-13 07:43:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxExpressionValue {\n\n    public static int maxExpressionValue(String expression) {\n        Set<String> permutations = new HashSet<>();\n        char[] operators = {'+', '-', '*'};\n        permuteOperators(operators, 0, permutations);\n        \n        int maxValue = Integer.MIN_VALUE;\n        for (String perm : permutations) {\n            maxValue = Math.max(maxValue, evaluateExpression(expression, perm));\n        }\n        return maxValue;\n    }\n    \n    private static void permuteOperators(char[] arr, int start, Set<String> result) {\n        if (start == arr.length) {\n            result.add(new String(arr));\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, start, i);\n            permuteOperators(arr, start + 1, result);\n            swap(arr, start, i);\n        }\n    }\n\n    private static void swap(char[] arr, int i, int j) {\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    private static int evaluateExpression(String expression, String precedence) {\n        Map<Character, Integer> precedenceMap = new HashMap<>();\n        for (int i = 0; i < precedence.length(); i++) {\n            precedenceMap.put(precedence.charAt(i), i);\n        }\n        return evaluateInPrecedence(expression, precedenceMap);\n    }\n    \n    private static int evaluateInPrecedence(String expression, Map<Character, Integer> precedenceMap) {\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> operators = new Stack<>();\n        \n        int i = 0;\n        while (i < expression.length()) {\n            char ch = expression.charAt(i);\n            \n            if (Character.isDigit(ch)) {\n                int val = 0;\n                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                    val = val * 10 + (expression.charAt(i) - '0');\n                    i++;\n                }\n                values.push(val);\n                continue;\n            }\n            \n            if (ch == '(') {\n                operators.push(ch);\n            } else if (ch == ')') {\n                while (!operators.isEmpty() && operators.peek() != '(') {\n                    processStack(values, operators);\n                }\n                operators.pop();\n            } else {\n                while (!operators.isEmpty() && precedenceMap.get(operators.peek()) >= precedenceMap.get(ch)) {\n                    processStack(values, operators);\n                }\n                operators.push(ch);\n            }\n            i++;\n        }\n        \n        while (!operators.isEmpty()) {\n            processStack(values, operators);\n        }\n        \n        return values.pop();\n    }\n    \n    private static void processStack(Stack<Integer> values, Stack<Character> operators) {\n        int b = values.pop();\n        int a = values.pop();\n        char op = operators.pop();\n        int res = performOp(a, b, op);\n        values.push(res);\n    }\n    \n    private static int performOp(int a, int b, char op) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            default: return 0;\n        }\n    }\n    \n    public static void main(String[] args) {\n        String expression = \"3+(2*2-1)\";\n        System.out.println(maxExpressionValue(expression)); // Output may vary depending on the input expression\n    }\n}",
    "timestamp": "2025-08-13 07:43:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint evaluate(int a, char op, int b) {\n    switch(op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n    }\n    return INT_MIN; // Shouldn't reach here\n}\n\nint computeMaxResult(char *expr) {\n    int n = strlen(expr);\n    char ops[] = \"+-*\";\n    \n    // The maximum result we can get by rearranging precedence\n    int maxResult = INT_MIN;\n\n    for (int op1 = 0; op1 < 3; ++op1) {\n        for (int op2 = 0; op2 < 3; ++op2) {\n            if (op1 == op2) continue; // Prevent duplicate precedence levels\n\n            for (int op3 = 0; op3 < 3; ++op3) {\n                if (op3 == op1 || op3 == op2) continue; // Prevent duplicate precedence levels\n\n                // Precedence levels\n                int precedence[256];\n                precedence[ops[op1]] = 1;\n                precedence[ops[op2]] = 2;\n                precedence[ops[op3]] = 3;\n\n                // Value stack\n                int values[n], vs = 0;\n\n                // Operator stack\n                char operators[n];\n                int os = 0;\n\n                int i = 0;\n                while (i < n) {\n                    if (expr[i] >= '0' && expr[i] <= '9') {\n                        // Parse number\n                        int num = 0;\n                        while (i < n && expr[i] >= '0' && expr[i] <= '9') {\n                            num = num * 10 + (expr[i] - '0');\n                            ++i;\n                        }\n                        values[vs++] = num;\n                    } else if (expr[i] == '(') {\n                        operators[os++] = expr[i];\n                        ++i;\n                    } else if (expr[i] == ')') {\n                        while (os > 0 && operators[os - 1] != '(') {\n                            char op = operators[--os];\n                            int b = values[--vs];\n                            int a = values[--vs];\n                            values[vs++] = evaluate(a, op, b);\n                        }\n                        --os; // Pop '('\n                        ++i;\n                    } else {\n                        // Operator encountered\n                        while (os > 0 && precedence[operators[os - 1]] >= precedence[expr[i]]) {\n                            char op = operators[--os];\n                            int b = values[--vs];\n                            int a = values[--vs];\n                            values[vs++] = evaluate(a, op, b);\n                        }\n                        operators[os++] = expr[i];\n                        ++i;\n                    }\n                }\n\n                while (os > 0) {\n                    char op = operators[--os];\n                    int b = values[--vs];\n                    int a = values[--vs];\n                    values[vs++] = evaluate(a, op, b);\n                }\n\n                if (vs == 1) {\n                    if (values[0] > maxResult) {\n                        maxResult = values[0];\n                    }\n                }\n            }\n        }\n    }\n\n    return maxResult;\n}\n\nint main() {\n    char expression[101];\n    printf(\"Enter the expression: \");\n    scanf(\"%s\", expression);\n    \n    int maxValue = computeMaxResult(expression);\n    printf(\"Maximum Result: %d\\n\", maxValue);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:44:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate(expression, precedence):\n    def tokenize(expr):\n        tokens = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in '+-*()':\n                tokens.append(expr[i])\n                i += 1\n            elif expr[i].isdigit():\n                num = 0\n                while i < len(expr) and expr[i].isdigit():\n                    num = num * 10 + int(expr[i])\n                    i += 1\n                tokens.append(num)\n            else:\n                i += 1\n        return tokens\n\n    def parse(tokens, prec):\n        def higher_precedence(op1, op2):\n            return prec[op1] > prec[op2]\n\n        def apply_op(operators, values):\n            op = operators.pop()\n            right = values.pop()\n            left = values.pop()\n            if op == '+':\n                values.append(left + right)\n            elif op == '-':\n                values.append(left - right)\n            else:\n                values.append(left * right)\n\n        values = []\n        operators = []\n        i = 0\n        while i < len(tokens):\n            if isinstance(tokens[i], int):\n                values.append(tokens[i])\n            elif tokens[i] == '(':\n                operators.append(tokens[i])\n            elif tokens[i] == ')':\n                while operators and operators[-1] != '(':\n                    apply_op(operators, values)\n                operators.pop()\n            else:\n                while (operators and operators[-1] != '(' and \n                       (higher_precedence(operators[-1], tokens[i]) or \n                        (operators[-1] in '+-*' and operators[-1] != tokens[i]))):\n                    apply_op(operators, values)\n                operators.append(tokens[i])\n            i += 1\n\n        while operators:\n            apply_op(operators, values)\n\n        return values[0]\n\n    max_result = float('-inf')\n    for a in range(3):\n        for b in range(3):\n            for c in range(3):\n                prec = {'+': a, '-': b, '*': c}\n                tokens = tokenize(expression)\n                result = parse(tokens, prec)\n                max_result = max(max_result, result)\n\n    return max_result\n\n# Read input\nexpression = input().strip()\nprint(calculate(expression, {}))",
    "timestamp": "2025-08-13 07:44:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import re\nfrom itertools import permutations\n\ndef solve():\n    s = input().strip()\n    # Extract numbers and operators\n    nums = list(map(int, re.split(r'\\+|\\-|\\*', s)))\n    ops = re.findall(r'\\+|\\-|\\*', s)\n    \n    max_val = -float('inf')\n    # Try all possible precedence permutations for the three operators\n    for precedence in permutations(['+', '-', '*']):\n        # Create a dictionary to map operator to precedence level\n        op_priority = {op: i for i, op in enumerate(precedence)}\n        \n        # Process numbers and operators with current precedence\n        stack_nums = [nums[0]]\n        stack_ops = []\n        \n        for i in range(len(ops)):\n            current_op = ops[i]\n            # Process stack_ops based on precedence\n            while stack_ops and op_priority[stack_ops[-1]] <= op_priority[current_op]:\n                op = stack_ops.pop()\n                b = stack_nums.pop()\n                a = stack_nums.pop()\n                if op == '+':\n                    stack_nums.append(a + b)\n                elif op == '-':\n                    stack_nums.append(a - b)\n                elif op == '*':\n                    stack_nums.append(a * b)\n            stack_ops.append(current_op)\n            stack_nums.append(nums[i+1])\n        \n        # Process remaining operations\n        while stack_ops:\n            op = stack_ops.pop()\n            b = stack_nums.pop()\n            a = stack_nums.pop()\n            if op == '+':\n                stack_nums.append(a + b)\n            elif op == '-':\n                stack_nums.append(a - b)\n            elif op == '*':\n                stack_nums.append(a * b)\n        \n        current_result = stack_nums[0]\n        if current_result > max_val:\n            max_val = current_result\n    \n    print(max_val)\n\nsolve()",
    "timestamp": "2025-08-13 07:44:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nint evaluateExpression(const string &expr, const string &order) {\n    stack<int> values;\n    stack<char> ops;\n    int i = 0;\n\n    auto applyOp = [](int a, int b, char op) {\n        switch(op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n        }\n        return 0;\n    };\n\n    auto precedence = [&](char op) {\n        return order.find(op);\n    };\n\n    auto processOps = [&]() {\n        while (!ops.empty() && values.size() > 1) {\n            int b = values.top(); values.pop();\n            int a = values.top(); values.pop();\n            char op = ops.top(); ops.pop();\n            values.push(applyOp(a, b, op));\n        }\n    };\n\n    while (i < expr.size()) {\n        if (isspace(expr[i])) {\n            i++;\n            continue;\n        }\n        if (isdigit(expr[i])) {\n            int value = 0;\n            while (i < expr.size() && isdigit(expr[i])) {\n                value = value * 10 + (expr[i] - '0');\n                i++;\n            }\n            values.push(value);\n        } else if (expr[i] == '(') {\n            ops.push(expr[i]);\n            i++;\n        } else if (expr[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                processOps();\n            }\n            ops.pop(); // pop opening '('\n            i++;\n        } else {\n            while (!ops.empty() && precedence(ops.top()) <= precedence(expr[i])) {\n                processOps();\n            }\n            ops.push(expr[i]);\n            i++;\n        }\n    }\n    processOps();\n    return values.top();\n}\n\nint maximizeResult(const string &expr) {\n    string operators = \"+-*\";\n    int maxResult = INT_MIN;\n    do {\n        maxResult = max(maxResult, evaluateExpression(expr, operators));\n    } while (next_permutation(operators.begin(), operators.end()));\n    return maxResult;\n}\n\nint main() {\n    string expr;\n    cin >> expr;\n    cout << maximizeResult(expr) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:30"
  }
]