[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn._\nobject Main extends App {\n  readLine.trim match {\n    case Expression(e) ⇒\n      println(math.max(e.execute(Operator(Plus, Minus, Times), Operator(Plus), Operator(Plus)), Array(Operator(Plus), Operator(Minus), Operator(Times)).permutations.flatMap{case Array(p, n, s) ⇒ Array(e.execute(p, n, s), e.execute(p + n, n, s), e.execute(p, n + s, s))}.max))\n    case _ ⇒ ???\n  }\n}\nobject Expression {\n  def unapply(arg: String): Option[Expression] = {\n    arg.toList match {\n      case f Formula Nil ⇒ Some(Expression(f))\n      case _ ⇒ ???\n    }\n  }\n  object Num {\n    def unapply(arg: List[Char]): Option[(Number, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (h, t) ⇒ Some(Number(h.foldLeft(0L){case (acc, r) ⇒ acc * 10 + r.asDigit}), t)\n      }\n    }\n  }\n  object Formula {\n    def unapply(arg: List[Char]): Option[(Expr, List[Char])] = {\n      arg match {\n        case n Num r ⇒\n          r match {\n            case '+'::(m Formula rest) ⇒ Some(Expr(n, Succ(Plus, m)), rest)\n            case '-'::(m Formula rest) ⇒ Some(Expr(n, Succ(Minus, m)), rest)\n            case '*'::(m Formula rest) ⇒ Some(Expr(n, Succ(Times, m)), rest)\n            case _ ⇒ Some((Expr(n, End), r))\n          }\n        case '('::(f Formula ')'::r) ⇒\n          r match {\n            case '+'::(m Formula rest) ⇒ Some(Expr(Bracket(Expression(f)), Succ(Plus, m)), rest)\n            case '-'::(m Formula rest) ⇒ Some(Expr(Bracket(Expression(f)), Succ(Minus, m)), rest)\n            case '*'::(m Formula rest) ⇒ Some(Expr(Bracket(Expression(f)), Succ(Times, m)), rest)\n            case _ ⇒ Some((Expr(Bracket(Expression(f)), End), r))\n          }\n        case _ ⇒ None\n      }\n    }\n  }\n}\n\nobject Operator {\n  def apply(operator: BiOp*): Operator = new Operator(operator)\n}\nclass Operator(val operator: Seq[BiOp]) {\n  def unapply(op: BiOp): Option[(Long ⇒ Long ⇒ Long)] = {\n    Some(op).filter(operator.contains)\n  }\n  def +(that: Operator): Operator = new Operator(operator ++ that.operator)\n}\ncase class Expression(expr: Expr) {\n  def execute(priOp: Operator, norOp: Operator, subOp: Operator): Long = {\n    expr.flatten(priOp, norOp, subOp).calculate(priOp, norOp, subOp)\n  }\n}\ncase class FExpr(head: Long, tail: FExprT) {\n  def calculate(priOp: Operator, norOp: Operator, subOp: Operator): Long = consume(consume(consume(this, priOp), norOp), subOp) match {\n    case head FExpr FEnd ⇒ head\n    case _ ⇒ ???\n  }\n  private def consume(expr: FExpr, operator: Operator): FExpr = {\n    expr match {\n      case left FExpr (operator(op) FSucc (right FExpr rest)) ⇒ consume(FExpr(op(left)(right), rest), operator)\n      case head FExpr (op FSucc rest) ⇒ FExpr(head, FSucc(op, consume(rest, operator)))\n      case _ ⇒ expr\n    }\n  }\n}\nsealed trait FExprT\ncase class FSucc(op: BiOp, tail: FExpr) extends FExprT\ncase object FEnd extends FExprT\n\ncase class Expr(head: Factor, tail: ExprT) {\n  def flatten(priOp: Operator, norOp: Operator, subOp: Operator): FExpr = {\n    head match {\n      case Bracket(expr) ⇒ FExpr(expr.execute(priOp, norOp, subOp), tail.flatten(priOp: Operator, norOp: Operator, subOp: Operator))\n      case Number(value) ⇒ FExpr(value, tail.flatten(priOp: Operator, norOp: Operator, subOp: Operator))\n    }\n  }\n}\nsealed trait ExprT {\n  def flatten(priOp: Operator, norOp: Operator, subOp: Operator): FExprT = {\n    this match {\n      case End ⇒ FEnd\n      case op Succ tail ⇒ FSucc(op, tail.flatten(priOp, norOp, subOp))\n    }\n  }\n}\ncase class Succ(op: BiOp, tail: Expr) extends ExprT\ncase object End extends ExprT\n\nsealed trait Factor\ncase class Bracket(expr: Expression) extends Factor\ncase class Number(value: Long) extends Factor\n\nsealed trait BiOp extends (Long ⇒ Long ⇒ Long)\ncase object Plus extends BiOp {\n  override def apply(v1: Long): Long ⇒ Long = v1.+\n}\ncase object Minus extends BiOp {\n  override def apply(v1: Long): Long ⇒ Long = v1.-\n}\ncase object Times extends BiOp  {\n  override def apply(v1: Long): Long ⇒ Long = v1.*\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cctype>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n\nll d[3];\n\nll number(State &begin) {\n  ll ans = 0;\n  while (isdigit(*begin)) ans = ans * 10 + (*begin - '0'), begin++;\n  return ans;\n}\n\nll first(State &begin);\n\nll check(State &begin) {\n  if (isdigit(*begin)) return number(begin);\n  begin++;\n  ll ans = first(begin);\n  begin++;\n  return ans;\n}\n\nll third(State &begin) {\n  ll ans = check(begin);\n  while (1) {\n    if (*begin == '*' && d[0] == 2) begin++, ans *= check(begin);\n    else if (*begin == '+' && d[1] == 2) begin++, ans += check(begin);\n    else if (*begin == '-' && d[2] == 2) begin++, ans -= check(begin);\n    else return ans;\n  }\n}\n\nll second(State &begin) {\n  ll ans = third(begin);\n  while (1) {\n    if (*begin == '*' && d[0] == 1) begin++, ans *= third(begin);\n    else if (*begin == '+' && d[1] == 1) begin++, ans += third(begin);\n    else if (*begin == '-' && d[2] == 1) begin++, ans -= third(begin);\n    else return ans;\n  }\n}\n\nll first(State &begin) {\n  ll ans = second(begin);\n  while (1) {\n    if (*begin == '*' && d[0] == 0) begin++, ans *= second(begin);\n    else if (*begin == '+' && d[1] == 0) begin++, ans += second(begin);\n    else if (*begin == '-' && d[2] == 0) begin++, ans -= second(begin);\n    else return ans;\n  }\n}\n\nint main() {\n  string s;\n  cin >> s;\n  State begin = s.begin();\n  ll ans = first(begin);\n  for (ll i = 0; i < 3; i++) for (ll j = 0; j < 3; j++) for (ll k = 0; k < 3; k++) {\n    d[0] = i, d[1] = j, d[2] = k;\n    State begin = s.begin();\n    //cout << first(begin) << endl;\n    //begin = s.begin();\n    ans = max(ans, first(begin));\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[10][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}};\n\n// stringテ・ツ楪凝」ツつ値ong long intテ・ツ楪凝」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            while (str[j] != ')') {\n                j++;\n            }\n            long long int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n    long long int max_res = -1e09;\n\n    for (long long int i = 0; i < 10; i++) {\n        //ansテ」ツ?ィmax_resテ」ツつ津ヲツッツ氾ィツシツε」ツ?凖」ツつ?\n        long long int ans = act(str, i);\n        //cout << \"I = \" << i << endl;\n        //cout << \"ANS = \" << ans << endl;\n        if (ans > max_res) {\n            max_res = ans;\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define int long long\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint expression1(State &begin);\nint expression2(State &begin);\nint expression3(State &begin);\n\nvector<int> priority(3);\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin)-'0';\n    begin++;\n  }\n  // cout<<\"number: \"<<ret<<endl;\n  return ret;\n}\n\nint factor(State &begin){\n  // cout<<\"in factor: \"<<*begin<<endl;\n  int ret;\n  if(*begin=='('){\n    begin++;\n    ret=expression1(begin);\n    begin++;\n  }else{\n    // cout<<\"factor in number\" <<endl;\n    ret=number(begin);\n  }\n  return ret;\n}\n\nint expression3(State &begin){\n  // cout<<\"in expr3: \"<<endl;\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='+'&&priority[2]&(1<<0)){\n      begin++;\n      ret+=factor(begin);\n    }else if(*begin=='-'&&priority[2]&(1<<1)){\n      begin++;\n      ret-=factor(begin);\n    }else if(*begin=='*'&&priority[2]&(1<<2)){\n      begin++;\n      ret*=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression2(State &begin){\n  int ret=expression3(begin);\n  // cout<<\"in expr2: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[1]&(1<<0)){\n      begin++;\n      ret+=expression3(begin);\n    }else if(*begin=='-'&&priority[1]&(1<<1)){\n      begin++;\n      ret-=expression3(begin);\n    }else if(*begin=='*'&&priority[1]&(1<<2)){\n      begin++;\n      ret*=expression3(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression1(State &begin){\n  int ret=expression2(begin);\n  // cout<<\"in expr1: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[0]&(1<<0)){\n      begin++;\n      ret+=expression2(begin);\n    }else if(*begin=='-'&&priority[0]&(1<<1)){\n      begin++;\n      ret-=expression2(begin);\n    }else if(*begin=='*'&&priority[0]&(1<<2)){\n      begin++;\n      ret*=expression2(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  int ans=LLONG_MIN;\n  for(int i=0;i<(1<<3);i++){\n    for(int j=0;j<(1<<3);j++){\n      for(int k=0;k<(1<<3);k++){\n    if((i|j|k)!=7)continue;\n    priority[0]=i;priority[1]=j;priority[2]=k;\n    State begin=s.begin();\n        //cout<<i<<\" \"<<j<<\" \"<<k<<\": \"<<expression1(begin)<<endl;\n    ans=max(ans,expression1(begin));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst vi add = {1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 3};\nconst vi sub = {1, 1, 2, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2};\nconst vi mul = {1, 1, 1, 2, 1, 2, 2, 3, 2, 3, 1, 2, 1};\n\nstring formula;\n\nll parse(int b, int e, int ord){\n    vector<ll> v;\n    vector<char> op;\n\n    range(i, b, e){\n        if(formula.at(i) == '('){\n            int next_b = i + 1, cnt = 1;\n            while(cnt){\n                if(formula[++i] == '(') cnt++;\n                else if(formula[i] == ')') cnt--;\n            }\n            v.pb(parse(next_b, i, ord));\n        }\n        else if(isdigit(formula.at(i))){\n            ll value = 0;\n            while(i < e && isdigit(formula.at(i))){\n                value = 10 * value + formula.at(i++) - '0';\n            }\n            v.pb(value);\n\n            i--;\n        }\n        else{\n            op.pb(formula.at(i));\n        }\n    }\n  \n    if(v.size() == 0) return 0;\n\n    range(i, 1, 4){\n        rep(j, op.size()){\n            bool operated = false;\n\n            if(op[j] == '+' && add[ord] == i){\n                v[j] = v[j] + v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '-' && sub[ord] == i){\n                v[j] = v[j] - v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '*' && mul[ord] == i){\n                v[j] = v[j] * v[j + 1];\n                operated = true;\n            }\n\n            if(operated){\n                v.erase(v.begin() + j + 1);\n                op.erase(op.begin() + j);\n                j--;\n            }\n        }\n    }\n\n    return v[0];\n}\n\nint main(void){\n    for(; cin >> formula;){\n        ll res = parse(0, formula.size(), 0);\n\n        range(i, 1, add.size()){\n            res = max(res, parse(0, formula.size(), i));\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <climits>\n#include <cctype>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0); (i) < (n); ++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed << setprecision(20)\n#define SHOWP(x) cerr<<\"[\"<<(x).FI<<\", \"<<(x).SE<<\"]\";\n#define SHOWX(x) cerr<<#x<<\": \"<<x<<endl;\n#define SHOWVEC(v, e) REP(i, e) cerr << (v[i]) << ' '; cerr << endl;\n#define SHOW2D(a, h, w) REP(i, h){REP(j, w)cerr<<setw(3)<<(a[i][j])<<' ';cerr<<endl;}\nconstexpr int INF = 1100000000;\nconstexpr long long LLINF = 1100000000000000000LL;\nconstexpr long long MOD = 1000000007;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef string::const_iterator State;\n\nvector<pair<ll, char>> func(vector<pair<ll, char>>& v, vector<char> op)\n{\n  vector<pair<ll, char>> ret;\n  ret.PB(v[0]);\n  for (int i = 1; i < v.size(); i += 2) {\n    char opt = v[i].SE;\n    ll num = v[i + 1].FI;\n    if (find(ALL(op), opt) != op.end()) {\n      if (opt == '+') ret.back().FI += num;\n      else if (opt == '-') ret.back().FI -= num;\n      else ret.back().FI *= num;\n    } else {\n      ret.PB(v[i]);\n      ret.PB(v[i + 1]);\n    }\n  }\n  return ret;\n}\n\nll number(State& s)\n{\n  ll ret = 0;\n  while (isdigit(*s)) {\n    ret *= 10;\n    ret += *s - '0';\n    s++;\n  }\n  return ret;\n}\n\nll expr1(State& s, vector<char>& op_list)\n{\n  s++;\n  vector<pair<ll, char>> v;\n  while (1) {\n    //cout << \"expr1: \" << *s << endl;\n    if (isdigit(*s)) {\n      v.PB(MP(number(s), ' '));\n    } else if (*s == '(') {\n      v.PB(MP(expr1(s,op_list), ' '));\n    } else if (*s == ')') {\n      break;\n    } else {\n      v.PB(MP(-LLINF, *s));\n      s++;\n    }\n  }\n  s++;\n\n  v = func(v, vector<char>{op_list[0]});\n  v = func(v, vector<char>{op_list[1]});\n  v = func(v, vector<char>{op_list[2]});\n\n  return v[0].FI;\n}\nll expr2(State& s, vector<char>& op_list)\n{\n  s++;\n  vector<pair<ll, char>> v;\n  while (1) {\n    //cout << \"expr2: \" << *s << endl;\n    if (isdigit(*s)) {\n      v.PB(MP(number(s), ' '));\n    } else if (*s == '(') {\n      v.PB(MP(expr2(s,op_list), ' '));\n    } else if (*s == ')') {\n      break;\n    } else {\n      v.PB(MP(-LLINF, *s));\n      s++;\n    }\n  }\n  s++;\n\n  v = func(v, vector<char>{op_list[0], op_list[1]});\n  v = func(v, vector<char>{op_list[2]});\n\n  return v[0].FI;\n}\nll expr3(State& s, vector<char>& op_list)\n{\n  s++;\n  vector<pair<ll, char>> v;\n  while (1) {\n    //cout << \"expr3: \" << *s << endl;\n    if (isdigit(*s)) {\n      v.PB(MP(number(s), ' '));\n    } else if (*s == '(') {\n      v.PB(MP(expr3(s,op_list), ' '));\n    } else if (*s == ')') {\n      break;\n    } else {\n      v.PB(MP(-LLINF, *s));\n      s++;\n    }\n  }\n  s++;\n\n  v = func(v, vector<char>{op_list[0]});\n  v = func(v, vector<char>{op_list[1], op_list[2]});\n\n  return v[0].FI;\n}\n\nll expr4(State& s, vector<char>& op_list)\n{\n  s++;\n  vector<pair<ll, char>> v;\n  while (1) {\n    //cout << \"expr4: \" << *s << endl;\n    if (isdigit(*s)) {\n      v.PB(MP(number(s), ' '));\n    } else if (*s == '(') {\n      v.PB(MP(expr4(s,op_list), ' '));\n    } else if (*s == ')') {\n      break;\n    } else {\n      v.PB(MP(-LLINF, *s));\n      s++;\n    }\n  }\n  s++;\n\n  v = func(v, op_list);\n\n  return v[0].FI;\n}\n\nint main()\n{\n  string S;\n  cin >> S;\n  S = '(' + S + ')';\n  vector<char> op_list = {'+', '-', '*'};\n  sort(ALL(op_list));\n  ll ans = LLONG_MIN;\n  do {\n    State begin = S.begin();\n    ans = max(ans, expr1(begin, op_list));\n    begin = S.begin();\n    ans = max(ans, expr2(begin, op_list));\n    begin = S.begin();\n    ans = max(ans, expr3(begin, op_list));\n    begin = S.begin();\n    ans = max(ans, expr4(begin, op_list));\n  } while(next_permutation(ALL(op_list)));\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll bnf1();\nll bnf2();\nll bnf3();\nll get_digit();\n\nstring s;\nint p,priority[300],len;\n\nll Cal(ll res,char c,ll x){\n  p++;\n  \n  ll r;\n  \n  if(x==2)r=bnf2();\n  if(x==3)r=bnf3();\n  if(x==4)r=get_digit();\n  \n  if(c=='+') return res+r;\n  if(c=='-') return res-r;\n  return res*r;\n}\n\nll bnf(){\n  \n  ll res;\n  \n  if(p<len&&s[p]=='('){\n    \n    p++;\n    \n    res=bnf1();\n    \n    p++;\n    return res;\n  }\n\n  res=bnf1();\n\n  return res;  \n}\n\nll bnf1(){\n  \n  ll res=bnf2();\n  \n  while(p<len&&priority[s[p]]==1) res=Cal(res,s[p],2);\n  \n  return res;\n}\n\nll bnf2(){\n  \n  ll res=bnf3();\n  \n  while(p<len&&priority[s[p]]==2) res=Cal(res,s[p],3);\n  \n  return res;\n}\n\nll bnf3(){\n  \n  ll res=get_digit();\n  \n  while(p<len&&priority[s[p]]==3) res=Cal(res,s[p],4);\n  \n  return res;\n}\n\nll get_digit(){\n  \n  ll res=0;\n  \n  if(s[p]=='('){\n    \n    res=bnf();\n    \n    return res;\n  }\n  \n  while('0'<=s[p]&&s[p]<='9') res=res*10+s[p++]-'0';\n  \n  return res;\n}\n\n\nint main(){\n  \n  cin>>s;\n\n  s='('+s+')';\n  len=s.size();\n  \n  ll ans=(1e-18);\n  \n  for(int i=1;i<=3;i++)\n    for(int j=1;j<=3;j++)\n      for(int k=1;k<=3;k++){\n\tpriority['+']=i;\n\tpriority['-']=j;\n\tpriority['*']=k;\n\tp=0;\n\tans=max(ans,bnf());\n      }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string temp = \"+-*\";\nconst int64 INF = 1LL << 62;\n\nstring S;\nint level[256];\n\nbool inc(int depth, char c)\n{\n  return(temp.find(c) != string::npos && level[c] == depth);\n}\n\nint64 F(int& idx, int depth)\n{\n  int64 val;\n  if(depth == 3) {\n    if(isdigit(S[idx])) {\n      val = 0;\n      while(idx < S.size() && isdigit(S[idx])) {\n        val = val * 10 + S[idx++] - '0';\n      }\n    } else {\n      ++idx;\n      val = F(idx, 0);\n      ++idx;\n    }\n  } else {\n    val = F(idx, depth + 1);\n    while(idx < S.size() && inc(depth, S[idx])) {\n      char op = S[idx++];\n      int64 y = F(idx, depth + 1);\n      if(op == '+') val += y;\n      else if(op == '-') val -= y;\n      else val *= y;\n    }\n  }\n  return(val);\n}\n\n\nint main()\n{ \n  cin >> S;\n  int64 ret = -INF;\n  \n  for(int& i = level['+'] = 0; i < 3; i++) {\n    for(int& j = level['-'] = 0; j < 3; j++) {\n      for(int& k = level['*'] = 0; k < 3; k++) {\n        int idx = 0;\n        ret = max(ret, F(idx, 0));\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <deque>\n#include <stack>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct T{\n\tbool t;\n\tll v;\n};\n\nint pt[13][3] = {\n\t{0, 0, 0},\n\t{1, 0, 0},\n\t{0, 1, 0},\n\t{0, 0, 1},\n\t{0, 1, 1},\n\t{1, 0, 1},\n\t{1, 1, 0},\n\t{0, 1, 2},\n\t{0, 2, 1},\n\t{1, 0, 2},\n\t{1, 2, 0},\n\t{2, 0, 1},\n\t{2, 1, 0}\n};\n\nstring str;\n\nint main(){\n\tcin >> str;\n\n\tll result;\n\trep(a, 13){\n\t\tint* p = pt[a];\n\n\t\tdeque<T> q;\n\t\tstack<int> s;\n\t\tstring n = \"\";\n\t\tfor(auto& c: str){\n\t\t\tif('0' <= c && c <= '9'){\n\t\t\t\tn += c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!n.empty()){\n\t\t\t\tq.push_back(T{false, stoll(n)});\n\t\t\t\tn = \"\";\n\t\t\t}\n\t\t\tif(c == '('){\n\t\t\t\ts.push(3);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c == ')'){\n\t\t\t\twhile(s.top() != 3){\n\t\t\t\t\tq.push_back(T{true, s.top()});\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\ts.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint type;\n\t\t\tif(c == '+'){\n\t\t\t\ttype = 0;\n\t\t\t}\n\t\t\telse if(c == '-'){\n\t\t\t\ttype = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = 2;\n\t\t\t}\n\t\t\twhile(!s.empty() && p[s.top()] >= p[type] && s.top() != 3){\n\t\t\t\tq.push_back(T{true, s.top()});\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(type);\n\t\t}\n\t\tif(!n.empty()){\n\t\t\tq.push_back(T{false, stoll(n)});\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tq.push_back(T{true, s.top()});\n\t\t\ts.pop();\n\t\t}\n\n\t\t/*\n\t\tif(a == 6){\n\t\t\trep(i, q.size()){\n\t\t\t\tauto v = q[i];\n\t\t\t\tif(v.t){\n\t\t\t\t\tif(v.v == 0){\n\t\t\t\t\t\tprintf(\"+\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.v == 1){\n\t\t\t\t\t\tprintf(\"-\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"*\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"%lld\\n\", v.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\tstack<ll> calc;\n\t\twhile(!q.empty()){\n\t\t\tauto v = q.front();\n\t\t\tq.pop_front();\n\t\t\tif(v.t){\n\t\t\t\tll b = calc.top();\n\t\t\t\tcalc.pop();\n\t\t\t\tll a = calc.top();\n\t\t\t\tcalc.pop();\n\t\t\t\tif(v.v == 0){\n\t\t\t\t\tcalc.push(a + b);\n\t\t\t\t}\n\t\t\t\telse if(v.v == 1){\n\t\t\t\t\tcalc.push(a - b);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcalc.push(a * b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcalc.push(v.v);\n\t\t\t}\n\t\t}\n\n\t\tif(a == 0){\n\t\t\tresult = calc.top();\n\t\t}\n\t\telse{\n\t\t\tresult = max(calc.top(), result);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", result);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\ntypedef long long ll;\n\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint ope[] = {'*', '-', '+'};\nint priority[] = {0, 0, 0};\n\ntypedef string::const_iterator State;\n\nll factor(State &begin);\nll expression(State &begin);\n\n\nll calc(ll a, ll b, char c) {\n  if (c == '+') return a + b;\n  if (c == '-') return a - b;\n  return a * b;\n}\n\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nll term1(State &begin) {\n  ll ret = factor(begin);\n  for (;;) {\n    bool ok = false;\n    rep(i, 0, 3) {\n      if (priority[i] != 0) continue;\n      if (*begin == ope[i]) {\n        ok = true;\n        begin++;\n        ret = calc(ret, factor(begin), ope[i]);\n      }\n    }\n    if (!ok) break;\n  }\n  return ret;\n}\n\nll term2(State &begin) {\n  ll ret = term1(begin);\n  for (;;) {\n    bool ok = false;\n    rep(i, 0, 3) {\n      if (priority[i] != 1) continue;\n      if (*begin == ope[i]) {\n        ok = true;\n        begin++;\n        ret = calc(ret, term1(begin), ope[i]);\n      }\n    }\n    if (!ok) break;\n  }\n  return ret;\n}\n\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++;\n    ll ret = expression(begin);\n    begin++;\n    return ret;\n  } else {\n    return number(begin);\n  }\n}\n\nll expression(State &begin) {\n  ll ret = term2(begin);\n  for (;;) {\n    bool ok = false;\n    rep(i, 0, 3) {\n      if (priority[i] != 2) continue;\n      if (*begin == ope[i]) {\n        ok = true;\n        begin++;\n        ret = calc(ret, term2(begin), ope[i]);\n      }\n    }\n    if (!ok) break;\n  }\n  return ret;\n}\n\nint main()\n{\n  string s; cin >> s;\n  sort(ope, ope + 3);\n  ll ans = LLONG_MIN;\n  do {\n    // 0, 1, 2\n    priority[0] = 0;\n    rep(i, 0, 2) rep(j, 0, 2) {\n      if (i == 0) priority[1] = priority[0];\n      else priority[1] = priority[0] + 1;\n      if (j == 0) priority[2] = priority[1];\n      else priority[2] = priority[1] + 1;\n      State begin = s.begin();\n      chmax(ans, expression(begin));\n    }\n  } while (next_permutation(ope, ope + 3));\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoi(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -1e18;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2613.cc: Unordered Operators\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int ON = 3;\n\ntypedef long long ll;\nconst ll LMINF = 1LL << 63;\n\n/* typedef */\n\n/* global variables */\n\nint prs[ON];\n\n/* subroutines */\n\nint op_pr(char c) {\n  switch (c) {\n  case '*': return prs[0];\n  case '+': return prs[1];\n  case '-': return prs[2];\n  }\n  return -1;\n}\n\nll num(string &s, int &pos) {\n  ll n = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '9')\n    n = n * 10 + s[pos++] - '0';\n  return n;\n}\n\nll expr(string &s, int &pos, int p = 0) {\n  if (p >= ON) {\n    if (s[pos] == '(') {\n      pos++; // '('\n      ll e = expr(s, pos, 0);\n      pos++; // ')'\n      return e;\n    }\n\n    return num(s, pos);\n  }\n\n  ll e0 = expr(s, pos, p + 1);\n  while (pos < s.size() && op_pr(s[pos]) == p) {\n    char op = s[pos++]; // '*', '+', '-'\n    ll e1 = expr(s, pos, p + 1);\n\n    switch (op) {\n    case '*': e0 *= e1; break;\n    case '+': e0 += e1; break;\n    case '-': e0 -= e1; break;\n    }\n  }\n\n  return e0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n\n  ll maxe = LMINF;\n\n  for (;;) {\n    int pos = 0;\n    ll e = expr(s, pos);\n    if (maxe < e) maxe = e;\n\n    int k = 0;\n    while (k < ON) {\n      if (++prs[k] < ON) break;\n      prs[k++] = 0;\n    }\n    if (k >= ON) break;\n  }\n\n  printf(\"%lld\\n\", maxe);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nint getend(string &str, int start){\n    int depth = 1;\n    int i;\n    for(i = start+1; depth > 0; i++){\n        if(str[i] == '(')depth++;\n        if(str[i] == ')')depth--;\n    }\n    return i;\n}\n\nll operate(string op, ll x, ll y){\n    char t = op[0];\n    switch(t){\n        case '*': return x*y;\n        case '+': return x+y;\n        case '^': return x-y;\n    }\n}\n\nll calc(string str, map<string, int> &op){\n    //cerr << \"inp: \" << str << endl;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] == '('){\n            int end = getend(str,i);\n            ll result = calc(str.substr(i+1,end-i-2), op);\n            string putin = to_string(result);\n            str.replace(i, end-i,putin);\n        }\n    }\n    list<string> arr;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            int end = i;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end-1;\n        }\n        else if(str[i] == '-'){\n            int end = i+1;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end - 1;\n        }\n        else{\n            arr.push_back(string{str[i]});\n        }\n    }\n    for(int i = 0; i < 3; i++){\n        for(auto itr = arr.begin(); itr != arr.end(); ++itr){\n            if(op.find(*itr) != op.end() && op[*itr] == i){\n                //cerr << \"inp: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n                auto left = itr, right = itr;--left; ++right;\n                string ins = to_string(operate(*itr, stoll(*left), stoll(*right)));\n                --itr;\n                for(int i = 0; i < 3; i++)itr = arr.erase(itr);\n                arr.insert(itr,ins);\n                itr = arr.begin();\n                //cerr << \"itr: \" << *itr << endl;\n                //cerr << \"res: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n            }\n        }\n    }\n    //cerr  << *arr.begin() << endl;\n    return stoll(*arr.begin());\n}\n\nsigned main(){\n    string str;\n    cin >> str;\n    for(auto &e: str)if(e == '-')e = '^';\n    map<string, int> op;\n    ll ans = LLONG_MIN;\n    for(int i = 0; i < 3; i++)for(int j = 0; j < 3; j++)for(int k = 0; k < 3; k++){\n        op[\"*\"] = i;op[\"+\"]=j;op[\"^\"]=k;\n        //for(auto e : op)cerr << e << \" \";\n        //cerr << endl;\n        ans = max(ans, calc(str, op));\n        //cerr << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF LONG_MIN\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nbool op_pri[3][256];\nint p;\n\nll calc(ll n1, char op, ll n2) {\n  switch(op) {\n    case '*': return n1 * n2;\n    case '+': return n1 + n2;\n    case '-': return n1 - n2;\n  }\n  return 0;\n}\n\nll number() {\n  ll ret = 0;\n  while(p < S.size() && '0' <= S[p] && S[p] <= '9') ret = ret * 10 + (S[p++] - '0');\n  return ret;\n}\n\nll expr(int level) {\n  ll ret;\n  char op;\n  if(level < 3) {\n    ret = expr(level + 1);\n    while(p < S.size() && op_pri[level][S[p]]) {\n      op = S[p++];\n      ret = calc(ret, op, expr(level + 1));\n    }\n  } else {\n    if(S[p] == '(') {\n      p++;\n      ret = expr(0);\n      p++;\n    } else {\n      ret = number();\n    }\n  }\n  return ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  string pri = \"*+-||\";\n  ll ans = -INF;\n  ll ret;\n  do {\n    REP(i, 0, 3) REP(j, 0, 256) op_pri[i][j] = false;\n    int k = 0;\n    bool f = true;\n    int cnt = 0;\n    REP(i, 0, pri.size()) {\n      if(pri[i] != '|') {\n        op_pri[2 - k][pri[i]] = true;\n        cnt++;\n      } else {\n        k++;\n      }\n    }\n\n    p = 0;\n    ret = expr(0);\n    ans = max(ans, ret);\n  } while(next_permutation(pri.begin(), pri.end()));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct bnf2{\n  string s;\n  ll x,n;\n  bnf2(){x=0;}\n  bnf2(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf1{\n  string s;\n  ll x,n;\n  bnf1(){x=0;}\n  bnf1(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\nstruct bnf3{\n  string s;\n  ll x,n;\n  bnf3(){x=0;}\n  bnf3(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf4{\n  string s;\n  ll x,n;\n  bnf4(){x=0;}\n  bnf4(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf5{\n  string s;\n  ll x,n;\n  bnf5(){x=0;}\n  bnf5(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf6{\n  string s;\n  ll x,n;\n  bnf6(){x=0;}\n  bnf6(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf7{\n  string s;\n  ll x,n;\n  bnf7(){x=0;}\n  bnf7(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf8{\n  string s;\n  ll x,n;\n  bnf8(){x=0;}\n  bnf8(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf9{\n  string s;\n  ll x,n;\n  bnf9(){x=0;}\n  bnf9(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf10{\n  string s;\n  ll x,n;\n  bnf10(){x=0;}\n  bnf10(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\n\nstruct bnf11{\n  string s;\n  ll x,n;\n  bnf11(){x=0;}\n  bnf11(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf12{\n  string s;\n  ll x,n;\n  bnf12(){x=0;}\n  bnf12(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf13{\n  string s;\n  ll x,n;\n  bnf13(){x=0;}\n  bnf13(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string s;\n  cin>>s;\n  bnf1 b1(s);\n  bnf2 b2(s);\n  bnf3 b3(s);\n  bnf4 b4(s);\n  bnf5 b5(s);\n  bnf6 b6(s);\n  bnf7 b7(s);\n  bnf8 b8(s);\n  bnf9 b9(s);\n  bnf10 b10(s);\n  bnf11 b11(s);\n  bnf12 b12(s);\n  bnf13 b13(s);\n  ll ans=b1.expr();\n  ans=max(ans,b2.expr());\n  ans=max(ans,b3.expr());\n  ans=max(ans,b4.expr());\n  ans=max(ans,b5.expr());\n  ans=max(ans,b6.expr());\n  ans=max(ans,b7.expr());\n  ans=max(ans,b8.expr());\n  ans=max(ans,b9.expr());\n  ans=max(ans,b10.expr());\n  ans=max(ans,b11.expr());\n  ans=max(ans,b12.expr());\n  ans=max(ans,b13.expr());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nstring s;\nvector<ll> v;\nchar op[] = {'+','-','*'};\nll Rank[3];\n\nll number(int &i);\nll facter(int &i);\nll expr3(int &i);\nll expr2(int &i);\nll expr1(int &i);\n\nll number(int &i){\n    ll res = 0;\n    while(s[i] >= '0' && s[i] <= '9'){\n        res *= 10;\n        res += (s[i] - '0');\n        i++;\n    }\n    return res;\n}\n\nll facter(int &i){\n    ll res = 0;\n    if(s[i] == '('){\n        i++;\n        res = expr1(i);\n        i++;\n    }\n    else if(s[i] >= '0' && s[i] <= '9'){\n        res = number(i);\n    }\n    return res;\n}\n\nll expr3(int &i){\n    ll res = facter(i);\n    while(1){\n        if(s[i] == '+' && Rank[0] == 2){\n            i++;\n            res += facter(i);\n        }\n        else if(s[i] == '-' && Rank[1] == 2){\n            i++;\n            res -= facter(i);\n        }\n        else if(s[i] == '*' && Rank[2] == 2){\n            i++;\n            res *= facter(i);\n        }\n        else break;\n    }\n    return res;\n}\n\nll expr2(int &i){\n    ll res = expr3(i);\n    while(1){\n        if(s[i] == '+' && Rank[0] == 1){\n            i++;\n            res += expr3(i);\n        }\n        else if(s[i] == '-' && Rank[1] == 1){\n            i++;\n            res -= expr3(i);\n        }\n        else if(s[i] == '*' && Rank[2] == 1){\n            i++;\n            res *= expr3(i);\n        }\n        else break;\n    }\n    return res;\n}\n\nll expr1(int &i){\n    ll res = expr2(i);\n    while(1){\n        if(s[i] == '+' && Rank[0] == 0){\n            i++;\n            res += expr2(i);\n        }\n        else if(s[i] == '-' && Rank[1] == 0){\n            i++;\n            res -= expr2(i);\n        }\n        else if(s[i] == '*' && Rank[2] == 0){\n            i++;\n            res *= expr2(i);\n        }\n        else break;\n    }\n    return res;\n}\n\nint main(){\n    cin >> s;\n    rep(i,3)v.push_back(i);\n    sort(ALL(v));\n    ll ans = LLONG_MIN;\n    rep(i,3){\n        rep(j,3){\n            rep(k,3){\n                Rank[0] = i;\n                Rank[1] = j;\n                Rank[2] = k;\n                int i = 0;\n                ll num = expr1(i);\n                ans = max(ans,num);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nchar buf[222];\nint n;\nint cnt;\nvector<char> op;\nbool counter(char c){\n  if( cnt >= n ) return false;\n  if( buf[cnt] == c ) { cnt++; return true; }\n  return false;\n}\n\nll number(){\n  ll num = 0;\n  while( '0' <= buf[cnt] && buf[cnt] <= '9' ){\n    num *=10;\n    num += buf[cnt++]-'0';\n  }\n  return num;\n}\n\nll calc( ll a, ll b, char o ){\n  if( o == '+' ) return a + b;\n  if( o == '-' ) return a - b;\n  return a * b;\n}\n\nll op1();\nll op4();\nll op6();\nll op7();\n\nll kakko(){\n  if( counter('(') ){\n    ll a = op1();\n    counter(')');\n    return a;\n  }\n  return number();\n}\nll kakko4(){\n  if( counter('(') ){\n    ll a = op4();\n    counter(')');\n    return a;\n  }\n  return number();\n}\nll kakko6(){\n  if( counter('(') ){\n    ll a = op6();\n    counter(')');\n    return a;\n  }\n  return number();\n}\nll kakko7(){\n  if( counter('(') ){\n    ll a = op7();\n    counter(')');\n    return a;\n  }\n  return number();\n}\n\n\nll op3(){\n  ll a = kakko();\n  while( counter( op[2] ) ) {\n    ll b = kakko();\n    a = calc( a, b, op[2] );\n  }\n  return a;\n}\n\nll op2(){\n  ll a = op3();\n  while( counter( op[1] ) ) {\n    ll b = op3();\n    a = calc( a, b, op[1] );\n  }\n  return a;\n}\n\nll op1(){\n  ll a = op2();\n  while( counter( op[0] ) ) {\n    ll b = op2();\n    a = calc( a, b, op[0] );   \n  }\n  return a;\n}\n\nll op5(){\n  ll a = kakko4();\n  while( true ){\n    if( counter( op[2] ) ) {\n      ll b = kakko4();\n      a = calc( a, b, op[2] );\n    } else if( counter( op[1] ) ){\n      ll b = kakko4();\n      a = calc( a, b, op[1] );\n    } else\n      break;\n  }\n  return a;\n}\n\nll op4(){\n  ll a = op5();\n  while( counter( op[0] ) ) {\n    ll b = op5();\n    a = calc( a, b, op[0] );\n  }\n  return a;\n}\n\nll op8(){\n  ll a = kakko6();\n  while( counter( op[2] ) ) {\n    ll b = kakko6();\n    a = calc( a, b, op[2] );\n  }\n  return a;  \n}\n\nll op6(){\n  ll a = op8();\n  while( true ){\n    if( counter( op[1] ) ) {\n      ll b = op8();\n      a = calc( a, b, op[1] );\n    } else if( counter( op[0] ) ){\n      ll b = op8();\n      a = calc( a, b, op[0] );\n    } else\n      break;\n  }\n  return a;\n}\n\nll op7(){\n  ll a = kakko7();\n  while( true ){\n    if( counter( op[0] ) ){\n      ll b = kakko7();\n      a = calc( a, b, op[0] );\n    } else if( counter( op[1] ) ) {\n      ll b = kakko7();\n      a = calc( a, b, op[1] );\n    } else if( counter( op[2] ) ){\n      ll b = kakko7();\n      a = calc( a, b, op[2] );\n    } else \n      break;\n  }\n  return a;\n}\n\n\nint main(){\n  cin >> buf;\n  n = strlen(buf);\n  op.push_back( '+' );\n  op.push_back( '-' );\n  op.push_back( '*' );\n  sort(op.begin(),op.end());\n  ll res = -LLONG_MAX;\n  do {\n    cnt = 0;\n    res = max( res, op1() );\n    cnt = 0;\n    res = max( res, op4() );\n    cnt = 0;\n    res = max( res, op6() );\n    cnt = 0;\n    res = max( res, op7() );\n  } while( next_permutation( op.begin(), op.end() ) );\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    ret = calc(ret, S[idx++], ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    ret = calc(ret, S[idx++], beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    ret = calc(ret, S[idx++], malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State&);\nint expressionB(State&);\nint expressionC(State&);\nint expressionD(State&);\nint term(State&);\nint term2(State&);\nint number(State&);\nint factor(State&);\n\nchar op[3] = {'+', '-', '*'};\nint expression(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += term(begin);\n\t\t\telse if(op[0] == '-') ret -= term(begin);\n\t\t\telse if(op[0] == '*') ret *= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorB(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionB(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termB(State &begin) {\n\tint ret = factorB(begin);\n\twhile(1) {\n\t\t//cout << \"term:\" << *begin << endl;\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorB(begin);\n\t\t\telse if(op[1] == '-') ret -= factorB(begin);\n\t\t\telse if(op[1] == '*') ret *= factorB(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorB(begin);\n\t\t\telse if(op[2] == '-') ret -= factorB(begin);\n\t\t\telse if(op[2] == '*') ret *= factorB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"tret:\" << ret << endl;\n\treturn ret;\n}\n\nint expressionB(State &begin) {\n\tint ret = termB(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += termB(begin);\n\t\t\telse if(op[0] == '-') ret -= termB(begin);\n\t\t\telse if(op[0] == '*') ret *= termB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"ret:\" << ret << endl;\n\treturn ret;\n}\n\nint factorD(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionD(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termD(State &begin) {\n\tint ret = factorD(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorD(begin);\n\t\t\telse if(op[0] == '-') ret -= factorD(begin);\n\t\t\telse if(op[0] == '*') ret *= factorD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionD(State &begin) {\n\tint ret = termD(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += termD(begin);\n\t\t\telse if(op[1] == '-') ret -= termD(begin);\n\t\t\telse if(op[1] == '*') ret *= termD(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += termD(begin);\n\t\t\telse if(op[2] == '-') ret -= termD(begin);\n\t\t\telse if(op[2] == '*') ret *= termD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorC(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionC(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint expressionC(State &begin) {\n\tint ret = factorC(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorC(begin);\n\t\t\telse if(op[0] == '-') ret -= factorC(begin);\n\t\t\telse if(op[0] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorC(begin);\n\t\t\telse if(op[1] == '-') ret -= factorC(begin);\n\t\t\telse if(op[1] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorC(begin);\n\t\t\telse if(op[2] == '-') ret -= factorC(begin);\n\t\t\telse if(op[2] == '*') ret *= factorC(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = term2(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += term2(begin);\n\t\t\telse if(op[1] == '-') ret -= term2(begin);\n\t\t\telse if(op[1] == '*') ret *= term2(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term2(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tstring s;\n\tgetline(cin, s);\n\n\tState begin = s.begin();\n\tint ret = expressionC(begin);\n\t//REP(i, 3) cout << op[i] << \" \";\n\t//cout << ret << endl;\n\n\tsort(op, op+3);\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionB(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionD(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nvector<char> op[3];\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  ll fact(){\n    if(parse[pos] == '('){\n      pos++;\n      ll p = expression();\n      pos++;\n      return p;\n    }else{\n      ll p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10LL;\n        p += parse[pos]-'0';\n        pos++;\n      }\n      return p;\n    }\n  }\n\n  ll term2(){\n    ll p = fact();\n    bool update = false;\n    rep(i,op[2].size()) if( parse[pos] == op[2][i] ) update = true;\n    while( update ){\n      if(parse[pos] == '*'){pos++;p *= fact();}\n      else if( parse[pos] == '-' ) {pos++;p -= fact();}\n      else { pos++; p += fact(); }\n      update = false;\n      if( pos < parse.size() ) rep(i,op[2].size()) if( parse[pos] == op[2][i] ) update = true;\n    }\n    return p;\n  }\n \n  ll term(){\n    ll p = term2();\n    bool update = false;\n    rep(i,op[1].size()) if( parse[pos] == op[1][i] ) update = true;\n    while( update ){\n      if(parse[pos] == '*'){pos++;p *= term2();}\n      else if( parse[pos] == '-' ) {pos++;p -= term2();}\n      else { pos++; p += term2(); }\n      update = false;\n      if( pos < parse.size() ) rep(i,op[1].size()) if( parse[pos] == op[1][i] ) update = true;\n    }\n    return p;\n  }\n \n  ll expression(){\n    ll p = term();\n    bool update = false;\n    rep(i,op[0].size()) if( parse[pos] == op[0][i] ) update = true;\n    while( update ){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else if( parse[pos] == '-' ){pos++;p-=term();}\n      else { pos++; p*=term();}\n      update = false;\n      if( pos < parse.size() ) rep(i,op[0].size()) if( parse[pos] == op[0][i] ) update = true;\n    }\n    return p;\n  } \n \n};\n\nint main(){\n  string s;\n  cin >> s;\n  ll maxi = 0;\n  rep(i,3) rep(j,3) rep(k,3) {\n    Parsing par(s);\n    rep(l,3) op[l].clear();\n    op[i].push_back('+');\n    op[j].push_back('-');\n    op[k].push_back('*');\n    maxi = max(maxi,par.expression());\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing iter = string::const_iterator;\n\nint pri[256];\nfunction<ll(ll, ll)> op[256];\n\nll expr(iter &it, int p)\n{\n\tll res = 0;\n\tif (p == 3){\n\t\tif (*it == '('){\n\t\t\t++it;\n\t\t\tres = expr(it, 0);\n\t\t\t++it;\n\t\t\treturn res;\n\t\t}\n\t\twhile (isdigit(*it)){\n\t\t\tres = res * 10 + (*it - '0');\n\t\t\t++it;\n\t\t}\n\t\treturn res;\n\t}\n\n\tres = expr(it, p + 1);\n\twhile (true){\n\t\tif (pri[*it] == p){\n\t\t\tchar c = *it;\n\t\t\t++it;\n\t\t\tres = (op[c])(res, expr(it, p + 1));\n\t\t}\n\t\telse break;\n\t}\n\n\treturn res;\n}\n\nll eval(const string &s)\n{\n\titer it = begin(s);\n\treturn expr(it, 0);\n}\n\nint main()\n{\n\top['+'] = [](ll x, ll y){ return x + y; };\n\top['-'] = [](ll x, ll y){ return x - y; };\n\top['*'] = [](ll x, ll y){ return x * y; };\n\tmemset(pri, -1, sizeof(pri));\n\n\tstring s;\n\tcin >> s;\n\n\tll res = LLONG_MIN;\n\trep(i, 3) rep(j, 3) rep(k, 3){\n\t\tpri['+'] = i;\n\t\tpri['-'] = j;\n\t\tpri['*'] = k;\n\t\tchmax(res, eval(s));\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops;\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    const Long INF = 1LL<<60;\n\n    void solve() {\n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = -INF;\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                for (int c = 0; c < 3; c++) {\n                    for (int i = 0; i < 4; i++) {\n                        ops.clear(); ops.resize(3);\n                        ops[a].push_back(t[0]);\n                        ops[b].push_back(t[1]);\n                        ops[c].push_back(t[2]);\n                        int index = 0;\n                        ans = max(ans, parse(s, index, 0));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\nvector<int>ord(256, -1);\n\nlong long int Calc(const string& s, int l=0, int r=N) {\n//\tcout << l << \" \" << r << endl;\n\tbool flag = true;\n\tfor (int i = l; i < r; i++) {\n\t\tif (s[i] > '9' || s[i] < '0')flag = false;\n\t}\n\tif (flag) {\n\t\tlong long int num = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tnum *= 10;\n\t\t\tnum += s[i] - '0';\n\t\t}\n\t\treturn num;\n\t}\n\tint m = MOD;\n\tint st = 0;\n\tfor (int i = l; i < r - 1; i++) {\n\t\tif (s[i] == '(')st++;\n\t\tif (s[i] == ')')st--;\n\t\tm = min(m, st);\n\t}\n\tif (m == 1 && s[r - 1] == ')') {\n\t\treturn Calc(s, l + 1, r - 1);\n\t}\n\tst = 0;\n\tfor (int i = r-1; i >=l; i--) {\n\t\tif (s[i] == '(')st++;\n\t\tif (s[i] == ')')st--;\n\t\tif (st == 0 && ord[s[i]] == 0) {\n\t\t\tif (s[i] == '+')return Calc(s, l, i) + Calc(s, i + 1, r);\n\t\t\tif (s[i] == '-')return Calc(s, l, i) - Calc(s, i + 1, r);\n\t\t\tif (s[i] == '*')return Calc(s, l, i) * Calc(s, i + 1, r);\n\t\t}\n\t}\n\tfor (int i = r - 1; i >= l; i--) {\n\t\tif (s[i] == '(')st++;\n\t\tif (s[i] == ')')st--;\n\t\tif (st == 0 && ord[s[i]] == 1) {\n\t\t\tif (s[i] == '+')return Calc(s, l, i) + Calc(s, i + 1, r);\n\t\t\tif (s[i] == '-')return Calc(s, l, i) - Calc(s, i + 1, r);\n\t\t\tif (s[i] == '*')return Calc(s, l, i) * Calc(s, i + 1, r);\n\t\t}\n\t}\n\tfor (int i = r - 1; i >= l; i--) {\n\t\tif (s[i] == '(')st++;\n\t\tif (s[i] == ')')st--;\n\t\tif (st == 0 && ord[s[i]] == 2) {\n\t\t\tif (s[i] == '+')return Calc(s, l, i) + Calc(s, i + 1, r);\n\t\t\tif (s[i] == '-')return Calc(s, l, i) - Calc(s, i + 1, r);\n\t\t\tif (s[i] == '*')return Calc(s, l, i) * Calc(s, i + 1, r);\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\tN = s.size();\n\tstring op = \"+-*\";\n\tfor (auto i : op)ord[i] = 0;\n\tlong long int ans = LLONG_MIN;\n\twhile (ord['*'] < 3) {\n\t\t//for (auto i : op) {\n\t\t//\tcout << i << \" \" << ord[i] << endl;\n\t\t//}\n\t\t//cout << Calc(s) << endl;\n\t\tans = max(ans, Calc(s));\n\t\tord['+']++;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (ord[op[i]] == 3) {\n\t\t\t\tord[op[i + 1]]++;\n\t\t\t\tord[op[i]] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nll number();\nll factor();\nll expr(int i=1);\nState cur;\nll number(){\n    ll ret = 0;\n    while(isdigit(*cur)){\n        ret = ret*10+*cur++-'0';\n    }\n    return ret;\n}\nll factor(){\n    if(*cur=='('){\n        cur++;\n        ll res = expr();\n        cur++;\n        return res;\n    }\n    else{\n        return number();\n    }\n}\nmap<char,int> mp;\nvoid f(ll &a,ll b,char c){\n    if(c=='*')a*=b;\n    if(c=='-')a-=b;\n    if(c=='+')a+=b;\n}\nll expr(int i){\n    if(i==4)return factor();\n    ll res = expr(i+1);\n    for(;;){\n        if(mp[*cur]==i){\n            char c = *cur++;\n            f(res,expr(i+1),c);\n        }\n        else break;\n    }\n    return res;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    string s;\n    getline(cin,s);\n    ll ma = -LONG_LONG_MAX;\n    rep(i,3)rep(j,3)rep(k,3){\n        mp['+']=i+1;\n        mp['-']=j+1;\n        mp['*']=k+1;\n        cur = s.begin();\n        chmax(ma,expr(1));\n    }\n    cout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range((i), (0), (a))\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\nlong long th( State & begin );\nint add, sub, mul;\n\nint main() {\n    string s;\n    cin >> s;\n\n    long long ans = LLONG_MIN;\n\n    range (i, 1, 4) range (j, 1, 4) range (k, 1, 4) {\n        add = i, sub = j, mul = k;\n        State begin = s.begin();\n        ans = max(ans, th(begin));\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n\nlong long factor( State & );\n\nlong long number( State & begin ) {\n    long long ret = 0;\n    while( isdigit( *begin ) ) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nlong long fi( State & begin ) {\n    long long ret = factor( begin );\n    for (;;) {\n        //最も優先順位が高い演算子\n        if ( add == 1 && *begin == '+' ) {\n            begin++;\n            ret += factor( begin );\n        }\n        else if ( sub == 1 && *begin == '-' ) {\n            begin++;\n            ret -= factor( begin );\n        }\n        else if ( mul == 1 && *begin == '*' ) {\n            begin++;\n            ret *= factor( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n\n}\n\nlong long se( State & begin ) {\n    long long ret = fi( begin );\n    for (;;) {\n        //二番目に優先順位が低い演算子\n        if ( add == 2 && *begin == '+' ) {\n            begin++;\n            ret += fi( begin );\n        }\n        else if ( sub == 2 && *begin == '-' ) {\n            begin++;\n            ret -= fi( begin );\n        }\n        else if ( mul == 2 && *begin == '*' ) {\n            begin++;\n            ret *= fi( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n}\n\nlong long th( State & begin ) {\n    long long ret = se( begin );\n    for (;;) {\n        //ここは最も優先順位が低い演算子\n        if ( add == 3 && *begin == '+' ) {\n            begin++;\n            ret += se( begin );\n        }\n        else if ( sub == 3 && *begin == '-' ) {\n            begin++;\n            ret -= se( begin );\n        }\n        else if ( mul == 3 && *begin == '*' ) {\n            begin++;\n            ret *= se( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n}\n\nlong long factor( State & begin ) {\n    if ( *begin == '(' ) {\n        begin++;\n        long long ret = th( begin );\n        begin++;\n        return ret;\n    }\n    else {\n        return number( begin );\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 62);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\tif (sent.size() != 1)exit(1);\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tll res = -9223372036854775808ll;\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\tfor (auto level : levels) {\n\t\tstack<string> st;\n\t\tfor (string s : vs) {\n\t\t\tif (s == \")\") {\n\t\t\t\tstack<string> sent;\n\t\t\t\twhile (true) {\n\t\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\t\tif (top == \"(\")break;\n\t\t\t\t\tsent.push(top);\n\t\t\t\t}\n\t\t\t\tst.push(calc(level, sent));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s);\n\t\t\t}\n\t\t}\n\t\tstack<string> op;\n\t\twhile (!st.empty()) {\n\t\t\top.push(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tres = max(res, stoll(calc(level, op)));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct bnf2{\n  string s;\n  ll x,n;\n  bnf2(){x=0;}\n  bnf2(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=factor();\n    while(1){\n      //cout<<res<<\":\"<<s[x]<<endl;\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf1{\n  string s;\n  ll x,n;\n  bnf1(){x=0;}\n  bnf1(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\nstruct bnf3{\n  string s;\n  ll x,n;\n  bnf3(){x=0;}\n  bnf3(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf4{\n  string s;\n  ll x,n;\n  bnf4(){x=0;}\n  bnf4(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf5{\n  string s;\n  ll x,n;\n  bnf5(){x=0;}\n  bnf5(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf6{\n  string s;\n  ll x,n;\n  bnf6(){x=0;}\n  bnf6(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf7{\n  string s;\n  ll x,n;\n  bnf7(){x=0;}\n  bnf7(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf8{\n  string s;\n  ll x,n;\n  bnf8(){x=0;}\n  bnf8(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf9{\n  string s;\n  ll x,n;\n  bnf9(){x=0;}\n  bnf9(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf10{\n  string s;\n  ll x,n;\n  bnf10(){x=0;}\n  bnf10(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\n\nstruct bnf11{\n  string s;\n  ll x,n;\n  bnf11(){x=0;}\n  bnf11(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf12{\n  string s;\n  ll x,n;\n  bnf12(){x=0;}\n  bnf12(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf13{\n  string s;\n  ll x,n;\n  bnf13(){x=0;}\n  bnf13(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string s;\n  cin>>s;\n  bnf1 b1(s);\n  bnf2 b2(s);\n  bnf3 b3(s);\n  bnf4 b4(s);\n  bnf5 b5(s);\n  bnf6 b6(s);\n  bnf7 b7(s);\n  bnf8 b8(s);\n  bnf9 b9(s);\n  bnf10 b10(s);\n  bnf11 b11(s);\n  bnf12 b12(s);\n  bnf13 b13(s);\n  ll ans=b1.expr();\n  ans=max(ans,b2.expr());\n  ans=max(ans,b3.expr());\n  ans=max(ans,b4.expr());\n  ans=max(ans,b5.expr());\n  ans=max(ans,b6.expr());\n  ans=max(ans,b7.expr());\n  ans=max(ans,b8.expr());\n  ans=max(ans,b9.expr());\n  ans=max(ans,b10.expr());\n  ans=max(ans,b11.expr());\n  ans=max(ans,b12.expr());\n  ans=max(ans,b13.expr());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 9223372036854775807 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\n\trep(i,3)rep(j,op.size())rep(k,3)if(a[k]==i&&op[j]==w[k]){\n\t\tchar c=w[k];\n\t\tif(c=='+')in[j]+=in[j+1];\n\t\tif(c=='-')in[j]-=in[j+1];\n\t\tif(c=='*')in[j]*=in[j+1];\n\t\tin.erase(in.begin()+j+1);\n\t\top.erase(op.begin()+j);\n\t\tj--;break;\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-inf-1;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tt=0;\n\t\ta=vi{i,j,k};\n\t\tout=max(out,expr());\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nchar cs[] = \"+-*\";\nint pri[] = { 0, 0, 0 };\n\nint it, n;\nstring s;\n\nll number();\nll fact();\nll expr(int);\n\nll number() {\n\tassert(isdigit(s[it]));\n\tll res = 0;\n\twhile (isdigit(s[it])) {\n\t\tres = res * 10 + (s[it++] - '0');\n\t}\n\treturn res;\n}\n\nll fact() {\n\tif (s[it] == '(') {\n\t\tit++;\n\t\tll res = expr(2);\n\t\tassert(s[it] == ')');\n\t\tit++;\n\t\treturn res;\n\t}\n\treturn number();\n}\n\nll expr(int p) {\n\tll res = p ? expr(p - 1) : fact();\n\twhile (true) {\n\t\tint id = -1;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (it < n && pri[i] == p && s[it] == cs[i]) {\n\t\t\t\tid = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (id == -1) break;\n\t\tit++;\n\t\tll tmp = p ? expr(p - 1) : fact();\n\t\tswitch (cs[id])\n\t\t{\n\t\tcase '+':\n\t\t\tres += tmp;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tres -= tmp;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tres *= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> s;\n\tn = s.size();\n\tll res = LLONG_MIN;\n\tfor (pri[0] = 0; pri[0] < 3; pri[0]++) {\n\t\tfor (pri[1] = 0; pri[1] < 3; pri[1]++) {\n\t\t\tfor (pri[2] = 0; pri[2] < 3; pri[2]++) {\n\t\t\t\tit = 0;\n\t\t\t\tll val = expr(2);\n\t\t\t\tassert(it == n);\n\t\t\t\tres = max(res, val);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll bnf1();\nll bnf2();\nll bnf3();\nll get_digit();\n\nstring s;\nint p,priority[300],len;\n\nll Cal(ll res,char c,ll x){\n  p++;\n  \n  ll r;\n  \n  if(x==2)r=bnf2();\n  if(x==3)r=bnf3();\n  if(x==4)r=get_digit();\n  \n  if(c=='+') return res+r;\n  if(c=='-') return res-r;\n  return res*r;\n}\n\nll bnf(){\n  \n  ll res;\n  \n  if(p<len&&s[p]=='('){\n    \n    p++;\n    \n    res=bnf1();\n    \n    p++;\n    return res;\n  }\n\n  res=bnf1();\n\n  return res;  \n}\n\nll bnf1(){\n  \n  ll res=bnf2();\n  \n  while(p<len&&priority[s[p]]==1) res=Cal(res,s[p],2);\n  \n  return res;\n}\n\nll bnf2(){\n  \n  ll res=bnf3();\n  \n  while(p<len&&priority[s[p]]==2) res=Cal(res,s[p],3);\n  \n  return res;\n}\n\nll bnf3(){\n  \n  ll res=get_digit();\n  \n  while(p<len&&priority[s[p]]==3) res=Cal(res,s[p],4);\n  \n  return res;\n}\n\nll get_digit(){\n  \n  ll res=0;\n  \n  if(s[p]=='('){\n    \n    res=bnf();\n    \n    return res;\n  }\n  \n  while('0'<=s[p]&&s[p]<='9') res=res*10+s[p++]-'0';\n  \n  return res;\n}\n\n\nint main(){\n  \n  cin>>s;\n\n  s='('+s+')';\n  len=s.size();\n  \n  ll ans=(1e-17);\n  \n  for(int i=1;i<=3;i++)\n    for(int j=1;j<=3;j++)\n      for(int k=1;k<=3;k++){\n\tpriority['+']=i;\n\tpriority['-']=j;\n\tpriority['*']=k;\n\tp=0;\n\tans=max(ans,bnf());\n      }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\n\trep(i,3)rep(j,op.size())rep(k,3)if(a[k]==i&&op[j]==w[k]){\n\t\tchar c=w[k];\n\t\tif(c=='+')in[j]+=in[j+1];\n\t\tif(c=='-')in[j]-=in[j+1];\n\t\tif(c=='*')in[j]*=in[j+1];\n\t\tin.erase(in.begin()+j+1);\n\t\top.erase(op.begin()+j);\n\t\tj--;break;\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-9223372036854775808;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tt=0;\n\t\ta=vi{i,j,k};\n\t\tout=max(out,expr());\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nll expr(string s, int &p, int lev);\nll factor(string s, int &p);\nll number(string s, int &p);\n\nstring op[3];\nvector<vector<string>> ops = {\n  {\"+-*\", \"\", \"\"},\n  {\"+\", \"-*\", \"\"}, {\"-\", \"+*\", \"\"}, {\"*\", \"+-\", \"\"},\n  {\"+-\", \"*\", \"\"}, {\"+*\", \"-\", \"\"}, {\"-*\", \"+\", \"\"},\n  {\"+\", \"-\", \"*\"}, {\"+\", \"*\", \"-\"}, {\"-\", \"+\", \"*\"}, {\"-\", \"*\", \"+\"}, {\"*\", \"+\", \"-\"}, {\"*\", \"-\", \"+\"}\n};\n\nll expr(string s, int &p, int lev) {\n  ll val1 = lev + 1 == 3 ? factor(s, p) : expr(s, p, lev + 1);\n  while (op[lev].find(s[p]) != string::npos) {\n    char op = s[p++];\n    ll val2 = lev + 1 == 3 ? factor(s, p) : expr(s, p, lev + 1);\n    switch (op) {\n      case '+': val1 += val2; break;\n      case '-': val1 -= val2; break;\n      case '*': val1 *= val2; break;\n    }\n  }\n  return val1;\n}\n\nll factor(string s, int &p) {\n  if (isdigit(s[p])) return number(s, p);\n  p++;\n  ll res = expr(s, p, 0);\n  p++;\n  return res;\n}\n\nll number(string s, int &p) {\n  ll res = 0;\n  while (isdigit(s[p])) {\n    res = res * 10 + (s[p++] - '0');\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  string s;\n  cin >> s;\n  ll ans = LLONG_MIN;\n  for (int i = 0; i < (int)ops.size(); i++) {\n    for (int j = 0; j < 3; j++) {\n      op[j] = ops[i][j];\n    }\n    int p = 0;\n    ans = max(ans, expr(s, p, 0));\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int add[13] = {1,1,2,1,2,2,1,1,1,2,3,2,3};\nconst int sub[13] = {1,1,2,2,1,1,2,2,3,1,1,3,2};\nconst int mul[13] = {1,2,1,1,2,1,2,3,2,3,2,1,1};\n\nstring s;\n\nll parse(int l, int r, int order){\n  vector<ll> v;\n  vector<char> op;\n  for(int i=l;i<r;i++){\n    if(s[i]=='('){\n      int k = 1, start = i+1;\n      while(k){\n\ti++;\n\tif(s[i]=='(')k++;\n\telse if(s[i]==')')k--;\n      }\n      v.push_back(parse(start,i,order));\n    }else if(isdigit(s[i])){\n      ll tmp = 0;\n      while(isdigit(s[i])){\n\ttmp = tmp*10 + s[i]-'0';\n\ti++;\n      }\n      v.push_back(tmp);\n      i--;\n    }else{\n      op.push_back(s[i]);\n    }\n  }\n  /*\n  for(int i=0;i<v.size();i++)cout << v[i] << \" \"; cout << endl;\n  for(int j=0;j<op.size();j++)cout << op[j] << \" \"; cout << endl;\n  */\n  if(v.size()==0)return 0;\n\n  for(int k=1;k<=3;k++){\n    for(int i=0;i<op.size();i++){\n      if(op[i] == '+' && add[order] == k){\n\tv[i] += v[i+1];\n\tv.erase(v.begin()+i+1);\n\top.erase(op.begin()+i);\n\ti--;\n      }\n      if(op[i] == '-' && sub[order] == k){\n\tv[i] -= v[i+1];\n\tv.erase(v.begin()+i+1);\n\top.erase(op.begin()+i);\n\ti--;\n      }\n      if(op[i] == '*' && mul[order] == k){\n\tv[i] *= v[i+1];\n\tv.erase(v.begin()+i+1);\n\top.erase(op.begin()+i);\n\ti--;\n      }\n    }\n  }\n  return v[0];\n}\n     \nint main(){\n  cin >> s;\n  \n  ll res = parse(0,s.size(),0);\n  for(int i=1;i<=12;i++)res = max(res,parse(0,s.size(),i));\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nstring s, pat = \"+-*\";\n\nll parse(int l, int r, vector<int> prio) {\n    int ptr = l;\n\n    vector<ll> val;\n    vector<char> op;\n    while(ptr < r) {\n        // 演算子\n        if(pat.find(s[ptr]) != string::npos) {\n            op.push_back(s[ptr++]);\n        }\n        // 数字\n        else if(isdigit(s[ptr])) {\n            ll tmp = 0;\n            while(isdigit(s[ptr])) {\n                tmp = (tmp * 10) + (s[ptr++] - '0');\n            }\n            val.push_back(tmp);\n        }\n        // 括弧\n        else if(s[ptr] == '(') {\n            int nl = ptr+1, nr = -1;\n            while(s[ptr] != ')') ptr++;\n            nr = ptr++;\n            val.push_back(parse(nl, nr, prio));\n        }\n    }\n\n    /*\n    for(int i=0; i<op.size(); i++) {\n        printf(\"%lld %c \", val[i], op[i]);\n    }\n    printf(\"%lld\\n\", val[op.size()]);\n    */\n\n    // マージ\n    for(int p=0; p<3; p++) {\n        for(size_t i=0; i<op.size(); i++) {\n            // printf(\"op %c (%d)\\n\", op[i], prio[pat.find(op[i])]);\n            if(prio[pat.find(op[i])] == p) {\n                // printf(\"op %c: %lld, %lld\\n\", op[i], val[i], val[i+1]);\n                if(op[i] == '+') val[i] = val[i] + val[i+1];\n                if(op[i] == '-') val[i] = val[i] - val[i+1];\n                if(op[i] == '*') val[i] = val[i] * val[i+1];\n                val.erase(val.begin() + i + 1);\n                op.erase(op.begin() + i);\n                i--;\n            }\n        }\n    }\n    return val[0];\n}\n\nint main() {\n    cin >> s;\n    int M = s.length();\n    ll ans = parse(0, M, vector<int>{0, 0, 0});\n\n    \n    for(int x=0; x<3; x++) {\n        for(int y=0; y<3; y++) {\n            for(int z=0; z<3; z++) {\n                vector<int> v = {x, y, z};\n                // printf(\"parse: %lld\\n\", parse(0, M, v));\n                ans = max(ans, parse(0, M, v));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint cur;\nchar str[210];\nint perm[3]={0,1,2};\nchar ch[5]=\"+-*\";\nint lv[3];\nlong long expr(int a){\n\tif(a==3){\n\t\tif(str[cur]=='('){\n\t\t\tcur++;\n\t\t\tlong long ret=expr(0);\n\t\t\tcur++;\n\t\t\treturn ret;\n\t\t}else{\n\t\t\tlong long ret=0;\n\t\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\t\tret*=10;\n\t\t\t\tret+=str[cur]-'0';\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlong long ret=expr(a+1);\n\twhile((str[cur]=='+'&&lv[0]==a)||(str[cur]=='-'&&lv[1]==a)||(str[cur]=='*'&&lv[2]==a)){\n\t\tchar tm=str[cur];\n\t\tcur++;\n\t\tlong long tmp=expr(a+1);\n\t\tif(tm=='+')ret+=tmp;\n\t\telse if(tm=='-')ret-=tmp;\n\t\telse ret*=tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tlong long ret=expr(0);\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++){\n\t\tlv[0]=i;lv[1]=j;lv[2]=k;\n\t\tcur=0;\n\t\tret=max(ret,expr(0));\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\n//template<typename T> using vec=std::vector<T>;\n\nconst ll inf=1<<30;\nconst long long unsigned int infll=1LL<<63;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nmap<char,ll> pri;\n\nll expr(state& begin);\n\nll number(state& begin){\n    ll res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nll factor(state& begin) {\n    if (*begin=='('){\n        begin++;\n        ll res=expr(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nll term_(state &begin){\n    ll res=factor(begin);\n    while(true){\n        if(*begin=='+' and pri['+']>pri['-'] and pri['+']>pri['*']){\n            ++begin;\n            res+=factor(begin);\n        }else if(*begin=='-' and pri['-']>pri['+'] and pri['-']>pri['*']){\n            ++begin;\n            res-=factor(begin);\n        }else if(*begin=='*' and pri['*']>pri['+'] and pri['*']>pri['-']){\n            ++begin;\n            res*=factor(begin);\n        }else break;\n    }\n    return res;\n}\n\nll term(state& begin){\n    ll res=term_(begin);\n    while(true){\n        if(*begin=='+' and ((pri['+']<pri['-'] and pri['+']>=pri['*']) or (pri['+']>=pri['-'] and pri['+']<pri['*']))){\n            ++begin;\n            res+=term_(begin);\n        }else if(*begin=='-' and ((pri['-']<pri['+'] and pri['-']>=pri['*']) or (pri['-']>=pri['+'] and pri['-']<pri['*']))){\n            ++begin;\n            res-=term_(begin);\n        }else if(*begin=='*' and ((pri['*']<pri['+'] and pri['*']>=pri['-']) or (pri['*']>=pri['+'] and pri['*']<pri['-']))){\n            ++begin;\n            res*=term_(begin);\n        }else break;\n    }\n    return res;\n}\n\nll expr(state& begin){\n    ll res=term(begin);\n    while(true){\n        if(*begin=='+' and pri['+']<=pri['-'] and pri['+']<=pri['*']){\n            ++begin;\n            res+=term(begin);\n        }else if(*begin=='-' and pri['-']<=pri['+'] and pri['-']<=pri['*']){\n            ++begin;\n            res-=term(begin);\n        }else if(*begin=='*' and pri['*']<=pri['+'] and pri['*']<=pri['-']){\n            ++begin;\n            res*=term(begin);\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    string s;\n    cin >> s;\n    ll ans=-infll;\n    rep(i,0,3) rep(j,0,3) rep(k,0,3){\n        pri['+']=i;\n        pri['-']=j;\n        pri['*']=k;\n        state begin=s.begin();\n        ans=max(ans,expr(begin));\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nchar op[3] = {'+', '-', '*'};\n\nint pos;\nstring s;\n\nll exprA1();\nll exprA2();\nll exprA3();\nll factorA();\nll exprB1();\nll exprB2();\nll factorB();\nll exprC1();\nll exprC2();\nll factorC();\nll exprD1();\nll factorD();\nll number();\n\nll exprA1() {\n  ll ret = exprA2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprA2();\n      else if(op[0] == '*') pos++, ret *= exprA2();\n      else if(op[0] == '-') pos++, ret -= exprA2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprA2() {\n  ll ret = exprA3();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprA3();\n      else if(op[1] == '*') pos++, ret *= exprA3();\n      else if(op[1] == '-') pos++, ret -= exprA3();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprA3() {\n  ll ret = factorA();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorA();\n      else if(op[2] == '*') pos++, ret *= factorA();\n      else if(op[2] == '-') pos++, ret -= factorA();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorA() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprA1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprB1() {\n  ll ret = exprB2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprB2();\n      else if(op[0] == '*') pos++, ret *= exprB2();\n      else if(op[0] == '-') pos++, ret -= exprB2();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprB2();\n      else if(op[1] == '*') pos++, ret *= exprB2();\n      else if(op[1] == '-') pos++, ret -= exprB2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprB2() {\n  ll ret = factorB();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorB();\n      else if(op[2] == '*') pos++, ret *= factorB();\n      else if(op[2] == '-') pos++, ret -= factorB();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorB() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprB1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprC1() {\n  ll ret = exprC2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprC2();\n      else if(op[0] == '*') pos++, ret *= exprC2();\n      else if(op[0] == '-') pos++, ret -= exprC2();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprC2();\n      else if(op[1] == '*') pos++, ret *= exprC2();\n      else if(op[1] == '-') pos++, ret -= exprC2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprC2() {\n  ll ret = factorC();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += factorC();\n      else if(op[1] == '*') pos++, ret *= factorC();\n      else if(op[1] == '-') pos++, ret -= factorC();\n    } else if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorC();\n      else if(op[2] == '*') pos++, ret *= factorC();\n      else if(op[2] == '-') pos++, ret -= factorC();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorC() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprC1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprD1() {\n  ll ret = factorD();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += factorD();\n      else if(op[0] == '*') pos++, ret *= factorD();\n      else if(op[0] == '-') pos++, ret -= factorD();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += factorD();\n      else if(op[1] == '*') pos++, ret *= factorD();\n      else if(op[1] == '-') pos++, ret -= factorD();\n    } else if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorD();\n      else if(op[2] == '*') pos++, ret *= factorD();\n      else if(op[2] == '-') pos++, ret -= factorD();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorD() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprD1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll number() {\n  ll ret = 0;\n  while(pos < s.size() && isdigit(s[pos])) {\n    ret *= 10;\n    ret += s[pos]-'0';\n    pos++;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> s;\n\n  ll ans = LLONG_MIN;\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprA1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprB1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprC1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprD1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nset<char> aops[3]; // 演算子の優先順位\n\ntemplate<class T> struct Parser {\n    // results\n    int root;                       // vals[root] is the answer\n    vector<T> vals;                 // value of each node\n    vector<char> ops;               // operator of each node ('a' means leaf values)\n    vector<int> left, right;        // the index of left-node, right-node\n    vector<int> ids;                // the node-index of i-th value\n    int ind = 0;\n    \n    void init() {\n        vals.clear(); ops.clear(); left.clear(); right.clear(); ids.clear();\n        ind = 0;\n    }\n    \n    // generate nodes\n    int newnode(char op, int lp, int rp, T val = 0) {\n        ops.push_back(op); left.push_back(lp); right.push_back(rp);\n        if (op == 'a') {\n            vals.push_back(val);\n            ids.push_back(ind++);\n        }\n        else {\n            if (op == '+') vals.push_back(vals[lp] + vals[rp]);\n            else if (op == '-') vals.push_back(vals[lp] - vals[rp]);\n            else if (op == '*') vals.push_back(vals[lp] * vals[rp]);\n            ids.push_back(-1);\n        }\n        return (int)vals.size() - 1;\n    }\n    \n    // main solver\n    T solve(const string &S) {\n        int p = 0;\n        root = expr(S, p);\n        return vals[root];\n    }\n    \n    // parser\n    int expr(const string &S, int &p, int depth = 0) {\n        if (depth < 3) {\n            int lp = expr(S, p, depth + 1);\n            while (p < (int)S.size() && aops[depth].count(S[p])) {\n                char op = S[p]; ++p;\n                int rp = expr(S, p, depth + 1);\n                lp = newnode(op, lp, rp);\n            }\n            return lp;\n        }\n        else {\n            if (S[p] == '(') {\n                ++p;                    // skip '('\n                int lp = expr(S, p, 0);\n                ++p;                    // skip ')'\n                return lp;\n            }\n            else {\n                /* each process */\n                long long val = 0;\n                while (S[p] >= '0' && S[p] <= '9') {\n                    val *= 10;\n                    val += (int)(S[p] - '0');\n                    ++p;\n                }\n                return newnode('a', -1, -1, val);\n            }\n        }\n    }\n};\n\nint main() {\n    string S; cin >> S;\n    Parser<long long> ps;\n    long long res = -LONG_MAX;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                for (int it = 0; it < 3; ++it) aops[it].clear();\n                aops[i].insert('+');\n                aops[j].insert('-');\n                aops[k].insert('*');\n                Parser<long long> ps;\n                long long tmp = ps.solve(S);\n                res = max(res, tmp);\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops; /* levelと演算子の対応. levelが大きいほど優先度が高い. */\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        // opが当該levelの演算子かどうかを返す\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    const Long INF = LLONG_MIN;\n\n    void solve() {\n        // 各演算子のlevelに対して全探索.\n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = -INF;\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                for (int c = 0; c < 3; c++) {\n                    for (int i = 0; i < 4; i++) {\n                        ops.clear(); ops.resize(3);\n                        ops[a].push_back(t[0]);\n                        ops[b].push_back(t[1]);\n                        ops[c].push_back(t[2]);\n                        int index = 0;\n                        ans = max(ans, parse(s, index, 0));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\n\nclass Calc {\n  private:\n    string str;\n    vector<char> p;\n    string::iterator it;\n\n  public:\n    Calc (string str, vector<char> p) {\n        this->str = str;\n        this->p   = p;\n        it = this->str.begin();\n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n    }\n\n    ll f0(int pt)\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            if (pt == 0) {\n                res = f3(0);\n            } else if (pt <= 2) {\n                res = f2(pt);   \n            } else {\n                res = f1(3);\n            }\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n\n    ll f1(int pt)\n    {\n        ll res = f0(pt);\n        while (*it == p[0] ||\n               (pt >= 2 && *it == p[1]) ||\n               (pt >= 3 && *it == p[2])) {\n            \n            if (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(pt));\n            } else if (pt >= 2 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f0(pt));\n            } else if (pt >= 3 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[1], f0(pt));\n            }            \n        }\n        return res;\n    }\n\n    ll f2(int pt)\n    {\n        ll res = f1(pt);\n        if (pt == 0) {\n            while (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1(0));\n            }\n        } else if (pt == 1) {\n            while (*it == p[1] || *it == p[2]) {\n                if (*it == p[1]) {\n                    ++it;\n                    res = get_val(res, p[1], f1(1));                \n                } else {                               \n                    ++it;\n                    res = get_val(res, p[2], f1(1));                \n                }\n            }\n        } else if (pt == 2) {\n            while (*it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f1(2));                \n            }\n        }\n        return res;\n    }\n\n    ll f3(int pt)\n    {\n        ll res = f2(0);\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2(0));\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;      \n    vector<char> p = {'*', '+', '-'};\n    ll res = LLONG_MIN;    \n    do {\n        for (int i = 0; i < 4; i++) {\n            Calc  c(str, p);\n            ll r = -1;\n            if (i == 0) {\n                r = c.f3(0);\n            } else if (i <= 2) {\n                r = c.f2(i);\n            } else {\n                r = c.f1(3);\n            }\n            res = max(res, r);\n        }\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint operate(int a, int b, char r){\n    return r == '+' ? a + b : r == '-' ? a - b : a * b;\n}\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n \nnamespace AAA{\n    int expression(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == '+' || op == '-' || op == '*'){\n                begin++;                \n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\nnamespace AAB{\n    char a1, a2, b;\n    int expression(State &begin);\n    int term(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a1 || op == a2){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\nnamespace ABB{\n    char a, b1, b2;\n    int expression(State &begin);\n    int term(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b1 || op == b2){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\n\nnamespace ABC{\n    char a, b, c;\n    int expression(State &begin);\n    int term(State &begin);\n    int term2(State &begin);\n    int factor(State &begin);\n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = term2(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b){\n                begin++;\n                ret = operate(ret, term2(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term2(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == c){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\n\nsigned main(){\n    string s;\n    cin >> s;\n    int ans = -1e18;\n    char op[] = \"+-*\";\n    sort(op, op + 3);\n    do{\n        AAB::a1 = ABB::a = ABC::a = op[0];\n        AAB::a2 = ABB::b1 = ABC::b = op[1];\n        AAB::b = ABB::b2 = ABC::c = op[2];\n        State begin = s.begin();\n        int now = AAA::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = AAB::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = ABB::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = ABC::expression(begin);\n        ans = max(ans, now);\n\n    }while(next_permutation(op, op + 3));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <string>\n#include <cctype>\n#include <set>\nusing namespace std;\n\nset<char> aops[3];  // 演算子の優先順位\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return expr(begin, 0);\n    }\n\n    T expr(State &begin, int depth) {\n        if (depth == 3) return factor(begin);\n        T ret = expr(begin, depth + 1);\n        for (;;) {\n            if (*begin == '+' && aops[depth].count('+')) {\n                begin++;\n                ret += expr(begin, depth + 1);\n            } else if (*begin == '-' && aops[depth].count('-')) {\n                begin++;\n                ret -= expr(begin, depth + 1);\n            } else if (*begin == '*' && aops[depth].count('*')) {\n                begin++;\n                ret *= expr(begin, depth + 1);\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n\n    T factor(State &begin) {\n        if (*begin == '(') {\n            begin++; // skip '('\n            T ret = expr(begin, 0);\n            begin++; // skip ')'\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    T number(State &begin) {\n        T ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    string S; cin >> S;\n    long long res = -LONG_MAX;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                for (int it = 0; it < 3; it++) aops[it].clear();\n                aops[i].insert('+');\n                aops[j].insert('-');\n                aops[k].insert('*');\n                Parser<long long> ps;\n                res = max(res, ps.solve(S));\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n#include <cctype>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nstruct Parser {\n  typedef string::const_iterator cursor_t;\n  Parser(){\n    memset(prit, 0, sizeof(prit));\n  }\n  ll eval(const string& s){\n    auto b = s.begin();\n    ll x = expr(b);\n    consume(b, '\\0');\n    return x;\n  }\n  inline void consume(cursor_t& cur, char expected){\n    assert(*cur == expected);\n    ++cur;\n  }\n  ll expr(cursor_t& cur, int pri=0){\n    if (pri == 3){\n      if (*cur == '('){\n        consume(cur, '(');\n        ll r = expr(cur);\n        consume(cur, ')');\n        return r;\n      }\n      return number(cur);\n    }\n    ll r = expr(cur, pri + 1);\n    while (prit[pri][*cur]){\n      if (*cur == '*') ++cur, r = r * expr(cur, pri + 1);\n      else if (*cur == '+') ++cur, r = r + expr(cur, pri + 1);\n      else if (*cur == '-') ++cur, r = r - expr(cur, pri + 1);\n    }\n    return r;\n  }\n  ll number(cursor_t& cur){\n    ll r = 0;\n    while (isdigit(*cur)){\n      r = r * 10 + *cur - '0';\n      ++cur;\n    }\n    return r;\n  }\n  int prit[3][256];\n};\n\nint main()\n{\n  Parser parser;\n  string S;\n\n  cin >> S;\n  ll maxi = LLONG_MIN;\n  for (int i = 0; i < 3; i++){\n    for (int j = 0; j < 3; j++){\n      for (int k = 0; k < 3; k++){\n        for (int l = 0; l < 3; l++){\n          parser.prit[l]['*'] = (i == l);\n          parser.prit[l]['+'] = (j == l);\n          parser.prit[l]['-'] = (k == l);\n        }\n        maxi = max(maxi, parser.eval(S));\n      }\n    }\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nvoid cal(int &a, char op, int b) {\n\tif (op == '+')a += b;\n\telse if (op == '-')a -= b;\n\telse if (op == '*')a *= b;\n\telse assert(1 == 0);\n}\n\nclass Parser1 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser1(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2<op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{op2,c};\n\tc=d,{op3,d};\n\td='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret = d();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, d());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint d() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser2 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser2(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2<op3\n\tEBNF\n\ta=b,{(op1|op2),b};\n\tb=c,{op3,c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser3 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser3(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2==op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{(op2|op3),c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser4 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser4(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2==op3\n\tEBNF\n\ta=b,{(op1|op2|op3),b};\n\tb='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nsigned main() {\n\tstring s; getline(cin, s);\n\ts += \"$\";\n\tint ans = -INF;\n\tvector<char> op = { '+','-','*' };\n\tsort(all(op));\n\tdo {\n\t\tParser1 P1(s.begin(), op[0], op[1], op[2]);\n\t\tParser2 P2(s.begin(), op[0], op[1], op[2]);\n\t\tParser3 P3(s.begin(), op[0], op[1], op[2]);\n\t\tParser4 P4(s.begin(), op[0], op[1], op[2]);\n\t\tans = max({ ans, P1.a(),P2.a(),P3.a(),P4.a() });\n\t} while (next_permutation(op.begin(), op.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nstring S;\nint N;\n\nLL C(int& i, string& order);\nLL D(int& i, string& order);\nLL E(int& i, string& order);\nLL F(int& i, string& order);\n\nLL C(int& i, string& order){\n  LL res = D(i, order);\n  if(i < N && S[i] == order[2]){\n\t++i;\n\tLL res2 = C(i, order);\n\tswitch(order[2]){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL D(int& i, string& order){\n  LL res = E(i, order);\n  if(i < N && S[i] == order[1]){\n\t++i;\n\tLL res2 = D(i, order);\n\tswitch(order[1]){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL E(int& i, string& order){\n  LL res = F(i, order);\n  if(i < N && S[i] == order[0]){\n\t++i;\n\tLL res2 = E(i, order);\n\tswitch(order[0]){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\n\nLL F(int& i, string& order){\n  LL res = 0;\n  if(S[i] == '('){\n\t++i;\n\tres = C(i, order);\n\t++i;\n  }\n  else{\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i]-'0');\n\t  ++i;\n\t}\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n  string op = \"+-*\";\n\n  SORT(op);\n  LL ans = -1e18;\n  do{\n\tint i = 0;\n\tmaxi(ans, C(i,op));\n  }while(next_permutation(ALL(op)));\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 62);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\tif (sent.size() != 1)exit(1);\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tll res = -INFL;\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\tfor (auto level : levels) {\n\t\tstack<string> st;\n\t\tfor (string s : vs) {\n\t\t\tif (s == \")\") {\n\t\t\t\tstack<string> sent;\n\t\t\t\twhile (true) {\n\t\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\t\tif (top == \"(\")break;\n\t\t\t\t\tsent.push(top);\n\t\t\t\t}\n\t\t\t\tst.push(calc(level, sent));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s);\n\t\t\t}\n\t\t}\n\t\tstack<string> op;\n\t\twhile (!st.empty()) {\n\t\t\top.push(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tres = max(res, stoll(calc(level, op)));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\nint c[3];\n\nll expression(State &begin);\nll number(State &begin);\nll factor(State &begin);\nll term1(State &begin);\nll term2(State &begin);\n\n\nll number(State &begin){\n\tll ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nll term2(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]==2){\n\t\t\tbegin++;\n\t\t\tret+=number(begin);\n\t\t}else if(*begin=='-' && c[1]==2){\n\t\t\tbegin++;\n\t\t\tret-=number(begin);\n\t\t}else if(*begin=='*' && c[2]==2){\n\t\t\tbegin++;\n\t\t\tret*=number(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll term1(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]>=1){\n\t\t\tbegin++;\n\t\t\tret+=term2(begin);\n\t\t}else if(*begin=='-' && c[1]>=1){\n\t\t\tbegin++;\n\t\t\tret-=term2(begin);\n\t\t}else if(*begin=='*' && c[2]>=1){\n\t\t\tbegin++;\n\t\t\tret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tll ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else number(begin);\n}\n\nll expression(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tif(c[0]==0)ret+=term1(begin);\n\t\t\tif(c[0]>=1)ret+=term2(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(c[1]==0)ret-=term1(begin);\n\t\t\tif(c[1]>=1)ret-=term2(begin);\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tif(c[2]==0)ret*=term1(begin);\n\t\t\tif(c[2]>=1)ret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tll res=0;\n\tfor(int i=0;i<3;i++){\n\t\tc[0]=i;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tc[1]=j;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tc[2]=k;\n\t\t\t\tState begin=str.begin();\n\t\t\t\tll re=expression(begin);\n\t\t\t\tif(i+j+k==0)res=re;\n\t\t\t\telse res=max(res,re);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = (1<<31);\nconst ll LLINF = (1LL<<63);\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nvector<char> ope[3];\nvector<int> v;\nint first, second, third;\n\nll firstParse(State &);\nll secondParse(State &);\nll thirdParse(State &);\nll number(State &);\nll factor(State &);\n\n// ??°??????????????????????????????????????°????????????\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n      ret = ret*10 + (*begin - '0');\n      begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++; // '('????£???°??????\n    ll ret;\n    if(v.size()==3) ret = thirdParse(begin);\n    else if(v.size()==2) ret = secondParse(begin);\n    else if(v.size()==1) ret = firstParse(begin);\n    begin++; // ')'????£???°??????\n    return ret;\n  } else {\n      return number(begin);\n  }\n  return -1;\n}\n\n//?¬¬?????????expression\nll firstParse(State &begin){\n  ll ret = factor(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[first].size()){\n      if (*begin == ope[first][i]) {\n        flag = true;\n        begin++;\n        if(ope[first][i]=='+') ret += factor(begin);\n        else if(ope[first][i]=='-') ret -= factor(begin);\n        else if(ope[first][i]=='*') ret *= factor(begin);\n        break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll secondParse(State &begin) {\n  ll ret = firstParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[second].size()){\n      if (*begin == ope[second][i]) {\n          flag = true;\n          begin++;\n          if(ope[second][i]=='+') ret += firstParse(begin);\n          else if(ope[second][i]=='-') ret -= firstParse(begin);\n          else if(ope[second][i]=='*') ret *= firstParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll thirdParse(State &begin) {\n  ll ret = secondParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[third].size()){\n      if (*begin == ope[third][i]) {\n          flag = true;\n          begin++;\n          if(ope[third][i]=='+') ret += secondParse(begin);\n          else if(ope[third][i]=='-') ret -= secondParse(begin);\n          else if(ope[third][i]=='*') ret *= secondParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\nint main() {\n  string s;\n  cin>>s;\n  State start = s.begin();\n  ll ans = -LLINF;\n  /*??°???????°?????????????????????????????????????*/\n  REP(i,0,3){\n    REP(j,0,3){\n      REP(k,0,3){\n\n        REP(l,0,3) ope[l].clear();\n        ope[i].push_back('+');\n        ope[j].push_back('-');\n        ope[k].push_back('*');\n        v.clear();\n        v.push_back(i); v.push_back(j); v.push_back(k);\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        ll tmp;\n        State start = s.begin();\n\n        if(v.size() == 3){\n          first = v[0]; second = v[1]; third = v[2];\n          tmp = thirdParse(start);\n        }else if(v.size() == 2){\n          first = v[0]; second = v[1];\n          tmp = secondParse(start);\n        }else{\n          first = v[0];\n          tmp = firstParse(start);\n        }\n        ans = max(ans, tmp);\n\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nmap<char, int> op;\n\nll term1(State&);\nll term2(State&);\nll term3(State&);\nll factor(State&);\nll number(State&);\n\nll calc(ll x, char c, ll y){\n    if (c == '+') x += y;\n    if (c == '-') x -= y;\n    if (c == '*') x *= y;\n    return x;\n}\n\nll term1(State &begin){\n    ll ret = term2(begin);\n    while (1){\n        if (op[*begin] == 1){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term2(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll term2(State &begin){\n    ll ret = term3(begin);\n    while (1){\n        if (op[*begin] == 2){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term3(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll term3(State &begin){\n    ll ret = factor(begin);\n    while (1){\n        if (op[*begin] == 3){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, factor(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll factor(State &begin){\n    if (*begin == '('){\n        begin++;\n        ll ret = term1(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nll number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    ll res = 0;\n    bool f = 1;\n    string s;\n    cin >> s;\n    REP(i,3) REP(j,3) REP(k,3){\n        op['+'] = i+1;\n        op['-'] = j+1;\n        op['*'] = k+1;\n        State begin = s.begin();\n        if (f) res = term1(begin), f = 0;\n        else res = max(res, term1(begin));\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    ret = calc(ret, S[idx++], ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    ret = calc(ret, S[idx++], beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    ret = calc(ret, S[idx++], malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  if(p>=s.size())return res;\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  if(p>=s.size())return res;\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  if(p>=s.size())return res;\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nlong long int calc(const int type, const long long int l, const long long r) {\n\tif (type == 0) {\n\t\treturn l + r;\n\t}\n\telse if (type == 1) {\n\t\treturn l - r;\n\n\t}\n\telse {\n\t\treturn l*r;\n\t}\n}\nlong long int calc1(const char type, const long long int l, const long long r) {\n\tif (type == '+') {\n\t\treturn calc(0, l, r);\n\t}\n\telse if (type == 1) {\n\t\treturn calc(1, l, r);\n\n\t}\n\telse {\n\t\treturn calc(2, l, r);\n\t}\n}\nint a = 0;\nvector<int>perms = { 0,1,2 };\nstring st;\nmap<int, char>mp;\nlong long int getnum() {\n\tlong long int num = 0;\n\twhile (isdigit(st[a])) {\n\t\tnum += num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\nlong long int getform0();\nlong long int getform2() {\n\tlong long int ans;\n\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tans = getform0();\n\t\ta++;\n\t}\n\telse {\n\t\tans = getnum();\n\t}\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[0]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[1]) {\n\t\t\treturn ans;\n\t\t}\n\t\telse if (st[a] == mp[2]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[2], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform1() {\n\tlong long int ans;\n\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tans = getform0();\n\t\ta++;\n\t}\n\telse {\n\t\tans = getnum();\n\t}\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[0]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[1]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[1], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[2]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[2], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform0(){\n\tlong long int ans;\n\t\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tans=getform0();\n\t\ta++;\n\t}\n\telse {\n\t\tans = getnum();\n\t}\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[0]) {\n\t\t\t\ta++;\n\t\t\t\tans = calc1(mp[0], ans, getform1());\n\t\t\t\n\t\t}\n\t\telse if(st[a]==mp[1]){\n\t\t\ta++;\n\t\t\tans = calc1(mp[1], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[2]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[2], ans, getnum());\n\t\t}\n\t\telse if(st[a]==')'){\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tmp[0] = '+';\n\tmp[1] = '-';\n\tmp[2] = '*';\n\tcin >> st;\n\tlong long int ans = -1e18;\n\tdo {\n\t\ta = 0;\n\t\tans = max(ans,getform0());\n\t} while (next_permutation(perms.begin(), perms.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res,t;\n  if(S[p]=='(') p++,res=calc(-1),p++;\n  else res=getNum();\n  while(p<S.size()&&S[p]!=')'&&ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  ll res=calc(-1);\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,calc(-1));\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#include<array>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long Int;\ntypedef string::const_iterator Itr;\n\narray<int,3> flag;\n\nInt ctoi(const char &c)\n{\n\treturn c - '0';\n}\n\nInt expression(Itr &);\nInt term(Itr &);\nInt term2(Itr &);\nInt factor(Itr &);\nInt number(Itr &);\n\nInt expression(Itr &itr)\n{\n\tInt ret = term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+' && flag[0]==0)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret + term(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret - term(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret*term(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term(Itr &itr)\n{\n\tInt ret = term2(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret + term2(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret - term2(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret*term2(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term2(Itr &itr)\n{\n\tInt ret = factor(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret + factor(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret - factor(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret*factor(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt factor(Itr &itr)\n{\n\tInt ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = number(itr);\n\t}\n\n\treturn ret;\n}\n\nInt number(Itr &itr)\n{\n\tInt ret = 0;\n\n\twhile (isdigit(*itr))\n\t{\n\t\tret *= 10;\n\t\tret += ctoi(*itr);\n\t\titr++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin, s);\n\ts.append(\"_\");\n\n\tInt max_ans = 0;\n\n\tREP(i,3)REP(j,3)REP(k,3)\n\t{\n\t\tflag[0] = i;\n\t\tflag[1] = j;\n\t\tflag[2] = k;\n\t\tItr begin = s.begin();\n\t\tInt ans = expression(begin);\n\t\tif (max_ans < ans)\n\t\t{\n\t\t\tmax_ans = ans;\n\t\t}\n\t}\n\tcout << max_ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoi(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans=-1e10;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nlong long int calc(const int type, const long long int l, const long long r) {\n\tif (type == 0) {\n\t\treturn l + r;\n\t}\n\telse if (type == 1) {\n\t\treturn l - r;\n\n\t}\n\telse {\n\t\treturn l*r;\n\t}\n}\nlong long int calc1(const char type, const long long int l, const long long r) {\n\tif (type == '+') {\n\t\treturn calc(0, l, r);\n\t}\n\telse if (type == '-') {\n\t\treturn calc(1, l, r);\n\n\t}\n\telse {\n\t\treturn calc(2, l, r);\n\t}\n}\nint a = 0;\nstring st;\nmap<char,int>mp;\nlong long int getform0();\nlong long int getnum() {\n\tlong long int num = 0;\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tnum= getform0();\n\t\ta++;\n\t}\n\telse {\n\t\twhile (isdigit(st[a])) {\n\t\t\tnum = num * 10 + st[a] - '0';\n\t\t\ta++;\n\t\t}\n\t}\n\treturn num;\n\t\n}\nlong long int getform2() {\n\tlong long int ans;\n\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (mp[st[a]] == 1) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (mp[st[a]] == 2) {\n\t\t\treturn ans;\n\t\t}\n\t\telse if (mp[st[a]] == 3) {\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\tans = calc1(type, ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform1() {\n\tlong long int ans;\n\n\t\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (mp[st[a]] == 1) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (mp[st[a]] == 2) {\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\tans = calc1(type, ans, getform2());\n\t\t}\n\t\telse if (mp[st[a]] == 3) {\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\tans = calc1(type, ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform0(){\n\tlong long int ans;\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (mp[st[a]] == 1) {\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\t\tans = calc1(type, ans, getform1());\n\t\t\t\n\t\t}\n\t\telse if(mp[st[a]] == 2){\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\tans = calc1(type, ans, getform2());\n\t\t}\n\t\telse if (mp[st[a]] == 3) {\n\t\t\tconst char type = st[a];\n\t\t\ta++;\n\t\t\tans = calc1(type, ans, getnum());\n\t\t}\n\t\telse if(st[a]==')'){\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> st;\n\tlong long int ans = -9223372036854775807;\n\tfor (mp['+'] = 1; mp['+'] < 4; ++mp['+']) {\n\t\tfor (mp['-'] = 1; mp['-'] < 4; ++mp['-']) {\n\t\t\tfor (mp['*'] = 1; mp['*'] < 4; ++mp['*']) {\n\t\t\t\ta = 0;\n\t\t\t\tans = max(ans, getform0());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef function<ll(string&, int&, int, ll&)> OpFunc;\n\nbool op_add(string& s, int& idx, int opidx, ll& n);\nbool op_sub(string& s, int& idx, int opidx, ll& n);\nbool op_mul(string& s, int& idx, int opidx, ll& n);\n\nll expr(string& s, int& idx, int opidx);\n\nint comb1[6][3] = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0},\n};\nint comb2[6][2] = {\n    {3, 2},\n    {2, 3},\n    {4, 1},\n    {1, 4},\n    {5, 0},\n    {0, 5},\n};\n\nvector<vector<OpFunc>> op;\n\nll factor(string& s, int& idx) {\n    ll n = 0;\n    if (s[idx] == '(') {\n        idx++; // (\n        n = expr(s, idx, 0);\n        idx++; // )\n    } else {\n        while (isdigit(s[idx])) {\n            n *= 10;\n            n += s[idx] - '0';\n            idx++;\n        }\n    }\n    return n;\n}\n\nll expr(string& s, int& idx, int opidx) {\n    if (opidx == SZ(op)) {\n        return factor(s, idx);\n    } else {\n        ll n = expr(s, idx, opidx+1);\n        for (; idx < (int)s.length();) {\n            bool ok = false;\n            REP(i, SZ(op[opidx])) {\n                if (op[opidx][i](s, idx, opidx, n)) {\n                    ok = true;\n                }\n            }\n            if (!ok) break;\n        }\n        return n;\n    }\n}\n\nbool op_add(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '+') {\n        idx++;\n        n += expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_sub(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '-') {\n        idx++;\n        n -= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_mul(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '*') {\n        idx++;\n        n *= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    string line;\n    cin >> line;\n    vector<vector<OpFunc>> o;\n    o.push_back({op_add});\n    o.push_back({op_sub});\n    o.push_back({op_mul});\n    o.push_back({op_add, op_sub});\n    o.push_back({op_add, op_mul});\n    o.push_back({op_sub, op_mul});\n\n    vector<vector<vector<OpFunc>>> ops;\n    REP(i, 3) {\n        vector<vector<OpFunc>> v;\n        REP(j, 3) {\n            v.push_back(o[comb1[i][j]]);\n        }\n        ops.push_back(v);\n        v.clear();\n        REP(j, 2) {\n            v.push_back(o[comb2[i][j]]);\n        }\n        ops.push_back(v);\n    }\n    ops.push_back({{op_add, op_sub, op_mul}});\n\n    ll ma = 0;\n    REP(i, SZ(ops)) {\n        op.clear();\n        op = ops[i];\n        int idx = 0;\n        ma = max(ma, expr(line, idx, 0));\n    }\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint cur;\nchar str[210];\nint perm[3]={0,1,2};\nchar ch[5]=\"+-*\";\nlong long expr(int a){\n\tif(a==3){\n\t\tif(str[cur]=='('){\n\t\t\tcur++;\n\t\t\tlong long ret=expr(0);\n\t\t\tcur++;\n\t\t\treturn ret;\n\t\t}else{\n\t\t\tlong long ret=0;\n\t\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\t\tret*=10;\n\t\t\t\tret+=str[cur]-'0';\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlong long ret=expr(a+1);\n\twhile(str[cur]==ch[perm[a]]){\n\t\tcur++;\n\t\tlong long tmp=expr(a+1);\n\t\tif(ch[perm[a]]=='+')ret+=tmp;\n\t\telse if(ch[perm[a]]=='-')ret-=tmp;\n\t\telse ret*=tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tlong long ret=expr(0);\n\tdo{\n\t\tcur=0;\n\t\tret=max(ret,expr(0));\n\t}while(next_permutation(perm,perm+3));\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\n\nll num(string&);\nll term(string&);\nll expr(string&);\nint pos;\nmap<char, int> mp;\nll calc(ll a, ll b, char op) {\n\tif (op == '-')return a - b;\n\tif (op == '+')return a + b;\n\tif (op == '*')return a * b;\n\tthrow(\"wrong op\");\n}\nll num(string& s) {\n\tll res = 0;\n\twhile (isdigit(s[pos])) {\n\t\tres *= 10;\n\t\tres += s[pos] - '0';\n\t\tpos++;\n\t}\n\treturn res;\n\n}\nll term(string& s) {\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\treturn expr(s);\n\t}\n\telse {\n\t\tll a = num(s);\n\t\treturn a;\n\t}\n}\nll expr(string& s) {\n\tvl res;\n\tres.push_back(term(s));\n\tvector<char> ops;\n\twhile (pos < s.size()) {\n\t\tif (s[pos] == ')') {\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t}\n\t\tops.push_back(s[pos]);\n\t\tpos++;\n\t\tll b = term(s);\n\t\tres.push_back(b);\n\t}\n\tREP(j, 3)REP(i, ops.size()) {\n\t\tif (mp[ops[i]] == j) {\n\t\t\tll tmp = calc(res[i], res[i + 1], ops[i]);\n\t\t\tres.insert(res.begin() + i, tmp);\n\t\t\tres.erase(res.begin() + i + 1, res.begin() + i + 3);\n\t\t\tops.erase(ops.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\n\treturn res[0];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\t//cout << exp(s) << endl;\n\tstring t = \"-+*\";\n\tll ans = numeric_limits<ll>::min();\n\tREP(i, 3)REP(j, 3)REP(k, 3) {\n\t\tmp.clear();\n\t\tmp['-'] = i;\n\t\tmp['+'] = j;\n\t\tmp['*'] = k;\n\t\tpos = 0;\n\t\tll tmp = expr(s);\n\t\tchmax(ans, tmp);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\ntypedef struct ParserState {\n    int pos, len;\n    std::string str;\n    std::deque<int> stack;\n\n    bool isEOF() {return pos >= len;}\n    bool isNotEOF() {return pos < len;}\n\n    char getCh() {\n        return pos < len ? str[pos++] : -1;\n    }\n    char seek() {\n        return pos < len ? str[pos] : -1;\n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n    std::string lookAhead(int l) {\n        return str.substr(pos, l);\n    }\n\n    void setBackrack(){stack.push_front(pos);}\n    bool backtrack(){\n        if(stack.empty()) return false;\n        pos = stack.front();\n        stack.pop_front();\n        return true;\n    }\n\n    bool isDigit(){return isDigit(0);}\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha(){return isUpperAlpha(0);}\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha(){return isLowerAlpha(0);}\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'a' && c <= 'z';\n    }\n}State;\n\nstd::map<char,int> pri;\n\nLL parseNumber(State*);\nLL parse(State*);\n\nLL calc(char op, LL left, LL right) {\n    if(op == '+') return left + right;\n    if(op == '-') return left - right;\n    if(op == '*') return left * right;\n    return assert(pri.count(op) > 0), -1;\n}\n\n\nint bot = 0;\nLL parseNumber(State* state) {\n    LL res = 0LL;\n    while(state->isNotEOF() && state->isDigit()) {\n        res *= 10;\n        res += (int)(state->getCh() - '0');\n    }\n    return res;\n}\n\nLL parse(int level, State* state) {\n    if(bot < level) {\n        if(state->isDigit()) return parseNumber(state);\n\n        state->getCh(); // eat (\n        LL r = parse(0, state);\n        state->getCh(); // eat )\n        return r;\n    }\n\n    LL result = parse(level + 1, state);\n    while(state->isNotEOF() && state->seek() != ')') {\n        char ch = state->seek();\n        if(pri[ch] < level) break;\n        state->getCh(); //eat op\n\n        LL res = parse(level + 1, state);\n        result = calc(ch, result, res);\n\n        if(state->isEOF()) break;\n    }\n    return result;\n}\n\nint main() {\n    std::string S;\n    std::cin >> S;\n    int len = S.length();\n\n    LL ans = 0LL;\n    for(int i=0; i<27; ++i) {\n        pri['+'] = i     % 3;\n        pri['-'] = (i/3) % 3;\n        pri['*'] = (i/9) % 3;\n        bot = std::max(i%3, std::max((i/3)%3, (i/9)%3));\n\n        State state = State{0, len, S};\n        LL res = parse(0, &state);\n\n        ans = std::max(ans, res);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\n\nll calc(ll v1, ll v2, char op) {\n    if(op == '+') {\n        return v1 + v2;\n    } else if(op == '-') {\n        return v1 - v2;\n    } else {\n        return v1 * v2;\n    }\n}\n\n// <expr> := <term1> | <expr> <op1> <term1>\n// <term1> := <term2> | <term1> <op2> <term2>\n// <term2> := <fact> | <term2> <op3> <fact>\n// <fact> := (<expr>) | <number>\n\nll expr(string const& s, int& p, map<char, int>& m);\nll term1(string const& s, int& p, map<char, int>& m);\nll term2(string const& s, int& p, map<char, int>& m);\nll fact(string const& s, int& p, map<char, int>& m);\n\nll number(string const& s, int& p) {\n    ll res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nll expr(string const& s, int& p, map<char, int>& m) {\n    ll v1 = term1(s, p, m);\n    while(p < s.size() && m.count(s[p]) == 1 && m[s[p]] == 0) {\n        char op = s[p++];\n        v1 = calc(v1, term1(s, p, m), op);\n    }\n    return v1;\n}\n\nll term1(string const& s, int& p, map<char, int>& m) {\n    ll v1 = term2(s, p, m);\n    while(p < s.size() && m.count(s[p]) == 1 && m[s[p]] == 1) {\n        char op = s[p++];\n        v1 = calc(v1, term2(s, p, m), op);\n    }\n    return v1;\n}\n\nll term2(string const& s, int& p, map<char, int>& m) {\n    ll v1 = fact(s, p, m);\n    while(p < s.size() && m.count(s[p]) == 1 && m[s[p]] == 2) {\n        char op = s[p++];\n        v1 = calc(v1, fact(s, p, m), op);\n    }\n    return v1;\n}\n\nll fact(string const& s, int& p, map<char, int>& m) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    ll res = expr(s, ++p, m);\n    ++p;\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    ll res = numeric_limits<ll>::min();\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            for(int k=0; k<3; ++k) {\n                int p = 0;\n                map<char, int> m;\n                m['+'] = i;\n                m['-'] = j;\n                m['*'] = k;\n                res = max(res, expr(s, p, m));\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint xx,yy,zz;\nint pr(char c)\n{\n    if(c=='+') return xx;\n    if(c=='-') return yy;\n    if(c=='*') return zz;\n    assert(false);\n}\n\nll E(string s)\n{\n    int S=s.size();\n    int idx = 0;\n\n    vector<ll> val;\n    vector<char> op;\n\n    while(idx<S)\n    {\n        if(s[idx]=='+' || s[idx]=='-' || s[idx]=='*') op.pb(s[idx++]);\n        else\n        {\n            if(s[idx]=='(')\n            {\n                int b = 1;\n                ++idx;\n                int st = idx;\n                while(b>0)\n                {\n                    if(s[idx]=='(') ++b;\n                    else if(s[idx]==')') --b;\n                    ++idx;\n                }\n\n                val.pb(E(s.substr(st,idx-1-st)));\n            }\n            else\n            {\n                int st = idx;\n                while('0'<=s[idx] && s[idx]<='9') ++idx;\n                val.pb(atoll(s.substr(st,idx-st).c_str()));\n            }\n        }\n    }\n\n    rep(i,3)\n    {\n        vector<ll> tv;\n        vector<char> to;\n\n        tv.pb(val[0]);\n        rep(j,op.size())\n        {\n            char c = op[j];\n            if(pr(c)==i)\n            {\n                int TV = tv.size();\n                if(c=='+') tv[TV-1] = tv[TV-1]+val[j+1];\n                if(c=='-') tv[TV-1] = tv[TV-1]-val[j+1];\n                if(c=='*') tv[TV-1] = tv[TV-1]*val[j+1];\n            }\n            else\n            {\n                to.pb(c);\n                tv.pb(val[j+1]);\n            }\n        }\n\n        val = tv;\n        op = to;\n    }\n\n    return val[0];\n}\n\nint main()\n{\n    string s;\n    cin >>s;\n    ll ans = -LLONG_MAX;\n    for(xx=0; xx<3; ++xx)for(yy=0; yy<3; ++yy)for(zz=0; zz<3; ++zz) ans = max(ans,E(s));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr char OP[] = {'+', '-', '*'};\nint p[] = {0, 0, 0};\nll Plus(const ll a, const ll b) { return a + b; }\nll Minus(const ll a, const ll b) { return a - b; }\nll Prod(const ll a, const ll b) { return a * b; }\nusing Func = ll (*)(const ll, const ll);\nFunc f[] = {Plus, Minus, Prod};\nstring S;\nint pos;\n\nll expr();\nll number()\n{\n    ll ans = 0;\n    for (; pos < S.size() and isdigit(S[pos]); pos++) { ans = ans * 10LL + S[pos] - '0'; }\n    return ans;\n}\nll atom()\n{\n    const char c = S[pos];\n    if (c == '(') {\n        pos++;\n        const ll sub = expr();\n        return pos++, sub;\n    } else {\n        return number();\n    }\n}\nll factor()\n{\n    ll ans = atom();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 2) {\n                pos++;\n                const ll sub = atom();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nll term()\n{\n    ll ans = factor();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 1) {\n                pos++;\n                const ll sub = factor();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nll expr()\n{\n    ll ans = term();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 0) {\n                pos++;\n                const ll sub = term();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nint main()\n{\n    cin >> S;\n    ll ans = -(1LL << 60);\n    for (p[0] = 0; p[0] < 3; p[0]++) {\n        for (p[1] = 0; p[1] < 3; p[1]++) {\n            for (p[2] = 0; p[2] < 3; p[2]++) {\n                pos = 0;\n                const ll sub = expr();\n                ans = max(ans, sub);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\nll number(State &begin) {\n    ll ret = 0;\n    while ('0' <= *begin and *begin <= '9') {\n        ret *= 10;\n        ret += *begin - '0';\n        ++begin;\n    }\n    return ret;\n}\n\nll parse(State &begin, map<char,int>& pri, int p);\n\nll factor(State &begin, map<char,int>& pri) {\n    if (*begin == '(') {\n        ++begin;\n        ll ret = parse(begin, pri, 3);\n        assert(*begin == ')');\n        ++begin;\n        return ret;\n    }\n    return number(begin);\n}\n\nll parse(State &begin, map<char,int>& pri, int p) {\n    if (p == 0) {\n        return factor(begin, pri);\n    }\n    ll ret = parse(begin, pri, p-1);\n    while (pri[*begin] == p) {\n        char op = *begin; ++begin;\n        if (op == '+') {\n            ret += parse(begin, pri, p-1);\n        }\n        if (op == '-') {\n            ret -= parse(begin, pri, p-1);\n        }\n        if (op == '*') {\n            ret *= parse(begin, pri, p-1);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    string s; cin >> s;\n\n    ll ans = numeric_limits<ll>::min();\n    FOR(a, 1, 4) {\n        FOR(b, 1, 4) {\n            FOR(c, 1, 4) {\n                map<char,int> pri;\n                pri['+'] = a;\n                pri['-'] = b;\n                pri['*'] = c;\n                State begin = s.begin();\n                chmax(ans, parse(begin, pri, 3));\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n#include <limits>\n\nint64_t expr(int &pos);\nint64_t term1(int &pos);\nint64_t term2(int &pos);\nint64_t term3(int &pos);\nint64_t number(int &pos);\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nstring s;\nset<char> op1, op2, op3; // 優先度 op1 < op2 < op3\n\nvoid debug(int pos) {\n  cerr << \"read string: \" << s.substr(0, pos) << endl;\n  cerr << \"s[pos] = '\" << s[pos] << \"'\" << endl;\n}\n\nint64_t expr(int &pos) {\n  // debug(pos);\n  auto res = term1(pos);\n  // debug(pos);\n  while (pos < s.size() and op1.count(s[pos])) {\n    auto op = s[pos++];\n    if (op == '+') {\n      res += term1(pos);\n    } else if(op == '-') {\n      res -= term1(pos);\n    } else {\n      res *= term1(pos);\n    }\n  }\n  return res;\n}\n\nint64_t term1(int &pos) {\n  auto res = term2(pos);\n  while (pos < s.size() and op2.count(s[pos])) {\n    auto op = s[pos++];\n    if (op == '+') {\n      res += term2(pos);\n    } else if(op == '-') {\n      res -= term2(pos);\n    } else {\n      res *= term2(pos);\n    }\n  }\n  return res;\n}\n\nint64_t term2(int &pos) {\n  auto res = term3(pos);\n  while (pos < s.size() and op3.count(s[pos])) {\n    auto op = s[pos++];\n    if (op == '+') {\n      res += term3(pos);\n    } else if(op == '-') {\n      res -= term3(pos);\n    } else {\n      res *= term3(pos);\n    }\n  }\n  return res;\n}\n\nbool is_digit(char ch) {\n  return '0' <= ch and ch <= '9';\n}\n\nint64_t term3(int &pos) {\n  if (is_digit(s[pos])) {\n    return number(pos);\n  }\n  assert(s[pos++] == '(');\n  auto res = expr(pos);\n  assert(s[pos++] == ')');\n  return res;\n}\n\nint64_t number(int &pos) {\n  int64_t res = 0;\n  while (pos < s.size() and is_digit(s[pos])) {\n    res = res * 10 + (s[pos++] - '0');\n  }\n  return res;\n}\n\nint main() {\n  cin >> s;\n  vector<char> ops = {'+', '-', '*'};\n  int64_t ans = numeric_limits<int64_t>::min();\n  rep(b1, 1 << 3) {\n    if (b1 == 0) continue;\n    rep(b2, 1 << 3) {\n      if (b1 != (1 << 3) - 1 and b2 == 0) continue;\n      if (b1 & b2) continue;\n      rep(b3, 1 << 3) {\n        if (b1 & b3) continue;\n        if (b2 & b3) continue;\n        if ((b1 | b2 | b3) != (1 << 3) - 1) continue;\n        op1.clear();\n        op2.clear();\n        op3.clear();\n        rep(i, 3) {\n          if (b1 >> i & 1) op1.insert(ops[i]);\n          if (b2 >> i & 1) op2.insert(ops[i]);\n          if (b3 >> i & 1) op3.insert(ops[i]);\n        }\n        // for (auto it: op1) cerr << it << \",\"; cerr << \"|\";\n        // for (auto it: op2) cerr << it << \",\"; cerr << \"|\";\n        // for (auto it: op3) cerr << it << \",\";\n        // cerr << endl;\n        // <expr> ::= <term1> [('+'|'-'|'*') <term1>]*\n        // <term1> ::= <term2> [('+'|'-'|'*') <term2>]*\n        // <term2> ::= <term3> [('+'|'-'|'*') <term3>]*\n        // <term3> ::= <number> | '(' <expr> ')'\n        // <number> ::= 123 など\n        int pos = 0;\n        auto res = expr(pos);\n        // cerr << res << endl;\n        ans = max(ans, res);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\n// string??????long long int????????????\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            int in = 1;\n            int out = 0;\n                //cout <<\"START = \"<<  str[j] << endl;\n            while (in != out) {\n                //cout << str[j] << endl;\n                j++;\n                if (str[j] == '(') {\n                    in++;\n                } else if (str[j] == ')') {\n                    out++;\n                }\n            }\n            long long int end = j;\n            //cout << start << \" \" << end << endl;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            //cout << \"ERROR = \" << str[j] << endl;\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n    long long int max_res = -1e09;\n\n    for (long long int i = 0; i < 13; i++) {\n        //ans??¨max_res???????????????\n        long long int ans = act(str, i);\n        //cout << \"I = \" << i << endl;\n        //cout << \"ANS = \" << ans << endl;\n        if (ans > max_res) {\n            max_res = ans;\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst vi add = {1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 3};\nconst vi sub = {1, 1, 2, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2};\nconst vi mul = {1, 1, 1, 2, 1, 2, 2, 3, 2, 3, 1, 2, 1};\n\nstring formula;\n\nll parse(int b, int e, int ord){\n    vector<ll> v;\n    vector<char> op;\n\n    range(i, b, e){\n        if(formula.at(i) == '('){\n            int next_b = i + 1, cnt = 1;\n            while(cnt){\n                if(formula[++i] == '(') cnt++;\n                else if(formula[i] == ')') cnt--;\n            }\n            v.pb(parse(next_b, i, ord));\n        }\n        else if(isdigit(formula.at(i))){\n            ll value = 0;\n            while(i < formula.size() && isdigit(formula.at(i))){\n                value = 10 * value + formula.at(i++) - '0';\n            }\n            v.pb(value);\n\n            i--;\n        }\n        else{\n            op.pb(formula.at(i));\n        }\n    }\n  \n    if(v.size() == 0) return 0;\n\n    range(i, 1, 4){\n        rep(j, op.size()){\n            bool operated = false;\n\n            if(op[j] == '+' && add[ord] == i){\n                v[j] = v[j] + v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '-' && sub[ord] == i){\n                v[j] = v[j] - v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '*' && mul[ord] == i){\n                v[j] = v[j] * v[j + 1];\n                operated = true;\n            }\n\n            if(operated){\n                v.erase(v.begin() + j + 1);\n                op.erase(op.begin() + j);\n                j--;\n            }\n        }\n    }\n\n    return v[0];\n}\n\nint main(void){\n    for(; cin >> formula;){\n        ll res = -INF;\n\n        rep(i, add.size()){\n            res = max(res, parse(0, formula.size(), i));\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2613&lang=jp\ntypedef long long ll;\nusing namespace std;\n#define LINF 1LL<<63;\nll solve(string expr, map<char, ll>& op);\nll check(int& i, string& expr);\n\nll solve(string expr, map<char, ll>& op) {\n\n\t/* <expr> <op> <expr> ??? ( <expr> <op> <expr> )*/\n\tfor (int p = 1; p <= 3;p++) {\n\t\tfor (int i = 0; i < (int)expr.length();i++) {\n\t\t\tif (expr[i] >= '0' && expr[i] <= '9')continue;\n\t\t\tif (op[expr[i]] != p) continue;\n\n\t\t\tint parentheses = 0;\n\t\t\tfor (int left = i - 1; left >= 0; left--) {\n\t\t\t\tif (left == 0) { expr = \"(\" + expr; i++; break; }\n\t\t\t\tif (expr[left] >= '0' && expr[left] <= '9')continue;\n\t\t\t\tif (expr[left] == ')') { parentheses++; }\n\t\t\t\tif (expr[left] == '(') { parentheses--; }\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + left + 1, '('); i++; break;\n\t\t\t}\n\t\t\tparentheses = 0;\n\t\t\tfor (int right = i + 1; right < expr.length();right++) {\n\t\t\t\tif (right == expr.length() - 1) { expr = expr + \")\"; break; }\n\t\t\t\tif (expr[right] >= '0' && expr[right] <= '9')continue;\n\t\t\t\tif (expr[right] == '(') { parentheses++;}\n\t\t\t\tif (expr[right] == ')') { parentheses--;}\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + right, ')'); break;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << op['+'] << \" \" << op['-'] << \" \" << op['*'] << endl;\n\t//cout << expr << endl;\n\tint i = 0;\n\tll ret = check(i, expr);\n\t//cout << ret << endl;\n\treturn ret;\n}\n\nll check(int& i, string& expr) {\n\tll l_expr, r_expr;\n\tif (expr[i] == '(') {\n\t\t/* \"( ~ )\" op ~ */\n\t\ti++;\n\t\tl_expr = check(i, expr);\n\t}\n\telse {\n\t\t/* \"number\" op ~ */\n\t\tl_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tl_expr = l_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\t/* (expr) or (number) */\n\tchar option;\n\tif (i == expr.length() || expr[i] == ')') { i++; return l_expr; }\n\telse {\n\t\toption = expr[i];\n\t\ti++;\n\t}\n\n\tif (expr[i] == '(') {\n\t\t/* ~ op \"( ~ )\"*/\n\t\ti++;\n\t\tr_expr = check(i, expr);\n\t}\n\telse {\n\t\t/* ~ op \"number\" */\n\t\tr_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tr_expr = r_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\tif (expr[i] == ')') {\n\t\ti++;\n\t\tif (option == '+') return l_expr + r_expr;\n\t\tif (option == '-') return l_expr - r_expr;\n\t\tif (option == '*') return l_expr * r_expr;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring expr; cin >> expr;\n\tmap<char, ll> op; op['('] = op[')'] = 0;\n\n\tll ans = -LINF;\n\tfor (int i = 1; i <= 3;i++) {\n\t\tfor (int j = 1; j <= 3;j++) {\n\t\t\tfor (int k = 1; k <= 3;k++) {\n\t\t\t\tif (i != 1 && j != 1 && k != 1) continue;\n\t\t\t\tint x = 0;\n\t\t\t\top['+'] = i; op['-'] = j; op['*'] = k;\n\t\t\t\tans = max(ans, solve(expr, op));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nmap<char, ll> pri;\nstring op = \"+-*\";\nstring s;\nll pos = 0;\nbool end() {\n    return pos == s.size();\n}\nvoid read_char(char c) {\n    assert(!end() && s[pos] == c);\n    ++pos;\n}\nll parse(ll);\nll number() {\n    if (s[pos] == '(') {\n        read_char('(');\n        ll res = parse(0);\n        read_char(')');\n        return res;\n    }\n    else {\n        string res = \"\";\n        while ( !end() && isdigit(s[pos]) ) {\n            res += s[pos++];\n        }\n        return stoll(res);\n    }\n}\nll parse(ll oid) {\n    if (oid == op.size()) return number();\n    ll res = parse(oid+1);\n    while ( !end() && pri.count(s[pos]) > 0 && pri[s[pos]] == oid ) {\n        char op = s[pos];\n        read_char(op);\n        ll right = parse(oid+1);\n        switch (op) {\n            case '*': res *= right; break;\n            case '+': res += right; break;\n            case '-': res -= right; break;\n        }\n    }\n    return res;\n}\nll parse() {\n    pos = 0;\n    return parse(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    ll ans = -linf;\n    rep(a, 3) rep(b, 3) rep(c, 3) {\n        vector<ll> v{a, b, c};\n        rep(i, 3) pri[op[i]] = v[i];\n        chmax(ans, parse());\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\nint c[4];\n\nll expression(State &begin);\nll number(State &begin);\nll factor(State &begin);\nll term1(State &begin);\nll term2(State &begin);\n\n\nll number(State &begin){\n\tll ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nll term2(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]==2){\n\t\t\tbegin++;\n\t\t\tret+=number(begin);\n\t\t}else if(*begin=='-' && c[1]==2){\n\t\t\tbegin++;\n\t\t\tret-=number(begin);\n\t\t}else if(*begin=='*' && c[2]==2){\n\t\t\tbegin++;\n\t\t\tret*=number(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll term1(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]>=1){\n\t\t\tbegin++;\n\t\t\tret+=term2(begin);\n\t\t}else if(*begin=='-' && c[1]>=1){\n\t\t\tbegin++;\n\t\t\tret-=term2(begin);\n\t\t}else if(*begin=='*' && c[2]>=1){\n\t\t\tbegin++;\n\t\t\tret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tll ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else number(begin);\n}\n\nll expression(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tif(c[0]==0)ret+=term1(begin);\n\t\t\tif(c[0]>=1)ret+=term2(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(c[1]==0)ret-=term1(begin);\n\t\t\tif(c[1]>=1)ret-=term2(begin);\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tif(c[2]==0)ret*=term1(begin);\n\t\t\tif(c[2]>=1)ret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tll res=0;\n\tfor(int i=0;i<3;i++){\n\t\tc[0]=i;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tc[1]=j;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tc[2]=k;\n\t\t\t\tState begin=str.begin();\n\t\t\t\tll re=expression(begin);\n\t\t\t\tif(i+j+k==0)res=re;\n\t\t\t\telse res=max(res,re);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = (1<<31);\nconst ll LLINF = (1LL<<63);\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nvector<char> ope[3];\nvector<int> v;\nint first, second, third;\n\nll firstParse(State &);\nll secondParse(State &);\nll thirdParse(State &);\nll number(State &);\nll factor(State &);\n\n// ??°??????????????????????????????????????°????????????\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n      ret = ret*10 + (*begin - '0');\n      begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++; // '('????£???°??????\n    ll ret;\n    if(v.size()==3) ret = thirdParse(begin);\n    else if(v.size()==2) ret = secondParse(begin);\n    else if(v.size()==1) ret = firstParse(begin);\n    begin++; // ')'????£???°??????\n    return ret;\n  } else {\n      return number(begin);\n  }\n  return -1;\n}\n\n//?¬¬?????????expression\nll firstParse(State &begin){\n  ll ret = factor(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[first].size()){\n      if (*begin == ope[first][i]) {\n        flag = true;\n        begin++;\n        if(ope[first][i]=='+') ret += factor(begin);\n        else if(ope[first][i]=='-') ret -= factor(begin);\n        else if(ope[first][i]=='*') ret *= factor(begin);\n        break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll secondParse(State &begin) {\n  ll ret = firstParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[second].size()){\n      if (*begin == ope[second][i]) {\n          flag = true;\n          begin++;\n          if(ope[second][i]=='+') ret += firstParse(begin);\n          else if(ope[second][i]=='-') ret -= firstParse(begin);\n          else if(ope[second][i]=='*') ret *= firstParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll thirdParse(State &begin) {\n  ll ret = secondParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[third].size()){\n      if (*begin == ope[third][i]) {\n          flag = true;\n          begin++;\n          if(ope[third][i]=='+') ret += secondParse(begin);\n          else if(ope[third][i]=='-') ret -= secondParse(begin);\n          else if(ope[third][i]=='*') ret *= secondParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\nint main() {\n  string s;\n  cin>>s;\n  State start = s.begin();\n  ll ans = (-1)*LLINF;\n  /*??°???????°?????????????????????????????????????*/\n  REP(i,0,3){\n    REP(j,0,3){\n      REP(k,0,3){\n\n        REP(l,0,3) ope[l].clear();\n        ope[i].push_back('+');\n        ope[j].push_back('-');\n        ope[k].push_back('*');\n        v.clear();\n        v.push_back(i); v.push_back(j); v.push_back(k);\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        ll tmp;\n        State start = s.begin();\n\n        if(v.size() == 3){\n          first = v[0]; second = v[1]; third = v[2];\n          tmp = thirdParse(start);\n        }else if(v.size() == 2){\n          first = v[0]; second = v[1];\n          tmp = secondParse(start);\n        }else{\n          first = v[0];\n          tmp = firstParse(start);\n        }\n        ans = max(ans, tmp);\n\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nlong long number(State&);\nlong long factor(State&,vector<long long>);\nlong long expr3(State&,long long,vector<long long>);\nlong long expr2(State&,long long,vector<long long>);\nlong long expr1(State&,long long,vector<long long>);\n\nvector<vector<long long>> v;\n\n// ??°??????????????????????????????????????°????????????\nlong long number(State &begin) {\n    long long ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nlong long factor(State &begin, vector<long long> v) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        long long ret = expr1(begin,0,v);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\nlong long expr3(State &begin, long long i, vector<long long> v) {\n    long long ret = factor(begin,v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += factor(begin,v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= factor(begin,v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= factor(begin,v);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nlong long expr2(State &begin, long long i, vector<long long> v) {\n    long long ret = expr3(begin, 2, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += expr3(begin, 2, v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= expr3(begin, 2, v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= expr3(begin, 2, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\nlong long expr1(State &begin, long long i, vector<long long> v) {\n    long long ret = expr2(begin, 1, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += expr2(begin, 1, v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= expr2(begin, 1, v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= expr2(begin, 1, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\n\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    vector<long long> num = {1,2,4};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,3,4};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,5,2};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,6,1};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,0,7};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n\n    string s;\n    cin >> s;\n\n    long long ans = -LONG_MAX;\n    rep(i,v.size()){\n        State tmp = s.begin();\n        ans = max(ans, expr1(tmp, 0, v[i]));\n        assert(tmp == s.end());\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF (1LL << 60);\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nbool op_pri[3][256];\nint p;\n\nll calc(ll n1, char op, ll n2) {\n  switch(op) {\n    case '*': return n1 * n2;\n    case '+': return n1 + n2;\n    case '-': return n1 - n2;\n  }\n  return 0;\n}\n\nll number() {\n  ll ret = 0;\n  while(p < S.size() && '0' <= S[p] && S[p] <= '9') ret = ret * 10 + (S[p++] - '0');\n  return ret;\n}\n\nll expr(int level) {\n  ll ret;\n  char op;\n  if(level < 3) {\n    ret = expr(level + 1);\n    while(p < S.size() && op_pri[level][S[p]]) {\n      op = S[p++];\n      ret = calc(ret, op, expr(level + 1));\n    }\n  } else {\n    if(S[p] == '(') {\n      p++;\n      ret = expr(0);\n      p++;\n    } else {\n      ret = number();\n    }\n  }\n  return ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  string pri = \"*+-||\";\n  ll ans = -INF;\n  ll ret;\n  do {\n    REP(i, 0, 3) REP(j, 0, 256) op_pri[i][j] = false;\n    int k = 0;\n    bool f = true;\n    int cnt = 0;\n    REP(i, 0, pri.size()) {\n      if(pri[i] != '|') {\n        op_pri[2 - k][pri[i]] = true;\n        cnt++;\n      } else {\n        k++;\n      }\n    }\n\n    p = 0;\n    ret = expr(0);\n    ans = max(ans, ret);\n  } while(next_permutation(pri.begin(), pri.end()));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;s[(int)s.size()]='(';\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <list>\n#include <string>\n\nusing namespace std;\n\ntypedef long long BigInt;\n\nclass Solver {\n    private:\n        enum OP {PLUS, MINUS, TIMES};\n        typedef list<BigInt> LI;\n        typedef list<OP> LO;\n        BigInt eval(int p[3], size_t *cur) {\n            static const char forms[] = \"+-*\";\n            LI nums;\n            LO ops;\n            while (*cur < expr.length() && expr[*cur] != ')') {\n                if (expr[*cur] == '(') {\n                    ++*cur;\n                    nums.push_back(eval(p, cur));\n                } else if (isdigit(expr[*cur])) {\n                    int x = expr[*cur] - '0';\n                    while (isdigit(expr[*cur + 1])) {\n                        x = 10 * x + (expr[*cur + 1] - '0');\n                        ++*cur;\n                    }\n                    nums.push_back(x);\n                } else {\n                    for (int i = 0; i < 3; ++i) {\n                        if (expr[*cur] == forms[i]) {\n                            ops.push_back(OP(i));\n                            break;\n                        }\n                    }\n                }\n                ++*cur;\n            }\n            for (int pi = 0; pi < 3; ++pi) {\n                LI::iterator ni = nums.begin();\n                LO::iterator oi = ops.begin();\n                while (oi != ops.end()) {\n                    if (p[*oi] == pi) {\n                        LI::iterator ni2 = ni;\n                        LO::iterator oi2 = oi;\n                        ++ni2;\n                        ++oi2;\n                        if (*oi == PLUS) {\n                            *ni = *ni + *ni2;\n                        } else if (*oi == MINUS) {\n                            *ni = *ni - *ni2;\n                        } else if (*oi == TIMES) {\n                            *ni = *ni * *ni2;\n                        }\n                        nums.erase(ni2);\n                        ops.erase(oi);\n                        oi = oi2;\n                    } else {\n                        ++ni;\n                        ++oi;\n                    }\n                }\n            }\n            return *nums.begin();\n        }\n    public:\n        string expr;\n        BigInt solve() {\n            int p[3];\n            bool is_first = true;\n            BigInt retval, x;\n            for (int i = 0; i < 3; ++i) {\n                p[PLUS] = i;\n                for (int j = 0; j < 3; ++j) {\n                    p[MINUS] = j;\n                    for (int k = 0; k < 3; ++k) {\n                        size_t cur = 0;\n                        p[TIMES] = k;\n                        x = eval(p, &cur);\n                        if (is_first) {\n                            retval = x;\n                            is_first = false;\n                        } else {\n                            retval = max(retval, x);\n                        }\n                    }\n                }\n            }\n            return retval;\n        }\n};\n\nint main() {\n    Solver s;\n    cin >> s.expr;\n    cout << s.solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = -(1LL << 62);\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int opst[27][3] = {\n\t{0,0,0},\n\t{0,0,1},\n\t{ 0,0,2 },\n\t{ 0,1,0 },\n\t{ 0,1,1 },\n\t{ 0,1,2 },\n\t{ 0,2,0 },\n\t{ 0,2,1 },\n\t{ 0,2,2 },\n\t{ 1,0,0 },\n\t{ 1,0,1 },\n\t{ 1,0,2 },\n\t{ 1,1,0 },\n\t{ 1,1,1 },\n\t{ 1,1,2 },\n\t{ 1,2,0 },\n\t{ 1,2,1 },\n\t{ 1,2,2 },\n\t{ 2,0,0 },\n\t{ 2,0,1 },\n\t{ 2,0,2 },\n\t{ 2,1,0 },\n\t{ 2,1,1 },\n\t{ 2,1,2 },\n\t{ 2,2,0 },\n\t{ 2,2,1 },\n\t{ 2,2,2 },\n};\n\nll calc(vector<ll> num, vector<int> op, int pri) {\n\tREP(n,3)\n\tREP(i,op.size()) {\n\t\tif (opst[pri][op[i]] == n) {\n\t\t\tif (op[i] == 0) {\n\t\t\t\tnum[i] += num[i + 1];\n\t\t\t}\n\t\t\telse if (op[i] == 1) {\n\t\t\t\tnum[i] -= num[i + 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[i] *= num[i + 1];\n\t\t\t}\n\t\t\tFOR(j, i + 1, num.size() - 1)\n\t\t\t\tnum[j] = num[j + 1];\n\t\t\tnum.resize(num.size() - 1);\n\t\t\tFOR(j, i, op.size() - 1)\n\t\t\t\top[j] = op[j + 1];\n\t\t\top.resize(op.size() - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn num[0];\n}\nll saiki(string s, int &idx, int pri) {\n\tvector<ll> num;\n\tvector<int> op;\n\twhile ((size_t)(idx) < s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tnum.push_back(saiki(s, idx, pri));\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn calc(num, op, pri);\n\t\t}\n\t\tif (isdigit(s[idx])) {\n\t\t\tll num2 = 0;\n\t\t\twhile (idx < s.length() && isdigit(s[idx])) {\n\t\t\t\tnum2 *= 10;\n\t\t\t\tnum2 += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tnum.push_back(num2);\n\t\t\tcontinue;\n\t\t}\n\t\tint opn=0;\n\t\tif (s[idx] == '-')\n\t\t\topn = 1;\n\t\tif (s[idx] == '*')\n\t\t\topn = 2;\n\t\top.push_back(opn);\n\t\tidx++;\n\t}\n\treturn calc(num, op, pri);\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tll ma = -(1 << 63);\n\tREP(i, 27) {\n\t\tint idx = 0;\n\t\tma = max(ma,saiki(s, idx, i));\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s;\nstring t=\"+-*\";\nint p[3];\nint id;\nlong f(int i)\n{\n\tlong now;\n\tif(i==3)\n\t{\n\t\tif(s[id]=='(')\n\t\t{\n\t\t\tid++;\n\t\t\tnow=f(0);\n\t\t\tid++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow=0;\n\t\t\twhile(s[id]>='0')\n\t\t\t{\n\t\t\t\tnow=now*10+s[id]-'0';\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tnow=f(i+1);\n\twhile((p[0]==i&&s[id]==t[0])||(p[1]==i&&s[id]==t[1])||(p[2]==i&&s[id]==t[2]))\n\t{\n\t\tchar op=s[id];\n\t\tid++;\n\t\tlong next=f(i+1);\n\t\tif(op=='+')now+=next;\n\t\telse if(op=='-')now-=next;\n\t\telse now*=next;\n\t}\n\treturn now;\n}\nmain()\n{\n\tcin>>s;\n\tsort(t.begin(),t.end());\n\tlong ans=f(0);\n\tfor(p[0]=0;p[0]<3;p[0]++)\n\t{\n\t\tfor(p[1]=0;p[1]<3;p[1]++)\n\t\t{\n\t\t\tfor(p[2]=0;p[2]<3;p[2]++)\n\t\t\t{\n\t\t\t\tid=0;\n\t\t\t\tans=max(ans,f(0));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nchar buf[222];\nint n;\nint cnt;\nvector<char> op;\nbool counter(char c){\n  if( cnt >= n ) return false;\n  if( buf[cnt] == c ) { cnt++; return true; }\n  return false;\n}\n\nll number(){\n  ll num = 0;\n  while( '0' <= buf[cnt] && buf[cnt] <= '9' ){\n    num *=10;\n    num += buf[cnt++]-'0';\n  }\n  return num;\n}\n\nll calc( ll a, ll b, char o ){\n  if( o == '+' ) return a + b;\n  if( o == '-' ) return a - b;\n  return a * b;\n}\n\nll op1();\n\nll kakko(){\n  if( counter('(') ){\n    ll a = op1();\n    counter(')');\n    return a;\n  }\n  return number();\n}\n\nll op3(){\n  ll a = kakko();\n  while( counter( op[2] ) ) {\n    ll b = kakko();\n    a = calc( a, b, op[2] );\n  }\n  return a;\n}\n\nll op2(){\n  ll a = op3();\n  while( counter( op[1] ) ) {\n    ll b = op3();\n    a = calc( a, b, op[1] );\n  }\n  return a;\n}\n\nll op1(){\n  ll a = op2();\n  while( counter( op[0] ) ) {\n    ll b = op2();\n    a = calc( a, b, op[0] );   \n  }\n  return a;\n}\n\nint main(){\n  cin >> buf;\n  n = strlen(buf);\n  op.push_back( '+' );\n  op.push_back( '-' );\n  op.push_back( '*' );\n  sort(op.begin(),op.end());\n  ll res = -LLONG_MAX;\n  do {\n    cnt = 0;\n    res = max( res, op1() );\n  } while( next_permutation( op.begin(), op.end() ) );\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFFFFFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1&&a[1]==2&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1&&a[1]==3&&a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2&&a[1]==1&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2&&a[1]==3&&a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3&&a[1]==1&&a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3&&a[1]==2&&a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  cout << \"warning \" << t << endl;\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstring S;\nint N;\n\nLL C(int& i, VS& order);\nLL D(int& i, VS& order);\nLL E(int& i, VS& order);\nLL F(int& i, VS& order);\n\nLL C(int& i, VS& order){\n  LL res = D(i, order);\n  if(i < N && order[0].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = C(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL D(int& i, VS& order){\n  LL res = E(i, order);\n  if(i < N && order[1].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = D(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL E(int& i, VS& order){\n  LL res = F(i, order);\n  if(i < N && order[2].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = E(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\n\nLL F(int& i, VS& order){\n  LL res = 0;\n  if(S[i] == '('){\n\t++i;\n\tres = C(i, order);\n\t++i;\n  }\n  else{\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i]-'0');\n\t  ++i;\n\t}\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n  LL ans = -1e18;\n\n  REP(i1,3){\n\tREP(i2,3){\n\t  REP(i3,3){\n\t\t//if(i1==i2||i2==i3||i1==i3) continue;\n\t\tint i = 0;\n\t\tVS ops(3);\n\t\tops[i1] += \"+\";\n\t\tops[i2] += \"-\";\n\t\tops[i3] += \"*\";\n\t\tmaxi(ans, C(i,ops));\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<59)\n\n\nvector<string> vs;\n\npii dp[300][300];\n\npii dfs(int l, int r){\n    if(r-l==1)return pii(stol(vs[l]),stol(vs[l]));\n    assert(l<=r);\n    if( dp[l][r] != pii(INF,INF) ){\n        return dp[l][r];\n    }\n    pii ret = pii(-INF,INF);\n    \n    for(int i=l+1;i<r-1;i+=2){\n        string op = vs[i];\n        pii res;\n        if(op==\"+\"){\n            pii res1 = dfs(l,i);\n            pii res2 = dfs(i+1,r);\n            res = pii(res1.first+res2.first, res1.second+res2.second);\n        }else if(op==\"-\"){\n            pii res1 = dfs(l,i);\n            pii res2 = dfs(i+1,r);\n            res = pii(res1.first-res2.second, res1.second-res2.first);\n        }else if(op==\"*\"){\n            pii res1 = dfs(l,i);\n            pii res2 = dfs(i+1,r);\n            res = pii(res1.first*res2.first, res1.second*res2.second);\n        }\n        ret.first = max<ll>(ret.first ,res.first );\n        ret.second= min<ll>(ret.second,res.second);\n    }\n    \n    return dp[l][r] = ret;\n}\n\nsigned main(){\n    rep(i,300)rep(j,300)dp[i][j] = pii(INF,INF);\n    string s;\n    cin>>s;\n    \n    string buf=\"\";\n    rep(i,s.size()){\n        if(s[i]=='-' || s[i]=='+' || s[i]=='*'){\n            vs.pb(buf);\n            vs.pb(string(1,s[i]));\n            buf=\"\";\n        }else{\n            buf+=string(1,s[i]);\n        }\n    }\n    vs.pb(buf);\n    \n    cout<<dfs(0,s.size()).first<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = (1<<31)-1;\nconst ll LLINF = (1LL<<63)-1;\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nvector<char> ope[3];\nvector<int> v;\nint first, second, third;\n\nll firstParse(State &);\nll secondParse(State &);\nll thirdParse(State &);\nll number(State &);\nll factor(State &);\n\n// ??°??????????????????????????????????????°????????????\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n      ret = ret*10 + (*begin - '0');\n      begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++; // '('????£???°??????\n    ll ret;\n    if(v.size()==3) ret = thirdParse(begin);\n    else if(v.size()==2) ret = secondParse(begin);\n    else if(v.size()==1) ret = firstParse(begin);\n    begin++; // ')'????£???°??????\n    return ret;\n  } else {\n      return number(begin);\n  }\n  return -1;\n}\n\n//?¬¬?????????expression\nll firstParse(State &begin){\n  ll ret = factor(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[first].size()){\n      if (*begin == ope[first][i]) {\n        flag = true;\n        begin++;\n        if(ope[first][i]=='+') ret += factor(begin);\n        else if(ope[first][i]=='-') ret -= factor(begin);\n        else if(ope[first][i]=='*') ret *= factor(begin);\n        break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll secondParse(State &begin) {\n  ll ret = firstParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[second].size()){\n      if (*begin == ope[second][i]) {\n          flag = true;\n          begin++;\n          if(ope[second][i]=='+') ret += firstParse(begin);\n          else if(ope[second][i]=='-') ret -= firstParse(begin);\n          else if(ope[second][i]=='*') ret *= firstParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll thirdParse(State &begin) {\n  ll ret = secondParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[third].size()){\n      if (*begin == ope[third][i]) {\n          flag = true;\n          begin++;\n          if(ope[third][i]=='+') ret += secondParse(begin);\n          else if(ope[third][i]=='-') ret -= secondParse(begin);\n          else if(ope[third][i]=='*') ret *= secondParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\nint main() {\n  string s;\n  cin>>s;\n  State start = s.begin();\n  ll ans = -LLINF;\n  /*??°???????°?????????????????????????????????????*/\n  REP(i,0,3){\n    REP(j,0,3){\n      REP(k,0,3){\n\n        REP(l,0,3) ope[l].clear();\n        ope[i].push_back('+');\n        ope[j].push_back('-');\n        ope[k].push_back('*');\n        v.clear();\n        v.push_back(i); v.push_back(j); v.push_back(k);\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        ll tmp;\n        State start = s.begin();\n\n        if(v.size() == 3){\n          first = v[0]; second = v[1]; third = v[2];\n          tmp = thirdParse(start);\n        }else if(v.size() == 2){\n          first = v[0]; second = v[1];\n          tmp = secondParse(start);\n        }else{\n          first = v[0];\n          tmp = firstParse(start);\n        }\n        ans = max(ans, tmp);\n\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef function<ll(string&, int&, int, ll&)> OpFunc;\n\nbool op_add(string& s, int& idx, int opidx, ll& n);\nbool op_sub(string& s, int& idx, int opidx, ll& n);\nbool op_mul(string& s, int& idx, int opidx, ll& n);\n\nll expr(string& s, int& idx, int opidx);\n\nint comb1[6][3] = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0},\n};\nint comb2[6][2] = {\n    {3, 2},\n    {2, 3},\n    {4, 1},\n    {1, 4},\n    {5, 0},\n    {0, 5},\n};\n\nvector<vector<OpFunc>> op;\n\nll factor(string& s, int& idx) {\n    ll n = 0;\n    if (s[idx] == '(') {\n        idx++; // (\n        n = expr(s, idx, 0);\n        idx++; // )\n    } else {\n        while (isdigit(s[idx])) {\n            n *= 10;\n            n += s[idx] - '0';\n            idx++;\n        }\n    }\n    return n;\n}\n\nll expr(string& s, int& idx, int opidx) {\n    if (opidx == SZ(op)) {\n        return factor(s, idx);\n    } else {\n        ll n = expr(s, idx, opidx+1);\n        for (; idx < (int)s.length();) {\n            bool ok = false;\n            REP(i, SZ(op[opidx])) {\n                if (op[opidx][i](s, idx, opidx, n)) {\n                    ok = true;\n                }\n            }\n            if (!ok) break;\n        }\n        return n;\n    }\n}\n\nbool op_add(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '+') {\n        idx++;\n        n += expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_sub(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '-') {\n        idx++;\n        n -= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_mul(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '*') {\n        idx++;\n        n *= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    string line;\n    cin >> line;\n    vector<vector<OpFunc>> o;\n    o.push_back({op_add});\n    o.push_back({op_sub});\n    o.push_back({op_mul});\n    o.push_back({op_add, op_sub});\n    o.push_back({op_add, op_mul});\n    o.push_back({op_sub, op_mul});\n\n    vector<vector<vector<OpFunc>>> ops;\n    REP(i, 6) {\n        vector<vector<OpFunc>> v;\n        REP(j, 3) {\n            v.push_back(o[comb1[i][j]]);\n        }\n        ops.push_back(v);\n        v.clear();\n        REP(j, 2) {\n            v.push_back(o[comb2[i][j]]);\n        }\n        ops.push_back(v);\n    }\n    ops.push_back({{op_add, op_sub, op_mul}});\n\n    ll ma = 0;\n    REP(i, SZ(ops)) {\n        op.clear();\n        op = ops[i];\n        int idx = 0;\n        ma = max(ma, expr(line, idx, 0));\n    }\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n\nclass Parser{\npublic:\n  int i;\n  string S;\n  map<char,int> M;\n  const string op = \"+-*\";\n  long long parse(){\n    i = 0;\n    long long ret = expr(-1);\n    return ret;\n  }\n  long long expr(int p){\n    long long ret;\n    if(isdigit(S[i])) ret = number();\n    else{\n      ++i; ret = expr(-1); ++i;\n    }\n    if(i == S.length() || op.find(S[i]) >= S.length())\n      return ret;\n    while(i < S.length() && op.find(S[i]) < S.length() && M[S[i]] > p){\n      long long x;\n      char o;\n      o = S[i];\n      ++i;\n      x = expr(M[o]);\n      if(o == '+') ret += x;\n      if(o == '-') ret -= x;\n      if(o == '*') ret *= x;\n    }\n    return ret;\n  }\n  long long number(){\n    long long ret = 0;\n    while(i < S.length() && isdigit(S[i])){\n      ret *= 10LL;\n      ret += (long long)(S[i] - '0');\n      ++i;\n    }\n    return ret;\n  }\n};\n\nint main(){\n  string S;\n  cin >> S;\n  long long ans = -(1LL<<62) - (1LL<<62);\n  Parser P;\n  P.S = S;\n  for(int i = 0; i < 3; ++i){\n    for(int j = 0; j < 3; ++j){\n      for(int k = 0; k < 3; ++k){\n        P.M['+'] = i;\n        P.M['-'] = j;\n        P.M['*'] = k;\n        ans = max(ans, P.parse());\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cctype>\nusing namespace std;\n \n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \ntypedef string::const_iterator iter;\n \nstring fstOp, sndOp, thdOp;\n \ntypedef long long i64;\n \ni64 fst(iter& p);\ni64 snd(iter& p);\ni64 thd(iter& p);\ni64 factor(iter& p);\ni64 number(iter& p);\n \ni64 fst(iter& p) {\n\t// cerr << \"fst(\" << *p << \")\" << endl;\n\ti64 r = snd(p);\n\twhile(true) {\n\t\tif(*p == '=') break;\n\t\ti64 idx = find(fstOp.begin(), fstOp.end(), *p) - fstOp.begin();\n\t\tif(idx == fstOp.size()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar op = fstOp[idx];\n\t\tp++;\n\t\ti64 res = snd(p);\n\t\tif(op == '+') r += res;\n\t\tif(op == '-') r -= res;\n\t\tif(op == '*') r *= res;\n\t}\n\treturn r;\n}\ni64 snd(iter& p) {\n\t// cerr << \"snd(\" << *p << \")\" << endl;\n\ti64 r = thd(p);\n\twhile(true) {\n\t\ti64 idx = find(sndOp.begin(), sndOp.end(), *p) - sndOp.begin();\n\t\tif(idx == sndOp.size()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar op = sndOp[idx];\n\t\tp++;\n\t\ti64 res = thd(p);\n\t\tif(op == '+') r += res;\n\t\tif(op == '-') r -= res;\n\t\tif(op == '*') r *= res;\n\t}\n\treturn r;\n}\ni64 thd(iter& p) {\n\t// cerr << \"thd(\" << *p << \")\" << endl;\n\ti64 r = factor(p);\n\twhile(true) {\n\t\ti64 idx = find(thdOp.begin(), thdOp.end(), *p) - thdOp.begin();\n\t\tif(idx == thdOp.size()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar op = thdOp[idx];\n\t\tp++;\n\t\ti64 res = factor(p);\n\t\tif(op == '+') r += res;\n\t\tif(op == '-') r -= res;\n\t\tif(op == '*') r *= res;\n\t}\n\treturn r;\n}\n \ni64 factor(iter& p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\ti64 res = fst(p);\n\t\tp++;\n\t\treturn res;\n\t}\n\treturn number(p);\n}\n \ni64 number(iter& p) {\n\ti64 res = 0;\n\twhile(isdigit(*p)) {\n\t\tres *= 10;\n\t\tres += *p - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n \n \nint main() {\n\tstring s; cin >> s;\n\ts += \"=\";\n\titer it;\n \n\ti64 maxValue = 1LL << 63;\n \n\tfstOp = \"+\"; sndOp = \"-\"; thdOp = \"*\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"+\"; sndOp = \"*\"; thdOp = \"-\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"-\"; sndOp = \"+\"; thdOp = \"*\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"-\"; sndOp = \"*\"; thdOp = \"+\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"*\"; sndOp = \"+\"; thdOp = \"-\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"*\"; sndOp = \"-\"; thdOp = \"+\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n \n\tfstOp = \"+-*\"; sndOp = \"\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n \n\tfstOp = \"+\"; sndOp = \"-*\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"-\"; sndOp = \"*+\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"*\"; sndOp = \"+-\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n \n\tfstOp = \"+-\"; sndOp = \"*\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"-*\"; sndOp = \"+\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tfstOp = \"*+\"; sndOp = \"-\"; thdOp = \"\";\n\tit = s.begin();\n\tmaxValue = max(maxValue, fst(it));\n \n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res=getNum(),t;\n  if(S[p]=='(') p++,res=calc(-1),p++;\n  while(ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  \n  ch[0]=ch[')']=-2;\n  ll res=calc(-1);\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,calc(-1));\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long int lint;\n\nmap< char, int > lev;\n\nlint calc(char op, lint a, lint b) {\n\tif (op == '+') return a + b;\n\tif (op == '-') return a - b;\n\treturn a * b;\n}\n\nlint parse(int l, int r, const string& S) {\n\tint open_cnt = 0, close_cnt = 0, nxt_l = -1;\n\tlint num = 0;\n\t\n\tstack< lint > stk_val;\n\tstack< char > stk_op;\n\t\n\tfor_(i,l,r) {\n\t\tif (open_cnt == close_cnt) {\n\t\t\tif (isdigit(S[i])) {\n\t\t\t\tnum = 10 * num + lint(S[i] - '0');\n\t\t\t} else if (S[i] == '(') {\n\t\t\t\t++open_cnt;\n\t\t\t\tnxt_l = i+1;\n\t\t\t} else if (S[i] == '$') {\n\t\t\t\tstk_val.push(num);\n\t\t\t\tnum = 0;\n\t\t\t} else {\n\t\t\t\tchar op = S[i];\n\t\t\t\twhile (!stk_op.empty() && lev[stk_op.top()] >= lev[op]) {\n\t\t\t\t\tchar pre = stk_op.top(); stk_op.pop();\n\t\t\t\t\tlint b = stk_val.top(); stk_val.pop();\n\t\t\t\t\tlint a = stk_val.top(); stk_val.pop();\n\t\t\t\t\tstk_val.push(calc(pre, a, b));\n\t\t\t\t}\n\t\t\t\tstk_op.push(op);\n\t\t\t}\n\t\t} else {\n\t\t\tif (S[i] == '(') ++open_cnt;\n\t\t\tif (S[i] == ')') {\n\t\t\t\t++close_cnt;\n\t\t\t\tif (open_cnt == close_cnt) stk_val.push(parse(nxt_l, i, S));\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!stk_op.empty()) {\n\t\tchar op = stk_op.top(); stk_op.pop();\n\t\tlint b = stk_val.top(); stk_val.pop();\n\t\tlint a = stk_val.top(); stk_val.pop();\n\t\tstk_val.push(calc(op, a, b));\n\t}\n\t\n\treturn stk_val.top();\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tS += '#';\n\t\n\tint m = S.size();\n\tfor_(i,0,m-1) {\n\t\tif (isdigit(S[i]) && !isdigit(S[i+1])) {\n\t\t\tS = S.substr(0,i+1) + \"$\" + S.substr(i+1);\n\t\t\tm = S.size();\n\t\t}\n\t}\n\tS = S.substr(0, m-1);\n\t\n\tlint ans = 1LL << 63;\n\tfor_(i,0,3) for_(j,0,3) for_(k,0,3) {\n\t\tlev['+'] = i;\n\t\tlev['-'] = j;\n\t\tlev['*'] = k;\n\t\tans = max(ans, parse(0, (int)S.size(), S));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=29;\nconst ll INF=1LL<<63;\nint x,y,z;\n\nll expr0(string S,int &i);\nll expr1(string S,int &i);\nll expr2(string S,int &i);\nll factor(string S,int &i);\nll number(string S,int &i);\n\nll expr0(string S,int &i){\n    ll res=0;\n    \n    res=expr1(S,i);\n    \n    while(i<S.size()){\n        if(S[i]=='+'&&x==0){\n            i++;\n            res+=expr1(S,i);\n        }else if(S[i]=='-'&&y==0){\n            i++;\n            res-=expr1(S,i);\n        }else if(S[i]=='*'&&z==0){\n            i++;\n            res*=expr1(S,i);\n        }else break;\n    }\n    \n    return res;\n}\n\nll expr1(string S,int &i){\n    ll res=0;\n    \n    res=expr2(S,i);\n    \n    while(i<S.size()){\n        if(S[i]=='+'&&x==1){\n            i++;\n            res+=expr2(S,i);\n        }else if(S[i]=='-'&&y==1){\n            i++;\n            res-=expr2(S,i);\n        }else if(S[i]=='*'&&z==1){\n            i++;\n            res*=expr2(S,i);\n        }else break;\n    }\n    \n    return res;\n}\n\nll expr2(string S,int &i){\n    ll res=0;\n    \n    res=factor(S,i);\n    \n    while(i<S.size()){\n        if(S[i]=='+'&&x==2){\n            i++;\n            res+=factor(S,i);\n        }else if(S[i]=='-'&&y==2){\n            i++;\n            res-=factor(S,i);\n        }else if(S[i]=='*'&&z==2){\n            i++;\n            res*=factor(S,i);\n        }else break;\n    }\n    \n    return res;\n}\n\nll factor(string S,int &i){\n    ll res=0;\n    if(S[i]=='('){\n        i++;\n        res=expr0(S,i);\n        i++;\n    }else{\n        res=number(S,i);\n    }\n    \n    return res;\n}\n\nll number(string S,int &i){\n    ll res=0;\n    while('0'<=S[i]&&S[i]<='9'){\n        res*=10;\n        res+=S[i]-'0';\n        i++;\n    }\n    return res;\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    ll ans=-LLONG_MAX;\n    \n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                x=i;\n                y=j;\n                z=k;\n                \n                int w=0;\n                ans=max(ans,expr0(S,w));\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nstring s;\nsize_t cur;\n\nll calc(ll a,ll b,char op){\n\tif(op=='+')\n\t\treturn a+b;\n\tif(op=='-')\n\t\treturn a-b;\n\tif(op=='*')\n\t\treturn a*b;\n\treturn 0;\n}\n\nll digit(){\n\treturn s[cur++]-'0';\n}\n\nll number(){\n\tll res=digit();\n\twhile(isdigit(s[cur])) res=res*10+digit();\n\treturn res;\n}\n\nll expr1();\nll expr2();\nll expr3();\nll factor();\n\nll factor(){\n\tll res=0;\n\tif(s[cur]=='('){\n\t\tcur++;\n\t\tres=expr1();\n\t\tcur++;\n\t\treturn res;\n\t}else{\n\t\tres=number();\n\t\treturn res;\n\t}\n}\n\nint op[3];\n\nll expr1(){\n\tll res=expr2();\n\tbool update=true;\n\twhile(cur<n&&update){\n\t\tupdate=false;\n\t\tif(op[0]==0&&s[cur]=='+'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr2();\n\t\t\tres=calc(res,b,'+');\n\t\t}\n\t\tif(op[1]==0&&s[cur]=='-'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr2();\n\t\t\tres=calc(res,b,'-');\n\t\t}\n\t\tif(op[2]==0&&s[cur]=='*'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr2();\n\t\t\tres=calc(res,b,'*');\n\t\t}\n\t\tif(s[cur]==')')\n\t\t\treturn res;\n\t}\n\treturn res;\n}\n\nll expr2(){\n\tll res=expr3();\n\tbool update=true;\n\twhile(cur<n&&update){\n\t\tupdate=false;\n\t\tif(op[0]==1&&s[cur]=='+'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr3();\n\t\t\tres=calc(res,b,'+');\n\t\t}\n\t\tif(op[1]==1&&s[cur]=='-'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr3();\n\t\t\tres=calc(res,b,'-');\n\t\t}\n\t\tif(op[2]==1&&s[cur]=='*'){\n\t\t\tcur++,update=true;\n\t\t\tll b=expr3();\n\t\t\tres=calc(res,b,'*');\n\t\t}\n\t\tif(s[cur]==')')\n\t\t\treturn res;\n\t}\n\treturn res;\n}\n\nll expr3(){\n\tll res=factor();\n\tbool update=true;\n\twhile(cur<n&&update){\n\t\tupdate=false;\n\t\tif(op[0]==2&&s[cur]=='+'){\n\t\t\tcur++,update=true;\n\t\t\tll b=factor();\n\t\t\tres=calc(res,b,'+');\n\t\t}\n\t\tif(op[1]==2&&s[cur]=='-'){\n\t\t\tcur++,update=true;\n\t\t\tll b=factor();\n\t\t\tres=calc(res,b,'-');\n\t\t}\n\t\tif(op[2]==2&&s[cur]=='*'){\n\t\t\tcur++,update=true;\n\t\t\tll b=factor();\n\t\t\tres=calc(res,b,'*');\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(void){\n\tcin >> s;\n\tn=s.size();\n\n\tcur=0;\n\tll ans=expr1();\n\trep(i,3)rep(j,3)rep(k,3){\n\t\top[0]=i,op[1]=j,op[2]=k;\n\t\tcur=0;\n\t\tans=max(ans,expr1());\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF -1LL<<63\n\nstring S;\nchar U[11] = \"0123456789\";\nint junjo[4] = { 0,0,1,1 };\n\nlong long STOI(string V) {\n\tint LEN = V.size();\n\tif (LEN == 0) { return 0; }\n\treturn (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L, int R) {\n\tint K = 0;\n\tvector<int>junjo2[4];\n\tfor (int i = 0; i<4; i++) {\n\t\tjunjo2[junjo[i]].push_back(i);\n\t}\n\tfor (int i = 0; i<4; i++) {\n\t\tif (junjo2[i].size() >= 1) {\n\t\t\tfor (int j = R - 1; j >= L; j--) {\n\t\t\t\tif (S[j] == '(') { K++; }\n\t\t\t\tif (S[j] == ')') { K--; }\n\t\t\t\tfor (int k = 0; k<junjo2[i].size(); k++) {\n\t\t\t\t\tif (junjo2[i][k] == 0) {\n\t\t\t\t\t\tif (S[j] == '+' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) + calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 1) {\n\t\t\t\t\t\tif (S[j] == '-' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) - calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 2) {\n\t\t\t\t\t\tif (S[j] == '*' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j)*calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 3) {\n\t\t\t\t\t\tif (S[j] == '/' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) / calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (S[L] == '(' && S[R - 1] == ')') { return calc(L + 1, R - 1); }\n\treturn STOI(S.substr(L, R - L));\n}\n\n\nint main() {\n\tlong long maxn = INF;\n\tint POW[4] = { 1,4,16,64 };\n\tcin >> S;\n\tS += '=';\n\tfor (int i = 0; i < 256; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tjunjo[j] = (i / POW[j]) % 4;\n\t\t}\n\t\tmaxn = max(maxn, calc(0, S.size() - 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Result{\n    int k;\n    LL val;\n};\nstring s;\nmap<char, int> ops;\nResult expr(int k, int d) {\n    // dump(k);\n    // dump(d);\n    if(d == 3) {\n        if(s[k] == '(') {\n            Result r = expr(k+1, 0);\n            assert(s[r.k++] == ')');\n            return r;\n        } else if(isdigit(s[k])) {\n            LL res = 0;\n            while(k < s.size() && isdigit(s[k])) {\n                res = res * 10 + s[k++] - '0';\n            }\n            return {k, res};\n        } else {\n            assert(false);\n        }\n    } else {\n        Result r = expr(k, d+1);\n        LL val = r.val;\n        k = r.k;\n        while(k < s.size()) {\n            if(!(ops.count(s[k]) && ops[s[k]] == d)) {\n                break;\n            }\n            Result p = expr(k+1, d+1);\n            if(s[k] == '+') {\n                val += p.val;\n            } else if(s[k] == '-') {\n                val -= p.val;\n            } else if(s[k] == '*') {\n                val *= p.val;\n            }\n            k = p.k;\n        }\n        return {k, val};\n    }\n}\nint main(){\n    iostream_init();\n    while(cin >> s) {\n        LL res = LLONG_MIN;\n        REP(a, 3) REP(b, 3) REP(c, 3) {\n            ops['+'] = a;\n            ops['-'] = b;\n            ops['*'] = c;\n            res = max(res, expr(0, 0).val);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct token{\n    bool is_num;\n    int64_t value;\n    token *next;\n};\n\ntoken *tokenize(char *code){\n    token head = {false, 0, nullptr};\n    token *cur = &head;\n    while(*code){\n        if(isdigit(*code)){\n            int64_t val = strtoll(code, &code, 10);\n            cur->next = new token{true, val, nullptr};\n            cur = cur->next;\n            continue;\n        }\n        cur->next = new token{false, *code, nullptr};\n        ++code;\n        cur = cur->next;\n    }\n    return head.next;\n}\n\ntoken *tok;\nconstexpr char ops[] = \"+-*\";\nconstexpr int pri[][3] = {\n    {0, 0, 0},\n    {1, 0, 0},\n    {0, 1, 0},\n    {0, 0, 1},\n    {1, 1, 0},\n    {1, 0, 1},\n    {0, 1, 1},\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0}\n};\nint64_t op(int p, int state);\nint64_t primary(int state){\n    if(tok->is_num){\n        int64_t val = tok->value;\n        tok = tok->next;\n        return val;\n    }\n    assert(tok->is_num == false && tok->value == '(');\n    tok = tok->next;\n    int64_t val = op(2, state);\n    assert(tok->is_num == false && tok->value == ')');\n    tok = tok->next;\n    return val;\n}\nint64_t op(int p, int state){\n    auto sub = [&](int state){\n        if(p == 0) return primary(state);\n        else return op(p-1, state);\n    };\n    auto val = sub(state);\n    while(tok){\n        assert(!tok->is_num);\n        for(int i=0;i<3;++i){\n            if(tok->value == ops[i] && pri[state][i] == p){\n                tok = tok->next;\n                auto v = sub(state);\n                if(i == 0) val += v;\n                if(i == 1) val -= v;\n                if(i == 2) val *= v;\n                goto l_next;\n            }\n        }\n        break;\n        l_next:;\n    }\n    return val;\n}\n\nint main(){\n    char s[201];\n    scanf(\"%s\", s);\n    token *t = tokenize(s);\n    int64_t ans = INT64_MIN;\n    for(int i=0;i<13;++i){\n        tok = t;\n        ans = max(ans, op(2, i));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define int long long\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint expression1(State &begin);\nint expression2(State &begin);\nint expression3(State &begin);\n\nvector<int> priority(3);\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin)-'0';\n    begin++;\n  }\n  // cout<<\"number: \"<<ret<<endl;\n  return ret;\n}\n\nint factor(State &begin){\n  // cout<<\"in factor: \"<<*begin<<endl;\n  int ret;\n  if(*begin=='('){\n    begin++;\n    ret=expression1(begin);\n    begin++;\n  }else{\n    // cout<<\"factor in number\" <<endl;\n    ret=number(begin);\n  }\n  return ret;\n}\n\nint expression3(State &begin){\n  // cout<<\"in expr3: \"<<endl;\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='+'&&priority[2]&(1<<0)){\n      begin++;\n      ret+=factor(begin);\n    }else if(*begin=='-'&&priority[2]&(1<<1)){\n      begin++;\n      ret-=factor(begin);\n    }else if(*begin=='*'&&priority[2]&(1<<2)){\n      begin++;\n      ret*=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression2(State &begin){\n  int ret=expression3(begin);\n  // cout<<\"in expr2: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[1]&(1<<0)){\n      begin++;\n      ret+=expression3(begin);\n    }else if(*begin=='-'&&priority[1]&(1<<1)){\n      begin++;\n      ret-=expression3(begin);\n    }else if(*begin=='*'&&priority[1]&(1<<2)){\n      begin++;\n      ret*=expression3(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression1(State &begin){\n  int ret=expression2(begin);\n  // cout<<\"in expr1: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[0]&(1<<0)){\n      begin++;\n      ret+=expression2(begin);\n    }else if(*begin=='-'&&priority[0]&(1<<1)){\n      begin++;\n      ret-=expression2(begin);\n    }else if(*begin=='*'&&priority[0]&(1<<2)){\n      begin++;\n      ret*=expression2(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  int ans=0;\n  for(int i=0;i<(1<<3);i++){\n    for(int j=0;j<(1<<3);j++){\n      for(int k=0;k<(1<<3);k++){\n\tif((__builtin_popcount(i)+__builtin_popcount(j)+__builtin_popcount(k))!=3)continue;\n\tpriority[0]=i;priority[1]=j;priority[2]=k;\n\tState begin=s.begin();\n\tans=max(ans,expression1(begin));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops;\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    void solve() {\n        int ps[4][3] = {\n            {0, 0, 0},\n            {0, 0, 1},\n            {0, 1, 1},\n            {0, 1, 2}\n        };\n                  \n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = 0;\n        do {\n            for (int i = 0; i < 4; i++) {\n                ops.clear(); ops.resize(3);\n                for (int j = 0; j < 3; j++) {\n                    int l = ps[i][j];\n                    ops[l].push_back(t[j]);\n                }\n                int index = 0;\n                ans = max(ans, parse(s, index, 0));\n            }\n        } while (next_permutation(t.begin(), t.end()));\n        cout << (long long)ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2613.cc: Unordered Operators\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int ON = 3;\n\ntypedef long long ll;\nconst ll LINF = 1LL << 62;\n\n/* typedef */\n\n/* global variables */\n\nint prs[ON];\n\n/* subroutines */\n\nint op_pr(char c) {\n  switch (c) {\n  case '*': return prs[0];\n  case '+': return prs[1];\n  case '-': return prs[2];\n  }\n  return -1;\n}\n\nll num(string &s, int &pos) {\n  ll n = 0;\n  while (pos < s.size() && s[pos] >= '0' && s[pos] <= '9')\n    n = n * 10 + s[pos++] - '0';\n  return n;\n}\n\nll expr(string &s, int &pos, int p = 0) {\n  if (p >= ON) {\n    if (s[pos] == '(') {\n      pos++; // '('\n      ll e = expr(s, pos, 0);\n      pos++; // ')'\n      return e;\n    }\n\n    return num(s, pos);\n  }\n\n  ll e0 = expr(s, pos, p + 1);\n  while (pos < s.size() && op_pr(s[pos]) == p) {\n    char op = s[pos++]; // '*', '+', '-'\n    ll e1 = expr(s, pos, p + 1);\n\n    switch (op) {\n    case '*': e0 *= e1; break;\n    case '+': e0 += e1; break;\n    case '-': e0 -= e1; break;\n    }\n  }\n\n  return e0;\n}\n\n/* main */\n\nint main() {\n  string s;\n  cin >> s;\n\n  ll maxe = -LINF;\n\n  for (;;) {\n    int pos = 0;\n    ll e = expr(s, pos);\n    if (maxe < e) maxe = e;\n\n    int k = 0;\n    while (k < ON) {\n      if (++prs[k] < ON) break;\n      prs[k++] = 0;\n    }\n    if (k >= ON) break;\n  }\n\n  printf(\"%lld\\n\", maxe);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\n// string??????long long int????????????\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            while (str[j] != ')') {\n                j++;\n            }\n            long long int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n    long long int max_res = -1e09;\n\n    for (long long int i = 0; i < 13; i++) {\n        //ans??¨max_res???????????????\n        long long int ans = act(str, i);\n        //cout << \"I = \" << i << endl;\n        //cout << \"ANS = \" << ans << endl;\n        if (ans > max_res) {\n            max_res = ans;\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1||a[1]==2||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1||a[1]==3||a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2||a[1]==1||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2||a[1]==3||a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3||a[1]==1||a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3||a[1]==2||a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint pri[256];\nstring S;\n\nint solve(int &i,int r){\n    if(r==0){\n        int ret=0;\n        if(S[i]=='('){\n            i++;\n            ret=solve(i,3);\n            i++;\n        }\n        else{\n            while(isdigit(S[i])){\n                ret=ret*10+S[i]-'0';\n                i++;\n            }\n        }\n        return ret;\n    }\n\n    int ret=solve(i,r-1);\n    while(true){\n        if(pri[S[i]]!=r)break;\n        if(S[i]=='+'){\n            i++;\n            ret+=solve(i,r-1);\n        }\n        else if(S[i]=='-'){\n            i++;\n            ret-=solve(i,r-1);\n        }\n        else if(S[i]=='*'){\n            i++;\n            ret*=solve(i,r-1);\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    cin>>S;\n    S+=\"=\";\n    int ans=LLONG_MIN;\n    for(int i=1;i<=3;i++){\n        for(int j=1;j<=3;j++){\n            for(int k=1;k<=3;k++){\n                pri['+']=i;\n                pri['-']=j;\n                pri['*']=k;\n                int idx=0;\n                chmax(ans,solve(idx,3));\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\nll bnf();\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res,t;\n  if(S[p]=='(') p++,res=bnf(),p++;\n  else res=getNum();\n  while(p<S.size()&&S[p]!=')'&&ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nll bnf(){\n  ll res=calc(-1),t;\n  while(p<S.size()&&S[p]!=')')t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  ll res=bnf();\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,calc(-100));\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10LL;\n\t\tres += (ll)(*it - '0');\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = LLONG_MIN;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(c.f3(), max(c2.f2(), c3.f2())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = (1<<30);\nconst ll LLINF = (1LL<<62);\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nvector<char> ope[3];\nvector<int> v;\nint first, second, third;\n\nll firstParse(State &);\nll secondParse(State &);\nll thirdParse(State &);\nll number(State &);\nll factor(State &);\n\n// ??°??????????????????????????????????????°????????????\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n      ret = ret*10 + (*begin - '0');\n      begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++; // '('????£???°??????\n    ll ret;\n    if(v.size()==3) ret = thirdParse(begin);\n    else if(v.size()==2) ret = secondParse(begin);\n    else if(v.size()==1) ret = firstParse(begin);\n    begin++; // ')'????£???°??????\n    return ret;\n  } else {\n      return number(begin);\n  }\n  return -1;\n}\n\n//?¬¬?????????expression\nll firstParse(State &begin){\n  ll ret = factor(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[first].size()){\n      if (*begin == ope[first][i]) {\n        flag = true;\n        begin++;\n        if(ope[first][i]=='+') ret += factor(begin);\n        else if(ope[first][i]=='-') ret -= factor(begin);\n        else if(ope[first][i]=='*') ret *= factor(begin);\n        break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll secondParse(State &begin) {\n  ll ret = firstParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[second].size()){\n      if (*begin == ope[second][i]) {\n          flag = true;\n          begin++;\n          if(ope[second][i]=='+') ret += firstParse(begin);\n          else if(ope[second][i]=='-') ret -= firstParse(begin);\n          else if(ope[second][i]=='*') ret *= firstParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll thirdParse(State &begin) {\n  ll ret = secondParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[third].size()){\n      if (*begin == ope[third][i]) {\n          flag = true;\n          begin++;\n          if(ope[third][i]=='+') ret += secondParse(begin);\n          else if(ope[third][i]=='-') ret -= secondParse(begin);\n          else if(ope[third][i]=='*') ret *= secondParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\nint main() {\n  string s;\n  cin>>s;\n  State start = s.begin();\n  ll ans = numeric_limits<long long>::min();\n  /*??°???????°?????????????????????????????????????*/\n  REP(i,0,3){\n    REP(j,0,3){\n      REP(k,0,3){\n\n        REP(l,0,3) ope[l].clear();\n        ope[i].push_back('+');\n        ope[j].push_back('-');\n        ope[k].push_back('*');\n        v.clear();\n        v.push_back(i); v.push_back(j); v.push_back(k);\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        ll tmp;\n        State start = s.begin();\n\n        if(v.size() == 3){\n          first = v[0]; second = v[1]; third = v[2];\n          tmp = thirdParse(start);\n        }else if(v.size() == 2){\n          first = v[0]; second = v[1];\n          tmp = secondParse(start);\n        }else{\n          first = v[0];\n          tmp = firstParse(start);\n        }\n        ans = max(ans, tmp);\n\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e19\n\n#define MAX_N 1000\n\nmap<char,int> prio;\nstring s;\n\null expr(int l,int r){\n\t//dbg(s.substr(l,r-l));\n\t// num\n\tbool isnum=true;\n\trepl(i,l,r){\n\t\tif(!isdigit(s[i]))isnum=false;\n\t}\n\tif(isnum)return stoll(s.substr(l,r-l));\n\n\t// (expr)\n\tull lev;\n\tif(s[l]=='('){\n\t\tlev=0;\n\t\tbool isk=true;\n\t\trepl(i,l,r){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(i!=r-1&&lev==0)isk=false;\n\t\t}\n\t\tif(isk)return expr(l+1,r-1);\n\t}\n\n\t// expr op expr\t\n\trep(j,3){\n\t\tlev=0;\n\t\tfor(int i=r-1;i>=l;i--){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(lev==0&&prio.count(s[i])&&prio[s[i]]==j){\n\t\t\t\tull resa=expr(l,i),resb=expr(i+1,r);\n\t\t\t\tif(s[i]=='+'){\n\t\t\t\t\treturn resa+resb;\n\t\t\t\t}else if(s[i]=='-'){\n\t\t\t\t\treturn resa-resb;\n\t\t\t\t}else{\n\t\t\t\t\treturn resa*resb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>s;\n\tull res=-INF;\n\tprio['+']=prio['-']=prio['*']=0;\n\trep(i,27){\n\t\tprio['+']=i/9;\n\t\tprio['-']=i%9/3;\n\t\tprio['*']=i%3;\n\t\tmaxch(res,expr(0,s.length()));\n\t\t//rep(j,3)dbg(prio[j]);\n\t\t//dbg(res);\n\t}\n\tcout<<(ll)res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = LLONG_MIN;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    char op = S[idx++];\n    ret = calc(ret, op, ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    char op = S[idx++];\n    ret = calc(ret, op, beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    char op = S[idx++];\n    ret = calc(ret, op, malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nchar op[]={'+','-','*'};\nint prio[]={0,1,2};\nstring s;\n\nll expr(int l,int r){\n\t//dbg(s.substr(l,r-l));\n\t// num\n\tbool isnum=true;\n\trepl(i,l,r){\n\t\tif(!isdigit(s[i]))isnum=false;\n\t}\n\tif(isnum)return stoi(s.substr(l,r-l));\n\n\t// (expr)\n\tll lev;\n\tif(s[l]=='('){\n\t\tlev=0;\n\t\tbool isk=true;\n\t\trepl(i,l,r){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(i!=r-1&&lev==0)isk=false;\n\t\t}\n\t\tif(isk)return expr(l+1,r-1);\n\t}\n\n\t// expr op expr\t\n\trep(j,3){\n\t\tlev=0;\n\t\tfor(int i=r-1;i>=l;i--){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(lev==0&&s[i]==op[prio[j]]){\n\t\t\t\tll resa=expr(l,i),resb=expr(i+1,r);\n\t\t\t\tif(op[prio[j]]=='+'){\n\t\t\t\t\treturn resa+resb;\n\t\t\t\t}else if(op[prio[j]]=='-'){\n\t\t\t\t\treturn resa-resb;\n\t\t\t\t}else{\n\t\t\t\t\treturn resa*resb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>s;\n\tll res=-INF;\n\tdo{\n\t\tmaxch(res,expr(0,s.length()));\n\t\t//rep(j,3)dbg(prio[j]);\n\t\t//dbg(res);\n\t}while(next_permutation(prio,prio+3));\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint operate(int a, int b, char r){\n    return r == '+' ? a + b : r == '-' ? a - b : a * b;\n}\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n \nnamespace AAA{\n    int expression(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == '+' || op == '-' || op == '*'){\n                begin++;                \n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\nnamespace AAB{\n    char a1, a2, b;\n    int expression(State &begin);\n    int term(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a1 || op == a2){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\nnamespace ABB{\n    char a, b1, b2;\n    int expression(State &begin);\n    int term(State &begin);\n    int factor(State &begin);    \n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b1 || op == b2){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\n\nnamespace ABC{\n    char a, b, c;\n    int expression(State &begin);\n    int term(State &begin);\n    int term2(State &begin);\n    int factor(State &begin);\n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            char op = *begin;\n            if(op == a){\n                begin++;                \n                ret = operate(ret, term(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = term2(begin);\n        for(;;){\n            char op = *begin;\n            if(op == b){\n                begin++;\n                ret = operate(ret, term2(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term2(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            char op = *begin;\n            if(op == c){\n                begin++;\n                ret = operate(ret, factor(begin), op);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        if(*begin == '('){\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }else{\n            return number(begin);\n        }\n    }\n}\n\nsigned main(){\n    string s;\n    cin >> s;\n    int ans = -LLONG_MAX;\n    char op[] = \"+-*\";\n    sort(op, op + 3);\n    do{\n        AAB::a1 = ABB::a = ABC::a = op[0];\n        AAB::a2 = ABB::b1 = ABC::b = op[1];\n        AAB::b = ABB::b2 = ABC::c = op[2];\n        State begin = s.begin();\n        int now = AAA::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = AAB::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = ABB::expression(begin);\n        ans = max(ans, now);\n\n        begin = s.begin();\n        now = ABC::expression(begin);\n        ans = max(ans, now);\n\n    }while(next_permutation(op, op + 3));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string temp = \"+-*\";\n\nstring S;\nint level[256];\n\nbool inc(int depth, char c)\n{\n  return(temp.find(c) != string::npos && level[c] == depth);\n}\n\nint64 F(int& idx, int depth)\n{\n  int64 val;\n  if(depth == 3) {\n    if(isdigit(S[idx])) {\n      val = 0;\n      while(idx < S.size() && isdigit(S[idx])) {\n        val = val * 10 + S[idx++] - '0';\n      }\n    } else {\n      ++idx;\n      val = F(idx, 0);\n      ++idx;\n    }\n  } else {\n    val = F(idx, depth + 1);\n    while(idx < S.size() && inc(depth, S[idx])) {\n      char op = S[idx++];\n      int64 y = F(idx, depth + 1);\n      if(op == '+') val += y;\n      else if(op == '-') val -= y;\n      else val *= y;\n    }\n  }\n  return(val);\n}\n\n\nint main()\n{ \n  cin >> S;\n  int64 ret = LLONG_MIN;\n  for(int& i = level['+'] = 0; i < 3; i++) {\n    for(int& j = level['-'] = 0; j < 3; j++) {\n      for(int& k = level['*'] = 0; k < 3; k++) {\n        int idx = 0;\n        ret = max(ret, F(idx, 0));\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = -(1LL << 63);\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nmap<char,int> prio;\nstring s;\n\nll expr(int l,int r){\n\t//dbg(s.substr(l,r-l));\n\t// num\n\tbool isnum=true;\n\trepl(i,l,r){\n\t\tif(!isdigit(s[i]))isnum=false;\n\t}\n\tif(isnum)return stoi(s.substr(l,r-l));\n\n\t// (expr)\n\tll lev;\n\tif(s[l]=='('){\n\t\tlev=0;\n\t\tbool isk=true;\n\t\trepl(i,l,r){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(i!=r-1&&lev==0)isk=false;\n\t\t}\n\t\tif(isk)return expr(l+1,r-1);\n\t}\n\n\t// expr op expr\t\n\trep(j,3){\n\t\tlev=0;\n\t\tfor(int i=r-1;i>=l;i--){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(lev==0&&prio.count(s[i])&&prio[s[i]]==j){\n\t\t\t\tll resa=expr(l,i),resb=expr(i+1,r);\n\t\t\t\tif(s[i]=='+'){\n\t\t\t\t\treturn resa+resb;\n\t\t\t\t}else if(s[i]=='-'){\n\t\t\t\t\treturn resa-resb;\n\t\t\t\t}else{\n\t\t\t\t\treturn resa*resb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>s;\n\tll res=-INF;\n\tprio['+']=prio['-']=prio['*']=0;\n\trep(i,27){\n\t\tprio['+']=i/9;\n\t\tprio['-']=i%9/3;\n\t\tprio['*']=i%3;\n\t\tmaxch(res,expr(0,s.length()));\n\t\t//rep(j,3)dbg(prio[j]);\n\t\t//dbg(res);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1||a[1]==2||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1||a[1]==3||a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2||a[1]==1||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2||a[1]==3||a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3||a[1]==1||a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3||a[1]==2||a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string temp = \"+-*\";\nconst int64 INF = 1LL << 62;\n\nstring S;\nint level[256];\n\nbool inc(int depth, char c)\n{\n  return(temp.find(c) != string::npos && level[c] == depth);\n}\n\nint64 F(int& idx, int depth)\n{\n  int64 val;\n  if(depth == 3) {\n    if(isdigit(S[idx])) {\n      val = 0;\n      while(idx < S.size() && isdigit(S[idx])) {\n        val = val * 10 + S[idx++] - '0';\n      }\n    } else {\n      ++idx;\n      val = F(idx, 0);\n      ++idx;\n    }\n  } else {\n    val = F(idx, depth + 1);\n    while(idx < S.size() && inc(depth, S[idx])) {\n      char op = S[idx++];\n      int64 y = F(idx, depth + 1);\n      if(op == '+') val += y;\n      else if(op == '-') val -= y;\n      else val *= y;\n    }\n  }\n  return(val);\n}\n\n\nint main()\n{ \n  cin >> S;\n  int ptr = 0;\n  int64 ret = F(ptr, 0);\n  for(int& i = level['+'] = 0; i < 3; i++) {\n    for(int& j = level['-'] = 0; j < 3; j++) {\n      for(int& k = level['*'] = 0; k < 3; k++) {\n        int idx = 0;\n        ret = max(ret, F(idx, 0));\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct _1 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _2 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _3 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _4 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _5 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _6 {  \n  int expr(string s, int& p) {\n    int res = expr2(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= expr2(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int expr2(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += term(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  }\n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _7 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\t\n\tres += term(s, p);\t\n\tcontinue;\n      }\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= term(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _8 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\t\n\tres += term(s, p);\t\n\tcontinue;\n      }\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= term(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _9 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\t\n\tres -= term(s, p);\t\n\tcontinue;\n      }\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= term(s, p);\t\n\tcontinue;\n      }\n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _10 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\t\n\tres *= term(s, p);\t\n\tcontinue;\n      }      \n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\t\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\n\nstruct _11 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '-' ) {\n\tp++;\t\n\tres -= term(s, p);\t\n\tcontinue;\n      }      \n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= fact(s, p);\n\tcontinue;\t\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _12 {  \n  int expr(string s, int& p) {\n    int res = term(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '+' ) {\n\tp++;\t\n\tres += term(s, p);\t\n\tcontinue;\n      }      \n      break;\n    }\n    return res;     \n  } \n  int term(string s, int& p) {\n    int res = fact(s, p);\n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\n\tres *= fact(s, p);\n\tcontinue;\n      }\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\t\n      }\n      break;\n    }\n    return res;    \n  }\n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nstruct _13 {  \n  int expr(string s, int& p) {\n    int res = fact(s, p);    \n    while ( p < (int)s.size() ) {\n      if ( s[p] == '*' ) {\n\tp++;\t\n\tres *= fact(s, p);\t\n\tcontinue;\n      }\n      if ( s[p] == '+' ) {\n\tp++;\n\tres += fact(s, p);\n\tcontinue;\n      }\n      if ( s[p] == '-' ) {\n\tp++;\n\tres -= fact(s, p);\n\tcontinue;\t\n      }\n      break;\n    }\n    return res;     \n  }  \n  int fact(string s, int& p) {\n    int res;\n    if ( s[p] == '(' ) {\n      p++;\n      res = expr(s, p);\n      p++;\n    } else {\n      res = numb(s, p);\n    }\n    return res;\n  }\n  \n  int numb(string s, int& p) {    \n    int res = 0;\n    while ( p < (int)s.size() && isdigit(s[p]) ) {\n      res = res*10+s[p++]-'0';      \n    }\n    return res;\n  }   \n};\n\nsigned main(){\n  string s;\n  cin >> s;\n\n  _1 a;\n  _2 b;\n  _3 c;\n  _4 d;\n  _5 e;\n  _6 f;\n  _7 A;\n  _8 B;\n  _9 C;\n  _10 D;\n  _11 E;\n  _12 F;\n  _13 G;    \n\n  int p = 0;\n  int ans = a.expr(s, p);\n  p = 0;\n  ans = max(ans, b.expr(s, p));  \n  p = 0;\n  ans = max(ans, c.expr(s, p));  \n  p = 0;\n  ans = max(ans, d.expr(s, p));  \n  p = 0;\n  ans = max(ans, e.expr(s, p));  \n  p = 0;\n  ans = max(ans, f.expr(s, p));\n  p = 0;\n  ans = max(ans, A.expr(s, p));  \n  p = 0;\n  ans = max(ans, B.expr(s, p));  \n  p = 0;\n  ans = max(ans, C.expr(s, p));  \n  p = 0;\n  ans = max(ans, D.expr(s, p));  \n  p = 0;\n  ans = max(ans, E.expr(s, p));\n  p = 0;\n  ans = max(ans, F.expr(s, p));  \n  p = 0;\n  ans = max(ans, G.expr(s, p));  \n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int =__int128;\n\nint p=0;\nInt formula(string& s,int turn);\nvector<char> op[3];\n\nInt calc(Int lhs,Int rhs,char op){\n    if(op=='+') return lhs+rhs;\n    if(op=='-') return lhs-rhs;\n    if(op=='*') return lhs*rhs;\n    throw(\"what calc\");\n}\n\nInt num(string& s){\n    Int res=0;\n    int op=1;\n    if(s[p]=='-'){\n        op=-1;\n        p++;\n    }\n    else if(s[p]=='+'){\n        op=1;\n        p++;\n    }\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return op*res;\n}\n\nInt term(string & s){\n    if(s[p]=='('){\n        p++;\n        Int res=formula(s,0);\n        p++;\n        return res;\n    }\n    return num(s);\n}\n\nInt formula(string& s,int turn){\n    if(turn==3) return term(s);\n    Int res=formula(s,turn+1);\n    while(p!=s.size() && s[p]!=')'){\n        bool breaker=false;\n        for(int i=0;i<turn;i++){\n            for(int j=0;j<op[i].size();j++){\n                if(op[i][j]==s[p]){\n                    breaker=true;\n                }\n            }\n        }\n        if(breaker) break;\n        char ops=s[p];\n        p++;\n        Int next=formula(s,turn+1);\n        res=calc(res,next,ops);\n    }\n    return res;\n}\nint main(){\n    string s;\n    cin>>s;    \n    Int res=-1e20;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                op[0].clear();\n                op[1].clear();\n                op[2].clear();\n                op[i].push_back('+');\n                op[j].push_back('-');\n                op[k].push_back('*');\n                p=0;\n                Int ret=formula(s,0);\n                res=max(res,ret);\n            }\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <limits>\nusing namespace std;\n\nint op[256];\nint64_t expr0(string &S, int &i);\nint64_t expr1(string &S, int &i);\nint64_t expr2(string &S, int &i);\nint64_t factor(string &S, int &i);\nint64_t number(string &S, int &i);\n\nint64_t expr0(string &S, int &i){\n    int64_t ret = expr1(S,i);\n    while(true){\n        if(op[S[i]]==0){\n            switch(S[i++]){\n                case '+':\n                    ret+=expr1(S,i);\n                    break;\n                case '-':\n                    ret-=expr1(S,i);\n                    break;\n                case '*':\n                    ret*=expr1(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint64_t expr1(string &S, int &i){\n    int64_t ret = expr2(S,i);\n    while(true){\n        if(op[S[i]]==1){\n            switch(S[i++]){\n                case '+':\n                    ret+=expr2(S,i);\n                    break;\n                case '-':\n                    ret-=expr2(S,i);\n                    break;\n                case '*':\n                    ret*=expr2(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint64_t expr2(string &S, int &i){\n    int64_t ret = factor(S,i);\n    while(true){\n        if(op[S[i]]==2){\n            switch(S[i++]){\n                case '+':\n                    ret+=factor(S,i);\n                    break;\n                case '-':\n                    ret-=factor(S,i);\n                    break;\n                case '*':\n                    ret*=factor(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint64_t factor(string &S, int &i){\n    int64_t ret;\n    if(S[i]=='('){\n        i++;\n        ret = expr0(S,i);\n        i++;\n    }else{\n        ret = number(S,i);\n    }\n    return ret;\n}\n\nint64_t number(string &S, int &i){\n    int64_t ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    cin>>S;\n    int64_t ans=numeric_limits<int64_t>::min();\n    fill(op,op+256,255);\n    for(op['+']=0;op['+']<3;op['+']++){\n        for(op['-']=0;op['-']<3;op['-']++){\n            for(op['*']=0;op['*']<3;op['*']++){\n                int i=0;\n                ans = max(ans,expr0(S,i));\n            }\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n#define pb push_back\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n    for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\nstring s;\nvector<char> ops({'+', '-', '*', '.', '.'});\nmap<char, int> ran;\n\nint64 calc(int64 l, int64 r);\nint64 expr(const string& s, int& p);\nint64 number(const string& s, int& p);\nint64 digit(const string& s, int& p);\n\n\nint64 expr(const string& s, int& p, int rank = 0) {\n    int64 l = p;\n    int64 now = 0;\n    if (rank == 3) {\n        if (s[p] == '(') {\n            p++;\n            now = expr(s, p, 0);\n            p++;\n            return now;\n        }\n        return number(s, p);\n    }\n\n    now = expr(s, p, rank+1);\n    while (p < s.size() && s[p] != ')' && ran[s[p]] == rank) {\n        char op = s[p++];\n        int64 nxt = expr(s, p, rank+1);\n        if (op == '+') now += nxt;\n        else if (op == '-') now -= nxt;\n        else if (op == '*') now *= nxt;\n    }\n//    cout << l << \" \" << p << \" \" << rank << \" \" << now << \" \" << s.substr(l, p-l+1) << endl;\n    return now;\n}\n\nint64 number(const string& s, int& p) {\n    int64 now = 0;\n    while(p < s.size()) {\n        if ('0' > s[p] || s[p] > '9')\n            break;\n        now = now*10 + digit(s, p);\n    }\n    return now;\n}\n\nint64 digit(const string& s, int& p) {\n    return s[p++]-'0';\n}\n\n\n\nint main(void){\n    cin >> s;\n    sort(all(ops));\n    int64 res = numeric_limits<int64_t>::min();\n    do {\n        int cnt = 0;\n        REP(i, ops.size()) {\n            if (ops[i] == '.') cnt++;\n            else ran[ops[i]] = cnt;\n//            cout << ops[i] << \" \";\n        }\n//        cout << endl;\n        int p = 0;\n        int64 ret = expr(s, p, 0);\n//        cout << ret << endl;\n        chmax(res, ret);\n    }while(next_permutation(all(ops)));\n    cout << res << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//'+','_','*'\nint a[3];\nbool mark(char t) {\n\tif (t == '+' || t == '_' || t == '*')return true;\n\telse return false;\n}\nstring trans(string x) {\n\tint l = x.length();\n\trep(j, 3) {\n\t\trep(i, l) {\n\t\t\tif (x[i] == '+'&&a[0] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) + stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t\telse if (x[i] == '_'&&a[1] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) - stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\n\t\t\t}\n\t\t\telse if (x[i] == '*'&&a[2] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) * stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t}\n\t}\n\treturn x;\n}\nll ord(string x) {\n\tint l = x.length();\n\trep(i, l) {\n\t\tif (x[i] == ')') {\n\t\t\tint le = i-1;\n\t\t\twhile (x[le] != '(')le--;\n\t\t\tstring u = x.substr(le + 1, i - le - 1);\n\t\t\tint d = i - le + 1;\n\t\t\tstring nu = trans(u);\n\t\t\tint d2 = nu.length();\n\t\t\tx.erase(x.begin() + le, x.begin() + i + 1);\n\t\t\tx.insert(le, nu);\n\t\t\ti = le - 1;\n\t\t\tl = l - d + d2;\n\t\t}\n\t}\n\tll res = stoll(trans(x));\n\treturn res;\n}\nint main() {\n\tstring s; cin >> s;\n\tint len = s.length();\n\trep(i, len) {\n\t\tif (s[i] == '-')s[i] = '_';\n\t}\n\tll ma;\n\trep(x, 3) {\n\t\trep(y, 3) {\n\t\t\trep(z, 3) {\n\t\t\t\ta[0] = x; a[1] = y; a[2] = z;\n\t\t\t\tif (x == 0 &&y == 0 && z == 0) {\n\t\t\t\t\tma = ord(s);\n\t\t\t\t}\n\t\t\t\tma = max(ma, ord(s));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// class Solve {\n// private:\n// \tbool isCat\n\n// public:\n// \tbool is_last_query{};\n// \tSolve()\n// \t{\n// \t\tif (hashFunc == \".\")\n// \t\t{\n// \t\t\tis_last_query = true;\n// \t\t\treturn;\n// \t\t}\n// \t}\n// };\n\nstd::string S;\nint priority[4];\n\nint64_t calcFormula(int&);\nint64_t calcExpression(int&);\nint64_t calcNum(int&);\nint translate(char);\nint64_t calcOperation(int64_t, int64_t, int);\n\nint main()\n{\n\t// while (!Solve().is_last_query);\n\tstd::cin >> S;\n\tint64_t max{LLONG_MIN};\n\tpriority[3] = -1;\n\tfor (priority[0] = 0; priority[0] < 3; priority[0]++)\n\t\tfor (priority[1] = 0; priority[1] < 3; priority[1]++)\n\t\t\tfor (priority[2] = 0; priority[2] < 3; priority[2]++)\n\t\t\t{\n\t\t\t\tint s_i{};\n\t\t\t\tmax = std::max(max, calcFormula(s_i));\n\t\t\t}\n\tprintf(\"%lld\\n\", max);\n\n\treturn 0;\n}\n\nint64_t calcFormula(int& s_i)\n{\n\tusing pii = std::pair<int, int64_t>;\n\tstd::stack<pii> st;\n\tst.push({3, calcExpression(s_i)});\n\twhile (s_i < (int)S.size() && S[s_i] != ')')\n\t{\n\t\tint ope{translate(S[s_i])};\n\t\ts_i++;\n\t\twhile (priority[ope] <= priority[st.top().first])\n\t\t{\n\t\t\tpii tmp{st.top()};\n\t\t\tst.pop();\n\t\t\tst.top().second = calcOperation(st.top().second, tmp.second, tmp.first);\n\t\t}\n\t\tst.push({ope, calcExpression(s_i)});\n\t}\n\twhile (st.size() >= 2)\n\t{\n\t\tpii tmp{st.top()};\n\t\tst.pop();\n\t\tst.top().second = calcOperation(st.top().second, tmp.second, tmp.first);\n\t}\n\treturn st.top().second;\n}\n\nint64_t calcExpression(int& s_i)\n{\n\tint64_t ret{};\n\tif (S[s_i] == '(')\n\t{\n\t\ts_i++;\n\t\tret = calcFormula(s_i);\n\t\ts_i++;\n\t}\n\telse\n\t\tret = calcNum(s_i);\n\treturn ret;\n}\n\nint64_t calcNum(int& s_i)\n{\n\tint64_t ret{};\n\twhile (s_i < (int)S.size() && isdigit(S[s_i]))\n\t{\n\t\tret = 10 * ret + S[s_i] - '0';\n\t\ts_i++;\n\t}\n\treturn ret;\n}\n\nchar operators[8]{\"*+-\"};\nint translate(char c)\n{\n\tfor (int i{}; i < 3; i++)\n\t\tif (c == operators[i])\n\t\t\treturn i;\n}\n\nint64_t calcOperation(int64_t a, int64_t b, int ope)\n{\n\tif (ope == 0) return a * b;\n\telse if (ope == 1) return a + b;\n\telse return a - b;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// <expr> ::= <term1>[op0<term1>]*\n// <term1> ::= <term2>[op1<term2>]*\n// <term2> ::= <fact>[op2<fact>]*\n// <fact> ::= <numb> | (<expr>)\n// <numb> ::= [0-9]+\n\ntemplate<typename T>\nstruct Parser {\n\tusing itr = string::const_iterator;\n\titr now;\n\tT ans;\n\tmap<char, int> op;\n\tconst struct ex {\n\t\tvector<char> _012;\n\t\tex() {\n\t\t\t_012.resize(10);\n\t\t\tfor(int i = 0; i < 10; ++i) {\n\t\t\t\t_012[i] = (char)('0' + i);\n\t\t\t}\n\t\t}\n\t} ex;\n\tParser(const string &s, const map<char, int> &op) : op(op) {\n\t\tnow = s.begin();\n\t\tans = expr(now);\n\t}\n\tT calc(T lhs, T rhs, char op) {\n\t\tif(op == '+') return lhs + rhs;\n\t\tif(op == '-') return lhs - rhs;\n\t\tif(op == '*') return lhs * rhs;\n\t}\n\tT expr(itr &now) {\n\t\tT ret = term1(now);\n\t\twhile(true) {\n\t\t\tchar c = *now;\n\t\t\tif(op[c] == 1) {\n\t\t\t\tnext(now, c);\n\t\t\t\tret = calc(ret, term1(now), c);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tT term1(itr &now) {\n\t\tT ret = term2(now);\n\t\twhile(true) {\n\t\t\tchar c = *now;\n\t\t\tif(op[c] == 2) {\n\t\t\t\tnext(now, c);\n\t\t\t\tret = calc(ret, term2(now), c);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tT term2(itr &now) {\n\t\tT ret = fact(now);\n\t\twhile(true) {\n\t\t\tchar c = *now;\n\t\t\tif(op[c] == 3) {\n\t\t\t\tnext(now, c);\n\t\t\t\tret = calc(ret, fact(now), c);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tT fact(itr &now) {\n\t\tif(*now == '(') {\n\t\t\tnext(now, '(');\n\t\t\tT ret = expr(now);\n\t\t\tnext(now, ')');\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn numb(now);\n\t\t}\n\t}\n\tT numb(itr &now) {\n\t\tT ret = 0;\n\t\twhile('0' <= *now and *now <= '9') {\n\t\t\tret *= 10;\n\t\t\tret += (T)(*now - '0');\n\t\t\tnext(now, ex._012);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid next(itr &now, const char expected) {\n\t\tvector<char> req = {expected};\n\t\tnext(now, req);\n\t}\n\tvoid next(itr &now, const vector<char> &expected) {\n\t\tfor(char c : expected) {\n\t\t\tif(*now == c) {\n\t\t\t\tnow++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcerr << \"now \" << *now << \"\\n\";\n\t\tfor(char c : expected) cerr << c << \"\\n\";\n\t}\n};\n\nint main() {\n\tstring s; cin >> s;\n\tmap<char, int> op;\n\tint64_t ans = INT64_MIN;\n\tfor(int i = 0; i < pow(3, 3); ++i) {\n\t\tint tmp = i;\n\t\top['+'] = tmp % 3 + 1;\n\t\ttmp /= 3;\n\t\top['-'] = tmp % 3 + 1;\n\t\ttmp /= 3;\n\t\top['*'] = tmp % 3 + 1;\n\t\tParser<int64_t> parse(s, op);\n\t\t// fprintf(stderr, \"%d %d %d\\n\", op['+'], op['-'], op['*']);\n\t\t// cerr << parse.ans << \"\\n\";\n\t\tans = max(ans, parse.ans);\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<char, int> mp;\nmap<char, function<ll(ll, ll)> > func;\n\ntemplate<typename T> class Parser\n{\nprivate:\n    string eq;\n    int pos;\n    T expr(){\n        T res = mid();\n        while(mp[eq[pos]] == 1){\n            char c = eq[pos++];\n            res = func[c](res, mid());\n        }\n        return res;\n    }\n    T mid(){\n        T res = term();\n        while(mp[eq[pos]] == 2){\n            char c = eq[pos++];\n            res = func[c](res, term());\n        }\n        return res;\n    }\n    T term(){\n        T res = factor();\n        while(mp[eq[pos]] == 3){\n            char c = eq[pos++];\n            res = func[c](res, factor());\n        }\n        return res;\n    }\n    T factor(){\n        if(isdigit(eq[pos])) return number();\n        pos++; // '('をとばす\n        T res = expr();\n        pos++; // ')'をとばす\n        return res;\n    }\n    T number(){\n        T res = 0;\n        do{\n            res *= 10;\n            res += (eq[pos++] - '0');\n        }while(isdigit(eq[pos]));\n        return res;\n    }\n\npublic:\n    Parser(string& s) : eq(s){}\n    T solve(){\n        pos = 0;\n        return expr();\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    Parser<ll> ps(s);\n    ll mx = numeric_limits<ll>::min();\n    func['+'] = [&](ll x, ll y){ return x + y; };\n    func['-'] = [&](ll x, ll y){ return x - y; };\n    func['*'] = [&](ll x, ll y){ return x * y; };\n    srep(i, 1, 4){\n        srep(j, 1, 4){\n            srep(k, 1, 4){\n                mp['+'] = i, mp['-'] = j, mp['*'] = k;\n                cmx(mx, ps.solve());\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <map>\n#include <bitset>\n#include <limits>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint NINF = numeric_limits<lint>::min();\n\nstring S;\nint itr;\n\nmap<char, int> revop = {{'+', 0}, {'-', 1}, {'*', 2}};\n\nbool look[3][3];\n\nlint number() {\n    lint ret = 0;\n    while (isdigit(S[itr])) {\n        (ret *= 10) += S[itr] - '0';\n        ++itr;\n    }\n    return ret;\n}\n\nlint expr(int d) {\n    lint ret;\n    if (d == 3) {\n        // 括弧か数をパース\n        if (S[itr] == '(') {\n            ++itr;\n            ret = expr(0);\n            assert(S[itr] == ')');\n            ++itr;\n        } else {\n            ret = number();\n        }\n    } else {\n        ret = expr(d + 1);\n\n        while (revop.count(S[itr]) && look[d][revop[S[itr]]]) {\n            char op = S[itr];\n            ++itr;\n            if (op == '+') {\n                ret += expr(d + 1);\n            } else if (op == '-') {\n                ret -= expr(d + 1);\n            } else if (op == '*') {\n                ret *= expr(d + 1);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin >> S;\n    lint ans = NINF;\n\n    int a[3];\n    for (a[0] = 0; a[0] < 8; ++a[0]) {\n        for (a[1] = 0; a[1] < 8; ++a[1]) {\n            if (a[0] & a[1]) continue;\n            a[2] = ~(a[0] | a[1]) & 7;\n\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < 3; ++j) {\n                    look[i][j] = ((a[i] >> j) & 1);\n                }\n            }\n\n            itr = 0;\n            ans = max(ans, expr(0));\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\trep(i,3){\n\t\trep(j,op.size())if(op[j]==w[a[i]]){\n\t\t\tchar c=w[a[i]];\n\t\t\tif(c=='+')in[j]+=in[j+1];\n\t\t\tif(c=='-')in[j]-=in[j+1];\n\t\t\tif(c=='*')in[j]*=in[j+1];\n\t\t\tin.erase(in.begin()+j+1);\n\t\t\top.erase(op.begin()+j);\n\t\t\tj--;\n\t\t}\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-inf;\n\tdo{\n\t\tt=0;\n\t\tout=max(out,expr());\n\t}while(next_permutation(all(a)));\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nlong long it;\nvector<string> perm;\n\nlong long numCalc(vector<long long> num, string ope) {\n\t\n\t\n\tfor(long long o=0;o<3;o++) {\n\t\tfor(long long i=0;i<ope.size();i++) {\n\t\t\tif(find(perm[o].begin(), perm[o].end(),ope[i]) != perm[o].end()) {\n\t\t\t\tif(ope[i]=='+')\n\t\t\t\t{\n\t\t\t\t\tnum[i] += num[i+1];\n\t\t\t\t}else if(ope[i]=='-')\n\t\t\t\t{\n\t\t\t\t\tnum[i] -= num[i+1];\n\t\t\t\t}else if(ope[i]=='*')\n\t\t\t\t{\n\t\t\t\t\tnum[i] *= num[i+1];\n\t\t\t\t}\n\t\t\t\tnum.erase(num.begin()+(i+1));\n\t\t\t\tope.erase(ope.begin()+i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\treturn num[0];\n}\nlong long calc(void)\n{\n\tlong long ans = 0;\n\tstring ope;\n\tvector<long long> num; \n\twhile(it<s.size())\n\t{\n\t\tif(s[it]=='(')\n\t\t{\n\t\t\tit++;\n\t\t\tnum.push_back(calc());\n\t\t}\n\t\telse if(s[it]==')')\n\t\t{\n\t\t\tit++;\n\t\t\treturn numCalc(num,ope);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(s[it]<'0' or s[it]>'9')\n\t\t\t\tope.push_back(s[it]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tstring tmp = \"\";\n\t\t\t\ttmp += s[it++];\n\t\t\t\twhile(it<s.size())\n\t\t\t\t{\n\t\t\t\t\tif(s[it]<'0' or s[it]>'9')\n\t\t\t\t\t{\n\t\t\t\t\t\tit--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttmp+=s[it++];\n\t\t\t\t}\n\t\t\t\tnum.push_back(stoll(tmp));\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n\treturn numCalc(num, ope);\n}\n\nint main() {\n\tcin >> s;\n\tlong long ans = LLONG_MIN;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tperm=vector<string>(3);\n\t\t\t\tperm[i].push_back('+');\n\t\t\t\tperm[j].push_back('-');\n\t\t\t\tperm[k].push_back('*');\n\t\t\t\tit=0;\n\t\t\t\tans = max(ans, calc());\n\t\t\t}\n\tcout << ans << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct bnf2{\n  string s;\n  ll x,n;\n  bnf2(){x=0;}\n  bnf2(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf1{\n  string s;\n  ll x,n;\n  bnf1(){x=0;}\n  bnf1(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\nstruct bnf3{\n  string s;\n  ll x,n;\n  bnf3(){x=0;}\n  bnf3(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf4{\n  string s;\n  ll x,n;\n  bnf4(){x=0;}\n  bnf4(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf5{\n  string s;\n  ll x,n;\n  bnf5(){x=0;}\n  bnf5(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf6{\n  string s;\n  ll x,n;\n  bnf6(){x=0;}\n  bnf6(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf7{\n  string s;\n  ll x,n;\n  bnf7(){x=0;}\n  bnf7(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf8{\n  string s;\n  ll x,n;\n  bnf8(){x=0;}\n  bnf8(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf9{\n  string s;\n  ll x,n;\n  bnf9(){x=0;}\n  bnf9(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\nstruct bnf10{\n  string s;\n  ll x,n;\n  bnf10(){x=0;}\n  bnf10(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\n\n\nstruct bnf11{\n  string s;\n  ll x,n;\n  bnf11(){x=0;}\n  bnf11(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf12{\n  string s;\n  ll x,n;\n  bnf12(){x=0;}\n  bnf12(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nstruct bnf13{\n  string s;\n  ll x,n;\n  bnf13(){x=0;}\n  bnf13(string s):s(s){x=0;n=s.size();}\n  ll expr(){\n    ll res=term();\n    while(1){\n      if(s[x]=='-'){\n\tx++;\n\tres-=term();\n      }else break;\n    }\n    return res;\n  }\n  ll term(){\n    ll res=term2();\n    while(1){\n      if(s[x]=='+'){\n\tx++;\n\tres+=term2();\n      }else break;\n    }\n    return res;\n  }\n  ll term2(){\n    ll res=factor();\n    while(1){\n      if(s[x]=='*'){\n\tx++;\n\tres*=factor();\n      }else break;\n    }\n    return res;\n  }\n  ll factor(){\n    ll res=0;\n    if(s[x]=='('){\n      x++;\n      res=expr();\n      x++;\n    }else{\n      res=number();\n    }\n    return res;\n  }\n  ll number(){\n    ll res=0;\n    while(x<n&&isdigit(s[x])){\n      res=res*10+s[x]-'0';\n      x++;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string s;\n  cin>>s;\n  bnf1 b1(s);\n  bnf2 b2(s);\n  bnf3 b3(s);\n  bnf4 b4(s);\n  bnf5 b5(s);\n  bnf6 b6(s);\n  bnf7 b7(s);\n  bnf8 b8(s);\n  bnf9 b9(s);\n  bnf10 b10(s);\n  bnf11 b11(s);\n  bnf12 b12(s);\n  bnf13 b13(s);\n  ll ans=b1.expr();\n  ans=max(ans,b2.expr());\n  ans=max(ans,b3.expr());\n  ans=max(ans,b4.expr());\n  ans=max(ans,b5.expr());\n  ans=max(ans,b6.expr());\n  ans=max(ans,b7.expr());\n  ans=max(ans,b8.expr());\n  ans=max(ans,b9.expr());\n  ans=max(ans,b10.expr());\n  ans=max(ans,b11.expr());\n  ans=max(ans,b12.expr());\n  ans=max(ans,b13.expr());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring y[3],s;\nint p;\nlong long f(int x){\n\tif( x == 3 ){\n\t\tif( s[p] == '(' ){\n\t\t\tp++;\n\t\t\tlong long ans = f(0);\n\t\t\tp++;\n\t\t\treturn ans;\n\t\t}else{\n\t\t\tlong long ans = 0;\n\t\t\twhile( s[p] >= '0' && s[p] <= '9' )\n\t\t\t\tans = ans * 10 + s[p++] - '0';\n\t\t\treturn ans;\n\t\t}\n\t}else{\n\t\tlong long ans = f(x+1);\n\t\twhile( y[x].find(s[p]) != -1 ){\n\t\t\tif( s[p] == '+' ){\n\t\t\t\tp++;\n\t\t\t\tans += f(x+1);\n\t\t\t}else if( s[p] == '-' ){\n\t\t\t\tp++;\n\t\t\t\tans -= f(x+1);\n\t\t\t}else if( s[p] == '*' ){\n\t\t\t\tp++;\n\t\t\t\tans *= f(x+1);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main(){\n\tcin >> s;\n\tlong long ans = -1;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\t\ty[0] = y[1] = y[2] = \"\";\n\t\t\t\ty[i] += \"+\";\n\t\t\t\ty[j] += \"-\";\n\t\t\t\ty[k] += \"*\";\n\t\t\t\tp = 0;\n\t\t\t\tans = max(ans,f(0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1LL<<60\n\nstring S;\nchar U[11] = \"0123456789\";\nint junjo[4] = { 0,0,1,1 };\n\nlong long STOI(string V) {\n\tint LEN = V.size();\n\tif (LEN == 0) { return 0; }\n\treturn (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L, int R) {\n\tint K = 0;\n\tvector<int>junjo2[4];\n\tfor (int i = 0; i<4; i++) {\n\t\tjunjo2[junjo[i]].push_back(i);\n\t}\n\tfor (int i = 0; i<4; i++) {\n\t\tif (junjo2[i].size() >= 1) {\n\t\t\tfor (int j = R - 1; j >= L; j--) {\n\t\t\t\tif (S[j] == '(') { K++; }\n\t\t\t\tif (S[j] == ')') { K--; }\n\t\t\t\tfor (int k = 0; k<junjo2[i].size(); k++) {\n\t\t\t\t\tif (junjo2[i][k] == 0) {\n\t\t\t\t\t\tif (S[j] == '+' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) + calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 1) {\n\t\t\t\t\t\tif (S[j] == '-' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) - calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 2) {\n\t\t\t\t\t\tif (S[j] == '*' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j)*calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (junjo2[i][k] == 3) {\n\t\t\t\t\t\tif (S[j] == '/' && K == 0) {\n\t\t\t\t\t\t\treturn calc(L, j) / calc(j + 1, R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (S[L] == '(' && S[R - 1] == ')') { return calc(L + 1, R - 1); }\n\treturn STOI(S.substr(L, R - L));\n}\n\n\nint main() {\n\tlong long maxn = -INF;\n\tint POW[4] = { 1,4,16,64 };\n\tcin >> S;\n\tS += '=';\n\tfor (int i = 0; i < 256; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tjunjo[j] = (i / POW[j]) % 4;\n\t\t}\n\t\tmaxn = max(maxn, calc(0, S.size() - 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State&);\nint expressionB(State&);\nint expressionC(State&);\nint expressionD(State&);\nint term(State&);\nint term2(State&);\nint number(State&);\nint factor(State&);\n\nchar op[3] = {'+', '-', '*'};\nint expression(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += term(begin);\n\t\t\telse if(op[0] == '-') ret -= term(begin);\n\t\t\telse if(op[0] == '*') ret *= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorB(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionB(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termB(State &begin) {\n\tint ret = factorB(begin);\n\twhile(1) {\n\t\t//cout << \"term:\" << *begin << endl;\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorB(begin);\n\t\t\telse if(op[1] == '-') ret -= factorB(begin);\n\t\t\telse if(op[1] == '*') ret *= factorB(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorB(begin);\n\t\t\telse if(op[2] == '-') ret -= factorB(begin);\n\t\t\telse if(op[2] == '*') ret *= factorB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"tret:\" << ret << endl;\n\treturn ret;\n}\n\nint expressionB(State &begin) {\n\tint ret = termB(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += termB(begin);\n\t\t\telse if(op[0] == '-') ret -= termB(begin);\n\t\t\telse if(op[0] == '*') ret *= termB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"ret:\" << ret << endl;\n\treturn ret;\n}\n\nint factorD(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionD(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termD(State &begin) {\n\tint ret = factorD(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorD(begin);\n\t\t\telse if(op[0] == '-') ret -= factorD(begin);\n\t\t\telse if(op[0] == '*') ret *= factorD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionD(State &begin) {\n\tint ret = termD(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += termD(begin);\n\t\t\telse if(op[1] == '-') ret -= termD(begin);\n\t\t\telse if(op[1] == '*') ret *= termD(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += termD(begin);\n\t\t\telse if(op[2] == '-') ret -= termD(begin);\n\t\t\telse if(op[2] == '*') ret *= termD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorC(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionC(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint expressionC(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorC(begin);\n\t\t\telse if(op[0] == '-') ret -= factorC(begin);\n\t\t\telse if(op[0] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorC(begin);\n\t\t\telse if(op[1] == '-') ret -= factorC(begin);\n\t\t\telse if(op[1] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorC(begin);\n\t\t\telse if(op[2] == '-') ret -= factorC(begin);\n\t\t\telse if(op[2] == '*') ret *= factorC(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = term2(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += term2(begin);\n\t\t\telse if(op[1] == '-') ret -= term2(begin);\n\t\t\telse if(op[1] == '*') ret *= term2(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term2(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tstring s;\n\tgetline(cin, s);\n\n\tState begin = s.begin();\n\tint ret = expressionC(begin);\n\tsort(op, op+3);\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionB(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionD(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\n\t//REP(i, 3) cout << op[i] << \" \";\n\t//cout << ret << \" \" << ans << endl;\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\n\nclass Calc {\n  private:\n    string str;\n    vector<char> p;\n    string::iterator it;\n\n  public:\n    Calc (string str, vector<char> p) {\n        this->str = str;\n        this->p   = p;\n        it = this->str.begin();\n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n    }\n\n    ll f0(int pt)\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            if (pt == 0) {\n                res = f3(0);\n            } else if (pt <= 2) {\n                res = f2(pt);   \n            } else {\n                res = f1(3);\n            }\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n\n    ll f1(int pt)\n    {\n        ll res = f0(pt);\n        while (*it == p[0] ||\n               (pt >= 2 && *it == p[1]) ||\n               (pt >= 3 && *it == p[2])) {\n            \n            if (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(pt));\n            } else if (pt >= 2 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f0(pt));\n            } else if (pt >= 3 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f0(pt));\n            }            \n        }\n        return res;\n    }\n\n    ll f2(int pt)\n    {\n        ll res = f1(pt);\n        if (pt == 0) {\n            while (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1(0));\n            }\n        } else if (pt == 1) {\n            while (*it == p[1] || *it == p[2]) {\n                if (*it == p[1]) {\n                    ++it;\n                    res = get_val(res, p[1], f1(1));                \n                } else {                               \n                    ++it;\n                    res = get_val(res, p[2], f1(1));                \n                }\n            }\n        } else if (pt == 2) {\n            while (*it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f1(2));                \n            }\n        }\n        return res;\n    }\n\n    ll f3(int pt)\n    {\n        ll res = f2(0);\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2(0));\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;      \n    vector<char> p = {'*', '+', '-'};\n    ll res = LLONG_MIN;    \n    do {\n        for (int i = 0; i < 4; i++) {\n            Calc  c(str, p);\n            ll r = -1;\n            if (i == 0) {\n                r = c.f3(0);\n            } else if (i <= 2) {\n                r = c.f2(i);\n            } else {\n                r = c.f1(3);\n            }\n            res = max(res, r);\n        }\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range((i), (0), (a))\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\nlong long th( State & begin );\nint add, sub, mul;\n\nint main() {\n    string s;\n    cin >> s;\n\n    long long ans = -1e18;\n\n    range (i, 1, 4) range (j, 1, 4) range (k, 1, 4) {\n        add = i, sub = j, mul = k;\n        State begin = s.begin();\n        ans = max(ans, th(begin));\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n\nlong long factor( State & );\n\nlong long number( State & begin ) {\n    long long ret = 0;\n    while( isdigit( *begin ) ) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nlong long fi( State & begin ) {\n    long long ret = factor( begin );\n    for (;;) {\n        //最も優先順位が高い演算子\n        if ( add == 1 && *begin == '+' ) {\n            begin++;\n            ret += factor( begin );\n        }\n        else if ( sub == 1 && *begin == '-' ) {\n            begin++;\n            ret -= factor( begin );\n        }\n        else if ( mul == 1 && *begin == '*' ) {\n            begin++;\n            ret *= factor( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n\n}\n\nlong long se( State & begin ) {\n    long long ret = fi( begin );\n    for (;;) {\n        //二番目に優先順位が低い演算子\n        if ( add == 2 && *begin == '+' ) {\n            begin++;\n            ret += fi( begin );\n        }\n        else if ( sub == 2 && *begin == '-' ) {\n            begin++;\n            ret -= fi( begin );\n        }\n        else if ( mul == 2 && *begin == '*' ) {\n            begin++;\n            ret *= fi( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n}\n\nlong long th( State & begin ) {\n    long long ret = se( begin );\n    for (;;) {\n        //ここは最も優先順位が低い演算子\n        if ( add == 3 && *begin == '+' ) {\n            begin++;\n            ret += se( begin );\n        }\n        else if ( sub == 3 && *begin == '-' ) {\n            begin++;\n            ret -= se( begin );\n        }\n        else if ( mul == 3 && *begin == '*' ) {\n            begin++;\n            ret *= se( begin );\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n}\n\nlong long factor( State & begin ) {\n    if ( *begin == '(' ) {\n        begin++;\n        long long ret = th( begin );\n        begin++;\n        return ret;\n    }\n    else {\n        return number( begin );\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nlong long number(State&);\nlong long factor(State&,vector<long long>);\nlong long expr3(State&,long long,vector<long long>);\nlong long expr2(State&,long long,vector<long long>);\nlong long expr1(State&,long long,vector<long long>);\n\nvector<vector<long long>> v;\n\n// ??°??????????????????????????????????????°????????????\nlong long number(State &begin) {\n    long long ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nlong long factor(State &begin, vector<long long> v) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        long long ret = expr1(begin,0,v);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\nlong long expr3(State &begin, long long i, vector<long long> v) {\n    long long ret = factor(begin,v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] == 0) {\n            begin++;\n            ret += factor(begin,v);\n        } else if (*begin == '-' && v[i] == 1) {\n            begin++;\n            ret -= factor(begin,v);\n        } else if (*begin == '*' && v[i] == 2){\n            begin++;\n            ret *= factor(begin,v);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nlong long expr2(State &begin, long long i, vector<long long> v) {\n    long long ret = expr3(begin, 2, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] == 0) {\n            begin++;\n            ret += expr3(begin, 2, v);\n        } else if (*begin == '-' && v[i] == 1) {\n            begin++;\n            ret -= expr3(begin, 2, v);\n        } else if (*begin == '*' && v[i] == 2){\n            begin++;\n            ret *= expr3(begin, 2, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\nlong long expr1(State &begin, long long i, vector<long long> v) {\n    long long ret = expr2(begin, 1, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] == 0) {\n            begin++;\n            ret += expr2(begin, 1, v);\n        } else if (*begin == '-' && v[i] == 1) {\n            begin++;\n            ret -= expr2(begin, 1, v);\n        } else if (*begin == '*' && v[i] == 2){\n            begin++;\n            ret *= expr2(begin, 1, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\n\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    vector<long long> num = {0,1,2};\n    do{\n        v.emplace_back(num);\n    }while(next_permutation(all(num))); \n\n    string s;\n    cin >> s;\n\n    long long ans = 0;\n    rep(i,v.size()){\n        State tmp = s.begin();\n        ans = max(ans, expr1(tmp, 0, v[i]));\n        assert(tmp == s.end());\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nll number(State &begin);\nll term(State &begin, char op1, char op2, char op3);\nll term2(State &begin, char op1, char op2, char op3);\nll factor(State &begin, char op1, char op2, char op3);\nll expression(State &begin, char op1, char op2, char op3);\nvoid consume(State &begin, char ch);\n\nll expression_two(State &begin, string op1, char op2);\nll term_two(State &begin, string op1, char op2);\nll factor_two(State &begin, string op1, char op2);\n\nll expression_two2(State &begin, char op1, string op2);\nll term_two2(State &begin, char op1, string op2);\nll factor_two2(State &begin, char op1, string op2);\n\nll expression_three(State &begin);\nll term_three(State &begin);\nll factor_three(State &begin);\n\nll expression_three(State &begin) {\n    ll ret = factor_three(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            ++begin;\n            ret += factor_three(begin);\n        }\n        else if (*begin == '-') {\n            ++begin;\n            ret -= factor_three(begin);\n        }\n        else if (*begin == '*') {\n            ++begin;\n            ret *= factor_three(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll factor_three(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        ll ret = expression_three(begin);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n// 数字の列をパースして，その数を返す\nll number(State &begin) {\n    ll ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10LL;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\nll term(State  &begin, char op1, char op2, char op3) {\n    ll ret = term2(begin, op1, op2, op3);\n\n    for (;;) {\n        if (*begin == op2) {\n            begin++;\n            if (op2 == '+') {\n                ret += term2(begin, op1, op2, op3);\n            }\n            else if (op2 == '-') {\n                ret -= term2(begin, op1, op2, op3);\n            }\n            else {\n                ret *= term2(begin, op1, op2, op3);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// 乗算除算の式をパースして，その評価結果を返す\nll term2(State &begin, char op1, char op2, char op3) {\n    ll ret = factor(begin, op1, op2, op3);\n\n    for (;;) {\n        if (*begin == op3) {\n            begin++;\n            if (op3 == '+') {\n                ret += factor(begin, op1, op2, op3);\n            }\n            else if (op3 == '-') {\n                ret -= factor(begin, op1, op2, op3);\n            }\n            else {\n                ret *= factor(begin, op1, op2, op3);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll factor(State &begin, char op1, char op2, char op3) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        ll ret = expression(begin, op1, op2, op3);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n\n// 四則演算の式をパースして，その評価結果を返す\nll expression(State &begin, char op1, char op2, char op3) {\n    ll ret = term(begin, op1, op2, op3);\n\n    for (;;) {\n        if (*begin == op1) {\n            begin++;\n            if (op1 == '+') {\n                ret += term(begin, op1, op2, op3);\n            }\n            else if (op1 == '-') {\n                ret -= term(begin, op1, op2, op3);\n            }\n            else {\n                ret *= term(begin, op1, op2, op3);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll expression_two(State &begin, string op1, char op2) {\n    ll ret = term_two(begin, op1, op2);\n\n    for (;;) {\n        if (*begin == op1[0]) {\n            begin++;\n            if (op1[0] == '+') {\n                ret += term_two(begin, op1, op2);\n            }\n            else if (op1[0] == '-') {\n                ret -= term_two(begin, op1, op2);\n            }\n            else {\n                ret *= term_two(begin, op1, op2);\n            }\n        }\n        else if (*begin == op1[1]) {\n            begin++;\n            if (op1[1] == '+') {\n                ret += term_two(begin, op1, op2);\n            }\n            else if (op1[1] == '-') {\n                ret -= term_two(begin, op1, op2);\n            }\n            else {\n                ret *= term_two(begin, op1, op2);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll term_two(State &begin, string op1, char op2) {\n    ll ret = factor_two(begin, op1, op2);\n\n    for (;;) {\n        if (*begin == op2) {\n            begin++;\n            if (op2 == '+') {\n                ret += factor_two(begin, op1, op2);\n            }\n            else if (op2 == '-') {\n                ret -= factor_two(begin, op1, op2);\n            }\n            else {\n                ret *= factor_two(begin, op1, op2);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll factor_two(State &begin, string op1, char op2) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        ll ret = expression_two(begin, op1, op2);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n\nll expression_two2(State &begin, char op1, string op2) {\n    ll ret = term_two2(begin, op1, op2);\n\n    for (;;) {\n        if (*begin == op1) {\n            begin++;\n            if (op1 == '+') {\n                ret += term_two2(begin, op1, op2);\n            }\n            else if (op1 == '-') {\n                ret -= term_two2(begin, op1, op2);\n            }\n            else {\n                ret *= term_two2(begin, op1, op2);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\nll term_two2(State &begin, char op1, string op2) {\n    ll ret = factor_two2(begin, op1, op2);\n\n    for (;;) {\n        if (*begin == op2[0]) {\n            begin++;\n            if (op2[0] == '+') {\n                ret += factor_two2(begin, op1, op2);\n            }\n            else if (op2[0] == '-') {\n                ret -= factor_two2(begin, op1, op2);\n            }\n            else {\n                ret *= factor_two2(begin, op1, op2);\n            }\n        }\n        else if (*begin == op2[1]) {\n            ++begin;\n            if (op2[1] == '+') {\n                ret += factor_two2(begin, op1, op2);\n            }\n            else if (op2[1] == '-') {\n                ret -= factor_two2(begin, op1, op2);\n            }\n            else {\n                ret *= factor_two2(begin, op1, op2);\n            }\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nll factor_two2(State &begin, char op1, string op2) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        ll ret = expression_two2(begin, op1, op2);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    }\n    else {\n        cerr << \"Expected \" << expected << \" but got \" << *begin << endl;\n        cerr << \"Rest string is \";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n\n    // 1つだけ選択\n    State begin = s.begin();\n    ll ret = expression_three(begin);\n\n    string tmp = \"+-*\";\n    rep(i, 3) rep(j, 3) {\n        if (i == j) continue;\n        rep(k, 3) {\n            if (i == k or j == k) continue;\n            char op1 = tmp[i];\n            char op2 = tmp[j];\n            char op3 = tmp[k];\n            State begin = s.begin();\n            ll ans = expression(begin, op1, op2, op3);\n            ret = max(ret, ans);\n        }\n    }\n    //\n    // 前に2つ選択\n    rep(i, 3) rep(j, 3) {\n        if (i == j) continue;\n        rep(k, 3) {\n            if (i == k or j == k) continue;\n            char op1 = tmp[i];\n            char op2 = tmp[j];\n            char op3 = tmp[k];\n            string OP1 = \"\" + string(1, op1) + string(1, op2);\n            State begin = s.begin();\n            ll ans = expression_two(begin, OP1, op3);\n            ret = max(ret, ans);\n        }\n    }\n\n    // 後ろに2つ\n    rep(i, 3) rep(j, 3) {\n        if (i == j) continue;\n        rep(k, 3) {\n            if (i == k or j == k) continue;\n            char op1 = tmp[i];\n            char op2 = tmp[j];\n            char op3 = tmp[k];\n            string OP2 = string(1, op2) + string(1, op3);\n            State begin = s.begin();\n            ll ans = expression_two2(begin, op1, OP2);\n            ret = max(ret, ans);\n        }\n    }\n\n    cout << ret << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// <expr>   ::= <term> [ ('+'|'-') <term> ]*\n// <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n// <factor> ::= <number> | '(' <expr> ')'\n// <number> :== ???????????°\n\nll expr(int& pos);\nll mid(int& pos);\nll term(int& pos);\nll factor(int& pos);\nll number(int& pos);\n\nstring s;\nstring en;\n\nvoid comp(ll& a1,ll a2,char c){\n    if(c == '+'){\n        a1 += a2;\n    }else if(c == '-'){\n        a1 -= a2;\n    }else{\n        a1 *= a2;\n    }\n}\n\nll expr(int& pos){\n    ll res = mid(pos);\n    while(s[pos] == en[0]){\n        comp(res,mid(++pos),en[0]);\n    }\n    return res;\n}\n\nll mid(int& pos){\n    ll res = term(pos);\n    while(s[pos] == en[1]){\n        comp(res,term(++pos),en[1]);\n    }\n    return res;\n}\n\nll term(int& pos){\n    ll res = factor(pos);\n    while(s[pos] == en[2]){\n        comp(res,factor(++pos),en[2]);\n    }\n    return res;\n}\n\nll factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('?????¨??°???\n    ll res = expr(pos);\n    pos++;  //')'?????¨??°???\n    return res;\n}\n\nll number(int& pos){\n    string res;\n    while(isdigit(s[pos])){\n        res.pb(s[pos++]);\n    }\n    return stoi(res);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> s;\n    vi v(3);\n    string hoge = \"+-*\";\n    iota(all(v),0);\n    ll mx = -(1LL << 60);\n    do{\n        en.clear();\n        int pos = 0;\n        rep(i,len(v)){\n            en.pb(hoge[v[i]]);\n        }\n        cmx(mx,expr(pos));\n    }while(next_permutation(all(v)));\n    cout << mx << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nint getend(string &str, int start){\n    int depth = 1;\n    int i;\n    for(i = start+1; depth > 0; i++){\n        if(str[i] == '(')depth++;\n        if(str[i] == ')')depth--;\n    }\n    return i;\n}\n\nll operate(string op, ll x, ll y){\n    char t = op[0];\n    switch(t){\n        case '*': return x*y;\n        case '+': return x+y;\n        case '^': return x-y;\n    }\n}\n\nll calc(string str, map<string, int> &op){\n    //cerr << \"inp: \" << str << endl;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] == '('){\n            int end = getend(str,i);\n            ll result = calc(str.substr(i+1,end-i-2), op);\n            string putin = to_string(result);\n            str.replace(i, end-i,putin);\n        }\n    }\n    list<string> arr;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            int end = i;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end-1;\n        }\n        else if(str[i] == '-'){\n            int end = i+1;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end - 1;\n        }\n        else{\n            arr.push_back(string{str[i]});\n        }\n    }\n    for(int i = 0; i < 3; i++){\n        for(auto itr = arr.begin(); itr != arr.end(); ++itr){\n            if(op.find(*itr) != op.end() && op[*itr] == i){\n                //cerr << \"inp: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n                auto left = itr, right = itr;--left; ++right;\n                string ins = to_string(operate(*itr, stoll(*left), stoll(*right)));\n                --itr;\n                for(int i = 0; i < 3; i++)itr = arr.erase(itr);\n                arr.insert(itr,ins);\n                itr = arr.begin();\n                //cerr << \"itr: \" << *itr << endl;\n                //cerr << \"res: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n            }\n        }\n    }\n    //cerr  << *arr.begin() << endl;\n    return stoll(*arr.begin());\n}\n\nsigned main(){\n    string str;\n    cin >> str;\n    for(auto &e: str)if(e == '-')e = '^';\n    map<string, int> op;\n    ll ans = -(ll)1e18;\n    for(int i = 0; i < 3; i++)for(int j = 0; j < 3; j++)for(int k = 0; k < 3; k++){\n        op[\"*\"] = i;op[\"+\"]=j;op[\"^\"]=k;\n        //for(auto e : op)cerr << e << \" \";\n        //cerr << endl;\n        ans = max(ans, calc(str, op));\n        //cerr << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef __int128_t ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nmap<char, ll> pri;\nstring op = \"+-*\";\nstring s;\nll pos = 0;\nbool end() {\n    return pos == s.size();\n}\nvoid read_char(char c) {\n    assert(!end() && s[pos] == c);\n    ++pos;\n}\nll parse(ll);\nll number() {\n    if (s[pos] == '(') {\n        read_char('(');\n        ll res = parse(0);\n        read_char(')');\n        return res;\n    }\n    else {\n        string res = \"\";\n        while ( !end() && isdigit(s[pos]) ) {\n            res += s[pos++];\n        }\n        return stoll(res);\n    }\n}\nll parse(ll oid) {\n    if (oid == op.size()) return number();\n    ll res = parse(oid+1);\n    while ( !end() && pri.count(s[pos]) > 0 && pri[s[pos]] == oid ) {\n        char op = s[pos];\n        read_char(op);\n        ll right = parse(oid+1);\n        switch (op) {\n            case '*': res *= right; break;\n            case '+': res += right; break;\n            case '-': res -= right; break;\n        }\n    }\n    return res;\n}\nll parse() {\n    pos = 0;\n    return parse(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    ll ans;\n    rep(a, 3) rep(b, 3) rep(c, 3) {\n        // vector<ll> v{a, b, c};\n        vector<ll> v{1, 1, 1};\n        rep(i, 3) pri[op[i]] = v[i];\n        if (a == 0 && b == 0 && c == 0) ans = parse();\n        else chmax(ans, parse());\n    }\n    cout << (long long)ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define int long long\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint expression1(State &begin);\nint expression2(State &begin);\nint expression3(State &begin);\n\nvector<int> priority(3);\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin)-'0';\n    begin++;\n  }\n  // cout<<\"number: \"<<ret<<endl;\n  return ret;\n}\n\nint factor(State &begin){\n  // cout<<\"in factor: \"<<*begin<<endl;\n  int ret;\n  if(*begin=='('){\n    begin++;\n    ret=expression1(begin);\n    begin++;\n  }else{\n    // cout<<\"factor in number\" <<endl;\n    ret=number(begin);\n  }\n  return ret;\n}\n\nint expression3(State &begin){\n  // cout<<\"in expr3: \"<<endl;\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='+'&&priority[2]&(1<<0)){\n      begin++;\n      ret+=factor(begin);\n    }else if(*begin=='-'&&priority[2]&(1<<1)){\n      begin++;\n      ret-=factor(begin);\n    }else if(*begin=='*'&&priority[2]&(1<<2)){\n      begin++;\n      ret*=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression2(State &begin){\n  int ret=expression3(begin);\n  // cout<<\"in expr2: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[1]&(1<<0)){\n      begin++;\n      ret+=expression3(begin);\n    }else if(*begin=='-'&&priority[1]&(1<<1)){\n      begin++;\n      ret-=expression3(begin);\n    }else if(*begin=='*'&&priority[1]&(1<<2)){\n      begin++;\n      ret*=expression3(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression1(State &begin){\n  int ret=expression2(begin);\n  // cout<<\"in expr1: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[0]&(1<<0)){\n      begin++;\n      ret+=expression2(begin);\n    }else if(*begin=='-'&&priority[0]&(1<<1)){\n      begin++;\n      ret-=expression2(begin);\n    }else if(*begin=='*'&&priority[0]&(1<<2)){\n      begin++;\n      ret*=expression2(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  int ans=LLONG_MIN;\n  for(int i=0;i<(1<<3);i++){\n    for(int j=0;j<(1<<3);j++){\n      for(int k=0;k<(1<<3);k++){\n\tif((__builtin_popcount(i)+__builtin_popcount(j)+__builtin_popcount(k))!=3||(i|j|k)!=7)continue;\n\tpriority[0]=i;priority[1]=j;priority[2]=k;\n\tState begin=s.begin();\n        //cout<<i<<\" \"<<j<<\" \"<<k<<\": \"<<expression1(begin)<<endl;\n\tans=max(ans,expression1(begin));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = 1e9;\nconst ll LLINF = 1e15;\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nvector<char> ope[3];\nvector<int> v;\nint first, second, third;\n/*\nint expression(State &);\nint term(State &);\n*/\nll firstParse(State &);\nll secondParse(State &);\nll thirdParse(State &);\nll number(State &);\nll factor(State &);\n\n// ??°??????????????????????????????????????°????????????\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n      ret = ret*10 + (*begin - '0');\n      begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nll factor(State &begin) {\n  if (*begin == '(') {\n    begin++; // '('????£???°??????\n    ll ret;\n    if(v.size()==3) ret = thirdParse(begin);\n    else if(v.size()==2) ret = secondParse(begin);\n    else if(v.size()==1) ret = firstParse(begin);\n    begin++; // ')'????£???°??????\n    return ret;\n  } else {\n      return number(begin);\n  }\n  return -1;\n}\n\n//?¬¬?????????expression\nll firstParse(State &begin){\n  ll ret = factor(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[first].size()){\n      if (*begin == ope[first][i]) {\n        flag = true;\n        begin++;\n        if(ope[first][i]=='+') ret += factor(begin);\n        else if(ope[first][i]=='-') ret -= factor(begin);\n        else if(ope[first][i]=='*') ret *= factor(begin);\n        break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll secondParse(State &begin) {\n  ll ret = firstParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[second].size()){\n      if (*begin == ope[second][i]) {\n          flag = true;\n          begin++;\n          if(ope[second][i]=='+') ret += firstParse(begin);\n          else if(ope[second][i]=='-') ret -= firstParse(begin);\n          else if(ope[second][i]=='*') ret *= firstParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\n//?¬¬?????????expression\nll thirdParse(State &begin) {\n  ll ret = secondParse(begin);\n  for (;;) {\n    bool flag = false;\n    REP(i,0,ope[third].size()){\n      if (*begin == ope[third][i]) {\n          flag = true;\n          begin++;\n          if(ope[third][i]=='+') ret += secondParse(begin);\n          else if(ope[third][i]=='-') ret -= secondParse(begin);\n          else if(ope[third][i]=='*') ret *= secondParse(begin);\n          break;\n      }\n    }\n    if(!flag) break;\n  }\n  return ret;\n}\n\nint main() {\n  string s;\n  cin>>s;\n  State start = s.begin();\n  ll ans = (-1)*LLINF;\n  /*??°???????°?????????????????????????????????????*/\n  REP(i,0,3){\n    REP(j,0,3){\n      REP(k,0,3){\n\n        REP(l,0,3) ope[l].clear();\n        ope[i].push_back('+');\n        ope[j].push_back('-');\n        ope[k].push_back('*');\n        v.clear();\n        v.push_back(i); v.push_back(j); v.push_back(k);\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        ll tmp;\n        State start = s.begin();\n\n        if(v.size() == 3){\n          first = v[0]; second = v[1]; third = v[2];\n          tmp = thirdParse(start);\n        }else if(v.size() == 2){\n          first = v[0]; second = v[1];\n          tmp = secondParse(start);\n        }else{\n          first = v[0];\n          tmp = firstParse(start);\n        }\n        ans = max(ans, tmp);\n\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring  formula;\nint idx;\n\nmap<char, int> mp;\n\nint solve(int pri)\n{\n  static int len = formula.size();\n  if(idx >= len) return 0;\n  int ret = 0; char c = formula[idx];\n  if(c == '(') idx++, ret = solve(0), idx++;\n  else if(c == ')') idx++;\n  else while(idx < len && isdigit(formula[idx]))\n\t ret = ret*10 + (formula[idx++]-'0');\n  while(idx < len && mp.count(formula[idx]) && mp[formula[idx]] > pri) {\n    char op = formula[idx++];\n    if(op == '+') ret += solve(mp[op]);\n    else if(op == '-') ret -= solve(mp[op]);\n    else if(op == '*') ret *= solve(mp[op]);\n  }\n  return ret;\n}\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> formula;\n  int ans = LLONG_MIN;\n  rep(i, 3) rep(j, 3) rep(k, 3) {\n    mp['+'] = i+1, mp['-'] = j+1, mp['*'] = k+1;\n    idx = 0; ans = max(ans, solve(0));\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<limits>\n\nusing namespace std;\n\n#define int long long\n\nvector<int> x(3);\n\n/*\nnumer 0\n( 1\n) 2\n+ 3\n- 4\n* 5\n*/\n\nchar temp[] = {'n', '(', ')', '+', '-', '*'};\n\nint solve(vector<pair<int,int>> t, int b, int e){\n\tvector<pair<int,int>> t2;\n\t\n\tfor(int i = b, depth = 0, index = -1; i < e; i++){\n\t\tswitch(t[i].first) {\n\t\t\tcase 1: \n\t\t\t\tif(depth == 0) {\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdepth--; \n\t\t\t\tif(depth == 0) {\n\t\t\t\t\tt2.push_back({0, solve(t, index+1, i)});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: if(!depth) t2.push_back(t[i]);\n\t\t}\n\t}\n\tfor(int k = 0; k < 3; k++) {\n\t\n\t\tvector<pair<int,int>> st;\n\t\t\n\t\tfor(int i = 0, depth = 0, index = -1; i < t2.size(); i++){\n\t\t\tst.push_back(t2[i]);\n\t\t\tpair<int,int> a, b, c;\n\t\t\t\n\t\t\twhile(st.size() >= 3) {\n\t\t\t\ta = st.back(); st.pop_back();\n\t\t\t\tb = st.back(); st.pop_back();\n\t\t\t\tc = st.back(); st.pop_back();\n\t\t\t\t\n\t\t\t\tif(!b.first){\n\t\t\t\t\tst.push_back(c);\n\t\t\t\t\tst.push_back(b);\n\t\t\t\t\tst.push_back(a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 3) {\n\t\t\t\t\tif(x[0] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second + a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 4) {\n\t\t\t\t\tif(x[1] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second - a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 5) {\n\t\t\t\t\tif(x[2] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second * a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t\n\t\tif(k == 2) {\n\t\t\treturn st.back().second;\n\t\t} else {\n\t\t\tt2 = st;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid hoge(string &s, vector<pair<int,int>> &t){\n\t\n\tfor(int i = 0, num = 0; i < s.size(); i++){\n\t\tswitch(s[i]) {\n\t\t\tcase '(': t.push_back({1,0}); break;\n\t\t\tcase ')': t.push_back({2,0}); break;\n\t\t\tcase '+': t.push_back({3,0}); break;\n\t\t\tcase '-': t.push_back({4,0}); break;\n\t\t\tcase '*': t.push_back({5,0}); break;\n\t\t\tdefault : \n\t\t\t\tnum = num * 10 + s[i] - '0';\n\t\t\t\tif(i + 1 == s.size() || '0' > s[i+1] && s[i+1]){\n\t\t\t\t\tt.push_back({0,num});\n\t\t\t\t\tnum = 0;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\t\n\tvector<pair<int,int>> t;\n\tstring s;\n\t\n\tint ans =  numeric_limits<long long>::min();\n\t\n\tcin>>s;\n\t\n\thoge(s, t);\n\t\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tx[0] = i;\n\t\t\t\tx[1] = j;\n\t\t\t\tx[2] = k;\n\t\t\t\tans = max(solve(t, 0, t.size()), ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n\nlong long parse_int(const std::string &s, size_t &i) {\n    long long res=0;\n    while (s[i] >= '0' && s[i] <= '9') \n        res = res*10 + s[i++]-'0';\n\n    return res;\n}\n\nlong long operate(long long lhs, char op, long long rhs) {\n    if (op == '+') {\n        return lhs + rhs;\n    } else if (op == '-') {\n        return lhs - rhs;\n    } else if (op == '*') {\n        return lhs * rhs;\n    } else {\n        assert(0);  // tsurai\n        return -123456789;  // not reached\n    }\n}\n\nlong long parse_expr(const std::string &s, size_t &i, const std::vector<std::string> &ops, int prec) {\n    if (ops[prec].empty()) {\n        if (s[i] == '(') {\n            long long tmp=parse_expr(s, ++i, ops, 0);\n            s[++i];  // ')'\n            return tmp;\n        } else {\n            return parse_int(s, i);\n        }\n    }\n\n    long long res=parse_expr(s, i, ops, prec+1);\n    while (i < s.length()) {\n        if (!std::count(ops[prec].begin(), ops[prec].end(), s[i]))\n            return res;\n\n        char op=s[i++];\n        long long tmp=parse_expr(s, i, ops, prec+1);\n        res = operate(res, op, tmp);\n    }\n\n    return res;\n}\n\nint main() {\n    char buf[256];\n    scanf(\"%s\", buf);\n    std::string s=buf;\n\n    char oplist[256]={};\n    long long res=LLONG_MIN;\n    for (int i=0; i<27; ++i) {\n        oplist['+'] = i % 3;\n        oplist['-'] = (i/3) % 3;\n        oplist['*'] = (i/9) % 3;\n\n        std::vector<std::string> ops(4);\n        for (char c: {'+', '-', '*'})\n            ops[oplist[int(c)]].push_back(c);\n\n        if (ops[0].empty()) continue;\n        if (ops[0].length() < 3 && ops[1].empty()) continue;\n\n        size_t index=0;\n        res = std::max(res, parse_expr(s, index, ops, 0));\n    }\n\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace solver {\nstring s;\ntypedef string::const_iterator Iter;\nIter it, end;\nint priority[3];\n\n#define my_assert(condition)  \\\n  if(!(condition)) {  \\\n    cout << string(it, end) << endl;  \\\n    assert(0 && #condition); \\\n  } \\\n\nvoid consume(char e) {\n  my_assert(*it == e);\n  it ++;\n}\n\nbool isconsume(char e) {\n  if(*it == e) {\n    consume(e);\n    return true;\n  }\n  return false;\n}\n\nll number() {\n  ll ret = 0;\n  my_assert(isdigit(*it));\n  while(isdigit(*it)) {\n    ret *= 10;\n    ret += *it - '0';\n    it ++;\n  }\n  return ret;\n}\n\n// 1. solve operator priority recursion\nll expr(int p) {\n  if(p == 3) {\n    if(isconsume('(')) {\n      ll ret = expr(0);\n      consume(')');\n      return ret;\n    }\n    return number();\n  }\n\n  // 2. solve operator association\n  ll ret = expr(p + 1);\n\n  auto priority_condition = [&]() {\n    auto k = string(\"+-*\").find(*it);\n    if(k == string::npos) return false;\n    return priority[k] == p;\n  };\n\n  while(priority_condition())\n    if(isconsume('+')) ret += expr(p + 1);\n    else if(isconsume('-')) ret -= expr(p + 1);\n    else if(isconsume('*')) ret *= expr(p + 1);\n\n  return ret;\n}\n\nll calc() {\n  it = s.begin(), end = s.end();\n  ll ret = expr(0);\n  my_assert(it == end);\n  return ret;\n}\n\nbool next_priority() {\n  static int turn = 0;\n  int t = turn++;\n  priority[0] = t % 3;\n  t /= 3;\n  priority[1] = t % 3;\n  t /= 3;\n  if(t >= 3) return false;\n  priority[2] = t;\n  return true;\n}\n\nll solve() {\n  ll ret = numeric_limits<ll>::min();\n  do {\n    ret = max(ret, calc());\n  } while(next_priority());\n  return ret;\n}\n\n}\n\nint main() {\n  cin >> solver::s;\n  cout << solver::solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops;\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    const Long INF = LLONG_MIN;\n\n    void solve() {\n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = -INF;\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                for (int c = 0; c < 3; c++) {\n                    for (int i = 0; i < 4; i++) {\n                        ops.clear(); ops.resize(3);\n                        ops[a].push_back(t[0]);\n                        ops[b].push_back(t[1]);\n                        ops[c].push_back(t[2]);\n                        int index = 0;\n                        ans = max(ans, parse(s, index, 0));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long STOI(string V) {\n    int LEN = V.size();\n    if (LEN == 0) { return 0; }\n    return (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return STOI(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = (1LL << 63); S+=\"=\";\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int opst[27][3] = {\n\t{0,0,0},\n\t{0,0,1},\n\t{ 0,0,2 },\n\t{ 0,1,0 },\n\t{ 0,1,1 },\n\t{ 0,1,2 },\n\t{ 0,2,0 },\n\t{ 0,2,1 },\n\t{ 0,2,2 },\n\t{ 1,0,0 },\n\t{ 1,0,1 },\n\t{ 1,0,2 },\n\t{ 1,1,0 },\n\t{ 1,1,1 },\n\t{ 1,1,2 },\n\t{ 1,2,0 },\n\t{ 1,2,1 },\n\t{ 1,2,2 },\n\t{ 2,0,0 },\n\t{ 2,0,1 },\n\t{ 2,0,2 },\n\t{ 2,1,0 },\n\t{ 2,1,1 },\n\t{ 2,1,2 },\n\t{ 2,2,0 },\n\t{ 2,2,1 },\n\t{ 2,2,2 },\n};\n\nll calc(vector<ll> num, vector<int> op, int pri) {\n\tREP(n,3)\n\tREP(i,op.size()) {\n\t\tif (opst[pri][op[i]] == n) {\n\t\t\tif (op[i] == 0) {\n\t\t\t\tnum[i] += num[i + 1];\n\t\t\t}\n\t\t\telse if (op[i] == 1) {\n\t\t\t\tnum[i] -= num[i + 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[i] *= num[i + 1];\n\t\t\t}\n\t\t\tFOR(j, i + 1, num.size() - 1)\n\t\t\t\tnum[j] = num[j + 1];\n\t\t\tnum.resize(num.size() - 1);\n\t\t\tFOR(j, i, op.size() - 1)\n\t\t\t\top[j] = op[j + 1];\n\t\t\top.resize(op.size() - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn num[0];\n}\nll saiki(string s, int &idx, int pri) {\n\tvector<ll> num;\n\tvector<int> op;\n\twhile ((size_t)(idx) < s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tnum.push_back(saiki(s, idx, pri));\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn calc(num, op, pri);\n\t\t}\n\t\tif (isdigit(s[idx])) {\n\t\t\tll num2 = 0;\n\t\t\twhile (idx < s.length() && isdigit(s[idx])) {\n\t\t\t\tnum2 *= 10;\n\t\t\t\tnum2 += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tnum.push_back(num2);\n\t\t\tcontinue;\n\t\t}\n\t\tint opn=0;\n\t\tif (s[idx] == '-')\n\t\t\topn = 1;\n\t\tif (s[idx] == '*')\n\t\t\topn = 2;\n\t\top.push_back(opn);\n\t\tidx++;\n\t}\n\treturn calc(num, op, pri);\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tll ma = -(1 << 63);\n\tREP(i, 27) {\n\t\tint idx = 0;\n\t\tma = max(ma,saiki(s, idx, i));\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint calc(char op, int lhs, int rhs) {\n    if(op == '+') {\n        return lhs + rhs;\n    } else if(op == '-') {\n        return lhs - rhs;\n    } else if(op == '*') {\n        return lhs * rhs;\n    }\n}\n\nint expr(string const& s, int& p, map<char, int>& op);\nint term1(string const& s, int& p, map<char, int>& op);\nint term2(string const& s, int& p, map<char, int>& op);\nint factor(string const& s, int& p, map<char, int>& op);\nint number(string const& s, int& p);\n\nint expr(string const& s, int& p, map<char, int>& op) {\n    int res = term1(s, p, op);\n    while(p < s.size() && op.count(s[p]) == 1 && op[s[p]] == 0) {\n        char c = s[p++];\n        res = calc(c, res, term1(s, p, op));\n    }\n    return res;\n}\n\nint term1(string const& s, int& p, map<char, int>& op) {\n    int res = term2(s, p, op);\n    while(p < s.size() && op.count(s[p]) == 1 && op[s[p]] == 1) {\n        char c = s[p++];\n        res = calc(c, res, term2(s, p, op));\n    }\n    return res;\n}\n\nint term2(string const& s, int& p, map<char, int>& op) {\n    int res = factor(s, p, op);\n    while(p < s.size() && op.count(s[p]) == 1 && op[s[p]] == 2) {\n        char c = s[p++];\n        res = calc(c, res, factor(s, p, op));\n    }\n    return res;\n}\n\nint factor(string const& s, int& p, map<char, int>& op) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    int res = expr(s, ++p, op);\n    ++p;\n    return res;\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\n\nint main() {\n    string s;\n    cin >> s;\n    map<char, int> op;\n    int res = -INF;\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            for(int k=0; k<3; ++k) {\n                op['+'] = i;\n                op['-'] = j;\n                op['*'] = k;\n                int p = 0;\n                res = max(res, expr(s, p, op));\n            }\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nchar op[3] = {'+', '-', '*'};\n\nint pos;\nstring s;\n\nll exprA1();\nll exprA2();\nll exprA3();\nll factorA();\nll exprB1();\nll exprB2();\nll factorB();\nll exprC1();\nll exprC2();\nll factorC();\nll exprD1();\nll factorD();\nll number();\n\nll exprA1() {\n  ll ret = exprA2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprA2();\n      else if(op[0] == '*') pos++, ret *= exprA2();\n      else if(op[0] == '-') pos++, ret -= exprA2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprA2() {\n  ll ret = exprA3();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprA3();\n      else if(op[1] == '*') pos++, ret *= exprA3();\n      else if(op[1] == '-') pos++, ret -= exprA3();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprA3() {\n  ll ret = factorA();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorA();\n      else if(op[2] == '*') pos++, ret *= factorA();\n      else if(op[2] == '-') pos++, ret -= factorA();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorA() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprA1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprB1() {\n  ll ret = exprB2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprB2();\n      else if(op[0] == '*') pos++, ret *= exprB2();\n      else if(op[0] == '-') pos++, ret -= exprB2();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprB2();\n      else if(op[1] == '*') pos++, ret *= exprB2();\n      else if(op[1] == '-') pos++, ret -= exprB2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprB2() {\n  ll ret = factorB();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorB();\n      else if(op[2] == '*') pos++, ret *= factorB();\n      else if(op[2] == '-') pos++, ret -= factorB();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorB() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprB1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprC1() {\n  ll ret = exprC2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += exprC2();\n      else if(op[0] == '*') pos++, ret *= exprC2();\n      else if(op[0] == '-') pos++, ret -= exprC2();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += exprC2();\n      else if(op[1] == '*') pos++, ret *= exprC2();\n      else if(op[1] == '-') pos++, ret -= exprC2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll exprC2() {\n  ll ret = factorC();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += factorC();\n      else if(op[1] == '*') pos++, ret *= factorC();\n      else if(op[1] == '-') pos++, ret -= factorC();\n    } else if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorC();\n      else if(op[2] == '*') pos++, ret *= factorC();\n      else if(op[2] == '-') pos++, ret -= factorC();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorC() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprC1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll exprD1() {\n  ll ret = factorD();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += factorD();\n      else if(op[0] == '*') pos++, ret *= factorD();\n      else if(op[0] == '-') pos++, ret -= factorD();\n    } else if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += factorD();\n      else if(op[1] == '*') pos++, ret *= factorD();\n      else if(op[1] == '-') pos++, ret -= factorD();\n    } else if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += factorD();\n      else if(op[2] == '*') pos++, ret *= factorD();\n      else if(op[2] == '-') pos++, ret -= factorD();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll factorD() {\n  ll ret;\n  if(s[pos] == '(') {\n    pos++;\n    ret = exprD1();\n    pos++;\n  } else {\n    ret = number();\n  }\n  return ret;\n}\n\nll number() {\n  ll ret = 0;\n  while(pos < s.size() && isdigit(s[pos])) {\n    ret *= 10;\n    ret += s[pos]-'0';\n    pos++;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> s;\n\n  ll ans = -LLINF;\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprA1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprB1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprC1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  sort(op, op+3);\n  do {\n    pos = 0;\n    ll ret = exprD1();\n    chmax(ans, ret);\n  } while(next_permutation(op, op+3));\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef function<ll(string&, int&, int, ll&)> OpFunc;\n\nbool op_add(string& s, int& idx, int opidx, ll& n);\nbool op_sub(string& s, int& idx, int opidx, ll& n);\nbool op_mul(string& s, int& idx, int opidx, ll& n);\n\nll expr(string& s, int& idx, int opidx);\n\nint comb1[6][3] = {\n    {0, 1, 2},\n    {0, 2, 1},\n    {1, 0, 2},\n    {1, 2, 0},\n    {2, 0, 1},\n    {2, 1, 0},\n};\nint comb2[6][2] = {\n    {3, 2},\n    {2, 3},\n    {4, 1},\n    {1, 4},\n    {5, 0},\n    {0, 5},\n};\n\nvector<vector<OpFunc>> op;\n\nll factor(string& s, int& idx) {\n    ll n = 0;\n    if (s[idx] == '(') {\n        idx++; // (\n        n = expr(s, idx, 0);\n        idx++; // )\n    } else {\n        while (isdigit(s[idx])) {\n            n *= 10;\n            n += s[idx] - '0';\n            idx++;\n        }\n    }\n    return n;\n}\n\nll expr(string& s, int& idx, int opidx) {\n    if (opidx == SZ(op)) {\n        return factor(s, idx);\n    } else {\n        ll n = expr(s, idx, opidx+1);\n        for (; idx < (int)s.length();) {\n            bool ok = false;\n            REP(i, SZ(op[opidx])) {\n                if (op[opidx][i](s, idx, opidx, n)) {\n                    ok = true;\n                }\n            }\n            if (!ok) break;\n        }\n        return n;\n    }\n}\n\nbool op_add(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '+') {\n        idx++;\n        n += expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_sub(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '-') {\n        idx++;\n        n -= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nbool op_mul(string& s, int& idx, int opidx, ll& n) {\n    if (s[idx] == '*') {\n        idx++;\n        n *= expr(s, idx, opidx+1);\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    string line;\n    cin >> line;\n    vector<vector<OpFunc>> o;\n    o.push_back({op_add});\n    o.push_back({op_sub});\n    o.push_back({op_mul});\n    o.push_back({op_add, op_sub});\n    o.push_back({op_add, op_mul});\n    o.push_back({op_sub, op_mul});\n\n    vector<vector<vector<OpFunc>>> ops;\n    REP(i, 6) {\n        vector<vector<OpFunc>> v;\n        REP(j, 3) {\n            v.push_back(o[comb1[i][j]]);\n        }\n        ops.push_back(v);\n        v.clear();\n        REP(j, 2) {\n            v.push_back(o[comb2[i][j]]);\n        }\n        ops.push_back(v);\n    }\n    ops.push_back({{op_add, op_sub, op_mul}});\n\n    ll ma = LLONG_MIN;\n    REP(i, SZ(ops)) {\n        op.clear();\n        op = ops[i];\n        int idx = 0;\n        ll n = expr(line, idx, 0);\n        ma = max(ma, n);\n    }\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll bnf1();\nll bnf2();\nll bnf3();\nll get_digit();\n\nstring s;\nint p,priority[300];\n\nll Cal(ll res,char c,ll x){\n  p++;\n  \n  ll r;\n  \n  if(x==2)r=bnf2();\n  if(x==3)r=bnf3();\n  if(x==4)r=get_digit();\n  \n  if(c=='+') return res+r;\n  if(c=='-') return res-r;\n  return res*r;\n}\n\nll bnf(){\n  \n  ll res;\n  \n  if(s[p]=='('){\n    \n    p++;\n    \n    res=bnf1();\n    \n    p++;\n    return res;\n  }\n\n  res=bnf1();\n\n  return res;  \n}\n\nll bnf1(){\n  \n  ll res=bnf2();\n  \n  while(priority[s[p]]==1) res=Cal(res,s[p],2);\n  \n  return res;\n}\n\nll bnf2(){\n  \n  ll res=bnf3();\n  \n  while(priority[s[p]]==2) res=Cal(res,s[p],3);\n  \n  return res;\n}\n\nll bnf3(){\n  \n  ll res=get_digit();\n  \n  while(priority[s[p]]==3) res=Cal(res,s[p],4);\n  \n  return res;\n}\n\nll get_digit(){\n  \n  ll res=0;\n  \n  if(s[p]=='('){\n    \n    res=bnf();\n    \n    return res;\n  }\n  \n  while('0'<=s[p]&&s[p]<='9') res=res*10+s[p++]-'0';\n  \n  return res;\n}\n\n\nint main(){\n  \n  cin>>s;\n\n  s='('+s+')';\n  \n  ll ans=(1e-17);\n  \n  for(int i=1;i<=3;i++)\n    for(int j=1;j<=3;j++)\n      for(int k=1;k<=3;k++){\n\tpriority['+']=i;\n\tpriority['-']=j;\n\tpriority['*']=k;\n\tp=0;\n\tans=max(ans,bnf());\n      }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;s[(int)s.size()+10000]='(';\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 9223372036854775807\n\n#define MAX_N 1000\n\nmap<char,int> prio;\nstring s;\n\nll expr(int l,int r){\n\t//dbg(s.substr(l,r-l));\n\t// num\n\tbool isnum=true;\n\trepl(i,l,r){\n\t\tif(!isdigit(s[i]))isnum=false;\n\t}\n\tif(isnum)return stoll(s.substr(l,r-l));\n\n\t// (expr)\n\tll lev;\n\tif(s[l]=='('){\n\t\tlev=0;\n\t\tbool isk=true;\n\t\trepl(i,l,r){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(i!=r-1&&lev==0)isk=false;\n\t\t}\n\t\tif(isk)return expr(l+1,r-1);\n\t}\n\n\t// expr op expr\t\n\trep(j,3){\n\t\tlev=0;\n\t\tfor(int i=r-1;i>=l;i--){\n\t\t\tif(s[i]=='(')lev++;\n\t\t\tif(s[i]==')')lev--;\n\t\t\tif(lev==0&&prio.count(s[i])&&prio[s[i]]==j){\n\t\t\t\tull resa=expr(l,i),resb=expr(i+1,r);\n\t\t\t\tif(s[i]=='+'){\n\t\t\t\t\treturn resa+resb;\n\t\t\t\t}else if(s[i]=='-'){\n\t\t\t\t\treturn resa-resb;\n\t\t\t\t}else{\n\t\t\t\t\treturn resa*resb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>s;\n\tll res=-INF;\n\tprio['+']=prio['-']=prio['*']=0;\n\trep(i,27){\n\t\tprio['+']=i/9;\n\t\tprio['-']=i%9/3;\n\t\tprio['*']=i%3;\n\t\tmaxch(res,expr(0,s.length()));\n\t\t//rep(j,3)dbg(prio[j]);\n\t\t//dbg(res);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nchar op[3] = {'+', '-', '*'};\n\nint pos;\nstring s;\n\nll expr1();\nll expr2();\nll expr3();\nll number();\n\nll expr1() {\n  ll ret = expr2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += expr2();\n      else if(op[0] == '*') pos++, ret *= expr2();\n      else if(op[0] == '-') pos++, ret -= expr2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr2() {\n  ll ret = expr3();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += expr3();\n      else if(op[1] == '*') pos++, ret *= expr3();\n      else if(op[1] == '-') pos++, ret -= expr3();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr3() {\n  ll ret;\n  if(s[pos]=='(') {\n    pos++;\n    ret = expr1();\n    // cout << \"expr3 \" << ret << endl;\n    pos++;\n  } else {\n    ret = number();\n  }\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += number();\n      else if(op[2] == '*') pos++, ret *= number();\n      else if(op[2] == '-') pos++, ret -= number();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll number() {\n  ll ret = 0;\n  while(pos < s.size() && isdigit(s[pos])) {\n    ret *= 10;\n    ret += s[pos]-'0';\n    pos++;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> s;\n\n  ll ans = -LLINF;\n  sort(op, op+3);\n  do {\n    // cout << op[0] << \" \" << op[1] << \" \" << op[2] << endl;\n    pos = 0;\n    ll ret = expr1();\n    chmax(ans, ret);\n    // cout << ret << endl;\n  } while(next_permutation(op, op+3));\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // エラー検出\n    void consume(State &begin, char expected) {\n        if(*begin == expected) begin++;\n        else {\n            cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n            cerr << \"Rest string is '\";\n            while(*begin) {\n                cerr << *begin++;\n            }\n            cerr << \"'\" << endl;\n            throw ParseError();\n        }\n    }\n\n    // 数字の列をパースして、その数を返す\n    ll number(State &begin) {\n        ll ret = 0;\n        while(isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n\n    // 括弧か数をパースして、その評価結果を返す\n    ll factor(State &begin, string x) {\n        if(*begin == '(') {\n            consume(begin, '(');    // '('を飛ばす\n            ll ret = expression(begin, x);\n            consume(begin, ')');    // ')'を飛ばす\n            return ret;\n        }else return number(begin);\n    }\n\n    // 最優先演算\n    ll termtop(State &begin, string x) {\n        ll ret = factor(begin, x);\n        // xの先頭のみ\n        while(1) {\n            if(*begin == x.at(0)) {\n                if(x.at(0) == '+') {\n                    consume(begin, '+');\n                    ret += factor(begin, x);\n                }else if(x.at(0) == '-') {\n                    consume(begin, '-');\n                    ret -= factor(begin, x);\n                }else if(x.at(0) == '*') {\n                    consume(begin, '*');\n                    ret *= factor(begin, x);\n                }else break;\n            }else break;\n        }\n        return ret;\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    // 優先度の高いものはここで処理\n    ll term(State &begin, string x) {\n        ll ret = termtop(begin, x);\n        // xの真ん中2つを採用\n        while(1) {\n            if(*begin == x.at(1)) {\n                if(x.at(1) == '+') {\n                    consume(begin, '+');\n                    ret += termtop(begin, x);\n                }else if(x.at(1) == '-') {\n                    consume(begin, '-');\n                    ret -= termtop(begin, x);\n                }else if(x.at(1) == '*') {\n                    consume(begin, '*');\n                    ret *= termtop(begin, x);\n                }else break;\n            }else if(*begin == x.at(2)) {\n                if(x.at(2) == '+') {\n                    consume(begin, '+');\n                    ret += termtop(begin, x);\n                }else if(x.at(2) == '-') {\n                    consume(begin, '-');\n                    ret -= termtop(begin, x);\n                }else if(x.at(2) == '*') {\n                    consume(begin, '*');\n                    ret *= termtop(begin, x);\n                }else break;\n            }else break;\n        }\n        return ret;\n    }\n\n    // 四則演算の式をパースして、その評価結果を返す\n    ll expression(State &begin, string x) {\n        ll ret = term(begin, x);\n        // xの後ろ3つを採用\n        while(1) {\n            if(*begin == x.at(3)) {\n                if(x.at(3) == '+') {\n                    consume(begin, '+');\n                    ret += term(begin, x);\n                }else if(x.at(3) == '-') {\n                    consume(begin, '-');\n                    ret -= term(begin, x);\n                }else if(x.at(3) == '*') {\n                    consume(begin, '*');\n                    ret *= term(begin, x);\n                }else break;\n            }else if(*begin == x.at(4)) {\n                if(x.at(4) == '+') {\n                    consume(begin, '+');\n                    ret += term(begin, x);\n                }else if(x.at(4) == '-') {\n                    consume(begin, '-');\n                    ret -= term(begin, x);\n                }else if(x.at(4) == '*') {\n                    consume(begin, '*');\n                    ret *= term(begin, x);\n                }else break;\n            }else if(*begin == x.at(5)) {\n                if(x.at(5) == '+') {\n                    consume(begin, '+');\n                    ret += term(begin, x);\n                }else if(x.at(5) == '-') {\n                    consume(begin, '-');\n                    ret -= term(begin, x);\n                }else if(x.at(5) == '*') {\n                    consume(begin, '*');\n                    ret *= term(begin, x);\n                }else break;\n            }else break;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    string s; getline(cin, s);\n    string op = \"ABC+-*\";\n    vector<int> opvec = {0, 1, 2, 3, 4, 5};\n    ll ans = LONG_MIN;\n    do {\n        Parser ps;\n        State begin = s.begin();\n        string opnow;\n        for(int i = 0; i < 6; ++i) opnow.push_back(op.at(opvec.at(i)));\n        // cout << opnow << endl;\n        ll now = ps.expression(begin, opnow);\n        // cout << now << endl;\n        chmax(ans, now);\n    }while(next_permutation(opvec.begin(), opvec.end()));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;s[(int)s.size()+1]='(';\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return lhs+rhs;\n  case '-': return lhs-rhs;\n  case '*': return lhs*rhs;\n  }\n  assert(false);\n}\n\nintmax_t parse(\n    const std::string &s, size_t &i, const std::vector<std::string> &ops,\n    size_t preced=0) {\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      intmax_t res=parse(s, ++i, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (isdigit(s[i])) {\n      intmax_t res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i])) \n        res = res*10+s[i]-'0';\n      return res;\n    }\n    assert(false);\n  }\n  intmax_t res=parse(s, i, ops, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t tmp=parse(s, ++i, ops, preced+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nint main() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  intmax_t res=INTMAX_MIN;\n  for (int i=0; i<3; ++i)\n    for (int j=0; j<3; ++j)\n      for (int k=0; k<3; ++k) {\n        std::vector<std::string> tmp(3);\n        tmp[i].push_back('+');\n        tmp[j].push_back('-');\n        tmp[k].push_back('*');\n        std::vector<std::string> ops;\n        for (const auto &op: tmp)\n          if (!op.empty()) ops.emplace_back(op);\n\n        size_t ind=0;\n        res = std::max(res, parse(s, ind, ops));\n      }\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstring S;\nint N;\n\nLL C(int& i, VS& order);\nLL D(int& i, VS& order);\nLL E(int& i, VS& order);\nLL F(int& i, VS& order);\n\nLL C(int& i, VS& order){\n  LL res = D(i, order);\n  while(i < N && order[0].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = D(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL D(int& i, VS& order){\n  LL res = E(i, order);\n  while(i < N && order[1].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = E(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL E(int& i, VS& order){\n  LL res = F(i, order);\n  while(i < N && order[2].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = F(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\n\nLL F(int& i, VS& order){\n  LL res = 0;\n  if(S[i] == '('){\n\t++i;\n\tres = C(i, order);\n\t++i;\n  }\n  else{\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i]-'0');\n\t  ++i;\n\t}\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n  LL ans = 1ll<<63;\n\n  REP(i1,3){\n\tREP(i2,3){\n\t  REP(i3,3){\n\t\tint i = 0;\n\t\tVS ops(3);\n\t\tops[i1] += \"+\";\n\t\tops[i2] += \"-\";\n\t\tops[i3] += \"*\";\n\t\tmaxi(ans, C(i,ops));\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    char op = S[idx++];\n    ret = calc(ret, op, ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    char op = S[idx++];\n    ret = calc(ret, op, beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    char op = S[idx++];\n    op;\n    ret = calc(ret, op, malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF (1LL << 63);\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nbool op_pri[3][256];\nint p;\n\nll calc(ll n1, char op, ll n2) {\n  switch(op) {\n    case '*': return n1 * n2;\n    case '+': return n1 + n2;\n    case '-': return n1 - n2;\n  }\n  return 0;\n}\n\nll number() {\n  ll ret = 0;\n  while(p < S.size() && '0' <= S[p] && S[p] <= '9') ret = ret * 10 + (S[p++] - '0');\n  return ret;\n}\n\nll expr(int level) {\n  ll ret;\n  char op;\n  if(level < 3) {\n    ret = expr(level + 1);\n    while(p < S.size() && op_pri[level][S[p]]) {\n      op = S[p++];\n      ret = calc(ret, op, expr(level + 1));\n    }\n  } else {\n    if(S[p] == '(') {\n      p++;\n      ret = expr(0);\n      p++;\n    } else {\n      ret = number();\n    }\n  }\n  return ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  string pri = \"*+-||\";\n  ll ans = -INF;\n  ll ret;\n  do {\n    REP(i, 0, 3) REP(j, 0, 256) op_pri[i][j] = false;\n    int k = 0;\n    bool f = true;\n    int cnt = 0;\n    REP(i, 0, pri.size()) {\n      if(pri[i] != '|') {\n        op_pri[2 - k][pri[i]] = true;\n        cnt++;\n      } else {\n        k++;\n      }\n    }\n\n    p = 0;\n    ret = expr(0);\n    ans = max(ans, ret);\n  } while(next_permutation(pri.begin(), pri.end()));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#define rep(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define inf long_min\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nbool op_pri[3][256];\nint p;\n\nll calc(ll n1, char op, ll n2) {\n  switch(op) {\n    case '*': return n1 * n2;\n    case '+': return n1 + n2;\n    case '-': return n1 - n2;\n  }\n  return 0;\n}\n\nll number() {\n  ll ret = 0;\n  while(p < s.size() && '0' <= s[p] && s[p] <= '9') ret = ret * 10 + (s[p++] - '0');\n  return ret;\n}\n\nll expr(int level) {\n  ll ret;\n  char op;\n  if(level < 3) {\n    ret = expr(level + 1);\n    while(p < s.size() && op_pri[level][s[p]]) {\n      op = s[p++];\n      ret = calc(ret, op, expr(level + 1));\n    }\n  } else {\n    if(s[p] == '(') {\n      p++;\n      ret = expr(0);\n      p++;\n    } else {\n      ret = number();\n    }\n  }\n  return ret;\n}\n\nint main(void) {\n  cin >> s;\n\n  string pri = \"*+-||\";\n  ll ans = -inf;\n  ll ret;\n  do {\n    rep(i, 0, 3) rep(j, 0, 256) op_pri[i][j] = false;\n    int k = 0;\n    bool f = true;\n    int cnt = 0;\n    rep(i, 0, pri.size()) {\n      if(pri[i] != '|') {\n        op_pri[2 - k][pri[i]] = true;\n        cnt++;\n      } else {\n        k++;\n      }\n    }\n\n    p = 0;\n    ret = expr(0);\n    ans = max(ans, ret);\n  } while(next_permutation(pri.begin(), pri.end()));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\n// string??????long long int????????????\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            int in = 1;\n            int out = 0;\n            //cout <<\"START = \"<<  str[j] << endl;\n            while (in != out) {\n                //cout << str[j] << endl;\n                j++;\n                if (str[j] == '(') {\n                    in++;\n                } else if (str[j] == ')') {\n                    out++;\n                }\n            }\n            long long int end = j;\n            //cout << start << \" \" << end << endl;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            //cout << \"ERROR = \" << str[j] << endl;\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n\n    long long int max_res;\n    for (long long int i = 0; i < 13; i++) {\n        //ans??¨max_res???????????????\n        long long int ans = act(str, i);\n        if (i == 0) {\n            max_res = ans; \n        } else {\n            if (ans > max_res) {\n                max_res = ans;\n            }\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// <expr>   ::= <term> [ ('+'|'-') <term> ]*\n// <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n// <factor> ::= <number> | '(' <expr> ')'\n// <number> :== ???????????°\n\nll expr(int& pos);\nll mid(int& pos);\nll term(int& pos);\nll factor(int& pos);\nll number(int& pos);\n\nstring s;\nmap<char,int> mp;\n\nvoid comp(ll& a1,ll a2,char c){\n    if(c == '+'){\n        a1 += a2;\n    }else if(c == '-'){\n        a1 -= a2;\n    }else{\n        a1 *= a2;\n    }\n}\n\nll expr(int& pos){\n    ll res = mid(pos);\n    while(mp[s[pos]] == 1){\n        char c = s[pos];\n        comp(res,mid(++pos),c);\n    }\n    return res;\n}\n\nll mid(int& pos){\n    ll res = term(pos);\n    while(mp[s[pos]] == 2){\n        char c = s[pos];\n        comp(res,term(++pos),c);\n    }\n    return res;\n}\n\nll term(int& pos){\n    ll res = factor(pos);\n    while(mp[s[pos]] == 3){\n        char c = s[pos];\n        comp(res,factor(++pos),c);\n    }\n    return res;\n}\n\nll factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('?????¨??°???\n    ll res = expr(pos);\n    pos++;  //')'?????¨??°???\n    return res;\n}\n\nll number(int& pos){\n    string res;\n    while(isdigit(s[pos])){\n        res.pb(s[pos++]);\n    }\n    return stoi(res);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> s;\n    vi v(3);\n    string hoge = \"+-*\";\n    iota(all(v),0);\n    ll mx = numeric_limits<ll>::min();\n    int pos = 0;\n    rep(i,3){\n        rep(j,3){\n            rep(k,3){\n                mp['+'] = i+1,mp['-'] = j+1,mp['*'] = k+1;\n                pos = 0;\n                cmx(mx,expr(pos));\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    char op = S[idx++];\n    ret = calc(ret, op, ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    char op = S[idx++];\n    ret = calc(ret, op, beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    char op = S[idx++];\n    cerr << op << endl;\n    ret = calc(ret, op, malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nusing Pt = string::const_iterator;\n\nint a, b, c; // +, - , *\nint expr1(Pt& pt);\nint expr2(Pt& pt);\nint expr3(Pt& pt);\nint expr4(Pt& pt);\nint number(Pt& pt);\n\nint expr1(Pt& pt) {\n  int acc = expr2(pt);\n  while (1) {\n    if (a == 1 && *pt == '+') {\n      acc += expr2(++pt);\n    } else if (b == 1 && *pt == '-') {\n      acc -= expr2(++pt);\n    } else if (c == 1 && *pt == '*') {\n      acc *= expr2(++pt);\n    } else return acc;\n  }\n}\nint expr2(Pt& pt) {\n  int acc = expr3(pt);\n  while (1) {\n    if (a == 2 && *pt == '+') {\n      acc += expr3(++pt);\n    } else if (b == 2 && *pt == '-') {\n      acc -= expr3(++pt);\n    } else if (c == 2 && *pt == '*') {\n      acc *= expr3(++pt);\n    } else return acc;\n  }\n}\nint expr3(Pt& pt) {\n  int acc = expr4(pt);\n  while (1) {\n    if (a == 3 && *pt == '+') {\n      acc += expr4(++pt);\n    } else if (b == 3 && *pt == '-') {\n      acc -= expr4(++pt);\n    } else if (c == 3 && *pt == '*') {\n      acc *= expr4(++pt);\n    } else return acc;\n  }\n}\nint expr4(Pt& pt) {\n  if (*pt == '(') {\n    int ret = expr1(++pt);\n    pt++;\n    return ret;\n  } else {\n    return number(pt);\n  }\n}\nint number(Pt& pt) {\n  int acc = 0;\n  while (isdigit(*pt)) {\n    acc = acc * 10 + (*(pt++) - '0');\n  }\n  return acc;\n}\n\nsigned main() {\n  string s; cin >> s;\n  int ans = numeric_limits<int>::min();\n  for (a = 1; a <= 3; a++) {\n    for (b = 1; b <= 3; b++) {\n      for (c = 1; c <= 3; c++) {\n        Pt pt = s.begin();\n        chmax(ans, expr1(pt));\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nchar op[3];\nint64_t expr0(string &S, int &i);\nint64_t expr1(string &S, int &i);\nint64_t expr2(string &S, int &i);\nint64_t factor(string &S, int &i);\nint64_t number(string &S, int &i);\n\nint64_t expr0(string &S, int &i){\n    int64_t ret = expr1(S,i);\n    while(true){\n        if(S[i]==op[0]){\n            i++;\n            switch(op[0]){\n                case '+':\n                    ret+=expr1(S,i);\n                    break;\n                case '-':\n                    ret-=expr1(S,i);\n                    break;\n                case '*':\n                    ret*=expr1(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'A'<<ret<<endl;\n    return ret;\n}\nint64_t expr1(string &S, int &i){\n    int64_t ret = expr2(S,i);\n    while(true){\n        if(S[i]==op[1]){\n            i++;\n            switch(op[1]){\n                case '+':\n                    ret+=expr2(S,i);\n                    break;\n                case '-':\n                    ret-=expr2(S,i);\n                    break;\n                case '*':\n                    ret*=expr2(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'B'<<ret<<endl;\n    return ret;\n}\nint64_t expr2(string &S, int &i){\n    int64_t ret = factor(S,i);\n    while(true){\n        if(S[i]==op[2]){\n            i++;\n            switch(op[2]){\n                case '+':\n                    ret+=factor(S,i);\n                    break;\n                case '-':\n                    ret-=factor(S,i);\n                    break;\n                case '*':\n                    ret*=factor(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'C'<<ret<<endl;\n    return ret;\n}\n\nint64_t factor(string &S, int &i){\n    int64_t ret;\n    if(S[i]=='('){\n        i++;\n        ret = expr0(S,i);\n        i++;\n    }else{\n        ret = number(S,i);\n    }\n    return ret;\n}\n\nint64_t number(string &S, int &i){\n    int64_t ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    cin>>S;\n    vector<char> V;\n    V.push_back('+');\n    V.push_back('-');\n    V.push_back('*');\n    sort(V.begin(), V.end());\n    int64_t ans=LONG_MIN;\n    do{\n        for(int i=0;i<3;i++) op[i]=V[i];\n        int i=0;\n        ans = max(ans, expr0(S,i));\n    }while(next_permutation(V.begin(),V.end()));\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nmap<char, int> op;\n\nll term(State&, int);\nll number(State&);\n\nll calc(ll x, char c, ll y){\n    if (c == '+') x += y;\n    if (c == '-') x -= y;\n    if (c == '*') x *= y;\n    return x;\n}\n\nll term(State &begin, int d){\n    ll ret = term(begin, d+1);\n    while (1){\n        if (d == 4){\n            if (*begin == '('){\n                begin++;\n                ll ret = term(begin, 1);\n                begin++;\n                return ret;\n            }else{\n                return number(begin);\n            }\n        }else if (op[*begin] == d){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term(begin, d+1));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    ll res = 0;\n    bool f = 1;\n    string s;\n    cin >> s;\n    REP(i,3) REP(j,3) REP(k,3){\n        op['+'] = i+1;\n        op['-'] = j+1;\n        op['*'] = k+1;\n        State begin = s.begin();\n        if (f) res = term(begin, 1), f = 0;\n        else res = max(res, term(begin, 1));\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State&);\nint expressionB(State&);\nint expressionC(State&);\nint expressionD(State&);\nint term(State&);\nint term2(State&);\nint number(State&);\nint factor(State&);\n\nchar op[3] = {'+', '-', '*'};\nint expression(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += term(begin);\n\t\t\telse if(op[0] == '-') ret -= term(begin);\n\t\t\telse if(op[0] == '*') ret *= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorB(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionB(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termB(State &begin) {\n\tint ret = factorB(begin);\n\twhile(1) {\n\t\t//cout << \"term:\" << *begin << endl;\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorB(begin);\n\t\t\telse if(op[1] == '-') ret -= factorB(begin);\n\t\t\telse if(op[1] == '*') ret *= factorB(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorB(begin);\n\t\t\telse if(op[2] == '-') ret -= factorB(begin);\n\t\t\telse if(op[2] == '*') ret *= factorB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"tret:\" << ret << endl;\n\treturn ret;\n}\n\nint expressionB(State &begin) {\n\tint ret = termB(begin);\n\twhile(1) {\n\t\t//cout << *begin << endl;\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += termB(begin);\n\t\t\telse if(op[0] == '-') ret -= termB(begin);\n\t\t\telse if(op[0] == '*') ret *= termB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"ret:\" << ret << endl;\n\treturn ret;\n}\n\nint factorD(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionD(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint termD(State &begin) {\n\tint ret = factorD(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorD(begin);\n\t\t\telse if(op[0] == '-') ret -= factorD(begin);\n\t\t\telse if(op[0] == '*') ret *= factorD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionD(State &begin) {\n\tint ret = termD(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += termD(begin);\n\t\t\telse if(op[1] == '-') ret -= termD(begin);\n\t\t\telse if(op[1] == '*') ret *= termD(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += termD(begin);\n\t\t\telse if(op[2] == '-') ret -= termD(begin);\n\t\t\telse if(op[2] == '*') ret *= termD(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factorC(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expressionC(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint expressionC(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factorC(begin);\n\t\t\telse if(op[0] == '-') ret -= factorC(begin);\n\t\t\telse if(op[0] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factorC(begin);\n\t\t\telse if(op[1] == '-') ret -= factorC(begin);\n\t\t\telse if(op[1] == '*') ret *= factorC(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factorC(begin);\n\t\t\telse if(op[2] == '-') ret -= factorC(begin);\n\t\t\telse if(op[2] == '*') ret *= factorC(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = term2(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += term2(begin);\n\t\t\telse if(op[1] == '-') ret -= term2(begin);\n\t\t\telse if(op[1] == '*') ret *= term2(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term2(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tstring s;\n\tgetline(cin, s);\n\n\tsort(op, op+3);\n\tint ret = -LLINF;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionB(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tsort(op, op+3);\n\t//cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionD(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \";\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\n\tState begin = s.begin();\n\tint ans = expressionC(begin);\n\tret = max(ret, ans);\n\t//REP(i, 3) cout << op[i] << \" \";\n\t//cout << ret << \" \" << ans << endl;\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\n//template<typename T> using vec=std::vector<T>;\n\nconst ll inf=1<<30;\nconst long long int infll=1LL<<63;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nmap<char,ll> pri;\n\nll expr(state& begin);\n\nll number(state& begin){\n    ll res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nll factor(state& begin) {\n    if (*begin=='('){\n        begin++;\n        ll res=expr(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nll term_(state &begin){\n    ll res=factor(begin);\n    while(true){\n        if(*begin=='+' and pri['+']>pri['-'] and pri['+']>pri['*']){\n            ++begin;\n            res+=factor(begin);\n        }else if(*begin=='-' and pri['-']>pri['+'] and pri['-']>pri['*']){\n            ++begin;\n            res-=factor(begin);\n        }else if(*begin=='*' and pri['*']>pri['+'] and pri['*']>pri['-']){\n            ++begin;\n            res*=factor(begin);\n        }else break;\n    }\n    return res;\n}\n\nll term(state& begin){\n    ll res=term_(begin);\n    while(true){\n        if(*begin=='+' and ((pri['+']<pri['-'] and pri['+']>=pri['*']) or (pri['+']>=pri['-'] and pri['+']<pri['*']))){\n            ++begin;\n            res+=term_(begin);\n        }else if(*begin=='-' and ((pri['-']<pri['+'] and pri['-']>=pri['*']) or (pri['-']>=pri['+'] and pri['-']<pri['*']))){\n            ++begin;\n            res-=term_(begin);\n        }else if(*begin=='*' and ((pri['*']<pri['+'] and pri['*']>=pri['-']) or (pri['*']>=pri['+'] and pri['*']<pri['-']))){\n            ++begin;\n            res*=term_(begin);\n        }else break;\n    }\n    return res;\n}\n\nll expr(state& begin){\n    ll res=term(begin);\n    while(true){\n        if(*begin=='+' and pri['+']<=pri['-'] and pri['+']<=pri['*']){\n            ++begin;\n            res+=term(begin);\n        }else if(*begin=='-' and pri['-']<=pri['+'] and pri['-']<=pri['*']){\n            ++begin;\n            res-=term(begin);\n        }else if(*begin=='*' and pri['*']<=pri['+'] and pri['*']<=pri['-']){\n            ++begin;\n            res*=term(begin);\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    string s;\n    cin >> s;\n    ll ans=-infll;\n    rep(i,0,3) rep(j,0,3) rep(k,0,3){\n        pri['+']=i;\n        pri['-']=j;\n        pri['*']=k;\n        state begin=s.begin();\n        ans=max(ans,expr(begin));\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<vector<int>,vector<char> > P;\n\nstring str;\nmap<char,int> num;\n\nlong long calc(long long a, long long b, char z){\n\tif(z == '+') return a+b;\n\tif(z == '-') return a-b;\n\treturn a*b;\n}\n\nlong long func(string str){\n\tvector<long long> nu, tmpnu;\n\tvector<char> ch, tmpch;\n\trep(i,str.size()){\n\t\tif(str[i] == '('){\n\t\t\tint cn = 0, st = i;\n\t\t\twhile(true){\n\t\t\t\ti++;\n\t\t\t\tif(str[i] == '(') cn++;\n\t\t\t\tif(str[i] == ')' && cn == 0){\n\t\t\t\t\tnu.push_back(func(str.substr(st+1,i-st-1)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(str[i] == ')') cn--;\n\t\t\t}\n\t\t} else if('0' <= str[i] && str[i] <= '9'){\n\t\t\tlong long x = str[i]-'0';\n\t\t\twhile(i != str.size()-1 && '0' <= str[i+1] && str[i+1] <= '9'){\n\t\t\t\ti++;\n\t\t\t\tx *= 10;\n\t\t\t\tx += str[i]-'0';\n\t\t\t}\n\t\t\tnu.push_back(x);\n\t\t} else{\n\t\t\tch.push_back(str[i]);\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++){\n\t\twhile(true){\n\t\t\tbool end = true;\n\t\t\tlong long tmp;\n\t\t\tint pos;\n\t\t\ttmpnu.clear(); tmpch.clear();\n\t\t\trep(j,ch.size()){\n\t\t\t\tif(num[ch[j]] != i) continue;\n\t\t\t\ttmp = calc(nu[j],nu[j+1],ch[j]);\n\t\t\t\tpos = j;\n\t\t\t\tend = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(end) break;\n\t\t\ttmpnu.push_back(nu[0]);\n\t\t\trep(j,ch.size()){\n\t\t\t\tif(j != pos){\n\t\t\t\t\ttmpnu.push_back(nu[j+1]);\n\t\t\t\t\ttmpch.push_back(ch[j]);\n\t\t\t\t} else{\n\t\t\t\t\ttmpnu.pop_back();\n\t\t\t\t\ttmpnu.push_back(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnu = tmpnu;\n\t\t\tch = tmpch;\n\t\t}\n\t}\n\treturn nu[0];\n}\n\nint main(){\n\tcin >> str;\n\tlong long ans;\n\tfor(int i = 0; i <= (1<<6); i++){\n\t\tnum.clear();\n\t\tint I = i;\n\t\tnum['+'] = I%4; I /= 4;\n\t\tnum['-'] = I%4; I /= 4;\n\t\tnum['*'] = I%4; I /= 4;\n\t\tif(i == 0) ans = func(str);\n\t\telse ans = max(ans,func(str));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tPlus,\n\tMinus,\n\tMult,\n};\n\nint loc[128];\n\nll calc_two_same(char line[202],int rank[3],int maximum){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('&& rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nll calc_three_same(char line[202]){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_all_different(char line[202],int rank[3],int maximum){\n\n\tint work_line_length,work_rank[3];\n\tll tmp,op1,work,count,work2,work_tmp;\n\tchar calc,work_line[202];\n\tstack<ll> NUM,work_num;\n\tstack<ll> to_make_work;\n\tqueue<ll> work_num2;\n\tstack<char> OP,work_op;\n\tqueue<char> work_op2;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{ //??°?????§????????´???\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '(' && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork_line_length = 0;\n\n\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tint S = 10;\n\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\twork_num.pop();\n\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t}\n\n\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint maximum;\n\tloc['+'] = 0;\n\tloc['-'] = 1;\n\tloc['*'] = 2;\n\n\tchar line[202];\n\tint length;\n\n\tint appear_num[128];\n\tappear_num['+'] = 0;\n\tappear_num['-'] = 0;\n\tappear_num['*'] = 0;\n\n\tscanf(\"%s\",line);\n\tfor(length = 0; line[length] != '\\0';length++){\n\t\tif(line[length] == '+'){\n\t\t\tappear_num['+']++;\n\t\t}else if(line[length] == '-'){\n\t\t\tappear_num['-']++;\n\t\t}else if(line[length] == '*'){\n\t\t\tappear_num['*']++;\n\t\t}\n\t}\n\n\t//(24-((2130*1)-3)+2*37)-(((0+11)+28+3+1)*((0*1)-((2+457)-2-237)+0-1+(1532-(36-0))-((3*0)-1)))\n\t//71611\n\n\tline[length] = '=';\n\tline[length+1] = '\\0';\n\n\tint rank[3],num[3];\n\tll ans = -9223372036854775808,tmp_ans;\n\n\tif(appear_num['+'] > 0 && appear_num['-'] > 0 && appear_num['*'] > 0){\n\t\tfor(int a = 0; a <= 2; a++){\n\t\t\tfor(int b = 0; b <= 2; b++){\n\t\t\t\tfor(int c = 0; c <= 2; c++){\n\n\t\t\t\t\tfor(int i = 0; i < 3; i++)num[i] = 0;\n\n\t\t\t\t\trank[Plus] = a;\n\t\t\t\t\trank[Minus] = b;\n\t\t\t\t\trank[Mult] = c;\n\n\t\t\t\t\tmaximum = -1;\n\t\t\t\t\tmaximum = max(a,max(b,c));\n\n\t\t\t\t\tnum[a]++;\n\t\t\t\t\tnum[b]++;\n\t\t\t\t\tnum[c]++;\n\n\t\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\t\ttmp_ans = calc_all_different(line,rank,maximum);\n\t\t\t\t\t}else if(num[0] == 3 || num[1] == 3 || num[2] == 3){\n\t\t\t\t\t\ttmp_ans = calc_three_same(line);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_ans = calc_two_same(line,rank,maximum);\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,tmp_ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else if(appear_num['+'] == 0 && appear_num['-'] > 0 && appear_num['*'] > 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 1;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 1;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else if(appear_num['+'] > 0 && appear_num['-'] == 0 && appear_num['*'] > 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 1;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 1;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else if(appear_num['+'] > 0 && appear_num['-'] > 0 && appear_num['*'] == 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 1;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 1;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else{\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nstring s, pat = \"+-*\";\n\nll parse(int l, int r, vector<int> prio) {\n    int ptr = l;\n\n    vector<ll> val;\n    vector<char> op;\n    while(ptr < r) {\n        // 演算子\n        if(pat.find(s[ptr]) != string::npos) {\n            op.push_back(s[ptr++]);\n        }\n        // 数字\n        else if(isdigit(s[ptr])) {\n            ll tmp = 0;\n            while(isdigit(s[ptr])) {\n                tmp = (tmp * 10) + (s[ptr++] - '0');\n            }\n            val.push_back(tmp);\n        }\n        // 括弧\n        else if(s[ptr] == '(') {\n            int nl = ptr+1, nr = -1;\n            while(s[ptr] != ')') ptr++;\n            nr = ptr++;\n            val.push_back(parse(nl, nr, prio));\n        }\n    }\n\n    /*\n    for(int i=0; i<op.size(); i++) {\n        printf(\"%lld %c \", val[i], op[i]);\n    }\n    printf(\"%lld\\n\", val[op.size()]);\n    */\n\n    // マージ\n    for(int p=0; p<3; p++) {\n        for(size_t i=0; i<op.size(); i++) {\n            // printf(\"op %c (%d)\\n\", op[i], prio[pat.find(op[i])]);\n            if(prio[pat.find(op[i])] == p) {\n                // printf(\"op %c: %lld, %lld\\n\", op[i], val[i], val[i+1]);\n                if(op[i] == '+') val[i] = val[i] + val[i+1];\n                if(op[i] == '-') val[i] = val[i] - val[i+1];\n                if(op[i] == '*') val[i] = val[i] * val[i+1];\n                val.erase(val.begin() + i + 1);\n                op.erase(op.begin() + i);\n                i--;\n            }\n        }\n    }\n    return val[0];\n}\n\nint main() {\n    cin >> s;\n    int M = s.length();\n    ll ans = parse(0, M, vector<int>{0, 0, 0});\n\n    \n    for(int x=0; x<3; x++) {\n        for(int y=0; y<3; y++) {\n            for(int z=0; z<3; z++) {\n                vector<int> v = {x, y, z};\n                // printf(\"parse: %lld\\n\", parse(0, M, v));\n                ans = max(ans, parse(0, M, v));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing ll = long long;\nconst char newl = '\\n';\n#define var auto\n\nconst ll MAX = LONG_LONG_MAX - 1357183;\n\nstring s;\n\nvector<vector<char>> priority;\n\nvector<vector<ll>> memo;\nll dfs(int begin, int end){\n    if (memo[begin][end] != MAX) return memo[begin][end];\n    vector<ll> nums{};\n    vector<char> ops{};\n    vector<int> lens{};\n    ll curNum = 0;\n    int beginBracket = -1;\n    int depth = 0;\n    for (int i = begin; i <= end; i++){\n        if (s[i] == '(') {\n            if (depth == 0) beginBracket = i;\n            depth++;\n        }\n        else if (s[i] == ')') {\n            if (depth == 1){\n                nums.push_back(dfs(beginBracket + 1, i - 1));\n                lens.push_back(i);\n            }\n            depth--;\n        }\n        else if ('0' <= s[i] && s[i] <= '9'){\n            if (depth != 0) continue;\n            curNum = curNum * 10 + (s[i] - '0');\n        }\n        else{\n            if (depth != 0) continue;\n            if (s[i - 1] != ')') nums.push_back(curNum);\n            curNum = 0;\n            ops.push_back(s[i]);\n        }\n    }\n    if (s[end] != ')'){\n        nums.push_back(curNum);\n        lens.push_back(end);\n    }\n\n    for (auto&& op : priority){\n        vector<ll> newnums{};\n        vector<char> newops{};\n        newnums.push_back(nums[0]);\n        for (int i = 0; i < ops.size(); i++){\n            if (find(op.begin(), op.end(), ops[i]) == op.end()){\n                newops.push_back(ops[i]);\n                newnums.push_back(nums[i + 1]);\n            }\n            else{\n                switch (ops[i]){\n                    case '+':\n                        newnums[newnums.size() - 1] += nums[i + 1];\n                        break;\n                    case '-':\n                        newnums[newnums.size() - 1] -= nums[i + 1];\n                        break;\n                    case '*':\n                        newnums[newnums.size() - 1] *= nums[i + 1];\n                        break;\n                }\n            }\n        }\n        nums = move(newnums);\n        ops = move(newops);\n    }\n\n    return memo[begin][end] = nums[0];\n}\n\nsigned main(){\n    cin >> s;\n    ll res = LLONG_MIN;\n    vector<char> op = {'+', '-', '*'};\n    sort(op.begin(), op.end());\n    vector<vector<int>> shit = {\n            vector<int>{0, 0, 0},\n            vector<int>{0, 0, 1},\n            vector<int>{0, 1, 1},\n            vector<int>{0, 1, 2}\n    };\n    do{\n        for (auto&& hoge : shit){\n            priority = vector<vector<char>>(3, vector<char>(0));\n            for (int i = 0; i < 3; i++){\n                priority[hoge[i]].push_back(op[i]);\n            }\n            memo = vector<vector<ll>>(200, vector<ll>(200, MAX));\n            var curres = dfs(0, s.size() - 1);\n            //cout << curres << endl;\n            res = max(res, curres);\n        }\n    }\n    while (next_permutation(op.begin(), op.end()));\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 62;\n\nstring S;\nint itr;\n\nstring op = \"+-*\";\n\nlint number() {\n    lint ret = 0;\n    while (isdigit(S[itr])) {\n        (ret *= 10) += S[itr] - '0';\n        ++itr;\n    }\n    return ret;\n}\n\nlint expr(int d) {\n    lint ret;\n    if (d == 3) {\n        // 括弧か数をパース\n        if (S[itr] == '(') {\n            ++itr;\n            ret = expr(0);\n            assert(S[itr] == ')');\n            ++itr;\n        } else {\n            ret = number();\n        }\n    } else {\n        ret = expr(d + 1);\n        while (S[itr] == op[d]) {\n            ++itr;\n            if (op[d] == '+') {\n                ret += expr(d + 1);\n            } else if (op[d] == '-') {\n                ret -= expr(d + 1);\n            } else if (op[d] == '*') {\n                ret *= expr(d + 1);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin >> S;\n    lint ans = -INF;\n\n    for (int i = 0; i < 6; ++i) {\n        itr = 0;\n        ans = max(ans, expr(0));\n        assert(itr == S.length());\n        next_permutation(op.begin(), op.end());\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nmap<char, int> op;\n\nll term1(State&);\nll term2(State&);\nll term3(State&);\nll factor(State&);\nll number(State&);\n\nll calc(ll x, char c, ll y){\n    if (c == '+') x += y;\n    if (c == '-') x -= y;\n    if (c == '*') x *= y;\n    return x;\n}\n\nll term1(State &begin){\n    ll ret = term2(begin);\n    while (1){\n        if (op[*begin] == 1){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term2(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll term2(State &begin){\n    ll ret = term3(begin);\n    while (1){\n        if (op[*begin] == 2){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term3(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll term3(State &begin){\n    ll ret = factor(begin);\n    while (1){\n        if (op[*begin] == 3){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, factor(begin));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll factor(State &begin){\n    if (*begin == '('){\n        begin++;\n        ll ret = term1(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nll number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    ll res = -1e18;\n    string s;\n    cin >> s;\n    REP(i,3) REP(j,3) REP(k,3){\n        op['+'] = i+1;\n        op['-'] = j+1;\n        op['*'] = k+1;\n        State begin = s.begin();\n        res = max(res, term1(begin));\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nlong long int calc(const int type, const long long int l, const long long r) {\n\tif (type == 0) {\n\t\treturn l + r;\n\t}\n\telse if (type == 1) {\n\t\treturn l - r;\n\n\t}\n\telse {\n\t\treturn l*r;\n\t}\n}\nlong long int calc1(const char type, const long long int l, const long long r) {\n\tif (type == '+') {\n\t\treturn calc(0, l, r);\n\t}\n\telse if (type == '-') {\n\t\treturn calc(1, l, r);\n\n\t}\n\telse {\n\t\treturn calc(2, l, r);\n\t}\n}\nint a = 0;\nvector<int>perms = { 0,1,2 };\nstring st;\nmap<int, char>mp;\nlong long int getform0();\nlong long int getnum() {\n\tlong long int num = 0;\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tnum= getform0();\n\t\ta++;\n\t}\n\telse {\n\t\twhile (isdigit(st[a])) {\n\t\t\tnum = num * 10 + st[a] - '0';\n\t\t\ta++;\n\t\t}\n\t}\n\treturn num;\n\t\n}\nlong long int getform2() {\n\tlong long int ans;\n\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[perms[1]]) {\n\t\t\treturn ans;\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform1() {\n\tlong long int ans;\n\n\t\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[perms[1]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[1]], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform0(){\n\tlong long int ans;\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\t\ta++;\n\t\t\t\tans = calc1(mp[perms[0]], ans, getform1());\n\t\t\t\n\t\t}\n\t\telse if(st[a]==mp[perms[1]]){\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[1]], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if(st[a]==')'){\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tmp[0] = '+';\n\tmp[1] = '-';\n\tmp[2] = '*';\n\tcin >> st;\n\tlong long int ans = -9223372036854775807;\n\tdo {\n\t\ta = 0;\n\t\tans = max(ans,getform0());\n\t} while (next_permutation(perms.begin(), perms.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long number(string &S, int &p, map<char, int> &mp);\nlong long factor(string &S, int &p, map<char, int> &mp);\nlong long expression(string &S, int &p, map<char, int> &mp, int d);\nlong long number(string &S, int &p, map<char, int> &mp){\n  long long ans = 0;\n  while (isdigit(S[p])){\n    ans *= 10;\n    ans += S[p] - '0';\n    p++;\n  }\n  return ans;\n}\nlong long factor(string &S, int &p, map<char, int> &mp){\n  if (S[p] == '('){\n    p++;\n    long long ans = expression(S, p, mp, 0);\n    p++;\n    return ans;\n  } else {\n    return number(S, p, mp);\n  }\n}\nlong long expression(string &S, int &p, map<char, int> &mp, int d){\n  long long ans;\n  if (d == 3){\n    ans = factor(S, p, mp);\n  } else {\n    ans = expression(S, p, mp, d + 1);\n  }\n  while (1){\n    bool ok = false;\n    long long tmp;\n    char op = S[p];\n    if (mp.count(op)){\n      if (mp[op] == d){\n        p++;\n        if (d == 3){\n          tmp = factor(S, p, mp);\n        } else {\n          tmp = expression(S, p, mp, d + 1);\n        }\n        ok = true;\n      }\n    }\n    if (!ok){\n      break;\n    } else {\n      if (op == '+'){\n        ans += tmp;\n      }\n      if (op == '-'){\n        ans -= tmp;\n      }\n      if (op == '*'){\n        ans *= tmp;\n      }\n    }\n  }\n  return ans;\n}\nint main(){\n  string S;\n  cin >> S;\n  long long ans = -1;\n  for (int i = 0; i < 63; i++){\n    ans *= 2;\n  }\n  for (int i = 0; i < 3; i++){\n    for (int j = 0; j < 3; j++){\n      for (int k = 0; k < 3; k++){\n        map<char, int> mp;\n        mp['+'] = i;\n        mp['-'] = j;\n        mp['*'] = k;\n        int p = 0;\n        ans = max(ans, expression(S, p, mp, 0));\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <map>\n#include <bitset>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 62;\n\nstring S;\nint itr;\n\nmap<char, int> revop = {{'+', 0}, {'-', 1}, {'*', 2}};\n\nbool look[3][3];\n\nlint number() {\n    lint ret = 0;\n    while (isdigit(S[itr])) {\n        (ret *= 10) += S[itr] - '0';\n        ++itr;\n    }\n    return ret;\n}\n\nlint expr(int d) {\n    lint ret;\n    if (d == 3) {\n        // 括弧か数をパース\n        if (S[itr] == '(') {\n            ++itr;\n            ret = expr(0);\n            assert(S[itr] == ')');\n            ++itr;\n        } else {\n            ret = number();\n        }\n    } else {\n        ret = expr(d + 1);\n\n        while (revop.count(S[itr]) && look[d][revop[S[itr]]]) {\n            char op = S[itr];\n            ++itr;\n            if (op == '+') {\n                ret += expr(d + 1);\n            } else if (op == '-') {\n                ret -= expr(d + 1);\n            } else if (op == '*') {\n                ret *= expr(d + 1);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin >> S;\n    lint ans = -INF;\n\n    int a[3];\n    for (a[0] = 0; a[0] < 8; ++a[0]) {\n        for (a[1] = 0; a[1] < 8; ++a[1]) {\n            if (a[0] & a[1]) continue;\n            a[2] = ~(a[0] | a[1]) & 7;\n\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < 3; ++j) {\n                    look[i][j] = ((a[i] >> j) & 1);\n                }\n            }\n\n            itr = 0;\n            ans = max(ans, expr(0));\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nstring C = \"+-*\";\n\nint k;\nstring op[3];\nstring s;\nlli pos, ans;\n\nlli f1(), f2(), f3(), f4();\n\nlli calc(lli a, lli b, char c) {\n  if(c == '+') return a + b;\n  if(c == '-') return a - b;\n  if(c == '*') return a * b;\n}\n\nlli f1(lli d) {\n  if(d == k) {\n    lli x = 0;\n    if(s[pos] == '(') {\n      ++pos;\n      x = f1(0);\n      ++pos;\n    } else {\n      string num;\n      while(isdigit(s[pos])) num += s[pos++];\n      x = atoll(num.c_str());\n    }\n    return x;\n  } else {\n    lli x = f1(d + 1), i;\n    while((i = op[d].find(s[pos])) != string::npos) {\n      ++pos; x = calc(x, f1(d + 1), op[d][i]);\n    }\n    return x;\n  }\n}\n\nvoid rec(lli j) {\n  if(j == C.size()) {\n    pos = 0;\n    ++k;\n    ans = max(ans, f1(0));\n    --k;\n    return;\n  }\n  op[k] += C[j];\n  rec(j+1);\n  op[k].erase(op[k].end()-1);\n  if(op[k].size()) {\n    ++k;\n    op[k] += C[j];\n    rec(j+1);\n    op[k].erase(op[k].end()-1);\n    --k;\n  }\n}\n\nint main() {\n  sort(C.begin(), C.end());\n  while(cin >> s) {\n    s += '$';\n    ans = LLONG_MIN;\n    k = 0;\n    do {\n      rec(0);\n    } while(next_permutation(C.begin(), C.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(ll i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\n//template<typename T> using vec=std::vector<T>;\n\nconst ll inf=1<<30;\nconst long long unsigned int infll=1LL<<63;\nconst double eps=1e-9;\nconst ll dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\n\nmap<char,ll> pri;\n\nll expr(state& begin);\n\nll number(state& begin){\n    ll res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nll factor(state& begin) {\n    if (*begin=='('){\n        begin++;\n        ll res=expr(begin);\n        begin++;\n        return res;\n    }else return number(begin);\n}\n\nll term_(state &begin){\n    ll res=factor(begin);\n    while(true){\n        if(*begin=='+' and pri['+']>pri['-'] and pri['+']>pri['*']){\n            ++begin;\n            res+=factor(begin);\n        }else if(*begin=='-' and pri['-']>pri['+'] and pri['-']>pri['*']){\n            ++begin;\n            res-=factor(begin);\n        }else if(*begin=='*' and pri['*']>pri['+'] and pri['*']>pri['-']){\n            ++begin;\n            res*=factor(begin);\n        }else break;\n    }\n    return res;\n}\n\nll term(state& begin){\n    ll res=term_(begin);\n    while(true){\n        if(*begin=='+' and ((pri['+']<=pri['-'] and pri['+']>pri['*']) or (pri['+']>pri['-'] and pri['+']<=pri['*']))){\n            ++begin;\n            res+=term_(begin);\n        }else if(*begin=='-' and ((pri['-']<=pri['+'] and pri['-']>pri['*']) or (pri['-']>pri['+'] and pri['-']<=pri['*']))){\n            ++begin;\n            res-=term_(begin);\n        }else if(*begin=='*' and ((pri['*']<=pri['+'] and pri['*']>pri['-']) or (pri['*']>pri['+'] and pri['*']<=pri['-']))){\n            ++begin;\n            res*=term_(begin);\n        }else break;\n    }\n    return res;\n}\n\nll expr(state& begin){\n    ll res=term(begin);\n    while(true){\n        if(*begin=='+' and pri['+']<=pri['-'] and pri['+']<=pri['*']){\n            ++begin;\n            res+=term(begin);\n        }else if(*begin=='-' and pri['-']<=pri['+'] and pri['-']<=pri['*']){\n            ++begin;\n            res-=term(begin);\n        }else if(*begin=='*' and pri['*']<=pri['+'] and pri['*']<=pri['-']){\n            ++begin;\n            res*=term(begin);\n        }else break;\n    }\n    return res;\n}\n\nvoid solve(){\n    string s;\n    cin >> s;\n    ll ans=-infll;\n    rep(i,0,3) rep(j,0,3) rep(k,0,3){\n        pri['+']=i;\n        pri['-']=j;\n        pri['*']=k;\n        state begin=s.begin();\n        ans=max(ans,expr(begin));\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <climits>\n\nlong long operate(long long lhs, long long rhs, char op) {\n  if (op == '+') return lhs + rhs;\n  if (op == '-') return lhs - rhs;\n  if (op == '*') return lhs * rhs;\n\n  assert(0);\n}\n\nlong long parse_expr(\n    const std::string &str, size_t &cursor,\n    const std::vector<std::string> &ops, size_t preced=0) {\n\n  // Parses as:\n  // <expr0> ::= <expr1> [<op0> <expr1>]...\n  // <expr1> ::= <expr2> [<op1> <expr2>]...\n  // ...\n  // <exprN> ::= '('<expr0>')' | <number>\n\n  if (ops[preced].empty())\n    // no more operators; now parse integers or parentheses\n    if (str[cursor] == '(') {\n      long long tmp=parse_expr(str, ++cursor, ops, 0);\n      ++cursor;  // ')'\n      return tmp;\n    } else {\n      long long res=0;\n      while (str[cursor] >= '0' && str[cursor] <= '9')\n        res = res*10 + str[cursor++]-'0';\n\n      return res;\n    }\n\n  long long res=parse_expr(str, cursor, ops, preced+1);\n  while (cursor < str.length()) {\n    char op=str[cursor];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op))\n      break;  // lower-precedence operations found\n\n    long long tmp=parse_expr(str, ++cursor, ops, preced+1);\n    res = operate(res, tmp, op);\n  }\n\n  return res;\n}\n\nint main() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n\n  char oplist[256]={};\n  long long res=LLONG_MIN;\n\n  for (int i=0; i<27; ++i) {\n    oplist['+'] = i % 3;\n    oplist['-'] = (i/3) % 3;\n    oplist['*'] = (i/9) % 3;\n\n    std::vector<std::string> ops(4);\n    for (int ch: {'+', '-', '*'})\n      ops[oplist[ch]].push_back(ch);\n\n    if (ops[0].empty()) continue;\n    if (ops[0].length() < 3 && ops[1].empty()) continue;\n\n    size_t index=0;\n    res = std::max(res, parse_expr(s, index, ops));\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint cur;\nchar str[210];\nint perm[3]={0,1,2};\nchar ch[5]=\"+-*\";\nlong long expr(int a){\n\tif(a==3){\n\t\tif(str[cur]=='('){\n\t\t\tcur++;\n\t\t\tlong long ret=expr(0);\n\t\t\tcur++;\n\t\t\treturn ret;\n\t\t}else{\n\t\t\tlong long ret=0;\n\t\t\twhile('0'<=str[cur]&&str[cur]<='9'){\n\t\t\t\tret*=10;\n\t\t\t\tret+=str[cur]-'0';\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlong long ret=expr(a+1);\n\twhile(str[cur]==ch[perm[a]]){\n\t\tcur++;\n\t\tlong long tmp=expr(a+1);\n\t\tif(ch[perm[a]]=='+')ret+=tmp;\n\t\telse if(ch[perm[a]]=='-')ret-=tmp;\n\t\telse ret*=tmp;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%s\",str);\n\tlong long ret=-999999999999999999LL;\n\tdo{\n\t\tcur=0;\n\t\tret=max(ret,expr(0));\n\t}while(next_permutation(perm,perm+3));\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\nvector<char> op[3];\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  ll fact(){\n    if(parse[pos] == '('){\n      pos++;\n      ll p = expression();\n      pos++;\n      return p;\n    }else{\n      ll p=0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n        p *= 10LL;\n        p += (ll)(parse[pos]-'0');\n        pos++;\n      }\n      return p;\n    }\n  }\n\n  ll term2(){\n    ll p = fact();\n    while( 1 ){\n      bool found = false;\n      rep(i,op[2].size()) if( parse[pos] == op[2][i] ) found = true;\n      if( !found ) break;\n      if(parse[pos] == '*'){pos++;p *= fact();}\n      else if( parse[pos] == '-' ) {pos++;p -= fact();}\n      else { pos++; p += fact(); }\n    }\n    return p;\n  }\n \n  ll term(){\n    ll p = term2();\n    while( 1 ){\n      bool found = false;\n      rep(i,op[1].size()) if( parse[pos] == op[1][i] ) found = true;\n      if( !found ) break;\n      if(parse[pos] == '*'){pos++;p *= term2();}\n      else if( parse[pos] == '-' ) {pos++;p -= term2();}\n      else { pos++; p += term2(); }\n    }\n    return p;\n  }\n \n  ll expression(){\n    ll p = term();\n    while( 1 ){\n      bool found = false;\n      rep(i,op[0].size()) if( parse[pos] == op[0][i] ) found = true;\n      if( !found ) break;\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else if( parse[pos] == '-' ){pos++;p-=term();}\n      else { pos++; p*=term();}\n    }\n    return p;\n  } \n \n};\n\nint main(){\n  string s;\n  cin >> s;\n  ll maxi = -LLINF;\n  rep(i,3) rep(j,3) rep(k,3) {\n    Parsing par(s);\n    rep(l,3) op[l].clear();\n    op[i].push_back('+');\n    op[j].push_back('-');\n    op[k].push_back('*');\n    maxi = max(maxi,par.expression());\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\nll bnf();\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll calc(int c){\n  ll res;\n  if(S[p]=='(') p++,res=bnf(),p++;\n  else res=getNum();\n  while(1){  \n   \n    if(S[p]==')'||p==S.size()||ch[S[p]]<=ch[c])return res;\n  int nc=S[p];\n  if(S[p]=='*')p++,res*=calc(nc);\n  else if(S[p]=='+')p++,res+=calc(nc);\n  else if(S[p]=='-')p++,res-=calc(nc);\n\n}\n\n  return res;\n}\n\nll bnf(){\n  ll res;\n  if(S[p]=='(')p++,res=bnf(),p++;\n  else  res=getNum();\n  \n  while(p<(int)S.size()){\n    if(S[p]=='+')res+=calc(S[p++]);\n    else if(S[p]=='-')res-=calc(S[p++]);\n    else if(S[p]=='*')res*=calc(S[p++]);\n    else break;\n    \n  }\n  return res;\n}\n\nint main(){\n  cin>>S; \n\n  ll res=bnf();\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,bnf());\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int =long long;\n\nint p=0;\nInt formula(string& s,int turn);\nvector<char> op[3];\n\nInt calc(Int lhs,Int rhs,char op){\n    if(op=='+') return lhs+rhs;\n    if(op=='-') return lhs-rhs;\n    if(op=='*') return lhs*rhs;\n    throw(\"what calc\");\n}\n\nInt num(string& s){\n    Int res=0;\n    int op=1;\n    if(s[p]=='-'){\n        op=-1;\n        p++;\n    }\n    else if(s[p]=='+'){\n        op=1;\n        p++;\n    }\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return op*res;\n}\n\nInt term(string & s){\n    if(s[p]=='('){\n        p++;\n        Int res=formula(s,0);\n        p++;\n        return res;\n    }\n    return num(s);\n}\n\nInt formula(string& s,int turn){\n    if(turn==3) return term(s);\n    Int res=formula(s,turn+1);\n    while(p!=s.size() && s[p]!=')'){\n        bool breaker=false;\n        for(int i=0;i<turn;i++){\n            for(int j=0;j<op[i].size();j++){\n                if(op[i][j]==s[p]){\n                    breaker=true;\n                }\n            }\n        }\n        if(breaker) break;\n        char ops=s[p];\n        p++;\n        Int next=formula(s,turn+1);\n        res=calc(res,next,ops);\n    }\n    return res;\n}\nint main(){\n    string s;\n    cin>>s;    \n    Int res=0;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                op[0].clear();\n                op[1].clear();\n                op[2].clear();\n                op[i].push_back('+');\n                op[j].push_back('-');\n                op[k].push_back('*');\n                p=0;\n                Int ret=formula(s,0);\n                res=max(res,ret);\n            }\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\n\nclass Calc {\n  private:\n    string str;\n    vector<char> p;\n    string::iterator it;\n\n  public:\n    Calc (string str, vector<char> p) {\n        this->str = str;\n        this->p   = p;\n        it = this->str.begin();\n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n    }\n\n    ll f0(int pt)\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            if (pt == 0) {\n                res = f3(0);\n            } else if (pt <= 2) {\n                res = f2(pt);   \n            } else {\n                res = f1(3);\n            }\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n\n    ll f1(int pt)\n    {\n        ll res = f0(pt);\n        while (*it == p[0] ||\n               (pt >= 2 && *it == p[1]) ||\n               (pt >= 3 && *it == p[2])) {\n            \n            if (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(pt));\n            } else if (pt >= 2 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f0(pt));\n            } else if (pt >= 3 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f0(pt));\n            }            \n        }\n        return res;\n    }\n\n    ll f2(int pt)\n    {\n        ll res = f1(pt);\n        while ((pt <= 1 && *it == p[1]) ||\n               (pt >= 1 && *it == p[2])) {\n            \n            if (pt <= 1 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1(pt));                                \n            } else if (pt >= 1 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f1(pt));                \n            }\n                   \n        }\n        return res;\n    }\n\n    ll f3(int pt)\n    {\n        ll res = f2(0);\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2(0));\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;      \n    vector<char> p = {'*', '+', '-'};\n    ll res = LLONG_MIN;    \n    do {\n        for (int i = 0; i < 4; i++) {\n            Calc  c(str, p);\n            ll r = -1;\n            if (i == 0) {\n                r = c.f3(0);\n            } else if (i <= 2) {\n                r = c.f2(i);\n            } else {\n                r = c.f1(3);\n            }\n            res = max(res, r);\n        }\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//'+','_','*'\nint a[3];\nbool mark(char t) {\n\tif (t == '+' || t == '_' || t == '*')return true;\n\telse return false;\n}\nstring trans(string x) {\n\tint l = x.length();\n\trep(j, 3) {\n\t\trep(i, l) {\n\t\t\tif (x[i] == '+'&&a[0] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) + stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t\telse if (x[i] == '_'&&a[1] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) - stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\n\t\t\t}\n\t\t\telse if (x[i] == '*'&&a[2] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) * stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t}\n\t}\n\treturn x;\n}\nll ord(string x) {\n\tint l = x.length();\n\trep(i, l) {\n\t\tif (x[i] == ')') {\n\t\t\tint le = i-1;\n\t\t\twhile (x[le] != '(')le--;\n\t\t\tstring u = x.substr(le + 1, i - le - 1);\n\t\t\tint d = i - le + 1;\n\t\t\tstring nu = trans(u);\n\t\t\tint d2 = nu.length();\n\t\t\tx.erase(x.begin() + le, x.begin() + i + 1);\n\t\t\tx.insert(le, nu);\n\t\t\ti = le - 1;\n\t\t\tl = l - d + d2;\n\t\t}\n\t}\n\tll res = stoll(trans(x));\n\treturn res;\n}\nint main() {\n\tstring s; cin >> s;\n\tint len = s.length();\n\trep(i, len) {\n\t\tif (s[i] == '-')s[i] = '_';\n\t}\n\tll ma = -LLONG_MAX;\n\trep(x, 3) {\n\t\trep(y, 3) {\n\t\t\trep(z, 3) {\n\t\t\t\ta[0] = x; a[1] = y; a[2] = z;\n\t\t\t\tma = max(ma, ord(s));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int =__int128;\n\nint p=0;\nInt formula(string& s,int turn);\nvector<char> op[3];\n\nInt calc(Int lhs,Int rhs,char op){\n    if(op=='+') return lhs+rhs;\n    if(op=='-') return lhs-rhs;\n    if(op=='*') return lhs*rhs;\n    throw(\"what calc\");\n}\n\nInt num(string& s){\n    Int res=0;\n    int op=1;\n    if(s[p]=='-'){\n        op=-1;\n        p++;\n    }\n    else if(s[p]=='+'){\n        op=1;\n        p++;\n    }\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return op*res;\n}\n\nInt term(string & s){\n    if(s[p]=='('){\n        p++;\n        Int res=formula(s,0);\n        p++;\n        return res;\n    }\n    return num(s);\n}\n\nInt formula(string& s,int turn){\n    if(turn==3) return term(s);\n    Int res=formula(s,turn+1);\n    while(p!=s.size() && s[p]!=')'){\n        bool breaker=false;\n        for(int i=0;i<turn;i++){\n            for(int j=0;j<op[i].size();j++){\n                if(op[i][j]==s[p]){\n                    breaker=true;\n                }\n            }\n        }\n        if(breaker) break;\n        char ops=s[p];\n        p++;\n        Int next=formula(s,turn+1);\n        res=calc(res,next,ops);\n    }\n    return res;\n}\nint main(){\n    string s;\n    cin>>s;    \n    Int res=-1e20;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                op[0].clear();\n                op[1].clear();\n                op[2].clear();\n                op[i].push_back('+');\n                op[j].push_back('-');\n                op[k].push_back('*');\n                p=0;\n                Int ret=formula(s,0);\n                res=max(res,ret);\n            }\n        }\n    }\n    cout<<(long long)(res)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstring S;\nint N;\n\nLL C(int& i, VS& order);\nLL D(int& i, VS& order);\nLL E(int& i, VS& order);\nLL F(int& i, VS& order);\n\nLL C(int& i, VS& order){\n  LL res = D(i, order);\n  while(i < N && order[0].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = D(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL D(int& i, VS& order){\n  LL res = E(i, order);\n  while(i < N && order[1].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = E(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL E(int& i, VS& order){\n  LL res = F(i, order);\n  while(i < N && order[2].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = F(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\n\nLL F(int& i, VS& order){\n  LL res = 0;\n  if(S[i] == '('){\n\t++i;\n\tres = C(i, order);\n\t++i;\n  }\n  else{\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i]-'0');\n\t  ++i;\n\t}\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n  LL ans = 1ll<<63;\n\n  REP(i1,3){\n\tREP(i2,3){\n\t  REP(i3,3){\n\t\tint i = 0;\n\t\tVS ops(3);\n\t\tops[i1] += \"+\";\n\t\tops[i2] += \"-\";\n\t\tops[i3] += \"*\";\n\t\tmaxi(ans, C(i,ops));\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing State = string::const_iterator;\nclass ParseError{};\n\nlong long expr(State& begin,const long long& a,const long long& b,const long long& c);\nlong long term(State& begin,const long long& a,const long long& b,const long long& c);\nlong long term2(State& begin,const long long& a,const long long& b,const long long& c);\nlong long fact(State& begin,const long long& a,const long long& b,const long long& c);\nlong long number(State& begin,const long long& a,const long long& b,const long long& c);\n\nlong long expr(State& begin,const long long& a,const long long& b,const long long& c){\n    long long res = term(begin,a,b,c);\n    while(true){\n        if(*begin == '+' && a == 1){\n            begin++;\n            res += term(begin,a,b,c);\n        }else if(*begin == '-' && b == 1){\n            begin++;\n            res -= term(begin,a,b,c);\n        }else if(*begin == '*' && c == 1){\n            begin++;\n            res *= term(begin,a,b,c);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nlong long term(State& begin,const long long& a,const long long& b,const long long& c){\n    long long res = term2(begin,a,b,c);\n    while(true){\n        if(*begin == '+' && a == 2){\n            begin++;\n            res += term2(begin,a,b,c);\n        }else if(*begin == '-' && b == 2){\n            begin++;\n            res -= term2(begin,a,b,c);\n        }else if(*begin == '*' && c == 2){\n            begin++;\n            res *= term2(begin,a,b,c);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nlong long term2(State& begin,const long long& a,const long long& b,const long long& c){\n    long long res = fact(begin,a,b,c);\n    while(true){\n        if(*begin == '+' && a == 3){\n            begin++;\n            res += fact(begin,a,b,c);\n        }else if(*begin == '-' && b == 3){\n            begin++;\n            res -= fact(begin,a,b,c);\n        }else if(*begin == '*' && c == 3){\n            begin++;\n            res *= fact(begin,a,b,c);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nlong long fact(State& begin,const long long& a,const long long& b,const long long& c){\n    if(*begin == '('){\n        begin++;\n        long long res = expr(begin,a,b,c);\n        begin++;\n        return res;\n    }\n    return number(begin,a,b,c);\n}\n\nlong long number(State& begin,const long long& a,const long long& b,const long long& c){\n    long long res = 0;\n    while(isdigit(*begin)){\n        res *= 10;\n        res += *begin - '0';\n        begin++;\n    }\n    return res;\n}\n\nint main(){\n    string S;\n    cin >> S;\n    State begin = S.begin();\n    long long ans = expr(begin,1,1,1);\n    long long v[] = {1,2,3};\n    for(auto a:v)for(auto b:v)for(auto c:v){\n        begin = S.begin();\n        ans = max(ans,expr(begin,a,b,c));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tll res = -INFL;\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\tfor (auto level : levels) {\n\t\tstack<string> st;\n\t\tfor (string s : vs) {\n\t\t\tif (s == \")\") {\n\t\t\t\tstack<string> sent;\n\t\t\t\twhile (true) {\n\t\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\t\tif (top == \"(\")break;\n\t\t\t\t\tsent.push(top);\n\t\t\t\t}\n\t\t\t\tst.push(calc(level, sent));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s);\n\t\t\t}\n\t\t}\n\t\tstack<string> op;\n\t\twhile (!st.empty()) {\n\t\t\top.push(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tres = max(res, stoll(calc(level, op)));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = 9223372036854775808;\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\tif (sent.size() != 1)exit(1);\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tll res = -INFL;\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\tfor (auto level : levels) {\n\t\tstack<string> st;\n\t\tfor (string s : vs) {\n\t\t\tif (s == \")\") {\n\t\t\t\tstack<string> sent;\n\t\t\t\twhile (true) {\n\t\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\t\tif (top == \"(\")break;\n\t\t\t\t\tsent.push(top);\n\t\t\t\t}\n\t\t\t\tst.push(calc(level, sent));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s);\n\t\t\t}\n\t\t}\n\t\tstack<string> op;\n\t\twhile (!st.empty()) {\n\t\t\top.push(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tres = max(res, stoll(calc(level, op)));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int opst[27][3] = {\n\t{0,0,0},\n\t{0,0,1},\n\t{ 0,0,2 },\n\t{ 0,1,0 },\n\t{ 0,1,1 },\n\t{ 0,1,2 },\n\t{ 0,2,0 },\n\t{ 0,2,1 },\n\t{ 0,2,2 },\n\t{ 1,0,0 },\n\t{ 1,0,1 },\n\t{ 1,0,2 },\n\t{ 1,1,0 },\n\t{ 1,1,1 },\n\t{ 1,1,2 },\n\t{ 1,2,0 },\n\t{ 1,2,1 },\n\t{ 1,2,2 },\n\t{ 2,0,0 },\n\t{ 2,0,1 },\n\t{ 2,0,2 },\n\t{ 2,1,0 },\n\t{ 2,1,1 },\n\t{ 2,1,2 },\n\t{ 2,2,0 },\n\t{ 2,2,1 },\n\t{ 2,2,2 },\n};\n\nll calc(vector<ll> num, vector<int> op, int pri) {\n\tREP(n,3)\n\tREP(i,op.size()) {\n\t\tif (opst[pri][op[i]] == n) {\n\t\t\tif (op[i] == 0) {\n\t\t\t\tnum[i] += num[i + 1];\n\t\t\t}\n\t\t\telse if (op[i] == 1) {\n\t\t\t\tnum[i] -= num[i + 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[i] *= num[i + 1];\n\t\t\t}\n\t\t\tFOR(j, i + 1, num.size() - 1)\n\t\t\t\tnum[j] = num[j + 1];\n\t\t\tnum.resize(num.size() - 1);\n\t\t\tFOR(j, i, op.size() - 1)\n\t\t\t\top[j] = op[j + 1];\n\t\t\top.resize(op.size() - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn num[0];\n}\nll saiki(string s, int &idx, int pri) {\n\tvector<ll> num;\n\tvector<int> op;\n\twhile ((size_t)(idx) < s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tnum.push_back(saiki(s, idx, pri));\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn calc(num, op, pri);\n\t\t}\n\t\tif (isdigit(s[idx])) {\n\t\t\tll num2 = 0;\n\t\t\twhile ((size_t)idx < s.length() && isdigit(s[idx])) {\n\t\t\t\tnum2 *= 10;\n\t\t\t\tnum2 += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tnum.push_back(num2);\n\t\t\tcontinue;\n\t\t}\n\t\tint opn=0;\n\t\tif (s[idx] == '-')\n\t\t\topn = 1;\n\t\tif (s[idx] == '*')\n\t\t\topn = 2;\n\t\top.push_back(opn);\n\t\tidx++;\n\t}\n\treturn calc(num, op, pri);\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tll ma = 1;\n\tma <<= 62;\n\tma *= -1;\n\tREP(i, 27) {\n\t\tint idx = 0;\n\t\tma = max(ma,saiki(s, idx, i));\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = -(1LL << 60);\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoll(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -1e18;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring y[3],s;\nint p;\nlong long f(int x){\n\tif( x == 3 ){\n\t\tif( s[p] == '(' ){\n\t\t\tp++;\n\t\t\tlong long ans = f(0);\n\t\t\tp++;\n\t\t\treturn ans;\n\t\t}else{\n\t\t\tlong long ans = 0;\n\t\t\twhile( s[p] >= '0' && s[p] <= '9' )\n\t\t\t\tans = ans * 10 + s[p++] - '0';\n\t\t\treturn ans;\n\t\t}\n\t}else{\n\t\tlong long ans = f(x+1);\n\t\twhile( y[x].find(s[p]) != -1 ){\n\t\t\tif( s[p] == '+' ){\n\t\t\t\tp++;\n\t\t\t\tans += f(x+1);\n\t\t\t}else if( s[p] == '-' ){\n\t\t\t\tp++;\n\t\t\t\tans -= f(x+1);\n\t\t\t}else if( s[p] == '*' ){\n\t\t\t\tp++;\n\t\t\t\tans *= f(x+1);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main(){\n\tcin >> s;\n\ts += \"~\";\n\tlong long ans;\n\tint fl = 0;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\t\ty[0] = y[1] = y[2] = \"\";\n\t\t\t\ty[i] += \"+\";\n\t\t\t\ty[j] += \"-\";\n\t\t\t\ty[k] += \"*\";\n\t\t\t\tp = 0;\n\t\t\t\tif(!fl){\n\t\t\t\t\tans = f(0);\n\t\t\t\t\tfl =1;\n\t\t\t\t}else ans = max(ans,f(0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nmap< char, int > lev;\n\nlint calc(char op, lint a, lint b) {\n\tif (op == '+') return a + b;\n\tif (op == '-') return a - b;\n\treturn a * b;\n}\n\nlint parse(int l, int r, const string& S) {\n\tint open_cnt = 0, close_cnt = 0, nxt_l = -1;\n\tlint num = 0;\n\t\n\tstack< lint > stk_val;\n\tstack< char > stk_op;\n\t\n\tfor_(i,l,r) {\n\t\tif (open_cnt == close_cnt) {\n\t\t\tif (isdigit(S[i])) {\n\t\t\t\tnum = 10 * num + (S[i] - '0');\n\t\t\t} else if (S[i] == '(') {\n\t\t\t\t++open_cnt;\n\t\t\t\tnxt_l = i+1;\n\t\t\t} else if (S[i] == '$') {\n\t\t\t\tstk_val.push(num);\n\t\t\t\tnum = 0;\n\t\t\t} else {\n\t\t\t\tchar op = S[i];\n\t\t\t\twhile (!stk_op.empty() && lev[stk_op.top()] >= lev[op]) {\n\t\t\t\t\tchar pre = stk_op.top(); stk_op.pop();\n\t\t\t\t\tlint b = stk_val.top(); stk_val.pop();\n\t\t\t\t\tlint a = stk_val.top(); stk_val.pop();\n\t\t\t\t\tstk_val.push(calc(pre, a, b));\n\t\t\t\t}\n\t\t\t\tstk_op.push(op);\n\t\t\t}\n\t\t} else {\n\t\t\tif (S[i] == '(') ++open_cnt;\n\t\t\tif (S[i] == ')') {\n\t\t\t\t++close_cnt;\n\t\t\t\tif (open_cnt == close_cnt) stk_val.push(parse(nxt_l, i, S));\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!stk_op.empty()) {\n\t\tchar op = stk_op.top(); stk_op.pop();\n\t\tlint b = stk_val.top(); stk_val.pop();\n\t\tlint a = stk_val.top(); stk_val.pop();\n\t\tstk_val.push(calc(op, a, b));\n\t}\n\t\n\treturn stk_val.top();\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tS += '#';\n\t\n\tint m = S.size();\n\tfor_(i,0,m-1) {\n\t\tif (isdigit(S[i]) && !isdigit(S[i+1])) {\n\t\t\tS = S.substr(0,i+1) + \"$\" + S.substr(i+1);\n\t\t\tm = S.size();\n\t\t}\n\t}\n\tS = S.substr(0, m-1);\n\t\n\tlint ans = 0;\n\tfor_(i,0,3) for_(j,0,3) for_(k,0,3) {\n\t\tlev['+'] = i;\n\t\tlev['-'] = j;\n\t\tlev['*'] = k;\n\t\tans = max(ans, parse(0, (int)S.size(), S));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  if(p>=s.size())return res;\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  if(p>=s.size())return res;\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  if(p>=s.size())return res;\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=0;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\n\nclass Calc {\n  private:\n    string str;\n    vector<char> p;\n    string::iterator it;\n\n  public:\n    Calc (string str, vector<char> p) {\n        this->str = str;\n        this->p   = p;\n        it = this->str.begin();\n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n\n    ll f0(int pt)\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            if (pt == 0) {\n                res = f3(0);\n            } else if (pt <= 2) {\n                res = f2(pt);   \n            } else {\n                res = f1(3);\n            }\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n\n    ll f1(int pt)\n    {\n        ll res = f0(pt);\n        if (pt == 0) {\n            while (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(0));\n            }\n        } else if (pt == 1) {\n            while (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(1));\n            }\n        } else if (pt == 2) {\n            while (*it == p[0] || *it == p[1]) {\n                if (*it == p[0]) {\n                    ++it;\n                    res = get_val(res, p[0], f0(2));                \n                } else {                               \n                    ++it;\n                    res = get_val(res, p[1], f0(2));                \n                }\n            }\n        } else {\n            while (*it == p[0] || *it == p[1] || *it == p[2]) {\n                if (*it == p[0]) {\n                    ++it;\n                    res = get_val(res, p[0], f0(3));                \n                } else if (*it == p[1]) {                               \n                    ++it;\n                    res = get_val(res, p[1], f0(3));                \n                } else {\n                    ++it;\n                    res = get_val(res, p[2], f0(3));                \n                }\n            }\n        }            \n        return res;\n    }\n\n    ll f2(int pt)\n    {\n        ll res = f1(pt);\n        if (pt == 0) {\n            while (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1(0));\n            }\n        } else if (pt == 1) {\n            while (*it == p[1] || *it == p[2]) {\n                if (*it == p[1]) {\n                    ++it;\n                    res = get_val(res, p[1], f1(1));                \n                } else {                               \n                    ++it;\n                    res = get_val(res, p[2], f1(1));                \n                }\n            }\n        } else if (pt == 2) {\n            while (*it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f1(2));                \n            }\n        }\n        return res;\n    }\n\n    ll f3(int pt)\n    {\n        ll res = f2(0);\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2(0));\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;      \n    vector<char> p = {'*', '+', '-'};\n    ll res = LLONG_MIN;    \n    do {\n        for (int i = 0; i < 4; i++) {\n            Calc  c(str, p);\n            ll r = -1;\n            if (i == 0) {\n                r = c.f3(0);\n            } else if (i <= 2) {\n                r = c.f2(i);\n            } else {\n                r = c.f1(3);\n            }\n            res = max(res, r);\n        }\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef __int128_t ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nmap<char, ll> pri;\nstring op = \"+-*\";\nstring s;\nll pos = 0;\nbool end() {\n    return pos == s.size();\n}\nvoid read_char(char c) {\n    assert(!end() && s[pos] == c);\n    ++pos;\n}\nll parse(ll);\nll number() {\n    if (s[pos] == '(') {\n        read_char('(');\n        ll res = parse(0);\n        read_char(')');\n        return res;\n    }\n    else {\n        string res = \"\";\n        while ( !end() && isdigit(s[pos]) ) {\n            res += s[pos++];\n        }\n        return stoll(res);\n    }\n}\nll parse(ll oid) {\n    if (oid == op.size()) return number();\n    ll res = parse(oid+1);\n    while ( !end() && pri.count(s[pos]) > 0 && pri[s[pos]] == oid ) {\n        char op = s[pos];\n        read_char(op);\n        ll right = parse(oid+1);\n        switch (op) {\n            case '*': res *= right; break;\n            case '+': res += right; break;\n            case '-': res -= right; break;\n        }\n    }\n    return res;\n}\nll parse() {\n    pos = 0;\n    return parse(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    ll ans = -linf;\n    rep(a, 3) rep(b, 3) rep(c, 3) {\n        vector<ll> v{a, b, c};\n        // vector<ll> v{2, 1, 1};\n        rep(i, 3) pri[op[i]] = v[i];\n        chmax(ans, parse());\n    }\n    cout << (long long)ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <limits>\nusing namespace std;\n\nchar op[3];\nint64_t expr0(string &S, int &i);\nint64_t expr1(string &S, int &i);\nint64_t expr2(string &S, int &i);\nint64_t factor(string &S, int &i);\nint64_t number(string &S, int &i);\n\nint64_t expr0(string &S, int &i){\n    int64_t ret = expr1(S,i);\n    while(true){\n        if(S[i]==op[0]){\n            i++;\n            switch(op[0]){\n                case '+':\n                    ret+=expr1(S,i);\n                    break;\n                case '-':\n                    ret-=expr1(S,i);\n                    break;\n                case '*':\n                    ret*=expr1(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'A'<<ret<<endl;\n    return ret;\n}\nint64_t expr1(string &S, int &i){\n    int64_t ret = expr2(S,i);\n    while(true){\n        if(S[i]==op[1]){\n            i++;\n            switch(op[1]){\n                case '+':\n                    ret+=expr2(S,i);\n                    break;\n                case '-':\n                    ret-=expr2(S,i);\n                    break;\n                case '*':\n                    ret*=expr2(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'B'<<ret<<endl;\n    return ret;\n}\nint64_t expr2(string &S, int &i){\n    int64_t ret = factor(S,i);\n    while(true){\n        if(S[i]==op[2]){\n            i++;\n            switch(op[2]){\n                case '+':\n                    ret+=factor(S,i);\n                    break;\n                case '-':\n                    ret-=factor(S,i);\n                    break;\n                case '*':\n                    ret*=factor(S,i);\n                    break;\n            }\n        }else{\n            break;\n        }\n    }\n    // cout<<'C'<<ret<<endl;\n    return ret;\n}\n\nint64_t factor(string &S, int &i){\n    int64_t ret;\n    if(S[i]=='('){\n        i++;\n        ret = expr0(S,i);\n        i++;\n    }else{\n        ret = number(S,i);\n    }\n    return ret;\n}\n\nint64_t number(string &S, int &i){\n    int64_t ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    cin>>S;\n    vector<char> V;\n    V.push_back('+');\n    V.push_back('-');\n    V.push_back('*');\n    sort(V.begin(), V.end());\n    int64_t ans=numeric_limits<int64_t>::min();\n    do{\n        for(int i=0;i<3;i++) op[i]=V[i];\n        int i=0;\n        ans = max(ans, expr0(S,i));\n    }while(next_permutation(V.begin(),V.end()));\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <limits>\n\nintmax_t parse_int(std::string const& s, size_t& i) {\n  assert(isdigit(s[i]));\n  intmax_t res = s[i]-'0';\n  while (isdigit(s[++i]))\n    res = res*10 + s[i]-'0';\n  return res;\n}\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  if (op == '+') return lhs + rhs;\n  if (op == '-') return lhs - rhs;\n  if (op == '*') return lhs * rhs;\n  assert(false);\n}\n\nintmax_t parse(std::string const& s, size_t& i, std::vector<std::string> const& ops, size_t preced = 0) {\n  if (preced == ops.size()) {\n    if (isdigit(s[i])) return parse_int(s, i);\n    if (s[i] == '(') {\n      intmax_t res = parse(s, ++i, ops, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    assert(false);\n  }\n  intmax_t res = parse(s, i, ops, preced+1);\n  while (i < s.length()) {\n    char op = s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    res = apply(res, op, parse(s, ++i, ops, preced+1));\n  }\n  return res;\n}\n\nint main() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string s = buf;\n\n  intmax_t res = std::numeric_limits<intmax_t>::min();\n  for (size_t i = 0; i < 3; ++i) {\n    for (size_t j = 0; j < 3; ++j) {\n      for (size_t k = 0; k < 3; ++k) {\n        std::vector<std::string> ops(3);\n        ops[i].push_back('+');\n        ops[j].push_back('-');\n        ops[k].push_back('*');\n        while (ops.back().empty()) ops.pop_back();\n        bool valid = true;\n        for (auto const& opsi: ops) {\n          if (opsi.empty()) {\n            valid = false;\n            break;\n          }\n        }\n        if (!valid) continue;\n\n        size_t p = 0;\n        res = std::max(res, parse(s, p, ops));\n      }\n    }\n  }\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\n\trep(i,3)rep(j,op.size())rep(k,3)if(a[k]==i&&op[j]==w[k]){\n\t\tchar c=w[k];\n\t\tif(c=='+')in[j]+=in[j+1];\n\t\tif(c=='-')in[j]-=in[j+1];\n\t\tif(c=='*')in[j]*=in[j+1];\n\t\tin.erase(in.begin()+j+1);\n\t\top.erase(op.begin()+j);\n\t\tj--;break;\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-9223372036854775808ll;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tt=0;\n\t\ta=vi{i,j,k};\n\t\tout=max(out,expr());\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tPlus,\n\tMinus,\n\tMult,\n};\n\nint loc[128];\n\nll calc_two_same(char line[202],int rank[3],int maximum){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('&& rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nll calc_three_same(char line[202]){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_all_different(char line[202],int rank[3],int maximum){\n\n\tint work_line_length,work_rank[3];\n\tll tmp,op1,work,count,work2,work_tmp;\n\tchar calc,work_line[202];\n\tstack<ll> NUM,work_num;\n\tstack<ll> to_make_work;\n\tqueue<ll> work_num2;\n\tstack<char> OP,work_op;\n\tqueue<char> work_op2;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{ //??°?????§????????´???\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '(' && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint maximum;\n\tloc['+'] = 0;\n\tloc['-'] = 1;\n\tloc['*'] = 2;\n\n\tchar line[202];\n\tint length;\n\n\tint appear_num[128];\n\tappear_num['+'] = 0;\n\tappear_num['-'] = 0;\n\tappear_num['*'] = 0;\n\n\tscanf(\"%s\",line);\n\tfor(length = 0; line[length] != '\\0';length++){\n\t\tif(line[length] == '+'){\n\t\t\tappear_num['+']++;\n\t\t}else if(line[length] == '-'){\n\t\t\tappear_num['-']++;\n\t\t}else if(line[length] == '*'){\n\t\t\tappear_num['*']++;\n\t\t}\n\t}\n\n\tline[length] = '=';\n\tline[length+1] = '\\0';\n\n\tint rank[3],num[3];\n\tll ans = -9223372036854775808,tmp_ans;\n\n\tif(appear_num['+'] > 0 && appear_num['-'] > 0 && appear_num['*'] > 0){\n\t\tfor(int a = 0; a <= 2; a++){\n\t\t\tfor(int b = 0; b <= 2; b++){\n\t\t\t\tfor(int c = 0; c <= 2; c++){\n\n\t\t\t\t\tfor(int i = 0; i < 3; i++)num[i] = 0;\n\n\t\t\t\t\trank[Plus] = a;\n\t\t\t\t\trank[Minus] = b;\n\t\t\t\t\trank[Mult] = c;\n\n\t\t\t\t\tmaximum = -1;\n\t\t\t\t\tmaximum = max(a,max(b,c));\n\n\t\t\t\t\tnum[a]++;\n\t\t\t\t\tnum[b]++;\n\t\t\t\t\tnum[c]++;\n\n\t\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\t\ttmp_ans = calc_all_different(line,rank,maximum);\n\t\t\t\t\t}else if(num[0] == 3 || num[1] == 3 || num[2] == 3){\n\t\t\t\t\t\ttmp_ans = calc_three_same(line);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_ans = calc_two_same(line,rank,maximum);\n\t\t\t\t\t}\n\t\t\t\t\tans = max(ans,tmp_ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else if(appear_num['+'] == 0 && appear_num['-'] > 0 && appear_num['*'] > 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 1;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 1;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else if(appear_num['+'] > 0 && appear_num['-'] == 0 && appear_num['*'] > 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 1;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 1;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else if(appear_num['+'] > 0 && appear_num['-'] > 0 && appear_num['*'] == 0){\n\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t\trank[Plus] = 0;\n\t\trank[Minus] = 1;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t\trank[Plus] = 1;\n\t\trank[Minus] = 0;\n\t\trank[Mult] = 0;\n\t\ttmp_ans = calc_two_same(line,rank,1);\n\t\tans = max(ans,tmp_ans);\n\n\t}else{\n\t\ttmp_ans = calc_three_same(line);\n\t\tans = max(ans,tmp_ans);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1||a[1]==2||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1||a[1]==3||a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2||a[1]==1||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2||a[1]==3||a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3||a[1]==1||a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3||a[1]==2||a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\n// ll expression();\n\n// ll factor() {\n//     if (S[cur] != '(') {\n//         return number();\n//     }\n//     cur++;\n//     int n = expression();\n//     assert(S[cur] == ')');\n//     cur += 1;\n//     return n;\n// }\n\n// ll term() {\n//     ll a = factor();\n//     while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n//         char op = S[cur];\n//         cur++;\n//         ll b = factor();\n//         if (op == '*') {\n//             a *= b;\n//         } else {\n//             a /= b;\n//         }\n//     }\n//     return a;\n// }\n\n// ll expression() {\n//     ll a = term();\n//     while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n//         char op = S[cur];\n//         cur++;\n//         ll b = term();\n//         if (op == '+') {\n//             a += b;\n//         } else {\n//             a -= b;\n//         }\n//     }\n//     return a;\n// }\n\nstring S;\nll cur = 0;\n\nint digit() {\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0';\n    cur++;\n    return n;\n}\n\nll number() {\n    ll n = digit();\n    while (cur < (ll)S.size() && isdigit(S[cur])) {\n        n = n * 10 + digit();\n    }\n    return n;\n}\n\nll solve(ll c1, ll c2, ll c3, ll dep);\n\nll factor(ll c1, ll c2, ll c3) {\n    ll n;\n    if (S[cur] == '(') {\n        cur++;\n        n = solve(c1, c2, c3, 0);\n        assert(S[cur] == ')');\n        cur += 1;\n    } else {\n        n = number();\n    }\n    return n;\n}\n\nll solve(ll c1, ll c2, ll c3, ll dep) {\n    ll a;\n    if (dep < 3) {\n        a = solve(c1, c2, c3, dep + 1);\n    } else {\n        a = factor(c1, c2, c3);\n    }\n    while (cur < (ll)S.size() && ((S[cur] == '+' && c1 == dep) ||\n        (S[cur] == '-' && c2 == dep) || (S[cur] == '*' && c3 == dep))) {\n        char c = S[cur];\n        cur++;\n        ll b;\n        if (dep < 3) {\n            b = solve(c1, c2, c3, dep + 1);\n        } else {\n            b = factor(c1, c2, c3);\n        }\n        if (c == '+') {\n            a += b;\n        } else if (c == '-') {\n            a -= b;\n        } else if (c == '*') {\n            a *= b;\n        }\n    }\n    return a;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> S;\n    ll ans = llmin;\n    REP(i, 0, 3) {\n        REP(j, 0, 3) {\n            REP(k, 0, 3) {\n                cur = 0;\n                ll num = solve(i, j, k, 0);\n                // cout << num << endl;\n                ans = max(ans, num);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\n\nclass Calc {\n  private:\n    string str;\n    vector<char> p;\n    string::iterator it;\n\n  public:\n    Calc (string str, vector<char> p) {\n        this->str = str;\n        this->p   = p;\n        it = this->str.begin();\n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n    }\n\n    ll f0(int pt)\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            if (pt == 0) {\n                res = f3(0);\n            } else if (pt <= 2) {\n                res = f2(pt);   \n            } else {\n                res = f1(3);\n            }\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n\n    ll f1(int pt)\n    {\n        ll res = f0(pt);\n        while (*it == p[0] ||\n               (pt >= 2 && *it == p[1]) ||\n               (pt >= 3 && *it == p[2])) {\n            \n            if (*it == p[0]) {\n                ++it;            \n                res = get_val(res, p[0], f0(pt));\n            } else if (pt >= 2 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f0(pt));\n            } else if (pt >= 3 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f0(pt));\n            }            \n        }\n        return res;\n    }\n\n    ll f2(int pt)\n    {\n        ll res = f1(pt);\n        while ((pt <= 1 && *it == p[1]) ||\n               (pt >= 1 && *it == p[2])) {\n            \n            if (pt <= 1 && *it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1(pt));                                \n            } else if (pt >= 1 && *it == p[2]) {\n                ++it;\n                res = get_val(res, p[2], f1(pt));                \n            }\n                   \n        }\n        return res;\n    }\n\n    ll f3(int pt)\n    {\n        ll res = f2(0);\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2(0));\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;      \n    vector<char> p = {'*', '+', '-'};\n    ll res = LLONG_MIN;    \n    do {\n        for (int i = 0; i < 4; i++) {\n            Calc  c(str, p);\n            ll r = -1;\n            if (i == 0) {\n                r = c.f3(0);\n            } else if (i <= 2) {\n                r = c.f2(i);\n            } else {\n                r = c.f1(3);\n            }\n            res = max(res, r);\n        }\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n#define rep(i, n) for(int i=0; i<(int)n; i++)\n\nusing namespace std;\n\nstring s;\n\nbool cmp(const pair<int, int> &x, const pair<int, int> &y)\n{\n\tif (x.first != y.first){\n\t\treturn x.first > y.first;\n\t}else{\n\t\treturn x.second < y.second;\n\t}\n}\n\nll calc(int a, int b, int c)\n{\n\tvector<ll> number;\n\tvector<char> ope;\n\t//priority, index\n\tvector<pair<int, int> > priority;\n\n\tint nest=0;\n\trep(idx, s.size()){\n\t\tif (s[idx]=='(') nest++;\n\t\tif (s[idx]==')') nest--;\n\t\tif ('0'<=s[idx] && s[idx]<='9'){\n\t\t\tstring temp=\"\"; temp += s[idx++];\n\t\t\twhile('0'<=s[idx] && s[idx]<='9'){\n\t\t\t\ttemp += s[idx];\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tnumber.push_back(stoll(temp));\n\t\t\tidx--;\n\t\t}\n\t\tif (s[idx]=='+'){\n\t\t\tope.push_back(s[idx]);\n\t\t\tpriority.push_back(make_pair(nest*10+a, priority.size()));\n\t\t}\n\t\tif (s[idx]=='-'){\n\t\t\tope.push_back(s[idx]);\n\t\t\tpriority.push_back(make_pair(nest*10+b, priority.size()));\n\t\t}\n\t\tif (s[idx]=='*'){\n\t\t\tope.push_back(s[idx]);\n\t\t\tpriority.push_back(make_pair(nest*10+c, priority.size()));\n\t\t}\n \t}\n \tvector<bool> use(ope.size(), false);\n \tsort(priority.begin(), priority.end(), cmp);\n \t\n \t/*rep(i, ope.size()){\n \t\tcout << ope[priority[i].second] << \", \" << priority[i].first << \", \" << priority[i].second << endl;\n \t}\n \tcout << endl;*/\n \t\n \tint size = ope.size();\n\n \trep(i, size){\n \t\tint index = priority[i].second;\n \t\tuse[index] = true; \n \t\tint isize = index;\n \t\trep(j, isize){\n \t\t\tif (use[j]) index--;\n \t\t}\n \t\tif (ope[index]=='+'){\n \t\t\tll res = number[index]+number[index+1];\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.insert(number.begin()+index, res);\n \t\t\t//cout << res << endl;\n \t\t}\n \t\tif (ope[index]=='-'){\n \t\t\tll res = number[index]-number[index+1];\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.insert(number.begin()+index, res);\n \t\t\t//cout << res << endl;\n \t\t}\n \t\tif (ope[index]=='*'){\n \t\t\tll res = number[index]*number[index+1];\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.erase(number.begin()+index);\n \t\t\tnumber.insert(number.begin()+index, res);\n \t\t\t//cout << res << endl;\n \t\t}\n \t\tope.erase(ope.begin()+index);\n \t}\n\treturn number[0];\n}\n\nint main()\n{\n\tcin>>s;\n\tll maxi = LONG_LONG_MIN;\n\trep(i, 3)rep(j, 3)rep(k, 3){\n\t\t//cout << i << \", \" << j << \", \" << k << endl;\n\t\tmaxi = max(maxi, calc(i, j, k));\n\t\t//cout << endl;\n\t}\n\tcout << maxi << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n//0:+, 1:-, 2:*\n\nstring s;\nint ind;\nvs in;\n\nint number(){\n  int ret = 0;\n  while(isdigit(s[ind])){\n    ret *= 10;\n    ret += s[ind] - '0';\n    ind++;\n  }\n  return ret;\n}\n\nint f(int a, int b, char c){\n    if(c == '+')return a+b;\n    if(c == '-')return a-b;\n    if(c == '*')return a*b;\n}\n\n\nint expression(int id){\n\n    if(id == in.size()){\n        if(s[ind] == '('){\n            ind++;\n            int ret = expression(0);\n            ind++;\n            return ret;\n        }else{\n            return number();\n        }\n    }\n\n    int ret = expression(id+1);\n    while(ind < s.size()){\n        bool c = true;\n        rep(i,in[id].size()){\n            char op = s[ind];\n            if(op == in[id][i]){\n                ind++;\n                ret = f(ret,expression(id+1),op);\n                c = false;\n                break;\n            }\n        }\n        if(c)break;\n    }\n    return ret;\n}\n\n\nsigned main(void) {\n    vector<vs> vvs;\n    rep(i,3)rep(j,3)rep(k,3){\n        vs t(3);\n        t[i] += '+';\n        t[j] += '-';\n        t[k] += '*';\n        int id = 0;\n        while(id < t.size()){\n            if(t[id].empty())t.erase(t.begin()+id);\n            else id++;\n        }\n        vvs.push_back(t);\n    }\n    cin >> s;\n    int ans = -(1LL<<63);\n    rep(i,vvs.size()){\n        ind = 0;\n        in = vvs[i];\n        int ret = expression(0);\n        ans = max(ans, ret);\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nmap<char, int> op;\n\nll term(State&, int);\nll number(State&);\n\nll calc(ll x, char c, ll y){\n    if (c == '+') x += y;\n    if (c == '-') x -= y;\n    if (c == '*') x *= y;\n    return x;\n}\n\nll term(State &begin, int d){\n    ll ret;\n    if (d < 4) ret = term(begin, d+1);\n    while (1){\n        if (d == 4){\n            if (*begin == '('){\n                begin++;\n                ll ret = term(begin, 1);\n                begin++;\n                return ret;\n            }else{\n                return number(begin);\n            }\n        }else if (op[*begin] == d){\n            char c = *begin;\n            begin++;\n            ret = calc(ret, c, term(begin, d+1));\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nll number(State &begin){\n    int ret = 0;\n    while (isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    ll res = 0;\n    bool f = 1;\n    string s;\n    cin >> s;\n    REP(i,3) REP(j,3) REP(k,3){\n        op['+'] = i+1;\n        op['-'] = j+1;\n        op['*'] = k+1;\n        State begin = s.begin();\n        if (f) res = term(begin, 1), f = 0;\n        else res = max(res, term(begin, 1));\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoll(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -9223372036854775807;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nlong long number(State&);\nlong long factor(State&,vector<long long>);\nlong long expr3(State&,long long,vector<long long>);\nlong long expr2(State&,long long,vector<long long>);\nlong long expr1(State&,long long,vector<long long>);\n\nvector<vector<long long>> v;\n\n// ??°??????????????????????????????????????°????????????\nlong long number(State &begin) {\n    long long ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nlong long factor(State &begin, vector<long long> v) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        long long ret = expr1(begin,0,v);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\nlong long expr3(State &begin, long long i, vector<long long> v) {\n    long long ret = factor(begin,v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += factor(begin,v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= factor(begin,v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= factor(begin,v);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nlong long expr2(State &begin, long long i, vector<long long> v) {\n    long long ret = expr3(begin, 2, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += expr3(begin, 2, v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= expr3(begin, 2, v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= expr3(begin, 2, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\nlong long expr1(State &begin, long long i, vector<long long> v) {\n    long long ret = expr2(begin, 1, v);\n\n    for (;;) {\n        if (*begin == '+' && v[i] & 1) {\n            begin++;\n            ret += expr2(begin, 1, v);\n        } else if (*begin == '-' && v[i] & 2) {\n            begin++;\n            ret -= expr2(begin, 1, v);\n        } else if (*begin == '*' && v[i] & 4){\n            begin++;\n            ret *= expr2(begin, 1, v);\n        } else {\n            break;\n        }\n\n    }\n\n    return ret;\n}\n\n\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint main(){\n    vector<long long> num = {1,2,4};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,3,4};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,5,2};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,6,1};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n    num = {0,0,7};\n    do{ v.emplace_back(num); }while(next_permutation(all(num))); \n\n    string s;\n    cin >> s;\n\n    long long ans = 0;\n    rep(i,v.size()){\n        State tmp = s.begin();\n        ans = max(ans, expr1(tmp, 0, v[i]));\n        assert(tmp == s.end());\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2613&lang=jp\ntypedef long long ll;\nusing namespace std;\n#define LINF 1LL<<60;\nll solve(string expr, map<char, ll>& op);\nll check(int& i, string& expr);\n\nll solve(string expr, map<char, ll>& op) {\n\n\t/* <expr> <op> <expr> ??? ( <expr> <op> <expr> )*/\n\tfor (int p = 1; p <= 3;p++) {\n\t\tfor (int i = 0; i < (int)expr.length();i++) {\n\t\t\tif (expr[i] >= '0' && expr[i] <= '9')continue;\n\t\t\tif (op[expr[i]] != p) continue;\n\n\t\t\tint parentheses = 0;\n\t\t\tfor (int left = i - 1; left >= 0; left--) {\n\t\t\t\tif (left == 0) { expr = \"(\" + expr; i++; break; }\n\t\t\t\tif (expr[left] >= '0' && expr[left] <= '9')continue;\n\t\t\t\tif (expr[left] == ')') { parentheses++; }\n\t\t\t\tif (expr[left] == '(') { parentheses--; }\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + left + 1, '('); i++; break;\n\t\t\t}\n\t\t\tparentheses = 0;\n\t\t\tfor (int right = i + 1; right < expr.length();right++) {\n\t\t\t\tif (right == expr.length() - 1) { expr = expr + \")\"; break; }\n\t\t\t\tif (expr[right] >= '0' && expr[right] <= '9')continue;\n\t\t\t\tif (expr[right] == '(') { parentheses++;}\n\t\t\t\tif (expr[right] == ')') { parentheses--;}\n\t\t\t\tif (parentheses > 0) continue;\n\t\t\t\texpr.insert(expr.begin() + right, ')'); break;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << op['+'] << \" \" << op['-'] << \" \" << op['*'] << endl;\n\t//cout << expr << endl;\n\tint i = 0;\n\tll ret = check(i, expr);\n\t//cout << ret << endl;\n\treturn ret;\n}\n\nll check(int& i, string& expr) {\n\tll l_expr, r_expr;\n\tif (expr[i] == '(') {\n\t\t/* \"( ~ )\" op ~ */\n\t\ti++;\n\t\tl_expr = check(i, expr);\n\t}\n\telse {\n\t\t/* \"number\" op ~ */\n\t\tl_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tl_expr = l_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\t/* (expr) or (number) */\n\tchar option;\n\tif (i == expr.length() || expr[i] == ')') { i++; return l_expr; }\n\telse {\n\t\toption = expr[i];\n\t\ti++;\n\t}\n\n\tif (expr[i] == '(') {\n\t\t/* ~ op \"( ~ )\"*/\n\t\ti++;\n\t\tr_expr = check(i, expr);\n\t}\n\telse {\n\t\t/* ~ op \"number\" */\n\t\tr_expr = 0;\n\t\twhile (expr[i] >= '0' && expr[i] <= '9') {\n\t\t\tr_expr = r_expr * 10 + (expr[i] - '0');\n\t\t\ti++;\n\t\t}\n\t}\n\tif (expr[i] == ')') {\n\t\ti++;\n\t\tif (option == '+') return l_expr + r_expr;\n\t\tif (option == '-') return l_expr - r_expr;\n\t\tif (option == '*') return l_expr * r_expr;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring expr; cin >> expr;\n\tmap<char, ll> op; op['('] = op[')'] = 0;\n\n\tll ans = -LINF;\n\tfor (int i = 1; i <= 3;i++) {\n\t\tfor (int j = 1; j <= 3;j++) {\n\t\t\tfor (int k = 1; k <= 3;k++) {\n\t\t\t\tif (i != 1 && j != 1 && k != 1) continue;\n\t\t\t\tint x = 0;\n\t\t\t\top['+'] = i; op['-'] = j; op['*'] = k;\n\t\t\t\tans = max(ans, solve(expr, op));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n\nlong long parse_int(const std::string &s, size_t &i) {\n    long long res=0;\n    while (s[i] >= '0' && s[i] <= '9') \n        res = res*10 + s[i++]-'0';\n\n    return res;\n}\n\nlong long operate(long long lhs, char op, long long rhs) {\n    if (op == '+') {\n        return lhs + rhs;\n    } else if (op == '-') {\n        return lhs - rhs;\n    } else if (op == '*') {\n        return lhs * rhs;\n    } else {\n        assert(0);  // tsurai\n        return -123456789;  // not reached\n    }\n}\n\nlong long parse_expr(const std::string &s, size_t &i, const std::vector<std::string> &ops, int prec) {\n    if (ops[prec].empty()) {\n        if (s[i] == '(') {\n            long long tmp=parse_expr(s, ++i, ops, 0);\n            s[++i];  // ')'\n            return tmp;\n        } else {\n            return parse_int(s, i);\n        }\n    }\n\n    long long res=parse_expr(s, i, ops, prec+1);\n    while (i < s.length()) {\n        if (!std::count(ops[prec].begin(), ops[prec].end(), s[i]))\n            return res;\n\n        char op=s[i++];\n        long long tmp=parse_expr(s, i, ops, prec+1);\n        res = operate(res, op, tmp);\n    }\n\n    return res;\n}\n\nint main() {\n    char buf[256];\n    scanf(\"%s\", buf);\n    std::string s=buf;\n\n    char oplist[256]={};\n    long long res=-1e18;\n    for (int i=0; i<27; ++i) {\n        oplist['+'] = i % 3;\n        oplist['-'] = (i/3) % 3;\n        oplist['*'] = (i/9) % 3;\n\n        std::vector<std::string> ops(4);\n        for (char c: {'+', '-', '*'})\n            ops[oplist[int(c)]].push_back(c);\n\n        if (ops[0].empty()) continue;\n        if (ops[0].length() < 3 && ops[1].empty()) continue;\n\n        size_t index=0;\n        res = std::max(res, parse_expr(s, index, ops, 0));\n    }\n\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nchar op[3] = {'+', '-', '*'};\n\nint pos;\nstring s;\n\nll expr1();\nll expr2();\nll expr3();\nll number();\n\nll expr1() {\n  ll ret = expr2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += expr2();\n      else if(op[0] == '*') pos++, ret *= expr2();\n      else if(op[0] == '-') pos++, ret -= expr2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr2() {\n  ll ret = expr3();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += expr3();\n      else if(op[1] == '*') pos++, ret *= expr3();\n      else if(op[1] == '-') pos++, ret -= expr3();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr3() {\n  ll ret;\n  if(s[pos]=='(') {\n    pos++;\n    ret = expr1();\n    cout << \"expr3 \" << ret << endl;\n    pos++;\n  } else {\n    ret = number();\n  }\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += number();\n      else if(op[2] == '*') pos++, ret *= number();\n      else if(op[2] == '-') pos++, ret -= number();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll number() {\n  ll ret = 0;\n  while(pos < s.size() && isdigit(s[pos])) {\n    ret *= 10;\n    ret += s[pos]-'0';\n    pos++;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> s;\n\n  ll ans = -LLINF;\n  sort(op, op+3);\n  do {\n    cout << op[0] << \" \" << op[1] << \" \" << op[2] << endl;\n    pos = 0;\n    ll ret = expr1();\n    chmax(ans, ret);\n    cout << ret << endl;\n  } while(next_permutation(op, op+3));\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\ntypedef struct ParserState {\n    int pos, len;\n    std::string str;\n    std::deque<int> stack;\n\n    bool isEOF() {return pos >= len;}\n    bool isNotEOF() {return pos < len;}\n\n    char getCh() {\n        return pos < len ? str[pos++] : -1;\n    }\n    char seek() {\n        return pos < len ? str[pos] : -1;\n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n    std::string lookAhead(int l) {\n        return str.substr(pos, l);\n    }\n\n    void setBackrack(){stack.push_front(pos);}\n    bool backtrack(){\n        if(stack.empty()) return false;\n        pos = stack.front();\n        stack.pop_front();\n        return true;\n    }\n\n    bool isDigit(){return isDigit(0);}\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha(){return isUpperAlpha(0);}\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha(){return isLowerAlpha(0);}\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'a' && c <= 'z';\n    }\n}State;\n\nstd::map<char,int> pri;\nint bot = 0;\n\nLL parseNumber(State*);\nLL parse(State*);\n\nLL calc(char op, LL left, LL right) {\n    if(op == '+') return left + right;\n    if(op == '-') return left - right;\n    if(op == '*') return left * right;\n    return assert(pri.count(op) > 0), -1;\n}\n\nLL parseNumber(State* state) {\n    LL res = 0LL;\n    while(state->isNotEOF() && state->isDigit()) {\n        res *= 10;\n        res += (int)(state->getCh() - '0');\n    }\n    return res;\n}\n\nLL parse(int level, State* state) {\n    if(bot < level) {\n        if(state->isDigit()) return parseNumber(state);\n\n        state->getCh(); // eat (\n        LL r = parse(0, state);\n        state->getCh(); // eat )\n        return r;\n    }\n\n    LL result = parse(level + 1, state);\n    while(state->isNotEOF() && state->seek() != ')') {\n        char ch = state->seek();\n        if(pri[ch] < level) break;\n        state->getCh(); //eat op\n\n        LL res = parse(level + 1, state);\n        result = calc(ch, result, res);\n\n        if(state->isEOF()) break;\n    }\n    return result;\n}\n\nint main() {\n    std::string S;\n    std::cin >> S;\n    int len = S.length();\n\n    LL ans = std::numeric_limits<LL>::min();\n    for(int i=0; i<27; ++i) {\n        pri['+'] = i     % 3;\n        pri['-'] = (i/3) % 3;\n        pri['*'] = (i/9) % 3;\n        bot = std::max(i%3, std::max((i/3)%3, (i/9)%3));\n\n        State state = State{0, len, S};\n        LL res = parse(0, &state);\n\n        ans = std::max(ans, res);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int =long long;\n\nint p=0;\nInt formula(string& s,int turn);\nvector<char> op[3];\n\nInt calc(Int lhs,Int rhs,char op){\n    if(op=='+') return lhs+rhs;\n    if(op=='-') return lhs-rhs;\n    if(op=='*') return lhs*rhs;\n    throw(\"what calc\");\n}\n\nInt num(string& s){\n    Int res=0;\n    int op=1;\n    if(s[p]=='-'){\n        op=-1;\n        p++;\n    }\n    else if(s[p]=='+'){\n        op=1;\n        p++;\n    }\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return op*res;\n}\n\nInt term(string & s){\n    if(s[p]=='('){\n        p++;\n        Int res=formula(s,0);\n        p++;\n        return res;\n    }\n    return num(s);\n}\n\nInt formula(string& s,int turn){\n    if(turn==3) return term(s);\n    Int res=formula(s,turn+1);\n    while(p!=s.size() && s[p]!=')'){\n        bool breaker=false;\n        for(int i=0;i<turn;i++){\n            for(int j=0;j<op[i].size();j++){\n                if(op[i][j]==s[p]){\n                    breaker=true;\n                }\n            }\n        }\n        if(breaker) break;\n        char ops=s[p];\n        p++;\n        Int next=formula(s,turn+1);\n        res=calc(res,next,ops);\n    }\n    return res;\n}\nint main(){\n    string s;\n    cin>>s;    \n    Int res=-1e18;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                op[0].clear();\n                op[1].clear();\n                op[2].clear();\n                op[i].push_back('+');\n                op[j].push_back('-');\n                op[k].push_back('*');\n                p=0;\n                Int ret=formula(s,0);\n                res=max(res,ret);\n            }\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\nvoid debug(vector<int> v){\n\treturn;\n\tlp(i,v.size()){\n\t\tif(v[i]==RK)cout<<\")\";\n\t\telse if(v[i]==LK)cout<<\"(\";\n\t\telse if(v[i]==PL)cout<<\"+\";\n\t\telse if(v[i]==MI)cout<<\"-\";\n\t\telse if(v[i]==KA)cout<<\"*\";\n\t\telse cout<<v[i];\n\t}\n\tcout<<endl;\n}\n\nbool isnum(int n){\n\tif(n%100000000000==0){\n\t\tif(2<=n/100000000000&&n/100000000000<=6)\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid remk(vector<int> &v){\n\twhile(1){\n\t\tint ch=0;\n\t\tfor(int i=1;i<v.size()-1;i++){\n\t\t\tif(isnum(v[i])&&v[i-1]==LK&&v[i+1]==RK){\n\t\t\t\tv[i-1]=v[i];\n\t\t\t\tv.erase(v.begin()+i);\n\t\t\t\tv.erase(v.begin()+i);\n\t\t\t}\n\t\t}\n\t\tif(ch==0)return;\n\t}\n}\n\nbool solve(int c,int d,int e,vector<int> &v){\n\t//cout<<c<<\" \"<<d<<\" \"<<e<<endl;;\n\tdebug(v);\n\tint check=0;\n\tint pl=0;\n\tlp(i,v.size()){\n\t\tif(v[i]==LK){\n\t\t\tpl=i;\n\t\t}\n\t}\n\tfor(int i=pl;i<v.size();i++){\n\t\tif(v[i]==RK)break;\n\t\tif(v[i]==c&&isnum(v[i-1])&&isnum(v[i+1])){\n\t\t\tcheck=1;\n\t\t\tif(c==PL){\n\t\t\t\tv[i-1]+=v[i+1];\n\t\t\t}\n\t\t\tif(c==MI){\n\t\t\t\tv[i-1]-=v[i+1];\n\t\t\t}\n\t\t\tif(c==KA){\n\t\t\t\tv[i-1]*=v[i+1];\n\t\t\t}\n\t\t\tv.erase(v.begin()+i);\n\t\t\tv.erase(v.begin()+i);\n\t\t\ti--;\n\t\t}\n\t\tif(v[i]==d&&d!=-1&&isnum(v[i-1])&&isnum(v[i+1])){\n\t\t\tcheck=1;\n\t\t\tif(d==PL){\n\t\t\t\tv[i-1]+=v[i+1];\n\t\t\t}\n\t\t\tif(d==MI){\n\t\t\t\tv[i-1]-=v[i+1];\n\t\t\t}\n\t\t\tif(d==KA){\n\t\t\t\tv[i-1]*=v[i+1];\n\t\t\t}\n\t\t\tv.erase(v.begin()+i);\n\t\t\tv.erase(v.begin()+i);\n\t\t\ti--;\n\t\t}\n\t\tif(v[i]==e&&e!=-1&&isnum(v[i-1])&&isnum(v[i+1])){\n\t\t\tcheck=1;\n\t\t\tif(e==PL){\n\t\t\t\tv[i-1]+=v[i+1];\n\t\t\t}\n\t\t\tif(e==MI){\n\t\t\t\tv[i-1]-=v[i+1];\n\t\t\t}\n\t\t\tif(e==KA){\n\t\t\t\tv[i-1]*=v[i+1];\n\t\t\t}\n\t\t\tv.erase(v.begin()+i);\n\t\t\tv.erase(v.begin()+i);\n\t\t\ti--;\n\t\t}\n\t}\n\tremk(v);\n\tdebug(v);\n\tif(check==0)return false;\n\treturn true;\n}\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tvector<int> v={PL,MI,KA};\n\tvector<int> val;\n\tint num=0;\n\tint mode=0;\n\tlp(i,s.size()){\n\t\tif('0'<=s[i]&&s[i]<='9'){\n\t\t\tmode=1;\n\t\t\tnum*=10;\n\t\t\tnum+=s[i]-'0';\n\t\t}\n\t\telse{\n\t\t\tif(mode==1){\n\t\t\t\tval.push_back(num);\n\t\t\t\tnum=0;\n\t\t\t\tmode=0;\n\t\t\t}\n\t\t\tif(s[i]=='(')val.push_back(LK);\n\t\t\tif(s[i]==')')val.push_back(RK);\n\t\t\tif(s[i]=='+')val.push_back(PL);\n\t\t\tif(s[i]=='-')val.push_back(MI);\n\t\t\tif(s[i]=='*')val.push_back(KA);\n\t\t}\n\t}\n\tif(mode==1){\n\t\t\t\tval.push_back(num);\n\t\t\t\tnum=0;\n\t\t\t\tmode=0;\n\t}\n\tint ans=KA;\n\tdo{\n\t\t//cout<<v<<endl;\n\t\tvector<int> vs=val;\n\t\tdo{\n\t\t\tdo{\n\t\t\t\tdo{\n\n\t\t\t\t}while(solve(v[0],-1,-1,vs));\n\t\t\t}while(solve(v[1],-1,-1,vs));\n\t\t}while(solve(v[2],-1,-1,vs));\n\t\tint ve=vs[0];\n\t\t//cout<<val<<\" \"<<v<<endl;\n\t\tif(ans==KA)ans=ve;\n\t\telse{\n\t\t\tans=max(ans,ve);\n\t\t}\n\n\t\tvs=val;\n\t\tdo{\n\t\t\tdo{\n\n\t\t\t}while(solve(v[1],v[0],-1,vs));\n\t\t}while(solve(v[2],-1,-1,vs));\n\t\tve=vs[0];\n\t\t//cout<<val<<\" \"<<v<<endl;\n\t\tans=max(ans,ve);\n\t\t//return 0;\t\t\n\t\tvs=val;\n\t\tdo{\n\t\t\tdo{\n\n\t\t\t}while(solve(v[0],-1,-1,vs));\n\t\t}while(solve(v[2],v[1],-1,vs));\n\t\tve=vs[0];\n\t\t//cout<<val<<\" \"<<v<<endl;\n\t\tans=max(ans,ve);\n\t\t//return 0;\n\t\tvs=val;\n\t\tdo{\n\t\t}while(solve(v[2],v[1],v[0],vs));\n\t\tve=vs[0];\n\t\t//cout<<val<<\" \"<<v<<endl;\n\t\tans=max(ans,ve);\n\t\t//return 0;\n\t}\n\twhile(next_permutation(all(v)));\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\n\trep(i,3)rep(j,op.size())rep(k,3)if(a[k]==i&&op[j]==w[k]){\n\t\tchar c=w[k];\n\t\tif(c=='+')in[j]+=in[j+1];\n\t\tif(c=='-')in[j]-=in[j+1];\n\t\tif(c=='*')in[j]*=in[j+1];\n\t\tin.erase(in.begin()+j+1);\n\t\top.erase(op.begin()+j);\n\t\tj--;break;\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-inf;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tt=0;\n\t\ta=vi{i,j,k};\n\t\tout=max(out,expr());\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\ntypedef struct ParserState {\n    int pos, len;\n    std::string str;\n    std::deque<int> stack;\n\n    bool isEOF() {return pos >= len;}\n    bool isNotEOF() {return pos < len;}\n\n    char getCh() {\n        return pos < len ? str[pos++] : -1;\n    }\n    char seek() {\n        return pos < len ? str[pos] : -1;\n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n    std::string lookAhead(int l) {\n        return str.substr(pos, l);\n    }\n\n    void setBackrack(){stack.push_front(pos);}\n    bool backtrack(){\n        if(stack.empty()) return false;\n        pos = stack.front();\n        stack.pop_front();\n        return true;\n    }\n\n    bool isDigit(){return isDigit(0);}\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha(){return isUpperAlpha(0);}\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha(){return isLowerAlpha(0);}\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'a' && c <= 'z';\n    }\n}State;\n\nstd::map<char,int> pri;\n\nLL parseNumber(State*);\nLL parse(State*);\n\nLL calc(char op, LL left, LL right) {\n    if(op == '+') return left + right;\n    if(op == '-') return left - right;\n    if(op == '*') return left * right;\n    return assert(pri.count(op) > 0), -1;\n}\n\n\nint bot = 0;\nLL parseNumber(State* state) {\n    LL res = 0LL;\n    while(state->isNotEOF() && state->isDigit()) {\n        res *= 10;\n        res += (int)(state->getCh() - '0');\n    }\n    return res;\n}\n\nLL parse(int level, State* state) {\n    if(bot < level) {\n        if(state->isDigit()) return parseNumber(state);\n\n        state->getCh(); // eat (\n        LL r = parse(0, state);\n        state->getCh(); // eat )\n        return r;\n    }\n\n    LL result = parse(level + 1, state);\n    while(state->isNotEOF() && state->seek() != ')') {\n        char ch = state->seek();\n        if(pri[ch] < level) break;\n        state->getCh(); //eat op\n\n        LL res = parse(level + 1, state);\n        result = calc(ch, result, res);\n\n        if(state->isEOF()) break;\n    }\n    return result;\n}\n\nint main() {\n    std::string S;\n    std::cin >> S;\n    int len = S.length();\n\n    LL ans = std::numeric_limits<LL>::min();\n    for(int i=0; i<27; ++i) {\n        pri['+'] = i     % 3;\n        pri['-'] = (i/3) % 3;\n        pri['*'] = (i/9) % 3;\n        bot = std::max(i%3, std::max((i/3)%3, (i/9)%3));\n\n        State state = State{0, len, S};\n        LL res = parse(0, &state);\n\n        ans = std::max(ans, res);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = 9223372036854775808ll;\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\tif (sent.size() != 1)exit(1);\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tll res = -INFL;\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\tfor (auto level : levels) {\n\t\tstack<string> st;\n\t\tfor (string s : vs) {\n\t\t\tif (s == \")\") {\n\t\t\t\tstack<string> sent;\n\t\t\t\twhile (true) {\n\t\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\t\tif (top == \"(\")break;\n\t\t\t\t\tsent.push(top);\n\t\t\t\t}\n\t\t\t\tst.push(calc(level, sent));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.push(s);\n\t\t\t}\n\t\t}\n\t\tstack<string> op;\n\t\twhile (!st.empty()) {\n\t\t\top.push(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tres = max(res, stoll(calc(level, op)));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = -(1LL << 63);\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long opnum[3] = {0}, n;\nstring s;\n\nlong long solve();\nlong long calc(int &id, int p);\nlong long number(int &id);\n\nint main() {\n  cin >> s;\n  n = s.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = 0;\n  for(int i = 0; i < 3; ++i)\n    for(int j = 0; j < 3; ++j)\n      for(int k = 0; k < 3; ++k) {\n        int id = 0;\n        opnum[0] = i;\n        opnum[1] = j;\n        opnum[2] = k;\n        if(i == j && j == k && i == 0)\n          ans = calc(id, 0);\n        else\n          ans = max(ans, calc(id, 0));\n        assert(id == n);\n      }\n  return ans;\n}\n\nlong long calc(int &id, int p) {\n  long long res = 0;\n  if(p != 2)\n    res = calc(id, p + 1);\n  else\n    res = number(id);\n  while(id < n) {\n    if(s[id] == '+' && opnum[0] == p) {\n      ++id;\n      if(p != 2)\n        res += calc(id, p + 1);\n      else\n        res += number(id);\n    }\n    else if(s[id] == '-' && opnum[1] == p) {\n      ++id;\n      if(p != 2)\n        res -= calc(id, p + 1);\n      else\n        res -= number(id);\n    }\n    else if(s[id] == '*' && opnum[2] == p) {\n      ++id;\n      if(p != 2)\n        res *= calc(id, p + 1);\n      else\n        res *= number(id);\n    }\n    else\n      break;\n  }\n  return res;\n}\nlong long number(int &id) {\n  long long res = 0;\n  if(s[id] == '(') {\n    res = calc(++id, 0);\n    assert(s[id] == ')');\n    ++id;\n  }\n  else {\n    assert(id < n && isdigit(s[id]));\n    while(id < n && isdigit(s[id])) {\n      res *= 10;\n      res += s[id++] - '0';\n    }\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long STOI(string V) {\n    int LEN = V.size();\n    if (LEN == 0) { return 0; }\n    return (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return STOI(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = -999999999999999999; S+=\"=\";\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nvoid cal(int &a, char op, int b) {\n\tif (op == '+')a += b;\n\telse if (op == '-')a -= b;\n\telse if (op == '*')a *= b;\n\telse assert(1 == 0);\n}\n\nclass Parser1 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser1(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2<op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{op2,c};\n\tc=d,{op3,d};\n\td='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret = d();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, d());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint d() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser2 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser2(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2<op3\n\tEBNF\n\ta=b,{(op1|op2),b};\n\tb=c,{op3,c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser3 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser3(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2==op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{(op2|op3),c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser4 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser4(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2==op3\n\tEBNF\n\ta=b,{(op1|op2|op3),b};\n\tb='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nsigned main() {\n\tstring s; getline(cin, s);\n\ts += \"$\";\n\tint ans;\n\tvector<char> op = { '+','-','*' };\n\tsort(all(op));\n\tbool first = false;\n\tdo {\n\t\tParser1 P1(s.begin(), op[0], op[1], op[2]);\n\t\tParser2 P2(s.begin(), op[0], op[1], op[2]);\n\t\tParser3 P3(s.begin(), op[0], op[1], op[2]);\n\t\tParser4 P4(s.begin(), op[0], op[1], op[2]);\n\t\tif (first)ans = max({ ans, P1.a(),P2.a(),P3.a(),P4.a() });\n\t\telse ans = max({ P1.a(),P2.a(),P3.a(),P4.a() });\n\t} while (next_permutation(op.begin(), op.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstring s;\nvs ord(3);\nint p;\n\nll op0();\n\nll num()\n{\n\tll res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nll unit()\n{\n\tll res;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = op0();\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tres = num();\n\t}\n\treturn res;\n}\n\nll op2()\n{\n\tll res = unit();\n\twhile (ord[2].find(s[p]) != -1)\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = unit();\n\t\t\tres += rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = unit();\n\t\t\tres -= rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '*')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = unit();\n\t\t\tres *= rhs;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn res;\n}\n\nll op1()\n{\n\tll res = op2();\n\twhile (ord[1].find(s[p]) != -1)\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op2();\n\t\t\tres += rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op2();\n\t\t\tres -= rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '*')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op2();\n\t\t\tres *= rhs;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn res;\n}\n\nll op0()\n{\n\tll res = op1();\n\twhile (ord[0].find(s[p]) != -1)\n\t{\n\t\tif (s[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op1();\n\t\t\tres += rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '-')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op1();\n\t\t\tres -= rhs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[p] == '*')\n\t\t{\n\t\t\tp++;\n\t\t\tll rhs = op1();\n\t\t\tres *= rhs;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn res;\n}\n\nll parse() //+-*\n{\n\tp = 0;\n\treturn op0();\n}\n\nint main()\n{\n\tcin >> s;\n\tll ans = LLONG_MIN;\n\tREP(i, 3)REP(j, 3)REP(k, 3)\n\t{\n\t\tord.clear();\n\t\tord.resize(3);\n\t\tord[i] += '+';\n\t\tord[j] += '-';\n\t\tord[k] += '*';\n\t\tll res = parse();\n\t\tchmax(ans, res);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr char OP[] = {'+', '-', '*'};\nint p[] = {0, 0, 0};\nll Plus(const ll a, const ll b) { return a + b; }\nll Minus(const ll a, const ll b) { return a - b; }\nll Prod(const ll a, const ll b) { return a * b; }\nusing Func = ll (*)(const ll, const ll);\nFunc f[] = {Plus, Minus, Prod};\nstring S;\nint pos;\n\nll expr();\nll number()\n{\n    ll ans = 0;\n    for (; pos < S.size() and isdigit(S[pos]); pos++) { ans = ans * 10LL + S[pos] - '0'; }\n    return ans;\n}\nll atom()\n{\n    const char c = S[pos];\n    if (c == '(') {\n        pos++;\n        const ll sub = expr();\n        return pos++, sub;\n    } else {\n        return number();\n    }\n}\nll factor()\n{\n    ll ans = atom();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 2) {\n                pos++;\n                const ll sub = atom();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nll term()\n{\n    ll ans = factor();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 1) {\n                pos++;\n                const ll sub = factor();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nll expr()\n{\n    ll ans = term();\n    for (bool fin = false; not fin and pos < S.size();) {\n        fin = true;\n        for (int i = 0; i < 3; i++) {\n            if (S[pos] == OP[i] and p[i] == 0) {\n                pos++;\n                const ll sub = term();\n                fin = false, ans = f[i](ans, sub);\n            }\n        }\n    }\n    return ans;\n}\nint main()\n{\n    cin >> S;\n    ll ans = numeric_limits<ll>::min();\n    for (p[0] = 0; p[0] < 3; p[0]++) {\n        for (p[1] = 0; p[1] < 3; p[1]++) {\n            for (p[2] = 0; p[2] < 3; p[2]++) {\n                pos = 0;\n                const ll sub = expr();\n                ans = max(ans, sub);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoll(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -1e18;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\tvector<char> ve;\n\tstring s;\n\tint aite[210];\nint yaru(int a,int b,char c){\n\tif(c=='+')return a+b;\n\tif(c=='*')return a*b;\n\tif(c=='-')return a-b;\n\telse exit(1);\n}\n\t\nint saiki(int l,int r){\n\tif(aite[l]==r){\n\t\treturn saiki(l+1,r-1);\n\t}\n\tint lev=0;\n\tint a[3]={-inf,-inf,-inf};\n\tfor(int i=l;i<=r;i++){\n\t\tif(s[i]=='(')lev++;\n\t\tif(s[i]==ve[0] && lev==0)a[0]=max(a[0],i);\n\t\tif(s[i]==ve[1] && lev==0)a[1]=max(a[1],i);\n\t\tif(s[i]==ve[2] && lev==0)a[2]=max(a[2],i);\n\t\tif(s[i]==')')lev--;\n\t}\n\t\tint z=max({a[0],a[1],a[2]});\n\tif(z==-inf){\n\t\treturn stoi(s.substr(l,r-l+1));\n\t}\n\tfor(int i=0;i<3;i++)if(a[i]>-inf){\n\t\tint l1=saiki(l,a[i]-1);\n\t\tint l2=saiki(a[i]+1,r);\n\t\treturn yaru(l1,l2,ve[i]);\n\t}\n\tcout<<\"out\"<<endl;\n\texit(1);\n}\n\t\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n\n \tcin>>s;\n \n \tve.pb('*');\n \tve.pb('-');\n \tve.pb('+');\n \tsort(ve.begin(),ve.end());\n \tvector<int> ans;\n \tint l=s.length();\n \tstack<int> st;\n \tfor(int i=0;i<l;i++)aite[i]=-1;\n \tfor(int i=0;i<l;i++){\n \t\tif(s[i]=='('){\n \t\t\tst.push(i);\n \t\t}\n \t\tif(s[i]==')'){\n \t\t\tint z=st.top();\n \t\t\tst.pop();\n \t\t\taite[z]=i;\n \t\t\taite[i]=z;\n \t\t}\n \t}\n \tdo{\n \t\t\n \t\tint y=saiki(0,l-1);\n \t//\tcout<<ve[0]<<\" \"<<ve[1]<<\" \"<<ve[2]<<\"   \"<<y<<endl;\n \t\tans.pb(y);\n \t\t\n \t}while(next_permutation(ve.begin(),ve.end()));\n \tsort(ans.begin(),ans.end());\n \tcout<<ans.back()<<endl;\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s,w=\"+-*\";\nint t;\nvi a{0,1,2};\nll number(){\n\tint out=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tout*=10;\n\t\tout+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn out;\n}\nll expr(){\n\tvi in;\n\tvector<char>op;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tin.pb(expr());\n\t\t}else if(s[t]==')'){\n\t\t\tbreak;\n\t\t}else if(isdigit(s[t])){\n\t\t\tin.pb(number());\n\t\t\tt--;\n\t\t}else op.pb(s[t]);\n\t\tt++;\n\t}\n\n\trep(i,3)rep(j,op.size())rep(k,3)if(a[k]==i&&op[j]==w[k]){\n\t\tchar c=w[k];\n\t\tif(c=='+')in[j]+=in[j+1];\n\t\tif(c=='-')in[j]-=in[j+1];\n\t\tif(c=='*')in[j]*=in[j+1];\n\t\tin.erase(in.begin()+j+1);\n\t\top.erase(op.begin()+j);\n\t\tj--;break;\n\t}\n\treturn in[0];\n}\nint main(){\n\tcin>>s;\n\tll out=-9223372036854775807;\n\trep(i,3)rep(j,3)rep(k,3){\n\t\tt=0;\n\t\ta=vi{i,j,k};\n\t\tout=max(out,expr());\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<limits>\n\nusing namespace std;\n\n#define int long long\n\nvector<int> x(3);\n\n/*\nnumer 0\n( 1\n) 2\n+ 3\n- 4\n* 5\n*/\n\nchar temp[] = {'n', '(', ')', '+', '-', '*'};\n\nint solve(vector<pair<int,int>> t, int b, int e){\n\tvector<pair<int,int>> t2;\n\t\n\tfor(int i = b, depth = 0, index = -1; i < e; i++){\n\t\tswitch(t[i].first) {\n\t\t\tcase 1: \n\t\t\t\tif(depth == 0) {\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdepth--; \n\t\t\t\tif(depth == 0) {\n\t\t\t\t\tt2.push_back({0, solve(t, index+1, i)});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: if(!depth) t2.push_back(t[i]);\n\t\t}\n\t}\n\tfor(int k = 0; k < 3; k++) {\n\t\n\t\tvector<pair<int,int>> st;\n\t\t\n\t\tfor(int i = 0, depth = 0, index = -1; i < t2.size(); i++){\n\t\t\tst.push_back(t2[i]);\n\t\t\tpair<int,int> a, b, c;\n\t\t\t\n\t\t\twhile(st.size() >= 3) {\n\t\t\t\ta = st.back(); st.pop_back();\n\t\t\t\tb = st.back(); st.pop_back();\n\t\t\t\tc = st.back(); st.pop_back();\n\t\t\t\t\n\t\t\t\tif(!b.first){\n\t\t\t\t\tst.push_back(c);\n\t\t\t\t\tst.push_back(b);\n\t\t\t\t\tst.push_back(a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 3) {\n\t\t\t\t\tif(x[0] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second + a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 4) {\n\t\t\t\t\tif(x[1] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second - a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(b.first == 5) {\n\t\t\t\t\tif(x[2] == k) {\n\t\t\t\t\t\tst.push_back({0,c.second * a.second});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tst.push_back(c);\n\t\t\t\t\t\tst.push_back(b);\n\t\t\t\t\t\tst.push_back(a);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t\n\t\tif(k == 2) {\n\t\t\treturn st.back().second;\n\t\t} else {\n\t\t\tt2 = st;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nvoid hoge(string &s, vector<pair<int,int>> &t){\n\t\n\tfor(int i = 0, num = 0; i < s.size(); i++){\n\t\tswitch(s[i]) {\n\t\t\tcase '(': t.push_back({1,0}); break;\n\t\t\tcase ')': t.push_back({2,0}); break;\n\t\t\tcase '+': t.push_back({3,0}); break;\n\t\t\tcase '-': t.push_back({4,0}); break;\n\t\t\tcase '*': t.push_back({5,0}); break;\n\t\t\tdefault : \n\t\t\t\tnum = num * 10 + s[i] - '0';\n\t\t\t\tif(i + 1 == s.size() || '0' > s[i+1] && s[i+1]){\n\t\t\t\t\tt.push_back({0,num});\n\t\t\t\t\tnum = 0;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\t\n\tvector<pair<int,int>> t;\n\tstring s;\n\t\n\tint ans =  numeric_limits<long long>::min();\n\t\n\tcin>>s;\n\t\n\thoge(s, t);\n\t\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tx[0] = i;\n\t\t\t\tx[1] = j;\n\t\t\t\tx[2] = k;\n\t\t\t\tans = max(solve(t, 0, t.size()), ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n\nll get_val(ll a, char op, ll b)\n{\n    switch (op) {\n        case '*':\n            return a * b;\n        case '+':\n            return a + b;\n        case '-':\n            return a - b;                \n    }\n    assert(0);\n}\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n      \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f3();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n         \n    ll f3()\n    {\n        ll res = f2();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n        }\n        return res;\n    }\n};\n \nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n   \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n  \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n \nclass Calc22 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc22(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n     \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n  \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n \nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n    \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n          \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f1();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1] || *it == p[2]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else if (*it == p[1]) {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            } else {\n                ++it;\n                res = get_val(res, p[2], f0());                \n            }\n        }\n        return res;\n    }\n};\n \nint main()\n{\n    string str;\n    cin >> str;\n     \n    vector<char> p = {'*', '+', '-'};\n \n    ll res = LLONG_MIN;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc22 c22(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(max(c.f3(), c2.f2()), max(c22.f2(), c3.f1())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint ts[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && T.find(S[idx]) != string::npos && ts[T.find(S[idx])] == 2) {\n    char op = S[idx++];\n    auto get = ei();\n    ret = calc(ret, op, get);\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && T.find(S[idx]) != string::npos && ts[T.find(S[idx])] == 1) {\n    char op = S[idx++];\n    auto get = beet();\n    ret = calc(ret, op, get);\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && T.find(S[idx]) != string::npos && ts[T.find(S[idx])] == 0) {\n    char op = S[idx++];\n    auto get = malta();\n    ret = calc(ret, op, get);\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(ts[0] = 0; ts[0] < 3; ts[0]++) {\n    for(ts[1] = 0; ts[1] < 3; ts[1]++) {\n      for(ts[2] = 0; ts[2] < 3; ts[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#include<array>\n#include<climits>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long Int;\ntypedef string::const_iterator Itr;\n\narray<int,3> flag;\n\nInt ctoi(const char &c)\n{\n\treturn c - '0';\n}\n\nInt expression(Itr &);\nInt term(Itr &);\nInt term2(Itr &);\nInt factor(Itr &);\nInt number(Itr &);\n\nInt expression(Itr &itr)\n{\n\tInt ret = term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+' && flag[0]==0)\n\t\t{\n\t\t\titr++;\n\t\t\tret += term(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= term(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= term(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term(Itr &itr)\n{\n\tInt ret = term2(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret += term2(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= term2(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= term2(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term2(Itr &itr)\n{\n\tInt ret = factor(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret += factor(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= factor(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= factor(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt factor(Itr &itr)\n{\n\tInt ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = number(itr);\n\t}\n\n\treturn ret;\n}\n\nInt number(Itr &itr)\n{\n\tInt ret = 0;\n\n\twhile (isdigit(*itr))\n\t{\n\t\tret *= 10;\n\t\tret += ctoi(*itr);\n\t\titr++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin, s);\n\ts.append(\"_\");\n\n\tInt max_ans = -LLONG_MIN;\n\n\tREP(i,3)REP(j,3)REP(k,3)\n\t{\n\t\tflag[0] = i;\n\t\tflag[1] = j;\n\t\tflag[2] = k;\n\t\tItr begin = s.begin();\n\t\tInt ans = expression(begin);\n\t\tif (max_ans < ans)\n\t\t{\n\t\t\tmax_ans = ans;\n\t\t}\n\t}\n\tcout << max_ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        return -1;\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10;\n\t\tres += *it - '0';\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        return -1;\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        res = max(res, max(c.f3(), c2.f2()));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\nll bnf();\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res,t;\n  if(S[p]=='(') p++,res=bnf(),p++;\n  else res=getNum();\n  while(p<S.size()&&S[p]!=')'&&ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nll bnf(){\n  ll res=calc(-1),t;\n  while(p<S.size()&&S[p]!=')')t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  ll res=bnf();\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,bnf());\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nmap< char, int > lev;\n\nlint calc(char op, lint a, lint b) {\n\tif (op == '+') return a + b;\n\tif (op == '-') return a - b;\n\treturn a * b;\n}\n\nlint parse(int l, int r, const string& S) {\n\tint open_cnt = 0, close_cnt = 0, nxt_l = -1;\n\tlint num = 0;\n\t\n\tstack< lint > stk_val;\n\tstack< char > stk_op;\n\t\n\tfor_(i,l,r) {\n\t\tif (open_cnt == close_cnt) {\n\t\t\tif (isdigit(S[i])) {\n\t\t\t\tnum = 10 * num + (S[i] - '0');\n\t\t\t} else if (S[i] == '(') {\n\t\t\t\t++open_cnt;\n\t\t\t\tnxt_l = i+1;\n\t\t\t} else if (S[i] == '$') {\n\t\t\t\tstk_val.push(num);\n\t\t\t\tnum = 0;\n\t\t\t} else {\n\t\t\t\tchar op = S[i];\n\t\t\t\twhile (!stk_op.empty() && lev[stk_op.top()] >= lev[op]) {\n\t\t\t\t\tchar pre = stk_op.top(); stk_op.pop();\n\t\t\t\t\tlint b = stk_val.top(); stk_val.pop();\n\t\t\t\t\tlint a = stk_val.top(); stk_val.pop();\n\t\t\t\t\tstk_val.push(calc(pre, a, b));\n\t\t\t\t}\n\t\t\t\tstk_op.push(op);\n\t\t\t}\n\t\t} else {\n\t\t\tif (S[i] == '(') ++open_cnt;\n\t\t\tif (S[i] == ')') {\n\t\t\t\t++close_cnt;\n\t\t\t\tif (open_cnt == close_cnt) stk_val.push(parse(nxt_l, i, S));\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!stk_op.empty()) {\n\t\tchar op = stk_op.top(); stk_op.pop();\n\t\tint b = stk_val.top(); stk_val.pop();\n\t\tint a = stk_val.top(); stk_val.pop();\n\t\tstk_val.push(calc(op, a, b));\n\t}\n\t\n\treturn stk_val.top();\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tS += '#';\n\t\n\tint m = S.size();\n\tfor_(i,0,m-1) {\n\t\tif (isdigit(S[i]) && !isdigit(S[i+1])) {\n\t\t\tS = S.substr(0,i+1) + \"$\" + S.substr(i+1);\n\t\t\tm = S.size();\n\t\t}\n\t}\n\tS = S.substr(0, m-1);\n\t\n\tlint ans = 0;\n\tfor_(i,0,3) for_(j,0,3) for_(k,0,3) {\n\t\tlev['+'] = i;\n\t\tlev['-'] = j;\n\t\tlev['*'] = k;\n\t\tans = max(ans, parse(0, (int)S.size(), S));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\nint c[4];\n\nll expression(State &begin);\nll number(State &begin);\nll factor(State &begin);\nll term1(State &begin);\nll term2(State &begin);\n\n\nll number(State &begin){\n\tll ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nll term2(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]==2){\n\t\t\tbegin++;\n\t\t\tret+=factor(begin);\n\t\t}else if(*begin=='-' && c[1]==2){\n\t\t\tbegin++;\n\t\t\tret-=factor(begin);\n\t\t}else if(*begin=='*' && c[2]==2){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll term1(State &begin){\n\tll ret=term2(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]>=1){\n\t\t\tbegin++;\n\t\t\tret+=term2(begin);\n\t\t}else if(*begin=='-' && c[1]>=1){\n\t\t\tbegin++;\n\t\t\tret-=term2(begin);\n\t\t}else if(*begin=='*' && c[2]>=1){\n\t\t\tbegin++;\n\t\t\tret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tll ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else return number(begin);\n}\n\nll expression(State &begin){\n\tll ret=term1(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tif(c[0]==0)ret+=term1(begin);\n\t\t\tif(c[0]>=1)ret+=term2(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(c[1]==0)ret-=term1(begin);\n\t\t\tif(c[1]>=1)ret-=term2(begin);\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tif(c[2]==0)ret*=term1(begin);\n\t\t\tif(c[2]>=1)ret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tll res=0;\n\tfor(int i=0;i<3;i++){\n\t\tc[0]=i;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tc[1]=j;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tc[2]=k;\n\t\t\t\tState begin=str.begin();\n\t\t\t\tll re=expression(begin);\n\t\t\t\tif(i+j+k==0)res=re;\n\t\t\t\telse res=max(res,re);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint p[3];\n\nll expr();\nll term1();\nll term2();\nll factor();\nll num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nll expr(){\n\tdebug(\"expr\");\n\tll x = term1();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 0){\n\t\t\tc++;\n\t\t\tx += term1();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 0){\n\t\t\tc++;\n\t\t\tx -= term1();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 0){\n\t\t\tc++;\n\t\t\tx *= term1();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term1(){\n\tdebug(\"term1\");\n\tll x = term2();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 1){\n\t\t\tc++;\n\t\t\tx += term2();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 1){\n\t\t\tc++;\n\t\t\tx -= term2();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 1){\n\t\t\tc++;\n\t\t\tx *= term2();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll term2(){\n\tdebug(\"term2\");\n\tll x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '+' && p[0] == 2){\n\t\t\tc++;\n\t\t\tx += factor();\n\t\t}\n\t\telse if(s[c] == '-' && p[1] == 2){\n\t\t\tc++;\n\t\t\tx -= factor();\n\t\t}\n\t\telse if(s[c] == '*' && p[2] == 2){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nll factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tll ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nll num(){\n\tdebug(\"num\");\n\tll ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> s;\n\tN = s.size();\n\n\tll ans = -(1LL << 63 + 10);\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tp[0] = i, p[1] = j, p[2] = k;\n\t\t\t\tc = 0;\n\t\t\t\tans = max(ans, expr());\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef long long ll;\nstring s;\nint r[200];\nll a1(int& it);\nll a2(int& it);\nll fac(int& it);\nll a0(int& it){\t//+\n\tll ret=a1(it);\n\twhile(r[s[it]]==0){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tret+=a1(it);\n\t\t}else if(s[it]=='-'){\n\t\t\tit++;\n\t\t\tret-=a1(it);\n\t\t}else{\n\t\t\tit++;\n\t\t\tret*=a1(it);\n\t\t}\n\t}\n\treturn ret;\n}\nll a1(int& it){\t//+\n\tll ret=a2(it);\n\twhile(r[s[it]]==1){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tret+=a2(it);\n\t\t}else if(s[it]=='-'){\n\t\t\tit++;\n\t\t\tret-=a2(it);\n\t\t}else{\n\t\t\tit++;\n\t\t\tret*=a2(it);\n\t\t}\n\t}\n\treturn ret;\n}\nll a2(int& it){\t//+\n\tll ret=fac(it);\n\twhile(r[s[it]]==2){\n\t\tif(s[it]=='+'){\n\t\t\tit++;\n\t\t\tret+=fac(it);\n\t\t}else if(s[it]=='-'){\n\t\t\tit++;\n\t\t\tret-=fac(it);\n\t\t}else{\n\t\t\tit++;\n\t\t\tret*=fac(it);\n\t\t}\n\t}\n\treturn ret;\n}\nll num(int& it){\n\tll ret=0;\n\twhile(isdigit(s[it])){\n\t\tret*=10;\n\t\tret+=s[it]-'0';\n\t\tit++;\n\t}\n\treturn ret;\n}\nll fac(int& it){\n\tif(s[it]=='('){\n\t\tit++;\n\t\tll ret=a0(it);\n\t\tit++;\n\t\treturn ret;\n\t}else{\n\t\treturn num(it);\n\t}\n}\nint main(){\n\trep(i,200) r[i]=-1;\n\tll ans=0;\n\tbool fst=1;\n\tcin>>s;\n\ts+=\"$\";\n\tint it=0;\n\trep(i,3) rep(j,3) rep(k,3){\n\t\tr['+']=i,r['-']=j,r['*']=k;\n\t\tll tmp=a0(it);\n\t\tit=0;\n//\t\tshow(tmp);\n\t\tif(fst||ans<tmp) ans=tmp;\n\t\tfst=0;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        return -1;\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10;\n\t\tres += *it - '0';\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc  c(str, p);\n        res = max(res, abs(c.f3()));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1||a[1]==2||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1||a[1]==3||a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2||a[1]==1||a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2||a[1]==3||a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3||a[1]==1||a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3||a[1]==2||a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cstdlib>\nusing namespace std;\n\nstring O[27]={\"111\",\"112\",\"113\",\"121\",\"122\",\"123\",\"131\",\"132\",\"133\",\"211\",\"212\",\"213\",\"221\",\"222\",\"223\",\"231\",\"232\",\"233\",\"311\",\"312\",\"313\",\"321\",\"322\",\"323\",\"331\",\"332\",\"333\"};\n\nstring cal(vector<string> V,int in)\n{  \n  for(int i=0;i<V.size();i++){\n    if(V[i]==\"(\"){\n      int l=1,r=0;\n      vector<string> v;\n      string s;\n      V.erase(V.begin()+i);\n      while(1){\n\tif(V[i]==\"(\")l++;\n\tif(V[i]==\")\")r++;\n\tv.push_back(V[i]);\n\tV.erase(V.begin()+i);\t \n\tif(r==l){\n\t  v.pop_back();\n\t  s=cal(v,in);\n\t  V.insert(V.begin()+i,s);\n\t  break;\n\t}\n      }\n    }\n  }\n  for(int k=1;k<=3;k++){\n    for(int i=0;i<V.size();i++){\n      if(V[i]==\"+\"){\n\tif((O[in][0]-'0')==k){\n\t  long long a=atoll(V[i-1].c_str())+atoll(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n      else if(V[i]==\"-\"){\n\tif((O[in][1]-'0')==k){\n\t  long long a=atoll(V[i-1].c_str())-atoll(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n      else if(V[i]==\"*\"){\n\tif((O[in][2]-'0')==k){\n\t  long long a=atoll(V[i-1].c_str())*atoll(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n    }\n  }\n  return V[0];\n}\nint main()\n{\n  string s,samp;\n  long long ans=0;\n  vector<string> V;\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if('0'<=s[i] && s[i]<='9'){\n      samp+=s[i];\n      if(i==s.length()-1)V.push_back(samp);\n    }\n    else {\n      if(!samp.empty()){\n\tV.push_back(samp);\n\tsamp=\"\";\n      }\n      samp=s[i];\n      V.push_back(samp);\n      samp=\"\";\n    }\n  }\n  for(int i=0;i<27;i++){\n    string a=cal(V,i);\n    long long b=atoll(a.c_str());\n    if(i==0)ans=b;\n    else ans=max(b,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\narray<int, 3> v{};\nusing state = string::const_iterator;\nll op1(state &cur, int depth);\nll number(state &cur);\nll factor(state &cur);\nll number(state &cur){\n    ll ans = *cur - '0';\n    while(isdigit(*++cur)) ans = ans*10+(*cur-'0');\n    return ans;\n}\n\nll factor(state &cur){\n    if(isdigit(*cur)) return number(cur);\n    cur++;\n    ll ans = op1(cur, 1);\n    cur++;\n    return ans;\n}\n\nll op1(state &cur, int depth) {\n    if(depth == 4) return factor(cur);\n    ll ans = op1(cur, depth+1);\n    while(true){\n\n        if(v[0] == depth && *cur == '+'){\n            cur++;\n            ans += op1(cur, depth+1);\n        }else if(v[1] == depth && *cur == '-'){\n            cur++;\n\n            ans -= op1(cur, depth+1);\n        }else if(v[2] == depth && *cur == '*'){\n            cur++;\n            ans *= op1(cur, depth+1);\n        }else break;\n    }\n    return ans;\n}\n\n\nll expr(state &cur){\n    return op1(cur, 1);\n}\n\nint main() {\n    string s;\n    cin >> s;\n    ll ans = INT64_MIN;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                v = {i+1, j+1, k+1};\n                state cur = s.begin();\n                ans = max(ans, expr(cur));\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace solver {\nstring s;\ntypedef string::const_iterator Iter;\nIter it, end;\nint priority[3];\n\n#define my_assert(condition)  \\\n  if(!(condition)) {  \\\n    cout << string(it, end) << endl;  \\\n    assert(0 && #condition); \\\n  } \\\n\nvoid consume(char e) {\n  my_assert(*it == e);\n  it ++;\n}\n\nbool isconsume(char e) {\n  if(*it == e) {\n    consume(e);\n    return true;\n  }\n  return false;\n}\n\nll number() {\n  ll ret = 0;\n  my_assert(isdigit(*it));\n  while(isdigit(*it)) {\n    ret *= 10;\n    ret += *it - '0';\n    it ++;\n  }\n  return ret;\n}\n\n// 1. solve operator priority recursion\nll expr(int p) {\n  if(p == 3) {\n    if(isconsume('(')) {\n      ll ret = expr(0);\n      consume(')');\n      return ret;\n    }\n    return number();\n  }\n\n  // 2. solve operator association\n  ll ret = expr(p + 1);\n\n  auto priority_condition = [&]() {\n    auto k = string(\"+-*\").find(*it);\n    if(k == string::npos) return false;\n    return priority[k] == p;\n  };\n\n  while(priority_condition())\n    if(isconsume('+')) ret += expr(p + 1);\n    else if(isconsume('-')) ret -= expr(p + 1);\n    else if(isconsume('*')) ret *= expr(p + 1);\n\n  return ret;\n}\n\nll calc() {\n  it = s.begin(), end = s.end();\n  ll ret = expr(0);\n  my_assert(it == end);\n  return ret;\n}\n\nbool next_priority() {\n  static int turn = 0;\n  int t = turn++;\n  priority[0] = t % 3;\n  t /= 3;\n  priority[1] = t % 3;\n  t /= 3;\n  if(t >= 3) return false;\n  priority[2] = t;\n  return true;\n}\n\nll solve() {\n  ll ret = numeric_limits<ll>::min();\n  do {\n    ret = max(ret, calc());\n  } while(next_priority());\n  return ret;\n}\n\n}\n\nint main() {\n  cin >> solver::s;\n  cout << solver::solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;s+='(';\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 62;\n\nstring S;\nint itr;\n\nstring op = \"+-*\";\n\nlint number() {\n    lint ret = 0;\n    while (isdigit(S[itr])) {\n        (ret *= 10) += S[itr] - '0';\n        ++itr;\n    }\n    return ret;\n}\n\nlint expr(int d) {\n    lint ret;\n    if (d == 3) {\n        // 括弧か数をパース\n        if (S[itr] == '(') {\n            ++itr;\n            ret = expr(0);\n            assert(S[itr] == ')');\n            ++itr;\n        } else {\n            ret = number();\n        }\n    } else {\n        ret = expr(d + 1);\n        while (S[itr] == op[d]) {\n            ++itr;\n            if (op[d] == '+') {\n                ret += expr(d + 1);\n            } else if (op[d] == '-') {\n                ret -= expr(d + 1);\n            } else if (op[d] == '*') {\n                ret *= expr(d + 1);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin >> S;\n    lint ans = -INF;\n\n    for (int i = 0; i < 6; ++i) {\n        itr = 0;\n        ans = max(ans, expr(0));\n        next_permutation(op.begin(), op.end());\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\ndef calc(lst, pos, pr):\n    ret = []\n    while True:\n        if pos >= len(lst):\n            break\n        if lst[pos] == '(':\n            val, pos = calc(lst, pos + 1, pr)\n            ret.append(val)\n        elif lst[pos] == ')':\n            pos += 1\n            break\n        else:\n            ret.append(lst[pos])\n            pos += 1\n    lst = ret\n    for p in pr:\n        i = 0\n        ret = []\n        while i < len(lst):\n            if lst[i] in p:\n                ret[-1] = eval(str(ret[-1]) + lst[i] + str(lst[i + 1]))\n                i += 2\n            else:\n                ret.append(lst[i])\n                i += 1\n    return ret[0], pos\n\nS = raw_input()\n\nlst = []\nss = ''\nfor c in S:\n    if c in ['+', '-', '*', '(', ')']:\n        if ss != '':\n            lst.append(int(ss))\n        lst.append(c)\n        ss = ''\n    else:\n        ss += c\nif ss != '':\n    lst.append(int(ss))\n\nans = -(10 ** 30)\nfor i, j, k in it.product([0, 1, 2], repeat = 3):\n    pr = [[], [], []]\n    pr[i].append('+')\n    pr[j].append('-')\n    pr[k].append('*')\n    ans = max(ans, calc(lst, 0, pr)[0])\n\nprint ans\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef __int128_t ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nmap<char, ll> pri;\nstring op = \"+-*\";\nstring s;\nll pos = 0;\nbool end() {\n    return pos == s.size();\n}\nvoid read_char(char c) {\n    assert(!end() && s[pos] == c);\n    ++pos;\n}\nll parse(ll);\nll number() {\n    if (s[pos] == '(') {\n        read_char('(');\n        ll res = parse(0);\n        read_char(')');\n        return res;\n    }\n    else {\n        string res = \"\";\n        while ( !end() && isdigit(s[pos]) ) {\n            res += s[pos++];\n        }\n        return stoll(res);\n    }\n}\nll parse(ll oid) {\n    if (oid == op.size()) return number();\n    ll res = parse(oid+1);\n    while ( !end() && pri.count(s[pos]) > 0 && pri[s[pos]] == oid ) {\n        char op = s[pos];\n        read_char(op);\n        ll right = parse(oid+1);\n        switch (op) {\n            case '*': res *= right; break;\n            case '+': res += right; break;\n            case '-': res -= right; break;\n        }\n    }\n    return res;\n}\nll parse() {\n    pos = 0;\n    return parse(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    ll ans = -linf;\n    rep(a, 3) rep(b, 3) rep(c, 3) {\n        vector<ll> v{a, b, c};\n        // vector<ll> v{1, 1, 1};\n        rep(i, 3) pri[op[i]] = v[i];\n        if (a == 0 && b == 0 && c == 0) ans = parse();\n        else chmax(ans, parse());\n        // chmax(ans, parse());\n    }\n    cout << (long long)ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nstring s;\nstring::iterator p;\nll fact();\nll term();\nll exp();\n\nset<char> se[3];\n\nll fact() {\n  ll x;\n  string num;\n  while(isdigit(*p)) {\n    num += *p;\n    ++p;\n  }\n  if(num.size()) {\n    stringstream ss;\n    ss << num;\n    ss >> x;\n  } else {\n    ++p;\n    x = exp();\n    ++p;\n  }\n  return x;\n}\n \nll termz() {\n  ll x = fact();\n  while(se[2].count(*p)) {\n    if(*p == '+') {\n      ++p;\n      x += fact();\n    } else if(*p == '*') {\n      ++p;\n      x *= fact();\n    } else {\n      ++p;\n      x -= fact();\n    }\n  }\n  return x;\n}\n\nll term() {\n  ll x = termz();\n  while(se[1].count(*p)) {\n    if(*p == '+') {\n      ++p;\n      x += termz();\n    } else if(*p == '*') {\n      ++p;\n      x *= termz();\n    } else {\n      ++p;\n      x -= termz();\n    }\n  }\n  return x;\n}\n \nll exp() {\n  ll x = term();\n  while(se[0].count(*p)) {\n    if(*p == '+') {\n      ++p;\n      x += term();\n    } else if(*p == '*') {\n      ++p;\n      x *= term();\n    } else {\n      ++p;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  R s;\n  ll ans=-LLONG_MAX;\n  rep(i,3) rep(j,3) rep(k,3) {\n    rep(l,3) se[l].clear();\n    se[i].insert('+');\n    se[j].insert('-');\n    se[k].insert('*');\n    p=s.begin();\n    ans=max(ans,exp());\n  }\n  pr(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll bnf1();\nll bnf2();\nll bnf3();\nll get_digit();\n\nstring s;\nint p,priority[300],len;\n\nll Cal(ll res,char c,ll x){\n  p++;\n  \n  ll r;\n  \n  if(x==2)r=bnf2();\n  if(x==3)r=bnf3();\n  if(x==4)r=get_digit();\n  \n  if(c=='+') return res+r;\n  if(c=='-') return res-r;\n  return res*r;\n}\n\nll bnf(){\n  \n  ll res;\n  \n  if(p<len&&s[p]=='('){\n    \n    p++;\n    \n    res=bnf1();\n    \n    p++;\n    return res;\n  }\n\n  res=bnf1();\n\n  return res;  \n}\n\nll bnf1(){\n  \n  ll res=bnf2();\n  \n  while(p<len&&priority[s[p]]==1) res=Cal(res,s[p],2);\n  \n  return res;\n}\n\nll bnf2(){\n  \n  ll res=bnf3();\n  \n  while(p<len&&priority[s[p]]==2) res=Cal(res,s[p],3);\n  \n  return res;\n}\n\nll bnf3(){\n  \n  ll res=get_digit();\n  \n  while(p<len&&priority[s[p]]==3) res=Cal(res,s[p],4);\n  \n  return res;\n}\n\nll get_digit(){\n  \n  ll res=0;\n  \n  if(s[p]=='('){\n    \n    res=bnf();\n    \n    return res;\n  }\n  \n  while('0'<=s[p]&&s[p]<='9') res=res*10+s[p++]-'0';\n  \n  return res;\n}\n\n\nint main(){\n  \n  cin>>s;\n\n  s='('+s+')';\n  len=s.size();\n  \n  ll ans;\n  int flag=0;\n  \n  for(int i=1;i<=3;i++)\n    for(int j=1;j<=3;j++)\n      for(int k=1;k<=3;k++){\n\tpriority['+']=i;\n\tpriority['-']=j;\n\tpriority['*']=k;\n\tp=0;\n\tif(!flag)ans=bnf(),flag=1;\n\telse ans=max(ans,bnf());\n      }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nvector< int > s{0, 1, 2};\nstring S, T = \"+-*\";\nint idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && S[idx] == T[s[2]]) {\n    ++idx;\n    ret = calc(ret, T[s[2]], ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && S[idx] == T[s[1]]) {\n    ++idx;\n    ret = calc(ret, T[s[1]], beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && S[idx] == T[s[0]]) {\n    ++idx;\n    ret = calc(ret, T[s[0]], malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  do {\n    idx = 0;\n    ret = max(ret, latte());\n  } while(next_permutation(begin(s), end(s)));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <map>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nstring s;\nmap<char, llint> mp;\n\nllint calc(llint a, char c, llint b)\n{\n\tif(c == '+') return a+b;\n\tif(c == '-') return a-b;\n\tif(c == '*') return a*b;\n}\n\nbool isDigit(char c)\n{\n\treturn (c >= '0' && c <= '9');\n}\n\nllint parseNumber(llint &pos)\n{\n\tllint ret = 0;\n\twhile(1){\n\t\tif(isDigit(s[pos])) ret *= 10, ret += s[pos] - '0';\n\t\telse break;\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nllint parse(llint &pos, llint depth)\n{\n\tif(depth == 3){\n\t\tif(s[pos] == '('){\n\t\t\tpos++;\n\t\t\tllint res = parse(pos, 0);\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\treturn parseNumber(pos);\n\t}\n\t\n\tllint ret = parse(pos, depth+1);\n\twhile(1){\n\t\tif(mp.count(s[pos]) && mp[s[pos]] == depth){\n\t\t\tchar ope = s[pos];\n\t\t\tpos++;\n\t\t\tllint res = parse(pos, depth+1);\n\t\t\tret = calc(ret, ope, res);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> s;\n\ts += \"#\";\n\t\n\tllint ans; bool flag = false;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\tmp['+'] = i, mp['-'] = j, mp['*'] = k;\n\t\t\t\tllint p = 0;\n\t\t\t\tif(!flag) ans = parse(p, 0), flag = true;\n\t\t\t\telse ans = max(ans, parse(p, 0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nchar op[3] = {'+', '-', '*'};\n\nint pos;\nstring s;\n\nll expr1();\nll expr2();\nll expr3();\nll number();\n\nll expr1() {\n  ll ret = expr2();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[0]) {\n      if(op[0] == '+') pos++, ret += expr2();\n      else if(op[0] == '*') pos++, ret *= expr2();\n      else if(op[0] == '-') pos++, ret -= expr2();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr2() {\n  ll ret = expr3();\n\n  while(pos < s.size()) {\n    if(s[pos] == op[1]) {\n      if(op[1] == '+') pos++, ret += expr3();\n      else if(op[1] == '*') pos++, ret *= expr3();\n      else if(op[1] == '-') pos++, ret -= expr3();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expr3() {\n  ll ret;\n  if(s[pos]=='(') {\n    pos++;\n    ret = expr1();\n    cout << \"expr3 \" << ret << endl;\n    pos++;\n  } else {\n    ret = number();\n  }\n\n  while(pos < s.size()) {\n    if(s[pos] == op[2]) {\n      if(op[2] == '+') pos++, ret += number();\n      else if(op[2] == '*') pos++, ret *= number();\n      else if(op[2] == '-') pos++, ret -= number();\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll number() {\n  ll ret = 0;\n  while(pos < s.size() && isdigit(s[pos])) {\n    ret *= 10;\n    ret += s[pos]-'0';\n    pos++;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> s;\n\n  ll ans = -LLINF;\n  sort(op, op+3);\n  do {\n    // cout << op[0] << \" \" << op[1] << \" \" << op[2] << endl;\n    pos = 0;\n    ll ret = expr1();\n    chmax(ans, ret);\n    // cout << ret << endl;\n  } while(next_permutation(op, op+3));\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 62);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nstring calc(const vector<set<string>>& level, stack<string>& sent) {\n\tfor (auto ops : level) {\n\t\tstack<string> res;\n\t\twhile (!sent.empty()) {\n\t\t\tstring top = sent.top(); sent.pop();\n\t\t\tif (ops.find(top) == ops.end()) {\n\t\t\t\tres.push(top);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll l = stoll(res.top()); res.pop();\n\t\t\t\tll r = stoll(sent.top()); sent.pop();\n\t\t\t\tif (top == \"+\")res.push(to_string(l + r));\n\t\t\t\tif (top == \"-\")res.push(to_string(l - r));\n\t\t\t\tif (top == \"*\")res.push(to_string(l * r));\n\t\t\t}\n\t\t}\n\t\twhile (!res.empty()) {\n\t\t\tsent.push(res.top());\n\t\t\tres.pop();\n\t\t}\n\t}\n\tif (sent.size() != 1)exit(1);\n\treturn sent.top();\n}\n\nvector<string> separater(string q) {\n\tvector<string> res;\n\tstring now;\n\tfor (char c : q) {\n\t\tif (isalnum(c)) {\n\t\t\tnow += c;\n\t\t}\n\t\telse {\n\t\t\tif (!now.empty()) {\n\t\t\t\tres.push_back(now);\n\t\t\t\tnow = \"\";\n\t\t\t}\n\t\t\tres.push_back({ c });\n\t\t}\n\t}\n\tif (!now.empty())res.push_back(now);\n\treturn res;\n}\n\nll solve(vector<string> vs, vector<set<string>>& level) {\n\tstack<string> st;\n\tfor (string s : vs) {\n\t\tif (s == \")\") {\n\t\t\tstack<string> sent;\n\t\t\twhile (true) {\n\t\t\t\tstring top = st.top(); st.pop();\n\t\t\t\tif (top == \"(\")break;\n\t\t\t\tsent.push(top);\n\t\t\t}\n\t\t\tst.push(calc(level, sent));\n\t\t}\n\t\telse {\n\t\t\tst.push(s);\n\t\t}\n\t}\n\tstack<string> op;\n\twhile (!st.empty()) {\n\t\top.push(st.top());\n\t\tst.pop();\n\t}\n\treturn stoll(calc(level, op));\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tauto vs = separater(s);\n\n\tvector<vector<set<string>>> levels = {\n\t\t// 1\n\t\t{{\"+\"},{\"-\"},{\"*\"}},\n\t\t{{\"+\"},{\"*\"},{\"-\"}},\n\t\t{{\"-\"},{\"+\"},{\"*\"}},\n\t\t{{\"-\"},{\"*\"},{\"+\"}},\n\t\t{{\"*\"},{\"+\"},{\"-\"}},\n\t\t{{\"*\"},{\"-\"},{\"+\"}},\n\t\t// 2\n\t\t{{\"+\"},{\"-\",\"*\"}},\n\t\t{{\"-\"},{\"+\",\"*\"}},\n\t\t{{\"*\"},{\"+\",\"-\"}},\n\t\t{{\"+\",\"-\"},{\"*\"}},\n\t\t{{\"+\",\"*\"},{\"-\"}},\n\t\t{{\"-\",\"*\"},{\"+\"}},\n\t\t// 3\n\t\t{{\"+\",\"-\",\"*\"}},\n\t};\n\n\tll res = solve(vs, levels.front());\n\tFOR(i, 1, levels.size()) {\n\t\tres = max(res, solve(vs, levels[i]));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\nvoid init() {\n\n}\n#define int ll\n\nmap<char, int> val;\n\nint num(State& now) {\n\tint ans = 0;\n\twhile (*now >= '0' && *now <= '9') {\n\t\tans *= 10LL;\n\t\tans += (long long)(*now - '0');\n\t\tnow++;\n\t}\n\treturn ans;\n}\n\nint sol(State& now, int itr) {\n\tif (itr == 3) {\n\t\tif (*now == '(') {\n\t\t\tnow++;\n\t\t\tint hoge = sol(now, 0);\n\t\t\tnow++;\n\t\t\treturn hoge;\n\t\t}\n\t\telse {\n\t\t\treturn num(now);\n\t\t}\n\t}\n\tint hoge = sol(now, itr + 1);\n\twhile (itr < 3) {\n\t\tif (*now == ')') break;\n\t\tif (val[*now] == itr) {\n\t\t\tint geko = *now;\n\t\t\tnow++;\n\t\t\tif (geko == '+') {\n\t\t\t\thoge += sol(now, itr + 1);\n\t\t\t}\n\t\t\telse if (geko == '-') {\n\t\t\t\thoge -= sol(now, itr + 1);\n\t\t\t}\n\t\t\telse if (geko == '*') {\n\t\t\t\thoge *= sol(now, itr + 1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\titr++;\n\t\t}\n\t}\n\treturn hoge;\n}\n\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\ts.push_back(')');\n\tstring backup = s;\n\tll ans = 0;\n\tfor (int i = 0; i < 27; ++i) {\n\t\ts = backup;\n\t\tstring neko = \"+-*\";\n\t\tint geko = i;\n\t\tREP(q, 3) {\n\t\t\tval[neko[q]] = geko%3;\n\t\t\tgeko /= 3;\n\t\t}\n\t\tState start = s.begin();\n\t\tif (i == 0) ans = sol(start, 0);\n\t\telse ans = max(ans, sol(start, 0));\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <map>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = (ll)1e9 + 7;\nconst int MAX_N = (ll)1e5 + 5;\n#define debug(x) cout << #x << \": \" << x << endl\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) { for(ll i = 0; i < (ll) v.size(); i++) os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); return os; }\nstruct Parser\n{\n    map<char, int> priority;\n    Parser(const map<char, int> &mp) : priority(mp) {}\n    ll calc(const ll &a, const ll &b, const char &ch)\n    {\n        if(ch == '+') return a + b;\n        else if(ch == '-') return a - b;\n        return a * b;\n    }\n    ll number(auto &pos)\n    {\n        ll res = 0;\n        while(isdigit(*pos))\n        {\n            res *= 10;\n            res += *pos - '0';\n            pos++;\n        }\n        return res;\n    }\n    ll factor(auto &pos)\n    {\n        if(*pos == '(')\n        {\n            pos++;\n            ll res = expression(pos);\n            pos++;\n            return res;\n        }\n        else return number(pos);\n    }\n    ll term2(auto &pos)\n    {\n        ll res = factor(pos);\n        while(true)\n        {\n            bool flag = false;\n            for(auto &x : priority)\n            {\n                if(x.second == 2 and *pos == x.first)\n                {\n                    pos++;\n                    flag = true;\n                    res = calc(res, factor(pos), x.first);\n                }\n            }\n            if(flag == false) break;\n        }\n        return res;\n    }\n    ll term1(auto &pos)\n    {\n        ll res = term2(pos);\n        while(true)\n        {\n            bool flag = false;\n            for(auto &x : priority)\n            {\n                if(x.second == 1 and *pos == x.first)\n                {\n                    pos++;\n                    flag = true;\n                    res = calc(res, term2(pos), x.first);\n                }\n            }\n            if(flag == false) break;\n        }\n        return res;\n    }\n    ll expression(auto &pos)\n    {\n        ll res = term1(pos);\n        while(true)\n        {\n            bool flag = false;\n            for(auto &x : priority)\n            {\n                if(x.second == 0 and *pos == x.first)\n                {\n                    pos++;\n                    flag = true;\n                    res = calc(res, term1(pos), x.first);\n                }\n            }\n            if(flag == false) break;\n        }\n        return res;\n    }\n};\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s; cin >> s;\n    ll ans = numeric_limits<ll>::min();\n    map<char, int> mp;\n    for(int i = 0; i < 3; i++)\n    {\n        for(int j = 0; j < 3; j++)\n        {\n            for(int k = 0; k < 3; k++)\n            {\n                mp['+'] = i;\n                mp['-'] = j;\n                mp['*'] = k;\n                Parser p(mp);\n                auto pos = s.begin();\n                ll tmp = p.expression(pos);\n                ans = max(ans, tmp);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  if(p>=s.size())return res;\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  if(p>=s.size())return res;\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  if(p>=s.size())return res;\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=0;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nint main(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nstruct Parser {\n  typedef string::const_iterator cursor_t;\n  Parser(){\n    memset(prit, 0, sizeof(prit));\n  }\n  ll eval(const string& s){\n    auto b = s.begin();\n    ll x = expr(b);\n    consume(b, '\\0');\n    return x;\n  }\n  inline void consume(cursor_t& cur, char expected){\n    assert(*cur == expected);\n    ++cur;\n  }\n  ll expr(cursor_t& cur, int pri=0){\n    if (pri == 3){\n      if (*cur == '('){\n        consume(cur, '(');\n        ll r = expr(cur);\n        consume(cur, ')');\n        return r;\n      }\n      return number(cur);\n    }\n    ll r = expr(cur, pri + 1);\n    while (prit[pri][*cur]){\n      if (*cur == '*') ++cur, r = r * expr(cur, pri + 1);\n      else if (*cur == '+') ++cur, r = r + expr(cur, pri + 1);\n      else if (*cur == '-') ++cur, r = r - expr(cur, pri + 1);\n    }\n    return r;\n  }\n  ll number(cursor_t& cur){\n    ll r = 0;\n    while (isdigit(*cur)){\n      r = r * 10 + *cur - '0';\n      ++cur;\n    }\n    return r;\n  }\n  int prit[3][256];\n};\n\nint main()\n{\n  Parser parser;\n  string S;\n\n  cin >> S;\n  ll maxi = -(1ll << 62);\n  for (int i = 0; i < 3; i++){\n    for (int j = 0; j < 3; j++){\n      for (int k = 0; k < 3; k++){\n        for (int l = 0; l < 3; l++){\n          parser.prit[l]['*'] = (i == l);\n          parser.prit[l]['+'] = (j == l);\n          parser.prit[l]['-'] = (k == l);\n        }\n        maxi = max(maxi, parser.eval(S));\n      }\n    }\n  }\n  cout << maxi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define int long long\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint expression1(State &begin);\nint expression2(State &begin);\nint expression3(State &begin);\n\nvector<int> priority(3);\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin)-'0';\n    begin++;\n  }\n  // cout<<\"number: \"<<ret<<endl;\n  return ret;\n}\n\nint factor(State &begin){\n  // cout<<\"in factor: \"<<*begin<<endl;\n  int ret;\n  if(*begin=='('){\n    begin++;\n    ret=expression1(begin);\n    begin++;\n  }else{\n    // cout<<\"factor in number\" <<endl;\n    ret=number(begin);\n  }\n  return ret;\n}\n\nint expression3(State &begin){\n  // cout<<\"in expr3: \"<<endl;\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='+'&&priority[2]&(1<<0)){\n      begin++;\n      ret+=factor(begin);\n    }else if(*begin=='-'&&priority[2]&(1<<1)){\n      begin++;\n      ret-=factor(begin);\n    }else if(*begin=='*'&&priority[2]&(1<<2)){\n      begin++;\n      ret*=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression2(State &begin){\n  int ret=expression3(begin);\n  // cout<<\"in expr2: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[1]&(1<<0)){\n      begin++;\n      ret+=expression3(begin);\n    }else if(*begin=='-'&&priority[1]&(1<<1)){\n      begin++;\n      ret-=expression3(begin);\n    }else if(*begin=='*'&&priority[1]&(1<<2)){\n      begin++;\n      ret*=expression3(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression1(State &begin){\n  int ret=expression2(begin);\n  // cout<<\"in expr1: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[0]&(1<<0)){\n      begin++;\n      ret+=expression2(begin);\n    }else if(*begin=='-'&&priority[0]&(1<<1)){\n      begin++;\n      ret-=expression2(begin);\n    }else if(*begin=='*'&&priority[0]&(1<<2)){\n      begin++;\n      ret*=expression2(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  int ans=0;\n  for(int i=0;i<(1<<3);i++){\n    for(int j=0;j<(1<<3);j++){\n      for(int k=0;k<(1<<3);k++){\n\tif((__builtin_popcount(i)+__builtin_popcount(j)+__builtin_popcount(k))!=3||(i|j|k)!=7)continue;\n\tpriority[0]=i;priority[1]=j;priority[2]=k;\n\tState begin=s.begin();\n        //cout<<i<<\" \"<<j<<\" \"<<k<<\": \"<<expression1(begin)<<endl;\n\tans=max(ans,expression1(begin));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring  formula;\nint idx;\n\nmap<char, int> mp;\n\nint solve(int pri)\n{\n  static int len = formula.size();\n  if(idx >= len) return 0;\n  int ret = 0; char c = formula[idx];\n  if(c == '(') idx++, ret = solve(0), idx++;\n  else if(c == ')') idx++;\n  else while(idx < len && isdigit(formula[idx]))\n\t ret = ret*10 + (formula[idx++]-'0');\n  while(idx < len && mp.count(formula[idx]) && mp[formula[idx]] > pri) {\n    char op = formula[idx++];\n    if(op == '+') ret += solve(mp[op]);\n    else if(op == '-') ret -= solve(mp[op]);\n    else if(op == '*') ret *= solve(mp[op]);\n  }\n  return ret;\n}\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> formula;\n  int ans = LLONG_MIN;\n  rep(i, 3) rep(j, 3) rep(k, 3) {\n    mp['+'] = i, mp['-'] = j, mp['*'] = k;\n    idx = 0; ans = max(ans, solve(0));\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nlong long int calc(const int type, const long long int l, const long long r) {\n\tif (type == 0) {\n\t\treturn l + r;\n\t}\n\telse if (type == 1) {\n\t\treturn l - r;\n\n\t}\n\telse {\n\t\treturn l*r;\n\t}\n}\nlong long int calc1(const char type, const long long int l, const long long r) {\n\tif (type == '+') {\n\t\treturn calc(0, l, r);\n\t}\n\telse if (type == '-') {\n\t\treturn calc(1, l, r);\n\n\t}\n\telse {\n\t\treturn calc(2, l, r);\n\t}\n}\nint a = 0;\nvector<int>perms = { 0,1,2 };\nstring st;\nmap<int, char>mp;\nlong long int getform0();\nlong long int getnum() {\n\tlong long int num = 0;\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tnum= getform0();\n\t\ta++;\n\t}\n\telse {\n\t\twhile (isdigit(st[a])) {\n\t\t\tnum = num * 10 + st[a] - '0';\n\t\t\ta++;\n\t\t}\n\t}\n\treturn num;\n\t\n}\nlong long int getform2() {\n\tlong long int ans;\n\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[perms[1]]) {\n\t\t\treturn ans;\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform1() {\n\tlong long int ans;\n\n\t\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\treturn ans;\n\n\t\t}\n\t\telse if (st[a] == mp[perms[1]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[1]], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\n\nlong long int getform0(){\n\tlong long int ans;\n\t\n\tans = getnum();\n\t\n\twhile (a != st.size()) {\n\t\tif (st[a] == mp[perms[0]]) {\n\t\t\t\ta++;\n\t\t\t\tans = calc1(mp[perms[0]], ans, getform1());\n\t\t\t\n\t\t}\n\t\telse if(st[a]==mp[perms[1]]){\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[1]], ans, getform2());\n\t\t}\n\t\telse if (st[a] == mp[perms[2]]) {\n\t\t\ta++;\n\t\t\tans = calc1(mp[perms[2]], ans, getnum());\n\t\t}\n\t\telse if(st[a]==')'){\n\t\t\treturn ans;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tmp[0] = '+';\n\tmp[1] = '-';\n\tmp[2] = '*';\n\tcin >> st;\n\tlong long int ans = -1e18;\n\tdo {\n\t\ta = 0;\n\t\tans = max(ans,getform0());\n\t} while (next_permutation(perms.begin(), perms.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef string::const_iterator State;\nVI arr1 = {0,1,2};\nVI arr2 = {0,1,2};\nVI arr3 = {0,1,2};\nll expression0(State&);\nll number(State &begin){\n  ll ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nll factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    ll ret = expression0(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n  cerr << \"err\" << endl;\n  return -1;\n}\n\nll expression2(State &begin){\n  ll ret = factor(begin);\n  while(true){\n    if(*begin == '+' && arr1[0] == 2){\n      begin++;\n      ret += factor(begin);\n    }\n    else if(*begin == '-' && arr2[0] == 2){\n      begin++;\n      ret -= factor(begin);\n    }\n    else if(*begin == '*' && arr3[0] == 2){\n      begin ++;\n      ret *= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expression1(State &begin){\n  ll ret = expression2(begin);\n  while(true){\n    if(*begin == '+' && arr1[0] == 1){\n      begin++;\n      ret += expression2(begin);\n    }\n    else if(*begin == '-' && arr2[0] == 1){\n      begin++;\n      ret -= expression2(begin);\n    }\n    else if(*begin == '*' && arr3[0] == 1){\n      begin ++;\n      ret *= expression2(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nll expression0(State &begin){\n  ll ret = expression1(begin);\n  while(true){\n    if(*begin == '+' && arr1[0] == 0){\n      begin++;\n      ret += expression1(begin);\n    }\n    else if(*begin == '-' && arr2[0] == 0){\n      begin++;\n      ret -= expression1(begin);\n    }\n    else if(*begin == '*' && arr3[0] == 0){\n      begin ++;\n      ret *= expression1(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  ll mans = -LLONG_MAX;\n  do {\n    do {\n      do {\n        State begin = s.begin();\n        ll ans = expression0(begin);\n        mans = max(mans,ans);\n      } while (next_permutation(all(arr3)));\n      sort(all(arr3));\n    } while (next_permutation(all(arr2)));\n    sort(all(arr2));\n  } while (next_permutation(all(arr1)));\n  cout << mans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nint getend(string &str, int start){\n    int depth = 1;\n    int i;\n    for(i = start+1; depth > 0; i++){\n        if(str[i] == '(')depth++;\n        if(str[i] == ')')depth--;\n    }\n    return i;\n}\n\nll operate(string op, ll x, ll y){\n    char t = op[0];\n    switch(t){\n        case '*': return x*y;\n        case '+': return x+y;\n        case '^': return x-y;\n    }\n}\n\nll calc(string str, vector<string> &op){\n    //cerr << \"inp: \" << str << endl;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] == '('){\n            int end = getend(str,i);\n            ll result = calc(str.substr(i+1,end-i-2), op);\n            string putin = to_string(result);\n            str.replace(i, end-i,putin);\n        }\n    }\n    list<string> arr;\n    for(int i = 0; i < str.size(); i++){\n        if(str[i] >= '0' && str[i] <= '9'){\n            int end = i;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end-1;\n        }\n        else if(str[i] == '-'){\n            int end = i+1;\n            while(str[end] >= '0' && str[end] <= '9' && end < str.size())end++;\n            arr.push_back(str.substr(i, end-i));\n            i = end - 1;\n        }\n        else{\n            arr.push_back(string{str[i]});\n        }\n    }\n    for(auto e : op){\n        for(auto itr = arr.begin(); itr != arr.end(); ++itr){\n            if(*itr == e){\n                //cerr << \"inp: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n                auto left = itr, right = itr;--left; ++right;\n                string ins = to_string(operate(e, stoll(*left), stoll(*right)));\n                --itr;\n                for(int i = 0; i < 3; i++)itr = arr.erase(itr);\n                arr.insert(itr,ins);\n                itr = arr.begin();\n                //cerr << \"itr: \" << *itr << endl;\n                //cerr << \"res: \";\n            //for(auto v : arr)cerr << v << \" \";cerr << endl << endl;\n            }\n        }\n    }\n    //cerr  << *arr.begin() << endl;\n    return stoll(*arr.begin());\n}\n\nsigned main(){\n    string str;\n    cin >> str;\n    for(auto &e: str)if(e == '-')e = '^';\n    vector<string> op{\"*\", \"+\", \"^\"};\n    sort(ALL(op));\n    ll ans = -(ll)1e18;\n    do{\n        //for(auto e : op)cerr << e << \" \";\n        //cerr << endl;\n        ans = max(ans, calc(str, op));\n        //cerr << endl;\n    }while(next_permutation(ALL(op)));\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nmap<char, int> pri;\n\nbool is_op(char c){\n    return c == '+' || c == '-' || c == '*';\n}\n\nlint calc(lint lhs, lint rhs, char op){\n    if(op == '+') return lhs + rhs;\n    else if(op == '-') return lhs - rhs;\n    else return lhs * rhs;\n}\n\nlint expr(string &s, int &i);\nlint hoge(string &s, int &i);\nlint fuga(string &s, int &i);\nlint tapi(string &s, int &i);\nlint number(string &s, int &i);\n\nlint expr(string &s, int &i){\n    lint ret = hoge(s, i);\n    while(i < (int)s.size() && is_op(s[i]) && pri[s[i]] == 0){\n        char op = s[i];\n        ++i;\n        ret = calc(ret, hoge(s, i), op);\n    }\n    return ret;\n}\n\nlint hoge(string &s, int &i){\n    lint ret = fuga(s, i);\n    while(i < (int)s.size() && is_op(s[i]) && pri[s[i]] == 1){\n        char op = s[i];\n        ++i;\n        ret = calc(ret, fuga(s, i), op);\n    }\n    return ret;\n}\n\nlint fuga(string &s, int &i){\n    lint ret = tapi(s, i);\n    while(i < (int)s.size() && is_op(s[i]) && pri[s[i]] == 2){\n        char op = s[i];\n        ++i;\n        ret = calc(ret, tapi(s, i), op);\n    }\n    return ret;\n}\n\nlint tapi(string &s, int &i){\n    if(s[i] == '('){\n        ++i;\n        lint ret = expr(s, i);\n        ++i;\n        return ret;\n    }\n    return number(s, i);\n}\n\nlint number(string &s, int &i){\n    lint ret = 0;\n    while(i < (int)s.size() && isdigit(s[i])){\n        ret = ret * 10 + s[i]-'0';\n        ++i;\n    }\n    return ret;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    lint ans = LLONG_MIN;\n    rep(S, 27){\n        pri['+'] = S % 3;\n        pri['-'] = S/3 % 3;\n        pri['*'] = S/3/3 % 3;\n        int i = 0;\n        chmax(ans, expr(s, i));\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long STOI(string V) {\n    int LEN = V.size();\n    if (LEN == 0) { return 0; }\n    return (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return STOI(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = -999999999999999999;\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\nlong long int string_to_lli(string str); \nlong long int check(char c); \nlong long int rep_pri(char c, long long int i); \nlong long int calc(long long int first, long long int second, char ope); \nlong long int act(string str, long long int i); \n\n\nint main(void) {\n    string str;\n    cin >> str;\n\n    long long int max_res;\n    for (long long int i = 0; i < 13; i++) {\n        long long int ans = act(str, i);\n        if (i == 0) {\n            max_res = ans; \n        } else {\n            if (ans > max_res) {\n                max_res = ans;\n            }\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}\n\n// stringテ・ツ楪凝」ツつ値ong long intテ・ツ楪凝」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n                    num.push(calc(first, second, old));\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            int in = 1;\n            int out = 0;\n            while (in != out) {\n                j++;\n                if (str[j] == '(') {\n                    in++;\n                } else if (str[j] == ')') {\n                    out++;\n                }\n            }\n            long long int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            num.push(act(sub, i));\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nmap<char, int>mp;\nvoid calc(int&a, int b, char op) {\n\tif (op == '+')a += b;\n\telse if (op == '-')a -= b;\n\telse if (op == '*')a *= b;\n}\nint num(string&s, int&i) {\n\tint n = 0;\n\twhile (isdigit(s[i]))n = n * 10 + s[i++] - '0';\n\treturn n;\n}\nint o1(string&, int&);\nint o4(string&s, int&i) {\n\tif (isdigit(s[i]))return num(s, i);\n\ti++;\n\tint ret = o1(s, i);\n\ti++;\n\treturn ret;\n}\nint o3(string&s, int&i) {\n\tint v = o4(s, i);\n\twhile (mp[s[i]] == 3) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o4(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nint o2(string&s, int&i) {\n\tint v = o3(s, i);\n\twhile (mp[s[i]] == 2) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o3(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nint o1(string&s, int&i) {\n\tint v = o2(s, i);\n\twhile (mp[s[i]] == 1) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o2(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint Max = 0;\n\trep(i, 3)rep(j, 3)rep(k, 3) {\n\t\tmp['+'] = i + 1; mp['-'] = j + 1; mp['*'] = k + 1;\n\t\tint l = 0; Max = max(Max, o1(s, l));\n\t}\n\tprintf(\"%lld\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoi(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans=-1e10;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoll(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -9223372036854775807;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[10][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}};\n\n// string??????long long int????????????\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            while (str[j] != ')') {\n                j++;\n            }\n            long long int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n    long long int max_res = -1e09;\n\n    for (long long int i = 0; i < 10; i++) {\n        //ans??¨max_res???????????????\n        long long int ans = act(str, i);\n        //cout << \"I = \" << i << endl;\n        //cout << \"ANS = \" << ans << endl;\n        if (ans > max_res) {\n            max_res = ans;\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nstring op = \"+-*\";\nstring s;\nll pos = 0;\nbool end() {\n    return pos == s.size();\n}\nvoid read_char(char c) {\n    assert(!end() && s[pos] == c);\n    ++pos;\n}\nll parse(ll);\nll number() {\n    if (s[pos] == '(') {\n        read_char('(');\n        ll res = parse(0);\n        read_char(')');\n        return res;\n    }\n    else {\n        string res = \"\";\n        while ( !end() && isdigit(s[pos]) ) {\n            res += s[pos++];\n        }\n        return stoll(res);\n    }\n}\nll parse(ll oid) {\n    if (oid == op.size()) return number();\n    ll res = parse(oid+1);\n    while ( !end() && s[pos] == op[oid] ) {\n        read_char(op[oid]);\n        ll right = parse(oid+1);\n        switch (op[oid]) {\n            case '*': res *= right; break;\n            case '+': res += right; break;\n            case '-': res -= right; break;\n        }\n    }\n    return res;\n}\nll parse() {\n    pos = 0;\n    return parse(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    ll ans = -linf;\n    sort(all(op));\n    do {\n        // cout << op << \" \" << parse() << endl;\n        chmax(ans, parse());\n    } while ( next_permutation(all(op)) );\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef string::iterator state;\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nmap<char, int> mp;\nstring operators = \"*-+\";\nll ans = LONG_MIN;\nll one(state &itr);\nll two(state &itr);\nll three(state &itr);\nll number(state &itr);\nll one(state &itr) {\n    ll now = two(itr);\n    while(true) {\n        //cerr << \"one: \" << *itr << endl;\n        if(*itr == ')') {\n            itr++;\n            return now;\n        }\n        if(*itr == '=') return now;\n        if(*itr == '-') {\n            itr++;\n            now -= two(itr);\n            continue;\n        }\n        if(*itr == '+') {\n            itr++;\n            now += two(itr);\n            continue;\n        }\n        if(*itr == '*') {\n            itr++;\n            now *= two(itr);\n            continue;\n        }\n    }\n}\n\nll two(state &itr) {\n    ll now = three(itr);\n    while(true) {\n        //cerr << \"tow: \" << *itr << endl;\n        if(mp[*itr] <= 1) {\n            return now;\n        }\n        if(*itr == '-') {\n            itr++;\n            now -= three(itr);\n            continue;\n        }\n        if(*itr == '+') {\n            itr++;\n            now += three(itr);\n            continue;\n        }\n        if(*itr == '*') {\n            itr++;\n            now *= three(itr);\n            continue;\n        }\n        return now;\n    }\n}\n\nll three(state &itr) {\n    ll now = number(itr);\n    while(true) {\n        //cerr << \"three: \" << *itr << endl;\n        //if(*itr == operators[0] || *itr == operators[1]) return now;\n        if(mp[*itr] <= 2) return now;\n        if(*itr == '-') {\n            itr++;\n            now -= number(itr);\n            continue;\n        }\n        if(*itr == '+') {\n            itr++;\n            now += number(itr);\n            continue;\n        }\n        if(*itr == '*') {\n            itr++;\n            now *= number(itr);\n            continue;\n        }\n        return now;\n    }\n}\n\nll number(state &itr) {\n    if(*itr == '(') {\n        itr++;\n        return one(itr);\n    }\n    ll now = 0;\n    while(true) {\n        //cerr << \"number: \" << *itr << endl;\n        if(*itr < '0' || *itr > '9') return now;\n        now *= 10;\n        now += *itr - '0';\n        itr++;\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    S = S + \"=\";\n    //sort(operators.begin(), operators.end());\n    //do {\n    for(mp['+'] = 1; mp['+'] <= 3; mp['+']++) {\n        for(mp['-'] = 1; mp['-'] <= 3; mp['-']++) {\n            for(mp['*'] = 1; mp['*'] <= 3; mp['*']++) {\n                state itr = S.begin();\n                ll now = one(itr);\n                ans = max(ans, now);\n            }\n        }\n    }\n        //cerr << operators << \" \" << now << endl;\n    //} while(next_permutation(operators.begin(), operators.end()));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\n#include <algorithm>\nusing std::max;\n#include <string>\nusing std::string;\n#include <stack>\nusing std::stack;\n\nconst int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\nlong long int string_to_lli(string str); \nint check(char c); \nint rep_pri(char c, long long int i); \nlong long int inner_calc(long long int first, long long int second, char ope); \nvoid calc(stack<long long int>& num, stack<char>& ope); \nlong long int act(string str, long long int i); \n\nint main(void) {\n    string str;\n    cin >> str;\n\n    long long int max_res;\n    for (int i = 0; i < 13; i++) {\n        long long int ans = act(str, i);\n        if (i == 0) {\n            max_res = ans; \n        } else {\n            max_res = max(max_res, ans);\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}\n\n// string??????long long int????????????\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nint check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nint rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int inner_calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nvoid calc(stack<long long int>& num, stack<char>& ope) {\n    long long int second = num.top();\n    num.pop();\n    long long int first = num.top();\n    num.pop();\n    num.push(inner_calc(first, second, ope.top()));\n    ope.pop();\n    return;\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        if (check(str[j]) == 0) {\n            int start = j;\n            while (check(str[j]) == 0) {\n                j++;\n            }\n            int end = j;\n            j--;\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    calc(num, ope);\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (check(str[j]) == 2) {\n            int start = j;\n            int kakko = 1;\n            while (kakko != 0) {\n                j++;\n                if (str[j] == '(') {\n                    kakko++;\n                } else if (str[j] == ')') {\n                    kakko--;\n                }\n            }\n            int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            num.push(act(sub, i));\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        calc(num, ope);\n    }\n\n    return num.top();\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return stoll(S.substr(L,R-L));\n}\nint main() {\n\tcin >> s; long long ret = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, s.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// <expr>   ::= <term> [ ('+'|'-') <term> ]*\n// <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n// <factor> ::= <number> | '(' <expr> ')'\n// <number> :== ???????????°\n\nll expr(int& pos);\nll mid(int& pos);\nll term(int& pos);\nll factor(int& pos);\nll number(int& pos);\n\nstring s;\nmap<char,int> mp;\n\nvoid comp(ll& a1,ll a2,char c){\n    if(c == '+'){\n        a1 += a2;\n    }else if(c == '-'){\n        a1 -= a2;\n    }else{\n        a1 *= a2;\n    }\n}\n\nll expr(int& pos){\n    ll res = mid(pos);\n    while(mp[s[pos]] == 1){\n        char c = s[pos];\n        comp(res,mid(++pos),c);\n    }\n    return res;\n}\n\nll mid(int& pos){\n    ll res = term(pos);\n    while(mp[s[pos]] == 2){\n        char c = s[pos];\n        comp(res,term(++pos),c);\n    }\n    return res;\n}\n\nll term(int& pos){\n    ll res = factor(pos);\n    while(mp[s[pos]] == 3){\n        char c = s[pos];\n        comp(res,factor(++pos),c);\n    }\n    return res;\n}\n\nll factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('?????¨??°???\n    ll res = expr(pos);\n    pos++;  //')'?????¨??°???\n    return res;\n}\n\nll number(int& pos){\n    string res;\n    while(isdigit(s[pos])){\n        res.pb(s[pos++]);\n    }\n    return stoi(res);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> s;\n    vi v(3);\n    string hoge = \"+-*\";\n    iota(all(v),0);\n    ll mx = -(1LL << 60);\n    int pos = 0;\n    rep(i,3){\n        rep(j,3){\n            rep(k,3){\n                mp['+'] = i+1,mp['-'] = j+1,mp['*'] = k+1;\n                pos = 0;\n                cmx(mx,expr(pos));\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nbool is_op(char c) {\n    return c == '+' || c == '-' || c == '*';\n}\n\nint fun(char c, int x, int y) {\n    if (c == '+') return x+y;\n    if (c == '-') return x-y;\n    if (c == '*') return x*y;\n    assert(0);\n    return 0LL;\n}\n\nstring s;\nmap<char,int> pri;\n\nint expr(int&);\nint term(int&);\n\nint expr(int &i) {\n    vector<char> op;\n    vector<int> val = {term(i)};\n    auto reduce = [&]() {\n        assert(sz(op) >= 1);\n        assert(sz(val) >= 2);\n        int y = val.back(); val.pop_back();\n        int x = val.back(); val.pop_back();\n        val.eb(fun(op.back(),x,y));\n        op.pop_back();\n    };\n    while (i < sz(s) && is_op(s[i])) {\n        char c = s[i]; i++;\n        int x = term(i);\n        while (op.size() && pri[op.back()] >= pri[c]) {\n            reduce();\n        }\n        op.eb(c);\n        val.eb(x);\n    }\n    while (op.size()) reduce();\n    assert(op.empty());\n    assert(sz(val) == 1);\n    return val[0];\n}\n\nint term(int &i) {\n    if (s[i] == '(') {\n        i++;\n        int val = expr(i);\n        assert(s[i] == ')');\n        i++;\n        return val;\n    } else {\n        assert(isdigit(s[i]));\n        int val = s[i++]-'0';\n        while (isdigit(s[i])) {\n            val = val*10 + (s[i++]-'0');\n        }\n        return val;\n    }\n}\n\nint32_t main() {\n    cin >> s;\n\n    vector<int> res;\n    rep (x,3) rep (y,3) rep (z,3) {\n        pri = { {'+',x}, {'-',y}, {'*',z} };\n        int i = 0;\n        int val = expr(i);\n        res.eb(val);\n    }\n\n    cout << *max_element(all(res)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define CR const &\n\ntypedef long long Val;\n\nVal operate(Val a, Val b, char r){\n    if(r != '+' && r != '-' && r != '*'){\n        printf(\" %c\\n\",r);\n        assert(false);\n    }\n    return r=='+' ? a+b : r=='-' ? a-b : a*b;\n}\n\nnamespace AAA {\n    pair<Val,int> A(int pos, const char * s);\n    pair<Val,int> B(int pos, const char * s);\n    pair<Val,int> A(int pos, const char * s){\n        Val res;\n        tie(res,pos) = B(pos,s);\n        while(s[pos] && (s[pos] == '+' || s[pos] == '-' || s[pos] == '*')){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = B(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> B(int pos, const char * s){\n        if(s[pos] == '('){\n            pos++;\n            pair<Val,int> res = A(pos,s);\n            res.second++;\n            return res;\n        }\n        if(isdigit(s[pos])){\n            Val res = 0;\n            while(isdigit(s[pos])){\n                res = res*10 + s[pos++]-'0';\n            }\n            return make_pair(res,pos);\n        }\n        printf(\" %d %s %c\\n\", pos, s, s[pos]);\n        assert(false);\n    }\n}\n\nnamespace AAB {\n    char a1,a2,b;\n    pair<Val,int> A(int pos, const char * s);\n    pair<Val,int> B(int pos, const char * s);\n    pair<Val,int> C(int pos, const char * s);\n    pair<Val,int> A(int pos, const char * s){\n        Val res;\n        tie(res,pos) = B(pos,s);\n        while(s[pos] && (s[pos] == a1 || s[pos] == a2)){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = B(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> B(int pos, const char * s){\n        Val res;\n        tie(res,pos) = C(pos,s);\n        while(s[pos] && s[pos] == b){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = C(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> C(int pos, const char * s){\n        if(s[pos] == '('){\n            pair<Val,int> res = A(pos+1,s);\n            res.second++;\n            return res;\n        }\n        if(isdigit(s[pos])){\n            Val res = 0;\n            while(isdigit(s[pos])){\n                res = res*10 + s[pos++]-'0';\n            }\n            return make_pair(res,pos);\n        }\n        assert(false);\n    }\n}\n\nnamespace ABB {\n    char a,b1,b2;\n    pair<Val,int> A(int pos, const char * s);\n    pair<Val,int> B(int pos, const char * s);\n    pair<Val,int> C(int pos, const char * s);\n    pair<Val,int> A(int pos, const char * s){\n        Val res;\n        tie(res,pos) = B(pos,s);\n        while(s[pos] && s[pos] == a){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = B(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> B(int pos, const char * s){\n        Val res;\n        tie(res,pos) = C(pos,s);\n        while(s[pos] && (s[pos] == b1 || s[pos] == b2)){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = C(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> C(int pos, const char * s){\n        if(s[pos] == '('){\n            pair<Val,int> res = A(pos+1,s);\n            res.second++;\n            return res;\n        }\n        if(isdigit(s[pos])){\n            Val res = 0;\n            while(isdigit(s[pos])){\n                res = res*10 + s[pos++]-'0';\n            }\n            return make_pair(res,pos);\n        }\n        assert(false);\n    }\n}\n\nnamespace ABC {\n    char a,b,c;\n    pair<Val,int> A(int pos, const char * s);\n    pair<Val,int> B(int pos, const char * s);\n    pair<Val,int> C(int pos, const char * s);\n    pair<Val,int> D(int pos, const char * s);\n    pair<Val,int> A(int pos, const char * s){\n        Val res;\n        tie(res,pos) = B(pos,s);\n        while(s[pos] && s[pos] == a){\n            char op = s[pos];\n            pos++;\n            Val ths;\n            tie(ths,pos) = B(pos,s);\n            res = operate(res,ths,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> B(int pos, const char * s){\n        Val res;\n        tie(res,pos) = C(pos,s);\n        while(s[pos] && s[pos] == b){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = C(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> C(int pos, const char * s){\n        Val res;\n        tie(res,pos) = D(pos,s);\n        while(s[pos] && s[pos] == c){\n            char op = s[pos];\n            pos++;\n            Val rhs;\n            tie(rhs,pos) = D(pos,s);\n            res = operate(res,rhs,op);\n        }\n        return make_pair(res,pos);\n    }\n    pair<Val,int> D(int pos, const char * s){\n        if(s[pos] == '('){\n            pair<Val,int> res = A(pos+1,s);\n            res.second++;\n            return res;\n        }\n        if(isdigit(s[pos])){\n            Val res = 0;\n            while(isdigit(s[pos])){\n                res = res*10 + s[pos++]-'0';\n            }\n            return make_pair(res,pos);\n        }\n        assert(false);\n    }\n}\n\nint main(){\n    string s;\n    while(cin >> s){\n        Val ans = numeric_limits<Val>::min();\n        char op[] = \"+-*\";\n        sort(op,op+3);\n        do {\n            AAB::a1 = ABB::a  = ABC::a = op[0];\n            AAB::a2 = ABB::b1 = ABC::b = op[1];\n            AAB::b  = ABB::b2 = ABC::c = op[2];\n            ans = max(ans, AAA::A(0,s.c_str()).first);\n            ans = max(ans, AAB::A(0,s.c_str()).first);\n            ans = max(ans, ABB::A(0,s.c_str()).first);\n            ans = max(ans, ABC::A(0,s.c_str()).first);\n        }while(next_permutation(op,op+3));\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10;\n\t\tres += *it - '0';\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nclass Calc22 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc22(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n\nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n      \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f1();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n   \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1] || *it == p[2]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else if (*it == p[1]) {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            } else {\n                ++it;\n                res = get_val(res, p[2], f0());                \n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc22 c22(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(max(c.f3(), c2.f2()), max(c22.f2(), c3.f1())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nconstexpr ll LLINF = numeric_limits<ll>::max();\n\nstring S;\nvint v(3);\nstring c = \"+-*\";\n\nll merge(ll a, ll b, int f) {\n\tif (f == 0) return (a + b);\n\tif (f == 1) return (a - b);\n\treturn (a * b);\n}\n\n//[a, b)\nll solve(int a, int b) {\n\t//char r; cin >> r;\n\t//cout << a << \" \" << b << endl;\n\n\tif (S[a] == '(' && S[b-1] == ')') {\n\t\ta++, b--;\n\t\tint cnt = 0;\n\t\tbool ff = false;\n\t\tfor (int i = a; i < b; i++) {\n\t\t\tif (S[i] == '(') cnt++;\n\t\t\tif (S[i] == ')') cnt--;\n\t\t\tif (cnt < 0) ff = true;\n\t\t}\n\t\tif (!ff) return (solve(a, b));\n\t\ta--, b++;\n\t}\n\n\tint cnt = 0;\n\tvint li1;\n\tli1.push_back(a);\n\tfor (int i = a; i < b; i++) {\n\t\tif (S[i] == '(') cnt++;\n\t\tif (S[i] == ')') cnt--;\n\t\tif (cnt == 0) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[i] == c[k] && v[k] == 1) li1.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tli1.push_back(b);\n\t\n\tif (li1.size() > 2) {\n\t\tll val = solve(li1[0], li1[1]);\n\t\tfor (int i = 1; i < (int)li1.size()-1; i++) {\n\t\t\tint d1 = li1[i], d2 = li1[i+1];\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[d1] == c[k]) val = merge(val, solve(d1+1, d2), k);\n\t\t\t}\n\t\t}\n\t\treturn (val);\n\t}\n\n\tcnt = 0;\n\tvint li2;\n\tli2.push_back(a);\n\tfor (int i = a; i < b; i++) {\n\t\tif (S[i] == '(') cnt++;\n\t\tif (S[i] == ')') cnt--;\n\t\tif (cnt == 0) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[i] == c[k] && v[k] == 2) li2.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tli2.push_back(b);\n\t\n\tif (li2.size() > 2) {\n\t\tll val = solve(li2[0], li2[1]);\n\t\tfor (int i = 1; i < (int)li2.size()-1; i++) {\n\t\t\tint d1 = li2[i], d2 = li2[i+1];\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[d1] == c[k]) val = merge(val, solve(d1+1, d2), k);\n\t\t\t}\n\t\t}\n\t\treturn (val);\n\t}\n\n\tcnt = 0;\n\tvint li3;\n\tli3.push_back(a);\n\tfor (int i = a; i < b; i++) {\n\t\tif (S[i] == '(') cnt++;\n\t\tif (S[i] == ')') cnt--;\n\t\tif (cnt == 0) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[i] == c[k] && v[k] == 3) li3.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tli3.push_back(b);\n\t\n\tif (li3.size() > 2) {\n\t\tll val = solve(li3[0], li3[1]);\n\t\tfor (int i = 1; i < (int)li3.size()-1; i++) {\n\t\t\tint d1 = li3[i], d2 = li3[i+1];\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tif (S[d1] == c[k]) val = merge(val, solve(d1+1, d2), k);\n\t\t\t}\n\t\t}\n\t\treturn (val);\n\t}\n\n\tll ret = stol(S.substr(a, b-a));\n\t//cout << a << \" \" << b << \" \" << ret << endl;\n\treturn (ret);\n}\n\nint main() {\n\tcin >> S;\n\n\tll maxv = -LLINF;\n\tfor (v[0] = 1; v[0] <= 3; v[0]++) {\n\t\tfor (v[1] = 1; v[1] <= 3; v[1]++) {\n\t\t\tfor (v[2] = 1; v[2] <= 3; v[2]++) {\n\t\t\t\tll val = solve(0, S.size());\n\t\t\t\tmaxv = max(maxv, val);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << maxv << endl;\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tPlus,\n\tMinus,\n\tMult,\n};\n\nint loc[128];\n\n\nll calc_two_same(char line[202],int rank[3],int maximum){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('&& rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_three_same(char line[202]){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_all_different(char line[202],int rank[3],int maximum){\n\n\tint work_line_length,work_rank[3];\n\tll tmp,op1,work,count,work2,work_tmp;\n\tchar calc,work_line[202];\n\tstack<ll> NUM,work_num;\n\tstack<ll> to_make_work;\n\tqueue<ll> work_num2;\n\tstack<char> OP,work_op;\n\tqueue<char> work_op2;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '(' && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint maximum;\n\tloc['+'] = 0;\n\tloc['-'] = 1;\n\tloc['*'] = 2;\n\n\tchar line[202];\n\tint length;\n\n\tscanf(\"%s\",line);\n\tfor(length = 0; line[length] != '\\0';length++);\n\n\tline[length] = '=';\n\tline[length+1] = '\\0';\n\n\tint rank[3],num[3];\n\tll ans = -BIG_NUM,tmp_ans;\n\n\tfor(int a = 0; a <= 2; a++){\n\t\tfor(int b = 0; b <= 2; b++){\n\t\t\tfor(int c = 0; c <= 2; c++){\n\n\t\t\t\tfor(int i = 0; i < 3; i++)num[i] = 0;\n\n\t\t\t\trank[Plus] = a;\n\t\t\t\trank[Minus] = b;\n\t\t\t\trank[Mult] = c;\n\n\t\t\t\tmaximum = -1;\n\t\t\t\tmaximum = max(a,max(b,c));\n\n\t\t\t\tnum[a]++;\n\t\t\t\tnum[b]++;\n\t\t\t\tnum[c]++;\n\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttmp_ans = calc_all_different(line,rank,maximum);\n\t\t\t\t}else if(num[0] == 3 || num[1] == 3 || num[2] == 3){\n\t\t\t\t\ttmp_ans = calc_three_same(line);\n\t\t\t\t}else{\n\t\t\t\t\ttmp_ans = calc_two_same(line,rank,maximum);\n\t\t\t\t}\n\t\t\t\tans = max(ans,tmp_ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1LL<<62)\n\ntypedef long long ll;\n\nstring s;\nint p;\nmap<char,int> t;\nll f(ll a,char ch,ll b){\n  if(ch=='+')return a+b;\n  else if(ch=='-')return a-b;\n  else return a*b;\n}\n\n\nll calc(int X);\n\nll getNum(){\n  if(s[p]=='('){\n    p++;\n    return calc(0);\n  }else{\n    ll res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+s[p]-'0';\n      p++;\n    }\n    return res;\n  }\n}\n\nll calc(int X){\n  if(X==3) return getNum();\n  ll res=calc(X+1);\n  while(1){\n    char ch=s[p++];\n    if(ch==')'||ch=='='||t[ch]<X){\n      if(X!=0)p--;\n      break;\n    }\n    res=f(res,ch,calc(X+1));\n  }\n  return res;\n}\n\nint main(){\n  cin>>s;\n  s.push_back('=');\n  ll ans=-INF;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      for(int k=0;k<3;k++){\n        t['+']=i;\n        t['-']=j;\n        t['*']=k;\n        p=0;\n        ans=max(ans,calc(0));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nmap<char, int>mp;\nvoid calc(int&a, int b, char op) {\n\tif (op == '+')a += b;\n\telse if (op == '-')a -= b;\n\telse if (op == '*')a *= b;\n}\nint num(string&s, int&i) {\n\tint n = 0;\n\twhile (isdigit(s[i]))n = n * 10 + s[i++] - '0';\n\treturn n;\n}\nint o1(string&, int&);\nint o4(string&s, int&i) {\n\tif (isdigit(s[i]))return num(s, i);\n\ti++;\n\tint ret = o1(s, i);\n\ti++;\n\treturn ret;\n}\nint o3(string&s, int&i) {\n\tint v = o4(s, i);\n\twhile (mp[s[i]] == 3) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o4(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nint o2(string&s, int&i) {\n\tint v = o3(s, i);\n\twhile (mp[s[i]] == 2) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o3(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nint o1(string&s, int&i) {\n\tint v = o2(s, i);\n\twhile (mp[s[i]] == 1) {\n\t\tchar op = s[i]; i++;\n\t\tint v2 = o2(s, i);\n\t\tcalc(v, v2, op);\n\t}\n\treturn v;\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint Max = LLONG_MIN;\n\trep(i, 3)rep(j, 3)rep(k, 3) {\n\t\tmp['+'] = i + 1; mp['-'] = j + 1; mp['*'] = k + 1;\n\t\tint l = 0; Max = max(Max, o1(s, l));\n\t}\n\tprintf(\"%lld\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring op = \"+-*\";\nll parse(string s, int &i, vector<int> pri, int x)\n{\n\t//printf(\"(%d, %d)\\n\", i, x);\n\n\tif (x == 3)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tll ret = parse(s, i, pri, 0);\n\t\t\ti++;\n\t\t\treturn ret;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '9')\n\t\t\t{\n\t\t\t\tret = ret * 10 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tll ret = parse(s, i, pri, x + 1);\n\n\t\tbool ok = true;\n\t\twhile (ok)\n\t\t{\n\t\t\tok = false;\n\t\t\tfor (int j = 0; j < 3; j++) if (s[i] == op[j] && pri[j] == x)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tswitch (s[i])\n\t\t\t\t{\n\t\t\t\tcase '+': i++; ret += parse(s, i, pri, x + 1); break;\n\t\t\t\tcase '-': i++; ret -= parse(s, i, pri, x+1); break;\n\t\t\t\tcase '*': i++; ret *= parse(s, i, pri, x+1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n}\n\nint main()\n{\n\tstring s; cin >> s; s += \"=\";\n\tll ans;\n\tbool init = true;\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) for (int k = 0; k < 3; k++)\n\t{\n\t\tint ii = 0;\n\t\tll ret = parse(s, ii, {i,j,k}, 0);\n\n\t\tif (init)\n\t\t{\n\t\t\tans = ret;\n\t\t\tinit = false;\n\t\t}\n\t\telse\n\t\t\tans = max(ans, ret);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<cstdlib>\nusing namespace std;\n\nstring O[27]={\"111\",\"112\",\"113\",\"121\",\"122\",\"123\",\"131\",\"132\",\"133\",\"211\",\"212\",\"213\",\"221\",\"222\",\"223\",\"231\",\"232\",\"233\",\"311\",\"312\",\"313\",\"321\",\"322\",\"323\",\"331\",\"332\",\"333\"};\n\nstring cal(vector<string> V,int in)\n{  \n  for(int i=0;i<V.size();i++){\n    if(V[i]==\"(\"){\n      int l=1,r=0;\n      vector<string> v;\n      string s;\n      V.erase(V.begin()+i);\n      while(1){\n\tif(V[i]==\"(\")l++;\n\tif(V[i]==\")\")r++;\n\tv.push_back(V[i]);\n\tV.erase(V.begin()+i);\t \n\tif(r==l){\n\t  v.pop_back();\n\t  s=cal(v,in);\n\t  V.insert(V.begin()+i,s);\n\t  break;\n\t}\n      }\n    }\n  }\n  for(int k=1;k<=3;k++){\n    for(int i=0;i<V.size();i++){\n      if(V[i]==\"+\"){\n\tif((O[in][0]-'0')==k){\n\t  long long a=atol(V[i-1].c_str())+atol(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n      else if(V[i]==\"-\"){\n\tif((O[in][1]-'0')==k){\n\t  long long a=atol(V[i-1].c_str())-atol(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n      else if(V[i]==\"*\"){\n\tif((O[in][2]-'0')==k){\n\t  long long a=atol(V[i-1].c_str())*atol(V[i+1].c_str());\n\t  stringstream ss;\n\t  ss << a;\n\t  string S=ss.str();\n\t  V.erase(V.begin()+i+1);\n\t  V.erase(V.begin()+i);\n\t  V.erase(V.begin()+i-1);\n\t  V.insert(V.begin()+i-1,S);\n\t  i-=2;\n\t}\n      }\n    }\n  }\n  return V[0];\n}\nint main()\n{\n  string s,samp;\n  long long ans=0;\n  vector<string> V;\n  cin>>s;\n  for(int i=0;i<s.length();i++){\n    if('0'<=s[i] && s[i]<='9'){\n      samp+=s[i];\n      if(i==s.length()-1)V.push_back(samp);\n    }\n    else {\n      if(!samp.empty()){\n\tV.push_back(samp);\n\tsamp=\"\";\n      }\n      samp=s[i];\n      V.push_back(samp);\n      samp=\"\";\n    }\n  }\n  for(int i=0;i<27;i++){\n    string a=cal(V,i);\n    long long b=atol(a.c_str());\n    ans=max(b,ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \ntypedef long long LL;\n \ntypedef struct ParserState {\n    int pos, len;\n    std::string str;\n    std::deque<int> stack;\n \n    bool isEOF() {return pos >= len;}\n    bool isNotEOF() {return pos < len;}\n \n    char getCh() {\n        return pos < len ? str[pos++] : -1;\n    }\n    char seek() {\n        return pos < len ? str[pos] : -1;\n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n    std::string lookAhead(int l) {\n        return str.substr(pos, l);\n    }\n \n    void setBackrack(){stack.push_front(pos);}\n    bool backtrack(){\n        if(stack.empty()) return false;\n        pos = stack.front();\n        stack.pop_front();\n        return true;\n    }\n \n    bool isDigit(){return isDigit(0);}\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha(){return isUpperAlpha(0);}\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha(){return isLowerAlpha(0);}\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c != -1 && c >= 'a' && c <= 'z';\n    }\n}State;\n \nstd::map<char,int> pri;\nint bot = 0;\n \nLL parseNumber(State*);\nLL parse(State*);\n \nLL calc(char op, LL left, LL right) {\n    if(op == '+') return left + right;\n    if(op == '-') return left - right;\n    if(op == '*') return left * right;\n    return assert(pri.count(op) > 0), -1;\n}\n \nLL parseNumber(State* state) {\n    LL res = 0LL;\n    while(state->isNotEOF() && state->isDigit()) {\n        res *= 10;\n        res += (int)(state->getCh() - '0');\n    }\n    return res;\n}\n \nLL parse(int level, State* state) {\n    if(bot < level) {\n        if(state->isDigit()) return parseNumber(state);\n \n        state->getCh(); // eat (\n        LL r = parse(0, state);\n        state->getCh(); // eat )\n        return r;\n    }\n \n    LL result = parse(level + 1, state);\n    while(state->isNotEOF() && state->seek() != ')') {\n        char ch = state->seek();\n        if(pri[ch] < level) break;\n        state->getCh(); //eat op\n \n        LL res = parse(level + 1, state);\n        result = calc(ch, result, res);\n    }\n    return result;\n}\n \nint main() {\n    std::string S;\n    std::cin >> S;\n    int len = S.length();\n \n    LL ans = std::numeric_limits<LL>::min();\n    for(int i=0; i<27; ++i) {\n        pri['+'] = i     % 3;\n        pri['-'] = (i/3) % 3;\n        pri['*'] = (i/9) % 3;\n        bot = std::max(i%3, std::max((i/3)%3, (i/9)%3));\n \n        State state = State{0, len, S};\n        LL res = parse(0, &state);\n \n        ans = std::max(ans, res);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10LL;\n\t\tres += (ll)(*it - '0');\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nclass Calc22 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc22(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n\nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n      \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f1();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n   \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1] || *it == p[2]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else if (*it == p[1]) {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            } else {\n                ++it;\n                res = get_val(res, p[2], f0());                \n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = LLONG_MIN;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc22 c22(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(max(c.f3(), c2.f2()), max(c22.f2(), c3.f1())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        return -1;\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10;\n\t\tres += *it - '0';\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc c(str, p);\n        ll r = c.f3();\n        res = max(res, r);\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State&);\nint term(State&);\nint term2(State&);\nint number(State&);\nint factor(State&);\n\nchar op[3] = {'+', '-', '*'};\nint expression(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += term(begin);\n\t\t\telse if(op[0] == '-') ret -= term(begin);\n\t\t\telse if(op[0] == '*') ret *= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint termB(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factor(begin);\n\t\t\telse if(op[1] == '-') ret -= factor(begin);\n\t\t\telse if(op[1] == '*') ret *= factor(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionB(State &begin) {\n\tint ret = termB(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += termB(begin);\n\t\t\telse if(op[0] == '-') ret -= termB(begin);\n\t\t\telse if(op[0] == '*') ret *= termB(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint termD(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factor(begin);\n\t\t\telse if(op[0] == '-') ret -= factor(begin);\n\t\t\telse if(op[0] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionD(State &begin) {\n\tint ret = termB(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factor(begin);\n\t\t\telse if(op[1] == '-') ret -= factor(begin);\n\t\t\telse if(op[1] == '*') ret *= factor(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expressionC(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += factor(begin);\n\t\t\telse if(op[0] == '-') ret -= factor(begin);\n\t\t\telse if(op[0] == '*') ret *= factor(begin);\n\t\t} else if(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += factor(begin);\n\t\t\telse if(op[1] == '-') ret -= factor(begin);\n\t\t\telse if(op[1] == '*') ret *= factor(begin);\n\t\t} else if(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = term2(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += term2(begin);\n\t\t\telse if(op[1] == '-') ret -= term2(begin);\n\t\t\telse if(op[1] == '*') ret *= term2(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term2(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tstring s;\n\tgetline(cin, s);\n\n\tsort(op, op+3);\n\tint ret = -LLINF;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tret = max(ret, ans);\n\t\t// REP(i, 3) cout << op[i] << \" \";\n\t\t// cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\tsort(op, op+3);\n\t// cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionB(begin);\n\t\tret = max(ret, ans);\n\t\t// REP(i, 3) cout << op[i] << \" \";\n\t\t// cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\tsort(op, op+3);\n\t// cout << \"A\" << endl;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expressionD(begin);\n\t\tret = max(ret, ans);\n\t\t// REP(i, 3) cout << op[i] << \" \";\n\t\t// cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\tState begin = s.begin();\n\tint ans = expressionC(begin);\n\tret = max(ret, ans);\n\t//REP(i, 3) cout << op[i] << \" \";\n\t//cout << ret << \" \" << ans << endl;\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10;\n\t\tres += *it - '0';\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nclass Calc22 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc22(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n\nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n      \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f1();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10;\n                res += *it - '0';\n                ++it;\n            }\n        }\n        return res;\n    }\n   \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1] || *it == p[2]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else if (*it == p[1]) {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            } else {\n                ++it;\n                res = get_val(res, p[2], f0());                \n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc22 c22(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(max(c.f3(), c2.f2()), max(c22.f2(), c3.f1())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long STOI(string V) {\n    int LEN = V.size();\n    if (LEN == 0) { return 0; }\n    return (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return STOI(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return stoll(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int junjo[4];\nlong long STOI(string V) {\n    int LEN = V.size();\n    if (LEN == 0) { return 0; }\n    return (V[LEN - 1] - '0') + 10 * (STOI(V.substr(0, LEN - 1)));\n}\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    cout << S.substr(L, R-L) << endl;\n    return STOI(S.substr(L,R-L));\n}\nint main() {\n\tcin >> S; long long ret = 0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tjunjo[0] = i, junjo[1] = j, junjo[2] = k;\n\t\t\t\tret = max(ret, calc(0, S.size() - 1));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tPlus,\n\tMinus,\n\tMult,\n};\n\nint loc[128];\n\nll calc_two_same(char line[202],int rank[3],int maximum){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('&& rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nll calc_three_same(char line[202]){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_all_different(char line[202],int rank[3],int maximum){\n\n\tint work_line_length,work_rank[3];\n\tll tmp,op1,work,count,work2,work_tmp;\n\tchar calc,work_line[202];\n\tstack<ll> NUM,work_num;\n\tstack<ll> to_make_work;\n\tqueue<ll> work_num2;\n\tstack<char> OP,work_op;\n\tqueue<char> work_op2;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{ //??°?????§????????´???\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '(' && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint maximum;\n\tloc['+'] = 0;\n\tloc['-'] = 1;\n\tloc['*'] = 2;\n\n\tchar line[202];\n\tint length;\n\n\tscanf(\"%s\",line);\n\tfor(length = 0; line[length] != '\\0';length++);\n\n\tline[length] = '=';\n\tline[length+1] = '\\0';\n\n\tint rank[3],num[3];\n\tll ans = -BIG_NUM,tmp_ans;\n\n\tfor(int a = 0; a <= 2; a++){\n\t\tfor(int b = 0; b <= 2; b++){\n\t\t\tfor(int c = 0; c <= 2; c++){\n\n\t\t\t\tfor(int i = 0; i < 3; i++)num[i] = 0;\n\n\t\t\t\trank[Plus] = a;\n\t\t\t\trank[Minus] = b;\n\t\t\t\trank[Mult] = c;\n\n\t\t\t\tmaximum = -1;\n\t\t\t\tmaximum = max(a,max(b,c));\n\n\t\t\t\tnum[a]++;\n\t\t\t\tnum[b]++;\n\t\t\t\tnum[c]++;\n\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttmp_ans = calc_all_different(line,rank,maximum);\n\t\t\t\t}else if(num[0] == 3 || num[1] == 3 || num[2] == 3){\n\t\t\t\t\ttmp_ans = calc_three_same(line);\n\t\t\t\t}else{\n\t\t\t\t\ttmp_ans = calc_two_same(line,rank,maximum);\n\t\t\t\t}\n\t\t\t\tans = max(ans,tmp_ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nconst int opst[27][3] = {\n\t{0,0,0},\n\t{0,0,1},\n\t{ 0,0,2 },\n\t{ 0,1,0 },\n\t{ 0,1,1 },\n\t{ 0,1,2 },\n\t{ 0,2,0 },\n\t{ 0,2,1 },\n\t{ 0,2,2 },\n\t{ 1,0,0 },\n\t{ 1,0,1 },\n\t{ 1,0,2 },\n\t{ 1,1,0 },\n\t{ 1,1,1 },\n\t{ 1,1,2 },\n\t{ 1,2,0 },\n\t{ 1,2,1 },\n\t{ 1,2,2 },\n\t{ 2,0,0 },\n\t{ 2,0,1 },\n\t{ 2,0,2 },\n\t{ 2,1,0 },\n\t{ 2,1,1 },\n\t{ 2,1,2 },\n\t{ 2,2,0 },\n\t{ 2,2,1 },\n\t{ 2,2,2 },\n};\n\nll calc(vector<ll> num, vector<int> op, int pri) {\n\tREP(n,3)\n\tREP(i,op.size()) {\n\t\tif (opst[pri][op[i]] == n) {\n\t\t\tif (op[i] == 0) {\n\t\t\t\tnum[i] += num[i + 1];\n\t\t\t}\n\t\t\telse if (op[i] == 1) {\n\t\t\t\tnum[i] -= num[i + 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[i] *= num[i + 1];\n\t\t\t}\n\t\t\tFOR(j, i + 1, num.size() - 1)\n\t\t\t\tnum[j] = num[j + 1];\n\t\t\tnum.resize(num.size() - 1);\n\t\t\tFOR(j, i, op.size() - 1)\n\t\t\t\top[j] = op[j + 1];\n\t\t\top.resize(op.size() - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn num[0];\n}\nll saiki(string s, int &idx, int pri) {\n\tvector<ll> num;\n\tvector<int> op;\n\twhile ((size_t)(idx) < s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tnum.push_back(saiki(s, idx, pri));\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn calc(num, op, pri);\n\t\t}\n\t\tif (isdigit(s[idx])) {\n\t\t\tll num2 = 0;\n\t\t\twhile ((size_t)idx < s.length() && isdigit(s[idx])) {\n\t\t\t\tnum2 *= 10;\n\t\t\t\tnum2 += s[idx] - '0';\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tnum.push_back(num2);\n\t\t\tcontinue;\n\t\t}\n\t\tint opn=0;\n\t\tif (s[idx] == '-')\n\t\t\topn = 1;\n\t\tif (s[idx] == '*')\n\t\t\topn = 2;\n\t\top.push_back(opn);\n\t\tidx++;\n\t}\n\treturn calc(num, op, pri);\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tll ma = 1;\n\tma <<= 63;\n\tma *= -1;\n\tREP(i, 27) {\n\t\tint idx = 0;\n\t\tma = max(ma,saiki(s, idx, i));\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#include<array>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long Int;\ntypedef string::const_iterator Itr;\n\narray<int,3> flag;\n\nInt ctoi(const char &c)\n{\n\treturn c - '0';\n}\n\nInt expression(Itr &);\nInt term(Itr &);\nInt term2(Itr &);\nInt factor(Itr &);\nInt number(Itr &);\n\nInt expression(Itr &itr)\n{\n\tInt ret = term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+' && flag[0]==0)\n\t\t{\n\t\t\titr++;\n\t\t\tret += term(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= term(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 0)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= term(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term(Itr &itr)\n{\n\tInt ret = term2(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret += term2(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= term2(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 1)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= term2(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt term2(Itr &itr)\n{\n\tInt ret = factor(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+'&& flag[0] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret += factor(itr);\n\t\t}\n\t\telse if (*itr == '-'&& flag[1] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret -= factor(itr);\n\t\t}\n\t\telse if (*itr == '*'&& flag[2] == 2)\n\t\t{\n\t\t\titr++;\n\t\t\tret *= factor(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nInt factor(Itr &itr)\n{\n\tInt ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = number(itr);\n\t}\n\n\treturn ret;\n}\n\nInt number(Itr &itr)\n{\n\tInt ret = 0;\n\n\twhile (isdigit(*itr))\n\t{\n\t\tret *= 10;\n\t\tret += ctoi(*itr);\n\t\titr++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin, s);\n\ts.append(\"_\");\n\n\tInt max_ans = -LLONG_MIN;\n\n\tREP(i,3)REP(j,3)REP(k,3)\n\t{\n\t\tflag[0] = i;\n\t\tflag[1] = j;\n\t\tflag[2] = k;\n\t\tItr begin = s.begin();\n\t\tInt ans = expression(begin);\n\t\tif (max_ans < ans)\n\t\t{\n\t\t\tmax_ans = ans;\n\t\t}\n\t}\n\tcout << max_ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res=getNum(),t;\n  if(S[p]=='(') p++,res=calc(-1),p++;\n  while(ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  \n  ch[0]=ch[')']=-2;\n  ll res=calc(-1);\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,calc(-1));\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State&);\nint term(State&);\nint term2(State&);\nint number(State&);\nint factor(State&);\n\nchar op[3] = {'+', '-', '*'};\nint expression(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\tif(*begin == op[0]) {\n\t\t\tbegin++;\n\t\t\tif(op[0] == '+') ret += term(begin);\n\t\t\telse if(op[0] == '-') ret -= term(begin);\n\t\t\telse if(op[0] == '*') ret *= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = term2(begin);\n\twhile(1) {\n\t\tif(*begin == op[1]) {\n\t\t\tbegin++;\n\t\t\tif(op[1] == '+') ret += term2(begin);\n\t\t\telse if(op[1] == '-') ret -= term2(begin);\n\t\t\telse if(op[1] == '*') ret *= term2(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term2(State &begin) {\n\tint ret = factor(begin);\n\twhile(1) {\n\t\tif(*begin == op[2]) {\n\t\t\tbegin++;\n\t\t\tif(op[2] == '+') ret += factor(begin);\n\t\t\telse if(op[2] == '-') ret -= factor(begin);\n\t\t\telse if(op[2] == '*') ret *= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\tstring s;\n\tgetline(cin, s);\n\n\tsort(op, op+3);\n\tint ret = -LLINF;\n\tdo {\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tret = max(ret, ans);\n\t\t//REP(i, 3) cout << op[i] << \" \"; cout << endl;\n\t\t//cout << ret << \" \" << ans << endl;\n\t} while(next_permutation(op, op+3));\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint priority[128];\n\nlong long number(string::const_iterator &it) {\n\tlong long res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nlong long expr(string::const_iterator &it, int p = 3) {\n\tif(p == 0) {\n\t\tif(*it == '(') {\n\t\t\t++it;\n\t\t\tconst long long res = expr(it);\n\t\t\tassert(*it == ')');\n\t\t\t++it;\n\t\t\treturn res;\n\t\t}\n\t\telse {\n\t\t\treturn number(it);\n\t\t}\n\t}\n\telse {\n\t\tlong long res = expr(it, p - 1);\n\n\t\twhile(priority[*it] == p) {\n\t\t\tconst char c = *it;\n\t\t\t++it;\n\t\t\tconst long long right = expr(it, p - 1);\n\n\t\t\tswitch(c) {\n\t\t\tcase '+': res += right; break;\n\t\t\tcase '*': res *= right; break;\n\t\t\tcase '-': res -= right; break;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tstring expression;\n\tcin >> expression;\n\n\tlong long ans = LLONG_MIN;\n\tfor(int &i = priority['+'] = 1; i <= 3; ++i) {\n\t\tfor(int &j = priority['-'] = 1; j <= 3; ++j) {\n\t\t\tfor(int &k = priority['*'] = 1; k <= 3; ++k) {\n\t\t\t\tauto it = expression.cbegin();\n\t\t\t\tchmax(ans, expr(it));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nlong long int tonum(string str){\n  int s=0,e=0;\n  for(; e<(int)str.length(); e++){\n    if(str[e]=='(') s=e+1;\n    if(str[e]==')') break;\n  }\n  return stoll(str.substr(s,e-s));\n}\n\nlong long int binop(long long int a, long long int b, char op){\n  if(op=='+') return a+b;\n  if(op=='-') return a-b;\n  if(op=='*') return a*b;\n  return -1;\n}\n\nlong long int calc(string str, int i, int j, int k){\n  vector<long long int> nums;\n  int s=0;\n  int depth=0;\n  bool onlynum=true;\n  for(int d=0; d<(int)str.length(); d++){\n    if(str[d]=='+' || str[d]=='-' || str[d]=='*'){\n      onlynum=false;\n      if(depth==0){\n        if(str[s]=='('){\n          nums.push_back( calc(str.substr(s+1, d-s-2), i,j,k));\n        }else{\n          nums.push_back( calc(str.substr(s,d-s), i,j,k) );\n        }\n        nums.push_back( str[d] );\n        s = d+1;\n      }\n    }\n    if(str[d]=='(') depth++;\n    if(str[d]==')') depth--;\n  }\n\n  if(onlynum) return tonum(str);\n  if(str[s]=='('){\n    nums.push_back( calc(str.substr(s+1,(int)str.length()-s-2), i,j,k));\n  }else{\n    nums.push_back( calc(str.substr(s,(int)str.length()-s), i,j,k) );\n  }\n\n  map<char,int> oppr;\n  oppr['+']=i;\n  oppr['-']=j;\n  oppr['*']=k;\n  for(int i=0; i<3; i++){\n    int nowop=1;\n    while(nowop<(int)nums.size()){\n      if(oppr[nums[nowop]] == i){\n        nums[nowop-1] = binop(nums[nowop-1], nums[nowop+1], (char)nums[nowop]);\n        nums.erase(nums.begin()+nowop);\n        nums.erase(nums.begin()+nowop);\n      }else{\n        nowop+=2;\n      }\n    }\n  }\n\n  return nums[0];\n}\n\nint main(){\n  string str;\n  cin >> str;\n\n  long long int ans = -9223372036854775807;\n  for(int i=0; i<3; i++){\n    for(int j=0; j<3; j++){\n      for(int k=0; k<3; k++){\n        ans = max(ans, calc(str,i,j,k));\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops;\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    void solve() {\n        int ps[4][3] = {\n            {0, 0, 0},\n            {0, 0, 1},\n            {0, 1, 1},\n            {0, 1, 2}\n        };\n                  \n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = 0;\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                for (int c = 0; c < 3; c++) {\n                    for (int i = 0; i < 4; i++) {\n                        ops.clear(); ops.resize(3);\n                        ops[a].push_back(t[0]);\n                        ops[b].push_back(t[1]);\n                        ops[c].push_back(t[2]);\n                        int index = 0;\n                        ans = max(ans, parse(s, index, 0));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\tvector<char> ve;\n\tstring s;\n\tint aite[210];\nint yaru(int a,int b,char c){\n\tif(c=='+')return a+b;\n\tif(c=='*')return a*b;\n\tif(c=='-')return a-b;\n\telse exit(1);\n}\n\tint jun[4][3];\nint saiki(int l,int r,int q){\n\tif(aite[l]==r){\n\t\treturn saiki(l+1,r-1,q);\n\t}\n\tint lev=0;\n\tint a[3]={-inf,-inf,-inf};\n\tfor(int i=l;i<=r;i++){\n\t\tif(s[i]=='(')lev++;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(s[i]==ve[j]&& lev==0)a[jun[q][j]]=max(a[jun[q][j]],i);\n\t\t}\n\t//\tif(s[i]==ve[0] && lev==0)a[0]=max(a[0],i);\n\t//\tif(s[i]==ve[1] && lev==0)a[1]=max(a[1],i);\n\t//\tif(s[i]==ve[2] && lev==0)a[2]=max(a[2],i);\n\t\tif(s[i]==')')lev--;\n\t}\n\t\tint z=max({a[0],a[1],a[2]});\n\tif(z==-inf){\n\t\treturn stoi(s.substr(l,r-l+1));\n\t}\n\tfor(int i=0;i<3;i++)if(a[i]>-inf){\n\t\tint l1=saiki(l,a[i]-1,q);\n\t\tint l2=saiki(a[i]+1,r,q);\n\t\treturn yaru(l1,l2,s[a[i]]);\n\t}\n\tcout<<\"out\"<<endl;\n\texit(1);\n}\n\t\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\tjun[0][0]=0;\n \tjun[0][1]=0;\n \tjun[0][2]=0;\n \t\n\tjun[1][0]=1;\n \tjun[1][1]=1;\n \tjun[1][2]=0;\n \t\n \tjun[2][0]=1;\n \tjun[2][1]=0;\n \tjun[2][2]=0;\n \t\n \tjun[3][0]=2;\n \tjun[3][1]=1;\n \tjun[3][2]=0;\n \tcin>>s;\n \n \tve.pb('*');\n \tve.pb('-');\n \tve.pb('+');\n \tsort(ve.begin(),ve.end());\n \tvector<int> ans;\n \tint l=s.length();\n \tstack<int> st;\n \tfor(int i=0;i<l;i++)aite[i]=-1;\n \tfor(int i=0;i<l;i++){\n \t\tif(s[i]=='('){\n \t\t\tst.push(i);\n \t\t}\n \t\tif(s[i]==')'){\n \t\t\tint z=st.top();\n \t\t\tst.pop();\n \t\t\taite[z]=i;\n \t\t\taite[i]=z;\n \t\t}\n \t}\n \tdo{\n \t\tfor(int j=0;j<4;j++){\n \t\tint y=saiki(0,l-1,j);\n \t//\tcout<<ve[0]<<\" \"<<ve[1]<<\" \"<<ve[2]<<\"   \"<<y<<endl;\n \t\tans.pb(y);\n \t\t}\n \t\t\n \t}while(next_permutation(ve.begin(),ve.end()));\n \tsort(ans.begin(),ans.end());\n \tcout<<ans.back()<<endl;\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\nint c[4];\n\nll expression(State &begin);\nll number(State &begin);\nll factor(State &begin);\nll term1(State &begin);\nll term2(State &begin);\n\n\nll number(State &begin){\n\tll ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nll term2(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]==2){\n\t\t\tbegin++;\n\t\t\tret+=number(begin);\n\t\t}else if(*begin=='-' && c[1]==2){\n\t\t\tbegin++;\n\t\t\tret-=number(begin);\n\t\t}else if(*begin=='*' && c[2]==2){\n\t\t\tbegin++;\n\t\t\tret*=number(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll term1(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+' && c[0]>=1){\n\t\t\tbegin++;\n\t\t\tret+=term2(begin);\n\t\t}else if(*begin=='-' && c[1]>=1){\n\t\t\tbegin++;\n\t\t\tret-=term2(begin);\n\t\t}else if(*begin=='*' && c[2]>=1){\n\t\t\tbegin++;\n\t\t\tret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nll factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tll ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else return number(begin);\n}\n\nll expression(State &begin){\n\tll ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tif(c[0]==0)ret+=term1(begin);\n\t\t\tif(c[0]>=1)ret+=term2(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(c[1]==0)ret-=term1(begin);\n\t\t\tif(c[1]>=1)ret-=term2(begin);\n\t\t}else if(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tif(c[2]==0)ret*=term1(begin);\n\t\t\tif(c[2]>=1)ret*=term2(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tll res=0;\n\tfor(int i=0;i<3;i++){\n\t\tc[0]=i;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tc[1]=j;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tc[2]=k;\n\t\t\t\tState begin=str.begin();\n\t\t\t\tll re=expression(begin);\n\t\t\t\tif(i+j+k==0)res=re;\n\t\t\t\telse res=max(res,re);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Calc {\n    string str;\n    vector<char> p;\n    string::iterator it;\n \n  public:\n    Calc(const string &str, vector<char> p){\n\tthis->str = str;        \n\tthis->p   = p;\n        it        = this->str.begin();    \n    }\n\n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n    \n    ll f0()\n    {\n        ll res = 0;\n\tif (*it == '(') {\n\t    ++it;\n\t    res = f3();\n\t    ++it;\n\t} else {\n\t    while (isdigit(*it)) {\n\t\tres *= 10LL;\n\t\tres += (ll)(*it - '0');\n\t\t++it;\n\t    }\n\t}\n        return res;\n    }\n \n    ll f1()\n    {\n\tll res = f0();\n\twhile (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n\t}\n\treturn res;\n    }\n\n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1]) {\n            ++it;\n            res = get_val(res, p[1], f1());\n        }\n        return res;\n    }\n        \n    ll f3()\n    {\n\tll res = f2();\n\twhile (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f2());\n\t}\n\treturn res;\n    }\n};\n\nclass Calc2 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc2(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n  \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0]) {\n            ++it;            \n            res = get_val(res, p[0], f0());\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[1] || *it == p[2]) {\n            if (*it == p[1]) {\n                ++it;\n                res = get_val(res, p[1], f1());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[2], f1());                \n            }\n        }\n        return res;\n    }\n};\n\nclass Calc22 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n  \n  public:\n    Calc22(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n     \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f2();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n    \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            }\n        }\n        return res;\n    }\n \n    ll f2()\n    {\n        ll res = f1();\n        while (*it == p[2]) {\n            ++it;\n            res = get_val(res, p[2], f1());                \n        }\n        return res;\n    }\n};\n\nclass Calc3 {\n    string str;\n    vector<char> p;\n    string::iterator it;\n   \n  public:\n    Calc3(const string &str, vector<char> p){\n        this->str = str;        \n        this->p   = p;\n        it        = this->str.begin();    \n    }\n  \n    ll get_val(ll a, char op, ll b)\n    {\n        switch (op) {\n            case '*':\n                return a * b;\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;                \n        }\n        assert(0);\n    }\n      \n    ll f0()\n    {\n        ll res = 0;\n        if (*it == '(') {\n            ++it;\n            res = f1();\n            ++it;\n        } else {\n            while (isdigit(*it)) {\n                res *= 10LL;\n                res += (ll)(*it - '0');\n                ++it;\n            }\n        }\n        return res;\n    }\n   \n    ll f1()\n    {\n        ll res = f0();\n        while (*it == p[0] || *it == p[1] || *it == p[2]) {\n            if (*it == p[0]) {\n                ++it;\n                res = get_val(res, p[0], f0());                \n            } else if (*it == p[1]) {                               \n                ++it;\n                res = get_val(res, p[1], f0());                \n            } else {\n                ++it;\n                res = get_val(res, p[2], f0());                \n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    string str;\n    cin >> str;\n    \n    vector<char> p = {'*', '+', '-'};\n\n    ll res = 0;    \n    do {\n        Calc  c(str, p);\n        Calc2 c2(str, p);\n        Calc22 c22(str, p);\n        Calc3 c3(str, p);\n        res = max(res, max(max(c.f3(), c2.f2()), max(c22.f2(), c3.f1())));\n    } while (next_permutation(p.begin(), p.end()));\n    cout << res << endl;    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFFFFFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1&&a[1]==2&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1&&a[1]==3&&a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2&&a[1]==1&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2&&a[1]==3&&a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3&&a[1]==1&&a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3&&a[1]==2&&a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  cout << \"warning \" << t << endl;\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Type{\n\tPlus,\n\tMinus,\n\tMult,\n};\n\nint loc[128];\n\nll calc_two_same(char line[202],int rank[3],int maximum){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\tnegFLG = false;\n\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(negFLG){\n\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\tnegFLG = false;\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('&& rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '(')){\n\t\t\t\t\tnegFLG = true;\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nll calc_three_same(char line[202]){\n\n\tll tmp,op1,work,count,work2;\n\tchar calc;\n\tstack<ll> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t}\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nll calc_all_different(char line[202],int rank[3],int maximum){\n\n\tint work_line_length,work_rank[3];\n\tll tmp,op1,work,count,work2,work_tmp;\n\tchar calc,work_line[202];\n\tstack<ll> NUM,work_num;\n\tstack<ll> to_make_work;\n\tqueue<ll> work_num2;\n\tstack<char> OP,work_op;\n\tqueue<char> work_op2;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{ //??°?????§????????´???\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '(' && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\tNUM.push(op1+tmp);\n\t\t\t\t\t}else{ //calc == '-'\n\t\t\t\t\t\tNUM.push(op1-tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*'){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k == 0 || line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\tif(k == 0){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('-');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif(OP.empty() == false && rank[loc[OP.top()]] == maximum){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork += work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = work2-work;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork_line_length = 0;\n\n\t\t\t\t\twhile(!work_num.empty()){\n\n\t\t\t\t\t\twork_tmp = work_num.top();\n\t\t\t\t\t\tif(work_tmp < 0){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '-';\n\t\t\t\t\t\t\twork_tmp *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint S = 10;\n\t\t\t\t\t\tfor(int a = 0; ;a++){\n\t\t\t\t\t\t\tto_make_work.push(work_tmp%S);\n\t\t\t\t\t\t\tif(S > work_tmp)break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\twork_tmp /= S;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile(!to_make_work.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = '0' + to_make_work.top();\n\t\t\t\t\t\t\tto_make_work.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\tif(!work_op.empty()){\n\t\t\t\t\t\t\twork_line[work_line_length++] = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twork_line[work_line_length] = '=';\n\t\t\t\t\twork_line[work_line_length+1] = '\\0';\n\n\t\t\t\t\tif(rank[0] == 2){\n\t\t\t\t\t\twork_rank[0] = 0;\n\t\t\t\t\t\twork_rank[1] = rank[1];\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else if(rank[1] == 2){\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = 0;\n\t\t\t\t\t\twork_rank[2] = rank[2];\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}else{ //rank[2] == 2\n\t\t\t\t\t\twork_rank[0] = rank[0];\n\t\t\t\t\t\twork_rank[1] = rank[2];\n\t\t\t\t\t\twork_rank[2] = 0;\n\n\t\t\t\t\t\twork = calc_two_same(work_line,work_rank,1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint maximum;\n\tloc['+'] = 0;\n\tloc['-'] = 1;\n\tloc['*'] = 2;\n\n\tchar line[202];\n\tint length;\n\n\tscanf(\"%s\",line);\n\tfor(length = 0; line[length] != '\\0';length++);\n\n\tline[length] = '=';\n\tline[length+1] = '\\0';\n\n\tint rank[3],num[3];\n\tll ans = -9223372036854775808,tmp_ans;\n\n\tfor(int a = 0; a <= 2; a++){\n\t\tfor(int b = 0; b <= 2; b++){\n\t\t\tfor(int c = 0; c <= 2; c++){\n\n\t\t\t\tfor(int i = 0; i < 3; i++)num[i] = 0;\n\n\t\t\t\trank[Plus] = a;\n\t\t\t\trank[Minus] = b;\n\t\t\t\trank[Mult] = c;\n\n\t\t\t\tmaximum = -1;\n\t\t\t\tmaximum = max(a,max(b,c));\n\n\t\t\t\tnum[a]++;\n\t\t\t\tnum[b]++;\n\t\t\t\tnum[c]++;\n\n\t\t\t\tif(a != b && a != c && b != c){\n\t\t\t\t\ttmp_ans = calc_all_different(line,rank,maximum);\n\t\t\t\t}else if(num[0] == 3 || num[1] == 3 || num[2] == 3){\n\t\t\t\t\ttmp_ans = calc_three_same(line);\n\t\t\t\t}else{\n\t\t\t\t\ttmp_ans = calc_two_same(line,rank,maximum);\n\t\t\t\t}\n\t\t\t\tans = max(ans,tmp_ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst vi add = {1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 3, 3};\nconst vi sub = {1, 1, 2, 1, 2, 1, 2, 2, 3, 1, 3, 1, 2};\nconst vi mul = {1, 1, 1, 2, 1, 2, 2, 3, 2, 3, 1, 2, 1};\n\nstring formula;\n\nll parse(int b, int e, int ord){\n    vector<ll> v;\n    vector<char> op;\n\n    range(i, b, e){\n        if(formula.at(i) == '('){\n            int next_b = i + 1, cnt = 1;\n            while(cnt){\n                if(formula[++i] == '(') cnt++;\n                else if(formula[i] == ')') cnt--;\n            }\n            v.pb(parse(next_b, i, ord));\n        }\n        else if(isdigit(formula.at(i))){\n            ll value = 0;\n            while(i < formula.size() && isdigit(formula.at(i))){\n                value = 10 * value + formula.at(i++) - '0';\n            }\n            v.pb(value);\n\n            i--;\n        }\n        else{\n            op.pb(formula.at(i));\n        }\n    }\n  \n    if(v.size() == 0) return 0;\n\n    range(i, 1, 4){\n        rep(j, op.size()){\n            bool operated = false;\n\n            if(op[j] == '+' && add[ord] == i){\n                v[j] = v[j] + v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '-' && sub[ord] == i){\n                v[j] = v[j] - v[j + 1];\n                operated = true;\n            }\n            else if(op[j] == '*' && mul[ord] == i){\n                v[j] = v[j] * v[j + 1];\n                operated = true;\n            }\n\n            if(operated){\n                v.erase(v.begin() + j + 1);\n                op.erase(op.begin() + j);\n                j--;\n            }\n        }\n    }\n\n    return v[0];\n}\n\nint main(void){\n    for(; cin >> formula;){\n        ll res = -INF;\n\n        rep(i, add.size()){\n            res = max(res, parse(0, formula.size(), i));\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nusing ll = long long;\n\n\n// <expr> := <term> | <expr> <op1> <term>\n// <term> := <term2> | <term> <op2> <term2>\n// <term2> := <fact> | <term2> <op3> <fact>\n// <fact> := (<expr>) | <number>\n\nll number(string const& s, int& p);\nll expr(string const& s, int& p, vector<vector<char>> const& op);\nll term(string const& s, int& p, vector<vector<char>> const& op);\nll term2(string const& s, int& p, vector<vector<char>> const& op);\nll fact(string const& s, int& p, vector<vector<char>> const& op);\n\nll number(string const& s, int& p) {\n    ll res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nll expr(string const& s, int& p, vector<vector<char>> const& op) {\n    ll v1 = term(s, p, op);\n    while(find(op[0].begin(), op[0].end(), s[p]) != op[0].end()) {\n        char o = s[p++];\n        ll v2 = term(s, p, op);\n        if(o == '+') {\n            v1 += v2;\n        } else if(o == '-') {\n            v1 -= v2;\n        } else {\n            v1 *= v2;\n        }\n    }\n    return v1;\n}\n\nll term(string const& s, int& p, vector<vector<char>> const& op) {\n    ll v1 = term2(s, p, op);\n    while(find(op[1].begin(), op[1].end(), s[p]) != op[1].end()) {\n        char o = s[p++];\n        ll v2 = term2(s, p, op);\n        if(o == '+') {\n            v1 += v2;\n        } else if(o == '-') {\n            v1 -= v2;\n        } else {\n            v1 *= v2;\n        }\n    }\n    return v1;\n}\n\nll term2(string const& s, int& p, vector<vector<char>> const& op) {\n    ll v1 = fact(s, p, op);\n    while(find(op[2].begin(), op[2].end(), s[p]) != op[2].end()) {\n        char o = s[p++];\n        ll v2 = fact(s, p, op);\n        if(o == '+') {\n            v1 += v2;\n        } else if(o == '-') {\n            v1 -= v2;\n        } else {\n            v1 *= v2;\n        }\n    }\n    return v1;\n}\n\nll fact(string const& s, int& p, vector<vector<char>> const& op) {\n    if(isdigit(s[p])) {\n        return number(s, p);\n    }\n    ll res = expr(s, ++p, op);\n    ++p;\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    ll res = numeric_limits<ll>::min();\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            for(int k=0; k<3; ++k) {\n                int p = 0;\n                vector<vector<char>> op(3);\n                op[i].push_back('+');\n                op[j].push_back('-');\n                op[k].push_back('*');\n                res = max(res, expr(s, p, op));\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring S;\nint p,ch[1<<8];\n\nll getNum(){\n  ll res=0;\n  while(isdigit(S[p])) res=res*10+S[p++]-'0';\n  return res;\n}\n\nll get(ll &a,ll b,char c){\n  if(c=='+')a+=b;\n  if(c=='-')a-=b;\n  if(c=='*')a*=b;\n  return a;\n}\n\nll calc(int c){\n  ll res,t;\n  if(S[p]=='(') p++,res=calc(-1),p++;\n  else res=getNum();\n  while(ch[S[p]]>c)t=S[p++],get(res,calc(ch[t]),t);\n  return res;\n}\n\nint main(){\n  cin>>S; \n  ch[0]=ch[')'] = -1000;\n  ll res=calc(-1);\n  for(int i=0;i<3;i++)\n    for(int j=0;j<3;j++)\n      for(int k=0;k<3;k++) {\n\tch['+']=i,ch['-']=j,ch['*']=k;\n\tp=0;\n\tres=max(res,calc(-1));\n      }\n  \n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstring S;\nint N;\n\nLL C(int& i, VS& order);\nLL D(int& i, VS& order);\nLL E(int& i, VS& order);\nLL F(int& i, VS& order);\n\nLL C(int& i, VS& order){\n  LL res = D(i, order);\n  while(i < N && order[0].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = D(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL D(int& i, VS& order){\n  LL res = E(i, order);\n  while(i < N && order[1].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = E(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\nLL E(int& i, VS& order){\n  LL res = F(i, order);\n  while(i < N && order[2].find(S[i]) != string::npos){\n\tchar op = S[i];\n\t++i;\n\tLL res2 = F(i, order);\n\tswitch(op){\n\tcase '+':\n\t  res += res2;\n\t  break;\n\tcase '-':\n\t  res -= res2;\n\t  break;\n\tcase '*':\n\t  res *= res2;\n\t  break;\n\t}\n  }\n  return res;\n}\n\nLL F(int& i, VS& order){\n  LL res = 0;\n  if(S[i] == '('){\n\t++i;\n\tres = C(i, order);\n\t++i;\n  }\n  else{\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i]-'0');\n\t  ++i;\n\t}\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> S;\n  N = SZ(S);\n  LL ans = -1e18;\n\n  REP(i1,3){\n\tREP(i2,3){\n\t  REP(i3,3){\n\t\tint i = 0;\n\t\tVS ops(3);\n\t\tops[i1] += \"+\";\n\t\tops[i2] += \"-\";\n\t\tops[i3] += \"*\";\n\t\tmaxi(ans, C(i,ops));\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nstring s, pat = \"+-*\";\n\nll parse(int l, int r, vector<int> prio) {\n    int ptr = l;\n\n    vector<ll> val;\n    vector<char> op;\n    while(ptr < r) {\n        // 演算子\n        if(pat.find(s[ptr]) != string::npos) {\n            op.push_back(s[ptr++]);\n        }\n        // 数字\n        else if(isdigit(s[ptr])) {\n            ll tmp = 0;\n            while(isdigit(s[ptr])) {\n                tmp = (tmp * 10) + (s[ptr++] - '0');\n            }\n            val.push_back(tmp);\n        }\n        // 括弧\n        else if(s[ptr] == '(') {\n            int cnt = 0;\n            int nl = ptr+1, nr = -1;\n            while(1) {\n                if(s[ptr] == '(') cnt++;\n                else if(s[ptr] == ')') {\n                    cnt--;\n                    if(cnt == 0) break;\n                }\n                ptr++;\n            } \n            nr = ptr++;\n            val.push_back(parse(nl, nr, prio));\n        }\n    }\n\n    /*\n    for(int i=0; i<op.size(); i++) {\n        printf(\"%lld %c \", val[i], op[i]);\n    }\n    printf(\"%lld\\n\", val[op.size()]);\n    */\n\n    // マージ\n    for(int p=0; p<3; p++) {\n        for(size_t i=0; i<op.size(); i++) {\n            // printf(\"op %c (%d)\\n\", op[i], prio[pat.find(op[i])]);\n            if(prio[pat.find(op[i])] == p) {\n                // printf(\"op %c: %lld, %lld\\n\", op[i], val[i], val[i+1]);\n                if(op[i] == '+') val[i] = val[i] + val[i+1];\n                if(op[i] == '-') val[i] = val[i] - val[i+1];\n                if(op[i] == '*') val[i] = val[i] * val[i+1];\n                val.erase(val.begin() + i + 1);\n                op.erase(op.begin() + i);\n                i--;\n            }\n        }\n    }\n    return val[0];\n}\n\nint main() {\n    cin >> s;\n    int M = s.length();\n    ll ans = parse(0, M, vector<int>{0, 0, 0});\n\n    \n    for(int x=0; x<3; x++) {\n        for(int y=0; y<3; y++) {\n            for(int z=0; z<3; z++) {\n                vector<int> v = {x, y, z};\n                // printf(\"parse: %lld\\n\", parse(0, M, v));\n                ans = max(ans, parse(0, M, v));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define int long long\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint expression1(State &begin);\nint expression2(State &begin);\nint expression3(State &begin);\n\nvector<int> priority(3);\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin)-'0';\n    begin++;\n  }\n  // cout<<\"number: \"<<ret<<endl;\n  return ret;\n}\n\nint factor(State &begin){\n  // cout<<\"in factor: \"<<*begin<<endl;\n  int ret;\n  if(*begin=='('){\n    begin++;\n    ret=expression1(begin);\n    begin++;\n  }else{\n    // cout<<\"factor in number\" <<endl;\n    ret=number(begin);\n  }\n  return ret;\n}\n\nint expression3(State &begin){\n  // cout<<\"in expr3: \"<<endl;\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='+'&&priority[2]&(1<<0)){\n      begin++;\n      ret+=factor(begin);\n    }else if(*begin=='-'&&priority[2]&(1<<1)){\n      begin++;\n      ret-=factor(begin);\n    }else if(*begin=='*'&&priority[2]&(1<<2)){\n      begin++;\n      ret*=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression2(State &begin){\n  int ret=expression3(begin);\n  // cout<<\"in expr2: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[1]&(1<<0)){\n      begin++;\n      ret+=expression3(begin);\n    }else if(*begin=='-'&&priority[1]&(1<<1)){\n      begin++;\n      ret-=expression3(begin);\n    }else if(*begin=='*'&&priority[1]&(1<<2)){\n      begin++;\n      ret*=expression3(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression1(State &begin){\n  int ret=expression2(begin);\n  // cout<<\"in expr1: \"<<endl;\n  while(1){\n    if(*begin=='+'&&priority[0]&(1<<0)){\n      begin++;\n      ret+=expression2(begin);\n    }else if(*begin=='-'&&priority[0]&(1<<1)){\n      begin++;\n      ret-=expression2(begin);\n    }else if(*begin=='*'&&priority[0]&(1<<2)){\n      begin++;\n      ret*=expression2(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nsigned main(){\n  string s;\n  cin>>s;\n  int ans=0;\n  for(int i=0;i<(1<<3);i++){\n    for(int j=0;j<(1<<3);j++){\n      for(int k=0;k<(1<<3);k++){\n\tif((__builtin_popcount(i)+__builtin_popcount(j)+__builtin_popcount(k))!=3)continue;\n\tcout<<__builtin_popcount(i)+__builtin_popcount(j)+__builtin_popcount(k)<<endl;\n\tpriority[0]=i;priority[1]=j;priority[2]=k;\n\tState begin=s.begin();\n        cout<<__builtin_popcount(i)<<\" \"<<__builtin_popcount(j)<<\" \"<<__builtin_popcount(k)<<endl;;\n\tans=max(ans,expression1(begin));\n\tcout<<ans<<endl;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\ntypedef long long ll;\n\nstring s;\nint p;\nmap<char,int> t;\nll f(ll a,char ch,ll b){\n  if(ch=='+')return a+b;\n  else if(ch=='-')return a-b;\n  else return a*b;\n}\n\n\nll calc(int X);\n\nll getNum(){\n  if(s[p]=='('){\n    p++;\n    return calc(0);\n  }else{\n    ll res=0;\n    while('0'<=s[p]&&s[p]<='9'){\n      res=res*10+s[p]-'0';\n      p++;\n    }\n    return res;\n  }\n}\n\nll calc(int X){\n  if(X==3) return getNum();\n  ll res=calc(X+1);\n  while(1){\n    char ch=s[p++];\n    if(ch==')'||ch=='='||t[ch]<X){\n      if(X!=0)p--;\n      break;\n    }\n    res=f(res,ch,calc(X+1));\n  }\n  return res;\n}\n\nint main(){\n  cin>>s;\n  s.push_back('=');\n  ll ans=LONG_LONG_MIN;\n  \n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      for(int k=0;k<3;k++){\n        t['+']=i;\n        t['-']=j;\n        t['*']=k;\n        p=0;\n        ans=max(ans,calc(0));\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nint f,p;\nstring s;\nmap<char,int>m;\nint bns1();\nint g_A(){\n  int r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nint bns3(){\n  int res=g_A();\n  while(m[s[p]]==3){\n    int t=p++;\n    if(s[t]=='+')res+=g_A();\n    if(s[t]=='-')res-=g_A();\n    if(s[t]=='*')res*=g_A();\n  }\n  return res;\n}\nint bns2(){\n  int res=bns3();\n  while(m[s[p]]==2){\n    int t=p++;\n    if(s[t]=='+')res+=bns3();\n    if(s[t]=='-')res-=bns3();\n    if(s[t]=='*')res*=bns3();\n  }\n  return res;\n}\nint bns1(){\n  int res=bns2();\n  while(m[s[p]]==1){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n    if(s[t]=='*')res*=bns2();\n  }\n  return res;\n}\nint dfs(){\n  int res=LLONG_MIN;\n  r(i,3)r(j,3)r(k,3){\n    m['+']=i+1;\n    m['-']=j+1;\n    m['*']=k+1;\n    p=0;\n    res=max(res,bns1());\n  }\n  return res;\n}\nmain(){\n  cin>>s;\n  cout<<dfs()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n\nint main(void){\n\tstring str;cin>>str;str.pub('#');\n\t\n\tint rule[3];\n\tint i;\n\tllint ans=-9223372036854775807LL;\n\tfor(int bi=0;bi<27;bi++){\n\t\tlist<pair<char,llint>>shiki;\n\t\tshiki.pub(mp('#',0));\n\t\t//演算子or数字 数字そのもの\n\t\tvector<pair<int,decltype(shiki.begin())>>zyu;\n\t\trule[0]=bi/9;\n\t\trule[1]=bi%9/3;\n\t\trule[2]=bi%3;\n\t\tif(rule[0]!=2&&rule[1]!=2&&rule[2]!=2){continue;}\n\t\tif(rule[0]!=1&&rule[1]!=1&&rule[2]!=1&&bi!=26){continue;}\n\t\tint kakko=0;\n\t\tfor(i=0;str[i]!='#';i++){\n\t\t\t//cerr<<str[i]<<endl;\n\t\t\tif(str[i]=='('){kakko++;}\n\t\t\telse if(str[i]==')'){kakko--;}\n\t\t\telse if(str[i]=='+'){\n\t\t\t\tshiki.pub(mp('+',0));\n\t\t\t\tzyu.pub(mp(kakko*10000+rule[0]*1000-i,prev(shiki.end())));\n\t\t\t}\n\t\t\telse if(str[i]=='-'){\n\t\t\t\tshiki.pub(mp('-',0));\n\t\t\t\tzyu.pub(mp(kakko*10000+rule[1]*1000-i,prev(shiki.end())));\n\t\t\t}\n\t\t\telse if(str[i]=='*'){\n\t\t\t\tshiki.pub(mp('*',0));\n\t\t\t\tzyu.pub(mp(kakko*10000+rule[2]*1000-i,prev(shiki.end())));\n\t\t\t}else{\n\t\t\t\tllint num=0;\n\t\t\t\twhile('0'<=str[i]&&str[i]<='9'){num*=10;num+=str[i]-'0';i++;}\n\t\t\t\ti--;\n\t\t\t\tshiki.pub(mp('n',num));\n\t\t\t}\n\t\t}\n\t\tshiki.pub(mp('#',0));\n\t\tsort(zyu.begin(),zyu.end(),\n\t\t\t[](pair<int,decltype(shiki.begin())> x,pair<int,decltype(shiki.begin())>y)->int{\n\t\t\t\treturn (x.fir<y.fir);\n\t\t\t}\n\t\t);REV(zyu);\n\t\t//cerr<<\"de\"<<__LINE__<<endl;\n\t\tfor(auto it:zyu){\n\t\t\t\n\t\t\tauto ptr=it.sec;\n\t\t\tllint x,y,z;\n\t\t\tx=prev(ptr)->sec;\n\t\t\ty=next(ptr)->sec;\n\t\t\t\n\t\t\t//cerr<<x<<\" \"<<(ptr->fir)<<\" \"<<y<<endl;\n\t\t\tif(ptr->fir=='+'){z=x+y;}\n\t\t\tif(ptr->fir=='-'){z=x-y;}\n\t\t\tif(ptr->fir=='*'){z=x*y;}\n\t\t\tauto qtr=next(next(ptr));\n\t\t\tshiki.erase(prev(ptr));\n\t\t\tshiki.erase(next(ptr));\n\t\t\tshiki.erase(ptr);\n\t\t\tshiki.insert(qtr,mp('n',z));\n\t\t}\n\t\tmaxeq(ans,next(shiki.begin())->sec);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//'+','_','*'\nint a[3];\nbool mark(char t) {\n\tif (t == '+' || t == '_' || t == '*')return true;\n\telse return false;\n}\nstring trans(string x) {\n\tint l = x.length();\n\trep(j, 3) {\n\t\trep(i, l) {\n\t\t\tif (x[i] == '+'&&a[0] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) + stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t\telse if (x[i] == '_'&&a[1] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) - stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\n\t\t\t}\n\t\t\telse if (x[i] == '*'&&a[2] == j) {\n\t\t\t\tint le = i-1; int ri = i+1;\n\t\t\t\twhile (le >= 0 && (!mark(x[le])))le--; le++;\n\t\t\t\twhile (ri < l && (!mark(x[ri])))ri++; ri--;\n\t\t\t\tint d = ri - le + 1;\n\t\t\t\tstring u1 = x.substr(le, i - le);\n\t\t\t\tstring u2 = x.substr(i + 1, ri - i);\n\t\t\t\tstring u = to_string(stoll(u1) * stoll(u2));\n\t\t\t\tint d2 = u.length();\n\t\t\t\tx.erase(x.begin() + le, x.begin() + ri + 1);\n\t\t\t\tx.insert(le, u);\n\t\t\t\ti = le - 1; l = l - d + d2;\n\t\t\t}\n\t\t}\n\t}\n\treturn x;\n}\nll ord(string x) {\n\tint l = x.length();\n\trep(i, l) {\n\t\tif (x[i] == ')') {\n\t\t\tint le = i-1;\n\t\t\twhile (x[le] != '(')le--;\n\t\t\tstring u = x.substr(le + 1, i - le - 1);\n\t\t\tint d = i - le + 1;\n\t\t\tstring nu = trans(u);\n\t\t\tint d2 = nu.length();\n\t\t\tx.erase(x.begin() + le, x.begin() + i + 1);\n\t\t\tx.insert(le, nu);\n\t\t\ti = le - 1;\n\t\t\tl = l - d + d2;\n\t\t}\n\t}\n\tll res = stoll(trans(x));\n\treturn res;\n}\nint main() {\n\tstring s; cin >> s;\n\tint len = s.length();\n\trep(i, len) {\n\t\tif (s[i] == '-')s[i] = '_';\n\t}\n\tll ma = -INF;\n\trep(x, 3) {\n\t\trep(y, 3) {\n\t\t\trep(z, 3) {\n\t\t\t\ta[0] = x; a[1] = y; a[2] = z;\n\t\t\t\tma = max(ma, ord(s));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef vector<long long int> VI;\ntypedef vector<vector<long long int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<long long int, long long int> PII;\ntypedef pair<char, PII> PCI;\ntypedef pair<long long int, PII> PIII;\n\nconst long long int pri[13][3] = {{1, 1, 1},{1, 1, 2},{1, 2, 1},{2, 1, 1},{1, 2, 3},{1, 3, 2},{2, 1, 3},{2, 3, 1},{3, 1, 2},{3, 2, 1}, {2, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n\n// stringテ・ツ楪凝」ツつ値ong long intテ・ツ楪凝」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nlong long int string_to_lli(string str) {\n    long long int length = str.length();\n    long long int number = 0;\n    for (long long int i = 0; i < length; i++) {\n        number += (long long int)(str[i] - '0');\n        number *= 10;\n    }\n    number /= 10;\n    return number;\n}\n\nlong long int check(char c) {\n    if (c >= '0' && c <= '9') {\n        return 0;\n    } else if (c == '+' || c == '-' || c == '*') {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nlong long int rep_pri(char c, long long int i) {\n    if (c == '+') {\n        return pri[i][0];\n    } else if (c == '-') {\n        return pri[i][1];\n    } else if (c == '*') {\n        return pri[i][2];\n    } else {\n        std::cerr << \"ERROR_REP_PRI\" << endl;\n        return -1;\n    }\n}\n\nlong long int calc(long long int first, long long int second, char ope) {\n    if (ope == '+') {\n        return first + second;\n    } else if (ope == '-') {\n        return first - second;\n    } else if (ope == '*') {\n        return first * second;\n    } else {\n        std::cerr << \"ERROR_CALC\" << endl;\n        return -1;\n    }\n}\n\nlong long int act(string str, long long int i) {\n    long long int ans;\n    long long int len = (long long int)str.length();\n    stack<long long int> num;\n    stack<char> ope;\n    for (long long int j = 0; j < len; j++) {\n        //cout << \"J = \" << j << endl;\n        //cout << \"STR[j] = \" << str[j] << endl;\n        if (check(str[j]) == 0) {\n            long long int start = j;\n            long long int end = j;\n            while (check(str[end]) == 0) {\n                end++;\n            }\n            string sub = str.substr(start, end - start);\n            num.push(string_to_lli(sub));\n            j = end - 1;\n            continue;\n        } else if (check(str[j]) == 1) {\n            if (ope.empty()) {\n                ope.push(str[j]);\n                continue;\n            } else {\n                char now = str[j];\n                while ((!ope.empty()) && (rep_pri(ope.top(), i) >= rep_pri(now, i))) {\n                    long long int second = num.top();\n                    num.pop();\n                    long long int first = num.top();\n                    num.pop();\n                    char old = ope.top();\n                    ope.pop();\n\n                    //cout << old << \" \" << rep_pri(old, i) << endl;\n                    //cout << now << \" \" << rep_pri(now, i) << endl;\n\n                    num.push(calc(first, second, old));\n                    //cout << first << \" \" << old << \" \" << second << \" \" << calc(first, second, old) << endl;\n                    //cout << now << endl;\n                }\n                ope.push(now);\n                continue;\n            }\n        } else if (str[j] == '(') {\n            long long int start = j;\n            while (str[j] != ')') {\n                j++;\n            }\n            long long int end = j;\n            string sub = str.substr(start + 1, end - start - 1);\n            //cout << sub << endl;\n            //cout << \"REC_IN\" << endl;\n            num.push(act(sub, i));\n            //cout << \"REC_OUT\" << endl;\n        } else {\n            std::cerr << \"ERROR_ACT\" << endl;\n        }\n    }\n\n    while (!ope.empty()) {\n        long long int second = num.top();\n        num.pop();\n        long long int first = num.top();\n        num.pop();\n        char ope_now = ope.top();\n        //cout << first << \" \" << ope_now << \" \" << second << endl;\n        ope.pop();\n        num.push(calc(first, second, ope_now));\n    }\n    ans = num.top();\n    return ans;\n}\n\nint main(void) {\n    string str;\n    cin >> str;\n    long long int max_res = -1e09;\n\n    for (long long int i = 0; i < 13; i++) {\n        //ansテ」ツ?ィmax_resテ」ツつ津ヲツッツ氾ィツシツε」ツ?凖」ツつ?\n        long long int ans = act(str, i);\n        //cout << \"I = \" << i << endl;\n        //cout << \"ANS = \" << ans << endl;\n        if (ans > max_res) {\n            max_res = ans;\n        }\n    }\n    cout << max_res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nstring S, T = \"+-*\";\nint s[3], idx;\n\nint64 latte();\n\n\nint64 calc(int64 a, char b, int64 c)\n{\n  if(b == '+') return (a + c);\n  if(b == '-') return (a - c);\n  return (a * c);\n}\n\nint64 ei()\n{\n  if(S[idx] == '(') {\n    ++idx;\n    int64 ret = latte();\n    ++idx;\n    return (ret);\n  } else {\n    int64 ret = 0;\n    while(idx < S.size() && isdigit(S[idx])) {\n      ret = ret * 10 + S[idx++] - '0';\n    }\n\n    return (ret);\n  }\n}\n\nint64 beet()\n{\n  int64 ret = ei();\n  while(idx < S.size() && s[T.find(S[idx])] == 2) {\n    ret = calc(ret, S[idx++], ei());\n  }\n  return (ret);\n}\n\nint64 malta()\n{\n  int64 ret = beet();\n  while(idx < S.size() && s[T.find(S[idx])] == 1) {\n    ret = calc(ret, S[idx++], beet());\n  }\n  return (ret);\n}\n\nint64 latte()\n{\n  int64 ret = malta();\n  while(idx < S.size() && s[T.find(S[idx])] == 0) {\n    ret = calc(ret, S[idx++], malta());\n  }\n  return (ret);\n}\n\nint main()\n{\n\n  cin >> S;\n  int64 ret = numeric_limits< int64 >::min();\n  for(s[0] = 0; s[0] < 3; s[0]++) {\n    for(s[1] = 0; s[1] < 3; s[1]++) {\n      for(s[2] = 0; s[2] < 3; s[2]++) {\n        idx = 0;\n        ret = max(ret, latte());\n      }\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\nnamespace solver{void solve();} int main() { solver::solve(); return 0; }\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\n\nnamespace solver {\nstring s;\nchar ops[3] = {'+','-','*'};\nint priority[3];\nint turn;\ntypedef string::const_iterator Iter;\nIter it;\n\nvoid consume(char e) {\n  assert(*it == e);\n  it ++;\n}\n\nbool isconsume(char e) {\n  if(*it == e) {\n    consume(e);\n    return true;\n  }\n  return false;\n}\n\nll number() {\n  assert(isdigit(*it));\n  Iter end = s.end();\n  stringstream ss(string(it, end));\n  ll x; ss >> x;\n  int size = to_string(x).size();\n  while(size --) it++;\n  return x;\n}\n\n// 1. solve operator priority\nll expr(int p) {\n  if(p == 3) {\n    if(isconsume('(')) {\n      ll r = expr(0);\n      consume(')');\n      return r;\n    }\n    return number();\n  }\n\n  ll r = expr(p + 1);\n\n  // 2. solve operator associativity\n  auto condition = [&]() { return find(ops, ops+3, *it)-ops < 3 && priority[find(ops, ops+3, *it)-ops] == p; };\n\n  while(condition())\n    if(isconsume('+')) r += expr(p + 1);\n    else if(isconsume('-')) r -= expr(p + 1);\n    else if(isconsume('*')) r *= expr(p + 1);\n    \n  return r;\n}\n\nll calc() {\n  it = s.begin();\n  ll r = expr(0);\n  assert(it == s.end());\n  return r;\n}\n\nbool set_piority() {\n  int a = 0;\n  rep(i, 3) rep(j, 3) rep(k, 3) {\n    if(a++ == turn) {\n      turn ++;\n      priority[0] = i;\n      priority[1] = j;\n      priority[2] = k;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n\n  cin >> s;\n  ll ans = std::numeric_limits<ll>::min();\n  while(set_piority())\n    ans = max(ans, calc());\n  cout << ans << endl;\n}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nvoid cal(int &a, char op, int b) {\n\tif (op == '+')a += b;\n\telse if (op == '-')a -= b;\n\telse if (op == '*')a *= b;\n\telse assert(1 == 0);\n}\n\nclass Parser1 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser1(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2<op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{op2,c};\n\tc=d,{op3,d};\n\td='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret = d();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, d());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint d() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser2 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser2(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2<op3\n\tEBNF\n\ta=b,{(op1|op2),b};\n\tb=c,{op3,c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser3 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser3(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1<op2==op3\n\tEBNF\n\ta=b,{op1,b};\n\tb=c,{(op2|op3),c};\n\tc='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, c());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, c());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass Parser4 {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tchar op1, op2, op3;\n\tParser4(Iter it, char op1, char op2, char op3) :it(it), op1(op1), op2(op2), op3(op3) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\top1==op2==op3\n\tEBNF\n\ta=b,{(op1|op2|op3),b};\n\tb='(',a,')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == op1) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op1, b());\n\t\t\t}\n\t\t\telse if (*it == op3) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op3, b());\n\t\t\t}\n\t\t\telse if (*it == op2) {\n\t\t\t\tit++;\n\t\t\t\tcal(ret, op2, b());\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nsigned main() {\n\tstring s; getline(cin, s);\n\ts += \"$\";\n\tint ans;\n\tvector<char> op = { '+','-','*' };\n\tsort(all(op));\n\tbool first = true;\n\tdo {\n\t\tParser1 P1(s.begin(), op[0], op[1], op[2]);\n\t\tParser2 P2(s.begin(), op[0], op[1], op[2]);\n\t\tParser3 P3(s.begin(), op[0], op[1], op[2]);\n\t\tParser4 P4(s.begin(), op[0], op[1], op[2]);\n\t\tif (first) {\n\t\t\tfirst = false; ans = max({ P1.a(),P2.a(),P3.a(),P4.a() });\n\t\t}\n\t\telse ans = max({ ans,P1.a(),P2.a(),P3.a(),P4.a() });\n\t} while (next_permutation(op.begin(), op.end()));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nstruct www_t{\n  long long re;\n  int j;\n};\n\nll judge(www_t res);\nll exprALl();\nll expr1();\nll expr2();\nll expr3();\nll term1();\nll term2();\nll term3();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nvector<vector<int> > order={{1,1,1},{1,1,2},{1,2,2},{1,2,1},{1,2,3},{1,3,2},{2,1,1},{2,2,1},{2,1,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}};\nvector<int> a;\n\nint main(){\n  cin >> s;\n  long long ans=0-INF;\n  for(int k=0;k<(int)order.size();k++){\n    a=order[k];\n    long long an;\n    t=0;\n    www_t z;\n    z.re=0;\n    z.j=0;\n    an=judge(z);\n    ans=max(ans,an);\n  }\n  cout << ans << endl;\n}\n\nll judge(www_t res){\n  if(a[0]==a[1]&&a[1]==a[2]){\n    if(res.j==0) return exprALl();\n    else if(res.j==1) return fac();\n  }\n  else if(a[0]==a[1]){\n    if(a[0]==1){\n      if(res.j==0) return term3();\n      else if(res.j==7) return expr1();\n      else if(res.j==2) return fac();\n    }\n    else if(a[2]==1){\n      if(res.j==0) return expr1();\n      else if(res.j==2) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  else if(a[1]==a[2]){\n    if(a[1]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return expr2();\n      else if(res.j==3) return fac();\n    }\n    else if(a[0]==1){\n      if(res.j==0) return expr2();\n      else if(res.j==3) return term1();\n      else if(res.j==5) return fac();\n    }\n  }\n  else if(a[2]==a[0]){\n    if(a[0]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return expr3();\n      else if(res.j==4) return fac();\n    }\n    else if(a[1]==1){\n      if(res.j==0) return expr3();\n      else if(res.j==4) return term2();\n      else if(res.j==6) return fac();\n    }\n  }\n  else{\n    if(a[0]==1&&a[1]==2&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==1&&a[1]==3&&a[2]==2){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return fac();\n    }\n    else if(a[0]==2&&a[1]==1&&a[2]==3){\n      if(res.j==0) return term3();\n      else if(res.j==7) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==2&&a[1]==3&&a[2]==1){\n      if(res.j==0) return term2();\n      else if(res.j==6) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return fac();\n    }\n    else if(a[0]==3&&a[1]==1&&a[2]==2){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term3();\n      else if(res.j==7) return term2();\n      else if(res.j==6) return fac();\n    }\n    else if(a[0]==3&&a[1]==2&&a[2]==1){\n      if(res.j==0) return term1();\n      else if(res.j==5) return term2();\n      else if(res.j==6) return term3();\n      else if(res.j==7) return fac();\n    }\n  }\n  cout << \"warning \" << t << endl;\n  return 0;\n}\n\nll exprALl(){\n  www_t res;\n  res.j=1;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-'||peek()=='*')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr1(){\n  www_t res;\n  res.j=2;\n  res.re=judge(res);\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr2(){\n  www_t res;\n  res.j=3;\n  res.re=judge(res);\n  while(left()&&(peek()=='-'||peek()=='*')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n    else if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll expr3(){\n  www_t res;\n  res.j=4;\n  res.re=judge(res);\n  while(left()&&(peek()=='*'||peek()=='+')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n    else if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term1(){\n  www_t res;\n  res.j=5;\n  res.re=judge(res);\n  while(left()&&(peek()=='+')){\n    if(peek()=='+'){\n      eat('+');\n      res.re+=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term2(){\n  www_t res;\n  res.j=6;\n  res.re=judge(res);\n  while(left()&&(peek()=='-')){\n    if(peek()=='-'){\n      eat('-');\n      res.re-=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll term3(){\n  www_t res;\n  res.j=7;\n  res.re=judge(res);\n  while(left()&&(peek()=='*')){\n    if(peek()=='*'){\n      eat('*');\n      res.re*=judge(res);\n    }\n  }\n  return res.re;\n}\n\nll fac(){\n  www_t res;\n  res.j=0;\n  if(peek()=='('){\n    eat('(');\n    res.re=judge(res);\n    eat(')');\n    return res.re;\n  }\n  else{\n    res.re=num();\n    return res.re;\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \",\" << vs[i];\n        return os << \"]\";\n    }\n\n    string s;\n    void input() {\n        cin >> s;\n    }\n\n    vector<string> ops;\n    Long number(const string& s, int& index) {\n        Long r = 0;\n        while (index < s.size() && isdigit(s[index])) {\n            r = r * 10 + (s[index] - '0');\n            index++;\n        }\n        return r;\n    }\n\n    bool check(char op, int level) {\n        for (int i = 0; i < ops[level].size(); i++) {\n            if (op == ops[level][i]) return true;\n        }\n        return false;\n    }\n\n    Long calc(char op, Long a, Long b) {\n        if (op == '+') return a + b;\n        if (op == '-') return a - b;\n        if (op == '*') return a * b;\n        assert(0);\n    }\n\n    Long parse(const string& s, int& index, int level) {\n        if (level == 3) {\n            if (s[index] == '(') {\n                index++;\n                Long r = parse(s, index, 0);\n                assert(s[index] == ')');\n                index++;\n                return r;\n            }\n            return number(s, index);\n        }\n        Long r = parse(s, index, level + 1);\n        while (index < s.size() && check(s[index], level)) {\n            char op = s[index];\n            index++;\n            Long a = parse(s, index, level + 1);\n            r = calc(op, r, a);\n        }\n        return r;\n    }\n\n    void solve() {\n        int ps[4][3] = {\n            {0, 0, 0},\n            {0, 0, 1},\n            {0, 1, 1},\n            {0, 1, 2}\n        };\n                  \n        string t = \"+-*\";\n        sort(t.begin(), t.end());\n        Long ans = 0;\n        do {\n            for (int i = 0; i < 4; i++) {\n                ops.clear(); ops.resize(3);\n                for (int j = 0; j < 3; j++) {\n                    int l = ps[i][j];\n                    ops[l].push_back(t[j]);\n                }\n                int index = 0;\n                ans = max(ans, parse(s, index, 0));\n            }\n        } while (next_permutation(t.begin(), t.end()));\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2613: Unordered Operators\n// 2017.10.10 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\n#define MAX 210\n\n#define VAL   10\n#define LEFT  -1\n#define RIGHT -2\n#define PLUS   0 \n#define MINUS  1\n#define MUL    2\n\ntypedef struct { long long v; char id; } T;\nT stack[MAX+3], buf[MAX+3]; int top, end;\n\nchar str[MAX], *p;\n\nint tbl[13][3] = {\n\t{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1},\n\t{1,1,1},{1,1,2},{2,2,1},{1,2,1},{2,1,2},{1,2,2},{2,1,1}}; int rid;\n\nlong long getInt(void)\n{\n\tlong long n = 0;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\treturn MUL;\n}\n\nint rank(int op)\n{\n\tif (op == LEFT) return LEFT;\n\treturn tbl[rid][op];\n}\n\nint main()\n{\n\tint i, id, f;\n\tlong long v1, v2, ans;\n\n\tscanf(\"%s\", str); f = 1;\n\tfor (rid = 0; rid < 13; rid++) {\n\t\tp = str, top = 0, end = 0;\n\t\twhile (*p) {\n\t\t\tif (isdigit(*p)) buf[end].id = VAL, buf[end++].v = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (top > 0 && stack[top-1].id != LEFT) buf[end++] = stack[--top];\n\t\t\t\tp++, top--;\n\t\t\t} else if (*p == '(') stack[top++].id = LEFT, p++;\n\t\t\telse {\n\t\t\t\tid = token(*p++);\n\t\t\t\twhile (top > 0) {\n\t\t\t\t\tif (rank(id) <= rank(stack[top-1].id))\n\t\t\t\t\t\tbuf[end++] = stack[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tstack[top++].id = id;\n\t\t\t}\n\t\t}\n\t\twhile (top > 0) buf[end++] = stack[--top];\n\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((id = buf[i].id) == VAL) stack[top++].v = buf[i].v;\n\t\t\telse {\n\t\t\t\tv1 = stack[--top].v, v2 = stack[--top].v;\n\t\t\t\tif      (id == PLUS)  v2 += v1;\n\t\t\t\telse if (id == MINUS) v2 -= v1;\n\t\t\t\telse if (id == MUL)   v2 *= v1;\n\t\t\t\tstack[top++].v = v2;\n\t\t\t}\n\t\t}\n\t\tif (f) ans = stack[--top].v, f = 0;\n\t\telse if (ans < stack[--top].v) ans = stack[top].v;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <inttypes.h>\n#include <ctype.h>\n\nint tokenNum;\nint64_t tokens[256];\n\nint yusen[8];\n\nint exprNum;\nint64_t expr[256];\n\nvoid gotiusa(void) {\n\tint i;\n\tint stackNum = 0;\n\tint64_t stack[256];\n\texprNum = 0;\n\tfor (i = 0; i < tokenNum; i++) {\n\t\tswitch (tokens[i]) {\n\t\t\tcase -1: case -2: case -3:\n\t\t\t\twhile (stackNum > 0 && yusen[-stack[stackNum - 1]] >= yusen[-tokens[i]]) {\n\t\t\t\t\texpr[exprNum++] = stack[--stackNum];\n\t\t\t\t}\n\t\t\t\tstack[stackNum++] = tokens[i];\n\t\t\t\tbreak;\n\t\t\tcase -4:\n\t\t\t\tstack[stackNum++] = -4;\n\t\t\t\tbreak;\n\t\t\tcase -5:\n\t\t\t\twhile (stackNum > 0 && stack[stackNum - 1] != -4) {\n\t\t\t\t\texpr[exprNum++] = stack[--stackNum];\n\t\t\t\t}\n\t\t\t\tif (stackNum > 0) stackNum--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texpr[exprNum++] = tokens[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile (stackNum > 0) {\n\t\texpr[exprNum++] = stack[--stackNum];\n\t}\n}\n\nint64_t kinnmoza(void) {\n\tint i;\n\tint stackNum = 0;\n\tint64_t stack[256];\n\tfor (i = 0; i < exprNum; i++) {\n\t\tswitch (expr[i]) {\n\t\t\tcase -1:\n\t\t\t\tif (stackNum >= 2) {\n\t\t\t\t\tstack[stackNum - 2] += stack[stackNum - 1];\n\t\t\t\t\tstackNum--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\tif (stackNum >= 2) {\n\t\t\t\t\tstack[stackNum - 2] -= stack[stackNum - 1];\n\t\t\t\t\tstackNum--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase -3:\n\t\t\t\tif (stackNum >= 2) {\n\t\t\t\t\tstack[stackNum - 2] *= stack[stackNum - 1];\n\t\t\t\t\tstackNum--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (expr[i] >= 0) stack[stackNum++] = expr[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn stackNum > 0 ? stack[stackNum - 1] : 0;\n}\n\nint main(void) {\n\tchar asumikana[256];\n\tint i;\n\tint64_t mizukinana = INT64_MIN;\n\tif (scanf(\"%255s\", asumikana) != 1) return 1;\n\tfor (i = 0; asumikana[i] != '\\0'; i++) {\n\t\tswitch (asumikana[i]) {\n\t\t\tcase '+': tokens[tokenNum++] = -1; break;\n\t\t\tcase '-': tokens[tokenNum++] = -2; break;\n\t\t\tcase '*': tokens[tokenNum++] = -3; break;\n\t\t\tcase '(': tokens[tokenNum++] = -4; break;\n\t\t\tcase ')': tokens[tokenNum++] = -5; break;\n\t\t\tdefault:\n\t\t\t\tif (isdigit((unsigned char)asumikana[i])) {\n\t\t\t\t\tint64_t num = 0;\n\t\t\t\t\twhile (isdigit((unsigned char)asumikana[i])) {\n\t\t\t\t\t\tnum = num * 10 + (asumikana[i] - '0');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti--;\n\t\t\t\t\ttokens[tokenNum++] = num;\n\t\t\t\t} else {\n\t\t\t\t\tputs(\"INVALID TOKEN\");\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor (yusen[1] = 1; yusen[1] <= 3; yusen[1]++) {\n\t\t\n\t\tfor (yusen[2] = 1; yusen[2] <= 3; yusen[2]++) {\n\t\t\tfor (yusen[3] = 1; yusen[3] <= 3; yusen[3]++) {\n\t\t\t\tint64_t mizuhasu;\n\t\t\t\tgotiusa();\n\t\t\t\tmizuhasu = kinnmoza();\n\t\t\t\tif (mizuhasu > mizukinana) mizukinana = mizuhasu;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%\" PRId64 \"\\n\", mizukinana);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Unordered Operators\n */\npublic class Main {\n\n\tstatic Main main;\n\tstatic int[][] PRI;\n\tstatic final int[][] _PRI = {\n\t\t\t{1, 2, 3},\n\t\t\t{1, 3, 2},\n\t\t\t{2, 1, 3},\n\t\t\t{2, 3, 1},\n\t\t\t{3, 1, 2},\n\t\t\t{3, 2, 1},\n\t\t\t//\n\t\t\t{1, 1, 2},\n\t\t\t{1, 2, 1},\n\t\t\t{2, 1, 1},\n\t\t\t//\n\t\t\t{2, 2, 1},\n\t\t\t{2, 1, 2},\n\t\t\t{1, 2, 2},\n\t\t\t//\n\t\t\t{2, 2, 2},\n\t};\n\n\t//priority list\n\t{\n\t\tPRI = new int[_PRI.length][128];\n\t\tfor (int i = 0; i < PRI.length; i++) {\n\t\t\tPRI[i]['('] = 5;\n\t\t\tPRI[i][127] = 4;\n\t\t\tPRI[i]['+'] = _PRI[i][0];\n\t\t\tPRI[i]['-'] = _PRI[i][1];\n\t\t\tPRI[i]['*'] = _PRI[i][2];\n\t\t\tPRI[i][')'] = 0;\n\t\t\tPRI[i]['\\0'] = -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tmain = new Main();\n\n\t\t//parse\n\t\tline = br.readLine();\n\t\twords = line.split(\"(?<!\\\\d)|(?!\\\\d)\");\n\t\tList<Elm> expr = new ArrayList<>();\n\n\t\tfor (String word : words) {\n\t\t\tchar c = word.charAt(0);\n\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\texpr.add(main.new Lp());\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\texpr.add(main.new Rp());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\texpr.add(main.new Add());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\texpr.add(main.new Subtract());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\texpr.add(main.new Multiply());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texpr.add(main.new Num(parseInt(word)));\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tlong max = Long.MIN_VALUE;\n\t\tfor (int i = 0; i < PRI.length; i++) {\n\t\t\t//toString(expr);\n\t\t\tmax = Math.max(max, eval(postfix(expr, PRI[i])));\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic List<Elm> postfix(List<Elm> expr, int[] pri) {\n\t\tDeque<Elm> stack = new ArrayDeque<>();\n\t\tList<Elm> list = new ArrayList<>();\n\n\t\tstack.push(main.new Nop());\n\t\tfor (Elm e : expr) {\n\t\t\tint p1, p2;\n\t\t\tp1 = pri[stack.peek().pri()];\n\t\t\tp2 = pri[e.pri()];\n\t\t\twhile (p2 <= p1 && !(stack.peek() instanceof Lp)) {\n\t\t\t\tlist.add(stack.pop());\n\t\t\t\tp1 = pri[stack.peek().pri()];\n\t\t\t}\n\t\t\tif (!(e instanceof Rp)) {\n\t\t\t\tstack.push(e);\n\t\t\t} else {\n\t\t\t\t//remove '('\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\twhile (!(stack.peek() instanceof Nop)) {\n\t\t\tlist.add(stack.pop());\n\t\t}\n\t\treturn list;\n\t}\n\n\tstatic long eval(List<Elm> expr) {\n\t\tDeque<Long> stack = new ArrayDeque<>();\n\n//\t\ttoString(expr);\n\n\t\tfor (Elm e : expr) {\n\t\t\tif (e instanceof Op) {\n\t\t\t\tlong a, b;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tstack.push(((Op) e).operate(a, b));\n\t\t\t} else {\n\t\t\t\tstack.push(((Num) e).value);\n\t\t\t}\n\t\t}\n\t\treturn stack.pop();\n\t}\n\n//\tstatic void toString(List<Elm> expr) {\n//\t\tfor (Elm e : expr) {\n//\t\t\tif (e instanceof Op) {\n//\t\t\t\tSystem.out.print((char) e.pri());\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(((Num) e).value);\n//\t\t\t}\n//\t\t\tSystem.out.print(' ');\n//\t\t}\n//\t\tSystem.out.println();\n//\t}\n\n\t//\n\tinterface Elm {\n\t\tint pri();\n\t}\n\n\tinterface Op extends Elm {\n\t\tlong operate(long a, long b);\n\t}\n\n\tclass Lp implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '(';\n\t\t}\n\t}\n\n\tclass Rp implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn ')';\n\t\t}\n\t}\n\n\tclass Add implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '+';\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a - b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '-';\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a * b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '*';\n\t\t}\n\t}\n\n\tclass Nop implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tclass Num implements Elm {\n\t\tlong value;\n\n\t\tNum(long value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn 127;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n\tstatic String s;\n\tstatic int now;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\ts = sc.next();\n\t\ts += \"=\";\n\t\tnow = 0;\n\t\tlong max = -9223372036854775808L;\n\t\tmax = Math.max(max, expression('+', '-', '*'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression12('+', '-', '*'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression12('-', '*', '+'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression12('*', '+', '-'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression21('+', '-', '*'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression21('-', '*', '+'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, expression21('*', '+', '-'));\n\t\tnow = 0;\n\t\tmax = Math.max(max, ex1('+', '-', '*'));\n\t\tnow  = 0;\n\t\tmax = Math.max(max, ex1('+', '*', '-'));\n\t\tnow  = 0;\n\t\tmax = Math.max(max, ex1('-', '+', '*'));\n\t\tnow  = 0;\n\t\tmax = Math.max(max, ex1('-', '*', '+'));\n\t\tnow  = 0;\n\t\tmax = Math.max(max, ex1('*', '+', '-'));\n\t\tnow  = 0;\n\t\tmax = Math.max(max, ex1('*', '-', '+'));\n\t\tSystem.out.println(max);\n\t}\n\tstatic long expression(char c1, char c2, char c3) {\n\t\tlong ret = factor(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c1) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor(c1, c2, c3), c1);\n\t\t\t} else if (s.charAt(now) == c2) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor(c1, c2, c3), c2);\n\t\t\t} else if (s.charAt(now) == c3) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor(c1, c2, c3), c3);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long factor(char c1, char c2, char c3) {\n\t\tif (s.charAt(now) == '(') {\n\t\t\tnow++;\n\t\t\tlong ret = expression(c1, c2, c3);\n\t\t\tnow++;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\tstatic long expression12(char c1, char c2, char c3) {\n\t\tlong ret = term12(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c1) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, term12(c1, c2, c3), c1);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long term12(char c1, char c2, char c3) {\n\t\tlong ret = factor12(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c2) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor12(c1, c2, c3), c2);\n\t\t\t} else if (s.charAt(now) == c3) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor12(c1, c2, c3), c3);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long factor12(char c1, char c2, char c3) {\n\t\tif (s.charAt(now) == '(') {\n\t\t\tnow++;\n\t\t\tlong ret = expression12(c1, c2, c3);\n\t\t\tnow++;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\tstatic long expression21(char c1, char c2, char c3) {\n\t\tlong ret = term21(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c1) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, term21(c1, c2, c3), c1);\n\t\t\t} else if (s.charAt(now) == c2) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, term21(c1, c2, c3), c2);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long term21(char c1, char c2, char c3) {\n\t\tlong ret = factor21(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c3) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor21(c1, c2, c3), c3);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long factor21(char c1, char c2, char c3) {\n\t\tif (s.charAt(now) == '(') {\n\t\t\tnow++;\n\t\t\tlong ret = expression21(c1, c2, c3);\n\t\t\tnow++;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\tstatic long ex1(char c1, char c2, char c3) {\n\t\tlong ret = ex2(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c1) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, ex2(c1, c2, c3), c1);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long ex2(char c1, char c2, char c3) {\n\t\tlong ret = ex3(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c2) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, ex3(c1, c2, c3), c2);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long ex3(char c1, char c2, char c3) {\n\t\tlong ret = factor1(c1, c2, c3);\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == c3) {\n\t\t\t\tnow++;\n\t\t\t\tret = cal(ret, factor1(c1, c2, c3), c3);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long factor1(char c1, char c2, char c3) {\n\t\tif (s.charAt(now) == '(') {\n\t\t\tnow++;\n\t\t\tlong ret = ex1(c1, c2, c3);\n\t\t\tnow++;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\tstatic long number() {\n\t\tlong ret = 0;\n\t\twhile (Character.isDigit(s.charAt(now))) {\n\t\t\tret *= 10;\n\t\t\tret += s.charAt(now) - '0';\n\t\t\tnow++;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic long cal(long n, long m, char c) {\n\t\tif (c == '+') {\n\t\t\treturn n + m;\n\t\t} else if (c == '-') {\n\t\t\treturn n - m;\n\t\t} else {\n\t\t\treturn n * m;\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Unordered Operators\n */\npublic class Main {\n\n\tstatic Main main;\n\tstatic int[][] PRI;\n\tstatic final int[][] _PRI = {\n\t\t\t{1, 2, 3},\n\t\t\t{1, 3, 2},\n\t\t\t{2, 1, 3},\n\t\t\t{2, 3, 1},\n\t\t\t{3, 1, 2},\n\t\t\t{3, 2, 1},\n\t\t\t//\n\t\t\t{1, 1, 2},\n\t\t\t{1, 2, 1},\n\t\t\t{2, 1, 1},\n\t\t\t//\n\t\t\t{2, 2, 1},\n\t\t\t{2, 1, 2},\n\t\t\t{1, 2, 2},\n\t\t\t//\n\t\t\t{2, 2, 2},\n\t};\n\n\t//priority list\n\t{\n\t\tPRI = new int[_PRI.length][128];\n\t\tfor (int i = 0; i < PRI.length; i++) {\n\t\t\tPRI[i]['('] = 5;\n\t\t\tPRI[i][127] = 4;\n\t\t\tPRI[i]['+'] = _PRI[i][0];\n\t\t\tPRI[i]['-'] = _PRI[i][1];\n\t\t\tPRI[i]['*'] = _PRI[i][2];\n\t\t\tPRI[i][')'] = 0;\n\t\t\tPRI[i]['\\0'] = -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tmain = new Main();\n\n\t\t//parse\n\t\tline = br.readLine();\n\t\twords = line.split(\"(?<!\\\\d)|(?!\\\\d)\");\n\t\tList<Elm> expr = new ArrayList<>();\n\n\t\tfor (String word : words) {\n\t\t\tchar c = word.charAt(0);\n\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\texpr.add(main.new Lp());\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\texpr.add(main.new Rp());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\texpr.add(main.new Add());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\texpr.add(main.new Subtract());\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\texpr.add(main.new Multiply());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texpr.add(main.new Num(parseInt(word)));\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tlong max = -(1 << 61);\n\t\tfor (int i = 0; i < PRI.length; i++) {\n\t\t\t//toString(expr);\n\t\t\tmax = Math.max(max, eval(postfix(expr, PRI[i])));\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic List<Elm> postfix(List<Elm> expr, int[] pri) {\n\t\tDeque<Elm> stack = new ArrayDeque<>();\n\t\tList<Elm> list = new ArrayList<>();\n\n\t\tstack.push(main.new Nop());\n\t\tfor (Elm e : expr) {\n\t\t\tint p1, p2;\n\t\t\tp1 = pri[stack.peek().pri()];\n\t\t\tp2 = pri[e.pri()];\n\t\t\twhile (p2 <= p1 && !(stack.peek() instanceof Lp)) {\n\t\t\t\tlist.add(stack.pop());\n\t\t\t\tp1 = pri[stack.peek().pri()];\n\t\t\t}\n\t\t\tif (!(e instanceof Rp)) {\n\t\t\t\tstack.push(e);\n\t\t\t} else {\n\t\t\t\t//remove '('\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\twhile (!(stack.peek() instanceof Nop)) {\n\t\t\tlist.add(stack.pop());\n\t\t}\n\t\treturn list;\n\t}\n\n\tstatic long eval(List<Elm> expr) {\n\t\tDeque<Long> stack = new ArrayDeque<>();\n\n//\t\ttoString(expr);\n\n\t\tfor (Elm e : expr) {\n\t\t\tif (e instanceof Op) {\n\t\t\t\tlong a, b;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tstack.push(((Op) e).operate(a, b));\n\t\t\t} else {\n\t\t\t\tstack.push(((Num) e).value);\n\t\t\t}\n\t\t}\n\t\treturn stack.pop();\n\t}\n\n//\tstatic void toString(List<Elm> expr) {\n//\t\tfor (Elm e : expr) {\n//\t\t\tif (e instanceof Op) {\n//\t\t\t\tSystem.out.print((char) e.pri());\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(((Num) e).value);\n//\t\t\t}\n//\t\t\tSystem.out.print(' ');\n//\t\t}\n//\t\tSystem.out.println();\n//\t}\n\n\t//\n\tinterface Elm {\n\t\tint pri();\n\t}\n\n\tinterface Op extends Elm {\n\t\tlong operate(long a, long b);\n\t}\n\n\tclass Lp implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '(';\n\t\t}\n\t}\n\n\tclass Rp implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn ')';\n\t\t}\n\t}\n\n\tclass Add implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '+';\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a - b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '-';\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn a * b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn '*';\n\t\t}\n\t}\n\n\tclass Nop implements Op {\n\n\t\t@Override\n\t\tpublic long operate(long a, long b) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tclass Num implements Elm {\n\t\tlong value;\n\n\t\tNum(long value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int pri() {\n\t\t\treturn 127;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "[Fixnum, Bignum].each do |klass|\n\tklass.class_eval do\n\t\talias :orig_plus :+\n\t\talias :orig_mul :*\n\t\talias :orig_sub :-\n\t\tremove_method :*, :/, :%, :+, :-, :&\n\tend\nend\t\n\ne0 = gets.chomp\nresults = []\n\nredef = -> op, orig {\n\tInteger.class_eval { define_method(op){|x| send(orig, x)} }\n}\n\n[0, 1, 2].repeated_permutation(3) do |priority|\n\tnext if ! priority.include?(0) \n\tnext if priority.sort.uniq == [0, 2]\n\n\te = e0.tr(\"+*-\", \"abc\")\t\n\tops = [[?*, ?/, ?%], [?+, ?-], [?&]]\n\n\top = ops[priority[0]].pop\n\te.gsub!(?a, op)\n\tredef[op, :orig_plus]\n\n\top = ops[priority[1]].pop\n\te.gsub!(?b, op)\n\tredef[op, :orig_mul]\n\n\top = ops[priority[2]].pop\n\te.gsub!(?c, op)\n\tredef[op, :orig_sub]\n\n\tresults << eval(e)\nend\n\np results.max"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n    alias :orig_plus :+\n    alias :orig_mul :*\n    alias :orig_sub :-\nend \n\ne0 = gets.chomp\nresults = []\n\n[0, 1, 2].repeated_permutation(3) do |priority|\n    tmp = priority.sort.uniq\n    next unless tmp == (0..tmp.size-1).to_a\n\n    e = e0.tr(\"+*-\", \"abc\") \n    ops = [[?*, ?/, ?%], [?+, ?-], [?&]]\n\n    op = ops[priority[0]].pop\n    e.gsub!(?a, op) \n    Fixnum.class_eval { alias_method(op, :orig_plus) }\n\n    op = ops[priority[1]].pop\n    e.gsub!(?b, op) \n    Fixnum.class_eval { alias_method(op, :orig_mul) }\n\n    op = ops[priority[2]].pop\n    e.gsub!(?c, op) \n    Fixnum.class_eval { alias_method(op, :orig_sub) }\n\n    results << eval(e)\nend\n\np results.max"
  },
  {
    "language": "Ruby",
    "code": "gets\np %w(% & |).permutation.map{|p|s=$_.tr\"-+*\",p*''\nFixnum.class_eval{%w(- + *).each{|o|alias_method p.pop,o}}\neval s}.max"
  },
  {
    "language": "Ruby",
    "code": "gets\np %w(% & |).permutation.map{|p|s=$_.tr\"-+*\",p*''\nFixnum.class_eval{%w(* + -).each{|o|alias_method p.pop,o}}\n(eval s).abs}.max"
  },
  {
    "language": "Ruby",
    "code": "ets\np %w(% & |).permutation.map{|p|s=$_.tr\"-+*\",p*''\nFixnum.class_eval{%w(* + -).each{|o|alias_method p.pop,o}}\neval s}.max"
  },
  {
    "language": "Ruby",
    "code": "gets\np %w(% & |).permutation.map{|p|s=$_.tr\"-+*\",p*''\nFixnum.class_eval{%w(* + -).each{|o|alias_method p.pop,o}}\neval s}.max"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n    alias :orig_plus :+\n    alias :orig_mul :*\n    alias :orig_sub :-\nend\n\ne0 = gets.chomp\nresults = []\n\n[0, 1, 2].repeated_permutation(3) do |priority|\n    next if ! priority.include?(0)\n    next if priority.sort.uniq == [0, 2]\n\n    e = e0.tr(\"+*-\", \"abc\")\n    ops = [[?*, ?/, ?%], [?+, ?-], [?&]]\n\n    op = ops[priority[0]].pop\n    e.gsub!(?a, op)\n    Fixnum.class_eval { alias_method(op, :orig_plus) }\n\n    op = ops[priority[1]].pop\n    e.gsub!(?b, op)\n    Fixnum.class_eval { alias_method(op, :orig_mul) }\n\n    op = ops[priority[2]].pop\n    e.gsub!(?c, op)\n    Fixnum.class_eval { alias_method(op, :orig_sub) }\n\n    results << eval(e)\nend\n\np results.max"
  },
  {
    "language": "Ruby",
    "code": "gets;p %w(% & |).permutation.map{|p|$_.tr!\"-+*\",p*'';Fixnum.class_eval{%w(- + *).each{|o|alias_method p.pop,o}};eval$_}.max"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\nops = [\"+\", \"-\", \"*\"]\nnums = [str(i) for i in range(0, 10)]\npriorities = []\nfor op1 in ops:\n  for op2 in ops:\n    for op3 in ops:\n      if op1 != op2 and op1 != op3 and op2 != op3:\n        priorities += [[op1], [op2], [op3]]\n        priorities += [[op1], [op2, op3]]\n        priorities += [[op1, op2], [op3]]\n        priorities += [[op1, op2, op3]]\n\ndef calc(num_lst, op_lst, priority):\n  for x in range(len(priority)):\n    while op_lst:\n      for i, op in enumerate(op_lst):\n        if op in priority[x]:\n          if op == \"+\":\n            num_lst = num_lst[:i] + [num_lst[i] + num_lst[i + 1]] + num_lst[i + 2:]\n          elif op == \"-\":\n            num_lst = num_lst[:i] + [num_lst[i] - num_lst[i + 1]] + num_lst[i + 2:]\n          else:\n            num_lst = num_lst[:i] + [num_lst[i] * num_lst[i + 1]] + num_lst[i + 2:]\n          op_lst.pop(i)\n          break\n      else:\n        break\n  return num_lst[0]\n\ndef parse(s, priority):\n  num_lst = []\n  op_lst = []\n  p = 0\n  if s[p] == \"(\":\n    p += 1\n    num, addp = parse(s[p:], priority)\n    num_lst.append(num)\n    p += addp\n\n  elif s[p] in nums:\n    acc = \"\"\n    while s[p] in nums:\n      acc += s[p]\n      p += 1\n    num_lst.append(int(acc))\n  \n  while p < len(s) and s[p] != \")\":\n    op_lst.append(s[p])\n    p += 1\n    acc = \"\"\n    if s[p] == \"(\":\n      p += 1\n      num, addp = parse(s[p:], priority)\n      num_lst.append(num)\n      p += addp\n    else:\n      #print(s[p])\n      while s[p] in nums:\n        acc += s[p]\n        p += 1\n      num_lst.append(int(acc))\n  p += 1\n\n  return (calc(num_lst, op_lst, priority), p)\n\ndef main():\n  s = \"(\" + input() + \")\"\n  ans = -INF\n  for priority in priorities:\n    a, _ = parse(s, priority)\n    ans = max(ans, a)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "\nS = input()\ny = [0,0,0]\nans = -1e64\n\ndef calc(s):\n    #print(s)\n    A = []\n    i = 0\n    cntr = 0\n    s2 = \"\"\n    for j,c in enumerate(s):\n        if cntr > 0:\n            if c == ')':\n                cntr -= 1\n                if cntr == 0:\n                    A.append(calc(s2))\n                    continue\n            if c == '(':\n                cntr += 1\n            s2 = s2 + c\n        else:\n            if c.isdigit():\n                i *= 10\n                i += int(c)\n            else:\n                if c == '(':\n                    cntr += 1\n                    if cntr == 1:\n                        s2 = \"\"\n                    continue\n                if s[j - 1] != ')':\n                    A.append(i)\n                i = 0\n                A.append(c)\n    A.append(i)\n    #print(A)\n    for i in range(3):\n        j = 0\n        while j < len(A):\n            a = A[j]\n            if a == \"+\" and y[0] == i:\n                A[j - 1] += A[j + 1]\n                del A[j : j + 2]\n            elif a == \"-\" and y[1] == i:\n                A[j - 1] -= A[j + 1]\n                del A[j : j + 2]\n            elif a == \"*\" and y[2] == i:\n                A[j - 1] *= A[j + 1]\n                del A[j : j + 2]\n            else:\n                j += 1\n    return A[0]\n\n\nfor i in range(27):\n    y[0] = i // 9\n    y[1] = (i % 9) // 3\n    y[2] = i % 3\n    ans = max(ans, calc(S))\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\ndef calc(lst, pos, pr):\n    ret = []\n    while pos < len(lst):\n        if lst[pos] == '(':\n            val, pos = calc(lst, pos + 1, pr)\n            ret.append(val)\n        elif lst[pos] == ')':\n            pos += 1\n            break\n        else:\n            ret.append(lst[pos])\n            pos += 1\n    lst = ret\n    for p in pr:\n        i = 0\n        ret = []\n        while i < len(lst):\n            if lst[i] in p:\n                ret[-1] = eval(str(ret[-1]) + lst[i] + str(lst[i + 1]))\n                i += 2\n            else:\n                ret.append(lst[i])\n                i += 1\n        lst = ret\n    return lst[0], pos\n\nS = raw_input()\n\nlst = []\nss = ''\nfor c in S:\n    if c in ['+', '-', '*', '(', ')']:\n        if ss != '':\n            lst.append(int(ss))\n        lst.append(c)\n        ss = ''\n    else:\n        ss += c\nif ss != '':\n    lst.append(int(ss))\n\nans = -(10 ** 30)\nfor i, j, k in it.product([0, 1, 2], repeat = 3):\n    pr = [[], [], []]\n    pr[i].append('+')\n    pr[j].append('-')\n    pr[k].append('*')\n    ans = max(ans, calc(lst, 0, pr)[0])\n\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\nO = {'+': lambda l, r: l + r,\n     '-': lambda l, r: l - r,\n     '*': lambda l, r: l * r}\n\nP = {'+': 0,\n     '-': 0,\n     '*': 0}\n\nclass Source():\n    def __init__(self, S, i=0):\n        self.S = S\n        self.pos = i\n\ndef peek(S):\n    return S.S[S.pos] if S.pos < len(S.S) else 'a'\n\ndef next(S):\n    S.pos += 1\n\ndef expr(S, i):\n    # print(S.pos)\n    if i == 0:\n        left = factor(S)\n    else:\n        left = expr(S, i - 1)\n\n    while peek(S) in O and P[peek(S)] == i:\n        ope = peek(S)\n        next(S)\n        if i == 0:\n            right = factor(S)\n        else:\n            right = expr(S, i - 1)\n            \n        left = O[ope](left, right)\n        \n    # print(left, i)\n    return left\n\n\ndef factor(S):\n    if peek(S) == '(':\n        next(S)\n        res = expr(S, 2)\n        next(S)\n    else:\n        res = num(S)\n    return res\n\ndef num(S):\n    sign = 1\n    if peek(S) == '-':\n        sign = -1\n        next(S)\n    res = 0\n    while '0' <= peek(S) <= '9':\n        res = res * 10 + int(peek(S))\n        next(S)\n\n    return sign * res\n\nS = input()\nans = -int(1e19)\n\nfor plus in range(3):\n    P['+'] = plus\n    for minus in range(3):\n        P['-'] = minus\n        for times in range(3):\n            P['*'] = times\n            ans = max(ans, expr(Source(S), 2))\n            \nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from string import digits\nfrom itertools import product\nS = input() + \"$\"\n\ndef parse(pri):\n    code = \"+-*\"\n\n    cur = 0\n    def number():\n        nonlocal cur\n        c = S[cur]\n        if c == '(':\n            cur += 1 # '('\n            v = expr(0)\n            cur += 1 # ')'\n            return v\n        num = 0\n        while S[cur] in digits:\n            num = 10*num + int(S[cur])\n            cur += 1\n        return num\n    def expr(level):\n        nonlocal cur\n        op = '+'\n        result = 0\n        while 1:\n            if level == 2:\n                v = number()\n            else:\n                v = expr(level+1)\n            if op == '+':\n                result += v\n            elif op == '-':\n                result -= v\n            else:\n                result *= v\n            c = S[cur]\n            if code.find(c) == -1 or pri[code.index(c)] != level:\n                break\n            op = c\n            cur += 1\n        return result\n    return expr(0)\nans = 0\nfor pri in product(range(3), repeat=3):\n    ans = max(ans, parse(pri))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n\n    t = []\n    k = 0\n    kf = False\n    for c in s:\n        if '0' <= c <= '9':\n            k *= 10\n            k += int(c)\n            kf = True\n        else:\n            if kf:\n                t.append(k)\n            k = 0\n            t.append(c)\n            kf = False\n    if kf:\n        t.append(k)\n\n    def calc(a,b,o):\n        if o == '+':\n            return a + b\n        if o == '-':\n            return a - b\n        return a * b\n\n    def f(s, ops):\n        t = s[:]\n        ff = True\n        while ff:\n            ff = False\n            ti = -1\n            for i in range(len(t)-1,-1,-1):\n                if t[i] == '(':\n                    ti = i\n                    break\n            if ti < 0:\n                break\n            tj = -1\n            for i in range(ti+1,len(t)):\n                if t[i] == ')':\n                    tj = i + 1\n                    break\n            t[ti:tj] = [f(t[ti+1:tj-1], ops)]\n            ff = True\n\n        for i in range(3):\n            nt = []\n            for c in t:\n                if isinstance(c, int):\n                    if len(nt) > 1 and ops[nt[-1]] == i:\n                        kt = calc(nt[-2],c,nt[-1])\n                        nt[-2] = kt\n                        del nt[-1]\n                    else:\n                        nt.append(c)\n                else:\n                    nt.append(c)\n            t = nt\n        return t[0]\n\n    r = -inf\n    for a in itertools.product(range(3), repeat=3):\n        tr = f(t, {'+': a[0], '-': a[1], '*': a[2]})\n        if r < tr:\n            r = tr\n\n    return r\n\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from string import digits\nfrom itertools import product\nS = input() + \"$\"\n\ndef parse(pri):\n    code = \"+-*\"\n\n    cur = 0\n    def number():\n        nonlocal cur\n        c = S[cur]\n        if c == '(':\n            cur += 1 # '('\n            v = expr(0)\n            cur += 1 # ')'\n            return v\n        num = 0\n        while S[cur] in digits:\n            num = 10*num + int(S[cur])\n            cur += 1\n        return num\n    def expr(level):\n        nonlocal cur\n        op = '+'\n        result = 0\n        while 1:\n            if level == 2:\n                v = number()\n            else:\n                v = expr(level+1)\n            if op == '+':\n                result += v\n            elif op == '-':\n                result -= v\n            else:\n                result *= v\n            c = S[cur]\n            if code.find(c) == -1 or pri[code.index(c)] != level:\n                break\n            op = c\n            cur += 1\n        return result\n    return expr(0)\nans = -10**30\nfor pri in product(range(3), repeat=3):\n    ans = max(ans, parse(pri))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\nops = [\"+\", \"-\", \"*\"]\nnums = [str(i) for i in range(0, 10)]\npriorities = []\nfor op1 in ops:\n  for op2 in ops:\n    for op3 in ops:\n      if op1 != op2 and op1 != op3 and op2 != op3:\n        priorities.append([[op1], [op2], [op3]])\n        priorities.append([[op1], [op2, op3]])\n        priorities.append([[op1, op2], [op3]])\n        priorities.append([[op1, op2, op3]])\n\ndef calc(num_lst, op_lst, priority):\n  for x in range(len(priority)):\n    while op_lst:\n      for i, op in enumerate(op_lst):\n        if op in priority[x]:\n          if op == \"+\":\n            num_lst = num_lst[:i] + [num_lst[i] + num_lst[i + 1]] + num_lst[i + 2:]\n          elif op == \"-\":\n            num_lst = num_lst[:i] + [num_lst[i] - num_lst[i + 1]] + num_lst[i + 2:]\n          else:\n            num_lst = num_lst[:i] + [num_lst[i] * num_lst[i + 1]] + num_lst[i + 2:]\n          op_lst.pop(i)\n          break\n      else:\n        break\n  return num_lst[0]\n\ndef parse(s, priority):\n  num_lst = []\n  op_lst = []\n  p = 0\n  if s[p] == \"(\":\n    p += 1\n    num, addp = parse(s[p:], priority)\n    num_lst.append(num)\n    p += addp\n\n  elif s[p] in nums:\n    acc = \"\"\n    while s[p] in nums:\n      acc += s[p]\n      p += 1\n    num_lst.append(int(acc))\n  \n  while p < len(s) and s[p] != \")\":\n    op_lst.append(s[p])\n    p += 1\n    acc = \"\"\n    if s[p] == \"(\":\n      p += 1\n      num, addp = parse(s[p:], priority)\n      num_lst.append(num)\n      p += addp\n    else:\n      #print(s[p])\n      while s[p] in nums:\n        acc += s[p]\n        p += 1\n      num_lst.append(int(acc))\n  p += 1\n\n  return (calc(num_lst, op_lst, priority), p)\n\ndef main():\n  s = \"(\" + input() + \")\"\n  ans = -INF\n  for priority in priorities:\n    a, _ = parse(s, priority)\n    ans = max(ans, a)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\ndef parse(S, op):\n    \"\"\"\n    構文木を返す\n    Sは普通の記法の式\n    opは優先順序　通常は(*/: 1, +-: 2)\n    \"\"\"\n    S = \"0+({})\".format(S)\n    V = []\n    for x in list(\"()+-*\"):\n        S = S.replace(x, \" {} \".format(x))\n    i = 0\n    rank = 0\n    O = []\n    for s in S.split():\n        if s == \"(\":\n            rank += 1\n        elif s == \")\":\n            rank -= 1\n        elif s.isdigit():\n            V.append(s)\n            i += 1\n        else:\n            V.append(s)\n            O.append([-rank, op[s], i])\n            i += 1\n\n    G = [[] for _ in range(len(V))]\n    P = [-1]*len(V)\n    O = sorted(O)\n    \n    def get_pair(i):\n        while P[i] != -1:\n            i = P[i]\n        return i\n    \n    for _, _, i in O:\n        l, r = get_pair(i-1), get_pair(i+1)\n        G[i].extend([l, r])\n        P[l], P[r] = i, i\n    p = O[-1][2]\n    return G, V, p\n\ndef make(G, V, p):\n    def call(i):\n        if V[i].isdigit():\n            return V[i]\n        else:\n            assert len(G[i]) == 2\n            left = call(G[i][0])\n            right = call(G[i][1])\n            return \"({}{}{})\".format(left, V[i], right)\n    return call(p)\n\nS = input()\nans = -float(\"inf\")\n\nfor a, b, c in product(range(3), repeat=3):\n    op = {}\n    op[\"+\"] = a\n    op[\"-\"] = b\n    op[\"*\"] = c\n    ans = max(ans, eval(make(*parse(S, op))))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\ndef func(S, pr):\n    lst = []\n    op_lst = ['+', '-', '*', '(', ')']\n    ss = ''\n    for c in S:\n        if c in op_lst:\n            if ss != '':\n                lst.append(int(ss))\n            lst.append(c)\n            ss = ''\n        else:\n            ss += c\n    if ss != '':\n        lst.append(int(ss))\n    while True:\n        if not '(' in lst:\n            break\n        pos1 = lst.index('(')\n        pos2 = lst.index(')')\n        lst = lst[:pos1] + [calc(lst[pos1 + 1:pos2], pr)] + lst[pos2 + 1:]\n    return calc(lst, pr)\n\ndef calc(lst, pr):\n    for p in pr:\n        for c in p:\n            while True:\n                if not c in lst:\n                    break\n                pos = lst.index(c)\n                lst = lst[:pos - 1] + [eval(str(lst[pos - 1]) + c + str(lst[pos + 1]))] + lst[pos + 2:]\n    return lst[0]\n\nS = raw_input()\nans = -(10 ** 30)\nfor i, j, k in it.product([0, 1, 2], repeat = 3):\n    pr = [[], [], []]\n    pr[i].append('+')\n    pr[j].append('-')\n    pr[k].append('*')\n    ans = max(ans, func(S, pr))\n\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nS = input()\nfor x in \"()+*-\":\n    S = S.replace(x, \" {} \".format(x))\nS = S.split()\n\ndef parse(pri, cur):\n\n    def number():\n        nonlocal cur\n        if S[cur].isdigit():\n            val = int(S[cur])\n            cur += 1\n            return val\n        cur += 1\n        val = expr(0)\n        cur += 1\n        return val\n    \n    def expr(level):\n        nonlocal cur\n        if level == 3:\n            this = number()\n        else:\n            this = expr(level+1)\n        while cur < len(S) and S[cur] in \"+-*\" and pri[S[cur]] == level:\n            op = S[cur]\n            cur += 1\n            that = expr(level+1)\n            if op == \"+\":\n                this += that\n            elif op == \"-\":\n                this -= that\n            else:\n                this *= that\n        return this\n    return expr(0)\n\npri = {}\nans = -float(\"inf\")\nfor P in product(range(3), repeat=3):\n    pri[\"+\"], pri[\"-\"], pri[\"*\"] = P\n    ans = max(ans, parse(pri, 0))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\ndef calc(lst, pos, pr):\n    ret = []\n    while True:\n        if pos >= len(lst):\n            break\n        if lst[pos] == '(':\n            val, pos = calc(lst, pos + 1, pr)\n            ret.append(val)\n        elif lst[pos] == ')':\n            pos += 1\n            break\n        else:\n            ret.append(lst[pos])\n            pos += 1\n    lst = ret\n    for p in pr:\n        i = 0\n        ret = []\n        while i < len(lst):\n            if lst[i] in p:\n                ret[-1] = eval(str(ret[-1]) + lst[i] + str(lst[i + 1]))\n                i += 2\n            else:\n                ret.append(lst[i])\n                i += 1\n    return ret[0], pos\n\nS = raw_input()\n\nlst = []\nss = ''\nfor c in S:\n    if c in ['+', '-', '*', '(', ')']:\n        if ss != '':\n            lst.append(int(ss))\n        lst.append(c)\n        ss = ''\n    else:\n        ss += c\nif ss != '':\n    lst.append(int(ss))\n\nans = -(10 ** 30)\nfor i, j, k in it.product([0, 1, 2], repeat = 3):\n    pr = [[], [], []]\n    pr[i].append('+')\n    pr[j].append('-')\n    pr[k].append('*')\n    ans = max(ans, calc(lst, 0, pr)[0])\n\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\nops = [\"+\", \"-\", \"*\"]\nnums = [str(i) for i in range(0, 10)]\npriorities = []\nfor op1 in ops:\n  for op2 in ops:\n    for op3 in ops:\n      if op1 != op2 and op1 != op3 and op2 != op3:\n        priorities.append([[op1], [op2], [op3]])\n        priorities.append([[op1], [op2, op3]])\n        priorities.append([[op1, op2], [op3]])\n        priorities.append([[op1, op2, op3]])\n\ndef calc(num_lst, op_lst, priority):\n  for x in range(len(priority)):\n    while op_lst:\n      for i, op in enumerate(op_lst):\n        if op in priority[x]:\n          if op == \"+\":\n            num_lst = num_lst[:i] + [num_lst[i] + num_lst[i + 1]] + num_lst[i + 2:]\n          elif op == \"-\":\n            num_lst = num_lst[:i] + [num_lst[i] - num_lst[i + 1]] + num_lst[i + 2:]\n          else:\n            num_lst = num_lst[:i] + [num_lst[i] * num_lst[i + 1]] + num_lst[i + 2:]\n          op_lst.pop(i)\n          break\n      else:\n        break\n  return num_lst[0]\n\ndef parse(s, priority):\n  num_lst = []\n  op_lst = []\n  p = 0\n  if s[p] == \"(\":\n    p += 1\n    num, addp = parse(s[p:], priority)\n    num_lst.append(num)\n    p += addp\n\n  elif s[p] in nums:\n    acc = \"\"\n    while s[p] in nums:\n      acc += s[p]\n      p += 1\n    num_lst.append(int(acc))\n  \n  while p < len(s) and s[p] != \")\":\n    op_lst.append(s[p])\n    p += 1\n    acc = \"\"\n    if s[p] == \"(\":\n      p += 1\n      num, addp = parse(s[p:], priority)\n      num_lst.append(num)\n      p += addp\n    else:\n      #print(s[p])\n      while s[p] in nums:\n        acc += s[p]\n        p += 1\n      num_lst.append(int(acc))\n  p += 1\n\n  return (calc(num_lst, op_lst, priority), p)\n\ndef main():\n  s = \"(\" + input() + \")\"\n  ans = -INF\n  for priority in priorities:\n    a, _ = parse(s, priority)\n    print(priority, a)\n    ans = max(ans, a)\n  print(ans)\nmain()\n"
  }
]