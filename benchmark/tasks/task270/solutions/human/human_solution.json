[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\nobject Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readLine()).takeWhile(_ != \"0 0 0\")\n      .map(str => (str.split(\" \")(0).toInt, str.split(\" \")(1).toInt, str.split(\" \")(2).toInt))\n      .map(MNCap => {\n        val fromTo = in.readLine()\n        val map = for (i <- 1 to MNCap._1) yield in.readLine()\n        val stations = for (i <- 1 to MNCap._2) yield in.readLine()\n        new Solver(MNCap, fromTo, map, stations)\n      }).map(_.solve()).foreach(println)\n\n  }\n}\n\nclass Solver(MNCap: (Int, Int, Int), fromTo: String, map: Seq[String], stationsSeq: Seq[String]) {\n  val (m, n, cap) = MNCap\n  val from = fromTo.split(\" \")(0)\n  val to = fromTo.split(\" \")(1)\n  val graph1 = map.map(fromToDistance => fromToDistance.split(\" \")(0) -> (fromToDistance.split(\" \")(1), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val graph2 = map.map(fromToDistance => fromToDistance.split(\" \")(1) -> (fromToDistance.split(\" \")(0), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val stations = stationsSeq.toSet\n\n  case class FoldResult(visited: Map[String, Int], answer: Map[(String, Int), Int])\n\n  def solve(): Int = {\n    import scala.collection.mutable.{PriorityQueue => MPriorityQueue}\n\n    val priorityQueue = MPriorityQueue[(Int, (String, Int))]()(Ordering.by(intString => -intString._1))\n\n    priorityQueue += (0 -> (from, cap*10))\n    val Sentinels = 2000 * 3000 + 1000\n\n    def fold(folder: FoldResult, dequeued: (Int, (String, Int))): FoldResult = {\n      val currentCityName = dequeued._2._1\n      val reamingGas = if(stations contains currentCityName) cap*10 else dequeued._2._2\n      val cityAndGasState = dequeued._2\n      val distanceToCurrentCity = dequeued._1\n\n      if(folder.visited.contains(to) ){\n        priorityQueue.clear()\n        folder\n      } else if (currentCityName == to) {\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n      else if (folder.visited.getOrElse(currentCityName,0) > reamingGas) folder\n      else {\n\n        graph1\n          .get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,0) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n        graph2.get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,0) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n    }\n\n\n    @tailrec\n    def req(foldResult: FoldResult): FoldResult = {\n//      println(priorityQueue.head +\" \"+ foldResult)\n      if (priorityQueue.length == 0) foldResult else req(fold(foldResult, priorityQueue.dequeue()))\n    }\n    val result: FoldResult = req(FoldResult(Map[String, Int](), Map[(String, Int), Int]()))\n//    println(result)\n    result.answer.map(ans => ans._1._1 -> ans._2 ).getOrElse(to,-1)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\nobject Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readLine()).takeWhile(_ != \"0 0 0\")\n      .map(str => (str.split(\" \")(0).toInt, str.split(\" \")(1).toInt, str.split(\" \")(2).toInt))\n      .map(MNCap => {\n        val fromTo = in.readLine()\n        val map = for (i <- 1 to MNCap._1) yield in.readLine()\n        val stations = for (i <- 1 to MNCap._2) yield in.readLine()\n        new Solver(MNCap, fromTo, map, stations)\n      }).map(_.solve()).foreach(println)\n\n  }\n}\n\nclass Solver(MNCap: (Int, Int, Int), fromTo: String, map: Seq[String], stationsSeq: Seq[String]) {\n  val (m, n, cap) = MNCap\n  val from = fromTo.split(\" \")(0)\n  val to = fromTo.split(\" \")(1)\n  val graph1 = map.map(fromToDistance => fromToDistance.split(\" \")(0) -> (fromToDistance.split(\" \")(1), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val graph2 = map.map(fromToDistance => fromToDistance.split(\" \")(1) -> (fromToDistance.split(\" \")(0), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val stations = stationsSeq.toSet\n\n  case class FoldResult(visited: Map[String, Int], answer: Map[(String, Int), Int])\n\n  def solve(): Int = {\n    import scala.collection.mutable.{PriorityQueue => MPriorityQueue}\n\n    val priorityQueue = MPriorityQueue[(Int, (String, Int))]()(Ordering.by(intString => -intString._1))\n\n    priorityQueue += (0 -> (from, cap*10))\n    val Sentinels = 2000 * 3000 + 1000\n\n    def fold(folder: FoldResult, dequeued: (Int, (String, Int))): FoldResult = {\n      val currentCityName = dequeued._2._1\n      val reamingGas = if(stations contains currentCityName) cap*10 else dequeued._2._2\n      val cityAndGasState = dequeued._2\n      val distanceToCurrentCity = dequeued._1\n\n      if(folder.visited.contains(to) ){\n        priorityQueue.clear()\n        folder\n      } else if (currentCityName == to) {\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n      else if (folder.visited.getOrElse(currentCityName,-1) > reamingGas) folder\n      else {\n\n        graph1\n          .get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasState => folder.visited.getOrElse(cityAndGasState._1,-1) < cityAndGasState._2 )\n          .filter(cityAndGasState => cityAndGasState._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,-1) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n        graph2.get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasState => folder.visited.getOrElse(cityAndGasState._1,-1) < cityAndGasState._2 )\n          .filter(cityAndGasState => cityAndGasState._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,-1) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n    }\n\n    @tailrec\n    def req(foldResult: FoldResult): FoldResult = {\n//      println(priorityQueue +\" \"+ foldResult)\n      if (priorityQueue.length == 0) foldResult else req(fold(foldResult, priorityQueue.dequeue()))\n    }\n    val result: FoldResult = req(FoldResult(Map[String, Int](), Map[(String, Int), Int]()))\n //   println(result)\n    result.answer.map(ans => ans._1._1 -> ans._2 ).getOrElse(to,-1)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\n\nobject Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readLine()).takeWhile(_ != \"0 0 0\")\n      .map(str => (str.split(\" \")(0).toInt, str.split(\" \")(1).toInt, str.split(\" \")(2).toInt))\n      .map(MNCap => {\n        val fromTo = in.readLine()\n        val map = for (i <- 1 to MNCap._1) yield in.readLine()\n        val stations = for (i <- 1 to MNCap._2) yield in.readLine()\n        new Solver(MNCap, fromTo, map, stations)\n      }).map(_.solve()).foreach(println)\n\n  }\n}\n\nclass Solver(MNCap: (Int, Int, Int), fromTo: String, map: Seq[String], stationsSeq: Seq[String]) {\n  val (m, n, cap) = MNCap\n  val from = fromTo.split(\" \")(0)\n  val to = fromTo.split(\" \")(1)\n  val graph1 = map.map(fromToDistance => fromToDistance.split(\" \")(0) -> (fromToDistance.split(\" \")(1), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val graph2 = map.map(fromToDistance => fromToDistance.split(\" \")(1) -> (fromToDistance.split(\" \")(0), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val stations = stationsSeq.toSet\n\n  case class FoldResult(visited: Map[String, Int], answer: Map[(String, Int), Int])\n\n  def solve(): Int = {\n    import scala.collection.mutable.{PriorityQueue => MPriorityQueue}\n\n    val priorityQueue = MPriorityQueue[(Int, (String, Int))]()(Ordering.by(intString => -intString._1))\n\n    priorityQueue += (0 -> (from, cap*10))\n    val Sentinels = 2000 * 3000 + 1000\n\n    def fold(folder: FoldResult, dequeued: (Int, (String, Int))): FoldResult = {\n      val currentCityName = dequeued._2._1\n      val reamingGas = if(stations contains currentCityName) cap*10 else dequeued._2._2\n      val cityAndGasState = dequeued._2\n      val distanceToCurrentCity = dequeued._1\n\n      if (currentCityName == to) {\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n      else if (folder.visited.getOrElse(currentCityName,0) > reamingGas) folder\n      else {\n\n        graph1\n          .get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance =>\n              priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, reamingGas - nextCityNameAndDistance._2))\n          )\n        graph2.get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance =>\n              priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, reamingGas - nextCityNameAndDistance._2))\n          )\n\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n    }\n\n\n    @tailrec\n    def req(foldResult: FoldResult): FoldResult = {\n      if (priorityQueue.length == 0) foldResult else req(fold(foldResult, priorityQueue.dequeue()))\n    }\n    val result: FoldResult = req(FoldResult(Map[String, Int](), Map[(String, Int), Int]()))\n    result.answer.map(ans => ans._1._1 -> ans._2 ).getOrElse(to,-1)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\n\nobject Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readLine()).takeWhile(_ != \"0 0 0\")\n      .map(str => (str.split(\" \")(0).toInt, str.split(\" \")(1).toInt, str.split(\" \")(2).toInt))\n      .map(MNCap => {\n        val fromTo = in.readLine()\n        val map = for (i <- 1 to MNCap._1) yield in.readLine()\n        val stations = for (i <- 1 to MNCap._2) yield in.readLine()\n        new Solver(MNCap, fromTo, map, stations)\n      }).map(_.solve()).foreach(println)\n\n  }\n}\n\nclass Solver(MNCap: (Int, Int, Int), fromTo: String, map: Seq[String], stationsSeq: Seq[String]) {\n  val (m, n, cap) = MNCap\n  val from = fromTo.split(\" \")(0)\n  val to = fromTo.split(\" \")(1)\n  val graph1 = map.map(fromToDistance => fromToDistance.split(\" \")(0) -> (fromToDistance.split(\" \")(1), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val graph2 = map.map(fromToDistance => fromToDistance.split(\" \")(1) -> (fromToDistance.split(\" \")(0), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val stations = stationsSeq.toSet\n\n  case class FoldResult(visited: Map[String, Int], answer: Map[(String, Int), Int])\n\n  def solve(): Int = {\n    import scala.collection.mutable.{PriorityQueue => MPriorityQueue}\n\n    val priorityQueue = MPriorityQueue[(Int, (String, Int))]()(Ordering.by(intString => -intString._1))\n\n    priorityQueue += (0 -> (from, cap*10))\n    val Sentinels = 2000 * 3000 + 1000\n\n    def fold(folder: FoldResult, dequeued: (Int, (String, Int))): FoldResult = {\n      val currentCityName = dequeued._2._1\n      val reamingGas = if(stations contains currentCityName) cap*10 else dequeued._2._2\n      val cityAndGasState = dequeued._2\n      val distanceToCurrentCity = dequeued._1\n\n      if(folder.visited.contains(to) ){\n        folder\n      } else if (currentCityName == to) {\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n      else if (folder.visited.getOrElse(currentCityName,0) > reamingGas) folder\n      else {\n\n        graph1\n          .get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance =>\n              priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, reamingGas - nextCityNameAndDistance._2))\n          )\n        graph2.get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasstate => folder.visited.getOrElse(cityAndGasState._1,0) < cityAndGasState._2 )\n          .filter(_cityAndGasstate => _cityAndGasstate._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance =>\n              priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, reamingGas - nextCityNameAndDistance._2))\n          )\n\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n    }\n\n\n    @tailrec\n    def req(foldResult: FoldResult): FoldResult = {\n//      println(priorityQueue.head +\" \"+ foldResult)\n      if (priorityQueue.length == 0) foldResult else req(fold(foldResult, priorityQueue.dequeue()))\n    }\n    val result: FoldResult = req(FoldResult(Map[String, Int](), Map[(String, Int), Int]()))\n//    println(result)\n    result.answer.map(ans => ans._1._1 -> ans._2 ).getOrElse(to,-1)\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\n\nobject Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readLine()).takeWhile(_ != \"0 0 0\")\n      .map(str => (str.split(\" \")(0).toInt, str.split(\" \")(1).toInt, str.split(\" \")(2).toInt))\n      .map(MNCap => {\n        val fromTo = in.readLine()\n        val map = for (i <- 1 to MNCap._1) yield in.readLine()\n        val stations = for (i <- 1 to MNCap._2) yield in.readLine()\n        new Solver(MNCap, fromTo, map, stations)\n      }).map(_.solve()).foreach(println)\n\n  }\n}\n\nclass Solver(MNCap: (Int, Int, Int), fromTo: String, map: Seq[String], stationsSeq: Seq[String]) {\n  val (m, n, cap) = MNCap\n  val from = fromTo.split(\" \")(0)\n  val to = fromTo.split(\" \")(1)\n  val graph1 = map.map(fromToDistance => fromToDistance.split(\" \")(0) -> (fromToDistance.split(\" \")(1), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val graph2 = map.map(fromToDistance => fromToDistance.split(\" \")(1) -> (fromToDistance.split(\" \")(0), fromToDistance.split(\" \")(2).toInt)).groupBy(_._1)\n  val stations = stationsSeq.toSet\n\n  case class FoldResult(visited: Map[String, Int], answer: Map[(String, Int), Int])\n\n  def solve(): Int = {\n    import scala.collection.mutable.{PriorityQueue => MPriorityQueue}\n\n    val priorityQueue = MPriorityQueue[(Int, (String, Int))]()(Ordering.by(intString => -intString._1))\n\n    priorityQueue += (0 -> (from, cap*10))\n    val Sentinels = 2000 * 3000 + 1000\n\n    def fold(folder: FoldResult, dequeued: (Int, (String, Int))): FoldResult = {\n      val currentCityName = dequeued._2._1\n      val reamingGas = if(stations contains currentCityName) cap*10 else dequeued._2._2\n      val cityAndGasState = dequeued._2\n      val distanceToCurrentCity = dequeued._1\n\n      if(folder.visited.contains(to) ){\n        priorityQueue.clear()\n        folder\n      } else if (currentCityName == to) {\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n      else if (folder.visited.getOrElse(currentCityName,-1) > reamingGas) folder\n      else {\n\n        graph1\n          .get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasState => cityAndGasState._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,-1) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n        graph2.get(currentCityName).getOrElse(Seq()).map(fromAndTo => fromAndTo._2)\n          .filter(cityAndGasState => cityAndGasState._2 <= reamingGas)\n          .foreach(\n            nextCityNameAndDistance => {\n              val nextGasReaming = if (stations.contains(nextCityNameAndDistance._1)) cap * 10 else reamingGas - nextCityNameAndDistance._2\n              if(folder.visited.getOrElse(nextCityNameAndDistance._1,-1) < nextGasReaming){\n                priorityQueue += (distanceToCurrentCity + nextCityNameAndDistance._2 -> (nextCityNameAndDistance._1, nextGasReaming))\n              }\n            }\n          )\n\n        val newAnswer = folder.answer + (cityAndGasState -> distanceToCurrentCity)\n        val newVisited = folder.visited + cityAndGasState\n        FoldResult(newVisited, newAnswer)\n      }\n    }\n\n    @tailrec\n    def req(foldResult: FoldResult): FoldResult = {\n//      println(priorityQueue +\" \"+ foldResult)\n      if (priorityQueue.length == 0) foldResult else req(fold(foldResult, priorityQueue.dequeue()))\n    }\n    val result: FoldResult = req(FoldResult(Map[String, Int](), Map[(String, Int), Int]()))\n//    println(result)\n    result.answer.map(ans => ans._1._1 -> ans._2 ).getOrElse(to,-1)\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 2000) continue;\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 2000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[4000];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  memset(vis,0,sizeof(vis));  \n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    int t=getnum(s);\n    //if(t>4000)exit(0);\n    lpg[t]=1;\n  }\n\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nca=ca-co;\n      if(to>4000 || nca>4000)break;\n      if(vis[to][nca])continue;\n      q.push(mp(-cc-co,mp(nca,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while((cin>>n>>m>>cap)&&n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nvector<pair<int, int> > E[4010];\nbool LPF[4010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\trep(i, 0, 4000) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 4000) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d;\n  short cap;\n  string str;\n  Data(int d = 0,short c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2;\n  short cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    //for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    d[cap][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\n\tpair<string,string> p2 = p;\n\tif(m[p2] == 0){\n\t  swap(p2.first,p2.second);\n\t}\n\n\tv.cap -= m[p2];\n\tif(v.cap < 0) continue;\n\tif(m[p2] == 0) continue;\n\tif(p.second == src) continue;\n  \n\tif(d[v.cap][p.second] == 0) d[v.cap][p.second] = INF;\n\n\tif(sta.find(p.second) != sta.end()){\n\n\t  if(d[cap][p.second] == 0) d[cap][p.second] = INF;\n\n\t  if(d[u.cap][p.first] + m[p2] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p2];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p2] < d[v.cap][p.second]){\n\t  for(int i=0;i<=v.cap;i++){\n\t    d[i][p.second] = d[u.cap][p.first] + m[p2];\n\t  }\n\t  v.str = p.second;\n\t  v.d = d[v.cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) if(d[i][dest] != 0) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define mem(a , b ) memset(a , b , sizeof(a))\nusing namespace std ;\nconst int MAXN = 3006 ;\nconst int INF = 0x7fffffff ;\nstruct Edge\n{\n    int adj ;\n    int d ;\n    int next ;\n}E[MAXN * 2] ;\nint head[MAXN * 2] ;\nint ed ;\nstruct Q\n{\n    int Node ;\n    int C ;\n};\nint n , m , cap ;\nstring s1 , s2 ;\nint st , e ;\nmap<string , int> mp ;\nint cnt ;\nbool inq[MAXN * 2][2006] ;\nint dis[MAXN * 2][2006] ;\nbool P[MAXN * 2] ; // 判断城市是否有加油站\nchar ss1[100] , ss2[100] ;\nvoid chu()\n{\n    mp.clear() ;\n    cnt = 0 ;\n    ed = 0 ;\n    mem(head , 0) ;\n    mem(dis , 0) ;\n    mem(P , 0) ;\n    mem(inq , 0) ;\n}\nvoid init()\n{\n    chu() ;\n    scanf(\"%s%s\" , ss1 , ss2) ;\n    s1 = string(ss1) ;\n    s2 = string(ss2) ;\n    if(mp.find(s1) == mp.end())\n    {\n        mp[s1] = ++ cnt ;\n    }\n    if(mp.find(s2) == mp.end())\n    {\n        mp[s2] = ++ cnt ;\n    }\n    st = mp[s1] ;\n    e = mp[s2] ;\n    cap *= 10 ;\n    int i ;\n    int td ;\n    int ta , tb ;\n    for(i = 0 ; i < n ; i ++)\n    {\n        scanf(\"%s%s\" , ss1 , ss2) ;\n        s1 = string(ss1) ;\n        s2 = string(ss2) ;\n        scanf(\"%d\" , &td) ;\n        if(!mp[s1])\n        {\n            mp[s1] = ++ cnt ;\n        }\n        if(!mp[s2])\n        {\n            mp[s2] = ++ cnt ;\n        }\n        ta = mp[s1] ;\n        tb = mp[s2] ;\n        if(td <= cap)  // 建&#22270;\n        {\n            ++ ed ;\n            E[ed].adj = tb ;\n            E[ed].d = td ;\n            E[ed].next = head[ta] ;\n            head[ta] = ed ;\n\n            ++ ed ;\n            E[ed].adj = ta ;\n            E[ed].d = td ;\n            E[ed].next = head[tb] ;\n            head[tb] = ed ;\n        }\n    }\n    for(i = 0 ; i < m ; i ++)\n    {\n        scanf(\"%s\" , ss1) ;\n        s1 = string(ss1) ;\n        if(!mp[s1])\n        {\n            mp[s1] = ++ cnt ;\n        }\n        int t = mp[s1] ;\n        P[t] = true ;\n    }\n}\nqueue<Q> q ;\nvoid spfa(Q u)\n{\n    while (!q.empty()) q.pop() ;\n    q.push(u) ;\n    inq[u.Node][u.C] = true ;\n    while (!q.empty())\n    {\n        Q v = q.front() ;\n        q.pop() ;\n        inq[v.Node][v.C] = false ;\n        int i ;\n        i = head[v.Node] ;\n        while (i != 0)\n        {\n            Edge tv = E[i] ;\n            int vn = tv.adj ;\n            int vd = tv.d ;\n            int se = v.C - vd ;\n            if(P[vn]) // 注意此&#22788;\n            {\n                se = cap ;\n            }\n            if(v.C - vd >= 0 && dis[v.Node][v.C] + vd < dis[vn][se] )\n            {\n\n                dis[vn][se] = dis[v.Node][v.C] + vd  ;\n                if(!inq[vn][se])\n                {\n                    inq[vn][se] = true ;\n                    Q tmp ;\n                    tmp.Node = vn ;\n                    tmp.C = se ;\n                    q.push(tmp) ;\n                }\n            }\n            i = E[i].next ;\n        }\n    }\n}\nvoid solve()\n{\n    int i , j ;\n    for(i = 1 ; i <= cnt ; i ++)\n    {\n        for(j = 0 ; j <= cap ; j ++)\n            dis[i][j] = INF ;\n    }\n    dis[st][cap] = 0 ;\n    Q Stmp ;\n    Stmp.Node = st ;\n    Stmp.C = cap ;\n    spfa(Stmp) ;\n    int MIN = INF ;\n    for(i = 0 ; i <= cap ; i ++)\n    {\n        MIN = min(MIN , dis[e][i]) ;\n    }\n    if(MIN == INF)\n        puts(\"-1\") ;\n    else\n        printf(\"%d\\n\" , MIN) ;\n}\nint main()\n{\n    while (scanf(\"%d%d%d\" , &n , &m , &cap) != EOF)\n    {\n        if(n == 0 && m == 0 && cap == 0)\n            break ;\n        init() ;\n        solve() ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<int, int> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      int nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<int, int> >,vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<int, int> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      int pos = now.second.first;\n      int f = now.second.second;\n      if (f < 0) continue;\n      if (st.count(pos)) f = cap;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      rep (i, edge[pos].size()) que.push(make_pair(cost + edge[pos][i].second, make_pair(edge[pos][i].first, f - edge[pos][i].second)));\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\tdp[to][next_remaining_LPG] = true;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2005]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    vector<Node> nodes[6001];\n    map<string,int> cities;\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n\nint d[6010][310];\nbool done[6010][310];\nint N, M, C;\n\ntypedef struct _Edge{\n    int to, dist;\n    _Edge(int to, int dist): to(to), dist(dist){};\n}Edge;\n\ntypedef struct _Node{\n    int v, gas, d;\n    _Node(int v, int gas, int d): v(v), gas(gas), d(d){};\n    bool operator<(const _Node& n)const{return d>n.d;}\n}Node;\n\nint dijkstra(vector<vector<Edge>> &G, set<int> &gass, int src, int dst){\n    int N = G.size();\n    memset(d, 0x3f, sizeof(d));\n    memset(done, 0, sizeof(done));\n    \n    priority_queue<Node> que;\n    \n    d[src][C*10] = 0;\n    que.push(Node(src, C*10, 0));\n    \n    while(!que.empty()){\n        auto node = que.top(); que.pop();\n        if(node.v == dst)\n            return node.d;\n        \n        auto p = make_pair(node.v, node.gas);\n        \n        if(done[p.first][p.second])\n            continue;\n        done[p.first][p.second] = true;\n             \n        for(auto e: G[node.v]){\n            if(node.gas < e.dist)\n                continue;\n            \n            pair<int, int> np;\n            np.first = e.to;\n            if(gass.find(e.to) != gass.end())\n                np.second = C*10;\n            else\n                np.second = node.gas - e.dist;\n            \n            if(d[p.first][p.second] + e.dist < d[np.first][np.second]){\n                d[np.first][np.second] = d[p.first][p.second] + e.dist;\n                que.push(Node(np.first, np.second, d[np.first][np.second]));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    string src, dst;\n    cin >> src >> dst;\n    \n    map<string, int> stoi;\n    vector<string> cs(N), cd(N);\n    vector<int> ds(N);\n    for(int i=0; i<N; i++){\n        cin >> cs[i] >> cd[i] >> ds[i];\n        \n        if(stoi.find(cs[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cs[i]] = x;\n        }\n        if(stoi.find(cd[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cd[i]] = x;\n        }\n    }\n    \n    set<int> gass;\n    for(int i=0; i<M; i++){\n        string s; cin >> s;\n        gass.insert(stoi[s]);\n    }\n    \n    vector<vector<Edge>> G(stoi.size());\n    for(int i=0; i<N; i++){\n        int si = stoi[cs[i]];\n        int di = stoi[cd[i]];\n        \n        G[si].emplace_back(di, ds[i]);\n        G[di].emplace_back(si, ds[i]);\n    }\n    \n    cout << dijkstra(G, gass, stoi[src], stoi[dst]) << endl;\n}\n\nint main(){\n    while(cin >> N >> M >> C, N|M|C)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    vector<string> node;\n    scanf(\"%s%s\",s,t);\n    node.push_back(s);\n    node.push_back(t);\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    int sz = node.size();\n    g.resize(sz,vector<edge>());\n    cost.resize(sz,vector<int>(cap*10+1));\n    sta.resize(sz);\n    for( int i = 0; i < sz; i++ ) {\n      sta[i] = false;\n      for( int j = 0; j <= cap*10; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n      if(nc<0)continue;\n      if(d[v][p.s.s]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\nusing namespace std;\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nbool sta[5001];\nint dis[5001][5001],dp[5001][2001];\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++)dis[i][j]=inf;\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      dis[M[a]][M[b]]=c;dis[M[b]][M[a]]=c;\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.n][u.a]<u.dis)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tcontinue;\n      }\n\n      for(int i=0;i<n;i++){\n\tif(dis[u.n][i]==inf)continue;\n\tif(sta[u.n]){\n\t  if(dis[u.n][i]<cap){\n\t    int sum1=u.dis+dis[u.n][i],sum2=cap-dis[u.n][i];\n\t    if(sum1<dp[i][sum2]){\n\t      dp[i][sum2]=sum1;\n\t      pq.push(State(i,sum2,sum1));\n\t    }\n\t  }\n\t}\n\telse {\n\t  if(dis[u.n][i]<u.a){\n\t    int sum1=u.dis+dis[u.n][i],sum2=u.a-dis[u.n][i];\n\t    if(sum1<dp[i][sum2]){\n\t      dp[i][sum2]=sum1;\n\t      pq.push(State(i,sum2,sum1));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n  \tvis[v][p.s.s]=true;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(p.s.s-e.cost>=0){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    //node.erase(unique(all(node)),node.end());\n  \tunique(all(node));\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n\nint N, M, Cap;\nint nCount;\nmap<string, int> myMap;\nstring sC, dC;\n\nconst int maxn = 6010;\nconst int maxm = 10010;\nconst int inf  = 0x3f3f3f3f;\n\nstruct Edge {\n    int u, v, w, next;\n    Edge() {}\n    Edge(int t_u, int t_v, int t_w, int t_next) : u(t_u), v(t_v), w(t_w), next(t_next) {}\n}edges[maxm];\n\nstruct Node {\n    int u, l;\n    Node() {}\n    Node(int t_u, int t_l) : u(t_u), l(t_l) {}\n};\n\nint head[maxn], edge_sum;\n\nvoid init_graph() {\n    edge_sum = 0;\n    memset(head, -1, sizeof(head));\n}\n\nvoid addEdge(int u, int v, int w) {\n    edges[edge_sum].u = u;\n    edges[edge_sum].v = v;\n    edges[edge_sum].w = w;\n    edges[edge_sum].next = head[u];\n    head[u] = edge_sum++;\n}\n\nbool visit[maxn];\nint  dis[maxn];\nbool mark[maxn];\nint  cap[maxn];\n\nint SPFA(int s, int t) {\n\n    Node now, next;\n    memset(visit, false, sizeof(visit));\n    memset(dis, inf, sizeof(dis));\n    memset(cap, 0, sizeof(cap));\n    queue<Node> Q;\n    dis[s] = 0; visit[s] = true;\n    Q.push(Node(s, Cap*10)); cap[s] = Cap * 10;\n    while(!Q.empty()) {\n        now = Q.front(); Q.pop(); visit[now.u] = false;\n        for(int i = head[now.u]; i != -1; i = edges[i].next) {\n            if(edges[i].w > cap[now.u]) {\n                continue;\n            }\n            int v = edges[i].v;\n            if(dis[v] > dis[now.u] + edges[i].w) {\n                dis[v] = dis[now.u] + edges[i].w;\n                if(!visit[v]) {\n                    visit[v] = true;\n                    next.u = v;\n                    next.l = mark[v] ? (Cap*10) : (cap[now.u] - edges[i].w);\n                    cap[v] = next.l;\n                    Q.push(next);\n                }\n            }\n            if(dis[v] == dis[now.u] + edges[i].w) {\n                cap[v] = max(cap[v], cap[now.u] - edges[i].w);\n            }\n        }\n    }\n    return dis[t];\n}\n\nint main() {\n\n    //freopen(\"aa.in\", \"r\", stdin);\n\n    string a, b; int w;\n    while(scanf(\"%d %d %d\", &N, &M, &Cap) != EOF) {\n        if(N == 0 && M == 0 && Cap == 0) break;\n        cin >> sC >> dC;\n        nCount = 0; myMap.clear();\n        init_graph();\n        for(int i = 1; i <= N; ++i) {\n            cin >> a >> b >> w;\n            if(myMap.count(a) == 0) {\n                myMap[a] = ++nCount;\n            }\n            if(myMap.count(b) == 0) {\n                myMap[b] = ++nCount;\n            }\n            addEdge(myMap[a], myMap[b], w);\n            addEdge(myMap[b], myMap[a], w);\n        }\n        memset(mark, false, sizeof(mark));\n        for(int i = 1; i <= M; ++i) {\n            cin >> a;\n            mark[myMap[a]] = true;\n        }\n        int ans = SPFA(myMap[sC], myMap[dC]);\n        if(ans == inf) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\ntemplate<class T>\nostream &operator<<(ostream &os,const vector<T> &v){\n\tfor(int i = 0;i < v.size();i++) os << (i ? \",\" : \"[\") << v[i];\n\tos << \"]\";\n\treturn os;\n}\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=998244353;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nostream &operator<<(ostream &os,const Edge<T> &p){ return os << \"(\" << p.to << \",\" << p.cost << \")\"; }\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvector<T> dijkstra(const WeightedGraph<T> &G,int source = 0){\n\tusing P = pair<T,int>;\n\tvector<T> dist(G.size(),INF);\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tdist[source] = 0;\n\tque.emplace(dist[source],source);\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first) continue;\n\t\tfor(const auto &e : G[v]){\n\t\t\tif(dist[e.to] > dist[v] + e.cost){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint n,m;\n\nvoid solve(){\n\tint cap,v = 0,c1[3010],c2[3010],d[3010];\n\tstring s,t;\n\tmap<string,int> mp;\n\tvector<int> lpg = {0,1};\n\tcin >> cap >> s >> t;\n\tmp[s] = v++; mp[t] = v++;\n\tfor(int i = 0;i < n;i++){\n\t\tstring sc1,sc2;\n\t\tcin >> sc1 >> sc2 >> d[i];\n\t\tif(!mp.count(sc1)) mp[sc1] = v++;\n\t\tif(!mp.count(sc2)) mp[sc2] = v++;\n\t\tc1[i] = mp[sc1];\n\t\tc2[i] = mp[sc2];\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif(ss != s && ss != t) lpg.push_back(mp[ss]);\n\t}\n\tWeightedGraph<int> G(mp.size()),lG(lpg.size());\n\tfor(int i = 0;i < n;i++){\n\t\tG[c1[i]].emplace_back(c2[i],d[i]);\n\t\tG[c2[i]].emplace_back(c1[i],d[i]);\n\t}\n\tfor(int i = 0;i < lpg.size();i++){\n\t\tauto dist = dijkstra(G,lpg[i]);\n\t\tfor(int j = i + 1;j < lpg.size();j++){\n\t\t\tif(dist[lpg[j]] <= cap * 10){\n\t\t\t\tlG[i].emplace_back(j,dist[lpg[j]]);\n\t\t\t\tlG[j].emplace_back(i,dist[lpg[j]]);\n\t\t\t}\n\t\t}\n\t}\n\tauto dist = dijkstra(lG,0);\n\tif(dist[1] == INF) cout << -1 << endl;\n\telse cout << dist[1] << endl;\n}\n\nsigned main(){\n\twhile(cin >> n >> m,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1<<30\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1[3100],c2[3100];\nint d[3100];\nstring s[310];\nbool gas[6100];\nint num;\nvector<P> G[6100];\nint dis[6100][2100];\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    cap *= 10;\n    map<string,int> id;\n    num = 0;\n    id[src] = num++; id[dest] = num++;\n    for(int i=0;i<n;i++){\n      cin >> c1[i] >> c2[i] >> d[i];\n      if(id.find(c1[i]) == id.end())id[c1[i]] = num++;\n      if(id.find(c2[i]) == id.end())id[c2[i]] = num++;\n    }\n\n    for(int i=0;i<num;i++)G[i].clear();\n\n    for(int i=0;i<n;i++){\n      G[id[c1[i]]].push_back(P(d[i],id[c2[i]]));\n      G[id[c2[i]]].push_back(P(d[i],id[c1[i]]));\n    }\n\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s[i];\n      gas[id[s[i]]] = true;\n    }\n\n    for(int i=0;i<num;i++){\n      for(int j=0;j<=cap;j++)dis[i][j] = INF;\n    }\n\n    dis[id[src]][cap] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      int dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      if(pos == id[dest])break;\n\n      for(int i=0;i<G[pos].size();i++){\n\tint len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\n\tif(len > tank)continue;\n\tint ntank = tank - len;\n\tif(gas[nxt])ntank = cap;\n\n\tif(dis[nxt][ntank] > dist + len){\n\t  dis[nxt][ntank] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++)ans = min(ans,dis[id[dest]][i]);\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\ntypedef long long ll;\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\n\nstruct Task{\n    int prev,pos;Cost c;\n    Task(int prev,int pos,Cost c)\n        :prev(prev),pos(pos),c(c){};\n    bool operator>(const Task& r) const{ return c > r.c;}\n};\n\nvector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n    const int V=g.size();\n    vector<Cost> d(V,CINF);d[s]=0;\n    fill(ALL(prev), -2);\n    \n    priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));// [ ,e,,f, ] <=> e.cost < e.cost\n    vector<bool> visited(V);\n    while(!que.empty()){\n        Task task=que.top();que.pop();\n        if(visited[task.pos])continue;\n        visited[task.pos]=true;\n        prev[task.pos]=task.prev;\n        EACH(e,g[task.pos])if(d[e->t]>d[e->f]+e->c){\n            d[e->t]=d[e->f]+e->c;\n            que.push(Task(e->f,e->t,d[e->t]));\n        }   \n    }\n    return d;\n}\nvector<Cost> dijkstra(const Graph& g,const int s){\n    vector<int> prev(g.size());return dijkstra(g,s,prev);\n}\n\n\nint main() {\n\tcout <<fixed<<setprecision(15);\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tint N,M,cap;cin >> N >> M >> cap;if(N==0)break;\n\t\t\n\t\tmap<string,int> m;int S=0;\n\t\tint s;\n\t\t{\n\t\t\tstring src;cin >> src;\n\t\t\tif(!m.count(src))m[src]=s=S++;\n\t\t}\n\t\tint t;\n\t\t{\n\t\t\tstring dist;cin >> dist;\n\t\t\tif(!m.count(dist))m[dist]=t=S++;\t\t\t\n\t\t}\n\t\tvector<tuple<int,int,int>> es;\n\t\tREP(i,N){\n\t\t\tstring f,t;int c;cin >> f >> t >> c;\n\t\t\tif(!m.count(f))m[f]=S++;\n\t\t\tif(!m.count(t))m[t]=S++;\n\t\t\tes.emplace_back(m[f],m[t],c);\n\t\t}\n\t\tvector<int> ss;\n\t\tREP(i,M){\n\t\t\tstring s;cin >>s;\n\t\t\tif(!m.count(s))m[s]=S++;\n\t\t\tss.push_back(m[s]);\n\t\t}\n\t\tmap<int,int> stoi;int I=0;\n\t\tif(!stoi.count(s))stoi[s]=I++;\n\t\tif(!stoi.count(t))stoi[t]=I++;\n\t\tREP(i,M)if(!stoi.count(ss[i])){\n\t\t\tstoi[ss[i]]=I++;\n\t\t}\n\t\tmap<int,int> itoS;EACH(it,stoi)itoS[it->second]=it->first;\n\n\t\tGraph g(S);\n\t\tREP(i,N){\n\t\t\t// cerr << es[i] <<endl;\n\t\t\tg[get<0>(es[i])].emplace_back(get<0>(es[i]),get<1>(es[i]),get<2>(es[i]));\n\t\t\tg[get<1>(es[i])].emplace_back(get<1>(es[i]),get<0>(es[i]),get<2>(es[i]));\n\t\t}\n\t\tGraph gc(I);\n\t\tREP(i,I){\n\t\t\tvector<Cost> cs=dijkstra(g,itoS[i]);\n\t\t\tREP(j,S)if(stoi.count(j)){\n\t\t\t\tint ji=stoi[j];\n\t\t\t\tif(cs[j]<=10*cap)gc[i].emplace_back(i,ji,cs[j]);\n\t\t\t}\n\t\t}\n\t\tvector<Cost> cs=dijkstra(gc,s);\n\n\t\tif(cs[t]>=CINF) cout << -1<<endl;\n\t\telse cout << cs[t]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      int idx=(st.count(next)?cap*10:now.c-c);\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[next][idx]);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 7000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[N];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    for (int i = 0; i < N; ++i) adj[i].clear(), adj2[i].clear();\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    set<int> good = {mp[src], mp[dest]};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      if (mp.count(s) == 0) continue;\n      good.insert(mp[s]);\n    }\n\n    vector<int> sources(good.begin(), good.end());\n    for (int source : sources) {\n      good.erase(source);\n      queue<pair<int, int>> q;\n      q.push({source, cap});\n      while (!q.empty()) {\n        int now = q.front().first, now_cap = q.front().second;\n        q.pop();\n        if (good.count(now)) {\n          adj2[source].emplace_back(now, cap - now_cap);\n          adj2[now].emplace_back(source, cap - now_cap);\n          continue;\n        }\n        for (auto& p : adj[now]) {\n          int child = p.first, d = p.second;\n          if (now_cap - d >= 0) q.push({child, now_cap - d});\n        }\n      }\n    }\n\n    int s = mp[src], t = mp[dest];\n    vector<bool> visit(mp.size(), false);\n    vector<int> dist(mp.size(), INT_MAX);\n    dist[s] = 0;\n    MinHeap<pair<int, int>> hp;\n    hp.push({0, s});\n    while (1) {\n      int now = -1;\n      while (!hp.empty() and visit[now = hp.top().second]) hp.pop();\n      if (now == -1 or visit[now]) break;\n      visit[now] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, d = p.second;\n        if (dist[child] > dist[now] + d) {\n          dist[child] = dist[now] + d;\n          hp.push({dist[child], child});\n        }\n      }\n    }\n\n    cout << (dist[t] == INT_MAX ? -1 : dist[t]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    //node.erase(unique(all(node)),node.end());\n  \tunique(all(node));\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\ntypedef int weight;\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int t, weight c):to(t), cost(c){}\n};\ntypedef pair<weight, int> P;\nconstexpr int INF = 0xfffffff;\n\nvector<int> dijkstra(int s, int cap, const vector<vector<edge>>& es) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INF);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst P p = que.top();\n\t\tque.pop();\n\t\tconst int v = p.second;\n\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < (int)es[v].size(); ++i) {\n\t\t\tconst edge& e = es[v][i];\n\t\t\tconst weight next_dist = dist[v] + e.cost;\n\t\t\tif(next_dist >= cap * 10) continue;\n\n\t\t\tif(dist[e.to] > next_dist) {\n\t\t\t\tdist[e.to] = next_dist;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nunordered_map<string, int> en;\ninline int encode(const string& s) {\n\tif(!en.count(s)) en.insert(make_pair(s, en.size()));\n\treturn en[s];\n}\n\ninline int input_city() {\n\tstring s;\n\tcin >> s;\n\treturn encode(s);\n}\n\ninline int calc_nearest_city(const vector<int>& LPG, const vector<int>& dist) {\n\tint idx = LPG[0];\n\tfor(int i = 1; i < (int)LPG.size(); ++i) {\n\t\tif(dist[idx] > dist[LPG[i]]) idx = LPG[i];\n\t}\n\treturn idx;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, cap; cin >> n >> m >> cap && n;) {\n\t\ten.clear();\n\t\tconst int s = input_city();\n\t\tconst int t = input_city();\n\n\t\tvector<tuple<int, int, int>> edges;\n\t\tedges.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int a = input_city();\n\t\t\tconst int b = input_city();\n\t\t\tint cost;\n\t\t\tcin >> cost;\n\t\t\tedges.emplace_back(a, b, cost);\n\t\t}\n\n\t\tvector<int> LPG(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tLPG[i] = input_city();\n\t\t}\n\n\t\tconst int number_of_city = static_cast<int>(en.size());\n\t\tvector<vector<edge>> es(number_of_city);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b, cost;\n\t\t\ttie(a, b, cost) = edges[i];\n\t\t\tes[a].emplace_back(b, cost);\n\t\t\tes[b].emplace_back(a, cost);\n\t\t}\n\n\t\tvector<int> dist = dijkstra(s, cap, es);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tconst int next = calc_nearest_city(LPG, dist);\n\t\t\tLPG.erase(remove(LPG.begin(), LPG.end(), next), LPG.end());\n\t\t\tvector<int> tmp = dijkstra(next, cap, es);\n\t\t\tfor(int i = 0; i < number_of_city; ++i) {\n\t\t\t\tchmin(dist[i], dist[next] + tmp[i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[t] == INF ? -1 : dist[t]) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1LL<<60\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1[3100],c2[3100];\nint d[3100];\nstring s[310];\nbool gas[10000];\nint num;\nvector<P> G[10000];\nlong long dis[10000][2100];\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    cap *= 10;\n    map<string,int> id;\n    num = 0;\n    id[src] = num++; id[dest] = num++;\n    for(int i=0;i<n;i++){\n      cin >> c1[i] >> c2[i] >> d[i];\n      if(id.find(c1[i]) == id.end())id[c1[i]] = num++;\n      if(id.find(c2[i]) == id.end())id[c2[i]] = num++;\n    }\n\n    for(int i=0;i<num;i++)G[i].clear();\n\n    for(int i=0;i<n;i++){\n      G[id[c1[i]]].push_back(P(d[i],id[c2[i]]));\n      G[id[c2[i]]].push_back(P(d[i],id[c1[i]]));\n    }\n\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s[i];\n      gas[id[s[i]]] = true;\n    }\n\n    for(int i=0;i<num;i++){\n      for(int j=0;j<=cap;j++)dis[i][j] = INF;\n    }\n\n    dis[id[src]][cap] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      long long dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      if(pos == id[dest])break;\n\n      for(int i=0;i<G[pos].size();i++){\n\tlong long len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\n\tif(len > tank)continue;\n\tint ntank = tank - len;\n\tif(gas[nxt])ntank = cap;\n\n\tif(dis[nxt][ntank] > dist + len){\n\t  dis[nxt][ntank] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    long long ans = INF;\n    for(int i=0;i<=cap;i++)ans = min(ans,dis[id[dest]][i]);\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][cap*10]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n};\n\nstruct aa {\n\tint now;\n\tint fuel;\n\tint cost;\n};\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint main() {\n\t\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif (!N)break;\n\t\tcap *= 10;\n\t\tstring st, fi; cin >> st >> fi;\n\t\tmap<string, int>mp;\n\t\tmp[st] = 0;\n\t\tmp[fi] = 1;\n\t\tint num = 2;\n\t\tvector<vector<edge>>edges(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (mp.count(a)) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp.emplace(a, num);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tif (mp.count(b)) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp.emplace(b, num);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint co; cin >> co;\n\t\t\tedges[mp[a]].push_back(edge{ mp[a],mp[b],co });\n\t\t\tedges[mp[b]].push_back(edge{ mp[b],mp[a],co });\n\t\t}\n\t\tvector<bool>stands(mp.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\n\t\t\t\tstands[mp[st]] = true;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,cap,0 });\n\t\tvector<vector<int>>memo(mp.size(), vector<int>(cap + 1,99999999));\n\t\tmemo[0][cap] = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tif (atop.now == 1)break;\n\t\t\tque.pop();\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (atop.fuel >= i.cost) {\n\t\t\t\t\tif (memo[i.to][atop.fuel - i.cost]>atop.cost + i.cost) {\n\t\t\t\t\t\tif (stands[i.to]) {\n\t\t\t\t\t\t\tque.push({ i.to,cap,atop.cost + i.cost });\n\t\t\t\t\t\t\tmemo[i.to][cap] = atop.cost + i.cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tque.push({ i.to,atop.fuel - i.cost,atop.cost + i.cost });\n\t\t\t\t\t\t\tmemo[i.to][atop.fuel - i.cost] = atop.cost + i.cost;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amin = 99999999;\n\t\tfor (int i = 0; i <= cap; ++i) {\n\t\t\tamin = min(amin, memo[1][i]);\n\t\t}\n\t\tif (amin == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << amin << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std ;\n\n#define lson l , m , rt<<1\n#define rson m+1 , r , rt<<1|1\n#define lowbit(x)  (x&(-x))\n#define pb push_back\n\ntemplate<typename T> T Max( T a , T b ) { return a > b ? a : b ; }\ntemplate<typename T> T Min( T a , T b ) { return a < b ? a : b ; }\ntemplate<typename T> T Abs( T A ) { return A > 0 ? A : -1*A ; }\ntemplate<typename T>void Swap( T &a , T &b) { T tmp = a ; a=b ; b = tmp ; }\n\ntypedef pair<int , int> pii ;\ntypedef long long llong ;\n\nconst llong LINF = 0x3FFFFFFFFFFFFFFLL ;\nconst int INF = 0X3FFFFFFF ;\nconst int MAXN = 3105 ;\nconst int msize = 315 ;\nstruct Node\n{\n    char names[20] ;\n    bool operator < (const Node& b )const\n    {\n        return strcmp( names , b.names) < 0 ;\n    }\n} LPG[msize];\nmap<Node , int> mp ;\n\nstruct Edge\n{\n    int v , next ;\n    int val ;\n} edge[MAXN*10] ;\nint head[MAXN] ;\nint ind ;\n\n\nint d[msize][MAXN] ;\nbool vis[MAXN] ;\n\nint g[msize][msize] ;\n\nvoid init()\n{\n    ind = 0 ;\n    memset( head , -1 , sizeof(head) ) ;\n}\n\nvoid addedge( int u , int v , int val )\n{\n    edge[ind].v = v ;\n    edge[ind].val = val ;\n    edge[ind].next = head[u] ;\n    head[u] = ind++ ;\n}\n\nvoid spfa( int s , int n  , int dis[] )\n{\n    for ( int i = 0 ;  i <= n; i++ )\n    {\n        dis[i] = INF ;\n        vis[i] = false ;\n    }\n    queue<int> Q ;\n\n    Q.push(s) ;\n    dis[s] = 0 ;\n    while ( !Q.empty() )\n    {\n        int u = Q.front() ;\n        Q.pop() ;\n        vis[u] = false ;\n        for ( int i = head[u] ; i != -1 ; i = edge[i].next )\n        {\n            int v = edge[i].v ;\n            if ( dis[u] + edge[i].val < dis[v] )\n            {\n                dis[v] = dis[u] + edge[i].val ;\n                if ( !vis[v] )\n                {\n                    vis[v] = true ;\n                    Q.push(v) ;\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n ,m , cap ;\n    while ( ~scanf(\"%d%d%d\" , &n , &m, &cap) )\n    {\n        if ( n == 0 && m == 0 && cap == 0 ) break ;\n\n        mp.clear() ;\n        init() ;\n        int src , dest , val , id = 0 , u  , v ;\n        Node s1 , s2 ;\n\n        scanf(\"%s%s\" , LPG[0].names , LPG[m+1].names) ;\n        if ( !mp[ LPG[0] ] ) mp[LPG[0]] = ++id ;\n        if ( !mp[ LPG[m+1] ] ) mp[LPG[m+1]] = ++id ;\n        src = mp[LPG[0]] , dest = mp[LPG[m+1]] ;\n\n        for ( int i = 1;  i <= n; i++ )\n        {\n            scanf(\"%s%s%d\" , s1.names , s2.names , &val ) ;\n            if ( !mp[ s1 ] ) mp[s1] = ++id ;\n            if ( !mp[ s2 ] ) mp[s2] = ++id ;\n\n            u = mp[s1] , v = mp[s2] ;\n            addedge( u , v , val ) ;\n            addedge( v , u , val ) ;\n        }\n\n        int l_id = 0 ;\n        for ( int i = 1 ; i <= m ; i++ )\n        {\n            scanf(\"%s\", LPG[i].names ) ;\n            if ( !mp[ LPG[i] ] )\n                mp[LPG[i]] = ++id ;\n\n            spfa( mp[LPG[i]] , id , d[i] ) ;\n        }\n        spfa( src , id , d[0] ) ;\n        spfa( dest, id , d[m+1] ) ;\n\n        int M = m+1 ;\n        for ( int i = 0; i <= M; i++ )\n        {\n            for ( int j = i+1 ; j <= M ; j++ )\n            {\n                int v = mp[LPG[j]] ;\n                if ( d[i][ v ] <= cap*10 )\n                if ( d[i][ v ] <= cap*10 )\n                    g[i][j] = g[j][i] = d[i][ v ] ;\n                else g[i][j] = g[j][i] = INF ;\n            }\n            g[i][i] = 0 ;\n        }\n\n        for ( int k = 0 ; k <= M; k++ )\n        for ( int i = 0 ; i <= M ; i++ )\n        {\n            if ( i == k ) continue ;\n            for ( int j = 0 ; j <= M ; j++ )\n            {\n                if ( j == i || j == k ) continue ;\n                if ( g[i][j] > g[i][k] + g[k][j] && ( g[i][k] != INF && g[k][j] != INF ) )\n                    g[i][j] = g[i][k] + g[k][j] ;\n            }\n        }\n\n        if ( g[0][M] >= INF )\n            g[0][M] = -1 ;\n        printf(\"%d\\n\" , g[0][M] ) ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 1000000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<V;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nstruct Edge {\n  int dst, dist;\n  Edge(int dst, int dist): dst(dst), dist(dist) {}\n};\n\nstruct State {\n  int city, rest, cost;\n  State(int city, int rest, int cost): city(city), rest(rest), cost(cost) {}\n  bool operator<(const State& rhs) const { return cost > rhs.cost; }\n};\n\ninline int add_name(map<string, int>& name2id, const string& name) {\n  if (name2id.count(name)) {\n    return name2id[name];\n  } else {\n    int id = name2id.size();\n    return name2id[name] = id;\n  }\n}\n\nconst int INF = 0x0f0f0f0f;\n\nvector<Edge> edges[6010];\nbool has_lpg[6010];\nbool visit[6010][2010];\nint cost[6010][2010];\n\nint main() {\n  int N, M, cap;\n  while (scanf(\"%d%d%d\", &N, &M, &cap), N|M|cap) {\n    map<string, int> name2id;\n    string src_name, dst_name;\n\n    memset(has_lpg, false, sizeof(has_lpg));\n    memset(visit, false, sizeof(visit));\n    memset(cost, INF, sizeof(cost));\n\n    cin >> src_name >> dst_name;\n    int src = add_name(name2id, src_name);\n    int dst = add_name(name2id, dst_name);\n    REP(i, N) {\n      int dist;\n      cin >> src_name >> dst_name >> dist;\n      int s = add_name(name2id, src_name);\n      int t = add_name(name2id, dst_name);\n      edges[s].push_back(Edge(t, dist));\n      edges[t].push_back(Edge(s, dist));\n    }\n    REP(i, M) {\n      cin >> src_name;\n      has_lpg[name2id[src_name]] = true;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(src, 10 * cap, 0));\n    cost[src][10 * cap] = 0;\n    while (!Q.empty()) {\n      int city = Q.top().city;\n      int rest = Q.top().rest;\n      Q.pop();\n\n      if (visit[city][rest]) { continue; }\n      visit[city][rest] = true;\n\n      FOREACH(it, edges[city]) {\n        int new_city = it->dst;\n        if (rest < it->dist) { continue; }\n        int new_rest = has_lpg[new_city] ? 10 * cap : rest - it->dist;\n        int new_cost = cost[city][rest] + it->dist;\n        if (new_cost >= cost[new_city][new_rest]) { continue; }\n        cost[new_city][new_rest] = new_cost;\n        Q.push(State(new_city, new_rest, new_cost));\n      }\n    }\n\n    int ans = *min_element(cost[dst], cost[dst] + 10 * cap);\n    cout << (ans < INF ? ans : -1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int INF=1000000000;\n\nstruct edge\n{\n    int w,u,v,res,dis;\n    bool operator <(edge q)const\n    {\n     return v>q.v;\n    }\n};\n\nmap <string,int> stoi;\nvector <edge> mp[3001];\nbool lca[3001];\nint dis[3001],res[1001],\n\nindex,cap;\n\nvoid dijkstra(int srt)\n{\n    int i,u,v,w;\n    edge now;\n    for(i=0;i<index;i++){dis[i]=INF;res[i]=0;}\n    priority_queue<edge> q;\n    dis[srt]=0;res[i]=cap*10;\n    for(i=0;i<mp[srt].size();i++)\n        {\n            mp[srt][i].res=cap*10;\n            mp[srt][i].dis=0;\n            q.push(mp[srt][i]);\n        }\n    while(!q.empty())\n    {\n       now=q.top();\n       q.pop();\n       u=now.u;\n       v=now.v;\n       w=now.w;\n       //cout <<u<<\" \"<<v<<\" \"<<w<<\" \"<<now.dis<<\" \"<<now.res<<endl;\n       //cout <<dis[v]<<\" \"<<res[v]<<endl;\n       //system(\"pause\");\n       if(now.res-w<=res[v]&&now.dis+w>=dis[v])continue;\n       if(now.res-w<0)continue;\n       now.res-=w;\n       now.dis+=w;\n       if(now.dis<dis[v]){dis[v]=now.dis;res[v]=now.w;}\n       if(lca[v])now.res=cap*10;\n       for(i=0;i<mp[v].size();i++)\n       {\n         mp[v][i].res=now.res;\n         mp[v][i].dis=now.dis;\n         q.push(mp[v][i]);\n       }\n    }\n}\n\nint main()\n{\n    int n,m,w,i;\n    edge ined;\n    string srt,st,ed,dest;\n    while(scanf(\"%d %d %d\",&n,&m,&cap)!=EOF&&(n!=0||m!=0||cap!=0))\n    {\n        index=0;\n        stoi.clear();\n        for(i=0;i<n;i++)mp[i].clear();\n        memset(lca,0,sizeof(lca));\n        index=0;\n        cin >>srt>>dest;\n        if(stoi.find(srt)==stoi.end())stoi[srt]=index++;\n        if(stoi.find(dest)==stoi.end())stoi[dest]=index++;\n        for(i=0;i<n;i++)\n        {\n            cin >>st >>ed >>w;\n            if(stoi.find(st)==stoi.end())stoi[st]=index++;\n            if(stoi.find(ed)==stoi.end())stoi[ed]=index++;\n            ined.u=stoi[st];\n            ined.v=stoi[ed];\n            ined.w=w;\n            mp[stoi[st]].push_back(ined);\n            swap(ined.u,ined.v);\n            //cout <<ined.u<<\" \"<<ined.v<<endl;\n            mp[stoi[ed]].push_back(ined);\n        }\n        for(i=0;i<m;i++)\n        {\n            cin >>st;\n            lca[stoi[st]]=true;\n        }\n        dijkstra(stoi[srt]);\n        if(dis[stoi[dest]]!=INF)printf(\"%d\\n\",dis[stoi[dest]]);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n \n \nclass DP{\npublic:\n\tint cost, gas, state;\n\t \n\tDP(){}\n\tDP(int st, int g, int cc){\n\t\tcost = cc;state=st;gas=g;\n\t}\n\t \n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n \nstruct edge{\n\tint to;\n\tint dist;\n};\n \nint N, M, C;\n\nbool visit[6000][2001];\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E(N*2);\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)) idx[from] = idx.size() - 1;\n\t\t\tif(!idx.count(to)) idx[to] = idx.size() - 1;\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tif(!idx.count(sta)) idx[sta] = idx.size() - 1;\n\t\t\tstations.insert(idx[sta]);\n\t\t}\n\t\tif(!idx.count(ss)) idx[ss] = idx.size() - 1;\n\t\tif(!idx.count(gg)) idx[gg] = idx.size() - 1;\n\t\ts = idx[ss];g = idx[gg];\n\t\t\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(s, C*10, 0));\n\t\tREP(i, N*2) REP(j, C*10+1) visit[i][j] = false;\n\t\tvisit[s][C*10] = true;\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.state == g) break;\n\t\t\tFOR(it, E[S.state]){\n\t\t\t\tif(S.gas < it->dist) continue;\n\t\t\t\tDP T=S;\n\t\t\t\tT.state = it->to;\n\t\t\t\tif(stations.count(it->to)) T.gas = C*10;\n\t\t\t\telse T.gas -= it->dist;\n\t\t\t\tT.cost += it->dist;\n\t\t\t\tif(!visit[it->to][T.gas]){\n\t\t\t\t\tdp.push(T);\n\t\t\t\t\tvisit[it->to][T.gas] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((S.state == g) ? S.cost : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\nint dist[6010][2010];\nbool done[6010][2010];\nvector<pair<int, int> > E[6010];\nset<int> gas;\n\nstring a, b, s;\n\nvoid init()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tcin >> a >> b;\n\tm[a] = 0; m[b] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\trep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n}\n\nint solve()\n{\n\tinit();\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\nvector<string> ash;\nint x,n,m,cap,inf=1e8,gas[302],dgas[302][302],d[6000];\nstring cst[3000][2];\nstruct edge{int to,cost;};\nvector<edge> G[6000];\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,x) d[i]=inf;\n\td[s]=0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc;\n\t\tif(d[v]<p.fs) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> m >> cap;\n\t\tif(n==0) break;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tash.clear();\n\t\trep(i,n){\n\t\t\tcin >> cst[i][0] >> cst[i][1] >> d[i];\n\t\t\tash.push_back(cst[i][0]);\n\t\t\tash.push_back(cst[i][1]);\n\t\t}\n\t\tsort(ash.begin(),ash.end());\n\t\tash.erase(unique(ash.begin(),ash.end()),ash.end());\n\t\tx=ash.size();\n//\t\trep(i,x) cout << i << \" = \" << ash[i] << endl;\n//\t\tcout << endl;\n\t\trep(i,x) G[i].clear();\n\t\trep(i,n){\n\t\t\tint c0=lower_bound(ash.begin(),ash.end(),cst[i][0])-ash.begin();\n\t\t\tint c1=lower_bound(ash.begin(),ash.end(),cst[i][1])-ash.begin();\n\t\t\tG[c0].push_back({c1,d[i]});\n\t\t\tG[c1].push_back({c0,d[i]});\n\t\t}\n\t\trep(i,m){\n\t\t\tstring sst;\n\t\t\tcin >> sst;\n\t\t\tgas[i]=lower_bound(ash.begin(),ash.end(),sst)-ash.begin();\n\t\t}\n\t\tgas[m]=lower_bound(ash.begin(),ash.end(),src)-ash.begin();\n\t\tgas[m+1]=lower_bound(ash.begin(),ash.end(),dest)-ash.begin();\n//\t\trep(i,m+2) cout << \"gas[i] = \" << ash[gas[i]] << endl;\n\t\trep(i,m+2){\n\t\t\tdijkstra(gas[i]);\n\t\t\trep(j,m+2){\n\t\t\t\tif(d[gas[j]]<=cap*10) dgas[i][j]=d[gas[j]];\n\t\t\t\telse dgas[i][j]=inf;\n\t\t\t}\n\t\t}\n/*\t\trep(i,m+2){\n\t\t\trep(j,m+2) cout << dgas[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(i,m+2) rep(j,m+2) rep(k,m+2) dgas[j][k]=min(dgas[j][k],dgas[j][i]+dgas[i][k]);\n\t\tif(dgas[m][m+1]==inf) dgas[m][m+1]=-1;\n\t\tcout << dgas[m][m+1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nvector<string>v,from,to;\nvector<int>cost;\nmap<string,int>id;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[3001][2001];\nvector<pii> conn[3001];\nbool station[3001];\n\nstruct node {\n\tint p, cost, gas;\n\tnode(int pp, int cc, int gg) {\n\t\tp = pp;\n\t\tcost = cc;\n\t\tgas = gg;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nint main() {\n\tint n, m, c;\n\twhile(cin >> n >> m >> c, n) {\n\t\tc *= 10;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmemset(station, 0, sizeof(station));\n\t\trep(i,n) conn[i].clear();\n\t\tmap<string, int> mp;\n\t\tint towns = 0;\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\tmp[start] = towns++;\n\t\tif( start != goal ) {\n\t\t\tmp[goal] = towns++;\n\t\t}\n\t\trep(i, n) {\n\t\t\tstring s, e;\n\t\t\tint d;\n\t\t\tcin >> s >> e >> d;\n\t\t\tif( mp.find(s) == mp.end() ) {\n\t\t\t\tmp[s] = towns++;\n\t\t\t}\n\t\t\tif( mp.find(e) == mp.end() ) {\n\t\t\t\tmp[e] = towns++;\n\t\t\t}\n\t\t\tconn[mp[s]].push_back(pii(mp[e], d));\n\t\t\tconn[mp[e]].push_back(pii(mp[s], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tstation[mp[in]] = true;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], 0, c) );\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top(); que.pop();\n\t\t\tif( nd.p == mp[goal] ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.gas] ) continue;\n\t\t\tvisit[nd.p][nd.gas] = true;\n\n\t\t\tif( station[nd.p] && !visit[nd.p][c] ) {\n\t\t\t\tque.push( node(nd.p, nd.cost, c) );\n\t\t\t}\n\n\t\t\tfor(int i=0; i<conn[nd.p].size(); i++) {\n\t\t\t\tif( nd.gas-conn[nd.p][i].second >= 0 &&  !visit[conn[nd.p][i].first][nd.gas-conn[nd.p][i].second] ) {\n\t\t\t\t\tque.push( node(conn[nd.p][i].first, nd.cost + conn[nd.p][i].second, nd.gas-conn[nd.p][i].second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define MAX_CP 2001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst;\nset<int> LPG;\nvector<Edge> G[MAX];\nint dist[MAX][MAX_CP];\n\nvoid init(){\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  cap *= 10;\n  fill(dist[0],dist[0]+MAX*MAX_CP,INF);\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    int idx = 1; init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 8000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(n, vi(cap + 1, inf));\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nmap<string,int> ma;\nvoid IN(string s){\n  if(!ma.count(s)) {\n    int k=ma.size();\n    ma[s]=k;\n  }\n}\nint d[6666][2222];\n\nvoid Main() {\n  int n,m,k;\n  while(cin >> n >> m >> k && n) {\n    ma.clear();\n    k*=10;\n    string ss,tt;\n    cin >> ss >> tt;\n    IN(ss);IN(tt);\n    vector<P> v[n*2];\n    rep(i,n) {\n      string s,t;\n      int z;\n      cin >> s >> t >> z;\n      IN(s);IN(t);\n      v[ma[s]].pb(P(ma[t],z));\n      v[ma[t]].pb(P(ma[s],z));\n    }\n    set<int> se;\n    rep(i,m) {\n      string s;\n      R s;\n      IN(s);\n      se.in(ma[s]);\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    rep(i,ma.size())rep(j,k+1)d[i][j]=MAX;\n    d[ma[ss]][k]=0;\n    que.push(PP(0,P(ma[ss],k)));\n    while(!que.empty()) {\n      PP p=que.top();que.pop();\n      int x=p.S.F,cc=p.F,t=p.S.S;\n      if(d[x][t]<cc) continue;\n      rep(i,v[x].size()) {\n        int y=v[x][i].F,c=v[x][i].S;\n        c=t-c;\n        if(c<0) continue;\n        if(se.count(y)) c=k;\n        if(d[y][c]<=d[x][t]+v[x][i].S) continue;\n        d[y][c]=d[x][t]+v[x][i].S;\n        que.push(PP(d[y][c],P(y,c)));\n      }\n    }\n    int ans=MAX;\n    rep(i,k+1) ans=min(ans,d[ma[tt]][i]);\n    if(ans==MAX) ans=-1;\n    pr(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n// #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[3001];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    for (int i = 0; i < 2 * n + 2; ++i) adj[i].clear();\n    for (int i = 0; i < n + 1; ++i) adj2[i].clear();\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = 0, mp[dest] = 1;\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int sz = mp.size();\n      if (mp.count(foo) == 0) mp[foo] = sz;\n      sz = mp.size();\n      if (mp.count(bar) == 0) mp[bar] = sz;\n      int u = mp[foo], v = mp[bar];\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (reach.count(now)) continue;\n      int sz = reach.size();\n      reach[now] = sz;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    if (reach.count(mp[dest]) == 0) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<vector<bool>> visit(reach.size(), vector<bool>(cap + 1, false));\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and\n             visit[now = hp.top().second][now_cap = hp.top().first.second])\n        hp.pop();\n      if (now == -1 or visit[now][now_cap]) break;\n      visit[now][now_cap] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nint inf = 100000000;\nint main(){\n    int n,m,cap,src,dst;\n    string s,t;\n    while(cin >> n >> m >> cap&&n!=0){\n        cin >> s >> t;\n        cap*=10;\n        int id = 0;\n        map<string,int>mp;\n        mp[s] = id;\n        src = id;\n        id++;\n        mp[t] = id;\n        dst = id;\n        id++;\n        vector<pair<pair<int,int>,int> > v;\n        for(int i=0;i<n;i++){\n            string ss,tt;\n            int x;\n            cin >> ss >> tt >> x;\n            if(mp.find(ss)==mp.end()){\n                mp[ss]= id;\n                id++;\n            }\n            if(mp.find(tt)==mp.end()){\n                mp[tt] = id;\n                id++;\n            }\n            v.PB(MP(MP(mp[ss],mp[tt]),x));\n        }\n        set<int> st;\n        rep(i,m){\n            string sx;\n            cin >> sx;\n            st.insert(mp[sx]);\n        }\n        if(s==t){\n            cout << 0 << endl;\n            continue;\n        }\n        int ns = mp.size();\n        vector<vector<pair<int,int> > > g(ns);\n        for(auto p:v){\n            g[p.first.first].PB(MP(p.first.second,p.second));\n            g[p.first.second].PB(MP(p.first.first,p.second));\n        }\n        vector<vector<int> > dp(ns,vector<int>(cap+1,inf));\n        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int > > ,greater<pair<pair<int,int>,int > >  > pq;\n        pq.push(MP(MP(0,cap),0));\n        while(!pq.empty()){\n            auto xxx = pq.top();\n            int x,y,now;\n            x = xxx.first.first;\n            y = xxx.first.second;\n            now = xxx.second;\n            pq.pop();\n            if(dp[now][y]<x)continue;\n            for(auto v:g[now]){\n                int next = v.first;\n                int d = v.second;\n                if(y<d)continue;\n                if(st.count(next)){\n                    if(dp[next][cap]>x+d){\n                        dp[next][cap] = x+d;\n                        pq.push(MP(MP(x+d,cap),next));\n                    }\n                }else{\n                    if(dp[next][y-d]>x+d){\n                        dp[next][y-d] = x+d;\n                        pq.push(MP(MP(x+d,y-d),next));\n                    }\n                }\n\n            }\n        }\n        int mi = inf;\n        rep(i,cap+1){\n            mi = min(mi,dp[1][i]);\n        }\n        if(mi>=inf){\n            cout << -1 << endl;\n        }else{\n            cout << mi << endl;\n        }\n    }\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 7000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n\nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  cap *= 10;\n  int dist[idx][cap+1];\n\n  for(int i = 0 ; i < idx ; i++){\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<set>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<sstream>\n#include<string>\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n\nint dp[7005][2005],head[7005];\nbool inq[7005],mark[7005];\nmap<string,int> mapp;\n\nstruct edge{\n\tint to,w,next;\n}edges[7005];\nint em=0;\n\nvoid addedge(int u,int v,int w){\n\tedges[em].next=head[u];\n\tedges[em].to=v;\n\tedges[em].w=w;\n\thead[u]=em++;\n\tedges[em].next=head[v];\n\tedges[em].to=u;\n\tedges[em].w=w;\n\thead[v]=em++;\n}\n\nint main(){\n\tint n,m,cap;\n\twhile(~scanf(\"%d%d%d\",&n,&m,&cap)&&(n||m||cap)){\n\t\tint cnt=1;\n\t\tem=0;\n\t\tcap*=10;\n\t\tstring s,t,tt,mm;\n\t\tmapp.clear();\n\t\tcin>>s>>t;\n\t\tmapp[s]=cnt++;//s:1\n\t\tmapp[t]=cnt++;//t:2\n\t\tmemset(head,-1,sizeof(head));\n\t\twhile(n--){\n\t\t\tint w;\n\t\t\tcin>>tt>>mm;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tif(mapp[tt]==0)\n\t\t\t\tmapp[tt]=cnt++;\n\t\t\tif(mapp[mm]==0)\n\t\t\t\tmapp[mm]=cnt++;\n\t\t\taddedge(mapp[tt],mapp[mm],w);\n\t\t}\n\t\tmemset(mark,false,sizeof(mark));\n\t\twhile(m--){\n\t\t\tcin>>tt;\n\t\t\tmark[mapp[tt]]=true;\n\t\t}\n\t\tqueue<int> q;\n\t\tmemset(inq,false,sizeof(inq));\n\t\tfor(int i=0;i<=cnt;i++)\n\t\t\tfor(int j=0;j<=cap;j++)\n\t\t\t\tdp[i][j]=INF;\n\t\tdp[1][cap]=0;\n\t\tq.push(1);\n\t\tinq[1]=true;\n//\t\tcout<<1<<endl;\n\t\twhile(!q.empty()){\n//\t\t\tcout<<3<<endl;\n\t\t\tint now=q.front();\n\t\t\tq.pop();\n\t\t\tinq[now]=false;\n\t\t\tif(mark[now])\n\t\t\t\tfor(int i=0;i<cap;i++)\n\t\t\t\t\tdp[now][cap]=min(dp[now][i],dp[now][cap]);\n\t\t\tfor(int e=head[now];e!=-1;e=edges[e].next){\n//\t\t\t\tcout<<4<<endl;\n\t\t\t\tint v=edges[e].to,w=edges[e].w;\n\t\t\t\tbool flag=false;\n\t\t\t\tfor(int i=cap;i>=0;i--)\n\t\t\t\t\tif(i>=w){\n\t\t\t\t\t\tif(dp[v][i-w]>dp[now][i]+w){\n//\t\t\t\t\t\t\tcout<<5<<endl;\n\t\t\t\t\t\t\tdp[v][i-w]=dp[now][i]+w;\n\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(flag&&!inq[v]){\n//\t\t\t\t\tcout<<6<<endl;\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<2<<endl;\n\t\tint ans=INF;\n\t\tfor(int i=0;i<=cap;i++)\n\t\t\tans=min(dp[2][i],ans);\n\t\tif(ans==INF)\n\t\t\tprintf(\"-1\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int ME = 5000;\nconst int MV = 5000;\nint fir[MV], rfir[MV];\nint n, m, cap, u[ME], v[ME], nex[ME], rnex[ME], w[ME];\nint dis[MV][5000];\nbool inq[MV][5000], oil_sta[MV];\n\nstruct dot{\n\tint oil, p;\n}rear, front;\n\nint main () {\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int>city;\n\t\tstring start, des;\n\t\tcin >> start >> des;\n\t\tcity[start] = 1; city[des] = 2;\n\t\tint d;\n\t\tstring x, y;\n\t\tint cou = 2;\n\t\tmemset(fir, -1, sizeof(fir));\n\t\tmemset(rfir, -1, sizeof(rfir));\n\t\t//int ee = 0;\n\t\tfor(int ee = 0; ee < n; ee++) {\n\t\t\tcin >> x >> y >> d;\n\t\t\tif(city[x] == 0) city[x] = ++cou;\n\t\t\tif(city[y] == 0) city[y] = ++cou;\n\t\t\t//if(d > cap * 10 ) continue; \n\t\t\tu[ee] = city[x];\n\t\t\tv[ee] = city[y];\n\t\t\tw[ee] = d;\n\t\t\tnex[ee] = fir[u[ee]]; fir[u[ee]] = ee;\n\t\t\trnex[ee] = rfir[v[ee]]; rfir[v[ee]] = ee;\n\t\t\t//ee++;\n\t\t}\n\t\tmemset(oil_sta, 0, sizeof(oil_sta));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin>>x;\n\t\t\tif(!city[x]) continue;\n\t\t\toil_sta[city[x]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap * 10;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint ok = 0;\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tdis[1][cap*10] = 0;\n\t\tinq[1][cap*10] = 1;\n\t\tint mmin = 0x3f3f3f3f;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = 0;\n\t\t\tif(front.p == 2 && !ok) { ok = 1; continue; }\n\t\t\tfor(int e = fir[front.p]; e != -1; e = nex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = v[e];\n\t\t\t\tif(oil_sta[v[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[v[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[v[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[v[e]][rear.oil]){\n\t\t\t\t\t\tinq[v[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int e = rfir[front.p]; e != -1; e = rnex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = u[e];\n\t\t\t\tif(oil_sta[u[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[u[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[u[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[u[e]][rear.oil]){\n\t\t\t\t\t\tinq[u[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tfor(int i = 0; i <= cap*10; i++) if(dis[2][i] < mmin) mmin = dis[2][i];\n\t\t\tprintf(\"%d\\n\", mmin);\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<string,int> con;\nvector<pii> graph[6010];\nint dist[6010][2010];\nbool station[6010];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v,int g){\n\tif(g>=0&&(dist[v][g]==-1||dist[v][g]>c)){\n\t\tdist[v][g]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint dijkstra(int cap){\n\tdist[0][cap]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(dist[v][g]<c)\n\t\t\tcontinue;\n\n\t\tif(station[v]){\n\t\t\tg=cap;\n\t\t\tupdate(c,v,g);\n\t\t}\n\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tint ng=g-v2.second;\n\t\t\tif(update(nc,v2.first,ng)){\n\t\t\t\tstate next(nc,v2.first,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tint n,m,cap;\n\tclr(dist,-1);\n\twhile(cin >> n >> m >> cap){\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[con[s]]=true;\n\t\t}\n\t\tint ans=dijkstra(cap*10);\n\t\tcout << ans << endl;\n\t\tcon.clear();\n\t\tclr(dist,-1);\n\t\trep(i,6010) graph[i].clear();\n\t\tclr(station,false);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<string>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,d; };\n\nint main(){\n\tfor(int m,ng,cap;scanf(\"%d%d%d\",&m,&ng,&cap),m;){\n\t\tcap*=10;\n\t\tchar s_s[16],s_t[16]; scanf(\"%s%s\",&s_s,&s_t);\n\n\t\tint n=0;\n\t\tvector<edge> adj[6000];\n\t\tbool gas[6000]={};\n\n\t\tmap<string,int> id;\n\t\trep(i,m){\n\t\t\tchar a[16],b[16];\n\t\t\tint d; scanf(\"%s%s%d\",a,b,&d);\n\t\t\tif(id.count(a)==0) id[a]=n++;\n\t\t\tif(id.count(b)==0) id[b]=n++;\n\n\t\t\tint u=id[a],v=id[b];\n\t\t\tadj[u].push_back((edge){v,d});\n\t\t\tadj[v].push_back((edge){u,d});\n\t\t}\n\t\trep(i,ng){\n\t\t\tchar a[16]; scanf(\"%s\",a);\n\t\t\tgas[id[a]]=true;\n\t\t}\n\t\tint s=id[s_s],t=id[s_t];\n\n\t\tint d[6000],c[6000];\n\t\trep(u,n){\n\t\t\td[u]=INF;\n\t\t\tc[u]=-1;\n\t\t}\n\t\td[s]=0;\n\t\tc[s]=cap;\n\n\t\tint ans=-1;\n\t\tpriority_queue< pair<pii,int> > pq;\n\t\tpq.push(make_pair(make_pair(0,cap),s));\n\t\twhile(!pq.empty()){\n\t\t\tint d_now=-pq.top().first.first;\n\t\t\tint c_now=pq.top().first.second;\n\t\t\tint u=pq.top().second; pq.pop();\n\n\t\t\tif(u==t){ ans=d_now; break; }\n\n\t\t\trep(i,adj[u].size()){\n\t\t\t\tedge e=adj[u][i];\n\t\t\t\tif(c_now<e.d) continue;\n\n\t\t\t\tint d_next=d_now+e.d;\n\t\t\t\tint c_next=(gas[e.v]?cap:c_now-e.d);\n\t\t\t\tif(d[e.v]>d_next || d[e.v]==d_next && c[e.v]<c_next){\n\t\t\t\t\td[e.v]=d_next;\n\t\t\t\t\tc[e.v]=c_next;\n\t\t\t\t\tpq.push(make_pair(make_pair(-d[e.v],c[e.v]),e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge {string to; int cost; };\ntypedef pair<int, string> P;\n\nconst int inf = 1000000000;\nint V;\nmap<string, vector<edge> > G1;\nmap<string, vector<edge> > G2;\nset<string> allcities;\nmap<string, int> d;\n\nvoid dijkstra(string s, map<string, vector<edge> > G) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  for (string c : allcities) {\n    d[c] = inf;\n  }\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    string v = p.second;\n    if (d[v] < p.first) continue;\n    for (edge e : G[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if (n == 0 && m == 0 && cap == 0) break;\n    G1.clear();\n    G2.clear();\n    allcities.clear();\n    d.clear();\n    string src, dest;\n    cin >> src >> dest;\n    for (int i = 0; i < n; i++) {\n      string c1, c2;\n      int dis;\n      cin >> c1 >> c2 >> dis;\n      G1[c1].push_back((edge){c2, dis});\n      G1[c2].push_back((edge){c1, dis});\n      allcities.insert(c1);\n      allcities.insert(c2);\n    }\n    vector<string> lpg(m+2);\n    for (int i = 0; i < m; i++) {\n      string s;\n      cin >> s;\n      lpg[i] = s;\n    }\n    lpg[m] = src; lpg[m+1] = dest;\n    for (int i = 0; i < m+2; i++) {\n      dijkstra(lpg[i], G1);\n      for (int j = 0; j < m+2; j++) {\n\tif (j == i) continue;\n\tif (d[lpg[j]] <= 10 * cap)\n\t  G2[lpg[i]].push_back((edge){lpg[j], d[lpg[j]]});\n      }\n    }\n    dijkstra(src, G2);\n    if (d[dest] >= inf)\n      cout << -1 << endl;\n    else\n      cout << d[dest] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#define mod 1000000007\n#define INF 1<<30\n#define eps 1e-10\nusing namespace std;\nint n,m,cap,tot;\nmap<string,int> mm;\nchar s[20],t[20];\nchar s1[20],t1[20];\nbool flag[6002];\nint s2,t2;\nstruct node\n{\n    short t,ti;\n};\nstruct state\n{\n    short vex,ca;\n};\nvector<node> ve[6002];\nint dp[6002][2002];\nbool vis[6002][2002];\npriority_queue<state> q;\nbool operator < (const state& a,const state& b)\n{\n    return dp[a.vex][a.ca]<dp[b.vex][b.ca];\n}\n\nvoid dijkstra(int s,int t)\n{\n    while(!q.empty()) q.pop();\n    for(int i=1;i<tot;i++)\n    for(int j=0;j<=cap;j++) {dp[i][j]=INF;vis[i][j]=0;}\n    dp[s][cap]=0;state ss;ss.vex=s;ss.ca=cap;q.push(ss);\n    while(!q.empty())\n    {\n        ss=q.top();q.pop();\n        if(vis[ss.vex][ss.ca]) continue;\n        //cout<<ss.vex<<\" \"<<ss.ca<<\" \"<<dp[ss.vex][ss.ca]<<endl;\n        if(ss.vex==t) return;\n        vis[ss.vex][ss.ca]=1;\n        for(int i=0;i<ve[ss.vex].size();i++)\n        {\n            node no=ve[ss.vex][i];\n            if(ss.ca<no.ti) continue;\n            int cc=ss.ca-no.ti;\n            if(flag[no.t]) cc=cap;\n            if(dp[ss.vex][ss.ca]+no.ti<dp[no.t][cc])\n            {\n                dp[no.t][cc]=dp[ss.vex][ss.ca]+no.ti;\n                state ss2;ss2.vex=no.t;ss2.ca=cc;\n                q.push(ss2);\n            }\n        }\n    }\n}\nmain()\n{\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&n,&m,&cap),n+m+cap)\n    {\n        tot=1;int dd;cap*=10;\n        scanf(\"%s%s\",s1,t1);\n        memset(ve,0,sizeof(ve));\n        memset(flag,0,sizeof(flag));\n        mm.clear();\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%s%s%d\",s,t,&dd);int ss,tt;\n            if(mm[s]==0)\n            {\n                mm[s]=tot++;ss=tot-1;\n            }\n            else\n            ss=mm[s];\n            if(mm[t]==0)\n            {\n                mm[t]=tot++;tt=tot-1;\n            }\n            else\n            tt=mm[t];\n            if(cap>=dd)\n            {node no;no.t=tt;no.ti=dd;ve[ss].push_back(no);\n            no.t=ss;ve[tt].push_back(no);}\n        }\n        s2=mm[s1];t2=mm[t1];\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%s\",s);flag[mm[s]]=1;\n        }\n        dijkstra(s2,t2);\n        int ans=INF;\n        for(int i=0;i<=cap;i++)\n        ans=min(ans,dp[t2][i]);\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    //while(1);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    dp[get_city_id(cities,src)][10*capacity] = true\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\tdp[to][next_remaining_LPG] = true;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Long Distance Taxi\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ntypedef long long LL;\nconst LL INF = 3000LL*200*2000;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        const int idx = dict.size();\n        return dict[str] = idx;\n    }\n};\n\nmap<int,LL> search_path(int from, map<int,vector<pair<int,LL>>> &graph) {\n    priority_queue<pair<LL,int>> q;\n    map<int,LL> memo;\n    q.push(make_pair(0, from));\n    memo[from] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(memo[cur] < cost) continue;\n        for(const auto &edge : graph[cur]) {\n            const LL nc = cost + edge.second;\n            if(memo.count(edge.first) == 0 || memo[edge.first] > nc) {\n                memo[edge.first] = nc;\n                q.push(make_pair(-nc, edge.first));\n            }\n        }\n    }\n    return memo;\n}\n\nbool solve() {\n    int N, M, C;\n    cin >> N >> M >> C;\n    if(!N && !M && !C) return false;\n\n    Dict dict;\n    string Sn, Dn;\n    cin >> Sn >> Dn;\n    const int S = dict.get(Sn);\n    const int D = dict.get(Dn);\n\n    map<int,vector<pair<int,LL>>> graph;\n    TIMES(_, N) {\n        string s, t;\n        LL d;\n        cin >> s >> t >> d;\n        const int si = dict.get(s);\n        const int ti = dict.get(t);\n        graph[si].push_back(make_pair(ti, d));\n        graph[ti].push_back(make_pair(si, d));\n    }\n    vector<int> stations;\n    TIMES(_, M) {\n        string s;\n        cin >> s;\n        stations.push_back(dict.get(s));\n    }\n    stations.push_back(S);\n    stations.push_back(D);\n    map<int,vector<pair<int,LL>>> min_graph;\n    for(int from : stations) {\n        map<int,LL> res = search_path(from, graph);\n        for(int i : stations) {\n            if(res.count(i) && res[i] <= C*10) {\n                min_graph[from].push_back(make_pair(i, res[i]));\n                //cout << from << ' ' << i << ' ' << res[i] << endl;\n            }\n        }\n    }\n\n    map<int,LL> res = search_path(S, min_graph);\n    LL ans = -1;\n    if(res.count(D)) {\n        ans = res[D];\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint N,M,Cap;\n\nstruct Edge{\npublic:\n\tint to,cost;\n\tEdge(int a,int b){to=a;cost=b;}\n\tEdge(){to=0;cost=0;}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF=1000000007;\n\nclass Info{\npublic: \n\tint now,total,rem;\n\tInfo(int a,int b,int c){now=a;total=b;rem=c;}\n\tbool operator < (const Info &a) const {return total>a.total;}\n};\n\nvector<int> get_cost(Graph g,int s){\n\tvector<int> res(N*2,INF);\n\tvector<bool> visit(N*2,false);\n\tpriority_queue<Info> Q;\n\tQ.push(Info(s,0,0));\n\twhile(!Q.empty()){\n\t\tInfo top=Q.top();\n\t\tQ.pop();\n\t\tint pos=top.now;\n\t\tif(visit[pos]) continue;\n\t\tvisit[pos]=true;\n\t\tres[pos]=top.total;\n\t\tfor(int i=0;i<g[pos].size();i++)\n\t\t\tQ.push(Info(g[pos][i].to,top.total+g[pos][i].cost,0));\n\t}\n\treturn res;\n}\n\nint calc(Graph g,int s,int t){\n\tvector<bool> visit(N*2,false);\n\tpriority_queue<Info> Q;\n\tQ.push(Info(s,0,0));\n\twhile(!Q.empty()){\n\t\tInfo top=Q.top();\n\t\tQ.pop();\n\t\tif(top.now==t) return top.total;\n\t\tint pos=top.now;\n\t\tif(visit[pos]) continue;\n\t\tvisit[pos]=true;\n\t\tfor(int i=0;i<g[pos].size();i++)\n\t\t\tQ.push(Info(g[pos][i].to,top.total+g[pos][i].cost,0));\n\t}\n\treturn -1;\n}\n\nvoid solve()\n{\n\tCap*=10;\n\tmap<string,int> Idx;\n\tGraph V(N*2,vector<Edge>(0));\n\tint size=0;\n\tstring start,goal;\n\tcin>>start>>goal;\n\tIdx[start]=size++; Idx[goal]=size++;\n\tfor(int i=0;i<N;i++){\n\t\tstring s1,s2; int d;\n\t\tcin>>s1>>s2>>d;\n\t\tif(!Idx.count(s1)) Idx[s1]=size++;\n\t\tif(!Idx.count(s2)) Idx[s2]=size++;\n\t\tV[Idx[s1]].push_back(Edge(Idx[s2],d));\n\t\tV[Idx[s2]].push_back(Edge(Idx[s1],d));\n\t}\n\n\tvector<int> Sta(M+2);\n\tfor(int i=0;i<M;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tSta[i]=Idx[s];\n\t}\n\tSta[M]=Idx[start];Sta[M+1]=Idx[goal];\n\n\tGraph g(N*2);\n\tfor(int i=0;i<M+2;i++){\n\t\tvector<int> temp=get_cost(V,Sta[i]);\n\t\tfor(int j=0;j<M+2;j++){\n\t\t\tif(temp[Sta[j]]<=Cap)\n\t\t\t\tg[Sta[i]].push_back(Edge(Sta[j],temp[Sta[j]]));\n\t\t}\n\t}\n\n\tcout<<calc(g,Idx[start],Idx[goal])<<endl;\n\n}\n\n\nint main()\n{\n\twhile(cin>>N>>M>>Cap){\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tcin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tif(!G[i].empty())\n\t\t\t\tG[i].clear();\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tif(!GG[i].empty())\n\t\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\t//if(ma.find(a) == ma.end())\n\t\t\t\t//ma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\t//dijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 3000) continue;\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int> > v[6005];\nmap<string,int> mp;\nint mpn;\nbool c[6005];\nunsigned dis[6005][2005],ans;\nchar a[20];\nqueue<pair<int,int> > q;\n\ninline int s2i(string x)\n{\n    if(!mp.count(x))\n        return mp[x]=mpn++;\n    return mp[x];\n}\n\nint main()\n{\n    int n,m,k,st,ed,i,j,x,y,w,ww,kk;\n    while(~scanf(\"%d%d%d\",&n,&m,&k)&&(n+m+k))\n    {\n        memset(c,0,sizeof(c));\n        memset(dis,-1,sizeof(dis));\n        mpn=0;k*=10;\n        scanf(\"%s\",a);st=s2i(a);\n        scanf(\"%s\",a);ed=s2i(a);\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%s\",a);x=s2i(a);\n            scanf(\"%s\",a);y=s2i(a);\n            scanf(\"%d\",&w);\n            v[x].push_back(make_pair(y,w));\n            v[y].push_back(make_pair(x,w));\n        }\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",a);\n            c[s2i(a)]=1;\n        }\n        dis[st][k]=0,ans=-1;\n        q.push(make_pair(st,k));\n        while(!q.empty())\n        {\n            x=q.front().first;\n            w=q.front().second;\n            kk=dis[x][w];\n            q.pop();\n            for(i=0,j=v[x].size();i<j;i++)\n            {\n                y=v[x][i].first;ww=w;\n                if(ww<v[x][i].second)\n                    continue;\n                ww-=v[x][i].second;\n                if(c[y])\n                    ww=k;\n                if((unsigned)kk+v[x][i].second<dis[y][ww])\n                {\n                    dis[y][ww]=kk+v[x][i].second;\n                    q.push(make_pair(y,ww));\n                    if(y==ed)\n                        ans=min(ans,dis[y][ww]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n        for(i=0;i<mpn;i++)\n            v[i].clear();\n        mp.clear();\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N,M,Cap;\nstring S,D;\n\nstruct Node{\n\tint rem;\n\tint total;\n};\n\nbool operator < (Node a,Node b){\n\treturn a.total>b.total;\n}\n\nstruct Info{\n\tNode node;\n\tint pos;\n};\n\nbool operator < (Info a,Info b){\n\treturn a.node.total>b.node.total;\n}\n\nint cost[6000][6000];\nbool sta[6000];\n\nvoid solve(){\n\tCap*=10;\n\tmemset(cost,-1,sizeof(cost));\n\tmemset(sta,false,sizeof(sta));\n\tmap<string,int> Idx;\n\tcin>>S>>D;\n\tIdx[S]=1;Idx[D]=2;\n\tint size=2;\n\n\tvector<vector<int> > Cost(2);\n\n\tfor(int i=0;i<N;i++){\n\t\tstring in,out; int d;\n\t\tcin>>in>>out; cin>>d;\n\t\tif(Idx[in]==0) Idx[in]=++size;\n\t\tif(Idx[out]==0) Idx[out]=++size;\n\t\tcost[Idx[in]-1][Idx[out]-1]=cost[Idx[out]-1][Idx[in]-1]=d;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tstring t;cin>>t;\n\t\tsta[Idx[t]-1]=true;\n\t}\n\n\tvector<vector<Node> > V(size);\n\tpriority_queue<Info> Q;\n\tInfo f;\n\tf.node.rem=Cap;\n\tf.node.total=0;\n\tf.pos=Idx[S]-1;\n\tQ.push(f);\n\n\tbool used[6000];\n\tmemset(used,false,sizeof(used));\n\n\twhile(!Q.empty()){\n\t\tInfo now=Q.top();\n\t\tQ.pop();\n\t\tif(now.pos==1&&now.node.rem>0){cout<<now.node.total<<endl;return;}\n\t\tif(now.node.rem<0){cout<<\"erroe!!!!\\n\"; continue;}\n\t\tV[now.pos].push_back(now.node);\n\t\t\n\t\t\tif(used[now.pos]) continue;\n\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(cost[now.pos][i]<0) continue;\n\t\t\tInfo next;\n\t\t\tif(sta[now.pos]){\n\t\t\t\tused[now.pos]=true;\n\t\t\t\tnext.node.rem=Cap;\n\t\t\t\tnext.node.total=now.node.total+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.node.rem=now.node.rem-cost[now.pos][i];\n\t\t\t\tif(next.node.rem<0) continue; \n\t\t\t\tnext.node.total=now.node.total+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int z=0;z<V[i].size();z++){\n\t\t\t\t\tif(!(next.node.rem>V[i][z].rem || next.node.total<V[i][z].total)){\n\t\t\t\t\t\tok=false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)\n\t\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n\nint main()\n{\n\twhile(cin>>N>>M>>Cap){\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[3010];\nint dist[3010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 3010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 3010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\t\tstring c1[3010], c2[3010];\n\t\tint d[3010];\n\t\tstring s[3010];\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tdijkstra(city2num[src], cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[city2num[dest]][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF INT_MAX\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>f,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    f.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      f.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[f[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[3010];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    reach[mp[dest]] = reach.size();\n    vector<bool> visit(mp.size(), false);\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (visit[now]) continue;\n      if (reach.count(now) == 0) reach[now] = reach.size();\n      visit[now] = true;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) adj[i].clear();\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n    cand.clear();\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    mp.clear();\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<set<int>> visit2(reach.size(), set<int>());\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and visit2[now = hp.top().second].count(\n                                 now_cap = hp.top().first.second))\n        hp.pop();\n      if (now == -1 or visit2[now].count(now_cap)) break;\n      visit2[now].insert(now_cap);\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n    for (int i = 0; i < (int)reach.size(); ++i) adj2[i].clear();\n\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;cost=c;\n\t}\n};\nvector<Edge> g[10000];\nvector<Edge> g2[10000];\nmap<string,int> mp; //都市名をインデックスに直す\nvector<int> check; //stとgl, LPGステーションの位置\nint d[10000];\n\n//始点sからの縮約前のダイクストラ\nvoid dijk(int s)\n{\n\tfill(d,d+10000,1e8-1);\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty())\n\t{\n\t\tP p=q.top();q.pop();\n\t\tif(p.first>d[p.second])\n\t\t\tcontinue;\n\t\tfor(int i=0;i<g[p.second].size();i++)\n\t\t{\n\t\t\tEdge e=g[p.second][i];\n\t\t\tif(p.first+e.cost<d[e.to])\n\t\t\t{\n\t\t\t\td[e.to]=p.first+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m,cap;\n\t\tint cnt=1;\n\t\tmp.clear();\n\t\tfor(int i=0;i<10000;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tg2[i].clear();\n\t\t}\n\t\tcheck.clear();\n\t\tcin>>n>>m>>cap;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tstring st,gl;\n\t\tcin>>st>>gl;\n\t\t//cerr<<gl<<endl;\n\t\tmp[st]=cnt; //スタートは1\n\t\tcnt++;\n\t\tmp[gl]=cnt; //ゴールは2\n\t\tcnt++;\n\t\tcheck.push_back(1);\n\t\tcheck.push_back(2);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tstring f,t;\n\t\t\tint dest;\n\t\t\tcin>>f>>t>>dest;\n\t\t\tif(mp[f]==0)\n\t\t\t{\n\t\t\t\tmp[f]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(mp[t]==0)\n\t\t\t{\n\t\t\t\tmp[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[mp[f]].push_back(Edge(mp[t],dest));\n\t\t\tg[mp[t]].push_back(Edge(mp[f],dest));\n\t\t}\n\t\t//LPG\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(mp[s]==0)\n\t\t\t{\n\t\t\t\tmp[s]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcheck.push_back(mp[s]);\n\t\t}\n\n\t\t//ここからダイクストラ（1回目）\n\t\tfor(int i=0;i<check.size();i++)\n\t\t{\n\t\t\tdijk(check[i]);\n\t\t\tfor(int j=0;j<check.size();j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d[check[j]]<=cap*10)\n\t\t\t\t\tg2[check[i]].push_back(Edge(check[j],d[check[j]]));\n\t\t\t}\n\t\t}\n\t\t//ダイクストラ（2回目）\n\t\tpriority_queue<P,vector<P>,greater<P> > q;\n\t\tfill(d,d+10000,1e8-1);\n\t\td[1]=0;\n\t\tq.push(P(0,1));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p=q.top();q.pop();\n\t\t\tif(p.first>d[p.second])\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<g2[p.second].size();i++)\n\t\t\t{\n\t\t\t\tEdge e=g2[p.second][i];\n\t\t\t\tif(e.cost+p.first<d[e.to])\n\t\t\t\t{\n\t\t\t\t\td[e.to]=e.cost+p.first;\n\t\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[2]==1e8-1)\n\t\t\tcout<<-1<<endl;\n\t\telse\n\t\t\tcout<<d[2]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{int to,cost;};\nstruct State{\n  int t, pos, fuel;\n  State(){}\n  State(int t, int p, int f):t(t),pos(p),fuel(f){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\nconst int CITY = 3001;\nconst int MAX = 305;\nconst int INF = (1<<25);\n\nint N,M,C,T[MAX][MAX];\nmap<string,int> NUM;\nvector<edge> E[CITY];\nint cnt,src,dest;\nvector<int> GS;\nint tt[MAX][2001];\nvoid init(){\n  fill(T[0],T[0]+MAX*MAX,INF);\n  NUM.clear();\n  GS.clear();\n  for(int i = 0; i < CITY; i++) E[i].clear();\n  cnt=0;\n}\n\nvoid input(){\n  string s,d;\n  cin >> s >> d;\n  NUM[s] = src = ++cnt;\n  NUM[d] = dest = ++cnt;\n\n  for(int i = 0; i < N; i++){\n    int cos;\n    cin >> s >> d >> cos;\n    if(NUM[s] == 0) NUM[s] = ++cnt;\n    if(NUM[d] == 0) NUM[d] = ++cnt;\n    E[NUM[s]].push_back((edge){NUM[d],cos});\n    E[NUM[d]].push_back((edge){NUM[s],cos});\n  }\n\n  for(int i = 0; i < M; i++){\n    cin >> s;\n    GS.push_back(NUM[s]);\n  }\n}\n\nbool hasGS(int p){\n  for(int i = 0; i < (int)GS.size(); i++)\n    if(GS[i] == p) return true;\n  return false;\n}\n\nvoid dijkstra(int from, int to){\n\n  fill(tt[0],tt[0]+MAX*2001,INF);\n  \n  int ans = INF;\n\n  priority_queue<State> Q;\n  Q.push(State(0,from,10*C));\n  tt[from][10*C] = 0;\n \n  //  cout << now.t << \" \" << now.pos << \" \" << now.fuel << endl;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n   \n    if(now.pos == to) ans = min(ans,now.t);\n\n    if(tt[now.pos][now.fuel] < now.t) continue;\n\n    for(int i = 0; i < (int)E[now.pos].size(); i++){\n      edge& e = E[now.pos][i];\n\n      State nex = now;\n      nex.fuel -= e.cost;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.fuel < 0) continue;\n      \n      if(hasGS(nex.pos)) nex.fuel = 10*C;\n\n      if(tt[nex.pos][nex.fuel] > nex.t){\n\ttt[nex.pos][nex.fuel] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n  T[from][to] = min(T[from][to],ans);\n  T[to][from] = min(T[to][from],ans);\n}\n\nvoid solve(){\n\n  vector<int> tmp = GS;\n  tmp.push_back(src);\n  tmp.push_back(dest);\n\n  for(int i = 0; i < (int)tmp.size(); i++)\n    for(int j = i+1; j < (int)tmp.size(); j++)\n      dijkstra(tmp[i],tmp[j]);\n\n  int size = tmp.size();\n \n  for(int i = 0; i <= size; i++) T[i][i] = 0;\n\n  for(int k = 0; k <= size; k++)\n    for(int i = 0; i <= size; i++)\n      for(int j = 0; j <= size; j++)\n\tT[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n  \n\n  if(T[src][dest] == INF) cout << -1 << endl;\n  else cout << T[src][dest] << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> C && N+M+C){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cfloat>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define INF (1<<30)\n\nclass Edge{\npublic:\nint to, cost;\nEdge(int to0, int cost0){\nto = to0;\ncost = cost0;\n}\n};\n\nint main()\n{\n    for(;;){\n        int r, m, cap;\n        string src, dest;\n        cin >> r >> m >> cap >> src >> dest;\n        if(r == 0)\n            return 0;\n\n        int n = 2;\n        map<string, int> index;\n        index[src] = 0;\n        index[dest] = 1;\n\n        vector<vector<Edge> > edges(2);\n        for(int i=0; i<r; ++i){\n            string s1, s2;\n            int d;\n            cin >> s1 >> s2 >> d;\n            int j = 0;\n            int k = 0;\n            if(index.find(s1) == index.end()){\n                index.insert(make_pair(s1, n));\n                ++ n;\n                edges.resize(n);\n            }\n            if(index.find(s2) == index.end()){\n                index.insert(make_pair(s2, n));\n                ++ n;\n                edges.resize(n);\n            }\n            j = index[s1];\n            k = index[s2];\n            edges[j].push_back(Edge(k, d));\n            edges[k].push_back(Edge(j, d));\n        }\n\n        vector<bool> station(n);\n        for(int i=0; i<m; ++i){\n            string s;\n            cin >> s;\n            station[index[s]] = true;\n        }\n\n        vector<int > check(n, -1);\n        multimap<int, pair<int, int> > mm;\n        mm.insert(make_pair(0, make_pair(0, cap*10)));\n        bool ng = true;\n        while(!mm.empty()){\n            int cost = mm.begin()->first;\n            int curr = mm.begin()->second.first;\n            int rest = mm.begin()->second.second;\n            mm.erase(mm.begin());\n\n            if(rest <= check[curr])\n                continue;\n            check[curr] = rest;\n\n            if(curr == 1){\n                cout << cost << endl;\n                ng = false;\n                break;\n            }\n\n            for(unsigned i=0; i<edges[curr].size(); ++i){\n                int cost1 = cost + edges[curr][i].cost;\n                int next = edges[curr][i].to;\n                int rest1 = rest - edges[curr][i].cost;\n                if(rest1 >= 0){\n                    if(station[next])\n                        rest1 = cap*10;\n                    if(rest1 > check[next])\n                        mm.insert(make_pair(cost1, make_pair(next, rest1)));\n                }\n            }\n        }\n\n        if(ng)\n            cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\nstring s1,s2,stt,goo;\nint n,m,x,c1;\nint dp[3009][20009];\nvector<P>v[5000];\nint main(){\n  while(cin>>n>>m>>x,n){\n    r(i,5000)v[i].clear();\n    r(i,3009)r(j,2009)dp[i][j]=1e9;\n    x*=10;\n    int c=1;\n    map<string,int>M;\n    set<int>s;\n    cin>>stt>>goo;\n    r(i,n){\n      cin>>s1>>s2>>c1;\n      if(!M[s1])M[s1]=c++;\n      if(!M[s2])M[s2]=c++;\n      v[M[s1]].push_back(P(M[s2],c1));\n      v[M[s2]].push_back(P(M[s1],c1));\n    }\n    int st=M[stt],go=M[goo];\n    r(i,m){\n      cin>>s1;\n      s.insert(M[s1]);\n    }\n    dp[st][x]=0;\n    priority_queue<P,vector<PP>,greater<PP> >q;\n    q.push(PP(0,P(st,x)));\n    while(!q.empty()){\n      PP p=q.top();q.pop();\n      int now=p.second.first;\n      int cost=p.first;\n      int cap=p.second.second;\n      if(dp[now][cap]<cost)continue;\n      r(i,v[now].size()){\n        int dis=v[now][i].second;\n        int next=v[now][i].first;\n        int cost2=cost+dis;\n        int cap2=cap-dis;\n        if(cap2<0)continue;\n        if(s.count(next))cap2=x;\n        if(dp[next][cap2]>cost2){//cout<<next<<' '<<cost2<<endl;\n          dp[next][cap2]=cost2;\n          q.push(PP(cost2,P(next,cap2)));\n        }\n      }\n    }\n    int ans=1e9;\n    r(i,2009)ans=min(dp[go][i],ans);\n    if(ans==1e9)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){ };\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n};\nmap<string, int> names;\nint memo[6100][2100];\nbool LPG[6100];\nvector<edge> G[6100];\n\nint main(){\n  int cnt;\n  int n, m, cap, d;\n  string src, dst;\n  string c1, c2, str;\n  while(cin >> n >> m >> cap && (n || m || cap)){\n    int res = INF;\n    cnt = 1;\n    cap *= 10;\n    cin >> src >> dst;\n\n    names.clear();\n    rep(i, 6100) G[i].clear();\n    memset(LPG, 0, sizeof(LPG));\n    fill(&memo[0][0], &memo[0][0] + 6100 * 2100, INF);\n    \n    rep(i, n){\n      cin >> c1 >> c2 >> d;\n      if(!names[c1]) names[c1] = cnt++;\n      if(!names[c2]) names[c2] = cnt++;\n      G[names[c1]].push_back(edge(names[c2], d));\n      G[names[c2]].push_back(edge(names[c1], d));\n    }\n    rep(i, m){\n      cin >> str;\n      LPG[names[str]] = true;\n    }\n    int s = names[src];\n    int t = names[dst];\n    memo[s][cap] = 0;\n    priority_queue<state, vector<state>, greater<state> > que;\n    que.push(state(0, P(s, cap)));\n    while(!que.empty()){\n      state st = que.top(); que.pop();\n      int cost = st.first;\n      int pos = st.second.first;\n      int tank = st.second.second;\n      if(cost > memo[pos][tank]) continue;\n      if(pos == t) res = min(res, cost);\n      rep(i, (int)G[pos].size()){\n\tint need = G[pos][i].cost;\n\tint nxt = G[pos][i].to;\n\t\n\tif(tank - need >= 0){\n\t  int ntank = LPG[nxt] ? cap : tank - need;\n\t  if(memo[nxt][ntank] > cost + need){\n\t    memo[nxt][ntank] = cost + need;\n\t    que.push(state(cost + need, P(nxt, ntank)));\n\t  } \n\t}\n      }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n  \n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n  \n#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n  \nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n  \nint n, m, cap, dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n  \ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n  \ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      adj[sid.size()].clear();\n      sid.emplace(s0, sid.size());\n    }\n    if(!sid.count(s1)) {\n      adj[sid.size()].clear();\n      sid.emplace(s1, sid.size());\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  dis[0] = 0;\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    //cerr << \"cost \" << nxt0.F << \" id \" << nxt0.S << endl;\n  \n    vector<int> tmp_dis(mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    if(tmp_dis[1] != INF)\n      return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  if(dis[1] == INF)\n    return -1;\n  else\n    return dis[1];\n}\n  \nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> g[6000];\nbool f[6000];\nint dist[6000][2010];\n\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tfor (int i = 0; i < 6000; i++) g[i].clear();\n\t\tmemset(f, 0, sizeof(f));\n\t\tcap *= 10;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tmap<string, int> mp;\n\t\tmp[src] = mp.size() - 1;\n\t\tmp[dst] = mp.size() - 1;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring a, b;\n\t\t\tint c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!mp.count(a)) mp[a] = mp.size() - 1;\n\t\t\tif (!mp.count(b)) mp[b] = mp.size() - 1;\n\t\t\tg[mp[a]].emplace_back(mp[b], c);\n\t\t\tg[mp[b]].emplace_back(mp[a], c);\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf[mp[s]] = true;\n\t\t}\n\t\tfill_n(*dist, 6000 * 2010, 1 << 28);\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\t\tdist[0][cap] = 0;\n\t\tpq.push(make_tuple(0, 0, cap));\n\t\tint res = -1;\n\t\twhile (pq.size()){\n\t\t\tint s, v, r;\n\t\t\ttie(s, v, r) = pq.top(); pq.pop();\n\t\t\tif (v == mp[dst]){\n\t\t\t\tres = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dist[v][r] < s) continue;\n\t\t\tif (f[v]) r = cap;\n\t\t\tfor (pair<int, int> &e : g[v]){\n\t\t\t\tif (r < e.second) continue;\n\t\t\t\tif (dist[e.first][r - e.second] > s + e.second){\n\t\t\t\t\tdist[e.first][r - e.second] = s + e.second;\n\t\t\t\t\tpq.push(make_tuple(s + e.second, e.first, r - e.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 100000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 6001\n#define INF 1e9\n \nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap)\n    : dist(dist),v(v),cap(cap) {}\n \n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n \nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n \nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n \nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n \nint dijkstra(){\n  vector<int> dist[idx];\n  cap *= 10;\n  \n  for(int i = 0 ; i < idx ; i++){\n    dist[i].resize(cap+1);\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n \n  dist[src][cap] = 0;\n \n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n \n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n     \n    if(dist[v][c] < s.dist) continue;\n     \n    if(v == dst){\n      return dist[v][c];\n    }\n \n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                          \n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  int d;\n  string a,b;\n   \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp;\n    cin >> a; mp[a] = src = idx++;\n    cin >> a; mp[a] = dst = idx++;\n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nbool visit[6001][2001];\nvector<pii> edge[6001];\nvector<int> mst;\nstruct node {\n\tint id, cap, dist;\n\tnode(int i, int c, int d) {\n\t\tid = i;\n\t\tcap = c;\n\t\tdist = d;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.dist > rhs.dist;\n}\n\nint main() {\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n and m and cap) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmst.clear();\n\t\tcap *= 10;\n\t\tmap<string, int> mp;\n\t\trep(i, 2*n+1) edge[i].clear();\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\tint k=0;\n\t\trep(i, n) {\n\t\t\tstring a, b;\n\t\t\tint d;\n\t\t\tcin >> a >> b >> d;\n\t\t\tif( mp.find(a) == mp.end() ) mp[a] = k++;\n\t\t\tif( mp.find(b) == mp.end() ) mp[b] = k++;\n\t\t\tedge[ mp[a] ].push_back(pii(mp[b], d));\n\t\t\tedge[ mp[b] ].push_back(pii(mp[a], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tmst.push_back(mp[s]);\n\t\t}\n\t\tsort(mst.begin(), mst.end());\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], cap, 0) );\n\t\tbool found = false;\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.id][nd.cap] ) continue;\n\t\t\tvisit[nd.id][nd.cap] = true;\n\t\t\tif( nd.id == mp[goal] ) {\n\t\t\t\tcout << nd.dist << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( binary_search(mst.begin(), mst.end(), nd.id) and !visit[nd.id][cap] ) {\n\t\t\t\tque.push( node(nd.id, cap, nd.dist) );\n\t\t\t}\n\t\t\trep(i, edge[nd.id].size()) {\n\t\t\t\tpii p = edge[nd.id][i];\n\t\t\t\tif( nd.cap >= p.second && !visit[p.first][nd.cap-p.second] ) {\n\t\t\t\t\tque.push( node(p.first, nd.cap-p.second, nd.dist + p.second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 3030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[303];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!G[i].empty())\n\t\t\tG[i].clear();\n\t\tfor(i = 0; i < 303; i++)\n\t\tif(!GG[i].empty())\n\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != m.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct Edge{\n  int cost, from, to;\n  Edge(int cost, int from, int to):\n    cost(cost), from(from), to(to) {}\n};\n\nbool operator<(const Edge& a, const Edge& b){\n  return a.cost != b.cost ? a.cost < b.cost : a.from != b.from ? a.from < b.from : a.to < b.to;\n}\n\nint dijkstra(const vector< vector< pair<int,int> > > &G,\n             const vector<bool> &is_lpg_station, int cap, int s, int g){\n  int n = G.size();\n  vector< pair<int,int> > D(n,make_pair(INF,cap));\n  priority_queue<Edge> wait;\n  wait.push(Edge(0,cap,s));\n  while(!wait.empty()){\n    Edge e = wait.top();\n    wait.pop();\n    int d = -e.cost, c = e.from, v = e.to;\n    if(d > D[v].first && c < D[v].second){\n      continue;\n    }else{\n      if(d < D[v].first) D[v] = make_pair(d,c);\n      if(d == D[v].first && D[v].second < c) D[v].second = c;\n    }\n    for(int i = 0; i < G[v].size(); ++i){\n      int d_ = G[v][i].first, v_ = G[v][i].second;\n      if(d_ <= c && d + d_ < D[v_].first){\n        D[v_].first = d + d_;\n        D[v_].second = c;\n        if(is_lpg_station[v_]){\n          wait.push(Edge(-d-d_,cap,v_));\n          D[v_].second = cap;\n        }else wait.push(Edge(-d-d_,c-d_,v_));\n      }else if(d_ <= c && d + d_ == D[v_].first){\n        if(c - d_ > D[v_].second){\n          D[v_].second = c - d_;\n          wait.push(Edge(-d-d_,c-d_,v_));\n        }\n      }else if(c - d_ > D[v_].second){\n        if(is_lpg_station[v_]) wait.push(Edge(-d-d_,cap,v_));\n        else wait.push(Edge(-d-d_,c-d_,v_));\n      }\n    }\n  }\n  return D[g].first;\n}\n\nint main(){\n  int N, M, cap;\n  while(cin >> N >> M >> cap, N){\n    string src, dest;\n    cin >> src >> dest;\n    map<string,int> mp;\n    vector<string> C1(N), C2(N);\n    vector<int> D(N);\n    int t = 1;\n    for(int i = 0; i < N; ++i){\n      cin >> C1[i] >> C2[i] >> D[i];\n      if(!mp[C1[i]]){\n        mp[C1[i]] = t;\n        ++t;\n      }\n      if(!mp[C2[i]]){\n        mp[C2[i]] = t;\n        ++t;\n      }\n    }\n    int n = mp.size();\n    vector< vector< pair<int,int> > > G(n);\n    for(int i = 0; i < N; ++i){\n      int u = mp[C1[i]] - 1, v = mp[C2[i]] - 1, d = D[i];\n      G[u].push_back(make_pair(d,v));\n      G[v].push_back(make_pair(d,u));\n    }\n    string S;\n    vector<bool> is_lpg_station(n, false);\n    for(int i = 0; i < M; ++i){\n      cin >> S;\n      is_lpg_station[mp[S]-1] = true;\n    }\n    int s = mp[src] - 1, g = mp[dest] - 1, \n      ans = dijkstra(G, is_lpg_station, cap*10, s, g);\n    if(ans >= INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6010\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2010];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVVP G;\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++,G.push_back(VP());\n  if(index.find(t) == index.end())index[t] = idx++,G.push_back(VP());\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      G.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++,G.push_back(VP());\n      index[sdest] = idx++,G.push_back(VP());\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx < MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2010)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n    \n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint N,M,Cap;\n\nstruct Edge{\npublic:\n\tint to,cost;\n\tEdge(int a,int b){to=a;cost=b;}\n\tEdge(){to=0;cost=0;}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nconst int INF=1000000007;\n\nclass Info{\npublic: \n\tint now,total,rem;\n\tInfo(int a,int b,int c){now=a;total=b;rem=c;}\n\tbool operator < (const Info &a) const {return total>a.total;}\n};\n\nint get_cost(Graph g,int s,int t){\n\tvector<bool> visit(N*2,false);\n\tpriority_queue<Info> Q;\n\tQ.push(Info(s,0,Cap));\n\twhile(!Q.empty()){\n\t\tInfo top=Q.top();\n\t\tQ.pop();\n\t\tif(top.now==t){return top.total;}\n\t\tint pos=top.now; \n\t\tif(visit[top.now]) continue;\n\t\tvisit[top.now]=true;\n\t\tfor(int i=0;i<g[pos].size();i++){\n\t\t\tQ.push(Info(g[pos][i].to,top.total+g[pos][i].cost,top.rem-g[pos][i].cost));\n\t\t}\n\t}\n\treturn INF;\n}\n\nvoid solve()\n{\n\tCap*=10;\n\tmap<string,int> Idx;\n\tGraph V(N*2,vector<Edge>(0));\n\tint size=0;\n\tstring start,goal;\n\tcin>>start>>goal;\n\tIdx[start]=size++; Idx[goal]=size++;\n\tfor(int i=0;i<N;i++){\n\t\tstring s1,s2; int d;\n\t\tcin>>s1>>s2>>d;\n\t\tif(!Idx.count(s1)) Idx[s1]=size++;\n\t\tif(!Idx.count(s2)) Idx[s2]=size++;\n\t\tV[Idx[s1]].push_back(Edge(Idx[s2],d));\n\t\tV[Idx[s2]].push_back(Edge(Idx[s1],d));\n\t}\n\n\tvector<int> Sta(M+2);\n\tfor(int i=0;i<M;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tSta[i]=Idx[s];\n\t}\n\tSta[M]=Idx[start];Sta[M+1]=Idx[goal];\n\n\tGraph g(N*2);\n\n\tfor(int i=0;i<M+2;i++){\n\t\tfor(int j=0;j<M+2;j++){\n\t\t\tif(i==j) continue;\n\t\t\tint c=get_cost(V,Sta[i],Sta[j]);\n\t\t\tif(c<=Cap){\n\t\t\t\tg[Sta[i]].push_back(Edge(Sta[j],c));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint res=get_cost(g,Idx[start],Idx[goal]);\n\tres= res<INF ? res:-1;\n\tcout<<res<<endl;\n}\n\n\nint main()\n{\n\twhile(cin>>N>>M>>Cap){\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n, m, k, p, dist[6007][2017], c[3000]; bool u[3000]; vector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<map<int, int>> min_dist(n);\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(min_dist[v].find(rest) != end(min_dist[v])) continue;\n            min_dist[v][rest] = dist;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv].find(nrest) != end(min_dist[nv])) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e.second);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n#if 0\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  int used[N]={};\n  vector<vector<int> >D(cap+1,vector<int>(n,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n\n    if(pos==1) return d;\n    if(ls[pos])c=cap;\n    if(D[c][pos]<d||used[pos]>c)continue;\n    used[pos]=c;\n\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nc][nx]>nd)Q.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<Edge> edges(total_roads);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges[road_idx] = Edge(from_num,to_num,dist);\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVVP G;\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++,G.push_back(VP());\n  if(index.find(t) == index.end())index[t] = idx++,G.push_back(VP());\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      G.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++,G.push_back(VP());\n      index[sdest] = idx++,G.push_back(VP());\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx < MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n    \n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1<<30\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1,c2;\nint d;\nstring s;\nbool gas[6100];\nint num;\nvector<P> G[6100];\nmap<P,int> dis;\nmap<string,int> id;\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    cap *= 10;\n    num = 0;\n    id.clear();\n    id[src] = num++; id[dest] = num++;\n\n    for(int i=0;i<6100;i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      cin >> c1 >> c2 >> d;\n      if(id.find(c1) == id.end())id[c1] = num++;\n      if(id.find(c2) == id.end())id[c2] = num++;\n      G[id[c1]].push_back(P(d,id[c2]));\n      G[id[c2]].push_back(P(d,id[c1]));\n    }\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s;\n      gas[id[s]] = true;\n    }\n\n    dis.clear();\n    dis[P(id[src],cap)] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      int dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      if(pos == id[dest])break;\n\n      for(int i=0;i<G[pos].size();i++){\n\tint len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\tif(len > tank)continue;\n\tint ntank = tank - len;\n\tif(gas[nxt])ntank = cap;\n\n\tif(dis.find(P(nxt,ntank)) == dis.end()){\n\t  dis[P(nxt,ntank)] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++){\n      if(dis.find(P(id[dest],i)) != dis.end())ans = min(ans,dis[P(id[dest],i)]);\n    }\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MT make_tuple\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint N, M, C, SZ;\nvector<Edge> G[6010];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[src] = SZ++;\n\tcor[dest] = SZ++;\n\tC *= 10;\n\tREP(i,6010) G[i].clear();\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = SZ++;\n\t  if(!cor.count(s2)) cor[s2] = SZ++;\n\t  int u = cor[s1], v = cor[s2];\n\t  G[u].PB(Edge(v,d));\n\t  G[v].PB(Edge(u,d));\n\t}\n\n\tset<int> LPG;\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  LPG.insert(cor[s]);\n\t}\n\n\ttypedef tuple<int,int,int> Node;\n\tpriority_queue<Node, vector<Node>, greater<Node> > pq;\n\tVVI dist(SZ+10, VI(C+10,INF));\n\tdist[0][C] = 0;\n\tpq.push(MT(0,0,C));\n\n\tint ans = INF;\n\twhile(!pq.empty()){\n\t  auto tp = pq.top(); pq.pop();\n\t  int c, v, f;\n\t  tie(c,v,f) = tp;\n\n\t  if(v == 1){\n\t\tans = c; break;\n\t  }\n\t  if(dist[v][f] < c) continue;\n\t  for(auto& e: G[v]){\n\t\tint d = e.cost;\n\t\tif(f < d) continue;\n\t\tint nf = LPG.count(e.to)? C: f-d;\n\t\tif(dist[e.to][nf] > dist[v][f] + d){\n\t\t  dist[e.to][nf] = dist[v][f] + d;\n\t\t  pq.push(MT(dist[e.to][nf], e.to, nf));\n\t\t}\n\t  }\n\t}\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n, m, k, p, dist[6007][2017], c[3000]; bool u[3000];\nvector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<short, short, short>, vector<tuple<short, short, short>>, greater<tuple<short, short, short>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, (int)dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( n, vector<int>( n, INF ) );\n\tfor( int from = 0; from < nstat.size(); ++from ){\n\t\tint n_from = nstat[from];\n\t\tdist[n_from][n_from] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, nstat[from] ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_f = p.second;\n\t\t\tif( dist[n_from][n_f] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_from].size(); ++i ){\n\t\t\t\tint n_to = road[n_from][i].first;\n\t\t\t\tint ds = p.first + road[n_from][i].second;\n\t\t\t\t\n\t\t\t\tif( ds < cap && dist[n_from][n_to] > ds ){\n\t\t\t\t\tdist[n_from][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[n_from][n_to] <= cap && dp[to] > dp[from] + dist[n_from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[n_from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#define int short\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,remain,cost;\n\tnode(int index,int remain,int cost):index(index),remain(remain),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nconst int MAX=(1<<14);\nconst int NONE=-1;\n#define int int\nint main() {\n#define int short\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        int nc=cities.size();\n        vvi g(nc,vi(nc,NONE));\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(nc);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n\n        priority_queue<node> q;\n        q.push(node(src_i,cap,0));\n        vvi cost(nc,vi(cap+1,MAX));\n        cost[0][cap]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.remain]<cnode.cost){\n                continue;\n\t\t    }\n            REP(i,nc){\n                if(g[cnode.index][i]!=NONE){\n                    int newremain=cnode.remain-g[cnode.index][i];\n                    int newcost=cnode.cost+g[cnode.index][i];\n                    if(newremain>=0){\n                        newremain=station[i] ? cap : newremain;\n\t\t\t\t\t\tif(cost[i][newremain]>newcost){\n                            cost[i][newremain]=newcost;\n                            q.push(node(i,newremain,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n        int ans=MAX;\n        REP(i,cap+1){\n            ans=min(ans,cost[dst_i][i]);\n\t    }\n        cout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\nvector<string> ash;\nint x,n,m,cap,inf=1e8,gas[302],dgas[302][302],d[3000];\nstring cst[3000][2];\nstruct edge{int to,cost;};\nvector<edge> G[6000];\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,x) d[i]=inf;\n\td[s]=0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc;\n\t\tif(d[v]<p.fs) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> m >> cap;\n\t\tif(n==0) break;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tash.clear();\n\t\trep(i,n){\n\t\t\tcin >> cst[i][0] >> cst[i][1] >> d[i];\n\t\t\tash.push_back(cst[i][0]);\n\t\t\tash.push_back(cst[i][1]);\n\t\t}\n\t\tsort(ash.begin(),ash.end());\n\t\tash.erase(unique(ash.begin(),ash.end()),ash.end());\n\t\tx=ash.size();\n\t\trep(i,x) G[i].clear();\n\t\trep(i,n){\n\t\t\tint c0=lower_bound(ash.begin(),ash.end(),cst[i][0])-ash.begin();\n\t\t\tint c1=lower_bound(ash.begin(),ash.end(),cst[i][1])-ash.begin();\n\t\t\tG[c0].push_back({c1,d[i]});\n\t\t\tG[c1].push_back({c0,d[i]});\n\t\t}\n\t\trep(i,m){\n\t\t\tstring sst;\n\t\t\tcin >> sst;\n\t\t\tgas[i]=lower_bound(ash.begin(),ash.end(),sst)-ash.begin();\n\t\t}\n\t\tgas[m]=lower_bound(ash.begin(),ash.end(),src)-ash.begin();\n\t\tgas[m+1]=lower_bound(ash.begin(),ash.end(),dest)-ash.begin();\n\t\trep(i,m+2){\n\t\t\tdijkstra(gas[i]);\n\t\t\trep(j,m+2){\n\t\t\t\tif(d[gas[j]]<=cap*10) dgas[i][j]=d[gas[j]];\n\t\t\t\telse dgas[i][j]=inf;\n\t\t\t}\n\t\t}\n\t\trep(i,m+2) rep(j,m+2) rep(k,m+2) dgas[j][k]=min(dgas[j][k],dgas[j][i]+dgas[i][k]);\n\t\tif(dgas[m][m+1]==inf) dgas[m][m+1]=-1;\n\t\tcout << dgas[m][m+1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[3001][3001];\nbool is_LPG[301];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6000];\nstring city[6000];\nint gs[6000];\nint dist[256][6000];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+2) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n    //    cout << cost << \" \" << v << \" \" << cap << endl;\n    if(dist[cap][v] < cost) continue;\n    //    cout << G[v].size() << endl;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      //      cout << e.d << \" \" << cap << endl;\n      if(e.d > cap*10) continue;\n      int tar = max(cap-(e.d/10 + (e.d%10?1:0)), gs[e.to]*C);\n      //      cout << tar << \" \" << e.to << \" \" << dist[tar][e.to] << \" \" << dist[cap][v] << \" \" << e.d << endl;\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\t//\tcout << tar << endl;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n    rep(i,6000) G[i].clear();\n    recity.clear();\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n    rep(i,M){\n      string s;\n      cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    /*    rep(i, V){\n      cout << city[i] << endl;\n      rep(j, G[i].size()) cout << G[i][j].to << \" \"; cout << endl;\n      }*/\n\n    dijkstra(recity[src]);\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\t\tstring c1[6010], c2[6010];\n\t\tint d[6010];\n\t\tstring s[6010];\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge {string to; int cost; };\ntypedef pair<int, string> P;\n\nconst int inf = 1000000000;\nint V;\nmap<string, vector<edge> > G1;\nmap<string, vector<edge> > G2;\nset<string> allcities;\nmap<string, int> d;\n\nvoid dijkstra(string s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  for (string c : allcities) {\n    d[c] = inf;\n  }\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    string v = p.second;\n    if (d[v] < p.first) continue;\n    for (edge e : G1[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid dijkstra2(string s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  for (string c : allcities) {\n    d[c] = inf;\n  }\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    string v = p.second;\n    if (d[v] < p.first) continue;\n    for (edge e : G2[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if (n == 0 && m == 0 && cap == 0) break;\n    G1.clear();\n    G2.clear();\n    allcities.clear();\n    d.clear();\n    string src, dest;\n    cin >> src >> dest;\n    for (int i = 0; i < n; i++) {\n      string c1, c2;\n      int dis;\n      cin >> c1 >> c2 >> dis;\n      G1[c1].push_back((edge){c2, dis});\n      G1[c2].push_back((edge){c1, dis});\n      allcities.insert(c1);\n      allcities.insert(c2);\n    }\n    vector<string> lpg(m+2);\n    for (int i = 0; i < m; i++) {\n      string s;\n      cin >> s;\n      lpg[i] = s;\n    }\n    lpg[m] = src; lpg[m+1] = dest;\n    for (int i = 0; i < m+2; i++) {\n      dijkstra(lpg[i]);\n      for (int j = 0; j < m+2; j++) {\n\tif (j == i) continue;\n\tif (d[lpg[j]] <= 10 * cap)\n\t  G2[lpg[i]].push_back((edge){lpg[j], d[lpg[j]]});\n      }\n    }\n    dijkstra2(src);\n    if (d[dest] >= inf)\n      cout << -1 << endl;\n    else\n      cout << d[dest] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nmap<int, vector<pair<int, int> > >E;\nbool LPF[6010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\tE.clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 6010) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[3500];\nint d[3500][2005];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m, c;\n    cin >> n >> m >> c;\n    if(!n) break;\n    c *= 10;\n    string s, t;\n    cin >> s >> t;\n    map<string,int> mp;\n    int cnt = 0;\n    REP(i, 3500) g[i].clear();\n    REP(i, n) {\n      string x, y; int l;\n      cin >> x >> y >> l;\n      if(mp.find(x) == mp.end()) {\n        mp[x] = cnt++;\n      }\n      if(mp.find(y) == mp.end()) {\n        mp[y] = cnt++;\n      }\n      g[mp[x]].PB({mp[y], l});\n      g[mp[y]].PB({mp[x], l});\n    }\n    VI exist(cnt, 0);\n    REP(i, m) {\n      string str; cin >> str;\n      exist[mp[str]] = 1;\n    }\n    // cout << exist << endl;\n\n    // for(auto i: mp) cout << i << endl;\n\n    int src = mp[s], dst = mp[t];\n    REP(i, 3500) REP(j, 2005) d[i][j] = LLINF;\n    d[src][c] = 0;\n    priority_queue<VI, VVI, greater<VI>> que;\n    que.push({d[src][c], src, c});\n\n    while(que.size()) {\n      VI v = que.top(); que.pop();\n      // cout << v << endl;\n      if(v[0] > d[v[1]][v[2]]) continue;\n      if(v[1] == dst) break;\n      for(PII e: g[v[1]]) {\n        if(v[2]>=e.second && d[e.first][v[2]-e.second] > d[v[1]][v[2]] + e.second) {\n          int tmp = exist[e.first] == 1 ? c : v[2] - e.second;\n          d[e.first][tmp] = d[v[1]][v[2]] + e.second;\n          que.push({d[e.first][tmp], e.first, tmp});\n        }\n      }\n    }\n\n    int ans = LLINF;\n    REP(i, c+1) chmin(ans, d[dst][i]);\n    if(ans == LLINF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[400];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    lpg[getnum(s)]=1;\n  }\n\n  memset(vis,0,sizeof(vis));\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nc=ca-co;\n      if(vis[to][nc])continue;\n      q.push(mp(-cc-co,mp(nc,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>cap,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct edge{\n  int n,c;\n  edge(int n=0, int c=0):n(n),c(c){}\n};\n\nstruct state{\n  int n,c,cap;\n  state(int n=0, int c=0, int cap=0):n(n),c(c),cap(cap){}\n  bool operator < (const state &s) const {\n    return c > s.c;\n  }\n};\n\nconst int INF = 1 << 29;\nbool lpg[6000];\nint n,m,cap,cnt,d[6000][2001],goal;\nmap<string,int> mp;\nvector<edge> G[6000];\n\nvoid init(){\n  cnt = 0;\n  mp.clear();\n  for(int i=0;i<6000;i++) G[i].clear();\n  fill(lpg,lpg+6000,false);\n  fill(d[0],d[6000],INF);\n}\n\nvoid solve(){\n  priority_queue<state> Q;\n  state u(0,0,cap),v;\n  d[0][cap] = 0;\n\n  for(Q.push(u);!Q.empty();){\n    u = Q.top();\n    Q.pop();\n    //cout << u.n << ' ' << u.c << ' ' << u.cap << endl;\n\n    if(u.n == goal){\n      cout << u.c << endl;\n      return;\n    } else if(u.c > d[u.n][u.cap]) continue;\n\n    for(int i=0;i<G[u.n].size();i++){\n      v = state(G[u.n][i].n, u.c+G[u.n][i].c, u.cap-G[u.n][i].c);\n      if(v.cap >= 0 && v.c < d[v.n][v.cap]){\n        if(lpg[v.n]) v.cap = cap;\n        for(int j=v.cap;j>=0;j--) d[v.n][j] = min(d[v.n][j],v.c);\n        Q.push(v);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> n >> m >> cap && (n|m|cap)){\n    string str,str2;\n    init();\n    cin >> str >> str2;\n    mp[str] = cnt++;\n    if(mp.find(str2) == mp.end()) mp[str2] = cnt++;\n    goal = mp[str2];\n    cap *= 10;\n\n    for(int i=0;i<n;i++){\n      int c;\n      cin >> str >> str2 >> c;\n      if(mp.find(str) == mp.end()) mp[str] = cnt++;\n      if(mp.find(str2) == mp.end()) mp[str2] = cnt++;\n      //cout << mp[str] << ' ' << mp[str2] << ' ' << c << endl;\n      G[mp[str]].push_back(edge(mp[str2],c));\n      G[mp[str2]].push_back(edge(mp[str],c));\n    }\n\n    for(int i=0;i<m;i++){\n      cin >> str;\n      lpg[mp[str]] = true;\n    }\n\n    /*\nfor(int i=0;i<6;i++){\n      for(int j=0;j<G[i].size();j++) cout << i << \" -> \" << G[i][j].n << \" : \" << G[i][j].c << endl;\n    }\n    */\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nmap<string, int> ids;\nvector<P> roads[6000];\nvector<int> st;\nint cap;\nint N;\nint M;\nint dist[6000];\nvector<P> road2[302];\nvoid exec()\n{\n\tfill(roads,roads+6000, vector<P>());\n\tfill(road2,road2+302, vector<P>());\n\tst.clear();\n\tids.clear();\n\tcin >> N >> M >> cap;\n\tcap*=10;\n\tif((N|M|cap)==0)exit(0);\n\tstring in;\n\tcin >> in;\n\tint id=0;\n\tids[in]=id++;\n\tcin >> in;\n\tids[in]=id++;\n\tfor(int i=0;i<N;i++){\n\t\tstring c;\n\t\tint d;\n\t\tcin >> in >> c >> d;\n\t\tif(ids.find(in)==ids.end())\n\t\t{\n\t\t\tids[in]=id++;\n\t\t}\n\t\tif(ids.find(c)==ids.end()){\n\t\t\tids[c]=id++;\n\t\t}\n\t\tint a=ids[in];\n\t\tint b=ids[c];\n\t\troads[a].push_back(P(b,d));\n\t\troads[b].push_back(P(a,d));\n\t\t//cout << a << \", \" << b << \":: \" << d << endl;\n\t}\n\t/*\n\tfor(auto a:ids)\n\t{\n\t\tcout << a.first << \": \" << a.second << endl;\n\t}*/\n\tst.push_back(0);\n\tst.push_back(1);\n\tfor(int i=0;i<M;i++){\n\t\tcin >> in;\n\t\tint a=ids[in];\n\t\tif(a>1){\n\t\t\tst.push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<st.size();i++){\n\t\tfill(dist,dist+ids.size(),cap+1);\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P(0,st[i]));\n\t\tdist[st[i]]=0;\n\t\twhile(q.size()){\n\t\t\tint f=q.top().second;\n\t\t\tint d=q.top().first;\n\t\t\tq.pop();\n\t\t\tif(dist[f]<d)continue;\n\t\t\tfor(auto p:roads[f]){\n\t\t\t\tint b=p.first;\n\t\t\t\tint dd=d+p.second;\n\t\t\t\tif(dd<dist[b]){\n\t\t\t\t\tq.push(P(dd,b));\n\t\t\t\t\tdist[b]=dd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<st.size();j++){\n\t\t\tif(dist[st[j]]<=cap)\n\t\t\t{\n\t\t\t\troad2[i].push_back(P(j,dist[st[j]]));\n\t\t\t\t//cout << i << \", \" << j << \": \" << dist[st[j]] << \", \" << st[j] << \": \" << ids.size() << endl;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfill(dist,dist+st.size(),INT_MAX);\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P(0,0));\n\t\tdist[0]=0;\n\t\twhile(q.size()){\n\t\t\tint f=q.top().second;\n\t\t\tint d=q.top().first;\n\t\t\tq.pop();\n\t\t\tif(dist[f]<d)continue;\n\t\t\tfor(auto p:road2[f]){\n\t\t\t\tint b=p.first;\n\t\t\t\tint dd=d+p.second;\n\t\t\t\tif(dd<dist[b]){\n\t\t\t\t\tq.push(P(dd,b));\n\t\t\t\t\tdist[b]=dd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[1]<INT_MAX){\n\t\tcout << dist[1] << endl;\n\t}\n\telse\n\t{\n\t\tcout << -1 << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\nint N,M,cap;\nstruct edge{\n\tint v,w;\n\tedge(int _v,int _w):v(_v),w(_w){\n\n\t}\n};\nvector<edge> ve[3005];\nbool hasGas[3005];\nbool visited[3005];\nint res;\nvoid DFS(int u,int t,int cur,int total){\n\tif(u==t){\n\t\tres = min(res,total);\n\t}\n\tvisited[u]=true;\n\tif(hasGas[u])\n\t\tcur = cap*10;\n\tfor(int j=0;j<ve[u].size();j++){\n\t\tedge e = ve[u][j];\n\t\tif(!visited[e.v] && cur - e.w >= 0)\n\t\t\tDFS(e.v,t,cur-e.w,total+e.w);\n\t}\n}\n\n\n\n\nint main()\n{\n\t// freopen(\"5854.in\",\"r\",stdin);\n\twhile(scanf(\"%d%d%d \",&N,&M,&cap) && (N+M+cap)){\n\t\tfor(int i=0;i<3005;i++) ve[i].clear();\n\t\tint noCnt=0;\n\t\tmap<string,int> no;\n\t\tstring start,end;\n\t\tcin >> start >> end;\n\t\tstring p1,p2;\n\t\tint u,v,w;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> p1 >> p2;\n\t\t\tif(no.find(p1)==no.end())\n\t\t\t\tno[p1]=noCnt++;\n\t\t\tif(no.find(p2)==no.end())\n\t\t\t\tno[p2]=noCnt++;\n\t\t\tu = no[p1]; v = no[p2];\n\t\t\tscanf(\"%d \",&w);\n\t\t\tve[u].push_back(edge(v,w));\n\t\t\tve[v].push_back(edge(u,w));\n\t\t}\n\t\tmemset(hasGas,0,sizeof(hasGas));\n\t\tstring gasName;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> gasName;\n\t\t\thasGas[no[gasName]]=true;\n\t\t}\n\t\tint s = no[start],t = no[end];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tres = 1e8;\n\t\tDFS(s,t,cap*10,0);\n\t\tif(res==1e8)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(;;){\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if(n == 0) break;\n    cap *= 10;\n    map<string,int> map;\n    string currN, destN;\n    cin >> currN >> destN;\n    auto mapping = [&map](const string &city) {\n      if(map.find(city) == map.end()) map.insert(make_pair(city, map.size()));\n      return map[city];\n    };\n    int curr = mapping(currN);\n    int dest = mapping(destN);\n    vector<vector<pair<int,int>>> es(2000,vector<pair<int,int>>());\n    for(int i = 0; i < n; i++) {\n      string src, tgt;\n      int d;\n      cin >> src >> tgt >> d;\n      int s = mapping(src);\n      int t = mapping(tgt);\n      es[s].push_back(make_pair(t, d));\n      es[t].push_back(make_pair(s, d));\n    }\n    vector<bool> gs(2000, false);\n    for(int i = 0; i < m; i++) {\n      string city;\n      cin >> city;\n      gs[mapping(city)] = true;\n    }\n    const int BIG = 3000*2000*2*2;\n    vector<vector<int>> ds(n, vector<int>(cap+1, BIG));\n    vector<vector<bool>> fixed(n, vector<bool>(cap+1, false));\n    priority_queue<pair<int, pair<int, int>>> que;\n    // Dijkstra\n    que.push(make_pair(0, make_pair(curr, cap)));\n    while(que.size() > 0) {\n      auto dvc = que.top();\n      que.pop();\n      const int d = dvc.first;\n      const int v = dvc.second.first;\n      const int c = dvc.second.second;\n      if(fixed[v][c]) continue;\n      fixed[v][c] = true;\n      ds[v][c] = d;\n      for(auto it = es[v].begin(); it != es[v].end(); it++) {\n        int cc = c - it->second;\n        if(cc >= 0) {\n          int i = it->first;\n          int dd = d + it->second;\n          if(gs[i]) cc = cap; // gas station\n          if(ds[i][cc] > dd){\n            ds[i][cc] = dd;\n            que.push(make_pair(dd, make_pair(i, cc)));\n          }\n        }\n      }\n    }\n    int min = BIG;\n    for(int i = 0; i <= cap; i++) {\n      if(min > ds[dest][i]) {\n        min = ds[dest][i];\n      }\n    }\n    cout << (min == BIG ? -1 : min) << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nmap<pair<int, int>, int> dis;\nvector<pair<short, short> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    dis.clear();\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    int res = 1e9;\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (dis.count(make_pair(pos, f)) && dis[make_pair(pos, f)] <= cost) continue;\n      dis[make_pair(pos, f)] = cost;\n      if (mp[dest] == pos) {\n\tres = cost;\n\tbreak;\n      }\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis.count(make_pair(np, nf)) && dis[make_pair(np, nf)] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6000];\nstring city[6000];\nint gs[6000];\nint dist[256][6000];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap*10) continue;\n      int tar = max(cap-(e.d/10 + (e.d%10?1:0)), gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n    rep(i,6000) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n    rep(i,M){\n      string s;\n      cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    /*    rep(i,V){\n      cout << city[i] << \" \";\n      rep(j,G[i].size()) cout << G[i][j].to << \" \"; cout << endl;\n      }*/\n\n    dijkstra(recity[src]);\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<vector<Node> > nodes(total_roads*2);\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 1000000000\n\nint dist[310][310];\nint dp2[6010];\nvector<int> st;\nvector<int> e[6010];\nvector<int> c[6010];\nmap<string,int> id;\nint n,m,cap;\nint to[310];\nint from[310];\nbool is[6010];\nint wh[6010];\n\n\nvoid solve(int x) {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\tfor (int i=0; i<m; i++) dist[wh[x]][i] = INF;\n\tto[wh[x]] = INF;\n\tfrom[wh[x]] = INF;\n\tdp2[x] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,x));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (is[p] && cur<=cap) {\n\t\t\tdist[wh[x]][wh[p]] = cur;\n\t\t}\n\t\tif (p==0) from[wh[x]] = cur;\n\t\tif (p==1) to[wh[x]] = cur;\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint solve2() {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\n\tdp2[0] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,0));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (p==1) {\n\t\t\treturn cur;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INF;\n}\n\t\t\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&n,&m,&cap) && n!=0) {\n\t\tid.clear();\n\t\tcap *= 10;\n\t\tfor (int i=0; i<2*n; i++) e[i].clear();\n\t\tfor (int i=0; i<2*n; i++) c[i].clear();\n\t\tint cnt = 2;\n\t\tst.clear();\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tid[src] = 0;\n\t\tid[dest] = 1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tstring s1,s2;\n\t\t\tcin>>s1>>s2;\n\t\t\tif (id.find(s1)==id.end()) id[s1] = cnt++;\n\t\t\tif (id.find(s2)==id.end()) id[s2] = cnt++;\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\te[id[s1]].push_back(id[s2]);\n\t\t\te[id[s2]].push_back(id[s1]);\n\t\t\tc[id[s1]].push_back(h);\n\t\t\tc[id[s2]].push_back(h);\n\t\t}\n\t\tfor (int i=0; i<2*n; i++) is[i] = 0;\n\t\tfor (int i=0; i<2*n; i++) wh[i] = 0;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif (id.find(s)==id.end()) continue;\n\t\t\tst.push_back(id[s]);\n\t\t\tis[id[s]] = 1;\n\t\t\twh[id[s]] = i;\n\t\t}\n\t\tn = cnt;\n\t\t\n\t\tfor (int i=0; i<st.size(); i++) {\n\t\t\tsolve(st[i]);\n\t\t}\n\t\t\n\t\t//for (int i=0; i<m; i++) {\n\t\t//\tfor (int j=0; j<m; j++) cout<<dist[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t\n\t\tint ans = solve2();\n\t\t\n\t\tif (ans>cap) ans = INF;\n\t\t\n\t\tfor (int k=0; k<m; k++) for (int i=0; i<m; i++) for (int j=0; j<m; j++) \n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tfor (int i=0; i<m; i++) for (int j=0; j<m; j++) {\n\t\t\tif (from[i]<=cap && to[j]<=cap) {\n\t\t\t\tans = min(ans, from[i] + to[j] + dist[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans==INF) cout<<-1<<endl; \n\t\telse cout<<ans<<endl;\n\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    string to;\n    int cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, cap;\n    while(cin >> N >> M >> cap, N) {\n        string src, dest;\n        cin >> src >> dest;\n        map<string, vector<edge>> g;\n        map<string, bool> gas;\n        map<string, vector<int>> res;  \n        cap *= 10;\n        for(int i=0; i<N; ++i) {\n            string c1, c2;\n            int d;\n            cin >> c1 >> c2 >> d;\n            g[c1].push_back(edge{c2, d});\n            g[c2].push_back(edge{c1, d});\n            if(res[c1].size() == 0) {\n                res[c1].resize(cap+1, INF);\n            }\n            if(res[c2].size() == 0) {\n                res[c2].resize(cap+1, INF);\n            }\n        }\n        for(int i=0; i<M; ++i) {\n            string s;\n            cin >> s;\n            gas[s] = true;\n        }\n        res[src][cap] = 0;\n        using state = tuple<int, int, string>;\n        priority_queue<state, vector<state>, greater<state>> que;\n        que.push(make_tuple(0, cap, src));\n        while(!que.empty()) {\n            int cd, rest;\n            string c;\n            tie(cd, rest, c) = que.top();\n            que.pop();\n            if(res[c][rest] < cd) {\n                continue;\n            }\n            for(auto& e : g[c]) {\n                if(e.cost > rest) {\n                    continue;\n                }\n                int nr = (gas[e.to] ? cap : rest - e.cost);\n                if(res[e.to][nr] > res[c][rest] + e.cost) {\n                    res[e.to][nr] = res[c][rest] + e.cost;\n                    que.push(make_tuple(res[e.to][nr], nr, e.to));\n                }\n            }\n        }\n        int r = (res[dest].size() == 0 ? INF : *min_element(res[dest].begin(), res[dest].end()));\n        if(r == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << r << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      int idx=(st.count(next)?cap*10:now.c-c);\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[next][idx]);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int> > v[6005],v2[6005];\nmap<string,int> mp;\nint mpn,n,m,k;\nbool c[6005];\nunsigned dis[6005];\nchar a[20];\nint b[305];\nqueue<int> q;\n\ninline int s2i(string x)\n{\n    if(!mp.count(x))\n        return mp[x]=mpn++;\n    return mp[x];\n}\n\nvoid spfa(int st)\n{\n    int i,j,x,y;\n    memset(dis,-1,sizeof(dis));\n    dis[st]=0;\n    q.push(st);\n    while(!q.empty())\n    {\n        x=q.front();\n        q.pop();\n        for(i=0,j=v[x].size();i<j;i++)\n        {\n            y=v[x][i].first;\n            if(dis[x]+v[x][i].second>(unsigned)k||dis[x]+v[x][i].second>dis[y])\n                continue;\n            dis[y]=dis[x]+v[x][i].second;\n            q.push(y);\n        }\n    }\n    for(i=0;i<mpn;i++)\n        if(c[i]&&i!=st&&dis[i]!=-1)\n            v2[st].push_back(make_pair(i,dis[i]));\n}\n\nint main()\n{\n    int st,ed,i,j,x,y,w;\n    while(~scanf(\"%d%d%d\",&n,&m,&k)&&(n+m+k))\n    {\n        memset(c,0,sizeof(c));\n        mpn=0;k*=10;\n        scanf(\"%s\",a);st=s2i(a);\n        scanf(\"%s\",a);ed=s2i(a);\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%s\",a);x=s2i(a);\n            scanf(\"%s\",a);y=s2i(a);\n            scanf(\"%d\",&w);\n            v[x].push_back(make_pair(y,w));\n            v[y].push_back(make_pair(x,w));\n        }\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",a);\n            c[b[i]=s2i(a)]=1;\n        }\n        c[st]=c[ed]=1;\n        spfa(st);\n        for(i=0;i<m;i++)\n            spfa(b[i]);\n        memset(dis,-1,sizeof(dis));\n        dis[st]=0;\n        q.push(st);\n        while(!q.empty())\n        {\n            x=q.front();\n            q.pop();\n            for(i=0,j=v2[x].size();i<j;i++)\n            {\n                y=v2[x][i].first;\n                if(dis[x]+v2[x][i].second<dis[y])\n                {\n                    dis[y]=dis[x]+v2[x][i].second;\n                    q.push(y);\n                }\n            }\n        }\n        printf(\"%d\\n\",dis[ed]);\n        for(i=0;i<mpn;i++)\n            v[i].clear(),v2[i].clear();\n        mp.clear();\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \t//d[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nmap<string,int> mp;\nstruct node{\n    int x;\n    int res;\n    node(int x,int res):x(x),res(res){\n    }\n    node(){}\n}Q[1010000];\nint l,r;\nstruct edge{\n    int to;\n    int len;\n    int next;\n\n}e[7000];\nint head[7000],num;\nint N,M;//轤ケ謨ー霎ケ謨ー\n\nint vis[7000][2005];\nvoid add(int from,int to,int len){\n    e[num].to=to;\n    e[num].len=len;\n    e[num].next=head[from];\n    head[from]=num++;\n}\nint dis[7000];\nbool ss[7000];\nvoid spfa(int s,int t,int initlen){\n\n    for(int i=0;i<=N+1;i++)dis[i]=-1;\n    dis[s]=0;\n    memset(vis,0,sizeof(vis));\n    l=r=0;\n    node u,o;\n    Q[r++]=node(s,initlen);\n    while(l!=r){\n        u=Q[l];l=(l+1)%1000000;\n        vis[u.x][u.res]=0;\n        for(int i=head[u.x];i!=-1;i=e[i].next)if(u.res>=e[i].len&&(dis[e[i].to]==-1||dis[e[i].to]>dis[u.x]+e[i].len)){\n            dis[e[i].to]=dis[u.x]+e[i].len;\n            o.x=e[i].to;o.res=u.res-e[i].len;\n            if(ss[o.x]){o.res=initlen;}\n            if(!vis[o.x][o.res]){\n                Q[r]=o;r=(r+1)%1000000;\n                vis[o.x][o.res]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",dis[t]);\n\n}\nvoid init(){\n    memset(head,-1,sizeof(head));\n    num=0;\n    memset(ss,0,sizeof(ss));\n\n}\nint flag;\nint insert(char str[]){\n    if(mp.find((string)(str))==mp.end()){\n            mp[(string)(str)]=flag++;\n    }\n    return mp[(string)(str)];\n}\nint main(){\n    int n,stop,cap;\n\n    int s,t;\n    int w;\n    char str1[100],str2[100];\n    while(scanf(\"%d%d%d\",&n,&stop,&cap),n||stop||cap){\n        mp.clear();\n        flag=0;\n        init();\n        scanf(\"%s %s\",str1,str2);\n        s=insert((str1));\n        t=insert((str2));\n        for(int i=0;i<n;i++){\n            scanf(\"%s%s%d\",str1,str2,&w);\n            int x=insert(str1),y=insert(str2);\n            add(x,y,w);\n            add(y,x,w);\n        }\n        for(int i=0;i<stop;i++){\n            scanf(\"%s\",str1);\n            int x=insert(str1);\n            ss[x]=1;\n        }\n\n        N=flag;\n        spfa(s,t,cap*10);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6010\n#define MAX_CP 2010\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst;\nmap<int,bool> LPG;\nvector<Edge> G[MAX];\nint dist[MAX][MAX_CP];\n\nvoid init(){\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  cap *= 10;\n  fill(dist[0],dist[0]+MAX*MAX_CP,INF);\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = LPG[v] ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    int idx = 1; init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG[mp[a]] = true;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\t\tstring c1[6010], c2[6010];\n\t\tint d[6010];\n\t\tstring s[6010];\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tdijkstra(city2num[src], cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[city2num[dest]][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 3000) continue;\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_sum_dist,int arg_fuel){\n\t\ttown = arg_town;\n\t\tsum_dist = arg_sum_dist;\n\t\tfuel = arg_fuel;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tint town,sum_dist,fuel;\n};\n\nchar town_table[6000][15];\nbool have_station[6000];\n\nint town_index,N,M,start = 0,goal = 1,capacity;\nint** min_dist;\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\n\ttown_index = 0;\n\n\tchar left[16],right[16];\n\tscanf(\"%s %s\",left,right);\n\n\tstrcpy(town_table[town_index++],left);\n\tstrcpy(town_table[town_index++],right);\n\n\tint dist;\n\n\tbool FLG;\n\tint left_index,right_index;\n\n\tvector<Info> V[6000];\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s %s %d\",left,right,&dist);\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\tFLG = true;\n\t\t\t\tleft_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],left);\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index;i++){\n\t\t\tif(strCmp(town_table[i],right)){\n\t\t\t\tFLG = true;\n\t\t\t\tright_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],right);\n\t\t}\n\n\t\tV[left_index].push_back(Info(right_index,dist));\n\t\tV[right_index].push_back(Info(left_index,dist));\n\t}\n\n\tfor(int i = 0; i < town_index;i++)have_station[i] = false;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",left);\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\thave_station[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < town_index; i++){\n\t\tfor(int k = 0; k <= 10*capacity; k++)min_dist[i][k] = BIG_NUM;\n\t}\n\n\tpriority_queue<Data> Q;\n\n\tmin_dist[0][10*capacity] = 0;\n\tQ.push(Data(0,0,10*capacity));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().town == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().town][Q.top().fuel]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().town].size(); i++){\n\t\t\t\tif(V[Q.top().town][i].dist <= Q.top().fuel){\n\n\t\t\t\t\tif(have_station[V[Q.top().town][i].to]){\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][10*capacity] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][10*capacity] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,10*capacity));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,Q.top().fuel-V[Q.top().town][i].dist));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\n\tfor(int i = 0; i <= 10*capacity; i++)ans = min(ans,min_dist[1][i]);\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_dist = new int*[6000];\n\tfor(int i = 0; i < 6000; i++)min_dist[i] = new int[2001];\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&capacity);\n\t\tif(N == 0 && M == 0 && capacity == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  static priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint s_n, m; int c;\nmap<string, int> mp;\nint n = 2;\nint to_id(const string &s) {\n\tif (mp[s])return mp[s];\n\telse {\n\t\tn++; mp[s] = n; return n;\n\t}\n}\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[3001];\nvector<edge> trueG[3001];\nint d[3001];\nvoid init(int s) {\n\trep1(i, n) {\n\t\td[i] = mod;\n\t}\n\td[s] = 0;\n}\nbool needed[3001];\n\npriority_queue<P,vector<P>,greater<P>> q;\nvoid dijkstra(int sta) {\n\tinit(sta);\n\tq.push({ 0,sta });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\trep(j, G[v].size()) {\n\t\t\tint to = G[v][j].to;\n\t\t\tif (p.first + G[v][j].cost < d[to]) {\n\t\t\t\td[to] = p.first + G[v][j].cost;\n\t\t\t\tq.push({ d[to],to });\n\t\t\t}\n\t\t}\n\t}\n\trep1(i, n) {\n\t\tif (i == sta)continue;\n\t\tif (!needed[i])continue;\n\t\tif (d[i] <= 10 * c) {\n\t\t\ttrueG[sta].push_back({ i,d[i] });\n\t\t}\n\t}\n}\nvoid all_init() {\n\trep1(i, n) {\n\t\tG[i].clear();\n\t\ttrueG[i].clear();\n\t}\n\tmp.clear();\n\tn = 2;\n}\nint main() {\n\twhile (cin >> m >> s_n >> c,m) {\n\t\tall_init();\n\t\tstring in1, in2;\n\t\tcin >> in1 >> in2;\n\t\tmp[in1] = 1; mp[in2] = 2;\n\t\trep(i, m) {\n\t\t\tint z;\n\t\t\tcin >> in1 >> in2 >> z;\n\t\t\tint i1 = to_id(in1), i2 = to_id(in2);\n\t\t\tG[i1].push_back({ i2,z });\n\t\t\tG[i2].push_back({ i1,z });\n\t\t}\n\t\tneeded[1] = needed[2] = true;\n\t\trep(i, s_n) {\n\t\t\tcin >> in1;\n\t\t\tneeded[to_id(in1)] = true;\n\t\t}\n\t\trep1(i, n)if (needed[i])dijkstra(i);\n\t\tinit(1);\n\t\tq.push({ 0,1 });\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\trep(j, trueG[v].size()) {\n\t\t\t\tint to = trueG[v][j].to;\n\t\t\t\tint cost = p.first + trueG[v][j].cost;\n\t\t\t\tif (cost < d[to]) {\n\t\t\t\t\td[to] = cost;\n\t\t\t\t\tq.push({ d[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[2] == mod)cout << -1 << endl;\n\t\telse cout << d[2] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define eps 1e-8\nmap<string,int>mp;\nint n,m,cap;\nint tot;\nstring st,ed;\nbool f[3005];\nint dis[3005];\nbool in[3005];\nstruct node\n{\n    int en;\n    int v;\n};\nvector<node>g[3005];\nvector<node>fin[3005];\nvoid spfa_ini(int root)\n{\n    memset(in,0,tot*sizeof(bool));\n    queue<int>q;\n    q.push(root);\n    for(int i=1;i<tot;i++) dis[i]=INF;\n    dis[root]=0;\n    in[root]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        in[now]=0;\n        for(int i=0;i<g[now].size();i++)\n        {\n            int temp=g[now][i].en;\n            int val=g[now][i].v;\n            if(dis[temp]>dis[now]+val)\n            {\n                dis[temp]=dis[now]+val;\n                if(!in[temp])   q.push(temp);\n            }\n        }\n    }\n    for(int i=1;i<tot;i++)\n    {\n        if(i==root) continue;\n        if(f[i]&&dis[i]<=cap*10)\n        {\n            node temp;\n            temp.en=i;\n            temp.v=dis[i];\n            fin[root].push_back(temp);\n        }\n    }\n}\n\nvoid spfa()\n{\n    queue<int>q;\n    for(int i=1;i<tot;i++)  dis[i]=INF;\n    dis[mp[st]]=0;\n    in[mp[st]]=1;\n    q.push(mp[st]);\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        in[now]=0;\n        for(int i=0;i<fin[now].size();i++)\n        {\n            int temp=fin[now][i].en;\n            int val=fin[now][i].v;\n            if(dis[temp]>dis[now]+val)\n            {\n                dis[temp]=dis[now]+val;\n                if(!in[temp])   q.push(temp);\n            }\n        }\n    }\n}\nvoid ini()\n{\n    mp.clear();\n    for(int i=1;i<tot;i++)\n    {\n        g[i].clear();\n        fin[i].clear();\n    }\n}\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d%d%d\",&n,&m,&cap);\n        if(n==0&&m==0&&cap==0)  break;\n        cin>>st>>ed;\n        mp[st]=1;\n        mp[ed]=2;\n        tot=3;\n        for(int i=0;i<n;i++)\n        {\n            string a,b;\n            int c;\n            cin>>a>>b>>c;\n            if(!mp[a])  mp[a]=tot++;\n            if(!mp[b])  mp[b]=tot++;\n            node temp;\n            temp.en=mp[b];\n            temp.v=c;\n            g[mp[a]].push_back(temp);\n            temp.en=mp[a];\n            g[mp[b]].push_back(temp);\n        }\n        memset(f,0,tot*sizeof(bool));\n        for(int i=0;i<m;i++)\n        {\n            string a;\n            cin>>a;\n            f[mp[a]]=1;\n        }\n        f[mp[ed]]=1;\n        f[mp[st]]=1;\n        for(int i=1;i<=n;i++)\n            if(f[i]&&i!=mp[ed])    spfa_ini(i);\n        spfa();\n        if(dis[mp[ed]]==INF)    printf(\"-1\\n\");\n        else printf(\"%d\\n\",dis[mp[ed]]);\n        ini();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 7000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 6001\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    //node.erase(unique(all(node)),node.end());\n  \tunique(all(node));\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 2000) continue;\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 2000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,cost;\n\tnode(int index,int cost):index(index),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint main() {\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        int nc=cities.size();\n        vvi g(nc,vi(nc,NONE));\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(nc);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n\t\tint src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n        \n\t\tvi st_city;\n        REP(i,nc){\n            if(station[i]){\n                st_city.push_back(i);\n\t\t\t}\n\t\t}\n        st_city.push_back(src_i);\n        st_city.push_back(dst_i);\n\n        vvi gg(st_city.size(),vi(st_city.size(),MAX));\n        REP(i,st_city.size()){\n            gg[i][i]=0;\n\t\t}\n\n        REP(from,st_city.size()){\n            FOR(to,from+1,st_city.size()){\n                priority_queue<node> q;\n                q.push(node(from,0));\n                vi cost(st_city.size(),MAX);\n                cost[from]=0;\n                while(!q.empty()){\n                    node cnode=q.top();q.pop();\n                    if(cost[cnode.index]<cnode.cost){\n                        continue;\n\t\t            }\n                    REP(i,st_city.size()){\n                        if(g[st_city[cnode.index]][st_city[i]]!=NONE){\n                            int newcost=cnode.cost+g[st_city[cnode.index]][st_city[i]];\n\t\t\t\t\t\t    if(cost[i]>newcost){\n                                cost[i]=newcost;\n                                q.push(node(i,newcost));\n\t\t\t\t\t\t    }\n\t\t\t            }\n\t\t            }\n\t            }\n                gg[from][to]=cost[to];\n                gg[to][from]=cost[to];\n\t\t    }\n\t\t}\n\n        vvi gg2(gg);\n        REP(i,st_city.size()){\n            REP(j,st_city.size()){\n                if(gg2[i][j]>cap)\n\t\t        gg[i][j]=MAX;\n\t\t\t}\n\t\t}\n        REP(k,st_city.size()){\n            REP(i,st_city.size()){\n                REP(j,st_city.size()){\n                    gg[i][j]=min(gg[i][j],gg[i][k]+gg[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        int ans=gg[st_city.size()-2][st_city.size()-1];\n\t\tcout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<30;\n\nstruct P{\n    int s1;\n    int s2;\n    int d;\n    P(){}\n    ~P(){}\n    P(int a, int b, int c) : s1(a), s2(b), d(c) {}\n    P(const P& r) : s1(r.s1), s2(r.s2), d(r.d) {}\n    bool operator < (const P& r) const {\n        return (s1 == r.s1 ? s2 < r.s2 : s1 < r.s1);\n    }\n};\n\nstruct Q{\n    int pos;\n    int fuel;\n    int dist;\n    vector<int> visited;\n    Q(){}\n    ~Q(){}\n    Q(int p, int f, int d, vector<int> v) : pos(p), fuel(f), dist(d), visited(v) {}\n    Q(const Q& r) : pos(r.pos), fuel(r.fuel), dist(r.dist), visited(r.visited) {}\n};\n\ntypedef pair<int, int> PR;\n\nint main(){\n    int n, m, cap, x;\n    vector<int> EMPTY;\n    while(cin >> n >> m >> cap, n||m||cap){\n        string src, dest;\n        cin >> src >> dest;\n        map<string, int> name;\n        vector<P> path(3000);\n        name[src] = 0;\n        name[dest] = 1;\n        int nn = 2;\n        string c1, c2;\n        int d;\n        vector<int> gs(n, 0);\n        for(x = 0; x < n; x++){\n            cin >> c1 >> c2 >> d;\n            if( name.find(c1) == name.end() ){\n                name[c1] = nn++;\n            }\n            if( name.find(c2) == name.end() ){\n                name[c2] = nn++;\n            }\n            path.push_back( P(name[c1], name[c2], d) );\n            path.push_back( P(name[c2], name[c1], d) );\n        }\n        sort(path.begin(), path.end());\n        for(x = 0; x < m; x++){\n            cin >> c1;\n            gs[ name[c1] ] = 1;\n        }\n        queue< Q > que;\n        que.push( Q(0, cap*10, 0, EMPTY) );\n        int mindist = INF;\n        while( !que.empty() ){\n            Q q = que.front();\n            que.pop();\n            vector<P>::iterator begin = lower_bound(path.begin(), path.end(),\n                                                    P(q.pos, -1, -1));\n            vector<P>::iterator end = lower_bound(path.begin(), path.end(),\n                                                  P(q.pos+1, -1, -1));\n            for(vector<P>::iterator nxt = begin;\n                    nxt != end; nxt++){\n                if( nxt->d > q.fuel ){ continue; }\n                if( nxt->s2 == 1 ){\n                    if( q.dist+nxt->d < mindist ){ mindist = q.dist+nxt->d; }\n                    continue;\n                }\n                bool ok = true;\n                for(vector<int>::iterator itr = q.visited.begin();\n                        itr != q.visited.end(); itr++){\n                    if( *itr == nxt->s2 ){\n                        ok = false;\n                        break;\n                    }\n                }\n                if( !ok ) continue;\n                vector<int> nv = q.visited;\n                nv.push_back(q.pos);\n                if( gs[ nxt->s2 ] ){\n                    que.push( Q(nxt->s2, cap*10, q.dist+nxt->d, nv) );\n                }else{\n                    que.push( Q(nxt->s2, q.fuel - nxt->d, q.dist+nxt->d, nv) );\n                }\n            }\n        }\n        cout << ((mindist == INF) ? -1 : mindist) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n  for(int i=0;i<=cap*10;i++)d[s][i]=0;\n\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]>=INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n  int id,cost,gas;\n\n  State(){}\n  State(int _id,int _cost,int _gas){\n    id = _id;\n    cost = _cost;\n    gas = _gas;\n  }\n\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint n,m,cap;\nint src,dest;\nvector<P> t[6002];\nbool flg[6002];\n\nbool closed[6002][2002];\n\nmap<string,int> name;\n\nint trans(string s){\n  if(name.find(s) == name.end()){\n    int size = name.size();\n    name[s] = size;\n    return size;\n  }\n  else{\n    return name[s];\n  }\n  return -1;\n}\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(src,0,cap));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n    if(closed[st.id][st.gas]) continue;\n    closed[st.id][st.gas] = true;\n\n    if(st.id == dest){\n      cout<<st.cost<<endl;\n      return ;\n    }\n\n    if(flg[st.id]){\n      st.gas = cap;\n    }\n\n    rep(i,t[st.id].size()){\n      P p = t[st.id][i];\n      if(st.gas >= p.second){\n        open.push(State(p.first,st.cost+p.second,st.gas-p.second));\n      }\n    }\n  }\n\n  cout<<-1<<endl;\n}\n\nint main(){\n  while(cin>>m>>n>>cap,m||n||cap){\n    cap *= 10;\n    name.clear();\n\n    string src_s,dest_s;\n    cin>>src_s>>dest_s;\n    src = trans(src_s);\n    dest = trans(dest_s);\n\n    rep(i,6002) t[i].clear();\n\n    rep(i,m){\n      string a_s,b_s;\n      int a,b,d;\n\n      cin>>a_s>>b_s>>d;\n      a = trans(a_s);\n      b = trans(b_s);\n\n      t[a].push_back(P(b,d));\n      t[b].push_back(P(a,d));\n    }\n\n    memset(flg,0,sizeof(flg));\n    rep(i,n){\n      string id_s;\n      int id;\n      cin>>id_s;\n      flg[trans(id_s)] = true;\n    }\n\n    /*\n    rep(i,name.size()){\n      cout<<i<<\":\";\n      rep(j,t[i].size()){\n        cout<<t[i][j].first<<\",\"<<t[i][j].second<<\"   \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1318>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nll N,M,cap;\nmap<string,int> city2idx;\nvector<string> citys;\nll solve(){\n    ll res = -1;\n    city2idx.clear(); citys.clear();\n    \n    string src,dest; cin >> src >> dest;\n    citys.push_back(src); citys.push_back(dest);\n    vector<string> c1(N),c2(N); vector<ll> d(N);\n    for(int i = 0; i < N;i++){\n        cin >> c1[i] >> c2[i] >> d[i];\n        citys.push_back(c1[i]); citys.push_back(c2[i]);\n    }\n    vector<string> s(M);\n    for(int i = 0; i < M;i++){\n        cin >> s[i];\n        citys.push_back(s[i]);\n    }\n    int idx = 0;\n    sort(citys.begin(),citys.end());\n    citys.erase(unique(citys.begin(),citys.end()),citys.end());\n    for(string& city:citys){\n        city2idx[city] = idx++;\n    }\n    int S = city2idx[src],T = city2idx[dest];\n    vector<vector<pll>> G(citys.size());\n    for(int i = 0; i < N;i++){\n        ll u = city2idx[c1[i]], v = city2idx[c2[i]];\n        G[u].push_back(make_pair(v,d[i]));\n        G[v].push_back(make_pair(u,d[i]));\n    }\n    vector<int> stations(citys.size());\n    for(int i = 0; i < M;i++){\n        ll n = city2idx[s[i]];\n        stations[n] = 1;\n    }\n    vector<vector<ll>> dist(citys.size(),vector<ll>(cap*10 + 1,LINF));\n    dist[S] = vector<ll>(cap*10+1,0);\n    queue<pll> q; q.push({S,0});\n    while(q.size()){\n        ll n,C; tie(n,C) = q.front(); q.pop();\n        if(stations[n]){ dist[n][0] = min(dist[n][0],dist[n][C]); C = 0;}\n        for(auto e:G[n]){\n            ll next = e.first, cost = e.second;\n           if(C + cost > cap*10) continue;\n            if(dist[next][C+cost] > dist[n][C] + cost){\n                dist[next][C+cost] = dist[n][C] + cost;\n                q.push(make_pair(next,C+cost));\n            }\n        }\n    }\n    res = *min_element(dist[T].begin(),dist[T].end());\n    if(res == LINF) return -1;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N >> M >> cap,N){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\nint N,M,cap;\nstruct edge{\n\tint v,w;\n\tedge(int _v,int _w):v(_v),w(_w){\n\n\t}\n};\nvector<edge> ve[50005];\nbool hasGas[50005];\nbool visited[50005];\nint res;\nvoid DFS(int u,int t,int cur,int total){\n\tif(u==t){\n\t\tres = min(res,total);\n\t}\n\tvisited[u]=true;\n\tif(hasGas[u])\n\t\tcur = cap*10;\n\tfor(int j=0;j<ve[u].size();j++){\n\t\tedge e = ve[u][j];\n\t\tif(!visited[e.v] && cur - e.w >= 0)\n\t\t\tDFS(e.v,t,cur-e.w,total+e.w);\n\t}\n}\n\n\n\n\nint main()\n{\n\t// freopen(\"5854.in\",\"r\",stdin);\n\twhile(scanf(\"%d%d%d \",&N,&M,&cap) && (N+M+cap)){\n\t\tfor(int i=0;i<50005;i++) ve[i].clear();\n\t\tint noCnt=0;\n\t\tmap<string,int> no;\n\t\tstring start,end;\n\t\tcin >> start >> end;\n\t\tstring p1,p2;\n\t\tint u,v,w;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> p1 >> p2;\n\t\t\tif(no.find(p1)==no.end())\n\t\t\t\tno[p1]=noCnt++;\n\t\t\tif(no.find(p2)==no.end())\n\t\t\t\tno[p2]=noCnt++;\n\t\t\tu = no[p1]; v = no[p2];\n\t\t\tscanf(\"%d \",&w);\n\t\t\tve[u].push_back(edge(v,w));\n\t\t\tve[v].push_back(edge(u,w));\n\t\t}\n\t\tmemset(hasGas,0,sizeof(hasGas));\n\t\tstring gasName;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> gasName;\n\t\t\thasGas[no[gasName]]=true;\n\t\t}\n\t\tint s = no[start],t = no[end];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tres = 1e8;\n\t\tDFS(s,t,cap*10,0);\n\t\tif(res==1e8)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m,cap;\n        cin >> n >> m >> cap;\n        if(!n and !m and !cap) return;\n\n        string str_src,str_dest;\n        map<string,int> mp;\n        vector<tuple<int,int,int>> edges;\n        cin >> str_src >> str_dest;\n        mp[str_src]=0;\n        mp[str_dest]=1;\n        int size=2;\n        rep(i,0,n){\n            string c1,c2;\n            int d;\n            cin >> c1 >> c2 >> d;\n            if(!mp.count(c1)){\n                mp[c1]=size;\n                ++size;\n            }\n            if(!mp.count(c2)){\n                mp[c2]=size;\n                ++size;\n            }\n            edges.emplace_back(make_tuple(mp[c1],mp[c2],d));\n        }\n        vector<vector<pii>> graph(size);\n        vector<bool> is_station(size,false);\n        rep(i,0,m){\n            string name;\n            cin >> name;\n            is_station[mp[name]]=true;\n        }\n        for(const auto &e:edges){\n            graph[get<0>(e)].emplace_back(make_pair(get<1>(e),get<2>(e)*10));\n            graph[get<1>(e)].emplace_back(make_pair(get<0>(e),get<2>(e)*10));\n        }\n\n        vector<vector<int>> dist(size,vector<int>(cap*10+1,inf));\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> que;\n        dist[0][cap*10]=0;\n        que.push(make_tuple(0,0,cap*10));\n        while(!que.empty()){\n            const auto tup=que.top();\n            que.pop();\n            const int d=get<0>(tup),u=get<1>(tup),c=get<2>(tup);\n            if(d>dist[u][c]) continue;\n            if(is_station[u] and d<dist[u][cap*10]){\n                dist[u][cap*10]=d;\n                que.push(make_tuple(d,u,cap*10));\n            }\n            for(const auto &e:graph[u]){\n                const int v=e.first,tmp_d=d+e.second,remain=c-e.second/10;\n                if(remain<0 or tmp_d>=dist[v][remain]) continue;\n                dist[v][remain]=tmp_d;\n                que.push(make_tuple(tmp_d,v,remain));\n            }\n        }\n\n        int ans=inf;\n        rep(i,0,cap*10+1) ans=min(ans,dist[1][i]);\n        if(ans==inf) cout << -1 << endl;\n        else cout << ans/10 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1318 : Long Distance Taxi **/\nconst int MAX_V = 6010;\nconst int MAX_CAP = 2010;\n\nint N, M, cap;\n\nint idx;\nmap<string, int> idx_list;\nbool LPG[MAX_V];\nint d[MAX_V][MAX_CAP];\nint target;\n\nstruct Node {\n\tint v, c, d;\n\tNode (int _d, int _v, int _c) : v(_v), c(_c), d(_d){}\n\tbool operator<(const Node &n)const{return d>n.d;}\n};\n\nstruct Edge {\n\tint to; int cost;\n\tEdge(int t, int c) :  to(t), cost(c){}\n};\nvector<Edge> G[MAX_V];\n\nint toIdx(string name)\n{\n\tif (idx_list.count(name)) {\n\t\treturn idx_list[name];\n\t} else {\n\t\tidx_list[name] = idx++;\n\t\treturn idx_list[name];\n\t}\n}\n\nvoid dijkstra(int s)\n{\n\tfill(d[0], d[0]+MAX_V*MAX_CAP, INF);\n\td[s][cap] = 0;\n\t\n\tpriority_queue<Node> Q;\n\tQ.push(Node(0, s, cap));\n\t\n\twhile (Q.size()) {\n\t\tNode p = Q.top(); Q.pop();\n\t\tint v = p.v, c = p.c;\n\t\tif (v == target) break;\n\t\t\n\t\tif (LPG[v])\n\t\t\tc = cap;\n\t\t//cerr << v << \" \" << c << \" \" << p.d << endl;\n\t\t\n\t\tbool ok=true;\n\t\tfor (int i=c; i<=cap; i++) {\n\t\t\tif (d[v][i] < p.d) ok=false;\n\t\t}\n\t\tif (!ok) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\tint nc = c - e.cost;\n\t\t\tif (nc<0) continue;\n\t\t\t\n\t\t\tif (d[e.to][nc] > p.d + e.cost) {\n\t\t\t\td[e.to][nc] = p.d + e.cost;\n\t\t\t\tQ.push(Node(d[e.to][nc], e.to, nc));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> N >> M >> cap, N||M||cap) {\n\t\tfor (int i=0; i<MAX_V; i++) G[i].clear();\n\t\tidx_list.clear(); idx=0;\n\t\tcap *= 10;\n\t\tfill(LPG, LPG+MAX_V, false);\n\t\t\n\t\tstring from, to;\n\t\tcin >> from >> to;\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring a, b; int c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tint ia = toIdx(a), ib = toIdx(b);\n\t\t\tG[ia].push_back(Edge(ib, c));\n\t\t\tG[ib].push_back(Edge(ia, c));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring a; cin >> a;\n\t\t\tLPG[toIdx(a)] = true;\n\t\t}\n\t\t\n\t\ttarget = toIdx(to);\n\t\tdijkstra(toIdx(from));\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<MAX_CAP; i++) {\n\t\t\tans = min(ans, d[toIdx(to)][i]);\n\t\t}\n\t\tif (ans==INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst ll NONE=-1;\n\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvi dist(n,vi(n,NONE));\n    vs cities;\n    REP(i,n){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai][bi]=d;\n      dist[bi][ai]=d;\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(i,n){\n        if(i!=cnode.index&&dist[cnode.index][i]!=NONE){\n          ll newcost=cnode.cost+dist[cnode.index][i];\n          int newgas=cnode.gas-dist[cnode.index][i];\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint size = 0;\n\t\tvector<vs> data(N, vs(3)); \n\t\tmap<string, int> index;\n\t\t{\n\t\t\tset<string> cities;\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, 2) {\n\t\t\t\t\tcin >> data[i][j];\n\t\t\t\t\tcities.insert(data[i][j]);\n\t\t\t\t}\n\t\t\t\tcin >> data[i][2];\n\t\t\t}\n\n\t\t\tset<string>::iterator it = cities.begin();\n\t\t\twhile(it != cities.end()) {\n\t\t\t\tindex[*it] = size;\n\t\t\t\tsize++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<pii> > dist(size);\n\t\tREP(i, N) {\n\t\t\tint c1 = index[data[i][0]];\n\t\t\tint c2 = index[data[i][1]];\n\t\t\tint cost = toInt(data[i][2]);\n\n\t\t\tdist[c1].push_back(make_pair(c2, cost));\n\t\t\tdist[c2].push_back(make_pair(c1, cost));\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvs cost(size, vsh(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, dist[st.p].size()) {\n\t\t\t\tint np = dist[st.p][d].first;\n\t\t\t\tint nc = st.c + dist[st.p][d].second;\n\t\t\t\tint ng = st.g - dist[st.p][d].second;\n\n\t\t\t\tif(ng < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(gas[np]) {\n\t\t\t\t\tng = cap*10;\n\t\t\t\t}\n\n\t\t\t\tif(nc < cost[np][ng]) {\n\t\t\t\t\tcost[np][ng] = nc;\n\t\t\t\t\tQ.push(state(np, nc, ng));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 3005\n#define M 2005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint n,m,cap,d[N][M],n_max;\nmap<string,int> num;\nstring src,dest;\nvector<P> G[N];\nset<int> lpc;\n\nint dijkstra(int s,int g){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n_max;i++)\n    for(int j=0;j<=cap*10;j++)\n      d[i][j]=INF;\n  q.push(P1(0,P(s,cap*10)));\n  d[s][cap*10]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first;\n    int node=t.second.first;\n    int c=t.second.second;\n    if(d[node][c]<cost)continue;\n    if(node==g)return cost;\n    for(int i=0;i<G[node].size();i++){\n      int ncost=cost+G[node][i].second;\n      int nnode=G[node][i].first;\n      int nc=c-G[node][i].second;\n      if(nc<0)continue;\n      if(d[nnode][nc]>ncost){\n\td[nnode][nc]=ncost;\n\tq.push(P1(ncost,P(nnode,nc)));\n      }\n      if(lpc.count(nnode)){\n\tnc=cap*10;\n\tif(d[nnode][nc]>ncost){\n\t  d[nnode][nc]=ncost;\n\t  q.push(P1(ncost,P(nnode,nc)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;\n    if(!n&&!m&&!cap)break;\n    cin>>src>>dest;\n    string a,b;\n    int c;\n    n_max=0;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(!num.count(a))num[a]=n_max++;\n      if(!num.count(b))num[b]=n_max++;\n      G[num[a]].push_back(P(num[b],c));\n      G[num[b]].push_back(P(num[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      lpc.insert(num[a]);\n    }\n    int s=num[src],g=num[dest];\n    cout<<dijkstra(s,g)<<endl;\n    num.clear();\n    lpc.clear();\n    for(int i=0;i<n_max;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<atring>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size()-1;\n      if(!ms.count(b)) ms[b]=ms.size()-1;\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=dp[i][ms[vs[j]]];\n\telse e[i][j]=inf*(i!=j);\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 2010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 1; j < MAX_V; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\t// printf(\"N %d M %d\\n\", N, M);\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> st;\n\t\tst.insert(src), st.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) st.insert(c1[i]), st.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : st) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(cnt + 1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 6005\n#define M 2005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint n,m,cap,d[N][M],n_max;\nmap<string,int> num;\nstring src,dest;\nvector<P> G[N];\nset<int> lpc;\n\nint dijkstra(int s,int g){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n_max;i++)\n    for(int j=0;j<=cap*10;j++)\n      d[i][j]=INF;\n  q.push(P1(0,P(s,cap*10)));\n  d[s][cap*10]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first;\n    int node=t.second.first;\n    int c=t.second.second;\n    if(d[node][c]<cost)continue;\n    if(node==g)return cost;\n    for(int i=0;i<G[node].size();i++){\n      int ncost=cost+G[node][i].second;\n      int nnode=G[node][i].first;\n      int nc=c-G[node][i].second;\n      if(nc<0)continue;\n      if(d[nnode][nc]>ncost){\n\td[nnode][nc]=ncost;\n\tq.push(P1(ncost,P(nnode,nc)));\n      }\n      if(lpc.count(nnode)){\n\tnc=cap*10;\n\tif(d[nnode][nc]>ncost){\n\t  d[nnode][nc]=ncost;\n\t  q.push(P1(ncost,P(nnode,nc)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;\n    if(!n&&!m&&!cap)break;\n    cin>>src>>dest;\n    string a,b;\n    int c;\n    n_max=0;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(!num.count(a))num[a]=n_max++;\n      if(!num.count(b))num[b]=n_max++;\n      G[num[a]].push_back(P(num[b],c));\n      G[num[b]].push_back(P(num[a],c));\n    }\n    if(!num.count(src))num[src]=n_max++;\n    if(!num.count(dest))num[dest]=n_max++;\n    for(int i=0;i<m;i++){\n      cin>>a;\n      lpc.insert(num[a]);\n    }\n    int s=num[src],g=num[dest];\n    cout<<dijkstra(s,g)<<endl;\n    num.clear();\n    lpc.clear();\n    for(int i=0;i<n_max;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INF 1000000000000LL\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nlong long dis[6100];\nvector<P> g[6100];\nlong long g2[310][310];\nmap<string,int> id;\nvector<int> gas;\nint n,m,cap,d;\nstring a,b;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> n >> m >> cap,n||m||cap){\n    id.clear(); gas.clear();\n    for(int i=0;i<6100;i++)g[i].clear();\n    \n    cin >> a >> b;\n    id[a] = id.size(); id[b] = id.size();\n    gas.push_back(1); gas.push_back(2);\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b >> d;\n      if(id.find(a) == id.end())id[a] = id.size();\n      if(id.find(b) == id.end())id[b] = id.size();\n      g[id[a]].push_back(P(d,id[b]));\n      g[id[b]].push_back(P(d,id[a]));\n    }\n    for(int i=0;i<m;i++){\n      cin >> a;\n      gas.push_back(id[a]);\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<gas.size();j++)g2[i][j] = INF;\n      g2[i][i] = 0;\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<=id.size();j++)dis[j] = INF;\n      dis[gas[i]] = 0;\n      priority_queue<P,vector<P>,greater<P> > q;\n      q.push(P(0,gas[i]));\n      \n      while(q.size()){\n\tP p = q.top();q.pop();\n\tlong long dist = p.first;\n\tint pos = p.second;\n\t\n\tfor(int x=0;x<g[pos].size();x++){\n\t  int tdis = dist + g[pos][x].first;\n\t  int nxt = g[pos][x].second;\n\t  if(dis[nxt] > tdis){\n\t    dis[nxt] = tdis;\n\t    q.push(P(tdis,nxt));\n\t  }\n\t}\n      }\n      for(int j=0;j<gas.size();j++){\n\tif(cap*10<dis[gas[j]])continue;\n\tg2[i][j] = dis[gas[j]];\t\n      }\n    }\n\n    for(int k=0;k<gas.size();k++)\n      for(int i=0;i<gas.size();i++)\n\tfor(int j=0;j<gas.size();j++)\n\t  g2[i][j] = min(g2[i][j],g2[i][k] + g2[k][j]);\n\n    if(g2[0][1] == INF)cout << -1 << endl;\n    else cout << g2[0][1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <map>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint N, M, cap;\nint S, T;\nint station[305];\nmap<string, int> name;\nstring src, dest;\nvector<edge> G[6005], stG[305];\n\nint V;\nint get(string str)\n{\n\tmap<string, int>::iterator p;\n\tp = name.find(str);\n\tif(p == name.end()){\n\t\tV++;\n\t\tname[str] = V;\n\t\treturn V;\n\t}\n\telse{\n\t\treturn p->second;\n\t}\n}\n\nint d[6005];\nbool used[6005];\n\nvoid dijkstra(vector<edge> G[], int s)\n{\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\t\n\tfor(int i = 0; i <= V; i++){\n\t\td[i] = inf;\n\t\tused[i] = false;\n\t}\n\td[s] = 0;\n\tQ.push( make_pair(0, s) );\n\t\n\tP p; int v;\n\twhile(Q.size()){\n\t\tp = Q.top(); Q.pop();\n\t\tv = p.second;\n\t\tused[v] = true;\n\t\tif(p.first > d[v]) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(used[G[v][i].to]) continue;\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(d[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\t\n\t\tcin >> src >> dest;\n\t\tV = 0;\n\t\tname.clear();\n\t\t\n\t\tstring s, t; int di;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s >> t >> di;\n\t\t\tG[get(s)].push_back( edge(get(t), di ) );\n\t\t\tG[get(t)].push_back( edge(get(s), di ) );\n\t\t}\n\t\tS = get(src), T = get(dest);\n\t\t\n\t\tstation[0] = S;\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tcin >> s;\n\t\t\tstation[i] = get(s);\n\t\t}\n\t\tstation[M+1] = T;\n\t\t\n\t\tfor(int i = 0; i <= M+1; i++){\n\t\t\tdijkstra(G, station[i]);\n\t\t\tfor(int j = 0; j <= M+1; j++){\n\t\t\t\tif(d[station[j]] <= cap * 10) stG[i].push_back( edge(j, d[station[j]]) );\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*dijkstra(G, S);\n\t\tfor(int i = 1; i <= V; i++) cout << d[i] << \" \";\n\t\tcout << endl;*/\n\t\t\n\t\tdijkstra(stG, 0);\n\t\tif(d[M+1] == inf) d[M+1] = -1;\n\t\tcout << d[M+1] << endl;\n\t\t\n\t\tfor(int i = 1; i <= V; i++) G[i].clear();\n\t\tfor(int i = 0; i <= M+1; i++) stG[i].clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){ };\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n};\nmap<string, int> names;\nint memo[2100][2100];\nbool LPG[2100];\nvector<edge> G[2100];\n\nint main(){\n  int cnt;\n  int n, m, cap, d;\n  string src, dst;\n  string c1, c2, str;\n  while(cin >> n >> m >> cap && (n || m || cap)){\n    int res = INF;\n    cnt = 1;\n    cap *= 10;\n    cin >> src >> dst;\n\n    names.clear();\n    rep(i, 3000) G[i].clear();\n    memset(LPG, 0, sizeof(LPG));\n    fill(&memo[0][0], &memo[0][0] + 3000 * 2100, INF);\n    \n    rep(i, n){\n      cin >> c1 >> c2 >> d;\n      if(!names[c1]) names[c1] = cnt++;\n      if(!names[c2]) names[c2] = cnt++;\n      G[names[c1]].push_back(edge(names[c2], d));\n      G[names[c2]].push_back(edge(names[c1], d));\n    }\n    rep(i, m){\n      cin >> str;\n      LPG[names[str]] = true;\n    }\n    int s = names[src];\n    int t = names[dst];\n    memo[s][cap] = 0;\n    priority_queue<state, vector<state>, greater<state> > que;\n    que.push(state(0, P(s, cap)));\n    while(!que.empty()){\n      state st = que.top(); que.pop();\n      int cost = st.first;\n      int pos = st.second.first;\n      int tank = st.second.second;\n      if(cost > memo[pos][tank]) continue;\n      if(pos == t) res = min(res, cost);\n      rep(i, (int)G[pos].size()){\n\tint need = G[pos][i].cost;\n\tint nxt = G[pos][i].to;\n\t\n\tif(tank - need >= 0){\n\t  int ntank = LPG[nxt] ? cap : tank - need;\n\t  if(memo[nxt][ntank] > cost + need){\n\t    memo[nxt][ntank] = cost + need;\n\t    que.push(state(cost + need, P(nxt, ntank)));\n\t  } \n\t}\n      }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\n\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2005]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\n//int dist[6010][2010];\n//bool done[6010][2010];\n\n//vector<vector<int> > dist;\n//vector<vector<bool> > done;\n\nvector<int> dist[6010];\nvector<bool> done[6010];\n\nvector<pair<int, int> > E[6010];\nset<int> gas;\n\nvoid init()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tm.clear();\n\tstring src, dest;\n\tcin >> src >> dest;\n\tm[src] = 0; m[dest] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tstring a, b;\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\t//dist.resize(idx, vector<int>(CAP + 1, INF));\n\t//done.resize(idx, vector<bool>(CAP + 1, false));\n\n\trep(i, 0, 6010) dist[i].resize(CAP+1);\n\trep(i, 0, 6010) done[i].resize(CAP + 1);\n\n\trep(i, 0, 6010) rep(j, 0, CAP + 1) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, CAP + 1) done[i][j] = false;\n\t\n\t/*rep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;*/\n}\n\nint solve()\n{\n\tinit();\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    if (N == 0 && M == 0 && cap == 0){\n      break;\n    }\n    cap *= 10;\n    string src, dest;\n    cin >> src >> dest;\n    vector<string> c1(N), c2(N);\n    vector<int> d(N);\n    for (int i = 0; i < N; i++){\n      cin >> c1[i] >> c2[i] >> d[i];\n    }\n    vector<string> s(M);\n    for (int i = 0; i < M; i++){\n      cin >> s[i];\n    }\n    vector<string> city;\n    for (int i = 0; i < N; i++){\n      city.push_back(c1[i]);\n      city.push_back(c2[i]);\n    }\n    sort(city.begin(), city.end());\n    city.erase(unique(city.begin(), city.end()), city.end());\n    int cnt = city.size();\n    map<string, int> mp;\n    for (int i = 0; i < cnt; i++){\n      mp[city[i]] = i;\n    }\n    int t1 = mp[src];\n    int t2 = mp[dest];\n    vector<vector<pair<int, int>>> E(cnt);\n    for (int i = 0; i < N; i++){\n      int v = mp[c1[i]];\n      int w = mp[c2[i]];\n      E[v].push_back(make_pair(d[i], w));\n      E[w].push_back(make_pair(d[i], v));\n    }\n    vector<bool> a(cnt, false);\n    for (int i = 0; i < M; i++){\n      a[mp[s[i]]] = true;\n    }\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n    pq.push(make_tuple(0, t1, cap));\n    set<pair<int, int>> used;\n    int ans = -1;\n    while (!pq.empty()){\n      int t = get<0>(pq.top());\n      int v = get<1>(pq.top());\n      int c = get<2>(pq.top());\n      pq.pop();\n      if (v == t2){\n        ans = t;\n        break;\n      }\n      if (!used.count(make_pair(v, c))){\n        used.insert(make_pair(v, c));\n        for (auto P : E[v]){\n          int d = P.first;\n          int w = P.second;\n          int c2 = c - d;\n          if (c2 >= 0){\n            if (a[w]){\n              c2 = cap;\n            }\n            if (!used.count(make_pair(w, c2))){\n              pq.push(make_tuple(t + d, w, c2));\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto& tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\t/*\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){ ???????????¨TLE(9.0s)\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap * 10 + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str1[16];\nchar str2[16];\nvector<pair<int,int > >g[10000];\nint chk[10000];\nint v[10000];\nint ijk[10000];\nint val[1000];\nint G[1000][1000];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&b,&a,&c),a){\n\t\tfor(int i=0;i<10000;i++){\n\t\t\tg[i].clear();\n\t\t\tchk[i]=0;\n\t\t}\n\t\tmap<string,int> m;\n\t\tscanf(\"%s%s\",str1,str2);\n\t\tstring S=str1;\n\t\tstring T=str2;\n\t\tm[S]=0;\n\t\tm[T]=1;\n\t\tint n=2;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint d;\n\t\t\tscanf(\"%s%s%d\",str1,str2,&d);\n\t\t\tstring p=str1;\n\t\t\tstring q=str2;\n\t\t\tint P,Q;\n\t\t\tif(m.count(str1)){\n\t\t\t\tP=m[str1];\n\t\t\t}else{\n\t\t\t\tP=n;\n\t\t\t\tm[str1]=n++;\n\t\t\t}\n\t\t\tif(m.count(str2)){\n\t\t\t\tQ=m[str2];\n\t\t\t}else{\n\t\t\t\tQ=n;\n\t\t\t\tm[str2]=n++;\n\t\t\t}\n\t\t\tg[P].push_back(make_pair(Q,d));\n\t\t\tg[Q].push_back(make_pair(P,d));\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str1);\n\t\t\tif(m.count(str1)){\n\t\t\t\tchk[m[str1]]=1;\n\t\t\t}else{\n\t\t\t\tm[str1]=n;\n\t\t\t\tchk[n++]=1;\n\t\t\t}\n\t\t}\n\t\tchk[0]=1;\n\t\tint vs=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(chk[i]){\n\t\t\t\tval[vs++]=i;\n\t\t\t}\n\t\t}\n\t\tif(!chk[1]){\n\t\t\tval[vs++]=1;\n\t\t}\n\t\tfor(int i=0;i<vs;i++)\n\t\t\tfor(int j=0;j<vs;j++)\n\t\t\t\tG[i][j]=999999999;\n\t\tfor(int i=0;i<vs;i++)G[i][i]=0;\n\t\tfor(int I=0;I<vs;I++){\n\t\t\tint i=val[I];\n\t\t\tpriority_queue<pair<int,int> >Q;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t\tijk[j]=999999999;\n\t\t\t}\n\t\t\tijk[i]=0;\n\t\t\tQ.push(make_pair(0,i));\n\t\t\twhile(Q.size()){\n\t\t\t\tint at=Q.top().second;\n\t\t\t\tint cost=-Q.top().first;\n\t\t\t\tQ.pop();\n\t\t\t\tif(v[at])continue;\n\t\t\t\tv[at]=1;\n\t\t\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\t\t\tif(!v[g[at][j].first]&&ijk[g[at][j].first]>cost+g[at][j].second){\n\t\t\t\t\t\tijk[g[at][j].first]=cost+g[at][j].second;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[g[at][j].first],g[at][j].first));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<vs;j++){\n\t\t\t\tif(c*10>=ijk[val[j]]){\n\t\t\t\t\tG[I][j]=G[j][I]=ijk[val[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<vs;k++)\n\t\t\tfor(int i=0;i<vs;i++)\n\t\t\t\tfor(int j=0;j<vs;j++)\n\t\t\t\t\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\tfor(int i=0;i<vs;i++){\n\t\t\tif(val[i]==1){\n\t\t\t\tif(G[0][i]==999999999)printf(\"-1\\n\");\n\t\t\t\telse printf(\"%d\\n\",G[0][i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nvector<pair<int,int> > v[6001];\nbool sta[6001];\nint dp[6001][2002];\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2+1;i++){\n    for(int j=0;j<=2001;j++){\n      if(i==0)dp[i][j]=0;\n      else dp[i][j]=inf;\n    }\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(mp(M[b],c));\n      v[M[b]].push_back(mp(M[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(u.n==1){\n\tans=u.dis;\n        break;\n      }\n\n      if(sta[u.n])u.a=cap;\n      if(dp[u.n][u.a]<u.dis)continue;\n      /*\n      bool flag=true;\n      for(int i=c;i<=cap;i++){\n\tif(dp[u.n][i]<u.dis)flag=false;\n      }\n      if(!flag)continue;\n      */\n      for(int i=0;i<v[u.n].size();i++){\n\tif(v[u.n][i].s<=u.a){\n\t  int x=u.dis+v[u.n][i].s,y=u.a-v[u.n][i].s,z=v[u.n][i].f;\n\t  if(x<dp[z][y]){\n\t    dp[z][y]=x;\n\t    pq.push(State(z,y,x));\n\t  }\n\t}\n      }\n\n    }\n    if(ans==inf)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nclass Edge\n{\npublic:\n\tint src, dst, cst;\n\tEdge() {}\n\tEdge(int s, int d, int c)\n\t\t:src(s),dst(d),cst(c)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nclass State\n{\npublic:\n\tint node, gas, cst;\n\tState(int n, int g, int c)\n\t\t:node(n),gas(g),cst(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn cst>s.cst;\n\t}\n};\n\nint M,N,cap;\nbool station[3005];\nbool visited[3005][2005];\n\nint solve(int S, int T, vector<Edge>& edges, int V)\n{\n\tGraph graph(V);\n\n\tfor(int i=0; i<edges.size(); i++){\n\t\tEdge e = edges[i];\n\t\tgraph[e.src].push_back(Edge(e.src, e.dst, e.cst));\n\t\tgraph[e.dst].push_back(Edge(e.dst, e.src, e.cst));\n\t}\n\n\tmemset(visited, 0, sizeof(visited));\n\n\tpriority_queue<State> q;\n\tq.push(State(S,cap*10,0));\n\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif(s.node == T) return s.cst;\n\n\t\tif(visited[s.node][s.gas]) continue;\n\t\tvisited[s.node][s.gas] = true;\n\n\t\tfor(int i=0; i<graph[s.node].size(); i++)\n\t\t{\n\t\t\tEdge e = graph[s.node][i];\n\n\t\t\tif(e.cst > s.gas) continue;\n\n\t\t\tint ngas = (station[e.dst]?cap*10:s.gas-e.cst); \n\t\t\tif(visited[e.dst][ngas]) continue;\n\n\t\t\tq.push(State(e.dst, ngas, s.cst + e.cst));\n\t\t}\n\t}\n\n\t\n\treturn -1;\n}\n\nint main()\n{\n\twhile(cin >> N >> M >> cap, (M||N||cap)) {\n\t\tstring s,t;\n\t\tcin >> s >> t;\n\n\t\tint id = 0;\n\t\tmap<string, int> dic;\n\n\t\tif(!dic.count(s)) dic[s] = id++;\n\t\tif(!dic.count(t)) dic[t] = id++;\n\t\t\n\t\tvector<Edge> edges(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring a,b;\n\t\t\tint c;\n\n\t\t\tcin >> a >> b >> c;\n\t\t\tif(!dic.count(a)) dic[a] = id++;\n\t\t\tif(!dic.count(b)) dic[b] = id++;\n\n\t\t\tedges[i] = Edge(dic[a], dic[b], c);\n\t\t}\n\n\t\tmemset(station, 0, sizeof(station));\n\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\tif(!dic.count(a)) dic[a] = id++;\n\n\t\t\tstation[dic[a]] = true;\n\t\t}\n\n\t\tcout << solve(dic[s], dic[t], edges, dic.size()) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\nint dist[6010][2010];\nbool done[6010][2010];\nvector<pair<int, int> > E[6010];\nset<int> gas;\n\nstring a, b, s;\n\nvoid init()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tcin >> a >> b;\n\tm[a] = 0; m[b] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\trep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n}\n\nint solve()\n{\n\tinit();\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 60000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\n//int dist[6010][2010];\n//bool done[6010][2010];\n\n//vector<vector<int> > dist;\n//vector<vector<bool> > done;\n\n\n\nint solve()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tvector<vector<int> > dist;\n\tvector<vector<bool> > done;\n\n\tvector<pair<int, int> > E[6010];\n\tset<int> gas;\n\n\tstring src, dest;\n\tcin >> src >> dest;\n\tm[src] = 0; m[dest] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tstring a, b;\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\t//dist.resize(idx, vector<int>(CAP + 1, INF));\n\t//done.resize(idx, vector<bool>(CAP + 1, false));\n\n\tdist.resize(idx);\n\tdone.resize(idx);\n\trep(i, 0, idx) dist[i] = vector<int>(CAP + 1);\n\trep(i, 0, idx) done[i] = vector<bool>(CAP + 1);\n\n\trep(i, 0, idx) rep(j, 0, CAP + 1) dist[i][j] = INF;\n\trep(i, 0, idx) rep(j, 0, CAP + 1) done[i][j] = false;\n\n\t/*rep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;*/\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[3005][3005];\nint gas[3005];\nint head[3005];\nint dp[2001][2501];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[6005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num+1;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(u<=2500&&dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return dp[gasnum][u]=0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n        }\n    }\n    if(u<=2500)\n        dp[gasnum][u]=ret;\n    return ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n                u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n            printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint nn,n,m,cap;\nint s,g;\nset<string>S;\nmap<string,int>M;\nvector<P>edge[6005];\nbool ok[6005];\nstring from[6005],to[6005];\nint d[6005];\nint dist[305][6005];\nint D[305];\nint main(){\n\twhile(1){\n\t\tcin>>nn>>m>>cap;\n\t\tif(nn==0) return 0;\n\t\tstring ss,gg; cin>>ss>>gg;\n\t\tM.clear(); S.clear();\n\t\trep(i,6005){\n\t\t\tedge[i].clear(); ok[i]=0;\n\t\t}\n\t\tS.insert(ss); S.insert(gg);\n\t\trep(i,nn){\n\t\t\tcin>>from[i]>>to[i]>>d[i];\n\t\t\tS.insert(from[i]);\n\t\t\tS.insert(to[i]);\n\t\t}\n\t\tvector<string>hoge;\n\t\trep(i,m){\n\t\t    string f; cin>>f; hoge.pb(f);\n\t\t}\n\t\tint nxt = 1;\n\t\tfor(auto s:S){\n\t\t    M[s] = nxt++;\n\t\t}\n\t\trep(i,nn){\n\t\t//\tcin>>from[i]>>to[i]>>d[i];\n\t\t\tedge[M[from[i]]].pb(mp(M[to[i]],d[i]));\n\t\t\tedge[M[to[i]]].pb(mp(M[from[i]],d[i]));\n\t\t}\n\t\tvector<int>cand;\n\t\trep(i,m){\n\t\t\tif(M.find(hoge[i]) == M.end()) continue;\n\t\t    ok[M[hoge[i]]] = 1;\n\t\t    cand.pb(M[hoge[i]]);\n\t\t}\n\t\tcand.pb(M[ss]); s = M[ss];\n\t\tcand.pb(M[gg]); g = M[gg];\n\t\tfor(int i=0;i<cand.size();i++){\n\t\t\trep(j,6005) dist[i][j] = INF;\n\t\t\tdist[i][cand[i]] = 0;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que;\n\t\t\tque.push(mp(0,cand[i]));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tif(dist[i][p.sc] != p.fi) continue;\n\t\t\t\tfor(int x=0;x<edge[p.sc].size();x++){\n\t\t\t\t\tint to = edge[p.sc][x].fi;\n\t\t\t\t\tint cs = edge[p.sc][x].sc;\n\t\t\t\t\tif(p.fi+cs < dist[i][to]){\n\t\t\t\t\t\tdist[i][to] = p.fi+cs;\n\t\t\t\t\t\tque.push(mp(p.fi+cs,to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,cand.size()) D[i] = INF;\n\t\tint sss,ggg;\n\t\trep(i,cand.size()){\n\t\t\tif(cand[i] == s) sss = i;\n\t\t\tif(cand[i] == g) ggg = i;\n\t\t}\n\t\tD[sss] = 0;\n\t\tpriority_queue<P,vector<P>,greater<P> >que;\n\t\tque.push(mp(0,sss));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif(D[p.sc] != p.fi) continue;\n\t\t\tfor(int j=0;j<cand.size();j++){\n\t\t\t\tif(dist[p.sc][cand[j]] > cap * 10) continue;\n\t\t\t\tif(D[p.sc] + dist[p.sc][cand[j]] < D[j]){\n\t\t\t\t\tD[j] = D[p.sc] + dist[p.sc][cand[j]];\n\t\t\t\t\tque.push(mp(D[j],j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(D[ggg] > 1e8) D[ggg] = -1;\n\t\tcout << D[ggg] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=p.s.s;\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \tif(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n  \tvis[v][p.s.s]=true;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(p.s.s-e.cost>=0){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n//#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint dist[6003][2001];\nvector<pair<int,int>> vertexs[6003];\nint gas[6003];\nvoid solve(){\n    while (true) {\n        int n, m, cap;\n        cin >> n >> m >> cap;\n        if (n == 0) return;\n        map<string, int> zip;\n        string s, t;\n        cin >> s >> t;\n        zip[s] = 1;\n        zip[t] = 1;\n        vector<tuple<string, string, int>> inputs;\n        REP(i, n) {\n            string a, b;\n            int c;\n            cin >> a >> b >> c;\n            inputs.push_back(make_tuple(a, b, c));\n            zip[a] = 1;\n            zip[b] = 1;\n        }\n        int cnt = 0;\n        for (auto i = zip.begin(); i != zip.end(); ++i) {\n            i->second = cnt;\n            cnt++;\n        }\n        REP(i, cnt) {\n            REP(q, cap * 10 + 1) {\n                dist[i][q] = 1e9;\n            }\n            gas[i] = 0;\n            vertexs[i].clear();\n        }\n        REP(i, n) {\n            vertexs[zip[get<0>(inputs[i])]].push_back(mp(zip[get<1>(inputs[i])], get<2>(inputs[i])));\n            vertexs[zip[get<1>(inputs[i])]].push_back(mp(zip[get<0>(inputs[i])], get<2>(inputs[i])));\n        }\n        REP(i, m) {\n            string a;\n            cin >> a;\n            gas[zip[a]] = 1;\n        }\n        dist[zip[s]][cap * 10] = 0;\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> next;\n        next.push(make_tuple(0, zip[s], cap * 10));\n        while (next.empty() == false) {\n            tuple<int, int, int> now = next.top();\n            next.pop();\n            if (dist[get<1>(now)][get<2>(now)] != get<0>(now)) continue;\n            if (gas[get<1>(now)] == 1) {\n                if (get<2>(now) != cap * 10) {\n                    if (dist[get<1>(now)][cap * 10] > get<0>(now)) {\n                        dist[get<1>(now)][cap * 10] = get<0>(now);\n                        next.push(make_tuple(get<0>(now), get<1>(now), cap * 10));\n                    }\n                    continue;\n                }\n            }\n            for (auto x : vertexs[get<1>(now)]) {\n                if (x.second > get<2>(now)) continue;\n                if (dist[x.first][get<2>(now) - x.second] > x.second + get<0>(now)) {\n                    dist[x.first][get<2>(now) - x.second] = x.second + get<0>(now);\n                    next.push(make_tuple(x.second + get<0>(now), x.first, get<2>(now) - x.second));\n                }\n            }\n        }\n        int ans = 1e9;\n        REP(q, cap * 10 + 1) {\n            ans = min(ans, dist[zip[t]][q]);\n        }\n        if (ans == 1e9) ans = -1;\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 1000000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n     \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n   \t\t d[e.to] = d[v]+e.cost;\n   \t\t que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n \n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n    map<string,int>vnum;\n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tint dis;\n\tint gas;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.dis> r.dis;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tcap *= 10;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tint num = 2;\n\t\tvector<vector<pair<int, int>>>edges(6000);\n\t\tstring sta, goa; cin >> sta >> goa; mp[sta] = 0; mp[goa] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring f, t; cin >> f >> t;\n\t\t\tint dis; cin >> dis;\n\t\t\tif (!mp.count(f)) {\n\t\t\t\tmp[f] = num++;\n\t\t\t}\n\t\t\tif (!mp.count(t)) {\n\t\t\t\tmp[t] = num++;\n\t\t\t}\n\t\t\tconst int fid = mp[f];\n\t\t\tconst int tid = mp[t];\n\t\t\tedges[fid].push_back(make_pair(tid, dis));\n\t\t\tedges[tid].push_back(make_pair(fid, dis));\n\t\t}\n\t\tedges.resize(mp.size());\n\t\tvector<bool>stat(edges.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\t\t\t\tstat[mp[st]] = true;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>mindiss(mp.size(), vector<int>(cap + 1, 99999999));\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,0,cap });\n\t\tmindiss[0][cap] = 0;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int pregas = atop.gas;\n\t\t\tconst int nowdis = atop.dis;\n\t\t\t\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (pregas >= i.second) {\n\t\t\t\t\tconst int newid = i.first;\n\t\t\t\t\tconst int newgas = stat[newid]?cap:atop.gas - i.second;\n\t\t\t\t\tconst int newdis = nowdis + i.second;\n\t\t\t\t\tif (mindiss[newid][newgas]> newdis) {\n\t\t\t\t\t\tmindiss[newid][newgas] = newdis;\n\t\t\t\t\t\tque.push(aa{ newid, newdis ,newgas });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\tfor (int i = 0; i < cap + 1; ++i) {\n\t\t\tans = min(mindiss[1][i], ans);\n\t\t}\n\t\tif (ans == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\nvector<int> dist[6010];\nvector<bool> done[6010];\nvector<pair<int, int> > E[6010];\nset<int> gas;\n\nstring a, b, s;\n\nvoid init()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tcin >> a >> b;\n\tm[a] = 0; m[b] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\trep(i, 0, 6010) dist[i].resize(CAP + 1, INF);\n\t//rep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) done[i].resize(CAP + 1, false);\n\t//rep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n}\n\nint solve()\n{\n\tinit();\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nconst int inf = numeric_limits<int>::max() / 3;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int to_,int cost_) : to(to_) , cost(cost_) {}\n};\n\nint N,M,cap;\nint src,dest;\nvector<edge> g[4000];\n\nvoid solve(){\n    for(int i=0;i<4000;i++) g[i] = vector<edge>();\n    string srcc,destt;\n    cap *= 10;\n    cin >> srcc >> destt;\n    int namecount=0;\n    map<string,int> names;\n    for(int i=0;i<N;i++){\n        string c1,c2;\n        int dist;\n        cin >> c1 >> c2 >> dist;\n        if(!names.count(c1)){\n            names[c1] = namecount++;\n        }\n        if(!names.count(c2)){\n            names[c2] = namecount++;\n        }\n\n        g[names[c1]].push_back(edge(names[c2],dist));\n        g[names[c2]].push_back(edge(names[c1],dist));\n    }\n\n    if(!names.count(srcc)){\n        names[srcc] = namecount++;\n    }\n    if(!names.count(destt)){\n        names[destt] = namecount++;\n    }\n    int src = names[srcc];\n    int dest = names[destt];\n\n    set<int> s;\n    for(int i=0;i<M;i++){\n        string ss;cin >> ss;\n        s.insert(names[ss]);\n    }\n\n    using Vertex = pair<int,int>; // ?????????????,???????????¨\n    using State = pair<int,Vertex>; // ????????????¢, ????????????? \n\n    // dist[?????????????][?????£?????????????¨??????????????¢???????\\] = ?????????????????????????¢\n    vector<vector<int>> dist(4000,vector<int>(300,inf));\n    \n    priority_queue<State,vector<State>,greater<State>> que;\n    que.push(State(0,Vertex(src,cap)));\n    dist[src][cap] = 0;\n\n    //for(auto p : names) cerr << p.first << \" \" << p.second << endl;\n\n    while(!que.empty()){\n        int d = que.top().first;\n        Vertex v = que.top().second;\n        que.pop();\n        \n        int node = v.first;\n        int c = v.second;\n\n        //cerr << node << \" \" << c << \" \" << d << endl;\n\n        if(s.count(node)){\n            c = cap;\n        }\n\n        for(edge& e : g[node]){\n            int ncap = c - e.cost;\n            //cerr << \"e = \" << e.to << \" \" << e.cost << endl;\n            if(ncap < 0) continue;\n            if(dist[e.to][ncap] > d + e.cost){\n                //cerr << \"push \" << e.to << \" \" << ncap << endl;\n                dist[e.to][ncap] = d + e.cost; \n                que.push(State(dist[e.to][ncap],Vertex(e.to,ncap)));\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int i=0;i<300;i++) ans = min(ans,dist[dest][i]);\n\n    if(ans==inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N >> M >> cap;\n        if(N==0 and M==0 and cap==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n \nint dis[6000][2001];\nvector<pair<short, short> > edge[6000];\n \nint main() {\n  while (true) {\n    rep (i, 6000) edge[i].clear();\n    rep (i, 6000) rep (j, 2001) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (dis[pos][f] < cost) continue;\n      if (mp[dest] == pos) break;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tdis[np][nf] = nc;\n\tif (np == mp[dest]) break;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2001) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint N,M,cap;\nmain()\n{\n\twhile(cin>>N>>M>>cap,N)\n\t{\n\t\tmap<string,int>MM;\n\t\tvector<pair<pair<int,int>,int> >E;\n\t\tstring start,goal;\n\t\tcin>>start>>goal;\n\t\tMM[start]=0;MM[goal]=1;\n\t\tint sz=2;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tstring s,t;int dis;cin>>s>>t>>dis;\n\t\t\tint is,it;\n\t\t\tif(MM.find(s)!=MM.end())is=MM[s];\n\t\t\telse is=MM[s]=sz++;\n\t\t\tif(MM.find(t)!=MM.end())it=MM[t];\n\t\t\telse it=MM[t]=sz++;\n\t\t\tE.push_back(make_pair(make_pair(is,it),dis));\n\t\t}\n\t\tvector<vector<pair<int,int> > >G(sz);\n\t\tvector<vector<int> >d(sz,vector<int>(10*cap+1,2e9));\n\t\tvector<bool>ok(sz);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tstring s;cin>>s;ok[MM[s]]=true;\n\t\t}\n\t\tfor(pair<pair<int,int>,int>p:E)\n\t\t{\n\t\t\tG[p.first.first].push_back(make_pair(p.first.second,p.second));\n\t\t\tG[p.first.second].push_back(make_pair(p.first.first,p.second));\n\t\t}\n\t\td[0][cap*10]=0;\n\t\tpriority_queue<pair<int,pair<int,int> > >P;\n\t\tP.push(make_pair(0,make_pair(0,cap*10)));\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint cost=-P.top().first;\n\t\t\tint u=P.top().second.first;\n\t\t\tint c=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(d[u][c]<cost)continue;\n\t\t\tfor(pair<int,int>p:G[u])\n\t\t\t{\n\t\t\t\tint v=p.first;\n\t\t\t\tif(p.second<=c)\n\t\t\t\t{\n\t\t\t\t\tint now=ok[v]?cap*10:c-p.second;\n\t\t\t\t\tif(d[v][now]>cost+p.second)\n\t\t\t\t\t{\n\t\t\t\t\t\td[v][now]=cost+p.second;\n\t\t\t\t\t\tP.push(make_pair(-d[v][now],make_pair(v,now)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=2e9;\n\t\tfor(int i=0;i<=cap*10;i++)ans=min(ans,d[1][i]);\n\t\tcout<<(ans<2e9?ans:-1)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n\nint d[6010][2010];\nbool done[6010][2010];\nint N, M, C;\n\ntypedef struct _Edge{\n    int to, dist;\n    _Edge(int to, int dist): to(to), dist(dist){};\n}Edge;\n\ntypedef struct _Node{\n    int v, gas, d;\n    _Node(int v, int gas, int d): v(v), gas(gas), d(d){};\n    bool operator<(const _Node& n)const{return d>n.d;}\n}Node;\n\nint dijkstra(vector<vector<Edge>> &G, set<int> &gass, int src, int dst){\n    int N = G.size();\n    memset(d, 0x3f, sizeof(d));\n    memset(done, 0, sizeof(done));\n    \n    priority_queue<Node> que;\n    \n    d[src][C*10] = 0;\n    que.push(Node(src, C*10, 0));\n    \n    while(!que.empty()){\n        auto node = que.top(); que.pop();\n        if(node.v == dst)\n            return node.d;\n        \n        auto p = make_pair(node.v, node.gas);\n        \n        if(done[p.first][p.second])\n            continue;\n        done[p.first][p.second] = true;\n             \n        for(auto e: G[node.v]){\n            if(node.gas < e.dist)\n                continue;\n            \n            pair<int, int> np;\n            np.first = e.to;\n            if(gass.find(e.to) != gass.end())\n                np.second = C*10;\n            else\n                np.second = node.gas - e.dist;\n            \n            if(d[p.first][p.second] + e.dist < d[np.first][np.second]){\n                d[np.first][np.second] = d[p.first][p.second] + e.dist;\n                que.push(Node(np.first, np.second, d[np.first][np.second]));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    string src, dst;\n    cin >> src >> dst;\n    \n    map<string, int> stoi;\n    vector<string> cs(N), cd(N);\n    vector<int> ds(N);\n    for(int i=0; i<N; i++){\n        cin >> cs[i] >> cd[i] >> ds[i];\n        \n        if(stoi.find(cs[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cs[i]] = x;\n        }\n        if(stoi.find(cd[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cd[i]] = x;\n        }\n    }\n    \n    set<int> gass;\n    for(int i=0; i<M; i++){\n        string s; cin >> s;\n        gass.insert(stoi[s]);\n    }\n    \n    vector<vector<Edge>> G(stoi.size());\n    for(int i=0; i<N; i++){\n        int si = stoi[cs[i]];\n        int di = stoi[cd[i]];\n        \n        G[si].emplace_back(di, ds[i]);\n        G[di].emplace_back(si, ds[i]);\n    }\n    \n    cout << dijkstra(G, gass, stoi[src], stoi[dst]) << endl;\n}\n\nint main(){\n    while(cin >> N >> M >> C, N|M|C)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=p.s.s;\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[v][p.s.s]==INF || (nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost)){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \tif(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int v,r,d;\n};\n\nbool operator<(const state &a,const state &b){\n  return a.d > b.d;\n}\n\nint n,m,C;\nstring src,dst;\nint S,T;\nmap<string,int> idx;\nvector<P> g[6000];\nbool aru[6000];\nint dist[6000][2010];\nint V=0;\n\nint getidx(string s){\n  if(idx.find(s)!=idx.end())return idx[s];\n  idx[s]=V++;\n  return idx[s];\n}\n\nint main(){\n  while(1){\n    cin>>m>>n>>C;\n    if(m==0&&n==0)break;\n\n    idx.clear();\n    rep(i,6000)g[i].clear();\n    memset(aru,0,sizeof(aru));\n    V=0;\n\n    cin>>src>>dst;\n    S=getidx(src);\n    T=getidx(dst);\n    rep(i,m){\n      string a,b;\n      int d;\n      cin>>a>>b>>d;\n      g[getidx(a)].push_back(P(getidx(b),d));\n      g[getidx(b)].push_back(P(getidx(a),d));\n    }\n    rep(i,n){\n      string a;\n      cin>>a;\n      aru[getidx(a)]=true;\n    }\n\n    priority_queue<state> que;\n    que.push((state){S,C*10,0});\n    rep(i,V)rep(j,C*10+1)dist[i][j]=INF;\n    while(que.size()){\n      state s=que.top(); \n      que.pop();\n      if(dist[s.v][s.r]!=INF)continue;\n      dist[s.v][s.r]=s.d;\n      for(P e : g[s.v]){\n        if(s.r<e.se)continue;\n        que.push((state){e.fi,s.r-e.se,s.d+e.se});\n      }\n      if(s.r<C*10&&aru[s.v]){\n        que.push((state){s.v,C*10,s.d});\n      }\n    }\n\n    int res=INF;\n    rep(j,C*10+1)minch(res,dist[T][j]);\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P, int> sP;\n\nvoid solve(int N, int M, int C) {\n    string start, goal;\n    cin >> start >> goal;\n\n    set<string> citys;\n    vector<string> slist(N), elist(N);\n    vector<int> edge(N);\n    for (int i = 0; i < N; i++) {\n        cin >> slist[i] >> elist[i] >> edge[i];\n        citys.insert(slist[i]);\n        citys.insert(elist[i]);\n    }\n\n    map<string,int> s_num;\n    int _idx = 0;\n    for (auto i : citys) {\n        s_num[i] = _idx;\n        _idx++;\n    }\n\n    vector<vector<P>> m(citys.size());\n    for (int i = 0; i < N; i++) {\n        m[s_num[slist[i]]].push_back(P(s_num[elist[i]], edge[i]));\n        m[s_num[elist[i]]].push_back(P(s_num[slist[i]], edge[i]));\n    }\n\n    vector<int> store(M);\n    for (auto& i : store) {\n        string x;\n        cin >> x;\n        i = s_num[x];\n    }\n    \n\n    vector<map<int,int>> dp(citys.size());\n    dp[s_num[start]][C*10] = 0;\n\n    priority_queue<sP, vector<sP>, greater<sP>> que;\n    que.push(sP(P(0, C*10), s_num[start]));\n\n    while (que.size() > 0) {\n        auto sp = que.top(); que.pop();\n        int now = sp.second;\n        int cost = sp.first.first;\n        int cap = sp.first.second;\n\n        if (dp[now].size() > 0\n            && dp[now].find(cap) != dp[now].end()\n            && dp[now][cap] < cost) continue;\n\n        if (now == s_num[goal]) break;\n\n        for (auto city : m[now]) {\n            int next = city.first;\n            int dist = city.second;\n            int _cap = cap - dist;\n\n            if (_cap < 0) continue;\n            if (find(store.begin(), store.end(), next) != store.end()) _cap = C * 10;\n            \n            if (dp[next].size() == 0 || dp[next].find(_cap) == dp[next].end()) {\n                dp[next][_cap] = cost + dist;\n                que.push(sP(P(cost + dist, _cap), next));\n            } else if (dp[next][_cap] > cost + dist) {\n                dp[next][_cap] = cost + dist;\n                que.push(sP(P(cost + dist, _cap), next));\n            }\n        }\n    }\n\n    if (dp[s_num[goal]].size() == 0) cout << -1 << endl;\n    else {\n        int ans = 1 << 28;\n        for (auto i : dp[s_num[goal]]) ans = min(ans, i.second);\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    int N, M, C;\n    while (cin >> N >> M >> C, N || M || C) solve(N, M, C);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[j][i]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n  \n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n  \n#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n  \nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n  \nint n, m, cap, dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n  \ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n  \ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      adj[sid.size()].clear();\n      sid.emplace(s0, sid.size());\n    }\n    if(!sid.count(s1)) {\n      adj[sid.size()].clear();\n      sid.emplace(s1, sid.size());\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  dis[0] = 0;\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    //cerr << \"cost \" << nxt0.F << \" id \" << nxt0.S << endl;\n  \n    vector<int> tmp_dis(mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  if(dis[1] == INF)\n    return -1;\n  else\n    return dis[1];\n}\n  \nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State,vector<State> >que;\n  que.push(State(0,cap*10,s));\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      if(now.c==c && !st.count(next) &&next!=g)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>v,from,to;\nvector<int>cost;\nmap<string,int>id;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int ME = 3010;\nconst int MV = 310;\nint fir[MV], rfir[MV];\nint n, m, cap, u[ME], v[ME], nex[ME], rnex[ME], w[ME];\nint dis[MV][2010];\nbool inq[MV][2010], oil_sta[MV];\n\nstruct dot{\n\tint oil, p;\n}rear, front;\n\nint main () {\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int>city;\n\t\tstring start, des;\n\t\tcin >> start >> des;\n\t\tcity[start] = 1; city[des] = 2;\n\t\tint d;\n\t\tstring x, y;\n\t\tint cou = 2;\n\t\tmemset(fir, -1, sizeof(fir));\n\t\tmemset(rfir, -1, sizeof(rfir));\n\t\t//int ee = 0;\n\t\tfor(int ee = 0; ee < n; ee++) {\n\t\t\tcin >> x >> y >> d;\n\t\t\tif(city[x] == 0) city[x] = ++cou;\n\t\t\tif(city[y] == 0) city[y] = ++cou;\n\t\t\t//if(d > cap * 10 ) continue; \n\t\t\tu[ee] = city[x];\n\t\t\tv[ee] = city[y];\n\t\t\tw[ee] = d;\n\t\t\tnex[ee] = fir[u[ee]]; fir[u[ee]] = ee;\n\t\t\trnex[ee] = rfir[v[ee]]; rfir[v[ee]] = ee;\n\t\t\t//ee++;\n\t\t}\n\t\tmemset(oil_sta, 0, sizeof(oil_sta));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin>>x;\n\t\t\tif(!city[x]) continue;\n\t\t\toil_sta[city[x]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap * 10;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint ok = 0;\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tdis[1][cap*10] = 0;\n\t\tinq[1][cap*10] = 1;\n\t\tint mmin = 0x3f3f3f3f;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = 0;\n\t\t\tif(front.p == 2 && !ok) { ok = 1; continue; }\n\t\t\tfor(int e = fir[front.p]; e != -1; e = nex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = v[e];\n\t\t\t\tif(oil_sta[v[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[v[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[v[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[v[e]][rear.oil]){\n\t\t\t\t\t\tinq[v[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int e = rfir[front.p]; e != -1; e = rnex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = u[e];\n\t\t\t\tif(oil_sta[u[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[u[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[u[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[u[e]][rear.oil]){\n\t\t\t\t\t\tinq[u[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tfor(int i = 0; i <= cap*10; i++) if(dis[2][i] < mmin) mmin = dis[2][i];\n\t\t\tprintf(\"%d\\n\", mmin);\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n  int to;\n  int cost;\n};\n\nint d[2001][3001];\nvector<edge> G[3001];\nbool isGas[10001];\nmap<string,int> m;\nint idx;\nint st,gl;\n\nint N,M,cap;\nconst int INF=1<<30;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> Sit;\n\nint dijkstra(){\n  for(int i=0;i<2001;i++)\n    for(int j=0;j<3001;j++)\n      d[i][j]=INF;\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  pq.push(make_pair(0,pii(cap*10,st)));\n  d[cap*10][st]=0;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int ccost=p.first;\n    int ccap=p.second.first;\n    int cnode=p.second.second;\n    if(d[ccap][cnode]<ccost)continue;\n    for(int i=0;i<(int)G[cnode].size();i++){\n      edge &e=G[cnode][i];\n      int ncap=ccap-e.cost;\n      if(ncap<0)continue;\n      int nnode=e.to;\n      int ncost=ccost+e.cost;\n      if(isGas[nnode])ncap=cap*10;\n      if(d[ncap][nnode]>ncost){\n\td[ncap][nnode]=ncost;\n\tpq.push(make_pair(ncost,pii(ncap,nnode)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<2001;i++)res=min(res,d[i][gl]);\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>cap&&(N|M|cap)){\n    memset(isGas,0,sizeof(isGas));\n    for(int i=0;i<3001;i++)G[i].clear();\n    idx=0;\n    string s,t;\n    cin>>s>>t;\n    if(m.count(s)==0)m[s]=idx++;\n    if(m.count(t)==0)m[t]=idx++;\n    st=m[s];gl=m[t];\n    for(int i=0;i<N;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(m.count(a)==0)m[a]=idx++;\n      if(m.count(b)==0)m[b]=idx++;\n      int x,y;\n      x=m[a];y=m[b];\n      edge e;\n      e.to=y;\n      e.cost=c;\n      G[x].push_back(e);\n      e.to=x;\n      G[y].push_back(e);\n    }\n    for(int i=0;i<M;i++){\n      string s;\n      cin>>s;\n      if(m.count(s)==0)m[s]=idx++;\n      isGas[m[s]]=true;\n    }\n    int res=dijkstra();\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 6001;\nconst int MAX_CAP = 2002;\n\nstruct Edge {\n  int to, cost;\n  Edge() {}\n  Edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct State {\n  int p, cost, oil;\n  State() {}\n  State(int p, int cost, int oil) : p(p), cost(cost), oil(oil) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(oil != s.oil) return oil < s.oil;\n    return p < s.p;\n  }\n};\n\nint Cap, num, Src, Dist;\n\nmap<string, int> id;\nvector<Edge> E[MAX_N];\n\nbool existS[MAX_N];\nint cost[MAX_N][MAX_CAP];\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = num++;\n  }\n  return id[s];\n}\n\n\nint solve() {\n  priority_queue<State> que;\n  State s(Src, 0, Cap);\n  que.push(s);\n  fill(cost[0], cost[num], -1);\n  while(!que.empty()) {\n\n    s = que.top(); que.pop();\n    //    cout << s.p << \", \" << s.cost << \", \" << s.oil << endl;\n    if(cost[s.p][s.oil] != -1) continue;\n    cost[s.p][s.oil] = s.cost;\n\n    if(s.p == Dist) return s.cost;\n\n    for(int i = 0; i < E[s.p].size(); ++i) {\n      int nextOil = s.oil - E[s.p][i].cost;\n      if(nextOil < 0) continue;\n      if(existS[E[s.p][i].to]) nextOil = Cap;\n      if(cost[E[s.p][i].to][nextOil] != -1) continue;\n\n      que.push(State(E[s.p][i].to, s.cost + E[s.p][i].cost, nextOil));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M >> Cap && (N | M | Cap)) {\n    num = 0;\n    Cap *= 10;\n    id.clear();\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n\n    string src, dist;\n    cin >> src >> dist;\n    Src = getId(src);\n    Dist = getId(dist);\n    for(int i = 0; i < N; ++i) {\n      string from, to;\n      int d;\n      cin >> from >> to >> d;\n      E[getId(from)].push_back(Edge(getId(to), d));\n      E[getId(to)].push_back(Edge(getId(from), d));\n    }\n\n    fill(existS, existS+MAX_N, false);\n    for(int i = 0; i < M; ++i) {\n      string name;\n      cin >> name;\n      existS[getId(name)] = true;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){ };\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n};\nmap<string, int> names;\nint memo[3000][2100];\nbool LPG[3000];\nvector<edge> G[3000];\n\nint main(){\n  int cnt;\n  int n, m, cap, d;\n  string src, dst;\n  string c1, c2, str;\n  while(cin >> n >> m >> cap && (n || m || cap)){\n    int res = INF;\n    cnt = 1;\n    cap *= 10;\n    cin >> src >> dst;\n\n    names.clear();\n    rep(i, 3000) G[i].clear();\n    memset(LPG, 0, sizeof(LPG));\n    fill(&memo[0][0], &memo[0][0] + 3000 * 2100, INF);\n    \n    rep(i, n){\n      cin >> c1 >> c2 >> d;\n      if(!names[c1]) names[c1] = cnt++;\n      if(!names[c2]) names[c2] = cnt++;\n      G[names[c1]].push_back(edge(names[c2], d));\n      G[names[c2]].push_back(edge(names[c1], d));\n    }\n    rep(i, m){\n      cin >> str;\n      LPG[names[str]] = true;\n    }\n    int s = names[src];\n    int t = names[dst];\n    memo[s][cap] = 0;\n    priority_queue<state, vector<state>, greater<state> > que;\n    que.push(state(0, P(s, cap)));\n    while(!que.empty()){\n      state st = que.top(); que.pop();\n      int cost = st.first;\n      int pos = st.second.first;\n      int tank = st.second.second;\n      if(cost > memo[pos][tank]) continue;\n      if(pos == t) res = min(res, cost);\n      rep(i, (int)G[pos].size()){\n\tint need = G[pos][i].cost;\n\tint nxt = G[pos][i].to;\n\t\n\tif(tank - need >= 0){\n\t  int ntank = LPG[nxt] ? cap : tank - need;\n\t  if(memo[nxt][ntank] > cost + need){\n\t    memo[nxt][ntank] = cost + need;\n\t    que.push(state(cost + need, P(nxt, ntank)));\n\t  } \n\t}\n      }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nmap<string, int> id;\nvector<pi> e[6000];\nint n, m, cap, sz;\nbool f[6000];\nint get(const string &s){\n\tif(id.count(s)) return id[s];\n\treturn id[s] = sz++;\n}\n\nint main(){\n\twhile(cin >> n >> m >> cap, n){\n\t\tid.clear(); sz = 0;\n\t\t\n\t\tstring s, t;\n\t\tcin >> s >> t;\n\t\tint si = get(s), ti = get(t);\n\t\t\n\t\trep(i, n){\n\t\t\tint d, a, b;\n\t\t\tcin >> s >> t >> d;\n\t\t\ta = get(s); b = get(t);\n\t\t\te[a].pb(mp(b, d));\n\t\t\te[b].pb(mp(a, d));\n\t\t}\n\t\tf[si] = f[ti] = 1;\n\t\trep(i, m){\n\t\t\tcin >> s;\n\t\t\tf[get(s)] = 1;\n\t\t}\n\t\tvector<vi> ds;\n\t\tvi ss;\n\t\trep(i, sz) if(f[i]) ss.pb(i);\n\t\t\n\t\trep(ii, ss.size()){\n\t\t\tint s = ss[ii];\n\t\t\tpriority_queue<pi> q;\n\t\t\tq.push(mp(0, s));\n\t\t\tvi dist(sz, inf), d2;\n\t\t\t\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c = q.top().second, co = q.top().first;\n\t\t\t\tq.pop();\n\t\t\t\t\n\t\t\t\tif(dist[c] <= -co) continue;\n\t\t\t\tdist[c] = -co;\n\t\t\t\trep(i, e[c].size()){\n\t\t\t\t\tif(dist[e[c][i].first] > -co + e[c][i].second)\n\t\t\t\t\tq.push(mp(co - e[c][i].second, e[c][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, ss.size()) d2.pb(dist[ss[i]] <= cap * 10 ? dist[ss[i]] : inf);\n\t\t\tds.pb(d2);\n\t\t}\n\t\t\n\t\tint l = ds.size();\n\t\trep(k, l) rep(i, l) rep(j, l) ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\n\t\tcout << (ds[0][1] >= inf ? -1 : ds[0][1]) << endl;\n\t\t\n\t\trep(i, sz) e[i].clear(), f[i] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <queue>\ntypedef long long ll;\n\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nstruct Edge {\n    int src, dst;\n    int weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n    Edge() {}\n};\n\nusing Graph = vector<vector<Edge>>;\n\nint V, E;\nint num_stand; // num of stands\nstring src, dst;\nint cap;\nGraph g;\n\nvector<string> c1, c2;\nvector<int> d;\nvector<string> s;\n\nmap<string, int> m;\n\nconst int inf = 1e9;\n\nint dist[4010][2100]; // at town i with gas j\nint canCharge[6010];\n\nint dijkstra(int s, int t) {\n    fill((int*)begin(dist), (int*)end(dist), inf);\n    priority_queue<tuple<int,int, int>> q;// -dist, town, cap\n    \n    dist[s][cap] = 0;\n    q.emplace(0, s, cap);\n\n    while (q.size()) {\n        int d, v, rem;\n        tie(d, v,rem) = q.top();\n        q.pop();\n        d = -d;\n\n        if (v == t) return d;\n\n        if (dist[v][rem] < d) continue;\n        for (auto &e : g[v]) {\n            int nv = e.dst;\n            int nrem = rem - e.weight;\n            if (nrem < 0) continue;\n            if (canCharge[nv]) {\n                nrem = cap;\n            }\n            int nd = d + e.weight;\n            if (dist[nv][nrem] > nd) {\n                dist[nv][nrem] = nd;\n                q.emplace(-nd, nv, nrem);\n            }\n        }\n    }\n\n    return 1e9;\n}\n\nint main() {\n    while (cin >> E >> num_stand >> cap && E) {\n        m.clear();\n        V = 0;\n        c1.resize(E);\n        c2.resize(E);\n        d.resize(E);\n        cap *= 10;\n        cin >> src >> dst;\n        if (m.count(src) == 0) m[src] = V++;\n        if (m.count(dst) == 0) m[dst] = V++;\n\n        for (int i = 0; i < E; ++i) {\n            cin >> c1[i] >> c2[i] >> d[i];\n            if (m.count(c1[i]) == 0) m[c1[i]] = V++;\n            if (m.count(c2[i]) == 0) m[c2[i]] = V++;\n        }\n\n        memset(canCharge, 0, sizeof(canCharge));\n        s.resize(num_stand);\n        for (int i = 0; i < num_stand; ++i) {\n            cin >> s[i];\n            canCharge[m[s[i]]] = true;\n        }\n\n        g.assign(V, {});\n        for (int i = 0; i < E; ++i) {\n            int a = m[c1[i]];\n            int b = m[c2[i]];\n            g[a].emplace_back(a, b, d[i]);\n            g[b].emplace_back(b, a, d[i]);\n        }\n\n        int ans = dijkstra(m[src], m[dst]);\n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n// const ll inf =1LL << 62;\nconst int inf =1LL << 29;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nint main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 4000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(n, vi(cap + 1, inf));\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=e[j][i]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m+1][m]<inf?e[m+1][m]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){ };\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n};\nmap<string, int> names;\nint memo[2100][2100];\nbool LPG[2100];\nvector<edge> G[2100];\n\nint main(){\n  int cnt;\n  int n, m, cap, d;\n  string src, dst;\n  string c1, c2, str;\n  while(cin >> n >> m >> cap && (n || m || cap)){\n    int res = INF;\n    cnt = 1;\n    cap *= 10;\n    cin >> src >> dst;\n\n    names.clear();\n    rep(i, 2100) G[i].clear();\n    memset(LPG, 0, sizeof(LPG));\n    fill(&memo[0][0], &memo[0][0] + 2100 * 2100, INF);\n    \n    rep(i, n){\n      cin >> c1 >> c2 >> d;\n      if(!names[c1]) names[c1] = cnt++;\n      if(!names[c2]) names[c2] = cnt++;\n      G[names[c1]].push_back(edge(names[c2], d));\n      G[names[c2]].push_back(edge(names[c1], d));\n    }\n    rep(i, m){\n      cin >> str;\n      LPG[names[str]] = true;\n    }\n    int s = names[src];\n    int t = names[dst];\n    memo[s][cap] = 0;\n    priority_queue<state, vector<state>, greater<state> > que;\n    que.push(state(0, P(s, cap)));\n    while(!que.empty()){\n      state st = que.top(); que.pop();\n      int cost = st.first;\n      int pos = st.second.first;\n      int tank = st.second.second;\n      if(cost > memo[pos][tank]) continue;\n      if(pos == t) res = min(res, cost);\n      rep(i, (int)G[pos].size()){\n\tint need = G[pos][i].cost;\n\tint nxt = G[pos][i].to;\n\t\n\tif(tank - need >= 0){\n\t  int ntank = LPG[nxt] ? cap : tank - need;\n\t  if(memo[nxt][ntank] > cost + need){\n\t    memo[nxt][ntank] = cost + need;\n\t    que.push(state(cost + need, P(nxt, ntank)));\n\t  } \n\t}\n      }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<edge> g[6011];\n//vector<vector<edge> > g;\n\nvector<bool> sta;\n//vector<vector<int> > cost;\nint cost[6011][2001];\nint from,to;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    {\n      vector<string> node;\n      scanf(\"%s%s\",s,t);\n      node.push_back(s);\n      node.push_back(t);\n      for( int i = 0; i < n; i++ ) {\n        scanf(\"%s%s%d\",c[i],d[i],w+i);\n        node.push_back(c[i]);\n        node.push_back(d[i]);\n      }\n      for( int i = 0; i < m; i++ ) {\n        scanf(\"%s\",st[i]);\n        node.push_back(st[i]);\n      }\n      sort(node.begin(),node.end());\n      node.erase(unique(node.begin(),node.end()),node.end());\n      int sz = node.size();\n      //g.clear();\n      //cost.clear();\n      sta.clear();\n      //g.resize(sz,vector<edge>());\n      //cost.resize(sz,vector<int>(cap*10+1));\n      sta.resize(sz);\n      for( int i = 0; i < sz; i++ ) {\n        sta[i] = false;\n        g[i].clear();\n        for( int j = 0; j <= cap*10; j++ ) {\n          cost[i][j] = 1919810893;\n        }\n      }\n      for( int i = 0; i < n; i++ ) {\n        int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n        int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n        g[a].push_back(edge(b,w[i]));\n        g[b].push_back(edge(a,w[i]));\n      }\n      for( int i = 0; i < m; i++ ) {\n        sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n      }\n      from = lower_bound(node.begin(),node.end(),s)-node.begin();\n      to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    }\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      if( cost[p.n][p.cap] < p.c ) continue;\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      int idx=(st.count(next)?cap*10:now.c-c);\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[next][idx]);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<stdlib.h>\n#include<ctype.h>\n#include<utility>\n#include<cmath>\n//#include<set>\nusing namespace std;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define eps 1e-8\n#define ll long long\n#define i64 __int64\n#define pb push_back\n#define sz(b) (int)b.size()\n#define lson k<<1\n#define rson k<<1|1\n#define INF 1000000005\n#define MOD 1000000007\n#define CLR(t,x) memset(t,x,sizeof(t));\n#define REP(k,x,y) for(k=x;k<y;k++)\n#define N 6005\nint idx,p[N],nxt[N],vv[N][2],n;\nint idx1,p1[N],nxt1[190005],vv1[190005][2];\nint d[N],vis[N];\nchar s1[25],s2[25],s[305][25];\nmap<string,int> mp;\ntypedef pair<int,int> P;\npriority_queue<P,vector<P>,greater<P> >que;\ninline void add(int u,int v,int w)\n{\n    nxt[idx]=p[u];\n    vv[idx][0]=v,vv[idx][1]=w,p[u]=idx++;\n}\ninline void add1(int u,int v,int w)\n{\n    nxt1[idx1]=p1[u];\n    vv1[idx1][0]=v,vv1[idx1][1]=w,p1[u]=idx1++;\n}\ninline void dijkstra(int st)\n{\n    while(!que.empty()) que.pop();\n    for(int i=1;i<=n;i++) d[i]=INF,vis[i]=0;\n    d[st]=0;que.push(P(d[st],st));\n    while(!que.empty())\n    {\n        P pir=que.top();que.pop();\n        int u=pir.second;\n        if(vis[u]) continue;\n        vis[u]=1;\n        for(int i=p[u];i!=-1;i=nxt[i])\n        {\n            int v=vv[i][0],w=vv[i][1];\n            if(d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                que.push(P(d[v],v));\n            }\n        }\n    }\n}\ninline void dijkstra1(int st)\n{\n    while(!que.empty()) que.pop();\n    for(int i=1;i<=n;i++) d[i]=INF,vis[i]=0;\n    d[st]=0;que.push(P(d[st],st));\n    while(!que.empty())\n    {\n        P pir=que.top();que.pop();\n        int u=pir.second;\n        if(vis[u]) continue;\n        vis[u]=1;\n        for(int i=p1[u];i!=-1;i=nxt1[i])\n        {\n            int v=vv1[i][0],w=vv1[i][1];\n            if(d[v]>d[u]+w)\n            {\n                d[v]=d[u]+w;\n                que.push(P(d[v],v));\n            }\n        }\n    }\n}\nint main()\n{\n    int m,k,cap,w;\n    while(scanf(\"%d%d%d\",&m,&k,&cap)!=EOF)\n    {\n        if(!m&&!k&&!cap) break;\n        char st[25],ed[25];\n        mp.clear();idx=n=0;CLR(p,-1);\n        scanf(\"%s%s\",st,ed);\n        if(!mp[st]) mp[st]=++n;\n        if(!mp[ed]) mp[ed]=++n;\n        int sst=mp[st],eed=mp[ed];\n        while(m--)\n        {\n            scanf(\"%s%s%d\",s1,s2,&w);\n            if(!mp[s1]) mp[s1]=++n;\n            if(!mp[s2]) mp[s2]=++n;\n            int u=mp[s1],v=mp[s2];\n            add(u,v,w);add(v,u,w);\n        }\n        for(int i=0;i<k;i++)\n        {\n            scanf(\"%s\",s[i]);\n            if(!mp[s[i]]) mp[s[i]]=++n;\n        }\n        idx1=0;CLR(p1,-1);\n        for(int i=0;i<k;i++)\n        {\n            int u=mp[s[i]];\n            dijkstra(u);\n            for(int j=0;j<k;j++)\n            {\n                if(j==i) continue;\n                int v=mp[s[j]];\n                if(d[v]<=cap*10)\n                {\n                    add1(u,v,d[v]);\n                    add1(v,u,d[v]);\n                }\n            }\n            if(d[sst]<=cap*10) add1(u,sst,d[sst]),add1(sst,u,d[sst]);\n            if(d[eed]<=cap*10) add1(u,eed,d[eed]),add1(eed,u,d[eed]);\n        }\n        dijkstra1(sst);\n        if(d[eed]==INF) puts(\"-1\");\n        else printf(\"%d\\n\",d[eed]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<MAX_V;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      if(now.c==c && !st.count(next) && next!=g)continue;\n\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nvector<string>v,from,to;\nvector<int>cost;\nmap<string,int>id;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<string,int> con;\nvector<pii> graph[6010];\nint dist[6010][2010];\nbool station[6010];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v,int g){\n\tif(g>=0&&(dist[v][g]==-1||dist[v][g]>c)){\n\t\tdist[v][g]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint dijkstra(int cap){\n\tdist[0][cap]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(dist[v][g]<c)\n\t\t\tcontinue;\n\n\t\tif(station[v]){\n\t\t\tg=cap;\n\t\t\tupdate(c,v,g);\n\t\t}\n\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tint ng=g-v2.second;\n\t\t\tif(update(nc,v2.first,ng)){\n\t\t\t\tstate next(nc,v2.first,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tint n,m,cap;\n\tclr(dist,-1);\n\twhile(cin >> n >> m >> cap){\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[con[s]]=true;\n\t\t}\n\t\tint ans=dijkstra(cap*10);\n\t\tcout << ans << endl;\n\t\tcon.clear();\n\t\tclr(dist,-1);\n\t\trep(i,6010) graph[i].clear();\n\t\tclr(station,false);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      assert(0 <= c1 && c1 < N);\n      assert(0 <= c2 && c2 < N);\n#if 0\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[7001];\nvector<edge> GG[7001];\nmap<string,int> city;\nint dp[7000];\nbool flag[7000];\n\nvoid make_path(int v){\n\tfill(dp,dp+city.size(),cap+1);\n\tpriority_queue<data> que;\n\tque.push(edge(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t\tGG[q.t].push_back(edge(v,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(edge(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst ll NONE=-1;\n\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvi dist(n,vi(n,NONE));\n    vs cities;\n    REP(i,n){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai][bi]=d;\n      dist[bi][ai]=d;\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n     while(0){//!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(i,n){\n        if(i!=cnode.index&&dist[cnode.index][i]!=NONE){\n          ll newcost=cnode.cost+dist[cnode.index][i];\n          int newgas=cnode.gas-dist[cnode.index][i];\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n \nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n \ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n \nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n \nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n \nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      string ssrc,sdest;\n      int src,dest;\n\n      idx = 0;\n      index.clear();\n      rep(i,MAX)G[i].clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n \n      rep(i,N)\n    {\n      string c1,c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      add_edge(c1,c2,d);\n    }\n \n      assert(idx <= MAX);\n\n\trep(i,idx) \n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}    \n \n      rep(i,M)\n    {\n      string s;\n      cin >> s;\n      LPG[index[s]] = true;\n    }\n \n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n \n      while(!que.empty())\n    {\n      Pox pox = que.top(); que.pop();\n       \n      if(ans <= pox.cost)continue;\n       \n      if(pox.cur == dest)\n        {\n          ans = min(ans,pox.cost);\n          break;\n        }\n \n      for(int i=0;i<G[pox.cur].size();i++)\n        {\n          P p = G[pox.cur][i];\n          int fuelConsumption = pox.tank - p.d; \n          int next = p.to;\n          if(p.d > pox.tank)continue;\n          if(p.d == pox.tank && !LPG[next])continue;\n \n          if(mincost[next][fuelConsumption] > pox.cost + p.d)\n        {\n          mincost[next][fuelConsumption] = pox.cost + p.d;\n          if(LPG[next])\n\t    {        \n\t      que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t      for(int j=cap*10;j>=0;j--)mincost[next][j] = min(mincost[next][j],mincost[next][cap*10]);\n\t    }\n\t  else\n\t    {\n\t      que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t      for(int j=fuelConsumption;j>=0;j--)mincost[next][j] = min(mincost[next][j],mincost[next][fuelConsumption]);\n\t    }\n        }\n        }\n    }\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename T>\nvector<int> dijkstra(const vector<vector<pair<int,T>>> &G,int s,T inf) {\n  vector<int> d(G.size(),inf);\n  d[s] = 0;\n  using P = pair<T,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,s);\n  while (!que.empty()) {\n    T dd; int v;\n    tie(dd,v) = que.top(); que.pop();\n    if (d[v] < dd) continue;\n    for (auto e : G[v]) {\n      if (d[e.first] > d[v]+e.second) {\n        d[e.first] = d[v]+e.second;\n        que.emplace(d[e.first],e.first);\n      }\n    }\n  }\n  return d;\n}\n\nint N,M,cap;\nstring src,dst;\nstring c[2][3010];\nint d[3010];\nstring s[310];\nint dis[310][310];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> M >> cap, N) {\n    cin >> src >> dst;\n    map<string,int> mp;\n    mp[src] = mp.size();\n    mp[dst] = mp.size();\n    REP(i,N) {\n      cin >> c[0][i] >> c[1][i] >> d[i];\n      if (mp.count(c[0][i]) == 0) mp[c[0][i]] = mp.size();\n      if (mp.count(c[1][i]) == 0) mp[c[1][i]] = mp.size();\n    }\n    REP(i,M) {\n      cin >> s[i];\n      if (mp.count(s[i]) == 0) mp[s[i]] = mp.size();\n    }\n    vector<vector<pii>> G(mp.size());\n    REP(i,N) {\n      int u = mp[c[0][i]];\n      int v = mp[c[1][i]];\n      G[u].emplace_back(v,d[i]);\n      G[v].emplace_back(u,d[i]);\n    }\n    map<int,int> cnv;\n    vector<string> inv_cnv(310);\n    REP(i,M) {\n      inv_cnv[cnv.size()] = s[i];\n      cnv[mp[s[i]]] = cnv.size();\n    }\n    if (cnv.count(mp[src]) == 0) {\n      inv_cnv[cnv.size()] = src;\n      cnv[mp[src]] = cnv.size();\n    }\n    if (cnv.count(mp[dst]) == 0) {\n      inv_cnv[cnv.size()] = dst;\n      cnv[mp[dst]] = cnv.size();\n    }\n\n    MINF(dis);\n    int sz = G.size();\n    REP(i,cnv.size()) {\n      vector<int> dd = dijkstra<int>(G,mp[inv_cnv[i]],INF);\n      for (int j = 0; j < sz; j++) {\n        if (cnv.count(j) && dd[j] <= cap*10) {\n          // cout << i << \" \" << cnv[j] << \" \" << dd[j] << endl;\n          dis[i][cnv[j]] = dis[cnv[j]][i] = dd[j];\n        }\n      }\n    }\n    // cout << \"src = \" << src << \" : \" << cnv[mp[src]] << endl;\n    // cout << \"dst = \" << dst << \" : \" << cnv[mp[dst]] << endl;\n    // REP(i,M) {\n    //   cout << \"s[\" << i << \"] = \" << s[i] << \" : \" << cnv[mp[s[i]]] << endl;\n    // }\n    // REP(i,cnv.size()) REP(j,cnv.size()) {\n    //   cout << \"i = \" << i << \" j = \" << j << \" dis = \" << dis[i][j] << endl;\n    // }\n    REP(k,cnv.size()) REP(i,cnv.size()) REP(j,cnv.size()) {\n      CHMIN(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n    int ans = dis[cnv[mp[src]]][cnv[mp[dst]]];\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    map<int,vector<Node> > nodes;\n    map<int,int> dp[6001]; //dp[city_id][remaining_LPG] = dist;\n\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tmap<int,int>::iterator it = dp[to].find(next_remaining_LPG);\n\tif(it != dp[to].end() \n\t   && it->second <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      map<int,int>::iterator it = dp[dst_id].find(remaining_LPG);\n      if(it == dp[dst_id].end()) continue;\n      res = min(it->second,res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<Edge> edges;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges.push_back(Edge(from_num,to_num,dist));\n      edges.push_back(Edge(to_num,from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nmap<string, int> id;\nvector<pi> e[6000];\nint n, m, cap, sz;\nbool f[6000];\nint get(const string &s){\n\tif(id.count(s)) return id[s];\n\treturn id[s] = sz++;\n}\n\nint main(){\n\twhile(cin >> n >> m >> cap, n){\n\t\tid.cleaar(); sz = 0;\n\t\t\n\t\tstring s, t;\n\t\tcin >> s >> t;\n\t\tint si = get(s), ti = get(t);\n\t\t\n\t\trep(i, n){\n\t\t\tint d, a, b;\n\t\t\tcin >> s >> t >> d;\n\t\t\ta = get(s); b = get(t);\n\t\t\te[a].pb(mp(b, d));\n\t\t\te[b].pb(mp(a, d));\n\t\t}\n\t\tf[si] = f[ti] = 1;\n\t\trep(i, m){\n\t\t\tcin >> s;\n\t\t\tf[get(s)] = 1;\n\t\t}\n\t\tvector<vi> ds;\n\t\tvi ss;\n\t\trep(i, sz) if(f[i]) ss.pb(i);\n\t\t\n\t\trep(ii, ss.size()){\n\t\t\tint s = ss[ii];\n\t\t\tpriority_queue<pi> q;\n\t\t\tq.push(mp(0, s));\n\t\t\tvi dist(sz, inf), d2;\n\t\t\t\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c = q.top().second, co = q.top().first;\n\t\t\t\tq.pop();\n\t\t\t\t\n\t\t\t\tif(dist[c] <= -co) continue;\n\t\t\t\tdist[c] = -co;\n\t\t\t\trep(i, e[c].size()){\n\t\t\t\t\tif(dist[e[c][i].first] > -co + e[c][i].second)\n\t\t\t\t\tq.push(mp(co - e[c][i].second, e[c][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, ss.size()) d2.pb(dist[ss[i]] <= cap * 10 ? dist[ss[i]] : inf);\n\t\t\tds.pb(d2);\n\t\t}\n\t\t\n\t\tint l = ds.size();\n\t\trep(k, l) rep(i, l) rep(j, l) ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\n\t\tcout << (ds[0][1] >= inf ? -1 : ds[0][1]) << endl;\n\t\t\n\t\trep(i, sz) e[i].clear(), f[i] = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 3005\n#define M 2005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint n,m,cap,d[N][M],n_max;\nmap<string,int> num;\nstring src,dest;\nvector<P> G[N];\nset<int> lpc;\n\nint dijkstra(int s,int g){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  for(int i=0;i<n_max;i++)\n    for(int j=0;j<=cap*10;j++)\n      d[i][j]=INF;\n  q.push(P1(0,P(s,cap*10)));\n  d[s][cap*10]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int cost=t.first;\n    int node=t.second.first;\n    int c=t.second.second;\n    if(d[node][c]<cost)continue;\n    if(node==g)return cost;\n    for(int i=0;i<G[node].size();i++){\n      int ncost=cost+G[node][i].second;\n      int nnode=G[node][i].first;\n      int nc=c-G[node][i].second;\n      if(nc<0)continue;\n      if(d[nnode][nc]>ncost){\n\td[nnode][nc]=ncost;\n\tq.push(P1(ncost,P(nnode,nc)));\n      }\n      if(lpc.count(nnode)){\n\tnc=cap*10;\n\tif(d[nnode][nc]>ncost){\n\t  d[nnode][nc]=ncost;\n\t  q.push(P1(ncost,P(nnode,nc)));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;\n    if(!n&&!m&&!cap)break;\n    cin>>src>>dest;\n    string a,b;\n    int c;\n    n_max=0;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(!num.count(a))num[a]=n_max++;\n      if(!num.count(b))num[b]=n_max++;\n      G[num[a]].push_back(P(num[b],c));\n      G[num[b]].push_back(P(num[a],c));\n    }\n    if(!num.count(src))num[src]=n_max++;\n    if(!num.count(dest))num[dest]=n_max++;\n    for(int i=0;i<m;i++){\n      cin>>a;\n      lpc.insert(num[a]);\n    }\n    int s=num[src],g=num[dest];\n    cout<<dijkstra(s,g)<<endl;\n    num.clear();\n    lpc.clear();\n    for(int i=0;i<n_max;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3030][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3030; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 1000000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<V;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 6001;\nconst int MAX_CAP = 202;\n\nstruct Edge {\n  int to, cost;\n  Edge() {}\n  Edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct State {\n  int p, cost, oil;\n  State() {}\n  State(int p, int cost, int oil) : p(p), cost(cost), oil(oil) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(oil != s.oil) return oil < s.oil;\n    return p < s.p;\n  }\n};\n\nint Cap, num, Src, Dist;\n\nmap<string, int> id;\nvector<Edge> E[MAX_N];\n\nbool existS[MAX_N];\nint cost[MAX_N][MAX_CAP];\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = num++;\n  }\n  return id[s];\n}\n\n\nint solve() {\n  priority_queue<State> que;\n  State s(Src, 0, Cap);\n  que.push(s);\n  fill(cost[0], cost[num], -1);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n\n    if(cost[s.p][s.oil] != -1) continue;\n    cost[s.p][s.oil] = s.cost;\n    if(s.p == Dist) return s.cost;\n    if(existS[s.p]) s.oil = Cap;\n    for(int i = 0; i < E[s.p].size(); ++i) {\n      int nextOil = s.oil - E[s.p][i].cost;\n      if(nextOil < 0) continue;\n      if(cost[E[s.p][i].to][nextOil] != -1) continue;\n      que.push(State(E[s.p][i].to, s.cost + E[s.p][i].cost, nextOil));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M >> Cap && (N | M | Cap)) {\n    num = 0;\n    Cap *= 10;\n    id.clear();\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n\n    string src, dist;\n    cin >> src >> dist;\n    Src = getId(src);\n    Dist = getId(dist);\n    for(int i = 0; i < N; ++i) {\n      string from, to;\n      int d;\n      cin >> from >> to >> d;\n      E[getId(from)].push_back(Edge(getId(to), d));\n      E[getId(to)].push_back(Edge(getId(from), d));\n    }\n\n    fill(existS, existS+MAX_N, false);\n    for(int i = 0; i < M; ++i) {\n      string name;\n      cin >> name;\n      existS[getId(name)] = true;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, int s, Array &d)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n)\n\t{\n\t\tmap<string, int> mp;\n\t\tstring src, dst; cin >> src >> dst;\n\t\tmp[src] = 0, mp[dst] = 1;\n\t\tint cnt = 2;\n\t\tGraph g;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s, t; cin >> s >> t;\n\t\t\tif (!mp.count(s))\n\t\t\t{\n\t\t\t\tmp[s] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (!mp.count(t))\n\t\t\t{\n\t\t\t\tmp[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg.resize(cnt);\n\t\t\tint d; cin >> d;\n\t\t\tadd_edge(g, mp[s], mp[t], d);\n\t\t\tadd_edge(g, mp[t], mp[s], d);\n\t\t}\n\t\tvi sta = { 0,1 };\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tsta.push_back(mp[s]);\n\t\t}\n\t\tGraph h(sta.size());\n\t\tREP(i, sta.size())\n\t\t{\n\t\t\tArray d;\n\t\t\tdijkstra(g, sta[i], d);\n\t\t\tREP(j, sta.size())\n\t\t\t{\n\t\t\t\tif (d[sta[j]] <= cap * 10) add_edge(h, i, j, d[sta[j]]);\n\t\t\t}\n\t\t}\n\t\tArray ans;\n\t\tdijkstra(h, 0, ans);\n\t\tif (ans[1] == INF) puts(\"-1\");\n\t\telse cout << ans[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(now.id!=s && mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<int> > dist( n, vector<int>( n, INF ) );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\tdist[a][b] = dist[b][a] = d[i];\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\n\tfor( int k = 0; k < n; ++k ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tfor( int j = 0; j < i; ++j ){\n\t\t\t\tif( dist[i][j] > dist[i][k] + dist[k][j] ){\n\t\t\t\t\tdist[i][j] = dist[j][i] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nreturn 0;\n\tcap *= 10;\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\ttypedef pair<int,int> pii;\n\tpriority_queue< pii, deque<pii>, greater<pii> > pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[n_from][n_to] <= cap && dp[to] > dp[from] + dist[n_from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[n_from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, int> PII;\ntypedef tuple<LL, int, int> PIII;\n\nconstexpr int N = 3000, M = 300;\nconstexpr LL INF = LLONG_MAX/2;\n\nint n, m, cap;\nLL dis[2*N+2], tmp_dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n\ninline LL solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      sid.emplace(s0, sid.size());\n      adj[sid.size()].clear();\n    }\n    if(!sid.count(s1)) {\n      sid.emplace(s1, sid.size());\n      adj[sid.size()].clear();\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n\t\tif(dis[nxt0.S] <= nxt0.F)\n      continue;    \n    dis[nxt0.S] = nxt0.F;\n    fill(tmp_dis, tmp_dis+mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    //if(tmp_dis[1] != INF)\n    //  return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i])\n        pq0.emplace(tmp_dis[i], i);\n  }\n  if(dis[1] >= INF)\n    return -1;\n  else\n    return dis[1];\n}\n\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int N=6002,M=300;\nconst int INF=123456789;\n\nstruct edge{int to,cost;};\nvector<edge> G[N], g[M];\n\nint d[N];\nvoid dijkstra(int start)\n{\n    fill(d,d+N,INF);\n\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    d[start]=0;\n    que.push(pi(0,start));\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint solve()\n{\n    fill(d,d+M,INF);\n\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    d[0]=0;\n    que.push(pi(0,0));\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,g[v].size())\n        {\n            edge e=g[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n\n    return d[1];\n}\n\nvoid init()\n{\n    rep(i,N) G[i].clear();\n    rep(i,M) g[i].clear();\n}\n\nint main()\n{\n    int n,m,cap;\n    while(cin >>n >>m >>cap,n)\n    {\n        init();\n\n        string src,dest;\n        cin >>src >>dest;\n\n        map<string,int> name_to_id;\n        name_to_id[src]=0;\n        name_to_id[dest]=1;\n\n        int now=2;\n        rep(i,n)\n        {\n            string a,b;\n            int D;\n            cin >>a >>b >>D;\n\n            if(name_to_id.find(a) == name_to_id.end()) name_to_id[a]=now++;\n            if(name_to_id.find(b) == name_to_id.end()) name_to_id[b]=now++;\n\n            int A=name_to_id[a], B=name_to_id[b];\n            G[A].pb(edge{B,D});\n            G[B].pb(edge{A,D});\n        }\n\n        vector<string> st(m);\n        rep(i,m) cin >>st[i];\n\n        dijkstra(0);\n        rep(i,m)\n        {\n            int s=name_to_id[st[i]];\n            if(d[s] <= cap*10)\n            {\n                g[0].pb(edge{i+2,d[s]});\n            }\n        }\n        if(d[1] <= cap*10) g[0].pb(edge{1,d[1]});\n\n        rep(i,m)\n        {\n            int s=name_to_id[st[i]];\n            if(s<=1) continue;\n\n            dijkstra(s);\n            rep(j,m)\n            {\n                int t=name_to_id[st[j]];\n                if(d[t] <= cap*10) g[i+2].pb(edge{j+2,d[t]});\n            }\n            if(d[1] <= cap*10) g[i+2].pb(edge{1,d[1]});\n        }\n\n        int ans=solve();\n        if(ans==INF) ans=-1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct In {\n  string s1, s2;\n  int d;\n};\nstruct Edge {\n  int from, to, d;\n};\nvoid solve(int n, int m, int cap) {\n  cap *= 10;\n  string ssrc, sdest; cin >> ssrc >> sdest;\n  vector<In> sv(n);\n  map<string ,int> mp;\n  int id = 1;\n  for(int i=0;i<n;++i) {\n    string s1, s2; int d; cin >> s1 >> s2 >> d;\n    sv[i] = {s1, s2, d};\n    if(mp[s1] == 0) {\n      mp[s1] = id;\n      id++;\n    }\n    if(mp[s2] == 0) {\n      mp[s2] = id;\n      id++;\n    }\n  }\n  int src = mp[ssrc]-1, dest = mp[sdest]-1;\n  vector<vector<Edge>> v(id);\n  for(int i=0;i<n;++i) {\n    v[mp[sv[i].s1]-1].push_back({mp[sv[i].s1]-1, mp[sv[i].s2]-1, sv[i].d});\n    v[mp[sv[i].s2]-1].push_back({mp[sv[i].s2]-1, mp[sv[i].s1]-1, sv[i].d});\n  }\n  map<int, bool> gas;\n  for(int i=0;i<m;++i) {\n    string s; cin >> s;\n    gas[mp[s]-1] = true;\n  }\n  vll dist(id * (cap+1), INF);\n  priority_queue<P, vector<P>, greater<P>> pq;\n  dist[src * (cap+1) + cap] = 0;\n  pq.push({0, src * (cap+1) + cap});\n  while(!pq.empty()) {\n    auto now = pq.top(); pq.pop();\n    int val = now.first, idx = now.second / (cap+1), nowcap = now.second % (cap+1);\n    if(dist[idx * (cap + 1) + nowcap] < val) continue;\n    for(int i=0;i<(int)(v[idx].size());++i) {\n      int nxt = v[idx][i].to, cost = v[idx][i].d;\n      if(nowcap < cost) continue;\n      if(gas[nxt] && dist[nxt * (cap + 1) + cap] > val + cost) {\n        dist[nxt * (cap + 1) + cap] = val + cost;\n        pq.push({val + cost, nxt * (cap+1) + cap});\n      } else if(!gas[nxt] && dist[nxt * (cap + 1) + (nowcap - cost)] > val + cost) {\n        dist[nxt * (cap + 1) + (nowcap - cost)] = val + cost;\n        pq.push({val + cost, nxt * (cap+1) + (nowcap - cost)});\n      }\n    }\n  }\n  ll ans = INF;\n  for(int i=0;i<=cap;++i) {\n    ans = min(ans, dist[dest * (cap+1) + i]);\n  }\n  cout << (ans == INF ? -1 : ans) << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m, cap; cin >> n >> m >> cap;\n    if(n == 0 && m == 0) break;\n    solve(n, m, cap);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst int mod = 1000000007;\nconst double PI = acos(-1.0); \n\n\n\nstruct P\n{\n\tint p, c, f;\n\tP(int p, int c, int f)\n\t\t: p(p), c(c), f(f) { }\n\n\tbool operator<(const P& b) const\n\t{\n\t\treturn c > b.c;\n\t}\n};\nint nono(map<string, int>& no, const string& s)\n{\n\tif (!no.count(s))\n\t{\n\t\tint t = no.size();\n\t\tno[s] = t;\n\t}\n\treturn no[s];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n)\n\t{\n\t\tcap *= 10;\n\n\t\tvector<vector<pint> > e(2 * n);\t// pint(cost, to)\n\t\tbool gas[6010];\n\t\tCL(gas, 0);\n\n\t\tmap<string, int> no;\n\t\tconst int src = 0, dest = 1;\n\n\t\t{\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b;\n\t\t\tno[a] = src, no[b] = dest;\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tint d;\n\t\t\t\tcin >> a >> b >> d;\n\t\t\t\tint x = nono(no, a), y = nono(no, b);\n\t\t\t\te[x].push_back(pint(d, y));\n\t\t\t\te[y].push_back(pint(d, x));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\tcin >> a, gas[nono(no, a)] = true;\n\t\t}\n\n\n\t\tconst int INF = 1 << 30;\n\t\tstatic int dis[6010][2010];\n\t\tfor (int i = 0; i < no.size(); ++i)\n\t\t\tfor (int j = 0; j <= cap; ++j)\n\t\t\t\tdis[i][j] = INF;\n\n\t\tpriority_queue<P> q;\n\t\tdis[src][cap] = 0;\n\t\tq.push(P(src, 0, cap));\n\n\t\tint res = -1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP cur = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = cur.p, c = cur.c, f = cur.f;\n\t\t\tif (c > dis[p][f])\n\t\t\t\tcontinue;\n\t\t\telse if (p == dest)\n\t\t\t{\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e[p].size(); ++i)\n\t\t\t{\n\t\t\t\tint to = e[p][i].second;\n\t\t\t\tint d = e[p][i].first;\n\t\t\t\tint nc = c + d;\n\t\t\t\tint nf = f - d;\n\t\t\t\tif (nf >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (gas[to])\n\t\t\t\t\t\tnf = cap;\n\t\t\t\t\tif (nc < dis[to][nf])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[to][nf] = nc;\n\t\t\t\t\t\tq.push(P(to, nc, nf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 6030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n//\t\tfor(i = 0; i < MAX_V; i++)\n//\t\tif(!G[i].empty())\n//\t\t\tG[i].clear();\n//\t\tfor(i = 0; i < MAX_V; i++)\n//\t\tif(!GG[i].empty())\n//\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=e[j][i]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m+1][m]<inf?e[m+1][m]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<Edge> edges;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges.push_back(Edge(from_num,to_num,dist));\n      edges.push_back(Edge(to_num,from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\nshort n,m,l,qq;\n#define MAXN 3001\nvector < pair<short,int> > a[MAXN];\nconst int inf = 0x7fffffff;\nint d[MAXN][2001];\nbool bo[MAXN][2001],p[MAXN];\nmap <string , int> hash;\nstruct node\n{\n    short d;\n    short c;\n};\nqueue<node> q;\nvoid  spfa(node &s)\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int j = 0; j <= l; ++j)\n        {\n            d[i][j]=inf;\n        }\n    }\n    memset(bo,0,sizeof(bo));\n    d[s.d][s.c]=0;bo[s.d][s.c]=1;\n    while (!q.empty()) q.pop();\n    q.push(s);\n    while (!q.empty())\n    {\n        node now=q.front();\n        q.pop();\n        bo[now.d][now.c]=0;\n        for (int i =0; i < a[now.d].size(); ++i)\n        {\n            int v = a[now.d][i].first;\n            int abc = a[now.d][i].second;\n            int se = now.c - abc;\n            if (p[v])\n            {\n                se = l;\n            }\n            if (now.c - abc >=0 && d[v][se]-abc>d[now.d][now.c])\n            {\n                d[v][se]=abc+d[now.d][now.c];\n                if (!bo[v][se])\n                {\n                    bo[v][se]=1;\n                    node temp;\n                    temp.d=v;\n                    temp.c=se;\n                    q.push(temp);\n                }\n            }\n        }\n    }\n}\nstring temp,temp2;\nint main(int argc, char const *argv[])\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    while (cin>>m>>qq>>l)\n    {\n        if (m==0 && qq==0 && l==0) break;\n        hash.clear();\n        l *= 10;\n        for (int i = 0; i < MAXN; ++i)\n        {\n            a[i].clear();\n        }\n        memset(p,0,sizeof(p));\n        n=0;\n        short s,t;\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        s=hash[temp];\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        t=hash[temp];\n        for (int i = 0; i < m; ++i)\n        {\n            cin>>temp>>temp2;\n            int x,y,z;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            if (!hash.count(temp2))\n            {\n                hash[temp2]=++n;\n            }\n            x=hash[temp];\n            y=hash[temp2];\n            cin>>z;\n            if (z <= l)\n            {\n                a[x].push_back(make_pair(y,z));\n                a[y].push_back(make_pair(x,z));\n            }\n        }\n        for (int i = 0; i < qq; ++i)\n        {\n            cin>>temp;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            int x=hash[temp];\n            p[x]=1;\n        }\n        node ini;\n        ini.d=s;\n        ini.c=l;\n        spfa(ini);\n        int ans=inf;\n        for (int i = 0; i <= l; ++i)\n        {\n            ans=min(ans,d[t][i]);\n        }\n        if (ans==inf)\n        {\n            puts(\"-1\");\n        }\n        else\n        {\n            printf(\"%d\\n\",ans );\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst int NONE=-1;\n\nint main(){\n  int r,m,cap;\n  while(cin>>r>>m>>cap,r|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvi dist(2*r,vi(2*r,NONE));\n    vs cities;\n    REP(i,r){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai][bi]=d;\n      dist[bi][ai]=d;\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    int n=cities.size();\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n     while(0){//!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(i,n){\n        if(i!=cnode.index&&dist[cnode.index][i]!=NONE){\n          ll newcost=cnode.cost+dist[cnode.index][i];\n          int newgas=cnode.gas-dist[cnode.index][i];\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,remain,cost;\n\tnode(int index,int remain,int cost):index(index),remain(remain),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint main() {\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        int nc=cities.size();\n        vvi g(nc,vi(nc,NONE));\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(nc);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n        priority_queue<node> q;\n        q.push(node(src_i,cap,0));\n        vvi cost(nc,vi(cap+1,MAX));\n        cost[0][cap]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.remain]<cnode.cost){\n                continue;\n\t\t    }\n            REP(i,nc){\n                if(g[cnode.index][i]!=NONE){\n                    int newremain=cnode.remain-g[cnode.index][i];\n                    int newcost=cnode.cost+g[cnode.index][i];\n                    if(newremain>=0){\n                        newremain=station[i] ? cap : newremain;\n\t\t\t\t\t\tif(cost[i][newremain]>newcost){\n                            cost[i][newremain]=newcost;\n                            q.push(node(i,newremain,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n        int ans=MAX;\n        REP(i,cap+1){\n            ans=min(ans,cost[dst_i][i]);\n\t    }\n        cout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n\nconstexpr int N = 3000, M = 300, INF = INT_MAX/2;\n\nint n, m, cap, dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline int solve() {\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  sid.emplace(s1, 1);\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      sid.emplace(s0, sid.size());\n      adj[sid.size()].clear();\n    }\n    if(!sid.count(s1)) {\n      sid.emplace(s1, sid.size());\n      adj[sid.size()].clear();\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  dis[0] = 0;\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    //cerr << \"cost \" << nxt0.F << \" id \" << nxt0.S << endl;\n\n    vector<int> tmp_dis(mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    if(tmp_dis[1] != INF)\n      return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  if(dis[1] == INF)\n    return -1;\n  else\n    return dis[1];\n}\n\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MT make_tuple\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint N, M, C, SZ;\nvector<Edge> G[6001];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[src] = SZ++;\n\tcor[dest] = SZ++;\n\tC *= 10;\n\tREP(i,6010) G[i].clear();\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = SZ++;\n\t  if(!cor.count(s2)) cor[s2] = SZ++;\n\t  int u = cor[s1], v = cor[s2];\n\t  G[u].PB(Edge(v,d));\n\t  G[v].PB(Edge(u,d));\n\t}\n\n\tset<int> LPG;\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  LPG.insert(cor[s]);\n\t}\n\n\ttypedef tuple<int,int,int> Node;\n\tVVI dist(SZ, VI(C+1,INF));\n\tpriority_queue<Node, vector<Node>, greater<Node> > pq;\n\t//\tfill((int*)dist, (int*)dist+6010*2010, INF);\n\tdist[0][C] = 0;\n\tpq.push(MT(0,0,C));\n\n\tint ans = INF;\n\twhile(!pq.empty()){\n\t  auto tp = pq.top(); pq.pop();\n\t  int c, v, f;\n\t  tie(c,v,f) = tp;\n\t  if(v == 1){\n\t\tans = c; break;\n\t  }\n\t  if(dist[v][f] < c) continue;\n\t  for(int i=0;i<G[v].size();++i){\n\t\tconst Edge& e = G[v][i];\n\t\tint d = e.cost;\n\t\tif(f < d) continue;\n\t\tint nf = LPG.count(e.to)? C: f-d;\n\t\tif(dist[e.to][nf] > dist[v][f] + d){\n\t\t  dist[e.to][nf] = dist[v][f] + d;\n\t\t  pq.push(MT(dist[e.to][nf], e.to, nf));\n\t\t}\n\t  }\n\t}\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n    map<int,int> dp[6001]; //dp[city_id][remaining_LPG] = dist;\n\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tmap<int,int>::iterator it = dp[to].find(next_remaining_LPG);\n\tif(it != dp[to].end() \n\t   && it->second <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      map<int,int>::iterator it = dp[dst_id].find(remaining_LPG);\n      if(it == dp[dst_id].end()) continue;\n      res = min(it->second,res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<set>\n#include<map>\n#include<limits>\nusing namespace std;\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define output freopen(\"output.txt\",\"w\",stdout)\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_NULL(a) memset(a,NULL,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define ll long long\n#define eps\n#define MOD\n#define MAXN\n#define N 3010\n#define M\nstruct Vertex\n{\n    int realcost;\n    int cost;\n    int id;\n    friend bool operator<(const Vertex a,const Vertex b)\n    {\n        return a.cost>b.cost;\n    }\n}v,newv,vt;\npriority_queue<Vertex>q;\nstruct Edge\n{\n    int from;\n    int next;\n    int to;\n    int cost;\n}edge[2*N];\nbool oil[N];\nint head[N];\nint cost[N];\nint realcost[N];\nint n,m,cap;\nint mostdis;\nint ans;\nmap<string,int>m1;\nmap<int,string>m2;\nstring sta;\nstring des;\nvoid dijkstra()\n{\n    clr_queue(q);\n    v.id=1;\n    v.cost=0;\n    v.realcost=0;\n    q.push(v);\n    clr_INT(cost);\n    cost[1]=0;\n    clr_INT(realcost);\n    cost[1]=0;\n    int i,now,to,cos;\n    ans=INT;\n    while(!q.empty())\n    {\n        v=q.top();\n        q.pop();\n        now=v.id;\n        for(i=head[now];i!=-1;i=edge[i].next)\n        {\n            to=edge[i].to;\n            cos=edge[i].cost;\n            if(v.cost+cos<=mostdis)\n            {\n                newv.id=to;\n                newv.cost=v.cost+cos;\n                if(oil[to]) newv.cost=0;\n                newv.realcost=v.realcost+cos;\n                if(newv.cost>=cost[to] && newv.realcost>=realcost[to]) continue;\n                q.push(newv);\n                cost[to]=min(cost[to],newv.cost);\n                realcost[to]=min(realcost[to],newv.realcost);\n            }\n        }\n    }\n}\nint main()\n{\n//    input;\n    string cc1,cc2;\n    int d,w,a,c1=1,c2=1,t;\n    while(~scanf(\"%d %d %d\",&n,&m,&cap) && (n+m+cap))\n    {\n        mostdis=cap*10;\n        w=0;\n        a=0;\n        clr_minus1(head);\n        m1.clear();\n        m2.clear();\n        cin>>sta>>des;\n        a++;\n        m1[sta]=a;\n        m2[a]=sta;\n        a++;\n        m1[des]=a;\n        m2[a]=des;\n        repin(i,1,n)\n        {\n            cin>>cc1>>cc2;\n            if(!m1[cc1])\n            {\n                a++;\n                c1=a;\n                m1[cc1]=a;\n                m2[a]=cc1;\n            }\n            else c1=m1[cc1];\n            if(!m1[cc2])\n            {\n                a++;\n                c2=a;\n                m1[cc2]=a;\n                m2[a]=cc2;\n            }\n            else c2=m1[cc2];\n            scanf(\"%d\",&d);\n            edge[w].from=c1;\n            edge[w].to=c2;\n            edge[w].cost=d;\n            edge[w].next=head[c1];\n            head[c1]=w++;\n            \n            edge[w].from=c2;\n            edge[w].to=c1;\n            edge[w].cost=d;\n            edge[w].next=head[c2];\n            head[c2]=w++;\n        }\n        clr_false(oil);\n        repin(i,1,m)\n        {\n            cin>>cc1;\n            t=m1[cc1];\n            oil[t]=true;\n        }\n        dijkstra();\n        printf(\"%d\\n\",realcost[2]==INT?-1:realcost[2]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 2000) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 2000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<string>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,d; };\n\nint main(){\n\tfor(int m,ng,cap;scanf(\"%d%d%d\",&m,&ng,&cap),m;){\n\t\tcap*=10;\n\n\t\tint n=0; // number of cities\n\t\tvector<edge> adj[7000];\n\t\tbool gas[7000]={};\n\n\t\tmap<string,int> id;\n\t\tchar ss[16],tt[16]; scanf(\"%s%s\",&ss,&tt);\n\t\tif(id.count(ss)==0) id[ss]=n++;\n\t\tif(id.count(tt)==0) id[tt]=n++;\n\t\tint s=id[ss],t=id[tt];\n\n\t\trep(i,m){\n\t\t\tchar a[16],b[16];\n\t\t\tint d; scanf(\"%s%s%d\",a,b,&d);\n\t\t\tif(id.count(a)==0) id[a]=n++;\n\t\t\tif(id.count(b)==0) id[b]=n++;\n\n\t\t\tint u=id[a],v=id[b];\n\t\t\tadj[u].push_back((edge){v,d});\n\t\t\tadj[v].push_back((edge){u,d});\n\t\t}\n\t\trep(i,ng){\n\t\t\tchar a[16]; scanf(\"%s\",a);\n\t\t\tif(id.count(a)==0) id[a]=n++;\n\t\t\tgas[id[a]]=true;\n\t\t}\n\n\t\tint d[7000],c[7000];\n\t\trep(u,n){\n\t\t\td[u]=INF;\n\t\t\tc[u]=-1;\n\t\t}\n\t\td[s]=0;\n\t\tc[s]=cap;\n\n\t\tint ans=-1;\n\t\tpriority_queue< pair<pii,int> > pq;\n\t\tpq.push(make_pair(make_pair(0,cap),s));\n\t\twhile(!pq.empty()){\n\t\t\tint d_now=-pq.top().first.first;\n\t\t\tint c_now=pq.top().first.second;\n\t\t\tint u=pq.top().second; pq.pop();\n\n\t\t\tif(u==t){ ans=d_now; break; }\n\n\t\t\trep(i,adj[u].size()){\n\t\t\t\tedge e=adj[u][i];\n\t\t\t\tif(c_now<e.d) continue;\n\n\t\t\t\tint d_next=d_now+e.d;\n\t\t\t\tint c_next=(gas[e.v]?cap:c_now-e.d);\n\t\t\t\tif(d[e.v]>d_next || d[e.v]==d_next && c[e.v]<c_next){\n\t\t\t\t\td[e.v]=d_next;\n\t\t\t\t\tc[e.v]=c_next;\n\t\t\t\t\tpq.push(make_pair(make_pair(-d[e.v],c[e.v]),e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\n\nclass DP{\npublic:\n\tint cost, gas, state;\n\t\n\tDP(){}\n\tDP(int st, int g, int cc){\n\t\tcost = cc;state=st;gas=g;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tint dist;\n};\n\nint N, M, C;\n\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E;\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)){\n\t\t\t\tidx[from] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tif(!idx.count(to)){\n\t\t\t\tidx[to] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(idx[sta]);\n\t\t}\n\t\ts = idx[ss];g = idx[gg];\n\t\t\n\t\tset< pair<int, int> > visit;\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(s, C*10, 0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.state == g) break;\n\t\t\tFOR(it, E[S.state]){\n\t\t\t\tDP T=S;\n\t\t\t\tif(T.gas < it->dist) continue;\n\t\t\t\tT.state = it->to;\n\t\t\t\tif(stations.count(it->to)) T.gas = C*10;\n\t\t\t\telse T.gas -= it->dist;\n\t\t\t\tT.cost += it->dist;\n\t\t\t\tif(!visit.count(pair<int, int>(it->to, T.gas))){\n\t\t\t\t\tdp.push(T);\n\t\t\t\t\tvisit.insert(pair<int, int>(it->to, T.gas));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((S.state == g) ? S.cost : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    map<int,vector<Node> > nodes;\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n// -- loop macros -- //\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (int)(s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define FOREACH(i,container) for (auto &&i : container)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n\n// -- functors -- //\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV1(a,exp) [&](const auto & a) -> auto { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\n// -- typedefs -- //\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n\n// -- I/O Helper -- //\nstruct _Reader { _Reader(istream &cin) :cin(cin) {} istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { _Writer(ostream &cout) :cout(cout) {} ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\n// -- vevector -- //\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(size_t n = 0, size_t m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(size_t n = 0, size_t m = 0, size_t l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(size_t n = 0, size_t m = 0, size_t l = 0, size_t k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, iter_pair_t<T> v) { if (v.beg != v.end) { out << *v.beg++; while (v.beg != v.end) { out << \" \" << *v.beg++; } } return out; }\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\n\n// -- etc -- //\ntemplate <class T> T infinity_value();\n#define DEFINE_INFINITY_VALUE(T, val) template <> constexpr T infinity_value<T>() { return (val); }\nDEFINE_INFINITY_VALUE(int, 1 << 28);\nDEFINE_INFINITY_VALUE(uint, 1u << 28);\nDEFINE_INFINITY_VALUE(llong, 1ll << 60);\nDEFINE_INFINITY_VALUE(ullong, 1ull << 60);\nDEFINE_INFINITY_VALUE(double, HUGE_VAL);\nDEFINE_INFINITY_VALUE(float, HUGE_VAL);\n#define INF(T) infinity_value<T>()\n\ninline int sign_of(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ntemplate <class TInt> bool in_range(TInt val, TInt min, TInt max) { return val >= min && val < max; }\ntemplate <> bool in_range<double>(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ntemplate <> bool in_range<float>(float val, float min, float max) { return val - min > -EPS && val - max < EPS; }\ntemplate <class TInt> bool in_range2d(TInt x, TInt y, TInt w, TInt h) { return x >= 0 && x < w && y >= 0 && y < h; }\nvector<int> iotavn(int start, int count) { vector<int> r(count); iota(allof(r), start);\treturn r; }\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t//// for local debugging\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto classic_table = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> ctable(classic_table, classic_table + ctype<char>::table_size);\n\t//ctable[':'] |= ctype_base::space; // as delimitor\n\t//ctable['/'] |= ctype_base::space; // as delimitor\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(ctable.data())));\n\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n// idconv //\ntemplate<class T>\nstruct idconv\n{\n\tmap<T, int> dict;\n\tvector<T> rev;\n\tint get(const T &t)\n\t{\n\t\tif (dict.count(t)) { return dict.at(t); }\n\t\tint id = dict.size();\n\t\trev.push_back(t);\n\t\treturn dict[t] = id;\n\t}\n};\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tint MAXNODES = 10000;\n\t\tREAD(int, N, M, cap);\n\t\tif (!N) { break; }\n\t\tidconv<string> idc;\n\t\tint start, goal;\n\t\t{\n\t\t\tREAD(string, a, b);\n\t\t\tstart = idc.get(a);\n\t\t\tgoal = idc.get(b);\n\t\t}\n\n\t\tstruct St\n\t\t{\n\t\t\tint pos, cost, fuel;\n\t\t\tbool operator >  (const St &_) const { return cost != _.cost ? cost > _.cost : fuel < _.fuel; }\n\t\t};\n\n\t\tvevector<St> roads(MAXNODES);\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(string, c1, c2); READ(int, cost);\n\t\t\troads[idc.get(c1)].push_back({ idc.get(c2), cost });\n\t\t\troads[idc.get(c2)].push_back({ idc.get(c1), cost });\n\t\t}\n\n\t\tvector<bool> gassta(MAXNODES);\n\t\tREP(i, M)\n\t\t{\n\t\t\tREAD(string, c);\n\t\t\tgassta[idc.get(c)] = true;\n\t\t}\n\n\t\tpriority_queue<St, vector<St>, greater<St>> q;\n\t\tvector<int> gas(MAXNODES);\n\t\tvector<int> cost(MAXNODES, INF(int));\n\n\t\tq.push({ start, 0, cap * 10 });\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tSt p = q.top(); q.pop();\n\t\t\tif (gassta[p.pos]) { p.fuel = cap * 10; }\n\t\t\tif (p.cost >= cost[p.pos] && p.fuel <= gas[p.pos]) { continue; }\n\t\t\t//DEBUG(idc.rev[p.pos], \"cost\", p.cost, \"gas\", p.fuel);\n\n\t\t\tgas[p.pos] = p.fuel;\n\t\t\tcost[p.pos] = p.cost;\n\t\t\tif (p.pos == goal) { break; }\n\t\t\tFOREACH(r, roads[p.pos])\n\t\t\t{\n\t\t\t\tint to = r.pos;\n\t\t\t\tif (r.cost <= p.fuel)\n\t\t\t\t{\n\t\t\t\t\tq.push({ r.pos, p.cost + r.cost, p.fuel - r.cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tWRITE(cost[goal] < INF(int) ? cost[goal] : -1);\n\t\t//DEBUG(cost[goal] < INF(int) ? cost[goal] : -1);\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=d[v][cap*10];\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n      if(nc<0)continue;\n      if(d[v][p.s.s]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \tif(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!G[i].empty())\n\t\t\tG[i].clear();\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!GG[i].empty())\n\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Long Distance Taxi\n//Level: 3\n//Category: グラフ,Graph,ダイクストラ,Dijkstra\n//Note:\n\n/**\n * 普通にmemo[都市][残り燃料] = 走行距離 でダイクストラすると、\n * 都市数は最大3000、燃料は10倍する必要があるので最大2000となり、\n * 頂点数6M、辺数6Mのグラフになる。\n * これは普通にダイクストラすると時間が足りないので、最初にガソリンスタンドと\n * 始点、終点だけからなるグラフに縮約してからダイクストラする。\n *\n * オーダーはO(N log M + C log C)。\n */\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ntypedef long long LL;\nconst LL INF = 3000LL*200*2000;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        const int idx = dict.size();\n        return dict[str] = idx;\n    }\n};\n\nunordered_map<int,LL> search_path(int from, unordered_map<int,vector<pair<int,LL>>> &graph) {\n    priority_queue<pair<LL,int>> q;\n    unordered_map<int,LL> memo;\n    q.push(make_pair(0, from));\n    memo[from] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(memo[cur] < cost) continue;\n        for(const auto &edge : graph[cur]) {\n            const LL nc = cost + edge.second;\n            if(memo.count(edge.first) == 0 || memo[edge.first] > nc) {\n                memo[edge.first] = nc;\n                q.push(make_pair(-nc, edge.first));\n            }\n        }\n    }\n    return memo;\n}\n\nbool solve() {\n    int N, M, C;\n    cin >> N >> M >> C;\n    if(!N && !M && !C) return false;\n\n    Dict dict;\n    string Sn, Dn;\n    cin >> Sn >> Dn;\n    const int S = dict.get(Sn);\n    const int D = dict.get(Dn);\n\n    unordered_map<int,vector<pair<int,LL>>> graph;\n    TIMES(_, N) {\n        string s, t;\n        LL d;\n        cin >> s >> t >> d;\n        const int si = dict.get(s);\n        const int ti = dict.get(t);\n        graph[si].push_back(make_pair(ti, d));\n        graph[ti].push_back(make_pair(si, d));\n    }\n    vector<int> stations;\n    TIMES(_, M) {\n        string s;\n        cin >> s;\n        stations.push_back(dict.get(s));\n    }\n    stations.push_back(S);\n    stations.push_back(D);\n    unordered_map<int,vector<pair<int,LL>>> min_graph;\n    for(int from : stations) {\n        unordered_map<int,LL> res = search_path(from, graph);\n        for(int i : stations) {\n            if(res.count(i) && res[i] <= C*10) {\n                min_graph[from].push_back(make_pair(i, res[i]));\n                //cout << from << ' ' << i << ' ' << res[i] << endl;\n            }\n        }\n    }\n\n    unordered_map<int,LL> res = search_path(S, min_graph);\n    LL ans = -1;\n    if(res.count(D)) {\n        ans = res[D];\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(;;){\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if(n == 0) break;\n    cap *= 10;\n    map<string,int> map;\n    string currN, destN;\n    cin >> currN >> destN;\n    auto mapping = [&map](const string &city) {\n      if(map.find(city) == map.end()) map.insert(make_pair(city, map.size()));\n      return map[city];\n    };\n    int curr = mapping(currN);\n    int dest = mapping(destN);\n    vector<vector<pair<int,int>>> es(2000,vector<pair<int,int>>());\n    for(int i = 0; i < n; i++) {\n      string src, tgt;\n      int d;\n      cin >> src >> tgt >> d;\n      int s = mapping(src);\n      int t = mapping(tgt);\n      es[s].push_back(make_pair(t, d));\n      es[t].push_back(make_pair(s, d));\n    }\n    vector<bool> gs(2000, false);\n    for(int i = 0; i < m; i++) {\n      string city;\n      cin >> city;\n      gs[mapping(city)] = true;\n    }\n    const int BIG = 3000*2000*2*2;\n    const int nn = map.size();\n    vector<vector<int>> ds(nn, vector<int>(cap+1, BIG));\n    vector<vector<bool>> fixed(nn, vector<bool>(cap+1, false));\n    priority_queue<pair<int, pair<int, int>>> que;\n    // Dijkstra\n    que.push(make_pair(0, make_pair(curr, cap)));\n    while(que.size() > 0) {\n      auto dvc = que.top();\n      que.pop();\n      const int d = dvc.first;\n      const int v = dvc.second.first;\n      const int c = dvc.second.second;\n      if(fixed[v][c]) continue;\n      fixed[v][c] = true;\n      ds[v][c] = d;\n      for(auto it = es[v].begin(); it != es[v].end(); it++) {\n        int cc = c - it->second;\n        if(cc >= 0) {\n          int i = it->first;\n          int dd = d + it->second;\n          if(gs[i]) cc = cap; // gas station\n          if(ds[i][cc] > dd){\n            ds[i][cc] = dd;\n            que.push(make_pair(dd, make_pair(i, cc)));\n          }\n        }\n      }\n    }\n    int min = BIG;\n    for(int i = 0; i <= cap; i++) {\n      if(min > ds[dest][i]) {\n        min = ds[dest][i];\n      }\n    }\n    cout << (min == BIG ? -1 : min) << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int v,r,d;\n};\n\nbool operator<(const state &a,const state &b){\n  return a.d > b.d;\n}\n\nint n,m,C;\nstring src,dst;\nint S,T;\nmap<string,int> idx;\nvector<P> g[300];\nbool aru[300];\nint dist[300][2000];\nint V=0;\n\nint getidx(string s){\n  if(idx.find(s)!=idx.end())return idx[s];\n  idx[s]=V++;\n  return idx[s];\n}\n\nint main(){\n  while(1){\n    cin>>m>>n>>C;\n    if(m==0&&n==0)break;\n    \n    idx.clear();\n    rep(i,300)g[i].clear();\n    memset(aru,0,sizeof(aru));\n    V=0;\n\n    cin>>src>>dst;\n    S=getidx(src);\n    T=getidx(dst);\n    rep(i,m){\n      string a,b;\n      int d;\n      cin>>a>>b>>d;\n      g[getidx(a)].push_back(P(getidx(b),d));\n      g[getidx(b)].push_back(P(getidx(a),d));\n    }\n    rep(i,n){\n      string a;\n      cin>>a;\n      aru[getidx(a)]=true;\n    }\n\n    priority_queue<state> que;\n    que.push((state){S,C*10,0});\n    rep(i,300)rep(j,2000)dist[i][j]=INF;\n    while(que.size()){\n      state s=que.top(); \n      que.pop();\n      if(dist[s.v][s.r]!=INF)continue;\n      dist[s.v][s.r]=s.d;\n      for(P e : g[s.v]){\n        if(s.r<e.se)continue;\n        que.push((state){e.fi,s.r-e.se,s.d+e.se});\n      }\n      if(s.r<C*10&&aru[s.v]){\n        que.push((state){s.v,C*10,s.d});\n      }\n    }\n\n    int res=INF;\n    rep(j,2000)minch(res,dist[T][j]);\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxm = 3001;\nconst int maxn = 6001;\nconst int INF = 0x3ffffff;\nstruct Side{\n\tint to,next,w;\n}side[maxm*2];\nint node[maxn],top;\nvoid add_side(int u,int v,int w){\n\tside[top]=(Side){v,node[u],w};node[u]=top++;\n\tside[top]=(Side){u,node[v],w};node[v]=top++;\n}\nint cap;\nmap<string,int>city;\nint cnt,start,end;\nbool is[maxn];\nint get_id(string str){\n\tif(city.count(str)==0)city[str]=++cnt;\n\treturn city[str];\n}\nint dis[maxn][2001];\nbool inqueue[maxn][2001];\nqueue<pair<int,int> >q;\nint get_dis(){\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int j=0;j<=cap;j++){\n\t\t\tinqueue[i][j]=false;\n\t\t\tdis[i][j]=INF;\n\t\t}\n\t}\n\tdis[start][cap]=0;\n\tpair<int,int>tmp=make_pair(start,cap);\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttmp=q.front();q.pop();\n\t\tint u=tmp.first;\n\t\tint c=tmp.second;\n\t\tinqueue[u][c]=false;\n\t\tif(c!=cap&&is[u]){\n\t\t\tif(dis[u][c]<dis[u][cap]){\n\t\t\t\tdis[u][cap]=dis[u][c];\n\t\t\t\tif(!inqueue[u][cap]){\n\t\t\t\t\tinqueue[u][cap]=true;\n\t\t\t\t\tq.push(make_pair(u,cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=node[u];i!=-1;i=side[i].next){\n\t\t\tint v=side[i].to;\n\t\t\tint last=c-side[i].w;\n\t\t\tif(last<0)continue;\n\t\t\tif(dis[u][c]+side[i].w<dis[v][last]){\n\t\t\t\tdis[v][last]=dis[u][c]+side[i].w;\n\t\t\t\tif(!inqueue[v][last]){\n\t\t\t\t\tinqueue[v][last]=true;\n\t\t\t\t\tq.push(make_pair(v,last));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(int i=0;i<=cap;i++){\n\t\tans=min(ans,dis[end][i]);\n\t}\n\treturn ans==INF?-1:ans;\n}\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d%d%d\",&m,&n,&cap)){\n\t\tif(m==0&&n==0&&cap==0)break;\n\t\tcap=cap*10;\n\t\tcity.clear();\n\t\ttop=0;\n\t\tcnt=0;\n\t\tmemset(node,-1,sizeof(node));\n\t\tmemset(is,false,sizeof(is));\n\t\tstring u,v;\n\t\tcin>>u>>v;\n\t\tstart=get_id(u);\n\t\tend=get_id(v);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v;\n\t\t\tint w;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tint x=get_id(u);\n\t\t\tint y=get_id(v);\n\t\t\tadd_side(x,y,w);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>u;\n\t\t\tis[get_id(u)]=true;\n\t\t}\n\t\tprintf(\"%d\\n\",get_dis());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,0x3f,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n\n    cities.clear();\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG] <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 8000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n    vis[v][p.s.s]=true;\n\n    if(v==vnum[dest]){\n      cout << p.f << endl;\n      return ;\n    }\n\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(p.s.s-e.cost>=0){\n        que.push(P3(p.f+e.cost, P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n  cout << -1 << endl;\n}\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n    vnum.clear();\n\n    cin >> src >> dest;\n\n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n\n    for(int i=0;i<V;i++)G[i].clear();\n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d = 0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap < 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  for(int i=0;i<=v.cap;i++){\n\t    d[i][p.second] = d[u.cap][p.first] + m[p];\n\t  }\n\t  v.str = p.second;\n\t  v.d = d[v.cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvoid dfs(vector<vector<int>>& ng, vector<vector<pair<int, int>>>& g, vector<int>& dis, vector<bool>& reset, int pre, int pos, int ene, int& maxi, int t){\n\tdis[pos] = ene;\n\tif(pos == t){\n\t\tif(ene < ng[pre][pos]){\n\t\t\tng[pre][pos] = ng[pos][pre] = ene;\n\t\t}\n\t\treturn;\n\t}\n\tif(reset[pos]){\n\t\tif(ene < ng[pre][pos]){\n\t\t\tng[pre][pos] = ng[pos][pre] = ene;\n\t\t}\n\t\tpre = pos;\n\t\tene = 0;\n\t}\n\n\tfor(auto e  : g[pos]){\n\t\tint cost, to;\n\t\ttie(to, cost) = e;\n\t\tif(ene + cost > maxi or dis[to] <= ene + cost) continue;\n\t\tdfs(ng, g, dis, reset, pre, to, ene + cost, maxi, t);\n\t}\n}\n\nint dijkstra(int n, int s, int t, vector<vector<int>>& g){\n\tvector<int> dis(n,1e8);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tint cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\n\nint main(){\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tmap<string,int> id;\n\t\tint idx = 0;\n\t\tstring src, dist;\n\t\tcin >> src >> dist;\n\t\tid[src] = idx++;\n\t\tid[dist] = idx++;\n\n\t\tvector<string> a(n), b(n);\n\t\tvector<int> c(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tif(not id.count(a[i])) id[a[i]] = idx++;\n\t\t\tif(not id.count(b[i])) id[b[i]] = idx++;\n\t\t}\n\n\t\tvector<string> sta(m);\n\t\trep(i,m){\n\t\t\tcin >> sta[i];\n\t\t\tif(not id.count(sta[i])) id[sta[i]] = idx++;\n\t\t}\n\n\t\tvector<vector<pair<int,int>>> g(id.size());\n\t\trep(i,n){\n\t\t\tg[id[a[i]]].emplace_back(id[b[i]], c[i]);\n\t\t\tg[id[b[i]]].emplace_back(id[a[i]], c[i]);\n\t\t}\n\n\t\tvector<vector<int>> ng(id.size(), vector<int>(id.size(), 1e8));\n\t\tvector<bool> reset(id.size(), 0);\n\t\tfor(auto i : sta) reset[id[i]] = true;\n\t\tvector<int> dis(id.size(), 1e8);\n\t\tdfs(ng, g, dis, reset, 0, id[src], 0, cap, id[dist]);\n\t\t//rep(i,n){\n\t\t//\trep(j,n){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tint ans = dijkstra(id.size(), id[src], id[dist], ng);\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1318>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nll N,M,cap;\nll solve(){\n    ll res = -1;\n    map<string,int> city2idx;\n    set<string> citys;\n    \n    string src,dest; cin >> src >> dest;\n    citys.insert(src); citys.insert(dest);\n    vector<string> c1(N),c2(N); vector<ll> d(N);\n    for(int i = 0; i < N;i++){\n        cin >> c1[i] >> c2[i] >> d[i];\n        citys.insert(c1[i]); citys.insert(c2[i]);\n    }\n    vector<string> s(M);\n    for(int i = 0; i < M;i++){\n        cin >> s[i];\n        citys.insert(s[i]);\n    }\n    \n    int idx = 0;\n    for(auto& city:citys){\n        city2idx[city] = idx++;\n    }\n    int S = city2idx[src],T = city2idx[dest];\n    vector<vector<pll>> G(N);\n    for(int i = 0; i < N;i++){\n        ll u = city2idx[c1[i]], v = city2idx[c2[i]];\n        G[u].push_back(make_pair(v,d[i]));\n        G[v].push_back(make_pair(u,d[i]));\n    }\n    vector<int> stations(citys.size());\n    for(int i = 0; i < M;i++){\n        ll n = city2idx[s[i]];\n        stations[n] = 1;\n    }\n    \n    vector<vector<ll>> dist(citys.size(),vector<ll>(cap*10 + 1,LINF));\n    dist[S] = vector<ll>(cap*10+1,0);\n    queue<pll> q; q.push({S,0});\n    while(q.size()){\n        ll n,C; tie(n,C) = q.front(); q.pop();\n        if(stations[n]){ dist[n][0] = min(dist[n][0],dist[n][C]); C = 0;}\n        for(auto e:G[n]){\n            ll next = e.first, cost = e.second;\n           if(C + cost > cap*10) continue;\n            if(dist[next][C+cost] > dist[n][C] + cost){\n                dist[next][C+cost] = dist[n][C] + cost;\n                q.push(make_pair(next,C+cost));\n            }\n        }\n    }\n    res = *min_element(dist[T].begin(),dist[T].end());\n    if(res == LINF) return -1;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N >> M >> cap,N){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,short> cities;\nint dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  short remaining_LPG;\n  State(int _city_id,int _dist,short _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    map<int,vector<Node> > nodes;\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\n#include <vector>\n#include <queue>\n#define inf 999999999\nusing namespace std;\nstruct xxx\n{\n    int y,c;\n};\nstruct yyy\n{\n    int num,oil;\n};\nint n,m,cap,tot;\nint dis[6001][2001];\nbool f[6001],vi[6001][2001];\nstring st,en;\nmap <string,int> mp1;\nvector <xxx> edge[6001];\nqueue <yyy> q;\nvoid spfa()\n{\n    while (!q.empty()) q.pop();\n    for (int i=1;i<=tot;i++)\n        for (int j=0;j<=cap*10;j++)\n        {\n            dis[i][j]=inf;\n            vi[i][j]=0;\n        }\n    dis[1][cap*10]=0;\n    yyy start;\n    start.num=1;\n    start.oil=cap*10;\n    q.push(start);\n    vi[1][cap*10]=1;\n    while (!q.empty())\n    {\n        yyy now=q.front();\n        q.pop();\n        for (int i=0;i<edge[now.num].size();i++)\n        {\n            int y=edge[now.num][i].y;\n            if (now.oil>=edge[now.num][i].c)\n            {\n                if (dis[y][now.oil-edge[now.num][i].c]>dis[now.num][now.oil]+edge[now.num][i].c)\n                {\n                    if (f[y])\n                    {\n                        dis[y][cap*10]=dis[now.num][now.oil]+edge[now.num][i].c;\n                        if (!vi[y][cap*10])\n                        {\n                            vi[y][cap*10]=1;\n                            yyy news;\n                            news.num=y;\n                            news.oil=cap*10;\n                            q.push(news);\n                        }\n                    }\n                    else\n                    {\n                        dis[y][now.oil-edge[now.num][i].c]=dis[now.num][now.oil]+edge[now.num][i].c;\n                        if (!vi[y][now.oil-edge[now.num][i].c])\n                        {\n                            vi[y][now.oil-edge[now.num][i].c]=1;\n                            yyy news;\n                            news.num=y;\n                            news.oil=now.oil-edge[now.num][i].c;\n                            q.push(news);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d%d\",&n,&m,&cap))\n    {\n        if (n==0&&m==0&&cap==0) break;\n        tot=0;\n        cin>>st>>en;\n        mp1[st]=++tot;\n        mp1[en]=++tot;\n        for (int i=1;i<=n;i++)\n        {\n            string s1,s2;\n            int len;\n            cin>>s1>>s2>>len;\n            if (!mp1[s1]) mp1[s1]=++tot;\n            if (!mp1[s2]) mp1[s2]=++tot;\n            int n1,n2;\n            n1=mp1[s1];\n            n2=mp1[s2];\n            xxx pp;\n            pp.c=len;\n            pp.y=n2;\n            edge[n1].push_back(pp);\n            pp.y=n1;\n            edge[n2].push_back(pp);\n        }\n        memset(f,0,sizeof(f));\n        for (int i=1;i<=m;i++)\n        {\n            string ss;\n            cin>>ss;\n            if (!mp1[ss])mp1[ss]=++tot;\n            f[mp1[ss]]=1;\n        }\n        spfa();\n        int ans=inf;\n        for (int i=0;i<=cap*10;i++)\n            ans=min(ans,dis[2][i]);\n        if (ans<inf) printf(\"%d\\n\",ans);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_sum_dist,int arg_fuel){\n\t\ttown = arg_town;\n\t\tsum_dist = arg_sum_dist;\n\t\tfuel = arg_fuel;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tint town,sum_dist,fuel;\n};\n\nchar town_table[6000][16];\nbool have_station[6000];\n\nint town_index,N,M,start = 0,goal = 1,capacity;\nint** min_dist;\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\n\ttown_index = 0;\n\n\tchar left[16],right[16];\n\tscanf(\"%s %s\",left,right);\n\n\tstrcpy(town_table[town_index++],left);\n\tstrcpy(town_table[town_index++],right);\n\n\tint dist;\n\n\tbool FLG;\n\tint left_index,right_index;\n\n\tvector<Info> V[6000];\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s %s %d\",left,right,&dist);\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\tFLG = true;\n\t\t\t\tleft_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],left);\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index;i++){\n\t\t\tif(strCmp(town_table[i],right)){\n\t\t\t\tFLG = true;\n\t\t\t\tright_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],right);\n\t\t}\n\n\t\tV[left_index].push_back(Info(right_index,dist));\n\t\tV[right_index].push_back(Info(left_index,dist));\n\t}\n\n\tfor(int i = 0; i < town_index;i++)have_station[i] = false;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",left);\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\thave_station[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < town_index; i++){\n\t\tfor(int k = 0; k <= 10*capacity; k++)min_dist[i][k] = BIG_NUM;\n\t}\n\n\tpriority_queue<Data> Q;\n\n\tmin_dist[0][10*capacity] = 0;\n\tQ.push(Data(0,0,10*capacity));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().town == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().town][Q.top().fuel]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().town].size(); i++){\n\t\t\t\tif(V[Q.top().town][i].dist <= Q.top().fuel){\n\t\t\t\t\tif(have_station[V[Q.top().town][i].to]){\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][10*capacity] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][10*capacity] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,10*capacity));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,Q.top().fuel-V[Q.top().town][i].dist));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\n\tfor(int i = 0; i <= 10*capacity; i++)ans = min(ans,min_dist[1][i]);\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_dist = new int*[6000];\n\tfor(int i = 0; i < 6000; i++)min_dist[i] = new int[2001];\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&capacity);\n\t\tif(N == 0 && M == 0 && capacity == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nconst int inf = numeric_limits<int>::max() / 3;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int to_,int cost_) : to(to_) , cost(cost_) {}\n};\n\nint N,M,cap;\nint src,dest;\nvector<edge> g[6000];\n\nvoid solve(){\n    for(int i=0;i<6000;i++) g[i] = vector<edge>();\n    string srcc,destt;\n    cap *= 10;\n    cin >> srcc >> destt;\n    int namecount=0;\n    map<string,int> names;\n    for(int i=0;i<N;i++){\n        string c1,c2;\n        int dist;\n        cin >> c1 >> c2 >> dist;\n        if(!names.count(c1)){\n            names[c1] = namecount++;\n        }\n        if(!names.count(c2)){\n            names[c2] = namecount++;\n        }\n\n        g[names[c1]].push_back(edge(names[c2],dist));\n        g[names[c2]].push_back(edge(names[c1],dist));\n    }\n\n    if(!names.count(srcc)){\n        names[srcc] = namecount++;\n    }\n    if(!names.count(destt)){\n        names[destt] = namecount++;\n    }\n    int src = names[srcc];\n    int dest = names[destt];\n\n    set<int> s;\n    for(int i=0;i<M;i++){\n        string ss;cin >> ss;\n        s.insert(names[ss]);\n    }\n\n    using Vertex = pair<int,int>; // ?????????????,???????????¨\n    using State = pair<int,Vertex>; // ????????????¢, ????????????? \n\n    // dist[?????????????][?????£?????????????¨??????????????¢???????\\] = ?????????????????????????¢\n    vector<vector<int>> dist(6000,vector<int>(3000,inf));\n    \n    priority_queue<State,vector<State>,greater<State>> que;\n    que.push(State(0,Vertex(src,cap)));\n    dist[src][cap] = 0;\n\n    //for(auto p : names) cerr << p.first << \" \" << p.second << endl;\n\n    while(!que.empty()){\n        int d = que.top().first;\n        Vertex v = que.top().second;\n        que.pop();\n        \n        int node = v.first;\n        int c = v.second;\n\n        //cerr << node << \" \" << c << \" \" << d << endl;\n\n        if(s.count(node)){\n            c = cap;\n        }\n\n        for(edge& e : g[node]){\n            int ncap = c - e.cost;\n            //cerr << \"e = \" << e.to << \" \" << e.cost << endl;\n            if(ncap < 0) continue;\n            if(dist[e.to][ncap] > d + e.cost){\n                //cerr << \"push \" << e.to << \" \" << ncap << endl;\n                dist[e.to][ncap] = d + e.cost; \n                que.push(State(dist[e.to][ncap],Vertex(e.to,ncap)));\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int i=0;i<3000;i++) ans = min(ans,dist[dest][i]);\n\n    if(ans==inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N >> M >> cap;\n        if(N==0 and M==0 and cap==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\ntypedef tuple< int, int, int > State;\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, cap;\n  while(cin >> N >> M >> cap, N) {\n    string src, dest;\n    cin >> src >> dest;\n  \n    map< string, int > comb;\n    vector< edge > graph[50000];\n    bool flag[50000] = {};\n    \n    while(N--) {\n      string a, b;\n      int d;\n      cin >> a >> b >> d;\n      if(comb.find(a) == comb.end()) comb[a] = comb.size() - 1;\n      if(comb.find(b) == comb.end()) comb[b] = comb.size() - 1;\n      graph[comb[a]].push_back((edge){comb[b], d});\n      graph[comb[b]].push_back((edge){comb[a], d});\n    }\n\n    while(M--) {\n      string s;\n      cin >> s;\n      flag[comb[s]] = true;\n    }\n    \n    cap *= 10;\n    int s = comb[src], g = comb[dest];\n\n    priority_queue< State, vector< State >, greater< State > > que;   \n    vector< vector< int > > min_cost(comb.size(), vector< int >(cap + 1, INF));\n    que.emplace(0, s, cap);\n    min_cost[0][cap] = 0;\n    int ret = -1;\n    while(!que.empty()) {\n      int cost, now, gas;\n      tie(cost, now, gas) = que.top(); que.pop();\n      if(cost > min_cost[now][gas]) continue;\n      if(now == g) { ret = cost; break; }\n      if(flag[now]) gas = cap;\n      for(auto e : graph[now]) {\n        int nextgas = gas - e.cost;\n        if(nextgas < 0) continue;\n        if(cost + e.cost >= min_cost[e.to][nextgas]) continue;\n        min_cost[e.to][nextgas] = cost + e.cost;\n        que.emplace(cost + e.cost, e.to, nextgas);\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <string.h>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <string>\n#include <iostream>\n#include <sstream>\n#define MAX 1e7\nusing namespace std;\nmap<string,int>num;\nvector<int>dis[3001];\nint mp[3001][3001]={0},c[3001],ans,d[3001]={0};\nint n,m,cp,i,j,k,a,b,p;\nstring s;\nstring s1,s2;\nint dfs(int a,int ccc,int ddd)\n{\n    if(a==2)\n    {\n        if(ddd<ans) ans=ddd;\n        return 0;\n    }\n    for(int i=0;i<dis[a].size();i++)\n    {\n        int h=dis[a][i];\n        if(ccc<mp[a][h]||d[h]==1) continue;\n        d[h]=1;\n        if(c[h]==1) dfs(h,cp,ddd+mp[a][h]);\n        else dfs(h,ccc-mp[a][h],ddd+mp[a][h]);\n        d[h]=0;\n    }\n    return 0;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&cp)&&n+m+cp>0)\n    {\n        cp*=10;\n        num.clear();\n        ans=MAX;\n        cin>>s1>>s2;\n        num[s1]=1;\n        num[s2]=2;\n        for(i=0,k=3;i<n;i++)\n        {\n            cin>>s1>>s2;\n            scanf(\"%d\",&p);\n            if(!num[s1]) num[s1]=k++;\n            if(!num[s2]) num[s2]=k++;\n            a=num[s1];\n            b=num[s2];\n            mp[a][b]=mp[b][a]=p;\n            dis[a].push_back(b);\n            dis[b].push_back(a);\n        }\n        memset(c,0,sizeof(c));\n        for(i=0;i<m;i++)\n        {\n            cin>>s1;\n            for(j=1;j<k;j++)\n                if(num[s1]) c[num[s1]]=1;\n        }\n        dfs(1,cp,0);\n        for(i=1;i<=k;i++) dis[i].clear();\n        if(ans==10000000) ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nstruct Edge {\n  int dst, dist;\n  Edge(int dst, int dist): dst(dst), dist(dist) {}\n};\n\nstruct State {\n  int city, rest, cost;\n  State(int city, int rest, int cost): city(city), rest(rest), cost(cost) {}\n  bool operator<(const State& rhs) const { return cost > rhs.cost; }\n};\n\ninline int add_name(map<string, int>& name2id, const string& name) {\n  if (name2id.count(name)) {\n    return name2id[name];\n  } else {\n    int id = name2id.size();\n    return name2id[name] = id;\n  }\n}\n\nconst int INF = 0x0f0f0f0f;\n\nvector<Edge> edges[6010];\nbool has_lpg[6010];\nbool visit[6010][2010];\nint cost[6010][2010];\n\nint main() {\n  int N, M, cap;\n  while (scanf(\"%d%d%d\", &N, &M, &cap), N|M|cap) {\n    map<string, int> name2id;\n    string src_name, dst_name;\n\n    memset(has_lpg, false, sizeof(has_lpg));\n    memset(visit, false, sizeof(visit));\n    memset(cost, INF, sizeof(cost));\n\n    cin >> src_name >> dst_name;\n    int src = add_name(name2id, src_name);\n    int dst = add_name(name2id, dst_name);\n    REP(i, N) {\n      int dist;\n      cin >> src_name >> dst_name >> dist;\n      int s = add_name(name2id, src_name);\n      int t = add_name(name2id, dst_name);\n      edges[s].push_back(Edge(t, dist));\n      edges[t].push_back(Edge(s, dist));\n    }\n    REP(i, M) {\n      cin >> src_name;\n      has_lpg[name2id[src_name]] = true;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(src, 10 * cap, 0));\n    cost[src][10 * cap] = 0;\n    while (!Q.empty()) {\n      int city = Q.top().city;\n      int rest = Q.top().rest;\n      Q.pop();\n\n      if (visit[city][rest]) { continue; }\n      visit[city][rest] = true;\n\n      FOREACH(it, edges[city]) {\n        int new_city = it->dst;\n        if (rest < it->dist) { continue; }\n        int new_rest = has_lpg[new_city] ? 10 * cap : rest - it->dist;\n        int new_cost = cost[city][rest] + it->dist;\n        if (new_cost >= cost[new_city][new_rest]) { continue; }\n        cost[new_city][new_rest] = new_cost;\n        Q.push(State(new_city, new_rest, new_cost));\n      }\n    }\n\n    int ans = *min_element(cost[dst], cost[dst] + 10 * cap + 1);\n    cout << (ans < INF ? ans : -1) << endl;\n\n    REP(i, name2id.size()) { edges[i].clear(); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( nstat.size(), vector<int>( n, INF ) );\n\tfor( int from = 0; from < nstat.size(); ++from ){\n\t\tint n_from = nstat[from];\n\t\tdist[from][n_from] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, nstat[from] ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_f = p.second;\n\t\t\tif( dist[from][n_f] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_from].size(); ++i ){\n\t\t\t\tint n_to = road[n_from][i].first;\n\t\t\t\tint ds = p.first + road[n_from][i].second;\n\t\t\t\t\n\t\t\t\tif( ds < cap && dist[from][n_to] > ds ){\n\t\t\t\t\tdist[from][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[from][n_to] <= cap && dp[to] > dp[from] + dist[from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[3005][3005];\nint gas[3005];\nint head[3005];\nint dp[2001][2501];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[6005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(u<=2500&&dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return dp[gasnum][u]=0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n        }\n    }\n    if(u<=2500)\n        dp[gasnum][u]=ret;\n    return ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n                u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n            printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  map<int,int> D[2001];\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[c][pos]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&(!D[nc].count(nx)||D[nc][nx]>nd))\n\tQ.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int to, cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, cap;\n    while(cin >> N >> M >> cap, N) {\n        unordered_map<string, int> idx;\n        string src, dest;\n        cin >> src >> dest;\n        graph g(6001);\n        idx[src] = 0; idx[dest] = 1;\n        cap *= 10;\n        for(int i=0; i<N; ++i) {\n            string c1, c2;\n            int d;\n            cin >> c1 >> c2 >> d;\n            if(idx.count(c1) == 0) {\n                idx[c1] = idx.size();\n            }\n            if(idx.count(c2) == 0) {\n                idx[c2] = idx.size();\n            }\n            g[idx[c1]].push_back(edge{idx[c2], d});\n            g[idx[c2]].push_back(edge{idx[c1], d});\n        }\n        vector<bool> gas(6001);\n        for(int i=0; i<M; ++i) {\n            string s;\n            cin >> s;\n            gas[idx[s]] = true;\n        }\n        vector<vector<int>> res(6001, vector<int>(cap+1, INF));\n        res[0][cap] = 0;\n        using state = tuple<int, int, int>;\n        priority_queue<state, vector<state>, greater<state>> que;\n        que.push(make_tuple(0, cap, idx[src]));\n        while(!que.empty()) {\n            int cd, rest, c;\n            tie(cd, rest, c) = que.top();\n            que.pop();\n            //cout << \"c: \" << c << \" rest: \" << rest << \"  cd: \" << cd << endl;\n            if(res[c][rest] < cd) {\n                continue;\n            }\n            for(auto& e : g[c]) {\n                if(e.cost > rest) {\n                    continue;\n                }\n                int nr = (gas[e.to] ? cap : rest - e.cost);\n                if(res[e.to][nr] > res[c][rest] + e.cost) {\n                    res[e.to][nr] = res[c][rest] + e.cost;\n                    que.push(make_tuple(res[e.to][nr], nr, e.to));\n                }\n            }\n        }\n        int r = *min_element(res[idx[dest]].begin(), res[idx[dest]].end());\n        cout << (r == INF ? -1 : r ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n\ntypedef long long ll;\n\nusing namespace std;\nconst int max_n = 3030;\nvector < pair<int, int> > G[max_n];\nint g[max_n], n, m, cap;\nstruct node\n{\n\tint k;\n\tint res;\n\tint dis;\n\tfriend int operator < (node a, node b)\n\t{\n\t\treturn a.dis > b.dis;\n\t}\n};\npriority_queue <node> que;\nint bfs()\n{\n\tint vis[max_n] = {};\n\tnode now , temp;\n\twhile(!que.empty())que.pop();\n\tnow.k = 0;\n\tnow.res = cap;\n\tnow.dis = 0;\n\tque.push(now);\n\tvis[0] = 1;\n\twhile(!que.empty())\n\t{\n\t\tnow = que.top();\n\t\tque.pop();\n\t\tif(now.k == 1)\n\t\t\treturn now.dis;\n\t\tfor(int i = 0; i < G[now.k].size(); i++)\n\t\t{\n\t\t\ttemp.res = now.res - G[now.k][i].second;\n\t\t\tif(temp.res >= vis[G[now.k][i].first])\n\t\t\t{\n\t\t\t\ttemp.k = G[now.k][i].first;\n\t\t\t\ttemp.dis = now.dis + G[now.k][i].second;\n\t\t\t\tif(g[G[now.k][i].first])\n\t\t\t\t{\n\t\t\t\t\ttemp.res = cap;\n\t\t\t\t}\n\t\t\t\tvis[G[now.k][i].first] = temp.res;\n\t\t\t\tque.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nmap <string, int> ma;\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &n, &m, &cap);\n\t\tif(n == 0 && m == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i <= n; i++)\n\t\t\tG[i].clear();\n\t\tmemset(g, 0, sizeof(g));\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k, num = 0;\n\t\tcin >> a >> b;\n\t\tma.clear();\n\t\tma[a] = num++;\n\t\tma[b] = num++;\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = num++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = num++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tG[ma[a]].push_back(make_pair(ma[b], k));\n\t\t\t\tG[ma[b]].push_back(make_pair(ma[a], k));\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tg[ma[a]] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvector<int> dijkstra(int n, int s, vector<vector<int>>& g, int cap){\n\tvector<int> dis(n,1e8);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tint cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(cost > cap) continue;\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis;\n}\n\nconst int INF = 1e8;\n\npair<int,int> e[3005];\nint d[3005];\nint t[305];\n\nint input(int n, int m){\n\tmap<string,int> id;\n\n\tstring src, dist;\n\tcin >> src >> dist;\n\tid[src] = id.size();\n\tid[dist] = id.size();\n\n\trep(i,n){\n\t\tstring c1, c2;\n\t\tcin >> c1 >> c2 >> d[i];\n\t\tif(not id.count(c1)) id[c1] = id.size();\n\t\tif(not id.count(c2)) id[c2] = id.size();\n\t\te[i] = make_pair(id[c1], id[c2]);\n\t}\n\n\trep(i,m){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(not id.count(s)) id[s] = id.size();\n\t\tt[i] = id[s];\n\t}\n\n\tt[m] = id[src];\n\tt[m + 1] = id[dist];\n\treturn id.size();\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tint v = input(n, m) + 5;\n\n\t\tvector<vector<int>> g(v, vector<int>(v, INF)), ng(v, vector<int>(v, INF));\n\t\trep(i,n){\n\t\t\tint x = e[i].first, y = e[i].second;\n\t\t\tg[x][y] = g[y][x] = d[i];\n\t\t}\n\n\t\trep(i,m + 2){\n\t\t\tint x = t[i];\n\t\t\tvector<int> dis = dijkstra(v, x, g, cap);\n\t\t\trep(j,m + 2){\n\t\t\t\tint y = t[j];\n\t\t\t\tif(dis[y] > cap) continue;\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,v){\n\t\t//\trep(j,v){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint ans = dijkstra(v, t[m], ng, INF).at(t[m + 1]);\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<long long int,pair<long long int,long long int>> node;\n\nint main(){\n\tlong long int N,M,cap;\n\twhile(cin>>N>>M>>cap, N||M||cap){\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tmap<string,long long int>X;\n\t\tX[src]=0;\n\t\tX[dest]=1;\n\t\tlong long int idx=2;\n\t\tvector<pair<pair<string, string>,long long int>>input(N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin>>input[i].first.first>>input[i].first.second>>input[i].second;\n\t\t\tif(X.count(input[i].first.first)==0){\n\t\t\t\tX[input[i].first.first]=idx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif(X.count(input[i].first.second)==0){\n\t\t\t\tX[input[i].first.second]=idx;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tvector<vector<pair<long long int,long long int>>>D(idx);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tD[X[input[i].first.first]].push_back(make_pair(X[input[i].first.second], input[i].second));\n\t\t\tD[X[input[i].first.second]].push_back(make_pair(X[input[i].first.first], input[i].second));\n\t\t}\n\t\tset<long long int>Station;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tStation.insert(X[s]);\n\t\t}\n\n\n\t\tpriority_queue<node, vector<node>,greater<node>>que;\n\t\tque.push(make_pair(0, make_pair(0, cap * 10)));\n\t\tvector<vector<node>>memo(idx);\n\t\t//memo[0].push_back(make_pair(0, make_pair(0, cap * 10)));\n\t\tbool ok=false;\n\t\twhile(que.size()){\n\t\t\tauto now= que.top();que.pop();\n\t\t\t//cout << now.first<<\" \"<<now.second.first<<\" \"<<now.second.second<<endl;\n\t\t\tif(now.second.first==1){\n\t\t\t\tcout<<now.first<<endl;\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tfor(auto check:memo[now.second.first]){\n\t\t\t\tif(now.first>=check.first && now.second.second <= check.second.second){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f)continue;\n\t\t\tmemo[now.second.first].push_back(now);\n\t\t\tif(Station.count(now.second.first)){\n\t\t\t\tnow.second.second=cap*10;\n\t\t\t}\n\t\t\tfor(auto nextPoint:D[now.second.first]){\n\t\t\t\tauto next=now;\n\t\t\t\tnext.second.first=nextPoint.first;\n\t\t\t\tnext.first+=nextPoint.second;\n\t\t\t\tnext.second.second-=nextPoint.second;\n\t\t\t\tif(next.second.second<0)continue;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tif(!ok)cout<<-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1000000000\n\nstruct Edge {\n\tint src,  dst;\n\tint weight;\n\tEdge(int src, int dst, int weight) : src(src), dst(dst), weight(weight) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\nint N, M, cap;\nint srcId, destId;\n\nmap<string, int> cityToId;\nset<int> gasstand;\nstring idToCity[8000];\nGraph graph;\nGraph graph2;\n\nint toId(string city){\n\tauto ret = cityToId.find(city);\n\tif(ret == cityToId.end()){\n\t\tint nid = cityToId.size();\n\t\tidToCity[nid] = city;\n\t\tcityToId[city] = nid;\n\t\treturn nid;\n\t}else{\n\t\treturn ret->second;\n\t}\n}\n\nstring toCity(int id){\n\treturn idToCity[id];\n}\n\nvoid dijkstra(Graph& g, int src, vector<int>& ret){\n\tret.assign(g.size(), INF);\n\ttypedef pair<int, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > queue;\n\tqueue.push(P(0, src));\n\twhile(!queue.empty()){\n\t\tP pp = queue.top(); queue.pop();\n\t\tif(ret[pp.second] > pp.first){\n\t\t\tret[pp.second] = pp.first;\n\t\t\tfor(Edge e : g[pp.second]){\n\t\t\t\tif(e.weight + pp.first < ret[e.dst]){\n\t\t\t\t\tqueue.push(P(e.weight + pp.first, e.dst));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> N >> M >> cap, N){\n\t\tstring s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tsrcId = toId(s1);\n\t\tdestId = toId(s2);\n\t\tgraph.clear();\n\t\tgasstand.clear();\n\t\tgasstand.insert(srcId);\n\t\tgasstand.insert(destId);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint d;\n\t\t\tcin >> s1 >> s2 >> d;\n\t\t\tint i1 = toId(s1);\n\t\t\tint i2 = toId(s2);\n\t\t\tif(i1 + 1 > graph.size()) graph.resize(i1 + 1);\n\t\t\tif(i2 + 1 > graph.size()) graph.resize(i2 + 1);\n\t\t\tgraph[i1].push_back(Edge(i1, i2, d));\n\t\t\tgraph[i2].push_back(Edge(i2, i1, d));\n\t\t}\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> s1;\n\t\t\tgasstand.insert(toId(s1));\n\t\t}\n\t\tgraph2.clear();\n\t\tgraph2.resize(graph.size());\n\t\tvector<int> ret(graph.size());\n\t\tfor(int ii : gasstand){\n\t\t\tdijkstra(graph, ii, ret);\n\t\t\tfor(int jj : gasstand){\n\t\t\t\tif(ii == jj) continue;\n\t\t\t\tif(ret[jj] <= cap * 10){\n\t\t\t\t\tgraph2[ii].push_back(Edge(ii, jj, ret[jj]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(graph2, srcId, ret);\n\t\tif(ret[destId] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ret[destId] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1318 : Long Distance Taxi **/\nconst int MAX_V = 6001;\nconst int MAX_CAP = 2001;\n\nint N, M, cap;\n\nint idx;\nmap<string, int> idx_list;\nbool LPG[MAX_V];\nint d[MAX_V][MAX_CAP];\nint target;\n\nstruct Node {\n\tint v, c, d;\n\tNode (int _d, int _v, int _c) : v(_v), c(_c), d(_d){}\n\tbool operator<(const Node &n)const{return d>n.d;}\n};\n\nstruct Edge {\n\tint to; int cost;\n\tEdge(int t, int c) :  to(t), cost(c){}\n};\nvector<Edge> G[MAX_V];\n\nint toIdx(string name)\n{\n\tif (idx_list.count(name)) {\n\t\treturn idx_list[name];\n\t} else {\n\t\tidx_list[name] = idx++;\n\t\treturn idx_list[name];\n\t}\n}\n\nvoid dijkstra(int s)\n{\n\tfill(d[0], d[0]+MAX_V*MAX_CAP, INF);\n\td[s][cap] = 0;\n\t\n\tpriority_queue<Node> Q;\n\tQ.push(Node(0, s, cap));\n\t\n\twhile (Q.size()) {\n\t\tNode p = Q.top(); Q.pop();\n\t\tint v = p.v, c = p.c;\n\t\t//if (v == target) break;\n\t\t\n\t\tif (LPG[v])\n\t\t\tc = cap;\n\t\t//cerr << v << \" \" << c << \" \" << p.d << endl;\n\t\t\n\t\tbool ok=true;\n\t\tfor (int i=c; i<=cap; i++) {\n\t\t\tif (d[v][i] < p.d) ok=false;\n\t\t}\n\t\tif (!ok) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\tint nc = c - e.cost;\n\t\t\tif (nc<0) continue;\n\t\t\t\n\t\t\tif (d[e.to][nc] > p.d + e.cost) {\n\t\t\t\td[e.to][nc] = p.d + e.cost;\n\t\t\t\tQ.push(Node(d[e.to][nc], e.to, nc));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> N >> M >> cap, N||M||cap) {\n\t\tfor (int i=0; i<MAX_V; i++) G[i].clear();\n\t\tcap *= 10;\n\t\tfill(LPG, LPG+MAX_V, false);\n\t\t\n\t\tstring from, to;\n\t\tcin >> from >> to;\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring a, b; int c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tint ia = toIdx(a), ib = toIdx(b);\n\t\t\tG[ia].push_back(Edge(ib, c));\n\t\t\tG[ib].push_back(Edge(ia, c));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring a; cin >> a;\n\t\t\tLPG[toIdx(a)] = true;\n\t\t}\n\t\t\n\t\ttarget = toIdx(to);\n\t\tdijkstra(toIdx(from));\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<MAX_CAP; i++) {\n\t\t\tans = min(ans, d[toIdx(to)][i]);\n\t\t}\n\t\tif (ans==INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    scanf(\"%s%s\",s,t);\n    vector<string> node;\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    int sz = node.size();\n    g.resize(sz,vector<edge>());\n    cost.resize(sz,vector<int>(cap*10+1));\n    sta.resize(sz);\n    for( int i = 0; i < sz; i++ ) {\n      sta[i] = false;\n      for( int j = 0; j <= cap*10; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d=0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap <= 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    Q.push(v);\n\t  }\n\t}\n\telse if(d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  d[v.cap][p.second] = d[u.cap][p.first] + m[p];\n\t  v.str = p.second;\n\t  v.cap = cap;\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\ntypedef int weight;\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int t, weight c):to(t), cost(c){}\n};\ntypedef pair<weight, int> P;\nconstexpr int INF = 0xfffffff;\n\nvector<int> dijkstra(int s, int cap, const vector<vector<edge>>& es) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INF);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst P p = que.top();\n\t\tque.pop();\n\t\tconst int v = p.second;\n\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < (int)es[v].size(); ++i) {\n\t\t\tconst edge& e = es[v][i];\n\t\t\tconst weight next_dist = dist[v] + e.cost;\n\t\t\tif(next_dist > cap * 10) continue;\n\n\t\t\tif(dist[e.to] > next_dist) {\n\t\t\t\tdist[e.to] = next_dist;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nunordered_map<string, int> en;\ninline int encode(const string& s) {\n\tif(!en.count(s)) en.insert(make_pair(s, en.size()));\n\treturn en[s];\n}\n\ninline int input_city() {\n\tstring s;\n\tcin >> s;\n\treturn encode(s);\n}\n\ninline int calc_nearest_city(const vector<int>& LPG, const vector<int>& dist) {\n\tint idx = LPG[0];\n\tfor(int i = 1; i < (int)LPG.size(); ++i) {\n\t\tif(dist[idx] > dist[LPG[i]]) idx = LPG[i];\n\t}\n\treturn idx;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, cap; cin >> n >> m >> cap && n;) {\n\t\ten.clear();\n\t\tconst int s = input_city();\n\t\tconst int t = input_city();\n\n\t\tvector<tuple<int, int, int>> edges;\n\t\tedges.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int a = input_city();\n\t\t\tconst int b = input_city();\n\t\t\tint cost;\n\t\t\tcin >> cost;\n\t\t\tedges.emplace_back(a, b, cost);\n\t\t}\n\n\t\tvector<int> LPG(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tLPG[i] = input_city();\n\t\t}\n\n\t\tconst int number_of_city = static_cast<int>(en.size());\n\t\tvector<vector<edge>> es(number_of_city);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b, cost;\n\t\t\ttie(a, b, cost) = edges[i];\n\t\t\tes[a].emplace_back(b, cost);\n\t\t\tes[b].emplace_back(a, cost);\n\t\t}\n\n\t\tvector<int> dist = dijkstra(s, cap, es);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tconst int next = calc_nearest_city(LPG, dist);\n\t\t\tLPG.erase(remove(LPG.begin(), LPG.end(), next), LPG.end());\n\t\t\tvector<int> tmp = dijkstra(next, cap, es);\n\t\t\tfor(int i = 0; i < number_of_city; ++i) {\n\t\t\t\tchmin(dist[i], dist[next] + tmp[i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[t] == INF ? -1 : dist[t]) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 1000000000\n\nint d[310];\nint dist[310][310];\nint dp2[6010];\nvector<int> st;\nvector<int> e[10010];\nvector<int> c[10010];\nmap<string,int> id;\nint n,m,cap;\nint to[310];\nint from[310];\nbool is[6010];\nint wh[6010];\n\n\nvoid solve(int x) {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\tfor (int i=0; i<m; i++) dist[wh[x]][i] = INF;\n\tto[wh[x]] = INF;\n\tfrom[wh[x]] = INF;\n\tdp2[x] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,x));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (is[p] && cur<=cap) {\n\t\t\tdist[wh[x]][wh[p]] = cur;\n\t\t}\n\t\tif (p==0) from[wh[x]] = cur;\n\t\tif (p==1) to[wh[x]] = cur;\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint solve2() {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\n\tdp2[0] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,0));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (p==1) {\n\t\t\treturn cur;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INF;\n}\n\t\t\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&n,&m,&cap) && n!=0) {\n\t\tid.clear();\n\t\tcap *= 10;\n\t\tfor (int i=0; i<2*n; i++) e[i].clear();\n\t\tfor (int i=0; i<2*n; i++) c[i].clear();\n\t\tint cnt = 2;\n\t\tst.clear();\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tid[src] = 0;\n\t\tid[dest] = 1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tstring s1,s2;\n\t\t\tcin>>s1>>s2;\n\t\t\tif (id.find(s1)==id.end()) id[s1] = cnt++;\n\t\t\tif (id.find(s2)==id.end()) id[s2] = cnt++;\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\te[id[s1]].push_back(id[s2]);\n\t\t\te[id[s2]].push_back(id[s1]);\n\t\t\tc[id[s1]].push_back(h);\n\t\t\tc[id[s2]].push_back(h);\n\t\t}\n\t\tfor (int i=0; i<2*n; i++) is[i] = 0;\n\t\tfor (int i=0; i<2*n; i++) wh[i] = 0;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif (id.find(s)==id.end()) continue;\n\t\t\tst.push_back(id[s]);\n\t\t\tis[id[s]] = 1;\n\t\t\twh[id[s]] = i;\n\t\t}\n\t\tn = cnt;\n\t\t\n\t\tfor (int i=0; i<st.size(); i++) {\n\t\t\tsolve(st[i]);\n\t\t}\n\t\t\n\t\t//for (int i=0; i<m; i++) {\n\t\t//\tfor (int j=0; j<m; j++) cout<<dist[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t\n\t\tint ans = solve2();\n\t\t\n\t\tif (ans>cap) ans = INF;\n\t\t\n\t\tfor (int k=0; k<m; k++) for (int i=0; i<m; i++) for (int j=0; j<m; j++) \n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tfor (int i=0; i<m; i++) for (int j=0; j<m; j++) {\n\t\t\tif (from[i]<=cap && to[i]>=cap) {\n\t\t\t\tans = min(ans, from[i] + to[i] + dist[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans==INF) cout<<-1<<endl; \n\t\telse cout<<ans<<endl;\n\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\nstring s1,s2,stt,goo;\nint n,m,x,c1;\nint dp[3009][2009];\nvector<P>v[5000];\nint main(){\n  while(cin>>n>>m>>x,n){\n    r(i,5000)v[i].clear();\n    r(i,3009)r(j,2009)dp[i][j]=1e9;\n    x*=10;\n    int c=1;\n    map<string,int>M;\n    set<int>s;\n    cin>>stt>>goo;\n    r(i,n){\n      cin>>s1>>s2>>c1;\n      if(!M[s1])M[s1]=c++;\n      if(!M[s2])M[s2]=c++;\n      v[M[s1]].push_back(P(M[s2],c1));\n      v[M[s2]].push_back(P(M[s1],c1));\n    }\n    int st=M[stt],go=M[goo];\n    r(i,m){\n      cin>>s1;\n      s.insert(M[s1]);\n    }\n    dp[st][x]=0;\n    priority_queue<P,vector<PP>,greater<PP> >q;\n    q.push(PP(0,P(st,x)));\n    while(!q.empty()){\n      PP p=q.top();q.pop();\n      int now=p.second.first;\n      int cost=p.first;\n      int cap=p.second.second;\n      if(dp[now][cap]<cost)continue;\n      r(i,v[now].size()){\n        int dis=v[now][i].second;\n        int next=v[now][i].first;\n        int cost2=cost+dis;\n        int cap2=cap-dis;\n        if(cap2<0)continue;\n        if(s.count(next))cap2=x;\n        if(dp[next][cap2]>cost2){//cout<<next<<' '<<cost2<<endl;\n          dp[next][cap2]=cost2;\n          q.push(PP(cost2,P(next,cap2)));\n        }\n      }\n    }\n    int ans=1e9;\n    r(i,2009)ans=min(dp[go][i],ans);\n    if(ans==1e9)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef int W;\n\nconst W INF = 1LL << 28;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph& G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nW wf[310][310];\nstring a[3000], b[3000];\nW dist[3000];\nstring st_name[310];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N | M | cap) {\n\t\tmap<string, int> city;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tcity[src] = -1;\n\t\tcity[dst] = -1;\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> a[i] >> b[i] >> dist[i];\n\t\t\tcity[a[i]] = -1;\n\t\t\tcity[b[i]] = -1;\n\t\t}\n\n\t\tint C = 0;\n\t\tfor(auto& p : city) {\n\t\t\tcity[p.first] = C++;\n\t\t}\n\n\t\tmap<string, int> station;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> st_name[i];\n\t\t\tstation[st_name[i]] = i;\n\t\t}\n\t\tstation[src] = M;\n\t\tstation[dst] = M + 1;\n\t\tst_name[M] = src;\n\t\tst_name[M + 1] = dst;\n\t\tM += 2;\n\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tGraph G(C);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tG[city[a[i]]].push_back(edge{ city[b[i]], dist[i] });\n\t\t\tG[city[b[i]]].push_back(edge{ city[a[i]], dist[i] });\n\t\t}\n\n\t\tvector<W> d(C);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tdijkstra(city[st_name[i]], G, d);\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(d[city[st_name[j]]] <= cap * 10) {\n\t\t\t\t\twf[i][j] = wf[j][i] = d[city[st_name[j]]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < M; k++)\n\t\t\tfor(int i = 0; i < M; i++)\n\t\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tW ans = wf[station[src]][station[dst]];\n\t\tif(ans == INF) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx <= MAX);\n\n      rep(i,idx)\n\t{\n\t  G[i].clear();\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n   \n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n      int ans = (1<<29);\n      P p;\n      Pox pox;\n      int i;\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      break;\n\t    }\n\n\t  for(i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      p = G[pox.cur][i];\n\t  \n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[p.to])continue;\n\n\t      if(mincost[p.to][pox.tank-p.d] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[p.to][pox.tank-p.d] = pox.cost + p.d;\n\t\t  if(LPG[p.to])\n\t\t    que.push(Pox(p.to,mincost[p.to][pox.tank-p.d],cap*10));\n\t\t  else\n\t\t    que.push(Pox(p.to,mincost[p.to][pox.tank-p.d],pox.tank-p.d));\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=e[j][i]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint s_n, m; int c;\nmap<string, int> mp;\nint n = 2;\nint to_id(const string &s) {\n\tif (mp[s])return mp[s];\n\telse {\n\t\tn++; mp[s] = n; return n;\n\t}\n}\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[3001];\nvector<edge> trueG[3001];\nint d[3001];\nvoid init(int s) {\n\trep1(i, n) {\n\t\td[i] = mod;\n\t}\n\td[s] = 0;\n}\nbool needed[3001];\n\npriority_queue<P,vector<P>,greater<P>> q;\nvoid dijkstra(int sta) {\n\tinit(sta);\n\tq.push({ 0,sta });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\trep(j, G[v].size()) {\n\t\t\tint to = G[v][j].to;\n\t\t\tif (p.first + G[v][j].cost < d[to]) {\n\t\t\t\td[to] = p.first + G[v][j].cost;\n\t\t\t\tq.push({ d[to],to });\n\t\t\t}\n\t\t}\n\t}\n\trep1(i, n) {\n\t\tif (i == sta)continue;\n\t\tif (!needed[i])continue;\n\t\tif (d[i] <= 10 * c) {\n\t\t\ttrueG[sta].push_back({ i,d[i] });\n\t\t}\n\t}\n}\nvoid all_init() {\n\trep1(i, n) {\n\t\tG[i].clear();\n\t\ttrueG[i].clear();\n\t}\n\tmp.clear();\n}\nint main() {\n\twhile (cin >> m >> s_n >> c,m) {\n\t\tall_init();\n\t\tstring in1, in2;\n\t\tcin >> in1 >> in2;\n\t\tmp[in1] = 1; mp[in2] = 2;\n\t\trep(i, m) {\n\t\t\tint z;\n\t\t\tcin >> in1 >> in2 >> z;\n\t\t\tint i1 = to_id(in1), i2 = to_id(in2);\n\t\t\tG[i1].push_back({ i2,z });\n\t\t\tG[i2].push_back({ i1,z });\n\t\t}\n\t\tneeded[1] = needed[2] = true;\n\t\trep(i, s_n) {\n\t\t\tcin >> in1;\n\t\t\tneeded[to_id(in1)] = true;\n\t\t}\n\t\trep1(i, n)if (needed[i])dijkstra(i);\n\t\tinit(1);\n\t\tq.push({ 0,1 });\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\trep(j, trueG[v].size()) {\n\t\t\t\tint to = trueG[v][j].to;\n\t\t\t\tint cost = p.first + trueG[v][j].cost;\n\t\t\t\tif (cost < d[to]) {\n\t\t\t\t\td[to] = cost;\n\t\t\t\t\tq.push({ d[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[2] == mod)cout << -1 << endl;\n\t\telse cout << d[2] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nvector<pair<int, int> > E[10000];\nbool LPF[10000];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\trep(i, 0, 10000) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 10000) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n  \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n  \n#define MAX_V 1000000\n#define INF 100000000\n  \nusing namespace std;\n  \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n  \nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n  \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n  \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n      \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n         d[e.to] = d[v]+e.cost;\n         que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n  \nint main(void){\n  \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n  \n  while(cin >> n >> m >> cap,n&m&cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \n    cin >> src >> dest;\n      \n    node.pb(src);\n    node.pb(dest);\n  \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n  \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n  \n    map<string,int>vnum;\n  \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n      \n    for(int i=0;i<V;i++)G[i].clear();    \n  \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n  \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n  \n  \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n  \n    dijkstra(vnum[src]);\n  \n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntypedef int weight;\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int t, weight c):to(t), cost(c){}\n};\ntypedef pair<weight, int> P;\nconstexpr int INF = 0xfffffff;\n\nvector<int> dijkstra(int s, int cap, const vector<vector<edge>>& es) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INF);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst P p = que.top();\n\t\tque.pop();\n\t\tconst int v = p.second;\n\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < (int)es[v].size(); ++i) {\n\t\t\tconst edge& e = es[v][i];\n\t\t\tconst weight next_dist = dist[v] + e.cost;\n\t\t\tif(next_dist > cap * 10) continue;\n\n\t\t\tif(dist[e.to] > next_dist) {\n\t\t\t\tdist[e.to] = next_dist;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nunordered_map<string, int> en;\ninline int encode(const string& s) {\n\tif(!en.count(s)) en.insert(make_pair(s, en.size()));\n\treturn en[s];\n}\n\ninline int input_city() {\n\tstring s;\n\tcin >> s;\n\treturn encode(s);\n}\n\ninline int calc_nearest_city(const vector<int>& LPG, const vector<int>& dist) {\n\tint idx = LPG[0];\n\tfor(int i = 1; i < (int)LPG.size(); ++i) {\n\t\tif(dist[idx] > dist[LPG[i]]) idx = LPG[i];\n\t}\n\treturn idx;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, cap; cin >> n >> m >> cap && n;) {\n\t\ten.clear();\n\t\tconst int s = input_city();\n\t\tconst int t = input_city();\n\n\t\tvector<tuple<int, int, int>> edges;\n\t\tedges.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int a = input_city();\n\t\t\tconst int b = input_city();\n\t\t\tint cost;\n\t\t\tcin >> cost;\n\t\t\tedges.emplace_back(a, b, cost);\n\t\t}\n\n\t\tvector<int> LPG(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tLPG[i] = input_city();\n\t\t}\n\n\t\tconst int number_of_city = static_cast<int>(en.size());\n\t\tvector<vector<edge>> es(number_of_city);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b, cost;\n\t\t\ttie(a, b, cost) = edges[i];\n\t\t\tes[a].emplace_back(b, cost);\n\t\t\tes[b].emplace_back(a, cost);\n\t\t}\n\n\t\tvector<int> dist = dijkstra(s, cap, es);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tconst int next = calc_nearest_city(LPG, dist);\n\t\t\tLPG.erase(remove(LPG.begin(), LPG.end(), next), LPG.end());\n\t\t\tvector<int> tmp = dijkstra(next, cap, es);\n\t\t\tfor(int i = 0; i < number_of_city; ++i) {\n\t\t\t\tchmin(dist[i], dist[next] + tmp[i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[t] == INF ? -1 : dist[t]) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: 1412kid1412@UESTC\n*/\n\n#include <stdexcept>\n#include <cstdarg>\n#include <iostream>\n#include <fstream>\n#include <exception>\n#include <memory>\n#include <locale>\n#include <sstream>\n#include <set>\n#include <list>\n#include <bitset>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <string>\n#include <utility>\n#include <cctype>\n#include <climits>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <cstdlib>\n#include <stack>\n#include <iterator>\n#include <functional>\n#include <complex>\n#include <valarray>\nusing namespace std;\n\nint dis[4010][2010];\nint inq[4010][2010];\nmap<string,int> idx;\nmap<int,int>nidx;\nstruct Edge{\n\tint v,d;\n\tEdge(){\n\t}\n\tEdge(int v,int d):v(v),d(d){\n\t}\n};\nvector<Edge> G[3010];\nbool can[6010];\nbool dfs(int u,int dist,int cap)\n{\n    if(dist>cap)return 0;\n    if(can[u])return 1;\n    int sz=G[u].size();\n    for(int i=0;i<sz;i++)\n    {\n        if(dfs(G[u][i].v,G[u][i].d+dist,cap))return 1;\n    }\n    return 0;\n}\nint spfa(int s,int t,int cap){\n\tmemset(dis,63,sizeof(dis));\n\tmemset(inq,0,sizeof(inq));\n\tint ret=(dis[0][0]);\n\tint oo=ret;\n\tqueue<pair<int,int> > que;\n\tque.push(make_pair(s,cap));\n\tinq[nidx[s]][cap]=true;\n\tdis[nidx[s]][cap]=0;\n\n\twhile(!que.empty()){\n\t\tpair<int,int> u=que.front();\n\t\tque.pop();\n\t\tinq[nidx[u.first]][u.second]=false;\n\t\tint sz=G[u.first].size();\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tint v=G[u.first][i].v;\n\t\t\tif(!nidx.count(v))continue;\n\t\t\tif(u.second<=G[u.first][i].d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nowcap=u.second-G[u.first][i].d;\n\t\t\tif(can[v]){\n\t\t\t\tnowcap=cap;\n\t\t\t}\n\t\t\tif(dis[nidx[v]][nowcap]>dis[nidx[u.first]][u.second]+G[u.first][i].d){\n\t\t\t\tdis[nidx[v]][nowcap]=dis[nidx[u.first]][u.second]+G[u.first][i].d;\n\t\t\t\tif(!inq[nidx[v]][nowcap]){\n\t\t\t\t\tinq[nidx[v]][nowcap]=true;\n\t\t\t\t\tque.push(make_pair(v,nowcap));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=cap;i++){\n\t\tret=min(ret,dis[nidx[t]][i]);\n\t}\n\tif(ret==oo){\n\t\tret=-1;\n\t}\n\treturn ret;\n}\nint main(){\n\tint road,load,cap;\n\twhile(scanf(\"%d%d%d\",&road,&load,&cap)){\n            idx.clear();\n            nidx.clear();\n\t\tcap*=10;\n\t\tif(0==road&&0==load&&0==cap){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(can,0,sizeof(can));\n\t\tfor(int i=0;i<=3000;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tint cnt=0;\n\t\tint S,T;\n\t\tstring a,b;\n\t\tcin>>a>>b;\n\t\tif(!idx.count(a)){\n\t\t\tidx[a]=cnt++;\n\t\t}\n\t\tif(!idx.count(b)){\n\t\t\tidx[b]=cnt++;\n\t\t}\n\t\tS=idx[a];\n\t\tT=idx[b];\n\t\tfor(int i=0;i<road;i++){\n\t\t\tstring a,b;\n\t\t\tint x;\n\t\t\tcin>>a>>b;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(!idx.count(a)){\n\t\t\t\tidx[a]=cnt++;\n\t\t\t}\n\t\t\tif(!idx.count(b)){\n\t\t\t\tidx[b]=cnt++;\n\t\t\t}\n\t\t\tint u=idx[a];\n\t\t\tint v=idx[b];\n\t\t\t//cout<<u<<\" \"<<v<<\" \"<<x<<endl;\n\t\t\tG[u].push_back(Edge(v,x));\n\t\t\tG[v].push_back(Edge(u,x));\n\t\t}\n\t\tfor(int i=0;i<load;i++){\n\t\t\tstring a;\n\t\t\tcin>>a;\n\t\t\tif(!idx.count(a)){\n\t\t\t\tidx[a]=cnt++;\n\t\t\t}\n\t\t\tint x=idx[a];\n\t\t\tcan[x]=true;\n\t\t}\n\t\tint ncnt=0;\n\t\tnidx[S]=ncnt++;\n\t\tnidx[T]=ncnt++;\n\t\tfor(int i=0;i<cnt;i++)\n            if(i!=S&&i!=T)\n        {\n         if(dfs(i,0,cap))nidx[i]=ncnt++;\n        }\n\t\tprintf(\"%d\\n\",spfa(S,T,cap));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<V;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int to, cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int INF = 1e9;\n\nvector<int> dijkstra(graph& g, int s) {\n    vector<int> d(g.size(), INF);\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.push(make_pair(0, s));\n    d[s] = 0;\n    while(!que.empty()) {\n        pii p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    int N, M, cap;\n    while(cin >> N >> M >> cap, N) {\n        unordered_map<string, int> idx;\n        string src, dest;\n        cin >> src >> dest;\n        graph g(6001);\n        idx[src] = 0; idx[dest] = 1;\n        cap *= 10;\n        for(int i=0; i<N; ++i) {\n            string c1, c2;\n            int d;\n            cin >> c1 >> c2 >> d;\n            if(idx.count(c1) == 0) {\n                idx[c1] = idx.size();\n            }\n            if(idx.count(c2) == 0) {\n                idx[c2] = idx.size();\n            }\n            g[idx[c1]].push_back(edge{idx[c2], d});\n            g[idx[c2]].push_back(edge{idx[c1], d});\n        }\n        vector<int> S = {0, 1};\n        for(int i=0; i<M; ++i) {\n            string s;\n            cin >> s;\n            S.push_back(idx[s]);\n        }\n        graph g2(S.size());\n        for(int i=0; i<S.size(); ++i) {\n            auto d = dijkstra(g, S[i]);\n            for(int j=0; j<S.size(); ++j) {\n                if(d[S[j]] <= cap) {\n                    g2[i].push_back(edge{j, d[S[j]]});\n                }\n            }\n        }\n        auto res = dijkstra(g2, 0);\n        cout << (res[1] == INF ? -1 : res[1]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(n, vi(cap + 1, inf));\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 1000000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n     \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n   \t\t d[e.to] = d[v]+e.cost;\n   \t\t que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n \n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n    map<string,int>vnum;\n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n    if(d[vnum[dest]]>=INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nmap<string, int> mp;\nconst int N = 10010;\nvector<P> G[N];\nint lpgid[N];\nconst int M = 310;\nint lpg[M];\nint d[M][M];\n\nvoid dijk(int s, int cap){\n\tvector<int> dist(N, 1e9);\n\n\tpriority_queue<P> q;\n\tq.push(MP(0, s));\n\tdist[s] = 0;\n\twhile (!q.empty()){\n\t\tauto p = q.top();\n\t\tq.pop();\n\n\t\tint dd = p.first;\n\t\tint pos = p.second;\n\t\tif (dist[pos] < dd) continue;\n\t\tif (lpgid[pos] >= 0) d[lpgid[s]][lpgid[pos]] = dd;\n\n\t\tfor (auto edge : G[pos]){\n\t\t\tint nd = dd + edge.second;\n\t\t\tint npos = edge.first;\n\t\t\tif (dist[npos] <= nd) continue;\n\t\t\tdist[npos] = nd;\n\n\t\t\tif (nd <= cap) q.emplace(nd, npos);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tMEMSET(lpgid, -1);\n\t\tMEMSET(lpg, -1);\n\t\trep(i, M) rep(j, M) if(i != j) d[i][j] = 1e9;\n\t\trep(i, N) G[i].clear();\n\t\tmp.clear();\n\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint num = 0;\n\t\tmp[src] = num++;\n\t\tmp[dest] = num++;\n\t\trep(i, n){\n\t\t\tstring s, t;\n\t\t\tcin >> s >> t;\n\t\t\tif (!mp.count(s)) mp[s] = num++;\n\t\t\tif (!mp.count(t)) mp[t] = num++;\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\tG[mp[s]].emplace_back(mp[t], d);\n\t\t\tG[mp[t]].emplace_back(mp[s], d);\n\t\t}\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tassert(mp.count(s) == 1);\n\t\t\tlpgid[mp[s]] = i;\n\t\t\tlpg[i] = mp[s];\n\t\t}\n\t\tlpgid[mp[src]] = m;\n\t\tlpg[m] = mp[src];\n\t\tlpgid[mp[dest]] = m + 1;\n\t\tlpg[m + 1] = mp[dest];\n\n\t\trep(i, m + 2) dijk(lpg[i], cap * 10);\n\n\t\trep(i, m + 2) rep(j, m + 2) rep(k, m + 2)\n\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n\n\t\tint ans = d[m][m + 1];\n\t\tif (ans >= 1e9) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n  int to;\n  int cost;\n};\n\nint d[2001][6011];\nvector<edge> G[6011];\nbool isGas[10001];\nmap<string,int> m;\nint idx;\nint st,gl;\n\nint N,M,cap;\nconst int INF=1<<30;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> Sit;\n\nint dijkstra(){\n  for(int i=0;i<2001;i++)\n    for(int j=0;j<6011;j++)\n      d[i][j]=INF;\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  pq.push(make_pair(0,pii(cap*10,st)));\n  d[cap*10][st]=0;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int ccost=p.first;\n    int ccap=p.second.first;\n    int cnode=p.second.second;\n    if(d[ccap][cnode]<ccost)continue;\n    for(int i=0;i<(int)G[cnode].size();i++){\n      edge &e=G[cnode][i];\n      int ncap=ccap-e.cost;\n      if(ncap<0)continue;\n      int nnode=e.to;\n      int ncost=ccost+e.cost;\n      if(isGas[nnode])ncap=cap*10;\n      if(d[ncap][nnode]>ncost){\n\td[ncap][nnode]=ncost;\n\tpq.push(make_pair(ncost,pii(ncap,nnode)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<2001;i++)res=min(res,d[i][gl]);\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>cap&&(N|M|cap)){\n    memset(isGas,0,sizeof(isGas));\n    for(int i=0;i<6011;i++)G[i].clear();\n    idx=0;\n    string s,t;\n    cin>>s>>t;\n    if(m.count(s)==0)m[s]=idx++;\n    if(m.count(t)==0)m[t]=idx++;\n    st=m[s];gl=m[t];\n    for(int i=0;i<N;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(m.count(a)==0)m[a]=idx++;\n      if(m.count(b)==0)m[b]=idx++;\n      int x,y;\n      x=m[a];y=m[b];\n      edge e;\n      e.to=y;\n      e.cost=c;\n      G[x].push_back(e);\n      e.to=x;\n      G[y].push_back(e);\n    }\n    for(int i=0;i<M;i++){\n      string s;\n      cin>>s;\n      if(m.count(s)==0)m[s]=idx++;\n      isGas[m[s]]=true;\n    }\n    int res=dijkstra();\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 2000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d<p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tset<string> cities;\n\t\tvector<vs> data(N, vs(3)); \n\t\tREP(i, N) {\n\t\t\tREP(j, 2) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tcities.insert(data[i][j]);\n\t\t\t}\n\t\t\tcin >> data[i][2];\n\t\t}\n\n\t\tmap<string, int> index;\n\t\tset<string>::iterator it = cities.begin();\n\t\tint size = 0;\n\t\twhile(it != cities.end()) {\n\t\t\tindex[*it] = size;\n\t\t\tsize++;\n\t\t\tit++;\n\t\t}\n\n\t\tvvs dist(size, vsh(size, INF));\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvector<bool> gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvs cost(size, vsh(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d][ng]) {\n\t\t\t\t\t\tcost[d][ng] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<int> > dist( n, vector<int>( n, INF ) );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\tdist[a][b] = dist[b][a] = d[i];\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\n\tfor( int k = 0; k < n; ++k ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tfor( int j = 0; j < i; ++j ){\n\t\t\t\tif( dist[i][j] > dist[i][k] + dist[k][j] ){\n\t\t\t\t\tdist[i][j] = dist[j][i] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcap *= 10;\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\ttypedef pair<int,int> pii;\n\tpriority_queue< pii, deque<pii>, greater<pii> > pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[n_from][n_to] <= cap && dp[to] > dp[from] + dist[n_from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[n_from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n \n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n \nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n \nint n, m, cap, dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n \ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n \ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      adj[sid.size()].clear();\n      sid.emplace(s0, sid.size());\n    }\n    if(!sid.count(s1)) {\n      adj[sid.size()].clear();\n      sid.emplace(s1, sid.size());\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  dis[0] = 0;\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    //cerr << \"cost \" << nxt0.F << \" id \" << nxt0.S << endl;\n \n    vector<int> tmp_dis(mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    if(tmp_dis[1] != INF)\n      return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  if(dis[1] == INF)\n    return -1;\n  else\n    return dis[1];\n}\n \nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct Edge {\n  int to, cost;\n};\n\nstruct P {\n  int p, cost, dist;\n\n  bool operator >(const P& p) const {\n    return cost > p.cost;\n  }\n};\n\nconst int INF = (int)1e9;\n\nint main() {\n  int road_n, gas_n, capacity;\n  string src, dst;\n  while(cin >> road_n >> gas_n >> capacity, road_n | gas_n | capacity) {\n    cin >> src >> dst;\n\n    map<string, int> id;\n    vector<vector<Edge>> E;\n    vector<bool> isgas;\n\n    REP(i, road_n){\n      string from, to;\n      int cost;\n      cin >> from >> to >> cost;\n      if (!EXIST(id, from)) {\n        id.insert({from, id.size()});\n        E.push_back(vector<Edge>());\n        isgas.push_back(false);\n      }\n      if (!EXIST(id, to)) {\n        id.insert({to, id.size()});\n        E.push_back(vector<Edge>());\n        isgas.push_back(false);\n      }\n      E[id[from]].push_back({id[to], cost});\n      E[id[to]].push_back({id[from], cost});\n    }\n    REP(i, gas_n){\n      string town;\n      cin >> town;\n      isgas[id[town]] = true;\n    }\n\n    int start = id[src];\n    int goal = id[dst];\n    vvi G(id.size(), vi(capacity * 10 + 1, INF));\n    G[start][0] = 0;\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({start, 0, 0});\n\n    int res = -1;\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      if(p.p == goal) {\n        res = p.cost;\n        break;\n      }\n\n      for(Edge e:E[p.p]) {\n        int next_dist = p.dist + e.cost;\n        if(next_dist > capacity * 10) continue;\n        if(isgas[e.to]) next_dist = 0;\n        int next_cost = p.cost + e.cost;\n        if (G[e.to][next_dist] > next_cost) {\n          G[e.to][next_dist] = next_cost;\n          que.push({e.to, next_cost, next_dist});\n        }\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 3030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[303];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + VV, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!G[i].empty())\n\t\t\tG[i].clear();\n\t\tfor(i = 0; i < 303; i++)\n\t\tif(!GG[i].empty())\n\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tVV = M + 2;\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[3005][3005];\nint gas[305];\nint head[3005];\nint dp[2001][2501];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[3005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(u<=2500&&dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return 0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n        }\n    }\n    if(u<=2500)\n    return dp[gasnum][u]=ret;\n    else\n    return ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n                u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n            printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 1000000000\n\nint dist[310][310];\nint dp2[6010];\nvector<int> st;\nvector<int> e[6010];\nvector<int> c[6010];\nmap<string,int> id;\nint n,m,cap;\nint to[310];\nint from[310];\nbool is[6010];\nint wh[6010];\n\n\nvoid solve(int x) {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\tfor (int i=0; i<m; i++) dist[wh[x]][i] = INF;\n\tto[wh[x]] = INF;\n\tfrom[wh[x]] = INF;\n\tdp2[x] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,x));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (is[p] && cur<=cap) {\n\t\t\tdist[wh[x]][wh[p]] = cur;\n\t\t}\n\t\tif (p==0) from[wh[x]] = cur;\n\t\tif (p==1) to[wh[x]] = cur;\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint solve2() {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\n\tdp2[0] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,0));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (p==1) {\n\t\t\treturn cur;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INF;\n}\n\t\t\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&n,&m,&cap) && n!=0) {\n\t\tid.clear();\n\t\tcap *= 10;\n\t\tfor (int i=0; i<2*n; i++) e[i].clear();\n\t\tfor (int i=0; i<2*n; i++) c[i].clear();\n\t\tint cnt = 2;\n\t\tst.clear();\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tid[src] = 0;\n\t\tid[dest] = 1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tstring s1,s2;\n\t\t\tcin>>s1>>s2;\n\t\t\tif (id.find(s1)==id.end()) id[s1] = cnt++;\n\t\t\tif (id.find(s2)==id.end()) id[s2] = cnt++;\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\te[id[s1]].push_back(id[s2]);\n\t\t\te[id[s2]].push_back(id[s1]);\n\t\t\tc[id[s1]].push_back(h);\n\t\t\tc[id[s2]].push_back(h);\n\t\t}\n\t\tfor (int i=0; i<2*n; i++) is[i] = 0;\n\t\tfor (int i=0; i<2*n; i++) wh[i] = 0;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif (id.find(s)==id.end()) continue;\n\t\t\tst.push_back(id[s]);\n\t\t\tis[id[s]] = 1;\n\t\t\twh[id[s]] = i;\n\t\t}\n\t\tn = cnt;\n\t\t\n\t\tfor (int i=0; i<st.size(); i++) {\n\t\t\tsolve(st[i]);\n\t\t}\n\t\t\n\t\t//for (int i=0; i<m; i++) {\n\t\t//\tfor (int j=0; j<m; j++) cout<<dist[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t\n\t\tint ans = solve2();\n\t\t\n\t\tif (ans>cap) ans = INF;\n\t\t\n\t\tfor (int k=0; k<m; k++) for (int i=0; i<m; i++) for (int j=0; j<m; j++) \n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tfor (int i=0; i<m; i++) for (int j=0; j<m; j++) {\n\t\t\tif (from[i]<=cap && to[j]>=cap) {\n\t\t\t\tans = min(ans, from[i] + to[j] + dist[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans==INF) cout<<-1<<endl; \n\t\telse cout<<ans<<endl;\n\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<string,int> con;\nvector<pii> graph[6010];\nint dist[310];\nint station[6010];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v){\n\tif(station[v]==-1)\n\t\treturn false;\n\tv=station[v];\n\tif(dist[v]==-1||dist[v]>c){\n\t\tdist[v]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint dijkstra(int cap){\n\tdist[0]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(station[v]){\n\t\t\tg=cap;\n\t\t\tupdate(c,v);\n\t\t}\n\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tint ng=g-v2.second;\n\t\t\tif(ng<0) continue;\n\t\t\tif(update(nc,v2.first)){\n\t\t\t\tstate next(nc,v2.first,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tint n,m,cap;\n\tclr(dist,-1);\n\tclr(station,-1);\n\twhile(cin >> n >> m >> cap){\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\t\tstation[0]=0,station[1]=1;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[con[s]]=i+2;\n\t\t}\n\t\tint ans=dijkstra(cap*10);\n\t\tcout << ans << endl;\n\t\tcon.clear();\n\t\tclr(dist,-1);\n\t\trep(i,6010) graph[i].clear();\n\t\tclr(station,-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MT make_tuple\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint N, M, C, SZ;\nvector<Edge> G[6001];\nint dist[6010][2010];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[src] = SZ++;\n\tcor[dest] = SZ++;\n\tC *= 10;\n\tREP(i,6010) G[i].clear();\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = SZ++;\n\t  if(!cor.count(s2)) cor[s2] = SZ++;\n\t  int u = cor[s1], v = cor[s2];\n\t  G[u].PB(Edge(v,d));\n\t  G[v].PB(Edge(u,d));\n\t}\n\n\tset<int> LPG;\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  LPG.insert(cor[s]);\n\t}\n\n\ttypedef tuple<int,int,int> Node;\n\tpriority_queue<Node, vector<Node>, greater<Node> > pq;\n\tfill((int*)dist, (int*)dist+6010*2010, INF);\n\tdist[0][C] = 0;\n\tpq.push(MT(0,0,C));\n\n\tint ans = INF;\n\twhile(!pq.empty()){\n\t  auto tp = pq.top(); pq.pop();\n\t  int c, v, f;\n\t  tie(c,v,f) = tp;\n\t  if(v == 1){\n\t\tans = c; break;\n\t  }\n\t  if(dist[v][f] < c) continue;\n\t  for(int i=0;i<G[v].size();++i){\n\t\tconst Edge& e = G[v][i];\n\t\tint d = e.cost;\n\t\tif(f < d) continue;\n\t\tint nf = LPG.count(e.to)? C: f-d;\n\t\tif(dist[e.to][nf] > dist[v][f] + d){\n\t\t  dist[e.to][nf] = dist[v][f] + d;\n\t\t  pq.push(MT(dist[e.to][nf], e.to, nf));\n\t\t}\n\t  }\n\t}\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nint main() {\n\twhile (true) {\n\t\tint n, m, cap; std::cin >> n >> m >> cap;\n\t\tif (n == 0 && m == 0) break;\n\t\tstd::map<std::string, int> to_int;\n\t\tstd::string source, destination; std::cin >> source >> destination; to_int.emplace(source, 0); to_int.emplace(destination, 1);\n\t\tstd::vector<std::vector<std::pair<int, int>>> nodes(2);\n\t\t{\n\t\t\tstd::string from, to; int distance;\n\t\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\t\tstd::cin >> from >> to >> distance;\n\t\t\t\tif (distance > cap * 10) continue;\n\t\t\t\tauto f = to_int.emplace(from, to_int.size());\n\t\t\t\tauto t = to_int.emplace(to, to_int.size());\n\t\t\t\tif (to_int.size() > nodes.size()) nodes.resize(to_int.size());\n\t\t\t\tnodes[f.first->second].emplace_back(t.first->second, distance); nodes[t.first->second].emplace_back(f.first->second, distance);\n\t\t\t}\n\t\t}\n\t\tstd::vector<bool> has_lpg_station(to_int.size(), false);\n\t\t{\n\t\t\tstd::string station;\n\t\t\tfor (auto i = 0; i < m; ++i) {\n\t\t\t\tstd::cin >> station; has_lpg_station[to_int[station]] = true;\n\t\t\t}\n\t\t}\n\t\tauto comparator = [](const std::pair<std::pair<int, int>, int>& a, const std::pair<std::pair<int, int>, int>& b) {return a.second > b.second; };\n\t\tstd::priority_queue<std::pair<std::pair<int, int>, int>, std::vector<std::pair<std::pair<int, int>, int>>, decltype(comparator)> queue(comparator);\n\t\tstd::vector<std::vector<int>> min_length(to_int.size(), std::vector<int>(cap * 10 + 1, INT_MAX));\n\t\tmin_length[0][cap * 10] = 0; queue.emplace(std::make_pair(0, cap * 10), 0);\n\t\twhile (!queue.empty()) {\n\t\t\tauto top = queue.top();\n\t\t\tif (top.first.first == 1) break;\n\t\t\tqueue.pop();\n\t\t\tif (min_length[top.first.first][top.first.second] == top.second) {\n\t\t\t\tfor (const auto& next : nodes[top.first.first]) if (has_lpg_station[top.first.first]) {\n\t\t\t\t\tif (min_length[next.first][cap * 10 - next.second] > top.second + next.second) {\n\t\t\t\t\t\tmin_length[next.first][cap * 10 - next.second] = top.second + next.second;\n\t\t\t\t\t\tqueue.emplace(std::make_pair(next.first, cap * 10 - next.second), top.second + next.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (top.first.second >= next.second) {\n\t\t\t\t\tif (min_length[next.first][top.first.second - next.second] > top.second + next.second) {\n\t\t\t\t\t\tmin_length[next.first][top.first.second - next.second] = top.second + next.second;\n\t\t\t\t\t\tqueue.emplace(std::make_pair(next.first, top.first.second - next.second), top.second + next.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (queue.empty()) std::cout << -1 << std::endl;\n\t\telse std::cout << queue.top().second << std::endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int N, M, C;\n  while (cin >> N >> M >> C && N != 0) {\n    C *= 10;\n    map<string,int> m;\n    string start, goal;\n    cin >> start >> goal;\n    m.insert(make_pair(start, 0));\n    m.insert(make_pair(goal, 1));\n    vector<vector<pair<int,int> > > gg(2);\n    for (int i = 0; i < N; i++) {\n      string src, dst;\n      int d;\n      cin >> src >> dst >> d;\n      int u, v;\n      if (!m.count(src)) {\n        u = m.size();\n        m.insert(make_pair(src, u));\n        gg.push_back(vector<pair<int,int> >());\n      } else {\n        u = m[src];\n      }\n      if (!m.count(dst)) {\n        v = m.size();\n        m.insert(make_pair(dst, v));\n        gg.push_back(vector<pair<int,int> >());\n      } else {\n        v = m[dst];\n      }\n      gg[u].push_back(make_pair(v, d));\n      gg[v].push_back(make_pair(u, d));\n    }\n\n    vector<int> gss, gss_map(gg.size(), -1);\n    gss.push_back(0); // start\n    gss.push_back(1); // goal\n    gss_map[0] = 0;\n    gss_map[1] = 1;\n    for (int i = 0; i < M; i++) {\n      string s;\n      cin >> s;\n      const int v = m[s];\n      if (v != 0 && v != 1) {\n        gss_map[v] = gss.size();\n        gss.push_back(v);\n      }\n    }\n    const int MM = gss.size();\n\n    static const int INF = 10000000;\n    vector<vector<int> > dist(MM, vector<int>(MM, INF));\n    for (int i = 0; i < MM; i++) {\n      priority_queue<pair<int,int> > q;\n      vector<int> dp(gg.size(), INF);\n      dp[gss[i]] = 0;\n      q.push(make_pair(0, gss[i]));\n      while (!q.empty()) {\n        const int n = q.top().second;\n        const int c = -q.top().first;\n        q.pop();\n        if (c > dp[n]) {\n          continue;\n        }\n        for (vector<pair<int,int> >::const_iterator it = gg[n].begin(); it != gg[n].end(); ++it) {\n          int k = it->first;\n          const int cc = c + it->second;\n          if (cc <= C && cc < dp[k]) {\n            dp[k] = cc;\n            if (gss_map[k] != -1) {\n              dist[i][gss_map[k]] = min(dist[i][gss_map[k]], cc);\n            } else {\n              q.push(make_pair(-cc, k));\n            }\n          }\n        }\n      }\n    }\n\n    priority_queue<pair<int,int> > q;\n    vector<int> dp(MM, INF);\n    dp[0] = 0;\n    q.push(make_pair(0, 0));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      if (n == 1) {\n        cout << c << endl;\n        goto NEXT;\n      }\n      for (int v = 0; v < MM; v++) {\n        const int cc = c + dist[n][v];\n        if (dist[n][v] != INF && cc < dp[v]) {\n          dp[v] = cc;\n          q.push(make_pair(-cc, v));\n        }\n      }\n    }\n    cout << \"-1\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n        graph.emplace_back();\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n        graph.emplace_back();\n      }\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : 0)\n;\n\tif(dp[to][next_remaining_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1LL<<60\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1[3100],c2[3100];\nint d[3100];\nstring s[310];\nbool gas[10000];\nint num;\nvector<P> G[10000];\nlong long dis[10000][210];\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    map<string,int> id;\n    num = 0;\n    id[src] = num++; id[dest] = num++;\n    for(int i=0;i<n;i++){\n      cin >> c1[i] >> c2[i] >> d[i];\n      if(id.find(c1[i]) == id.end())id[c1[i]] = num++;\n      if(id.find(c2[i]) == id.end())id[c2[i]] = num++;\n    }\n\n    for(int i=0;i<num;i++)G[i].clear();\n\n    for(int i=0;i<n;i++){\n      G[id[c1[i]]].push_back(P(d[i],id[c2[i]]));\n      G[id[c2[i]]].push_back(P(d[i],id[c1[i]]));\n    }\n\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s[i];\n      gas[id[s[i]]] = true;\n    }\n\n    for(int i=0;i<num;i++){\n      for(int j=0;j<=cap;j++)dis[i][j] = INF;\n    }\n\n    dis[id[src]][cap] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      long long dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      if(pos == id[dest])break;\n\n      for(int i=0;i<G[pos].size();i++){\n\tint len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\n\tif(len > 10*tank)continue;\n\tint ntank = (10*tank - len)/10;\n\tif(gas[nxt])ntank = cap;\n\n\tif(dis[nxt][ntank] > dist + len){\n\t  dis[nxt][ntank] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    long long ans = INF;\n    for(int i=0;i<=cap;i++)ans = min(ans,dis[id[dest]][i]);\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[2500][2500];\nint gas[2500];\nint head[2500];\nint dp[2001][2500];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[3005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return dp[gasnum][u]=0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n        }\n    }\n    return dp[gasnum][u]=ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n                u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n            printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<edge> g[3333];\nbool sta[3333];\nint cost[3333][2222];\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    scanf(\"%s%s\",s,t);\n    vector<string> node;\n    for( int i = 0; i < 6666; i++ ) {\n      g[i].clear();\n      sta[i] = false;\n      for( int j = 0; j < 2222; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\nvector< vector< pair<int,int> > > G;\n\nstruct Edge{\n  int cost, from, to;\n  Edge(int cost, int from, int to):\n    cost(cost), from(from), to(to) {}\n};\n\nbool operator<(const Edge& a, const Edge& b){\n  return a.cost != b.cost ? a.cost < b.cost : a.from != b.from ? a.from < b.from : a.to < b.to;\n}\n\nvector<int> dijkstra(const vector< vector< pair<int,int> > > &G, int s){\n  int n = G.size();\n  vector<int> D(n,INF);\n  priority_queue< pair<int,int> > wait;\n  wait.push(make_pair(0,s));\n  while(!wait.empty()){\n    int d = -wait.top().first, v = wait.top().second;\n    wait.pop();\n    if(d > D[v]) continue;\n    D[v] = d;\n    for(int i = 0; i < G[v].size(); ++i){\n      int d_ = d + G[v][i].first, v_ = G[v][i].second;\n      if(d_ < D[v_]){\n        wait.push(make_pair(-d_, v_));\n        D[v_] = d_;\n      }\n    }\n  }\n  return D;\n}\n\nint main(){\n  int N, M, cap;\n  while(cin >> N >> M >> cap, N){\n    string src, dest;\n    cin >> src >> dest;\n    map<string,int> mp;\n    vector<string> C1(N), C2(N);\n    vector<int> D(N);\n    int t = 1;\n    for(int i = 0; i < N; ++i){\n      cin >> C1[i] >> C2[i] >> D[i];\n      if(!mp[C1[i]]){\n        mp[C1[i]] = t;\n        ++t;\n      }\n      if(!mp[C2[i]]){\n        mp[C2[i]] = t;\n        ++t;\n      }\n    }\n    int n = mp.size();\n    G = vector< vector< pair<int,int> > >(n);\n    for(int i = 0; i < N; ++i){\n      int u = mp[C1[i]] - 1, v = mp[C2[i]] - 1, d = D[i];\n      G[u].push_back(make_pair(d,v));\n      G[v].push_back(make_pair(d,u));\n    }\n    string c;\n    vector<int> S(M+2);\n    for(int i = 0; i < M; ++i){\n      cin >> c;\n      S[i] = mp[c] - 1;\n    }\n    int s = mp[src] - 1, g = mp[dest] - 1;\n    S[M] = s;\n    S[M+1] = g;\n    vector< vector< pair<int,int> > > G_(M+2);\n    for(int i = 0; i < M+2; ++i){\n      vector<int> D_ = dijkstra(G,S[i]);\n      for(int j = 0; j < M+2; ++j){\n        int d = D_[S[j]];\n        if(d <= cap*10) G_[i].push_back(make_pair(d,j));\n      }\n    }\n    int ans = dijkstra(G_,M)[M+1];\n    if(ans >= INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=e[j][i]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    cout << -1 << endl;\n    continue;\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<edge> g[6011];\n//vector<vector<edge> > g;\n\nvector<bool> sta;\nvector<vector<int> > cost;\nint from,to;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    {\n      vector<string> node;\n      scanf(\"%s%s\",s,t);\n      node.push_back(s);\n      node.push_back(t);\n      for( int i = 0; i < n; i++ ) {\n        scanf(\"%s%s%d\",c[i],d[i],w+i);\n        node.push_back(c[i]);\n        node.push_back(d[i]);\n      }\n      for( int i = 0; i < m; i++ ) {\n        scanf(\"%s\",st[i]);\n        node.push_back(st[i]);\n      }\n      sort(node.begin(),node.end());\n      node.erase(unique(node.begin(),node.end()),node.end());\n      int sz = node.size();\n      //g.clear();\n      cost.clear();\n      sta.clear();\n      //g.resize(sz,vector<edge>());\n      cost.resize(sz,vector<int>(cap*10+1));\n      sta.resize(sz);\n      for( int i = 0; i < sz; i++ ) {\n        sta[i] = false;\n        g[i].clear();\n        for( int j = 0; j <= cap*10; j++ ) {\n          cost[i][j] = 1919810893;\n        }\n      }\n      for( int i = 0; i < n; i++ ) {\n        int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n        int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n        g[a].push_back(edge(b,w[i]));\n        g[b].push_back(edge(a,w[i]));\n      }\n      for( int i = 0; i < m; i++ ) {\n        sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n      }\n      from = lower_bound(node.begin(),node.end(),s)-node.begin();\n      to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    }\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<int, int> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      int nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<int, int> >,vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<int, int> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      int pos = now.second.first;\n      int f = now.second.second;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      if (mp[dest] == pos) break;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tint np = edge[pos][i].first;\n\tint nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)){int k=ms.size();ms[a]=k;}\n      if(!ms.count(b)){int k=ms.size();ms[b]=k;}\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=dp[i][ms[vs[j]]];\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(;;){\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if(n == 0) break;\n    cap *= 10;\n    map<string,int> map;\n    string currN, destN;\n    cin >> currN >> destN;\n    auto mapping = [&map](const string &city) {\n      if(map.find(city) == map.end()) map.insert(make_pair(city, map.size()));\n      return map[city];\n    };\n    int curr = mapping(currN);\n    int dest = mapping(destN);\n    vector<vector<pair<int,int>>> es(2000,vector<pair<int,int>>());\n    for(int i = 0; i < n; i++) {\n      string src, tgt;\n      int d;\n      cin >> src >> tgt >> d;\n      int s = mapping(src);\n      int t = mapping(tgt);\n      es[s].push_back(make_pair(t, d));\n      es[t].push_back(make_pair(s, d));\n    }\n    vector<bool> gs(2000, false);\n    for(int i = 0; i < m; i++) {\n      string city;\n      cin >> city;\n      gs[mapping(city)] = true;\n    }\n    const int BIG = 3000*2000*2*2;\n    const int nn = map.size();\n    vector<vector<int>> ds(nn, vector<int>(cap+1, BIG));\n    vector<vector<bool>> fixed(nn, vector<bool>(cap+1, false));\n    priority_queue<pair<int, pair<int, int>>> que;\n    // Dijkstra\n    que.push(make_pair(0, make_pair(curr, cap)));\n    while(que.size() > 0) {\n      auto dvc = que.top();\n      que.pop();\n      const int d = dvc.first;\n      const int v = dvc.second.first;\n      const int c = dvc.second.second;\n      if(fixed[v][c]) continue;\n      fixed[v][c] = true;\n      ds[v][c] = d;\n      for(auto it = es[v].begin(); it != es[v].end(); it++) {\n        int cc = c - it->second;\n        if(cc >= 0) {\n          int i = it->first;\n          int dd = d + it->second;\n          if(gs[i]) cc = cap; // gas station\n          if(ds[i][cc] > dd){\n            ds[i][cc] = dd;\n            que.push(make_pair(dd, make_pair(i, cc)));\n          }\n        }\n      }\n    }\n    int min = BIG;\n    for(int i = 0; i <= cap; i++) {\n      if(min > ds[dest][i]) {\n        min = ds[dest][i];\n      }\n    }\n    cout << (min == BIG ? -1 : min) << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint p, q, c;\n\tNode(int p, int q, int c) : p(p), q(q), c(c) {}\n\tbool operator < (const Node &nd) const { return c > nd.c; }\n};\n\nconst int INF = 1000000007;\ntypedef vector< vector<Node> > graph;\n\nvector<int> getCost(const graph &g, int src, int cap){\n\tvector<bool> visit(g.size(), false);\n\tvector<int> res(g.size(), 10*cap+1);\n\tpriority_queue< Node > qu; qu.push(Node(src, src, 0));\n\tres[src] = 0;\n\twhile(!qu.empty()){\n\t\tNode nd = qu.top(); qu.pop();\n\t\tint pos = nd.q, cost = nd.c;\n\t\tif(visit[pos]) continue;\n\t\tfor(int i=0;i<g[pos].size();i++){\n\t\t\tint next = g[pos][i].q;\n\t\t\tif(cost + g[pos][i].c < res[next]){\n\t\t\t\tres[next] = cost + g[pos][i].c;\n\t\t\t\tqu.push(Node(pos, next, res[next]));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint dijkstra(const graph &g, int src, int dst){\n\tvector<bool> visit(g.size(), false);\n\tvector<int> res(g.size(), INF);\n\tpriority_queue< Node > qu; qu.push(Node(src, src, 0));\n\tres[src] = 0;\n\twhile(!qu.empty()){\n\t\tNode nd = qu.top(); qu.pop();\n\t\tint pos = nd.q, cost = nd.c;\n\t\tif(visit[pos]) continue;\n\t\tfor(int i=0;i<g[pos].size();i++){\n\t\t\tint next = g[pos][i].q;\n\t\t\tif(cost + g[pos][i].c < res[next]){\n\t\t\t\tres[next] = cost + g[pos][i].c;\n\t\t\t\tqu.push(Node(pos, next, res[next]));\n\t\t\t}\n\t\t}\n\t}\n\treturn res[dst] < INF ? res[dst] : -1;\n}\n\nint main(){\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N){\n\t\tstring src, dst; cin >> src >> dst;\n\t\tmap<string, int> mp;\n\t\tgraph g1(2*N, vector<Node>());\n\t\tint idx = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring c1, c2; int d;\n\t\t\tcin >> c1 >> c2 >> d;\n\t\t\tif(!mp.count(c1)) mp[c1] = idx++;\n\t\t\tif(!mp.count(c2)) mp[c2] = idx++;\n\t\t\tg1[mp[c1]].push_back(Node(mp[c1], mp[c2], d));\n\t\t\tg1[mp[c2]].push_back(Node(mp[c2], mp[c1], d));\n\t\t}\n\t\tvector<int> LPG(M+2);\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tstring s; cin >> s;\n\t\t\tLPG[i] = mp[s];\n\t\t}\n\t\t\n\t\tif(!mp.count(src)){ cout << -1 << endl; continue; }\n\t\tif(!mp.count(dst)){ cout << -1 << endl; continue; }\n\n\t\tLPG[0  ] = mp[src];\n\t\tLPG[M+1] = mp[dst];\n\n\t\tgraph g2(M+2, vector<Node>());\n\t\tfor(int i=0;i<M+2;i++){\n\t\t\tvector<int> vi = getCost(g1, LPG[i], cap);\n\t\t\tfor(int j=0;j<M+2;j++){\n\t\t\t\tif(vi[LPG[j]] <= 10*cap)\n\t\t\t\t\tg2[i].push_back(Node(i, j, vi[LPG[j]]));\n\t\t\t}\n\t\t}\n\n\t\tcout << dijkstra(g2, 0, M+1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nmap<string,int>id;\nvector<string>v,from,to;\nvector<int>cost;\nmap<string,int>id;\nvector<string>v,from,to;\nvector<int>cost;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear();\n    from.clear();\n    to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 5000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(N, vi(cap + 1, inf));\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dis[6100];\nvector<P> g[6100];\nint g2[310][310];\nmap<string,int> id;\nvector<int> gas;\nint n,m,cap,d;\nstring a,b;\nbool isg[6100];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> n >> m >> cap,n||m||cap){\n    id.clear(); gas.clear();\n    for(int i=0;i<6100;i++)g[i].clear();\n    \n    cin >> a >> b;\n    id[a] = id.size(); id[b] = id.size();\n    gas.push_back(1); gas.push_back(2);\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b >> d;\n      if(id.find(a) == id.end())id[a] = id.size();\n      if(id.find(b) == id.end())id[b] = id.size();\n      g[id[a]].push_back(P(d,id[b]));\n      g[id[b]].push_back(P(d,id[a]));\n    }\n    for(int i=0;i<=id.size();i++)isg[i] = false;\n    isg[1] = isg[2] = true;\n\n    for(int i=0;i<m;i++){\n      cin >> a;\n      gas.push_back(id[a]);\n      isg[id[a]] = true;\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<gas.size();j++)g2[i][j] = INF;\n      g2[i][i] = 0;\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<=id.size();j++)dis[j] = INF;\n      dis[gas[i]] = 0;\n      priority_queue<P,vector<P>,greater<P> > q;\n      q.push(P(0,gas[i]));\n      int cnt = 1;\n      while(q.size()){\n\tif(cnt==gas.size())break;\n\tP p = q.top();q.pop();\n\tint dist = p.first;\n\tint pos = p.second;\n\t\n\tfor(int x=0;x<g[pos].size();x++){\n\t  int tdis = dist + g[pos][x].first;\n\t  int nxt = g[pos][x].second;\n\t  if(dis[nxt] > tdis){\n\t    dis[nxt] = tdis;\n\t    q.push(P(tdis,nxt));\n\t    if(isg[nxt])cnt++;\n\t  }\n\t}\n      }\n      for(int j=0;j<gas.size();j++){\n\tif(cap*10<dis[gas[j]])continue;\n\tg2[i][j] = dis[gas[j]];\t\n      }\n    }\n\n    for(int k=0;k<gas.size();k++)\n      for(int i=0;i<gas.size();i++)\n\tfor(int j=0;j<gas.size();j++)\n\t  g2[i][j] = min(g2[i][j],g2[i][k] + g2[k][j]);\n\n    if(g2[0][1] == INF)cout << -1 << endl;\n    else cout << g2[0][1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\n#define pb push_back \n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\nusing namespace std;\ntypedef pair <int,int> P;\nint c;\nmap<string,int> city;\nvector<P> root[3010];\nbool sup[3010];\n\nstruct node{\n\tint cur,dis,cap;\n\tbool operator <(node a)const{\n    \treturn dis < a.dis;\n  \t}\n};\n\nint dijkstra(void){\n\tnode s;\n\ts.cur=0,s.dis=0,s.cap=c*10;\n\tpriority_queue<node> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tnode cur;\n\t\tcur=q.top();q.pop();\n\t\tint state=cur.cur;\n\t//\tcout << cur.cur << \" \" << cur.dis <<\" \" << cur.cap << endl;\n\t\tif(cur.cap < 0||cur.cap >c*10)\n\t\t\tcontinue;\n\t\tif(state==1)\n\t\t\treturn cur.dis;\n\t\tfor(int i=0;i<root[state].size();i++){\n\t\t\tnode next;\n\t\t\tif(cur.cap>=root[state][i].second){\n\t\t\t\tnext.cur=root[state][i].first;\n\t\t\t\tnext.dis=cur.dis+root[state][i].second;\n\t\t\t\tif(sup[next.cur])\n\t\t\t\t\tnext.cap=c*10;\n\t\t\t\telse\n\t\t\t\t\tnext.cap-=root[state][i].second;\n\t\t\t\tq.push(next);\n\t\t\t\t//cout << next.cur << \" \" << next.dis <<\" \" << next.cap << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m >> c,n|m|c){\n\t\tcity.erase( city.begin(), city.end() );\n\t\tfor(int i=0;i<6000;i++){\n\t\t\troot[i].erase(root[i].begin(),root[i].end());\n\t\t\tsup[i]=false;\n\t\t}\n\t\tstring src,dest;\n\t\tint cnum=2;\n\t\tcin >> src >> dest;\n\t\tcity[src]=0;\n\t\tcity[dest]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tcin >> f >> t;\n\t\t\tif(city.find(f)==city.end())\n\t\t\t\tcity[f]=cnum++;\n\t\t\tif(city.find(t)==city.end())\n\t\t\t\tcity[t]=cnum++;\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\tP next;\n\t\t\tnext.first=city[t];next.second=d;\n\t\t\troot[city[f]].pb(next);\n\t\t\tnext.first=city[f];next.second=d;\n\t\t\troot[city[t]].pb(next);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tsup[city[s]]=true;\n\t\t}\n\t\tint ans=dijkstra();\n\t\tcout << ans << endl;\n\t\t//cout << root[0][0].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF INT_MAX\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>f,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    f.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      f.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    //node.erase(unique(all(node)),node.end());\n    unique(all(node));\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[f[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst int mod = 1000000007;\nconst double PI = acos(-1.0); \n\n\n\nstruct P\n{\n\tint p, c, f;\n\tP(int p, int c, int f)\n\t\t: p(p), c(c), f(f) { }\n\n\tbool operator<(const P& b) const\n\t{\n\t\treturn c < b.c;\n\t}\n};\nint nono(map<string, int>& no, const string& s)\n{\n\tif (!no.count(s))\n\t{\n\t\tint t = no.size();\n\t\tno[s] = t;\n\t}\n\treturn no[s];\n}\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n)\n\t{\n\t\tcap *= 10;\n\n\t\tvector<vector<pint> > e(2 * n);\t// pint(cost, to)\n\t\tbool gas[3010];\n\t\tCL(gas, 0);\n\n\t\tmap<string, int> no;\n\t\tconst int src = 0, dest = 1;\n\n\t\t{\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b;\n\t\t\tno[a] = src, no[b] = dest;\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tint d;\n\t\t\t\tcin >> a >> b >> d;\n\t\t\t\tint x = nono(no, a), y = nono(no, b);\n\t\t\t\te[x].push_back(pint(d, y));\n\t\t\t\te[y].push_back(pint(d, x));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\tcin >> a, gas[nono(no, a)] = true;\n\t\t}\n\n\n\t\tconst int INF = 1 << 30;\n\t\tstatic int dis[3010][2010];\n\t\tfor (int i = 0; i < no.size(); ++i)\n\t\t\tfor (int j = 0; j <= cap; ++j)\n\t\t\t\tdis[i][j] = INF;\n\n\t\tpriority_queue<P> q;\n\t\tdis[src][cap] = 0;\n\t\tq.push(P(src, 0, cap));\n\n\t\tint res = -1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP cur = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = cur.p, c = cur.c, f = cur.f;\n\t\t\tif (c > dis[p][f])\n\t\t\t\tcontinue;\n\t\t\telse if (p == dest)\n\t\t\t{\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e[p].size(); ++i)\n\t\t\t{\n\t\t\t\tint to = e[p][i].second;\n\t\t\t\tint d = e[p][i].first;\n\t\t\t\tint nc = c + d;\n\t\t\t\tint nf = f - d;\n\t\t\t\tif (nf >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (gas[to])\n\t\t\t\t\t\tnf = cap;\n\t\t\t\t\tif (nc < dis[to][nf])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[to][nf] = nc;\n\t\t\t\t\t\tq.push(P(to, nc, nf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nstruct Edge {\n  int dst, dist;\n  Edge(int dst, int dist): dst(dst), dist(dist) {}\n};\n\nstruct State {\n  int city, rest, cost;\n  State(int city, int rest, int cost): city(city), rest(rest), cost(cost) {}\n  bool operator<(const State& rhs) const { return cost > rhs.cost; }\n};\n\ninline int add_name(map<string, int>& name2id, const string& name) {\n  if (name2id.count(name)) {\n    return name2id[name];\n  } else {\n    int id = name2id.size();\n    return name2id[name] = id;\n  }\n}\n\nconst int INF = 0x0f0f0f0f;\n\nvector<Edge> edges[6010];\nbool has_lpg[6010];\nbool visit[6010][2010];\nint cost[6010][2010];\n\nint main() {\n  int N, M, cap;\n  while (scanf(\"%d%d%d\", &N, &M, &cap), N|M|cap) {\n    map<string, int> name2id;\n    string src_name, dst_name;\n\n    memset(has_lpg, false, sizeof(has_lpg));\n    memset(visit, false, sizeof(visit));\n    memset(cost, INF, sizeof(cost));\n\n    cin >> src_name >> dst_name;\n    int src = add_name(name2id, src_name);\n    int dst = add_name(name2id, dst_name);\n    REP(i, N) {\n      int dist;\n      cin >> src_name >> dst_name >> dist;\n      int s = add_name(name2id, src_name);\n      int t = add_name(name2id, dst_name);\n      edges[s].push_back(Edge(t, dist));\n      edges[t].push_back(Edge(s, dist));\n    }\n    REP(i, M) {\n      cin >> src_name;\n      has_lpg[name2id[src_name]] = true;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(src, 10 * cap, 0));\n    cost[src][10 * cap] = 0;\n    while (!Q.empty()) {\n      int city = Q.top().city;\n      int rest = Q.top().rest;\n      Q.pop();\n\n      if (visit[city][rest]) { continue; }\n      visit[city][rest] = true;\n\n      FOREACH(it, edges[city]) {\n        int new_city = it->dst;\n        if (rest < it->dist) { continue; }\n        int new_rest = has_lpg[new_city] ? 10 * cap : rest - it->dist;\n        int new_cost = cost[city][rest] + it->dist;\n        if (new_cost >= cost[new_city][new_rest]) { continue; }\n        cost[new_city][new_rest] = new_cost;\n        Q.push(State(new_city, new_rest, new_cost));\n      }\n    }\n\n    int ans = *min_element(cost[dst], cost[dst] + 10 * cap);\n    cout << (ans < INF ? ans : -1) << endl;\n\n    REP(i, name2id.size()) { edges[i].clear(); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct edge{\n  int to, cost;\n};\nstruct S{\n  int d, p, g; // dist point gas\n};\nbool operator < (const S& s, const S& t){\n  return s.d > t.d;\n}\ntypedef vector<edge> edges;\n\nint getid(map<string, int>& ID, string s){\n  int m = ID.size();\n  if(ID.count(s))return ID[s];\n  else return (ID[s] = m);\n}\n\nint main(){\n  int N, M, cap;\n  while(cin>>N>>M>>cap && N){\n    cap *= 10;\n    map<string, int> ID;\n    string src, dest;\n    cin>>src>>dest;\n    int srcid = getid(ID, src);\n    int destid = getid(ID, dest);\n    vector<edges> g(6000);\n    REP(i, N){\n      string s1,s2;int c;\n      cin>>s1>>s2>>c;\n      int u = getid(ID, s1);\n      int v = getid(ID, s2);\n      g[u].push_back((edge){v, c});\n      g[v].push_back((edge){u, c});\n    }\n    bool gas[6000] = {};\n    REP(i, M){\n      string s; cin>>s;\n      gas[getid(ID, s)] = true;\n    }\n    bool used[6000][201] = {};\n    priority_queue<S> que;\n    que.push((S){0, srcid, cap});\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.p == destid){\n        cout<<s.d<<endl;\n        goto END;\n      }\n      if(used[s.p][s.g]) continue;\n      used[s.p][s.g] = true;\n      FORIT(it, g[s.p]){\n        if(it->cost <= s.g){\n          S next = (S){s.d + it->cost, it->to, (gas[it->to])?cap:(s.g - it->cost)};\n          que.push(next);\n        }\n      }\n    }\n    cout<<-1<<endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[5001];\nvector<edge> GG[5001];\nmap<string,int> city;\nint dp[5000];\nbool flag[5000];\n\nvoid make_path(int v){\n\tfill(dp,dp+n,cap+1);\n\tpriority_queue<data> que;\n\tque.push(edge(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t\tGG[q.t].push_back(edge(v,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(edge(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<30;\n\nstruct P{\n    int s1;\n    int s2;\n    int d;\n    P(){}\n    ~P(){}\n    P(int a, int b, int c) : s1(a), s2(b), d(c) {}\n    P(const P& r) : s1(r.s1), s2(r.s2), d(r.d) {}\n};\n\nstruct Q{\n    int pos;\n    int fuel;\n    int dist;\n    vector<int> visited;\n    Q(){}\n    ~Q(){}\n    Q(int p, int f, int d, vector<int> v) : pos(p), fuel(f), dist(d), visited(v) {}\n    Q(const Q& r) : pos(r.pos), fuel(r.fuel), dist(r.dist), visited(r.visited) {}\n};\n\ntypedef pair<int, int> PR;\n\nint main(){\n    int n, m, cap, x;\n    vector<int> EMPTY;\n    while(cin >> n >> m >> cap, n||m||cap){\n        string src, dest;\n        cin >> src >> dest;\n        map<string, int> name;\n        vector< vector<PR> > path(3000);\n        name[src] = 0;\n        name[dest] = 1;\n        int nn = 2;\n        string c1, c2;\n        int d;\n        vector<int> gs(n, 0);\n        for(x = 0; x < n; x++){\n            cin >> c1 >> c2 >> d;\n            if( name.find(c1) == name.end() ){\n                name[c1] = nn++;\n            }\n            if( name.find(c2) == name.end() ){\n                name[c2] = nn++;\n            }\n            path[name[c1]].push_back( PR(name[c2], d) );\n            path[name[c2]].push_back( PR(name[c1], d) );\n        }\n        for(x = 0; x < m; x++){\n            cin >> c1;\n            gs[ name[c1] ] = 1;\n        }\n        queue< Q > que;\n        que.push( Q(0, cap*10, 0, EMPTY) );\n        int mindist = INF;\n        while( !que.empty() ){\n            Q q = que.front();\n            que.pop();\n            for(vector<PR>::iterator nxt = path[q.pos].begin();\n                    nxt != path[q.pos].end(); nxt++){\n                if( nxt->second > q.fuel ){ continue; }\n                if( nxt->first == 1 ){\n                    if( q.dist+nxt->second < mindist ){ mindist = q.dist+nxt->second; }\n                    continue;\n                }\n                bool ok = true;\n                for(vector<int>::iterator itr = q.visited.begin();\n                        itr != q.visited.end(); itr++){\n                    if( *itr == nxt->first ){\n                        ok = false;\n                        break;\n                    }\n                }\n                if( !ok ) continue;\n                vector<int> nv = q.visited;\n                nv.push_back(q.pos);\n                if( gs[ nxt->first ] ){\n                    que.push( Q(nxt->first, cap*10, q.dist+nxt->second, nv) );\n                }else{\n                    que.push( Q(nxt->first, q.fuel - nxt->second, q.dist+nxt->second, nv) );\n                }\n            }\n        }\n        cout << ((mindist == INF) ? -1 : mindist) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  if(n>3000) return -1;\n  vector<vector<int> >D(n,vector<int>(cap+1,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[0][cap]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tint dis;\n\tint gas;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.gas> r.gas;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tcap *= 10;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tint num = 2;\n\t\tvector<vector<pair<int, int>>>edges(6000);\n\t\tstring sta, goa; cin >> sta >> goa; mp[sta] = 0; mp[goa] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring f, t; cin >> f >> t;\n\t\t\tint dis; cin >> dis;\n\t\t\tif (!mp.count(f)) {\n\t\t\t\tmp[f] = num++;\n\t\t\t}\n\t\t\tif (!mp.count(t)) {\n\t\t\t\tmp[t] = num++;\n\t\t\t}\n\t\t\tconst int fid = mp[f];\n\t\t\tconst int tid = mp[t];\n\t\t\tedges[fid].push_back(make_pair(tid, dis));\n\t\t\tedges[tid].push_back(make_pair(fid, dis));\n\t\t}\n\t\tedges.resize(mp.size());\n\t\tvector<bool>stat(edges.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\t\t\t\tstat[mp[st]] = true;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>mindiss(mp.size(), vector<int>(cap + 1, 99999999));\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,0,cap });\n\t\tmindiss[0][cap] = 0;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int pregas = atop.gas;\n\t\t\tconst int nowdis = atop.dis;\n\t\t\tif (atop.now == 1)break;\n\t\t\t\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (pregas >= i.second) {\n\t\t\t\t\tconst int newid = i.first;\n\t\t\t\t\tconst int newgas = stat[newid]?cap:atop.gas - i.second;\n\t\t\t\t\tconst int newdis = nowdis + i.second;\n\t\t\t\t\tif (mindiss[newid][newgas]> newdis) {\n\t\t\t\t\t\tmindiss[newid][newgas] = newdis;\n\t\t\t\t\t\tque.push(aa{ newid, newdis ,newgas });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\tfor (int i = 0; i < cap + 1; ++i) {\n\t\t\tans = min(mindiss[1][i], ans);\n\t\t}\n\t\tif (ans == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    if(dist == s.dist){\n      return consumed_LPG < s.consumed_LPG;\n    }\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    if(dist == s.dist){\n      return consumed_LPG > s.consumed_LPG;\n    }\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 2000) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tif(to == dst_id) break;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 2000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int v,r,d;\n};\n\nbool operator<(const state &a,const state &b){\n  return a.d > b.d;\n}\n\nint n,m,C;\nstring src,dst;\nint S,T;\nmap<string,int> idx;\nvector<P> g[300];\nbool aru[300];\nint dist[300][2010];\nint V=0;\n\nint getidx(string s){\n  if(idx.find(s)!=idx.end())return idx[s];\n  idx[s]=V++;\n  return idx[s];\n}\n\nint main(){\n  while(1){\n    cin>>m>>n>>C;\n    if(m==0&&n==0)break;\n\n    idx.clear();\n    rep(i,300)g[i].clear();\n    memset(aru,0,sizeof(aru));\n    V=0;\n\n    cin>>src>>dst;\n    S=getidx(src);\n    T=getidx(dst);\n    rep(i,m){\n      string a,b;\n      int d;\n      cin>>a>>b>>d;\n      g[getidx(a)].push_back(P(getidx(b),d));\n      g[getidx(b)].push_back(P(getidx(a),d));\n    }\n    rep(i,n){\n      string a;\n      cin>>a;\n      aru[getidx(a)]=true;\n    }\n\n    priority_queue<state> que;\n    que.push((state){S,C*10,0});\n    rep(i,300)rep(j,2010)dist[i][j]=INF;\n    while(que.size()){\n      state s=que.top(); \n      que.pop();\n      if(dist[s.v][s.r]!=INF)continue;\n      dist[s.v][s.r]=s.d;\n      for(P e : g[s.v]){\n        if(s.r<e.se)continue;\n        que.push((state){e.fi,s.r-e.se,s.d+e.se});\n      }\n      if(s.r<C*10&&aru[s.v]){\n        que.push((state){s.v,C*10,s.d});\n      }\n    }\n\n    int res=INF;\n    rep(j,2010)minch(res,dist[T][j]);\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst int NONE=-1;\n\nint main(){\n  int r,m,cap;\n  while(cin>>r>>m>>cap,r|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvi dist(2*r,vi(2*r,NONE));\n    vs cities;\n    REP(i,r){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai][bi]=d;\n      dist[bi][ai]=d;\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    int n=cities.size();\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(i,n){\n        if(i!=cnode.index&&dist[cnode.index][i]!=NONE){\n          ll newcost=cnode.cost+dist[cnode.index][i];\n          int newgas=cnode.gas-dist[cnode.index][i];\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N+1);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      assert(0 <= c1 && c1 <= N);\n      assert(0 <= c2 && c2 <= N);\n#if 0\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n  int to;\n  int cost;\n};\n\nint d[2001][6011];\nvector<edge> G[6011];\nbool isGas[10001];\nmap<string,int> m;\nint idx;\nint st,gl;\n\nint N,M,cap;\nconst int INF=1<<30;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> Sit;\n\nint dijkstra(){\n  for(int i=0;i<2001;i++)\n    for(int j=0;j<6011;j++)\n      d[i][j]=INF;\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  pq.push(make_pair(0,pii(cap*10,st)));\n  d[cap*10][st]=0;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int ccost=p.first;\n    int ccap=p.second.first;\n    int cnode=p.second.second;\n    if(d[ccap][cnode]<ccost)continue;\n    for(int i=0;i<(int)G[cnode].size();i++){\n      edge &e=G[cnode][i];\n      int ncap=ccap-e.cost;\n      if(ncap<0)continue;\n      int nnode=e.to;\n      int ncost=ccost+e.cost;\n      if(isGas[nnode])ncap=cap*10;\n      if(d[ncap][nnode]>ncost){\n\td[ncap][nnode]=ncost;\n\tpq.push(make_pair(ncost,pii(ncap,nnode)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<2001;i++)\n    res=min(res,d[i][gl]);\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>cap&&(N|M|cap)){\n    memset(isGas,0,sizeof(isGas));\n    for(int i=0;i<6011;i++)G[i].clear();\n    m.clear();\n    idx=0;\n    string s,t;\n    cin>>s>>t;\n    if(m.count(s)==0)m[s]=idx++;\n    if(m.count(t)==0)m[t]=idx++;\n    st=m[s];gl=m[t];\n    for(int i=0;i<N;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(m.count(a)==0)m[a]=idx++;\n      if(m.count(b)==0)m[b]=idx++;\n      int x,y;\n      x=m[a];y=m[b];\n      edge e;\n      e.to=y;\n      e.cost=c;\n      G[x].push_back(e);\n      e.to=x;\n      G[y].push_back(e);\n    }\n    for(int i=0;i<M;i++){\n      string s;\n      cin>>s;\n      if(m.count(s)==0)m[s]=idx++;\n      isGas[m[s]]=true;\n    }\n    int res=dijkstra();\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nmap<string,int>id;\nvector<string>v,from,to;\nvector<int>cost;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <memory.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 28;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){ };\n  edge(int to, int cost){\n    this->to = to;\n    this->cost = cost;\n  }\n};\nmap<string, int> names;\nint memo[4100][2100];\nbool LPG[4100];\nmap<int, vector<edge> > G;\n\nint main(){\n  int cnt;\n  int n, m, cap, d;\n  string src, dst;\n  string c1, c2, str;\n  while(cin >> n >> m >> cap && (n || m || cap)){\n    int res = INF;\n    cnt = 1;\n    cap *= 10;\n    cin >> src >> dst;\n\n    names.clear();\n    G.clear();\n    memset(LPG, 0, sizeof(LPG));\n    fill(&memo[0][0], &memo[0][0] + 4100 * 2100, INF);\n    \n    rep(i, n){\n      cin >> c1 >> c2 >> d;\n      if(!names[c1]) names[c1] = cnt++;\n      if(!names[c2]) names[c2] = cnt++;\n      G[names[c1]].push_back(edge(names[c2], d));\n      G[names[c2]].push_back(edge(names[c1], d));\n    }\n    rep(i, m){\n      cin >> str;\n      LPG[names[str]] = true;\n    }\n    int s = names[src];\n    int t = names[dst];\n    memo[s][cap] = 0;\n    priority_queue<state, vector<state>, greater<state> > que;\n    que.push(state(0, P(s, cap)));\n    while(!que.empty()){\n      state st = que.top(); que.pop();\n      int cost = st.first;\n      int pos = st.second.first;\n      int tank = st.second.second;\n      if(cost > memo[pos][tank]) continue;\n      if(pos == t) res = min(res, cost);\n      rep(i, (int)G[pos].size()){\n\tint need = G[pos][i].cost;\n\tint nxt = G[pos][i].to;\n\t\n\tif(tank - need >= 0){\n\t  int ntank = LPG[nxt] ? cap : tank - need;\n\t  if(memo[nxt][ntank] > cost + need){\n\t    memo[nxt][ntank] = cost + need;\n\t    que.push(state(cost + need, P(nxt, ntank)));\n\t  } \n\t}\n      }\n    }\n    if(res == INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 6001\n#define INF 1e9\n \nstruct State{\n    int dist,v,cap;\n    State(int dist,int v,int cap) \n\t: dist(dist),v(v),cap(cap) {}\n \n    bool operator > (const State &s)const{\n\treturn dist > s.dist;\n    }\n};\n \nstruct Edge{\n    int to,dist;\n    Edge(int to,int dist) : to(to),dist(dist) {}\n};\n \nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n \nvoid init(){\n    idx = 1;\n    LPG.clear();\n    for(int i = 0 ; i < MAX ; i++){\n\tG[i].clear();\n    }\n}\n \nint dijkstra(){\n    vector<vector<int> > dist(idx);\n    cap *= 10;\n  \n    for(int i = 0 ; i < idx ; i++){\n\tdist[i].resize(cap+1);\n\tfor(int j = 0 ; j <= cap ; j++){\n\t    dist[i][j] = INF;\n\t}\n    }\n \n    dist[src][cap] = 0;\n \n    priority_queue<State,vector<State>,greater<State> > Q;\n    Q.push(State(0,src,cap));\n \n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint v = s.v,c = s.cap;\n     \n\tif(dist[v][c] < s.dist) continue;\n     \n\tif(v == dst){\n\t    return dist[v][c];\n\t}\n \n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    Edge e = G[v][i];\n\t    int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n\t    if(e.dist <= nc){\n\t\tnc -= e.dist;\n\t\tif(dist[v][c] + e.dist < dist[e.to][nc]){\n\t\t    dist[e.to][nc] = dist[v][c] + e.dist;\n\t\t    Q.push(State(dist[e.to][nc],e.to,nc));\n\t\t}                           \n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    int d;\n    string a,b;\n   \n    while(cin >> N >> M >> cap, N){\n\tinit();\n\tmap<string,int> mp; \n\tcin >> a; mp[a] = src = idx++; \n\tcin >> a; mp[a] = dst = idx++; \n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> a >> b >> d;\n\t    if(mp.find(a) == mp.end()){\n\t\tmp[a] = idx++;\n\t    }\n\t    if(mp.find(b) == mp.end()){\n\t\tmp[b] = idx++;\n\t    }\n\t    G[mp[a]].push_back(Edge(mp[b],d));\n\t    G[mp[b]].push_back(Edge(mp[a],d));\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a;\n\t    LPG.insert(mp[a]);\n\t}\n\tcout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Edge {\n  int dest;\n  int cost;\n  Edge(int dest, int cost) : dest(dest), cost(cost) {;}\n  bool operator<(const Edge &rhs) const { return cost > rhs.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nint n;\nint e, m, cap;\nbool lgp[6010];\nchar str1[1000];\nchar str2[1000];\nmap<string, int> mapto;\n\nbool visit[2001][6001];\n//int dist[2010][6010];\n\nint Push(const char* str) {\n  if (!mapto.count(str)) {\n    mapto[str] = n++;\n    g.push_back(Edges());\n  }\n  return mapto[str];\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &e, &m, &cap), e|m|cap) {\n    n = 0;\n    cap *= 10;\n    g.clear();\n    MEMSET(lgp, false);\n    mapto.clear();\n    scanf(\"%s %s\", str1, str2);\n    int start = Push(str1);\n    int end = Push(str2);\n    REP(i, e) {\n      int d;\n      scanf(\"%s %s %d\", str1, str2, &d);\n      int l = Push(str1);\n      int r = Push(str2);\n      g[l].push_back(Edge(r, d));\n      g[r].push_back(Edge(l, d));\n    }\n    REP(i, m) {\n      scanf(\"%s\", str1);\n      int v = Push(str1);\n      lgp[v] = true;\n    }\n\n    MEMSET(visit, false);\n    //MEMSET(dist, 0x0f);\n    priority_queue<pair<Edge, int> > que;\n    que.push(make_pair(Edge(start, 0), cap));\n    while (!que.empty()) {\n      Edge e = que.top().first;\n      int rest = que.top().second;\n      que.pop();\n      int from = e.dest;\n      if (lgp[from]) { rest = cap; }\n      if (visit[rest][from]) { continue; }\n      visit[rest][from] = true;\n      if (from == end) {\n        printf(\"%d\\n\", e.cost);\n        goto next;\n      }\n      FORIT(it, g[from]) {\n        int to = it->dest;\n        int ncost = e.cost + it->cost;\n        int nrest = rest - it->cost;\n        if (nrest < 0 || visit[nrest][to]/* || ncost >= dist[nrest][to]*/) { continue; }\n        //dist[nrest][to] = ncost;\n        que.push(make_pair(Edge(to, ncost), nrest));\n      }\n    }\n    puts(\"-1\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n\nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  vector<int> dist[idx];\n  cap *= 10;\n \n  for(int i = 0 ; i < idx ; i++){\n    dist[i].resize(cap+1);\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint N, M, cap;\n\nusing Graph = vector< vector< pair<int, int> > >;\n\nconst int INF = 1 << 29;\nint dist[3010][2010];\n\nstruct Elem {\n    int pos, tot, cost;\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n\n\nint solve(Graph &G, vector<int>& is_station, int S, int T) {\n    fill(dist[0], dist[3010], INF);\n    dist[S][0] = 0;\n\n    priority_queue<Elem> que;\n    que.push(Elem{S, 0, 0});\n\n    while(que.size()) {\n        Elem cur = que.top(); que.pop();\n\n        int u = cur.pos, pre_tot = cur.tot, pre_cost = cur.cost;\n        if(dist[u][pre_tot] < pre_cost) continue;\n\n        for(auto e : G[u]) {\n            int v = e.first, cost = e.second;\n\n            int nxt_cost = pre_cost + cost;\n            int nxt_tot  = pre_tot  + cost;\n            if(nxt_tot > cap) continue;\n            if(is_station[v]) nxt_tot = 0;\n\n            if(dist[v][nxt_tot] > nxt_cost) {\n                dist[v][nxt_tot] = nxt_cost;\n                que.push(Elem{v, nxt_tot, nxt_cost});\n            }\n        }\n    }\n\n    int ret = *min_element(dist[T], dist[T] + cap + 1);\n    return (ret == INF ? -1 : ret);\n}\n\nint main() {\n    while(cin >> N >> M >> cap, N) {\n        cap *= 10;\n        string st, gl; cin >> st >> gl;\n\n        vector<string> u(N), v(N);\n        vector<int> d(N);\n\n        map<string, int> to_int_id;\n        for(int i=0; i<N; i++) {\n            cin >> u[i] >> v[i] >> d[i];\n            to_int_id[ u[i] ]++;\n            to_int_id[ v[i] ]++;\n        }\n\n        int id = 0;\n        for(auto &e : to_int_id) {\n            e.second = id++;\n        }\n\n        Graph G(id);\n        for(int i=0; i<N; i++) {\n            int x = to_int_id[ u[i] ];\n            int y = to_int_id[ v[i] ];\n            G[x].push_back(make_pair(y, d[i]));\n            G[y].push_back(make_pair(x, d[i]));\n        }\n\n        vector<int> is_station(id);\n        for(int i=0; i<M; i++) {\n            string s; cin >> s;\n            int s_id = to_int_id[s];\n\n            is_station[s_id] = true;\n        }\n\n        int start_v = to_int_id[st];\n        int goal_v  = to_int_id[gl];\n        cout << solve(G, is_station, start_v, goal_v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    dp[get_city_id(cities,src)][10*capacity] = true;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\tdp[to][next_remaining_LPG] = true;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nmap<int, string> num2city;\nset<int> LPG;\n\nvector<pair<int, int>> G[3010];\nint dist[3010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 3010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(), num2city.clear(), LPG.clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\t\tstring c1[3010], c2[3010];\n\t\tint d[3010];\n\t\tstring s[3010];\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto u : city) {\n\t\t\tcity2num[u] = cnt;\n\t\t\tnum2city[cnt] = u;\n\t\t\tcnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tdijkstra(city2num[src], cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[city2num[dest]][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 1000000000\n\nint d[310];\nint dist[310][310];\nint dp2[310][6010];\nvector<int> st;\nvector<int> e[10010];\nvector<int> c[10010];\nmap<string,int> id;\nint n,m,cap;\nint to[310];\nint from[310];\nbool is[6010];\nint wh[6010];\n\n\nvoid solve(int x) {\n\tfor (int i=0; i<n; i++) dp2[x][i] = INF;\n\tfor (int i=0; i<m; i++) dist[wh[x]][i] = INF;\n\tto[wh[x]] = INF;\n\tfrom[wh[x]] = INF;\n\tdp2[x][x] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,x));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (is[p] && cur<=cap) {\n\t\t\tdist[wh[x]][wh[p]] = cur;\n\t\t}\n\t\tif (p==0) from[wh[x]] = cur;\n\t\tif (p==1) to[wh[x]] = cur;\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[x][u] > w + dp2[x][p]) {\n\t\t\t\tdp2[x][u] = w + dp2[x][p];\n\t\t\t\tq.push(make_pair(-dp2[x][u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint solve2() {\n\tfor (int i=0; i<n; i++) dp2[0][i] = INF;\n\n\tdp2[0][0] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,0));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (p==1) {\n\t\t\treturn cur;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[0][u] > w + dp2[0][p]) {\n\t\t\t\tdp2[0][u] = w + dp2[0][p];\n\t\t\t\tq.push(make_pair(-dp2[0][u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INF;\n}\n\t\t\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&n,&m,&cap) && n!=0) {\n\t\tid.clear();\n\t\tcap *= 10;\n\t\tfor (int i=0; i<2*n; i++) e[i].clear();\n\t\tint cnt = 2;\n\t\tst.clear();\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tid[src] = 0;\n\t\tid[dest] = 1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tstring s1,s2;\n\t\t\tcin>>s1>>s2;\n\t\t\tif (id.find(s1)==id.end()) id[s1] = cnt++;\n\t\t\tif (id.find(s2)==id.end()) id[s2] = cnt++;\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\te[id[s1]].push_back(id[s2]);\n\t\t\te[id[s2]].push_back(id[s1]);\n\t\t\tc[id[s1]].push_back(h);\n\t\t\tc[id[s2]].push_back(h);\n\t\t}\n\t\tfor (int i=0; i<2*n; i++) is[i] = 0;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif (id.find(s)==id.end()) continue;\n\t\t\tst.push_back(id[s]);\n\t\t\tis[id[s]] = 1;\n\t\t\twh[id[s]] = i;\n\t\t}\n\t\tn = cnt;\n\t\t\n\t\tfor (int i=0; i<st.size(); i++) {\n\t\t\tsolve(st[i]);\n\t\t}\n\t\t\n\t\t//for (int i=0; i<m; i++) {\n\t\t//\tfor (int j=0; j<m; j++) cout<<dist[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t\n\t\tint ans = solve2();\n\t\t\n\t\tif (ans>cap) ans = INF;\n\t\t\n\t\tfor (int k=0; k<m; k++) for (int i=0; i<m; i++) for (int j=0; j<m; j++) \n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tfor (int i=0; i<m; i++) for (int j=0; j<m; j++) {\n\t\t\tif (from[i]<=cap && to[i]>=cap) {\n\t\t\t\tans = min(ans, from[i] + to[i] + dist[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans==INF) cout<<-1<<endl; \n\t\telse cout<<ans<<endl;\n\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nshort dist[6000][6000];\nshort cost[6000][2001];\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tset<string> cities;\n\t\tvector<vs> data(N, vs(3)); \n\t\tREP(i, N) {\n\t\t\tREP(j, 2) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tcities.insert(data[i][j]);\n\t\t\t}\n\t\t\tcin >> data[i][2];\n\t\t}\n\n\t\tmap<string, int> index;\n\t\tset<string>::iterator it = cities.begin();\n\t\tint size = 0;\n\t\twhile(it != cities.end()) {\n\t\t\tindex[*it] = size;\n\t\t\tsize++;\n\t\t\tit++;\n\t\t}\n\n\t\t//vvs dist(size, vsh(size, INF));\n\t\tREP(i, size) {\n\t\t\tREP(j, size) {\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\t//vvs cost(size, vsh(cap*10+1, INF));\n\t\tREP(i, size) {\n\t\t\tREP(j, cap*10+1) {\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d][ng]) {\n\t\t\t\t\t\tcost[d][ng] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#define mod 1000000007\n#define INF 1<<30\n#define eps 1e-10\nusing namespace std;\nint n,m,cap,tot;\nmap<string,int> mm;\nchar s[20],t[20];\nchar s1[20],t1[20];\nbool flag[6002];\nint s2,t2;\nstruct node\n{\n    short t,ti;\n};\nstruct state\n{\n    short vex,ca;\n};\nvector<node> ve[6002];\nint dp[6002][2020];\nbool vis[6002][2020];\nbool operator < (const state& a,const state& b)\n{\n    return dp[a.vex][a.ca]<dp[b.vex][b.ca];\n}\n\nvoid dijkstra(int s,int t)\n{\n    priority_queue<state> q;\n    for(int i=1;i<tot;i++)\n    for(int j=0;j<=cap;j++) {dp[i][j]=INF;vis[i][j]=0;}\n    dp[s][cap]=0;state ss;ss.vex=s;ss.ca=cap;q.push(ss);\n    while(!q.empty())\n    {\n        ss=q.top();q.pop();\n        if(vis[ss.vex][ss.ca]) continue;\n        //cout<<ss.vex<<\" \"<<ss.ca<<\" \"<<dp[ss.vex][ss.ca]<<endl;\n        if(ss.vex==t) return;\n        vis[ss.vex][ss.ca]=1;\n        for(int i=0;i<ve[ss.vex].size();i++)\n        {\n            node no=ve[ss.vex][i];\n            if(ss.ca<no.ti) continue;\n            int cc=ss.ca-no.ti;\n            if(flag[no.t]) cc=cap;\n            if(dp[ss.vex][ss.ca]+no.ti<dp[no.t][cc])\n            {\n                dp[no.t][cc]=dp[ss.vex][ss.ca]+no.ti;\n                state ss2;ss2.vex=no.t;ss2.ca=cc;\n                q.push(ss2);\n            }\n        }\n    }\n}\nmain()\n{\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&n,&m,&cap),n+m+cap)\n    {\n        tot=1;int dd;cap*=10;\n        scanf(\"%s%s\",s1,t1);\n        memset(ve,0,sizeof(ve));\n        memset(flag,0,sizeof(flag));\n        mm.clear();\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%s%s%d\",s,t,&dd);int ss,tt;\n            if(mm[s]==0)\n            {\n                mm[s]=tot++;ss=tot-1;\n            }\n            else\n            ss=mm[s];\n            if(mm[t]==0)\n            {\n                mm[t]=tot++;tt=tot-1;\n            }\n            else\n            tt=mm[t];\n            node no;no.t=tt;no.ti=dd;ve[ss].push_back(no);\n            no.t=ss;ve[tt].push_back(no);\n        }\n        s2=mm[s1];t2=mm[t1];\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%s\",s);flag[mm[s]]=1;\n        }\n        dijkstra(s2,t2);\n        int ans=INF;\n        for(int i=0;i<=cap;i++)\n        ans=min(ans,dp[t2][i]);\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n  \tvis[v][p.s.s]=true;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n      if(nc>=0 && !vis[e.to][nc]){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[v][p.s.s]>=INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)){int k=ms.size();ms[a]=k;}\n      if(!ms.count(b)){int k=ms.size();ms[b]=k;}\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[i][j]=dp[i][ms[vs[j]]];\n\telse e[i][j]=inf*(i!=j);\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF INT_MAX\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>f,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    f.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      f.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[f[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nvector<pair<int, int> > E[6010];\nset<int> gas;\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tint idx = 0;\n\t\tmap<string, int> m;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tm[src] = 0; m[dest] = 1;\n\t\tidx = 2;\n\n\t\trep(i, 0, 6010) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\t\tint dd; cin >> dd;\n\t\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t\t}\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\t\tgas.insert(m[s]);\n\t\t}\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[3001][3001];\nbool is_LPG[3001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nvector<pair<int,int> > v[6001];\nbool sta[6001];\nint dp[6001][2001];\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2+1;i++){\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(mp(M[b],c));\n      v[M[b]].push_back(mp(M[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(sta[u.n])u.a=cap;\n      bool flag=true;\n      for(int i=c;i<=cap;i++){\n\tif(dp[u.n][i]<u.dis)flag=false;\n      }\n\n      if(!flag)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tbreak;\n      }\n\n      for(int i=0;i<v[u.n].size();i++){\n\tif(v[u.n][i].s<=u.a){\n\t  int sum1=u.dis+v[u.n][i].s,sum2=u.a-v[u.n][i].s;\n\t  if(sum1<dp[v[u.n][i].f][sum2]){\n\t    dp[v[u.n][i].f][sum2]=sum1;\n\t    pq.push(State(v[u.n][i].f,sum2,sum1));\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(N, vi(cap + 1, inf));\n\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        int res = inf;\n        for(auto & e : min_dist[t]){\n            chmin(res, e);\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Edge {\n  int dest;\n  int cost;\n  Edge(int dest, int cost) : dest(dest), cost(cost) {;}\n  bool operator<(const Edge &rhs) const { return cost > rhs.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nint n;\nint e, m, cap;\nbool lgp[6010];\nchar str1[1000];\nchar str2[1000];\nmap<string, int> mapto;\n\nbool visit[2010][6010];\nint dist[2010][6010];\n\nint Push(const char* str) {\n  if (!mapto.count(str)) {\n    mapto[str] = n++;\n    g.push_back(Edges());\n  }\n  return mapto[str];\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &e, &m, &cap), e|m|cap) {\n    n = 0;\n    cap *= 10;\n    g.clear();\n    MEMSET(lgp, false);\n    mapto.clear();\n    scanf(\"%s %s\", str1, str2);\n    int start = Push(str1);\n    int end = Push(str2);\n    REP(i, e) {\n      int d;\n      scanf(\"%s %s %d\", str1, str2, &d);\n      int l = Push(str1);\n      int r = Push(str2);\n      g[l].push_back(Edge(r, d));\n      g[r].push_back(Edge(l, d));\n    }\n    REP(i, m) {\n      scanf(\"%s\", str1);\n      int v = Push(str1);\n      lgp[v] = true;\n    }\n\n    MEMSET(visit, false);\n    MEMSET(dist, 0x0f);\n    priority_queue<pair<Edge, int> > que;\n    que.push(make_pair(Edge(start, 0), cap));\n    while (!que.empty()) {\n      Edge e = que.top().first;\n      int rest = que.top().second;\n      que.pop();\n      int from = e.dest;\n      if (lgp[from]) { rest = cap; }\n      if (visit[rest][from]) { continue; }\n      visit[rest][from] = true;\n      if (from == end) {\n        printf(\"%d\\n\", e.cost);\n        goto next;\n      }\n      FORIT(it, g[from]) {\n        int to = it->dest;\n        int ncost = e.cost + it->cost;\n        int nrest = rest - it->cost;\n        if (nrest < 0 || visit[nrest][to] || ncost >= dist[nrest][to]) { continue; }\n        dist[nrest][to] = ncost;\n        que.push(make_pair(Edge(to, ncost), nrest));\n      }\n    }\n    puts(\"-1\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nshort n, m, k, p, dist[6007][2017], c[3000]; bool u[3000];\nvector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<short, short, short>, vector<tuple<short, short, short>>, greater<tuple<short, short, short>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nbool visit[6001][2001];\nvector<pii> edge[6001];\nvector<int> mst;\nstruct node {\n\tint id, cap, dist;\n\tnode(int i, int c, int d) {\n\t\tid = i;\n\t\tcap = c;\n\t\tdist = d;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.dist > rhs.dist;\n}\n\nint main() {\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n and m and cap) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmst.clear();\n\t\tcap *= 10;\n\t\tmap<string, int> mp;\n\t\trep(i, 2*n) edge[i].clear();\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\trep(i, n) {\n\t\t\tstring a, b;\n\t\t\tint d;\n\t\t\tcin >> a >> b >> d;\n\t\t\tif( mp.find(a) == mp.end() ) mp[a] = mp.size();\n\t\t\tif( mp.find(b) == mp.end() ) mp[b] = mp.size();\n\t\t\tedge[ mp[a] ].push_back(pii(mp[b], d));\n\t\t\tedge[ mp[b] ].push_back(pii(mp[a], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tmst.push_back(mp[s]);\n\t\t}\n\t\tsort(mst.begin(), mst.end());\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], cap, 0) );\n\t\tbool found = false;\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[ nd.id ][ nd.cap ] ) continue;\n\t\t\tvisit[nd.id][nd.cap] = true;\n\t\t\tif( nd.id == mp[goal] ) {\n\t\t\t\tcout << nd.dist << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( binary_search(mst.begin(), mst.end(), nd.id) and !visit[nd.id][cap] ) {\n\t\t\t\tque.push( node(nd.id, cap, nd.dist) );\n\t\t\t}\n\t\t\trep(i, edge[nd.id].size()) {\n\t\t\t\tpii p = edge[nd.id][i];\n\t\t\t\tif( nd.cap >= p.second && !visit[p.first][nd.cap-p.second] ) {\n\t\t\t\t\tque.push( node(p.first, nd.cap-p.second, nd.dist + p.second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6001];\nstring city[6001];\nchar gs[6001];\nint dist[2001][6001];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n\n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap) continue;\n      int tar = max(cap-e.d, gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n\n    rep(i,3005) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    C *= 10;\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n\n    rep(i,M){\n      string s;  cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    dijkstra(recity[src]);\n\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=p.s.s;\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[v][p.s.s]==INF || ( d[e.to][nc] > d[v][p.s.s]+e.cost)){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \t//if(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[301];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nconst int max_n = 6001;\n\nint s_n, m; int c;\nmap<string, int> mp;\nint n = 2;\nint to_id(const string &s) {\n\tif (mp[s])return mp[s];\n\telse {\n\t\tn++; mp[s] = n; return n;\n\t}\n}\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[max_n];\nvector<edge> trueG[max_n];\nint d[max_n];\nvoid init(int s) {\n\trep1(i, n) {\n\t\td[i] = mod;\n\t}\n\td[s] = 0;\n}\nbool needed[max_n];\n\npriority_queue<P,vector<P>,greater<P>> q;\nvoid dijkstra(int sta) {\n\tinit(sta);\n\tq.push({ 0,sta });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\trep(j, G[v].size()) {\n\t\t\tint to = G[v][j].to;\n\t\t\tif (p.first + G[v][j].cost < d[to]) {\n\t\t\t\td[to] = p.first + G[v][j].cost;\n\t\t\t\tq.push({ d[to],to });\n\t\t\t}\n\t\t}\n\t}\n\trep1(i, n) {\n\t\tif (i == sta)continue;\n\t\tif (!needed[i])continue;\n\t\tif (d[i] <= 10 * c) {\n\t\t\ttrueG[sta].push_back({ i,d[i] });\n\t\t}\n\t}\n}\nvoid all_init() {\n\trep1(i, n) {\n\t\tG[i].clear();\n\t\ttrueG[i].clear();\n\t\tneeded[i] = false;\n\t}\n\tmp.clear();\n\tn = 2;\n}\nint main() {\n\twhile (cin >> m >> s_n >> c,m) {\n\t\tall_init();\n\t\tstring in1, in2;\n\t\tcin >> in1 >> in2;\n\t\tmp[in1] = 1; mp[in2] = 2;\n\t\trep(i, m) {\n\t\t\tint z;\n\t\t\tcin >> in1 >> in2 >> z;\n\t\t\tint i1 = to_id(in1), i2 = to_id(in2);\n\t\t\tG[i1].push_back({ i2,z });\n\t\t\tG[i2].push_back({ i1,z });\n\t\t}\n\t\tneeded[1] = needed[2] = true;\n\t\trep(i, s_n) {\n\t\t\tcin >> in1;\n\t\t\tneeded[to_id(in1)] = true;\n\t\t}\n\t\trep1(i, n)if (needed[i])dijkstra(i);\n\t\tinit(1);\n\t\tq.push({ 0,1 });\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\trep(j, trueG[v].size()) {\n\t\t\t\tint to = trueG[v][j].to;\n\t\t\t\tint cost = p.first + trueG[v][j].cost;\n\t\t\t\tif (cost < d[to]) {\n\t\t\t\t\td[to] = cost;\n\t\t\t\t\tq.push({ d[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[2] == mod)cout << -1 << endl;\n\t\telse cout << d[2] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nvector<pair<int, int> > E[6010];\nbool LPF[6010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\trep(i, 0, 10000) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 10000) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define INF (1<<28)\n#define MAX_N 3005\n#define MAX_L 2005\nstruct state{\n  int pos,pos2,cost;\n  bool operator < ( const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint n,m,l,cnt;\nstring si,ti,str;\nvector<edge> G[MAX_N];\nbool flg[MAX_N];\nmap<string,int> change;\n\nint d[MAX_N][MAX_L];\n\nint solve(int si,int ti){\n  for(int i=0;i<cnt;i++)\n    for(int j=0;j<=l*10;j++)\n      d[i][j]=INF;\n  d[1][l*10]=0;\n  priority_queue< state > Q;\n  Q.push((state){si,l*10,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.pos==ti)return s.cost;\n    if(s.cost>d[s.pos][s.pos2])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      int ncost=s.cost+e.cost;\n      int npos=e.to;\n      int npos2=s.pos2-e.cost;\n      if(npos2<0)continue;\n      \n      if(flg[npos])npos2=l*10;\n      if(ncost<d[npos][npos2]){\n        d[npos][npos2]=ncost;\n        Q.push((state){npos,npos2,ncost});\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  change.clear();\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    flg[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l;\n    if(n==0&&m==0&&l==0)break;\n    cin>>si>>ti;\n    init();\n    cnt=1;\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int a=change[str];\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int b=change[str];\n      int c;\n      cin>>c;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<m;i++){\n      cin>>str;\n      flg[change[str]]=true;\n    }\n    cout<<solve(change[si],change[ti])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<queue>\n#define MAX_V 6005\n#define MAX_C 2000\n#define INF 0x7fffffff\nusing namespace std;\n\nmap<string, int> mp;\n\nstruct edge\n{\n\tint to, cost;\n\tedge(int t, int c)\n\t{\n\t\tto = t; cost = c;\n\t}\n};\n\nstruct node\n{\n\tint id, ca;\n\tnode(int i, int c)\n\t{\n\t\tid = i; ca = c;\n\t}\n};\n\nvector<edge> G[MAX_V];\nint scr, dest;\nint ans = INF;\nint V, E, dp[MAX_V][MAX_C], cap;\nbool inQue[MAX_V][MAX_C], LPG[MAX_V];\nstring stringS, stringT;\nqueue<node> que;\n\nvoid ini()\n{\n\tans = INF;\n\tfor (int i = 0; i <= 2 * E + 2; i++)\n\t\tG[i].clear();\n\tcap *= 10;\n\tfor (int i = 0; i <= 2 * E; i++)\n\t\tfor (int j = 0; j <= cap + 5; j++)\n\t\t\tdp[i][j] = INF;\n\tmp.clear();\n\tmemset(inQue, 0, sizeof(inQue));\n\tmemset(LPG, 0, sizeof(LPG));\n\twhile (!que.empty())que.pop();\n}\n\nvoid spfa()\n{\n\tque.push(node(scr, cap));\n\tinQue[scr][cap] = 1;\n\tdp[scr][cap] = 0;\n\twhile (!que.empty())\n\t{\n\t\tnode now = que.front();\n\t\tque.pop();\n\t\tint u = now.id, ca = now.ca;\n\t\tinQue[u][ca] = 0;\n\t\tfor (int i = 0; i < G[u].size(); i++)\n\t\t{\n\t\t\tint v = G[u][i].to, c = G[u][i].cost;\n\t\t\tif (dp[u][ca] != INF&&ca - c >= 0 && LPG[v] && dp[v][cap]>dp[u][ca] + c)\n\t\t\t{\n\t\t\t\tdp[v][cap] = dp[u][ca] + c;\n\t\t\t\tif (!inQue[v][cap])\n\t\t\t\t{\n\t\t\t\t\tinQue[v][cap] = 1;\n\t\t\t\t\tque.push(node(v, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (dp[u][ca] != INF&&ca - c >= 0 && dp[v][ca - c] > dp[u][ca] + c)\n\t\t\t{\n\t\t\t\tdp[v][ca - c] = dp[u][ca] + c;\n\t\t\t\tif (!inQue[v][ca - c])\n\t\t\t\t{\n\t\t\t\t\tinQue[v][ca - c] = 1;\n\t\t\t\t\tque.push(node(v, ca - c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= cap; i++)\n\t\tans = min(ans, dp[dest][i]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &E, &V, &cap))\n\t{\n\t\tint tot = 0;\n\t\tini();\n\t\tif (E + V + cap == 0)\n\t\t\tbreak;\n\t\tchar str1[20], str2[20];\n\t\tscanf(\"%s%s\", str1, str2);\n\t\tstringS = str1; stringT = str2;\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tstring t1, t2;\n\t\t\tint d;\n\t\t\tscanf(\"%s%s%d\", str1, str2, &d);\n\t\t\tt1 = str1; t2 = str2;\n\t\t\tif (mp[t1] == 0)\n\t\t\t\tmp[t1] = ++tot;\n\t\t\tif (mp[t2] == 0)\n\t\t\t\tmp[t2] = ++tot;\n\t\t\tint u = mp[t1], v = mp[t2];\n\t\t\tG[u].push_back(edge(v, d));\n\t\t\tG[v].push_back(edge(u, d));\n\t\t}\n\t\tscr = mp[stringS], dest = mp[stringT];\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tstring temp;\n\t\t\tscanf(\"%s\", str1);\n\t\t\ttemp = str1;\n\t\t\tLPG[mp[temp]] = 1;\n\t\t}\n\t\tspfa();\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct Edge{\n  int cost, from, to;\n  Edge(int cost, int from, int to):\n    cost(cost), from(from), to(to) {}\n};\n\nbool operator<(const Edge& a, const Edge& b){\n  return a.cost != b.cost ? a.cost < b.cost : a.from != b.from ? a.from < b.from : a.to < b.to;\n}\n\nint dijkstra(const vector< vector< pair<int,int> > > &G,\n             const vector<bool> &is_lpg_station, int cap, int s, int g){\n  int n = G.size();\n  vector< pair<int,int> > D(n,make_pair(INF,cap));\n  priority_queue<Edge> wait;\n  wait.push(Edge(0,cap,s));\n  while(!wait.empty()){\n    Edge e = wait.top();\n    wait.pop();\n    int d = -e.cost, c = e.from, v = e.to;\n    if(d > D[v].first && c < D[v].second){\n      continue;\n    }else{\n      if(d < D[v].first) D[v] = make_pair(d,c);\n      if(d == D[v].first && D[v].second < c) D[v].second = c;\n    }\n    for(int i = 0; i < G[v].size(); ++i){\n      int d_ = G[v][i].first, v_ = G[v][i].second;\n      if(d_ <= c && d + d_ < D[v_].first){\n        D[v_].first = d + d_;\n        D[v_].second = c;\n        if(is_lpg_station[v_]) wait.push(Edge(-d-d_,cap,v_));\n        else wait.push(Edge(-d-d_,c-d_,v_));\n      }else if(d_ <= c && d + d_ == D[v_].first){\n        if(c - d_ > D[v_].second){\n          D[v_].second = c - d_;\n          wait.push(Edge(-d-d_,c-d_,v_));\n        }\n      }else if(c - d_ > D[v_].second){\n        if(is_lpg_station[v_]) wait.push(Edge(-d-d_,cap,v_));\n        else wait.push(Edge(-d-d_,c-d_,v_));\n      }\n    }\n  }\n  return D[g].first;\n}\n\nint main(){\n  int N, M, cap;\n  while(cin >> N >> M >> cap, N){\n    string src, dest;\n    cin >> src >> dest;\n    map<string,int> mp;\n    vector<string> C1(N), C2(N);\n    vector<int> D(N);\n    int t = 1;\n    for(int i = 0; i < N; ++i){\n      cin >> C1[i] >> C2[i] >> D[i];\n      if(!mp[C1[i]]){\n        mp[C1[i]] = t;\n        ++t;\n      }\n      if(!mp[C2[i]]){\n        mp[C2[i]] = t;\n        ++t;\n      }\n    }\n    int n = mp.size();\n    /*\n      for(auto itr = mp.begin(); itr != mp.end(); ++itr){\n      cout << itr->first << \" \" << itr->second << endl;\n      }\n    */\n    vector< vector< pair<int,int> > > G(n);\n    for(int i = 0; i < N; ++i){\n      int u = mp[C1[i]] - 1, v = mp[C2[i]] - 1, d = D[i];\n      G[u].push_back(make_pair(d,v));\n      G[v].push_back(make_pair(d,u));\n    }\n    string S;\n    vector<bool> is_lpg_station(n, false);\n    for(int i = 0; i < M; ++i){\n      cin >> S;\n      is_lpg_station[mp[S]-1] = true;\n    }\n    int s = mp[src] - 1, g = mp[dest] - 1, \n      ans = dijkstra(G, is_lpg_station, cap*10, s, g);\n    if(ans >= INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int V = 6010;\nconst int E = 3010;\nint n, m, cap;\n\nstruct dot{\n\tint p, oil;\n}front, rear;\n\nstruct edge{\n\tint to, w;\n};\n\nvector<edge> G[V];\nchar s1[20], s2[20];\n\nvoid add_edge(int u, int v, int d){\n\tedge ee;\n\tee.to = v;\n\tee.w = d;\n\tG[u].push_back(ee);\n\tee.to = u;\n\tG[v].push_back(ee);\n}\n\nbool sta[V];\nint dis[V][2010];\nbool inq[V][2010];\n\nint main () { //freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int> city;\n\t\tcap *= 10;\n\t\tscanf(\"%s %s\", s1, s2);\n\t\tcity[string(s1)] = 1;\n\t\tcity[string(s2)] = 2;\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t\tint u, v, d, cou = 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%s %s %d\", s1, s2, &d);\n\t\t\tif(!city[string(s1)]) city[string(s1)] = ++cou;\n\t\t\tif(!city[string(s2)]) city[string(s2)] = ++cou;\n\t\t\tu = city[string(s1)];\n\t\t\tv = city[string(s2)];\n\t\t\tadd_edge(u, v, d);\n\t\t}\n\t\tmemset(sta, 0, sizeof(sta));\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%s\", s1);\n\t\t\tif(!city[string(s1)]) continue;\n\t\t\telse sta[city[string(s1)]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint mmin  = 0x3f3f3f3f;\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tdis[1][cap] = 0;\n\t\tint ok = 0;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = false;\n\t\t\tif(front.p == 2) {ok = 1; if(dis[2][front.oil] < mmin) mmin = dis[2][front.oil]; continue; }\n\t\t\tfor(int i = 0; i < G[front.p].size(); i++){\n\t\t\t\tif(G[front.p][i].w > front.oil) continue;\n\t\t\t\trear.oil = front.oil -G[front.p][i].w;\n\t\t\t\trear.p = G[front.p][i].to;\n\t\t\t\tif(sta[rear.p]) rear.oil = cap;\n\t\t\t\tif(dis[rear.p][rear.oil] > dis[front.p][front.oil] + G[front.p][i].w){\n\t\t\t\t\tdis[rear.p][rear.oil] = dis[front.p][front.oil] + G[front.p][i].w;\n\t\t\t\t\tif(!inq[rear.p][rear.oil]){\n\t\t\t\t\t\tinq[rear.p][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(\"-1\");\n\t\telse printf(\"%d\\n\", mmin);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <queue>\ntypedef long long ll;\n\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nstruct Edge {\n    int src, dst;\n    int weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n    Edge() {}\n};\n\nusing Graph = vector<vector<Edge>>;\n\nint V, E;\nint num_stand; // num of stands\nstring src, dst;\nint cap;\nGraph g;\n\nvector<string> c1, c2;\nvector<int> d;\nvector<string> s;\n\nmap<string, int> m;\n\nconst int inf = 1e9;\n\nint dist[4010][210]; // at town i with gas j\nint canCharge[4010];\n\nint dijkstra(int s, int t) {\n    fill((int*)begin(dist), (int*)end(dist), inf);\n    priority_queue<tuple<int,int, int>> q;// -dist, town, cap\n    \n    dist[s][cap] = 0;\n    q.emplace(0, s, cap);\n\n    while (q.size()) {\n        int d, v, rem;\n        tie(d, v,rem) = q.top();\n        q.pop();\n        d = -d;\n\n        if (v == t) return d;\n\n        if (dist[v][d] < d) continue;\n        for (auto &e : g[v]) {\n            int nv = e.dst;\n            int nrem = rem - e.weight;\n            if (nrem < 0) continue;\n            if (canCharge[nv]) {\n                nrem = cap;\n            }\n            int nd = d + e.weight;\n            if (dist[nv][nrem] > nd) {\n                dist[nv][nrem] = nd;\n                q.emplace(-nd, nv, nrem);\n            }\n        }\n    }\n\n    return 1e9;\n}\n\nint main() {\n    while (cin >> E >> num_stand >> cap && E) {\n        m.clear();\n        V = 0;\n        c1.resize(E);\n        c2.resize(E);\n        d.resize(E);\n        cap *= 10;\n        cin >> src >> dst;\n        if (m.count(src) == 0) m[src] = V++;\n        if (m.count(dst) == 0) m[dst] = V++;\n\n        for (int i = 0; i < E; ++i) {\n            cin >> c1[i] >> c2[i] >> d[i];\n            if (m.count(c1[i]) == 0) m[c1[i]] = V++;\n            if (m.count(c2[i]) == 0) m[c2[i]] = V++;\n        }\n\n        memset(canCharge, 0, sizeof(canCharge));\n        s.resize(num_stand);\n        for (int i = 0; i < num_stand; ++i) {\n            cin >> s[i];\n            if (m.count(s[i]) == 0) m[s[i]] = V++;\n            canCharge[m[s[i]]] = true;\n        }\n\n        g.assign(V, {});\n        for (int i = 0; i < E; ++i) {\n            int a = m[c1[i]];\n            int b = m[c2[i]];\n            g[a].emplace_back(a, b, d[i]);\n            g[b].emplace_back(b, a, d[i]);\n        }\n\n        int ans = dijkstra(m[src], m[dst]);\n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[3010];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    for (int i = 0; i < N; ++i) adj[i].clear();\n    for (int i = 0; i < 3010; ++i) adj2[i].clear();\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    reach[mp[dest]] = reach.size();\n    vector<bool> visit(mp.size(), false);\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (visit[now]) continue;\n      if (reach.count(now) == 0) reach[now] = reach.size();\n      visit[now] = true;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<vector<bool>> visit2(reach.size(), vector<bool>(cap + 1, false));\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and\n             visit2[now = hp.top().second][now_cap = hp.top().first.second])\n        hp.pop();\n      if (now == -1 or visit2[now][now_cap]) break;\n      visit2[now][now_cap] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n#if 0\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n#endif\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6010\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nstatic int mincost[MAX][2010];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVVP G;\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++,G.push_back(VP());\n  if(index.find(t) == index.end())index[t] = idx++,G.push_back(VP());\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      G.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++,G.push_back(VP());\n      index[sdest] = idx++,G.push_back(VP());\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx < MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2010)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n    \n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    cout << -1 << endl;\n    continue;\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{int to,cost;};\nstruct data{string from,to;int cost;};\nstruct State{\n  int t, pos, fuel;\n  State(){}\n  State(int t, int p, int f):t(t),pos(p),fuel(f){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\nconst int MAX = 305;\nconst int INF = (1<<25);\n\nint N,M,C,T[MAX][MAX];\nmap<string,int> NUM;\nvector<edge> E[MAX];\nint cnt,src,dest;\nvector<int> GS;\nint tt[MAX][2001];\n\nvoid init(){\n  fill(T[0],T[0]+MAX*MAX,INF);\n  NUM.clear();\n  GS.clear();\n  for(int i = 0; i < MAX; i++) E[i].clear();\n  cnt=0;\n}\n\nvoid input(){\n  string s,d;\n  cin >> s >> d;\n  NUM[s] = src = ++cnt;\n  NUM[d] = dest = ++cnt;\n\n  vector<data> V;\n  V.resize(N);\n\n  for(int i = 0; i < N; i++)\n    cin >> V[i].from >> V[i].to >> V[i].cost;\n\n  for(int i = 0; i < M; i++){\n    cin >> s;\n    if(NUM[s] == 0)  NUM[s] = ++cnt;\n    GS.push_back(NUM[s]);\n  }\n\n  for(int i = 0; i < N; i++){\n    if(NUM[s] == 0) NUM[s] = ++cnt;\n    if(NUM[d] == 0) NUM[d] = ++cnt;\n    E[NUM[V[i].from]].push_back((edge){NUM[V[i].to],V[i].cost});\n    E[NUM[V[i].to]].push_back((edge){NUM[V[i].from],V[i].cost});\n  }\n}\n\nbool hasGS(int p){\n  for(int i = 0; i < (int)GS.size(); i++)\n    if(GS[i] == p) return true;\n  return false;\n}\n\nvoid dijkstra(int from, const vector<int>& v){\n\n  fill(tt[0],tt[0]+MAX*2001,INF);\n\n  priority_queue<State> Q;\n  Q.push(State(0,from,10*C));\n  tt[from][10*C] = 0;\n \n  //  cout << now.t << \" \" << now.pos << \" \" << now.fuel << endl;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    if(tt[now.pos][now.fuel] < now.t) continue;\n    \n    for(int i = 0; i < (int)E[now.pos].size(); i++){\n      edge& e = E[now.pos][i];\n\n      State nex = now;\n      nex.fuel -= e.cost;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.fuel < 0) continue;\n      \n      if(hasGS(nex.pos)) nex.fuel = 10*C;\n\n      if(tt[nex.pos][nex.fuel] > nex.t){\n\ttt[nex.pos][nex.fuel] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  for(int i = 0; i < (int)v.size(); i++)\n    for(int j = 0; j < 2001; j++)\n      T[from][v[i]] = min(T[from][v[i]],tt[v[i]][j]);\n}\n\nvoid solve(){\n\n  vector<int> tmp = GS;\n  tmp.push_back(src);\n  tmp.push_back(dest);\n\n  for(int i = 0; i < (int)tmp.size(); i++)\n    dijkstra(tmp[i],tmp);\n\n  int size = tmp.size();\n \n  for(int i = 0; i <= size; i++) T[i][i] = 0;\n\n  for(int k = 0; k <= size; k++)\n    for(int i = 0; i <= size; i++)\n      for(int j = 0; j <= size; j++)\n\tT[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n  \n\n  if(T[src][dest] == INF) cout << -1 << endl;\n  else cout << T[src][dest] << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> C && N+M+C){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[301];\nint nodes[1501][1501];\nbool is_LPG[3001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d,d+MAX_V,INF);\n  d[s]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nint N, M, C;\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int cap){\n  return cap*3000+u;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tint sz = 0;\n\tcor[src] = sz++;\n\tcor[dest] = sz++;\n\tC *= 10;\n\tGraph G(3000*2100);\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = sz++;\n\t  if(!cor.count(s2)) cor[s2] = sz++;\n\n\t  for(int j=d;j<=C;++j){\n\t\tG[idx(cor[s1],j)].PB(Edge(idx(cor[s2],j-d),d));\n\t\tG[idx(cor[s2],j)].PB(Edge(idx(cor[s1],j-d),d));\n\t  }\n\t}\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  for(int j=0;j<=C;++j)\n\t\tG[idx(cor[s],j)].PB(Edge(idx(cor[s],C),0));\t  \n\t}\n\n\tVI dist(3000*2100);\n\tDijkstra(G,dist,idx(cor[src],C));\n\tint ans = INF;\n\tfor(int j=0;j<=C;++j)\n\t  ans = min(ans, dist[idx(cor[dest],j)]);\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 2000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return p.d<d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\n\nclass DP{\npublic:\n\tint cost, gas;\n\tstring state;\n\t\n\tDP(){}\n\tDP(string st, int g, int cc){\n\t\tcost = cc;state=st;gas=g;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct edge{\n\tstring to;\n\tint dist;\n};\n\nint N, M, C;\n\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring s, g;\n\t\tcin >> s >> g;\n\t\tmap<string, vector<edge> > E;\n\t\tset<pair<string, int> > visit;\n\t\tset<string> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tE[from].push_back((edge){to, dist});\n\t\t\tE[to].push_back((edge){from, dist});\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(sta);\n\t\t}\n\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(s, C, 0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\n\t\t\tif(S.state == g) break;\n\t\t\tFOR(it, E[S.state]){\n\t\t\t\tDP T=S;\n\t\t\t\tif(T.gas*10 < it->dist) continue;\n\t\t\t\tT.state = it->to;\n\t\t\t\tif(stations.count(it->to)) T.gas = C;\n\t\t\t\telse T.gas -= (it->dist+9)/10;\n\t\t\t\tT.cost += it->dist;\n\t\t\t\tif(!visit.count(pair<string, int>(it->to, T.gas))){\n\t\t\t\t\tdp.push(T);\n\t\t\t\t\tvisit.insert(pair<string, int>(it->to, T.gas));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((S.state == g) ? S.cost : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[301][301];\nbool is_LPG[301];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{int to,cost;};\nstruct data{string from,to;int cost;};\nstruct State{\n  int t, pos, fuel;\n  State(){}\n  State(int t, int p, int f):t(t),pos(p),fuel(f){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\nconst int MAX = 305;\nconst int INF = (1<<25);\n\nint N,M,C,T[MAX][MAX];\nmap<string,int> NUM;\nvector<edge> E[MAX];\nint cnt,src,dest;\nvector<int> GS;\nint tt[MAX][2001];\n\nvoid init(){\n  fill(T[0],T[0]+MAX*MAX,INF);\n  NUM.clear();\n  GS.clear();\n  for(int i = 0; i < MAX; i++) E[i].clear();\n  cnt=0;\n}\n\nvoid input(){\n  string s,d;\n  cin >> s >> d;\n  NUM[s] = src = ++cnt;\n  NUM[d] = dest = ++cnt;\n\n  vector<data> V;\n  V.resize(N);\n\n  for(int i = 0; i < N; i++)\n    cin >> V[i].from >> V[i].to >> V[i].cost;\n\n  for(int i = 0; i < M; i++){\n    cin >> s;\n    if(NUM[s] == 0)  NUM[s] = ++cnt;\n    GS.push_back(NUM[s]);\n  }\n\n  for(int i = 0; i < N; i++){\n    if(NUM[s] == 0) NUM[s] = ++cnt;\n    if(NUM[d] == 0) NUM[d] = ++cnt;\n    E[NUM[V[i].from]].push_back((edge){NUM[V[i].to],V[i].cost});\n    E[NUM[V[i].to]].push_back((edge){NUM[V[i].from],V[i].cost});\n  }\n}\n\nbool hasGS(int p){\n  for(int i = 0; i < (int)GS.size(); i++)\n    if(GS[i] == p) return true;\n  return false;\n}\n\nvoid dijkstra(int from, int to){\n\n  fill(tt[0],tt[0]+MAX*2001,INF);\n  \n  int ans = INF;\n\n  priority_queue<State> Q;\n  Q.push(State(0,from,10*C));\n  tt[from][10*C] = 0;\n \n  //  cout << now.t << \" \" << now.pos << \" \" << now.fuel << endl;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n   \n    if(now.pos == to) ans = min(ans,now.t);\n\n    if(tt[now.pos][now.fuel] < now.t) continue;\n\n    for(int i = 0; i < (int)E[now.pos].size(); i++){\n      edge& e = E[now.pos][i];\n\n      State nex = now;\n      nex.fuel -= e.cost;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.fuel < 0) continue;\n      \n      if(hasGS(nex.pos)) nex.fuel = 10*C;\n\n      if(tt[nex.pos][nex.fuel] > nex.t){\n\ttt[nex.pos][nex.fuel] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n  T[from][to] = min(T[from][to],ans);\n  T[to][from] = min(T[to][from],ans);\n}\n\nvoid solve(){\n\n  vector<int> tmp = GS;\n  tmp.push_back(src);\n  tmp.push_back(dest);\n\n  for(int i = 0; i < (int)tmp.size(); i++)\n    for(int j = i+1; j < (int)tmp.size(); j++)\n      dijkstra(tmp[i],tmp[j]);\n\n  int size = tmp.size();\n \n  for(int i = 0; i <= size; i++) T[i][i] = 0;\n\n  for(int k = 0; k <= size; k++)\n    for(int i = 0; i <= size; i++)\n      for(int j = 0; j <= size; j++)\n\tT[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n  \n\n  if(T[src][dest] == INF) cout << -1 << endl;\n  else cout << T[src][dest] << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> C && N+M+C){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\ntemplate<typename T = int,\n        typename E = int,\n        typename F = function<T(T, E)>,\n        typename Compare = function<bool(T, T) >>\nclass Dijkstra {\npublic:\n    Int N;\n    T s_value;\n    T init_value;\n    F f;\n    Compare cmp;\n\n    vector<T> dist;\n    vector<vector<pair<int, E>>>\n            G; // first : index, second : E\n\n\n    Dijkstra(Int N, T init_value = INF, T s_value = 0,\n             F f = [](T l, E r) { return l + r; },\n             Compare cmp = [](T l, T r) { return l > r; }\n    ) : N(N), s_value(s_value), init_value(init_value), f(f), cmp(cmp) {\n        dist.resize(N, init_value);\n        G.resize(N);\n    }\n\n    void add_edge(int f, int t, E e) {\n        G[f].push_back(make_pair(t, e));\n    }\n\n    void compute(int s) {\n        using P = pair<T, int>;\n        auto pq_cmp = [this](P l, P r) -> bool {\n            return cmp(l.first, r.first);\n        };\n        priority_queue<P, vector<P>, decltype(pq_cmp)> que(pq_cmp);\n        fill(dist.begin(), dist.end(), init_value);\n        dist[s] = s_value;\n\n        que.push(P(dist[s], s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n\n//            if (!cmp(dist[v], p.first) && (dist[v] != p.first)) continue;\n            if (cmp(p.first, dist[v])) continue;\n\n            for (int i = 0; i < G[v].size(); i++) {\n                int to_idx = G[v][i].first;\n                E to_e = G[v][i].second;\n\n//                auto prev_cost = dist[to_idx];\n//                auto next_cost = f(dist[v], to_e);\n\n                if (cmp(dist[to_idx], f(dist[v], to_e)) && !(dist[to_idx] == init_value && dist[v] == init_value)) {\n                    dist[to_idx] = f(dist[v], to_e);\n                    que.push(P(dist[to_idx], to_idx));\n                }\n            }\n        }\n    }\n\n    T get_dist(int v) {\n        return dist[v];\n    }\n\n\n};\n\nbool solve() {\n    Int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if (N == 0) return false;\n\n    string src, dest;\n    cin >> src >> dest;\n\n    map<string, int> s_to_i;\n    map<int, int> i_to_m;\n    vector<Int> from, to;\n    vector<Int> dist;\n    set<Int> station; // dijkstraでtoがstationなら満タンに\n\n\n    if (!s_to_i.count(src)) {\n        int cnt = s_to_i.size();\n        s_to_i[src] = cnt;\n        i_to_m[cnt] = cnt;\n    }\n    if (!s_to_i.count(dest)) {\n        int cnt = s_to_i.size();\n        s_to_i[dest] = cnt;\n        i_to_m[cnt] = cnt;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        string f, t;\n        Int d;\n        cin >> f >> t >> d;\n        if (!s_to_i.count(f)) {\n            int cnt = s_to_i.size();\n            s_to_i[f] = cnt;\n        }\n        if (!s_to_i.count(t)) {\n            int cnt = s_to_i.size();\n            s_to_i[t] = cnt;\n        }\n        from.push_back(s_to_i[f]);\n        to.push_back(s_to_i[t]);\n        dist.push_back(d);\n    }\n\n    rep(i, 0, M) {\n        string s;\n        cin >> s;\n        if (!s_to_i.count(s)) {\n            int cnt = s_to_i.size();\n            s_to_i[s] = cnt;\n        }\n\n        if (!i_to_m.count(s_to_i[s])) {\n            int cnt = i_to_m.size();\n            i_to_m[s_to_i[s]] = cnt;\n        }\n\n        station.insert(s_to_i[s]);\n    }\n\n\n//    Dijkstra<T, E, decltype(merge), decltype(cmp)> dij(s_to_i.size(), init_value, s_value, merge, cmp);\n\n    station.insert(s_to_i[src]);\n    station.insert(s_to_i[dest]);\n\n\n    Dijkstra<> dij(s_to_i.size());\n    for (int i = 0; i < N; ++i) {\n        dij.add_edge(from[i], to[i], dist[i]);\n        dij.add_edge(to[i], from[i], dist[i]);\n    }\n\n    vector<vector<Int>> d(station.size(), vector<Int>(station.size(), INF));\n    for (auto st : station) {\n        dij.compute(st);\n        for (auto v : station) {\n            Int a = i_to_m[st];\n            Int b = i_to_m[v];\n            Int c = dij.get_dist(v);\n            if (c <= cap)\n                d[a][b] = c;\n        }\n    }\n\n//    int n = station.size();\n    rep(k, 0, station.size()) {\n        rep(i, 0, station.size()) {\n            rep(j, 0, station.size()) {\n                chmin(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    Int Start = i_to_m[s_to_i[src]];\n    Int Term = i_to_m[s_to_i[dest]];\n\n    Int ans = d[Start][Term];\n\n    if (ans == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n\n\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n\n\n    while (solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint D[N][N];\npriority_queue<PP,vector<PP>,greater<PP> > Q;\nint dijkstra(){\n  while(!Q.empty())Q.pop();\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++) D[i][j]=INF;\n\n  Q.push(PP(0,P(cap,0)));\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\nstring s1,s2,stt,goo;\nint n,m,x,c1;\nint dp[6009][2009];\nvector<P>v[6001];\nint main(){\n  while(cin>>n>>m>>x,n){\n    r(i,6001)v[i].clear();\n    r(i,6009)r(j,2009)dp[i][j]=1e9;\n    x*=10;\n    int c=1;\n    map<string,int>M;\n    set<int>s;\n    cin>>stt>>goo;\n    r(i,n){\n      cin>>s1>>s2>>c1;\n      if(!M[s1])M[s1]=c++;\n      if(!M[s2])M[s2]=c++;\n      v[M[s1]].push_back(P(M[s2],c1));\n      v[M[s2]].push_back(P(M[s1],c1));\n      //cout<<c<<endl;\n    }\n    int st=M[stt],go=M[goo];\n    r(i,m){\n      cin>>s1;\n      s.insert(M[s1]);\n    }\n    //cout<<c<<endl;\n    dp[st][x]=0;\n    priority_queue<P,vector<PP>,greater<PP> >q;\n    q.push(PP(0,P(st,x)));\n    while(!q.empty()){\n      PP p=q.top();q.pop();\n      int now=p.second.first;\n      int cost=p.first;\n      int cap=p.second.second;\n      if(dp[now][cap]<cost)continue;\n      r(i,v[now].size()){\n        int dis=v[now][i].second;\n        int next=v[now][i].first;\n        int cost2=cost+dis;\n        int cap2=cap-dis;\n        if(cap2<0)continue;\n        if(s.count(next))cap2=x;\n        if(dp[next][cap2]>cost2){//cout<<next<<' '<<cost2<<endl;\n          dp[next][cap2]=cost2;\n          q.push(PP(cost2,P(next,cap2)));\n        }\n      }\n    }\n    int ans=1e9;\n    r(i,2009)ans=min(dp[go][i],ans);\n    if(ans==1e9)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, int> PII;\ntypedef tuple<LL, int, int> PIII;\n\nconstexpr int N = 3000, M = 300;\nconstexpr LL INF = LLONG_MAX/2;\n\nint n, m, cap;\nLL dis[2*N+2], tmp_dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n\ninline LL solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      sid.emplace(s0, sid.size());\n      adj[sid.size()].clear();\n    }\n    if(!sid.count(s1)) {\n      sid.emplace(s1, sid.size());\n      adj[sid.size()].clear();\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n\t\tif(dis[nxt0.S] <= nxt0.F)\n      continue;    \n    dis[nxt0.S] = nxt0.F;\n    fill(tmp_dis, tmp_dis+mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    //if(tmp_dis[1] != INF)\n    //  return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i])\n        pq0.emplace(tmp_dis[i], i);\n  }\n  if(dis[1] >= INF)\n    return -1;\n  else\n    return dis[1];\n}\n\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct node{\n    int index,cost;\n    node(int index,int cost):index(index),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\n \nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint main() {\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n \n        int nc;\n        vvi g;\n        vi st_city;\n        int src_i;\n        int dst_i;\n\t\t{\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n            }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n            }\n        }\n\t\tnc=cities.size();\n\n\t\tg=vvi(nc,vi(nc,NONE));\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(nc);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n        REP(i,nc){\n            if(station[i]){\n                st_city.push_back(i);\n            }\n        }\n        st_city.push_back(src_i);\n        st_city.push_back(dst_i);\n\t\t}\n \n         \n \n        vvi gg(st_city.size(),vi(st_city.size(),MAX));\n        REP(i,st_city.size()){\n            gg[i][i]=0;\n        }\n \n        REP(from,st_city.size()){\n            priority_queue<node> q;\n            q.push(node(st_city[from],0));\n            vi cost(nc,MAX);\n            cost[st_city[from]]=0;\n            while(!q.empty()){\n                node cnode=q.top();q.pop();\n                if(cost[cnode.index]<cnode.cost){\n                    continue;\n                }\n                REP(i,nc){\n\t\t\t\t\tif(g[cnode.index][i]!=NONE){\n                        int newcost=cnode.cost+g[cnode.index][i];\n                        if(cost[i]>newcost){\n                            cost[i]=newcost;\n                            q.push(node(i,newcost));\n                        }\n                    }\n                }\n            }\n\t\t\tREP(to,st_city.size()){\n\t\t\t\tgg[from][to]=cost[st_city[to]];\n\t\t\t\tgg[to][from]=cost[st_city[to]];\n\t\t\t}\n        }\n \n        REP(i,st_city.size()){\n            REP(j,st_city.size()){\n                if(gg[i][j]>cap)\n                gg[i][j]=MAX;\n            }\n        }\n        REP(k,st_city.size()){\n            REP(i,st_city.size()){\n                REP(j,st_city.size()){\n                    gg[i][j]=min(gg[i][j],gg[i][k]+gg[k][j]);\n                }\n            }\n        }\n        int ans=gg[st_city.size()-2][st_city.size()-1];\n        cout<<(ans==MAX?-1:ans)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\nvector<pii> graph[6000];\nint graph2[310][310];\n\nint dist[6010];\nint dist2[310][2010];\n\nint station[310];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v,int g){\n\tif(g>=0&&(dist2[v][g]==-1||dist2[v][g]>c)){\n\t\tdist2[v][g]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid dijkstra(int s,int m){\n\tclr(dist,-1);\n\tint src=station[s];\n\tdist[src]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,src,-1);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(dist[v]<c)\n\t\t\tcontinue;\n\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tif(dist[v2.first]==-1||dist[v2.first]>nc){\n\t\t\t\tdist[v2.first]=nc;\n\t\t\t\tstate next(nc,v2.first,-1);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m) graph2[s][i]=dist[station[i]];\n\treturn;\n}\n\n\nint dijkstra2(int cap,int m){\n\tclr(dist2,-1);\n\tdist2[0][cap]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(dist2[v][g]<c)\n\t\t\tcontinue;\n\n\t\tif(v>=2) g=cap;\n\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint nc=c+graph2[v][i];\n\t\t\tint ng=g-graph2[v][i];\n\t\t\tif(update(nc,i,ng)){\n\t\t\t\tstate next(nc,i,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tint n,m,cap;\n\twhile(cin >> n >> m >> cap){\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\n\t\tmap<string,int> con;\n\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\n\t\tm+=2;\n\t\tclr(station,-1);\n\t\tstation[0]=con[src],station[1]=con[dest];\n\t\tfor(int i=2;i<m;++i){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[i]=con[s];\n\t\t}\n\t\trep(i,m) dijkstra(i,m);\n\n\t\tcap*=10;\n\t\tint ans=dijkstra2(cap,m);\n\t\tcout << ans << endl;\n\n\t\trep(i,nmax) graph[i].clear();\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[4000];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  memset(vis,0,sizeof(vis));  \n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    int t=getnum(s);\n    if(t>4000)exit(0);\n    lpg[t]=1;\n  }\n\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nca=ca-co;\n      if(to>4000 || nca>4000)break;\n      if(vis[to][nca])continue;\n      q.push(mp(-cc-co,mp(nca,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>cap,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n\nstruct Elem {\n    int pos, cap, dist;\n    bool operator<(const Elem &e) const {\n        return dist > e.dist;\n    }\n};\n\nint N, M, cap;\n\nsigned main() {\n    while(cin >> N >> M >> cap, N) {\n        cap *= 10;\n        map<string, int> v_id;\n\n        string start_v, goal_v; cin >> start_v >> goal_v;\n        v_id[start_v]++;\n        v_id[goal_v]++;\n\n        vector<string> u(N), v(N);\n        vector<int> cost(N);\n        for(int i=0; i<N; i++) {\n            cin >> u[i] >> v[i] >> cost[i];\n            v_id[ u[i] ]++;\n            v_id[ v[i] ]++;\n        }\n\n        vector<string> station(M);\n        for(int i=0; i<M; i++) {\n            cin >> station[i];\n            v_id[ station[i] ]++;\n        }\n\n        // 座圧\n        int id = 0;\n        for(auto x : v_id) {\n            v_id[ x.first ] = id++;\n        }\n\n        // 頂点数\n        int V = id;\n\n        // グラフ作成\n        vector< vector<pii> > G(V);\n        for(int i=0; i<N; i++) {\n            int x = v_id[ u[i] ];\n            int y = v_id[ v[i] ];\n            G[x].push_back(make_pair(y, cost[i]));\n            G[y].push_back(make_pair(x, cost[i]));\n        }\n\n        // station assignment\n        vector<int> is_station(V);\n        for(int i=0; i<M; i++) {\n            int st = v_id[ station[i] ];\n            is_station[st] = true;\n        }\n\n        // dijkstra\n        vector< vector<int> > dist(V, vector<int>(cap + 1, INF));\n        int sv = v_id[ start_v ], gv = v_id[ goal_v ];\n        dist[sv][cap] = 0;\n\n        priority_queue< Elem > que;\n        que.push(Elem{sv, cap, 0});\n\n        int ans = INF;\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n\n            int x = cur.pos, c = cur.cap, d = cur.dist;\n            if(dist[x][c] < d) continue;\n            if(x == gv) {\n                ans = min(ans, d);\n            }\n\n            for(auto e : G[x]) {\n                int y = e.first;\n                int n_cap = c - e.second;\n                int n_dist = d + e.second;\n                if(n_cap < 0) continue;\n\n                if(is_station[y]) {\n                    n_cap = cap;\n                }\n\n                if(dist[y][n_cap] > n_dist) {\n                    dist[y][n_cap] = n_dist;\n                    que.push(Elem{y, n_cap, n_dist});\n                }\n            }\n        }\n\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{int to,cost;};\nstruct State{\n  int t, pos, fuel;\n  State(){}\n  State(int t, int p, int f):t(t),pos(p),fuel(f){}\n  bool operator < (const State& s) const {return t > s.t;}\n};\nconst int MAX = 3005;\nconst int INF = (1<<25);\n\nint N,M,C,T[MAX][MAX];\nmap<string,int> NUM;\nvector<edge> E[MAX];\nint cnt,src,dest;\nvector<int> GS;\nint tt[MAX][2001];\nvoid init(){\n  fill(T[0],T[0]+MAX*MAX,INF);\n  NUM.clear();\n  GS.clear();\n  for(int i = 0; i < MAX; i++) E[i].clear();\n  cnt=0;\n}\n\nvoid input(){\n  string s,d;\n  cin >> s >> d;\n  NUM[s] = src = ++cnt;\n  NUM[d] = dest = ++cnt;\n\n  for(int i = 0; i < N; i++){\n    int cos;\n    cin >> s >> d >> cos;\n    if(NUM[s] == 0) NUM[s] = ++cnt;\n    if(NUM[d] == 0) NUM[d] = ++cnt;\n    E[NUM[s]].push_back((edge){NUM[d],cos});\n    E[NUM[d]].push_back((edge){NUM[s],cos});\n  }\n\n  for(int i = 0; i < M; i++){\n    cin >> s;\n    GS.push_back(NUM[s]);\n  }\n}\n\nbool hasGS(int p){\n  for(int i = 0; i < (int)GS.size(); i++)\n    if(GS[i] == p) return true;\n  return false;\n}\n\nvoid dijkstra(int from, int to){\n\n  fill(tt[0],tt[0]+MAX*2001,INF);\n  \n  int ans = INF;\n\n  priority_queue<State> Q;\n  Q.push(State(0,from,10*C));\n  tt[from][10*C] = 0;\n \n  //  cout << now.t << \" \" << now.pos << \" \" << now.fuel << endl;\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n   \n    if(now.pos == to) ans = min(ans,now.t);\n\n    if(tt[now.pos][now.fuel] < now.t) continue;\n\n    for(int i = 0; i < (int)E[now.pos].size(); i++){\n      edge& e = E[now.pos][i];\n\n      State nex = now;\n      nex.fuel -= e.cost;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.fuel < 0) continue;\n      \n      if(hasGS(nex.pos)) nex.fuel = 10*C;\n\n      if(tt[nex.pos][nex.fuel] > nex.t){\n\ttt[nex.pos][nex.fuel] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n  T[from][to] = min(T[from][to],ans);\n  T[to][from] = min(T[to][from],ans);\n}\n\nvoid solve(){\n\n  vector<int> tmp = GS;\n  tmp.push_back(src);\n  tmp.push_back(dest);\n\n  for(int i = 0; i < (int)tmp.size(); i++)\n    for(int j = i+1; j < (int)tmp.size(); j++)\n      dijkstra(tmp[i],tmp[j]);\n\n  int size = tmp.size();\n \n  for(int i = 0; i <= size; i++) T[i][i] = 0;\n\n  for(int k = 0; k <= size; k++)\n    for(int i = 0; i <= size; i++)\n      for(int j = 0; j <= size; j++)\n\tT[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n  \n\n  if(T[src][dest] == INF) cout << -1 << endl;\n  else cout << T[src][dest] << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> C && N+M+C){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    map<int,vector<Node> > nodes;\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : 0)\n;\n\tif(dp[to][next_remaining_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define INF\t(1 << 30)\n\n#define MAX_N\t(3000)\n#define MAX_C\t(MAX_N * 2)\n#define MAX_D\t(200 * 10)\n\n#define DBIT\t(11)\n#define DMASK\t((1 << DBIT) - 1)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef map<string,int> msi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\n/* global variables */\n\nmsi chash;\nint rds[MAX_N][3];\nvpii nbrs[MAX_C];\nbool gss[MAX_C];\nshort dists[MAX_C << DBIT];\n\nstruct g_dist {\n  bool operator()(const int& a, const int& b) const {\n    return dists[b] < dists[a];\n  }\n};\n\n/* subroutines */\n\n/* main */\n\nint main() {\n\n  for (;;) {\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if ((n | m | cap) == 0) break;\n\n    string scty, dcty;\n    cin >> scty >> dcty;\n\n    int nc = 0;\n    chash.clear();\n\n    for (int i = 0; i < n; i++) {\n      string cti0, cti1;\n      int di;\n      cin >> cti0 >> cti1 >> di;\n\n      if (chash.find(cti0) == chash.end())\n\tchash[cti0] = nc++;\n      if (chash.find(cti1) == chash.end())\n\tchash[cti1] = nc++;\n\n      rds[i][0] = chash[cti0];\n      rds[i][1] = chash[cti1];\n      rds[i][2] = di;\n    }\n\n    for (int i = 0; i < nc; i++) nbrs[i].clear();\n    \n    for (int i = 0; i < n; i++) {\n      nbrs[rds[i][0]].push_back(pii(rds[i][1], rds[i][2]));\n      nbrs[rds[i][1]].push_back(pii(rds[i][0], rds[i][2]));\n    }\n    //p edges\n    //p nbrs\n\n    memset(gss, false, sizeof(bool) * nc);\n\n    for (int i = 0; i < m; i++) {\n      string cty;\n      cin >> cty;\n      gss[chash[cty]] = true;\n    }\n    //p gss\n\n    int sc = chash[scty];\n    int dc = chash[dcty];\n    //p [sc, dc]\n\n    int max_d = cap * 10;\n\n    memset(dists, -1, sizeof(dists));\n    int st = sc << DBIT | 0;\n    dists[st] = 0;\n\n    priority_queue<int,vi,g_dist> q;\n    q.push(st);\n\n    int min_d = INF;\n    \n    while (! q.empty()) {\n      int u = q.top();\n      q.pop();\n\n      int uc = u >> DBIT;\n      int ug = u & DMASK;\n      int ud = dists[u];\n\n      if (uc == dc) {\n\tif (min_d > ud) min_d = ud;\n\tbreak;\n      }\n\n      if (gss[uc]) ug = 0;\n\n      for (int i = 0; i < nbrs[uc].size(); i++) {\n\tint vc = nbrs[uc][i].first;\n\tint ed = nbrs[uc][i].second;\n\n\tint vg = ug + ed;\n\tif (vg > max_d) continue;\n\n\tint v = vc << DBIT | vg;\n\tint nvd = ud + ed;\n\n\tif (dists[v] < 0 || dists[v] > nvd) {\n\t  dists[v] = nvd;\n\t  q.push(v);\n\t}\n      }\n    }\n\n    cout << (min_d >= INF ? -1 : min_d) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\n\nclass DP{\npublic:\n\tint cost, gas, state;\n\t\n\tDP(){}\n\tDP(int st, int g, int cc){\n\t\tcost = cc;state=st;gas=g;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tint dist;\n};\n\nint N, M, C;\n\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E;\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)){\n\t\t\t\tidx[from] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tif(!idx.count(to)){\n\t\t\t\tidx[to] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(idx[sta]);\n\t\t}\n\t\ts = idx[ss];g = idx[gg];\n\t\t\n\t//\tset< pair<int, int> > visit;\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(s, C*10, 0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.state == g) break;\n\t\t\tFOR(it, E[S.state]){\n\t\t\t\tDP T=S;\n\t\t\t\tif(T.gas < it->dist) continue;\n\t\t\t\tT.state = it->to;\n\t\t\t\tif(stations.count(it->to)) T.gas = C*10;\n\t\t\t\telse T.gas -= it->dist;\n\t\t\t\tT.cost += it->dist;\n\t\t//\t\tif(!visit.count(pair<int, int>(it->to, T.gas))){\n\t\t\t\t\tdp.push(T);\n\t\t//\t\t\tvisit.insert(pair<int, int>(it->to, T.gas));\n\t\t//\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((S.state == g) ? S.cost : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <functional>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n\tbool operator>(const edge& e1)const{\n\t\treturn c>e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[7001];\nvector<edge> GG[7001];\nmap<string,int> city;\nint dp[7000];\nbool flag[7000];\n\nvoid make_path(int v){\n\tfill(dp,dp+city.size(),cap+1);\n\tpriority_queue<edge,vector<edge>,greater<edge> > que;\n\tque.push(data(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<edge,vector<edge>,greater<edge> > que;\n\tque.push(data(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<=city.size();i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<=city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 2010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 0; j <= cap; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\t\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> city;\n\t\tcity.insert(src), city.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) city.insert(c1[i]), city.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : city) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(6010);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nmap<string, int> mp;\nconst int N = 3010;\nvector<P> G[N];\nint lpgid[N];\nconst int M = 310;\nint lpg[M];\nint d[M][M];\n\nvoid dijk(int s, int cap){\n\tvector<int> dist(N, 1e9);\n\n\tpriority_queue<P> q;\n\tq.push(MP(0, s));\n\tdist[s] = 0;\n\twhile (!q.empty()){\n\t\tauto p = q.top();\n\t\tq.pop();\n\n\t\tint dd = p.first;\n\t\tint pos = p.second;\n\t\tif (dist[pos] < dd) continue;\n\t\tif (lpgid[pos] >= 0) d[lpgid[s]][lpgid[pos]] = dd;\n\n\t\tfor (auto edge : G[pos]){\n\t\t\tint nd = dd + edge.second;\n\t\t\tint npos = edge.first;\n\t\t\tif (dist[npos] <= nd) continue;\n\t\t\tdist[npos] = nd;\n\n\t\t\tif (nd <= cap) q.emplace(nd, npos);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tMEMSET(lpgid, -1);\n\t\tMEMSET(lpg, -1);\n\t\trep(i, M) rep(j, M) if(i != j) d[i][j] = 1e9;\n\t\trep(i, N) G[i].clear();\n\t\tmp.clear();\n\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint num = 0;\n\t\tmp[src] = num++;\n\t\tmp[dest] = num++;\n\t\trep(i, n){\n\t\t\tstring s, t;\n\t\t\tcin >> s >> t;\n\t\t\tif (!mp.count(s)) mp[s] = num++;\n\t\t\tif (!mp.count(t)) mp[t] = num++;\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\tG[mp[s]].emplace_back(mp[t], d);\n\t\t\tG[mp[t]].emplace_back(mp[s], d);\n\t\t}\n\t\trep(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tassert(mp.count(s) == 1);\n\t\t\tlpgid[mp[s]] = i;\n\t\t\tlpg[i] = mp[s];\n\t\t}\n\t\tlpgid[mp[src]] = m;\n\t\tlpg[m] = mp[src];\n\t\tlpgid[mp[dest]] = m + 1;\n\t\tlpg[m + 1] = mp[dest];\n\n\t\trep(i, m + 2) dijk(lpg[i], cap * 10);\n\n\t\trep(i, m + 2) rep(j, m + 2) rep(k, m + 2)\n\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n\n\t\tint ans = d[m][m + 1];\n\t\tif (ans >= 1e9) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[3010];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    reach[mp[dest]] = reach.size();\n    vector<bool> visit(mp.size(), false);\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (visit[now]) continue;\n      if (reach.count(now) == 0) reach[now] = reach.size();\n      visit[now] = true;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) adj[i].clear();\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n    cand.clear();\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    mp.clear();\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<set<int>> visit2(reach.size(), set<int>());\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and visit2[now = hp.top().second].count(\n                                 now_cap = hp.top().first.second))\n        hp.pop();\n      if (now == -1 or visit2[now].count(now_cap)) break;\n      visit2[now].insert(now_cap);\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n    for (int i = 0; i < (int)reach.size(); ++i) adj2[i].clear();\n\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n\nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n\nint n, m, cap, dis[2*N+2], tmp_dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      adj[sid.size()].clear();\n      sid.emplace(s0, sid.size());\n    }\n    if(!sid.count(s1)) {\n      adj[sid.size()].clear();\n      sid.emplace(s1, sid.size());\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  fill(dis, dis+mid, INF);\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    fill(tmp_dis, tmp_dis+mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  return (dis[1] == INF) ? -1 : dis[1];\n}\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\nint from,to;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    {\n      vector<string> node;\n      scanf(\"%s%s\",s,t);\n      node.push_back(s);\n      node.push_back(t);\n      for( int i = 0; i < n; i++ ) {\n        scanf(\"%s%s%d\",c[i],d[i],w+i);\n        node.push_back(c[i]);\n        node.push_back(d[i]);\n      }\n      for( int i = 0; i < m; i++ ) {\n        scanf(\"%s\",st[i]);\n        node.push_back(st[i]);\n      }\n      sort(node.begin(),node.end());\n      node.erase(unique(node.begin(),node.end()),node.end());\n      int sz = node.size();\n      g.clear();\n      cost.clear();\n      sta.clear();\n      g.resize(sz,vector<edge>());\n      cost.resize(sz,vector<int>(cap*10+1));\n      sta.resize(sz);\n      for( int i = 0; i < sz; i++ ) {\n        sta[i] = false;\n        for( int j = 0; j <= cap*10; j++ ) {\n          cost[i][j] = 1919810893;\n        }\n      }\n      for( int i = 0; i < n; i++ ) {\n        int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n        int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n        g[a].push_back(edge(b,w[i]));\n        g[b].push_back(edge(a,w[i]));\n      }\n      for( int i = 0; i < m; i++ ) {\n        sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n      }\n      from = lower_bound(node.begin(),node.end(),s)-node.begin();\n      to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    }\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  map<int,int> D[20001];\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[c][pos]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&(!D[nc].count(nx)||D[nc][nx]>nd))\n\tQ.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nvector<pair<int, int> > E[6010];\nbool LPF[6010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\trep(i, 0, 6010) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 6010) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>f,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    f.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      f.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<V;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[f[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 7001\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    //node.erase(unique(all(node)),node.end());\n  \tunique(all(node));\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<edge> g[3333];\nbool sta[3333];\nint cost[3333][2222];\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    scanf(\"%s%s\",s,t);\n    vector<string> node;\n    for( int i = 0; i < 3333; i++ ) {\n      g[i].clear();\n      sta[i] = false;\n      for( int j = 0; j < 2222; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nvector<pair<int,int> > v[6000];\nbool sta[6000];\nint dp[6000][2002];\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2;i++){\n    for(int j=0;j<=2001;j++){\n      if(i==0)dp[i][j]=0;\n      else dp[i][j]=inf;\n    }\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(mp(M[b],c));\n      v[M[b]].push_back(mp(M[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(u.n==1){\n\tans=u.dis;\n        break;\n      }\n\n      if(sta[u.n])u.a=cap;\n\n      bool flag=true;\n      for(int i=u.a;i<=cap;i++){\n\tif(dp[u.n][i]<u.dis){\n\t  flag=false;\n\t  break;\n\t}\n      }\n      if(!flag)continue;\n      \n      for(int i=0;i<v[u.n].size();i++){\n\tif(v[u.n][i].s<=u.a){\n\t  int x=u.dis+v[u.n][i].s,y=u.a-v[u.n][i].s,z=v[u.n][i].f;\n\t  if(x<dp[z][y]){\n\t    dp[z][y]=x;\n\t    pq.push(State(z,y,x));\n\t  }\n\t}\n      }\n\n    }\n    if(ans==inf)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n \nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n \ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n \nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n \nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n \n \nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      rep(i,MAX)G[i].clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n \n      rep(i,N)\n    {\n      string c1,c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      add_edge(c1,c2,d);\n    }\n \n      assert(idx <= MAX);\n\n\trep(i,idx) \n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}    \n \n      rep(i,M)\n    {\n      string s;\n      cin >> s;\n      LPG[index[s]] = true;\n    }\n \n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n \n      while(!que.empty())\n    {\n      Pox pox = que.top(); que.pop();\n       \n      if(ans <= pox.cost)continue;\n       \n      if(pox.cur == dest)\n        {\n          ans = min(ans,pox.cost);\n          break;\n        }\n \n      for(int i=0;i<G[pox.cur].size();i++)\n        {\n          P p = G[pox.cur][i];\n          int fuelConsumption = pox.tank - p.d; \n          int next = p.to;\n          if(p.d > pox.tank)continue;\n          if(p.d == pox.tank && !LPG[next])continue;\n \n          if(mincost[next][fuelConsumption] > pox.cost + p.d)\n        {\n          mincost[next][fuelConsumption] = pox.cost + p.d;\n          if(LPG[next])\n            que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n          else\n            que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n             \n \n        }\n        }\n    }\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nvector<pair<int, int> > E[4010];\nbool LPF[4010];\nll dist[4010][3010];\nbool done[4010][3010];\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[m[SRC]][CAP] = 0;\n\tque.push(make_pair(m[SRC] * 10000 + CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nn * 10000 + nc, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\trep(i, 0, 4000) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 4000) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\trep(i, 0, 4000) rep(j, 0, 3010) dist[i][j] = INF;\n\t\trep(i, 0, 4000) rep(j, 0, 3010) done[i][j] = false;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1318 : Long Distance Taxi **/\nconst int MAX_V = 6010;\nconst int MAX_CAP = 2010;\n\nint N, M, cap;\n\nint idx;\nmap<string, int> idx_list;\nbool LPG[MAX_V];\nint d[MAX_V][MAX_CAP];\nint target;\n\nstruct Node {\n\tint v, c, d;\n\tNode (int _d, int _v, int _c) : v(_v), c(_c), d(_d){}\n\tbool operator<(const Node &n)const{return d>n.d;}\n};\n\nstruct Edge {\n\tint to; int cost;\n\tEdge(int t, int c) :  to(t), cost(c){}\n};\nvector<Edge> G[MAX_V];\n\nint toIdx(string name)\n{\n\tif (idx_list.count(name)) {\n\t\treturn idx_list[name];\n\t} else {\n\t\tidx_list[name] = idx++;\n\t\treturn idx_list[name];\n\t}\n}\n\nvoid dijkstra(int s)\n{\n\tfill(d[0], d[0]+MAX_V*MAX_CAP, INF);\n\td[s][cap] = 0;\n\t\n\tpriority_queue<Node> Q;\n\tQ.push(Node(0, s, cap));\n\t\n\twhile (Q.size()) {\n\t\tNode p = Q.top(); Q.pop();\n\t\tint v = p.v, c = p.c;\n\t\tif (v == target) break;\n\t\t\n\t\tif (LPG[v])\n\t\t\tc = cap;\n\t\t//cerr << v << \" \" << c << \" \" << p.d << endl;\n\t\t\n\t\tif (d[v][c] < p.d) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\tint nc = c - e.cost;\n\t\t\tif (nc<0) continue;\n\t\t\t\n\t\t\tif (d[e.to][nc] > p.d + e.cost) {\n\t\t\t\td[e.to][nc] = p.d + e.cost;\n\t\t\t\tQ.push(Node(d[e.to][nc], e.to, nc));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> N >> M >> cap, N||M||cap) {\n\t\tfor (int i=0; i<MAX_V; i++) G[i].clear();\n\t\tidx_list.clear(); idx=0;\n\t\tcap *= 10;\n\t\tfill(LPG, LPG+MAX_V, false);\n\t\t\n\t\tstring from, to;\n\t\tcin >> from >> to;\n\t\t\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring a, b; int c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tint ia = toIdx(a), ib = toIdx(b);\n\t\t\tG[ia].push_back(Edge(ib, c));\n\t\t\tG[ib].push_back(Edge(ia, c));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring a; cin >> a;\n\t\t\tLPG[toIdx(a)] = true;\n\t\t}\n\t\t\n\t\ttarget = toIdx(to);\n\t\tdijkstra(toIdx(from));\n\t\t\n\t\tint ans = INF;\n\t\tfor (int i=0; i<MAX_CAP; i++) {\n\t\t\tans = min(ans, d[toIdx(to)][i]);\n\t\t}\n\t\tif (ans==INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[301][301];\nbool is_LPG[301];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(next_consumed_LPG > 3000) continue;\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[4000];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  memset(vis,0,sizeof(vis));  \n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    int t=getnum(s);\n    //if(t>4000)exit(0);\n    lpg[t]=1;\n  }\n\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nca=ca-co;\n      //if(to>4000 || nca>4000)break;\n      if(vis[to][nca])continue;\n      q.push(mp(-cc-co,mp(nca,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while((cin>>n>>m>>cap)&&n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  vector<vector<int> >D(cap+1,vector<int>(n,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n\n    if(pos==1) return d;\n    if(ls[pos])c=cap;\n    if(D[c][pos]<d)continue;\n    \n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nc][nx]>nd)Q.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\nvector<pii> graph[6000];\nvi dist[6000];\nbool station[6000];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v,int g){\n\tif(g>=0&&(dist[v][g]==-1||dist[v][g]>c)){\n\t\tdist[v][g]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint dijkstra(int cap){\n\tdist[0][cap]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(dist[v][g]<c)\n\t\t\tcontinue;\n\n\t\tif(station[v]){\n\t\t\tg=cap;\n\t\t\tdist[v][g]=c;\n\t\t}\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tint ng=g-v2.second;\n\t\t\tif(update(nc,v2.first,ng)){\n\t\t\t\tstate next(nc,v2.first,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tint n,m,cap;\n\twhile(cin >> n >> m >> cap){\n\t\tmap<string,int> con;\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[con[s]]=true;\n\t\t}\n\t\tcap*=10;\n\t\trep(i,nmax) dist[i].assign(cap+1,-1);\n\t\tint ans=dijkstra(cap);\n\t\tcout << ans << endl;\n\n\t\trep(i,nmax) graph[i].clear();\n\t\trep(i,nmax) dist[i].clear();\n\t\tclr(station,false);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  vector<vector<int> >D(cap+1,vector<int>(n,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n\n    if(pos==1) return d;\n    if(D[c][pos]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=ls[nx]? cap:c-G[pos][i].second;\n      if(nc>=0&&D[nc][nx]>nd)Q.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8;\n\nstruct Edge{\n\tint to;\n\tint cost;\n\tEdge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct Node{\n\tint dis;\n\tbool used;\n\tNode() : dis(INF), used(false) { }\n\tNode(int d, bool f) : dis(d), used(f) { }\n};\n\ntypedef vector<vector<Edge>> graph;\n\nvector<Node> dijkstra(graph g, int s, int n){\n\tvector<Node> node(n);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.push(make_pair(0, s));\n\tnode[s] = Node{0, true};\n\n\twhile(not q.empty()){\n\t\tint dis, pos;\n\t\ttie(dis, pos) = q.top(); q.pop();\n\t\tnode[pos].used = true;\n\n\t\tfor(auto e : g[pos]){\n\t\t\tif(node[e.to].used == true) continue;\n\t\t\tif(node[e.to].dis > dis + e.cost){\n\t\t\t\tnode[e.to].dis = dis + e.cost;\n\t\t\t\tq.emplace(node[e.to].dis, e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn node;\n}\n\n\npair<int,int> e[3005];\nint d[3005];\nint t[305];\n\nint input(int n, int m){\n\tmap<string,int> id;\n\n\tstring src, dist;\n\tcin >> src >> dist;\n\tid[src] = id.size();\n\tid[dist] = id.size();\n\n\trep(i,n){\n\t\tstring c1, c2;\n\t\tcin >> c1 >> c2 >> d[i];\n\t\tif(not id.count(c1)) id[c1] = id.size();\n\t\tif(not id.count(c2)) id[c2] = id.size();\n\t\te[i] = make_pair(id[c1], id[c2]);\n\t}\n\n\trep(i,m){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(not id.count(s)) id[s] = id.size();\n\t\tt[i] = id[s];\n\t}\n\n\tt[m] = id[src];\n\tt[m + 1] = id[dist];\n\treturn id.size();\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tint v = input(n, m) + 5;\n\n\t\tgraph g(v), ng(v);\n\t\trep(i,n){\n\t\t\tint x = e[i].first, y = e[i].second;\n\t\t\tg[x].emplace_back(y, d[i]);\n\t\t\tg[y].emplace_back(x, d[i]);\n\t\t}\n\n\t\trep(i,m + 2){\n\t\t\tint x = t[i];\n\t\t\tauto dis = dijkstra(g, x, v);\n\t\t\trep(j,m + 2){\n\t\t\t\tint y = t[j];\n\t\t\t\tif(dis[y].dis > cap) continue;\n\t\t\t\tng[x].emplace_back(y, dis[y].dis);\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,v){\n\t\t//\trep(j,v){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint ans = dijkstra(ng, t[m], v).at(t[m + 1]).dis;\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<stack>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<set>\nusing namespace std;\nmap<string, int> ind;\nmap<string, bool> exi;\nbool gas[3333];\nbool can;\nint no=0;\nvector<int> route[3333];\nvector<int> roulen[3333];\nint n,m,cap,lo;\nint ncap;\nstring start,dest,t1,t2;\nint destid;\nint ans=INT_MAX;\nvoid cp(bool *a,bool *b){\n\tfor(int i=0;i<3333;i++)\n\t\tb[i]=a[i];\n}\nvoid dfs(int now,int gass,int ta,bool *v){\n\tif(gass<0||v[now])return;\n\tif(gas[now])gass=cap;\n\t//cout<<now<<\" \"<<gass<<\" \"<<ta<<\"\\n\";\n\tif(now==destid){\n\t\tans=min(ans,ta);\n\t\treturn;\n\t}\n\tv[now]=true;\n\tbool t[3333];\n\tfor(int i=0;i<route[now].size();i++){\n\t\tcp(v,t);\n\t\tdfs(route[now][i],gass-roulen[now][i],ta+roulen[now][i],t);\n\t}\n}\nvoid solve(){\n\tcap*=10;\n\tncap=cap;\n\tind.clear();\n\tans=INT_MAX;\n\tfor(int i=0;i>3333;i++){\n\t\troute[i].clear();\n\t\troulen[i].clear();\n\t}\n\tbool v[3333];\n\tmemset(v,0,sizeof(v));\n\tdfs(0,ncap,0,v);\n\tif(ans!=INT_MAX)cout<<ans<<\"\\n\";\n\telse cout<<\"-1\\n\";\n}\nint main(){\n\tios::sync_with_stdio(0);\n\twhile(cin>>n>>m>>cap&&n+m+cap>0){\n\t\tmemset(gas,0,sizeof(gas));\n\t\tcin>>start>>dest;\n\t\tif(!exi[start]){\n\t\t\tind[start]=no++;\n\t\t\texi[start]=true;\n\t\t}\n\t\tif(!exi[dest]){\n\t\t\tind[dest]=no++;\n\t\t\texi[dest]=true;\n\t\t}\n\t\tdestid=no-1;\n\t\twhile(n--){\n\t\t\tcin>>t1>>t2>>lo;\n\t\t\tif(!exi[t1]){\n\t\t\t\tind[t1]=no++;\n\t\t\t\texi[t1]=true;\n\t\t\t}\n\t\t\tif(!exi[t2]){\n\t\t\t\tind[t2]=no++;\n\t\t\t\texi[t2]=true;\n\t\t\t}\n\t\t\troute[ind[t1]].push_back(ind[t2]);\n\t\t\troulen[ind[t1]].push_back(lo);\n\t\t\troute[ind[t2]].push_back(ind[t1]);\n\t\t\troulen[ind[t2]].push_back(lo);\n\t\t}\n\t\twhile(m--){\n\t\t\tcin>>t1;\n\t\t\tgas[ind[t1]]=true;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct NODE{\n\tint src,dst,cap,weight;\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.weight > b.weight;\n}\nmap<string,int> dic;\nint get(string s){\n\tif( dic.count(s) ) return dic[s];\n\tint k = dic.size();\n\treturn dic[s] = k;\n}\n\nbool done[6010][2000];\nint main(){\n\tint n,m,cap;\n\twhile( cin >> n >> m >> cap&& n ){\n\t\tmemset(done,0,sizeof(done));\n\t\tvector<NODE> g[6010];\n\t\tint LPG[6010] = {};\n\t\tdic.clear();\n\t\tstring s_,g_;\n\t\tcin >> s_ >> g_;\n\t\tint s = get(s_);\n\t\tint gg = get(g_);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a_,b_;\n\t\t\tcin >> a_ >> b_;\n\t\t\tint a = get(a_);\n\t\t\tint b = get(b_);\n\t\t\tint c; cin >> c;\n\t\t\tg[a].push_back({a,b,0,c});\n\t\t\tg[b].push_back({b,a,0,c});\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring x_; cin >> x_;\n\t\t\tint x = get(x_);\n\t\t\tLPG[x] = true;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push({s,-114514,cap*10,0});\n\t\twhile( Q.size() ){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.cap < 0 ) continue;\n\t\t\tif( q.src == gg ){\n\t\t\t\tcout << q.weight << endl;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t\tif( done[q.src][q.cap] ) continue;\n\t\t\telse done[q.src][q.cap] = true;\n\t\t\tif( LPG[q.src] ){\n\t\t\t\tQ.push({q.src,-114514,cap*10,q.weight});\n\t\t\t}\n\t\t\tfor( auto e : g[q.src] ){\n\t\t\t\tQ.push({e.dst,-114514,q.cap-e.weight,q.weight+e.weight});\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tok:;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[7001];\nvector<edge> GG[7001];\nmap<string,int> city;\nint dp[7000];\nbool flag[7000];\n\nvoid make_path(int v){\n\tfill(dp,dp+city.size(),cap+1);\n\tpriority_queue<data> que;\n\tque.push(edge(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(edge(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define MAX_CP 2001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n\nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  vector<int> dist[idx];\n  cap *= 10;\n \n  for(int i = 0 ; i < idx ; i++){\n    dist[i].resize(cap+1);\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<14)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6001];\nstring city[6001];\nchar gs[6001];\nshort dist[2001][6001];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    short cap = p.second.first, v = p.second.second, cost = p.first;\n\n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap) continue;\n      short tar = max(cap-e.d, gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n\n    rep(i,3005) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    C *= 10;\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n\n    rep(i,N){\n      string s1, s2; short d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n\n    rep(i,M){\n      string s;  cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    dijkstra(recity[src]);\n\n    short res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[3010][2010];\nvector<pii> conn[3010];\nbool station[3010];\n\nstruct node {\n\tint p, cost, gas;\n\tnode(int pp, int cc, int gg) {\n\t\tp = pp;\n\t\tcost = cc;\n\t\tgas = gg;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nint main() {\n\tint n, m, c;\n\twhile(cin >> n >> m >> c, n) {\n\t\tc *= 10;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmemset(station, 0, sizeof(station));\n\t\trep(i,n) conn[i].clear();\n\t\tmap<string, int> mp;\n\t\tint towns = 0;\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\tmp[start] = towns++;\n\t\tif( start != goal ) {\n\t\t\tmp[goal] = towns++;\n\t\t}\n\t\trep(i, n) {\n\t\t\tstring s, e;\n\t\t\tint d;\n\t\t\tcin >> s >> e >> d;\n\t\t\tif( mp.find(s) == mp.end() ) {\n\t\t\t\tmp[s] = towns++;\n\t\t\t}\n\t\t\tif( mp.find(e) == mp.end() ) {\n\t\t\t\tmp[e] = towns++;\n\t\t\t}\n\t\t\tconn[mp[s]].push_back(pii(mp[e], d));\n\t\t\tconn[mp[e]].push_back(pii(mp[s], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tstation[mp[in]] = true;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], 0, c) );\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top(); que.pop();\n\t\t\tif( nd.p == mp[goal] ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.gas] ) continue;\n\t\t\tvisit[nd.p][nd.gas] = true;\n\n\t\t\tif( station[nd.p] && !visit[nd.p][c] ) {\n\t\t\t\tque.push( node(nd.p, nd.cost, c) );\n\t\t\t}\n\n\t\t\tfor(int i=0; i<conn[nd.p].size(); i++) {\n\t\t\t\tif( nd.gas-conn[nd.p][i].second >= 0 &&  !visit[conn[nd.p][i].first][nd.gas-conn[nd.p][i].second] ) {\n\t\t\t\t\tque.push( node(conn[nd.p][i].first, nd.cost + conn[nd.p][i].second, nd.gas-conn[nd.p][i].second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  map<P,int> D;\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[P(cap,0)]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[P(c,pos)]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&(!D.count(P(nc,nx))||D[P(nc,nx)]>nd))\n\tQ.push(PP(nd,P(nc,nx))),D[P(nc,nx)]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n \nbool used[6000][2001];\nvector<pair<short, short> > edge[6000];\n \nint main() {\n  while (true) {\n    rep (i, 6000) edge[i].clear();\n    rep (i, 6000) rep (j, 2001) used[i][j] = false;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    int res = 1e9;\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (used[pos][f]) continue;\n      used[pos][f] = true;\n      if (mp[dest] == pos) {\n\tres = cost;\n      }\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (used[np][nf]) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst int mod = 1000000007;\nconst double PI = acos(-1.0); \n\n\n\nstruct P\n{\n\tint p, c, f;\n\tP(int p, int c, int f)\n\t\t: p(p), c(c), f(f) { }\n\n\tbool operator<(const P& b) const\n\t{\n\t\treturn c < b.c;\n\t}\n};\nint nono(map<string, int>& no, const string& s)\n{\n\tif (!no.count(s))\n\t{\n\t\tint t = no.size();\n\t\tno[s] = t;\n\t}\n\treturn no[s];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n)\n\t{\n\t\tcap *= 10;\n\n\t\tvector<vector<pint> > e(2 * n);\t// pint(cost, to)\n\t\tbool gas[6010];\n\t\tCL(gas, 0);\n\n\t\tmap<string, int> no;\n\t\tconst int src = 0, dest = 1;\n\n\t\t{\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b;\n\t\t\tno[a] = src, no[b] = dest;\n\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tint d;\n\t\t\t\tcin >> a >> b >> d;\n\t\t\t\tint x = nono(no, a), y = nono(no, b);\n\t\t\t\te[x].push_back(pint(d, y));\n\t\t\t\te[y].push_back(pint(d, x));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\tcin >> a, gas[nono(no, a)] = true;\n\t\t}\n\n\n\t\tconst int INF = 1 << 30;\n\t\tstatic int dis[6010][2010];\n\t\tfor (int i = 0; i < no.size(); ++i)\n\t\t\tfor (int j = 0; j <= cap; ++j)\n\t\t\t\tdis[i][j] = INF;\n\n\t\tpriority_queue<P> q;\n\t\tdis[src][cap] = 0;\n\t\tq.push(P(src, 0, cap));\n\n\t\tint res = -1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP cur = q.top();\n\t\t\tq.pop();\n\n\t\t\tint p = cur.p, c = cur.c, f = cur.f;\n\t\t\tif (c > dis[p][f])\n\t\t\t\tcontinue;\n\t\t\telse if (p == dest)\n\t\t\t{\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < e[p].size(); ++i)\n\t\t\t{\n\t\t\t\tint to = e[p][i].second;\n\t\t\t\tint d = e[p][i].first;\n\t\t\t\tint nc = c + d;\n\t\t\t\tint nf = f - d;\n\t\t\t\tif (nf >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (gas[to])\n\t\t\t\t\t\tnf = cap;\n\t\t\t\t\tif (nc < dis[to][nf])\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[to][nf] = nc;\n\t\t\t\t\t\tq.push(P(to, nc, nf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n,m,cap;\n    cin >> n >> m >> cap;\n    if(n==0) return 0;\n    string src,dest;\n    cin >> src >> dest;\n    vector<string> u(n),v(n);\n    vector<int> d(n);\n    map<string,int> idx;\n    for(int i=0;i<n;i++){\n      cin >> u[i] >> v[i] >> d[i];\n      idx.insert({u[i],0});\n      idx.insert({v[i],0});\n    }\n    int co=0;\n    for(auto &it:idx){\n      it.second=co;\n      co++;\n    }\n    vector<list<pair<int,int>>> e(co);\n    vector<bool> sta(co,false);\n    int ui,vi;\n    for(int i=0;i<n;i++){\n      ui=idx[u[i]],vi=idx[v[i]];\n      e[ui].push_back({vi,d[i]});\n      e[vi].push_back({ui,d[i]});\n    }\n    string sss;\n    for(int i=0;i<m;i++){\n      cin >> sss;\n      sta[idx[sss]]=true;\n    }\n    int s=idx[src],t=idx[dest];\n    cap*=10;\n    vector<vector<int>> dist(co,vector<int>(cap+1,INF));\n    priority_queue<pair<int,pair<int,int>>> dijk;\n    dijk.push({0,{s,cap}});\n    pair<int,pair<int,int>> now;\n    int pos,nd,nc;\n    while(!dijk.empty()){\n      now=dijk.top();\n      dijk.pop();\n      nd=-now.first;\n      pos=now.second.first;\n      if(sta[pos]) nc=cap;\n      else nc=now.second.second;\n      if(dist[pos][nc]==INF){\n        dist[pos][nc]=nd;\n        for(auto ee:e[pos]){\n          if(nc>=ee.second){\n            if(dist[ee.first][nc-ee.second]==INF){\n              dijk.push({-nd-ee.second,{ee.first,nc-ee.second}});\n            }\n          }\n        }\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<=cap;i++){\n      ans=min(ans,dist[t][i]);\n    }\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n||m||cap){\n    map<string,int> ms;\n    string src,dst;\n    cin>>src>>dst;\n    ms[src]=0;ms[dst]=1;\n    vector<P> G[10000];\n    for(int i=0;i<n;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(!ms.count(a)) ms[a]=ms.size();\n      if(!ms.count(b)) ms[b]=ms.size();\n      G[ms[a]].push_back(P(ms[b],c));\n      G[ms[b]].push_back(P(ms[a],c));\n    }\n    \n    int v=ms.size(),inf=1<<25;\n    int dp[m+2][v];\n    vector<string> vs(m+2);\n    for(int i=0;i<m+2;i++){\n      for(int j=0;j<v;j++) dp[i][j]=inf;\n      if(i<m) cin>>vs[i];\n      else if(i==m) vs[i]=src;\n      else vs[i]=dst;\n      int u=ms[vs[i]];\n      priority_queue<P> q;\n      dp[i][u]=0;\n      q.push(P(0,u));\n      while(!q.empty()){\n\tP p=q.top();q.pop();\n\tint x=p.second;\n\tif(dp[i][x]<-p.first) continue;\n\tfor(P y:G[x]){\n\t  if(dp[i][x]+y.second<dp[i][y.first]){\n\t    dp[i][y.first]=dp[i][x]+y.second;\n\t    q.push(P(-dp[i][y.first],y.first));\n\t  }\n\t}\n      }\n    }\n\n    int e[m+2][m+2];\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\te[i][j]=inf*(i!=j);\n\n    for(int i=0;i<m+2;i++)\n      for(int j=0;j<m+2;j++)\n\tif(dp[i][ms[vs[j]]]<=cap*10)\n\t  e[j][i]=dp[i][ms[vs[j]]];//,cout<<ms[vs[i]]<<\" \"<<ms[vs[j]]<<endl;;\n    \n    for(int k=0;k<m+2;k++)\n      for(int i=0;i<m+2;i++)\n\tfor(int j=0;j<m+2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n\n    cout<<(e[m][m+1]<inf?e[m][m+1]:-1)<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    int V = names.size();\n    names.clear();\n    vector<vector<int>> D(V, vector<int>(cap+1, INF));\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n \n \nclass DP{\npublic:\n\tint cost, gas, state;\n\t \n\tDP(){}\n\tDP(int st, int g, int cc){\n\t\tcost = cc;state=st;gas=g;\n\t}\n\t \n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n \nstruct edge{\n\tint to;\n\tint dist;\n};\n \nint N, M, C;\n\nbool visit[6000][2001];\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E(N*2);\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)) idx[from] = idx.size() - 1;\n\t\t\tif(!idx.count(to)) idx[to] = idx.size() - 1;\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(idx[sta]);\n\t\t}\n\t\tif(!idx.count(ss)) idx[ss] = idx.size() - 1;\n\t\tif(!idx.count(gg)) idx[gg] = idx.size() - 1;\n\t\ts = idx[ss];g = idx[gg];\n\t\t\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(s, C*10, 0));\n\t\tREP(i, N*2) REP(j, C*10+1) visit[i][j] = false;\n\t\tvisit[s][C*10] = true;\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.state == g) break;\n\t\t\tFOR(it, E[S.state]){\n\t\t\t\tif(S.gas < it->dist) continue;\n\t\t\t\tDP T=S;\n\t\t\t\tT.state = it->to;\n\t\t\t\tif(stations.count(it->to)) T.gas = C*10;\n\t\t\t\telse T.gas -= it->dist;\n\t\t\t\tT.cost += it->dist;\n\t\t\t\tif(!visit[it->to][T.gas]){\n\t\t\t\t\tdp.push(T);\n\t\t\t\t\tvisit[it->to][T.gas] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ((S.state == g) ? S.cost : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename T>\nvector<int> dijkstra(const vector<vector<pair<int,T>>> &G,int s,T inf) {\n  vector<int> d(G.size(),inf);\n  d[s] = 0;\n  using P = pair<T,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,s);\n  while (!que.empty()) {\n    T dd; int v;\n    tie(dd,v) = que.top(); que.pop();\n    if (d[v] < dd) continue;\n    for (auto e : G[v]) {\n      if (d[e.first] > d[v]+e.second) {\n        d[e.first] = d[v]+e.second;\n        que.emplace(d[e.first],e.first);\n      }\n    }\n  }\n  return d;\n}\n\nint N,M,cap;\nstring src,dst;\nstring c[2][3010];\nint d[3010];\nstring s[310];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> M >> cap, N) {\n    vector<string> vs;\n    cin >> src >> dst;\n    vs.push_back(src);\n    vs.push_back(dst);\n    REP(i,N) {\n      cin >> c[0][i] >> c[1][i] >> d[i];\n      vs.push_back(c[0][i]);\n      vs.push_back(c[1][i]);\n    }\n    vector<string> LPG;\n    LPG.push_back(src);\n    LPG.push_back(dst);\n    REP(i,M) {\n      cin >> s[i];\n      vs.push_back(s[i]);\n      LPG.push_back(s[i]);\n    }\n    UNI(LPG);\n    UNI(vs);\n    map<string,int> inv_vs,inv_LPG;\n    vector<vector<pii>> G(vs.size());\n    REP(i,vs.size()) inv_vs[vs[i]] = i;\n    REP(i,LPG.size()) inv_LPG[LPG[i]] = i;\n    REP(i,N) {\n      int v = inv_vs[c[0][i]];\n      int u = inv_vs[c[1][i]];\n      G[v].emplace_back(u,d[i]);\n      G[u].emplace_back(v,d[i]);\n    }\n    int dis[310][310];\n    MINF(dis);\n    REP(i,LPG.size()) {\n      int v = inv_vs[LPG[i]];\n      vector<int> dd = dijkstra<int>(G,v,INF);\n      REP(j,LPG.size()) if (dd[inv_vs[LPG[j]]] <= cap*10) {\n        dis[i][j] = dis[j][i] = dd[inv_vs[LPG[j]]];\n      }\n    }\n    REP(k,LPG.size()) REP(i,LPG.size()) REP(j,LPG.size()) {\n      CHMIN(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n    int ans = dis[inv_LPG[src]][inv_LPG[dst]];\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d = 0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap < 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  for(int i=0;i<=v.cap;i++){\n\t    d[i][p.second] = d[u.cap][p.first] + m[p];\n\t  }\n\t  v.str = p.second;\n\t  v.cap = cap;\n\t  v.d = d[cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std ;\n\nconst int INF = 0x3fffffff ;\nconst int MAXN = 7005 ;\nconst int Csize = 2005 ;\nconst int msize = 305 ;\nstruct Edge {\n\tint v, next ;\n\tint val ;\n} edge[MAXN*2] ; \nint head[MAXN] ;\nint ind ;\n\nint dis[MAXN][Csize];\nbool vis[MAXN][Csize] , is_sta[MAXN] ;\n\nstruct Node {\n\tchar names[20] ;\n\tbool operator < ( const Node &b) const {\n\t\treturn strcmp( names , b.names ) < 0 ;\n\t}\n} ;\nmap<Node , int> mp ;\n\ninline void init() {\n\tind = 0 ; \n \tmemset( head , -1 ,sizeof(head) ) ;\n}\n\ninline void addedge( int u , int v , int val ){\n\tedge[ind].v = v ; \n\tedge[ind].val = val  ;\n\tedge[ind].next = head[u] ;\n\thead[u] = ind++ ;\n}\n\nstruct Que {\n\tint dis , lea ;\n\tint v ;\n\tQue(){}\n\tQue(int _d , int _l , int _v):dis(_d),lea(_l),v(_v){}\n\tbool operator < (const Que& b) const {\n\t\treturn dis > b.dis ;\n\t}\n} ;\n\n\nint Dijkstra( int s , int t  , int n , int lea ) {\n\tfor ( int i = 0 ;  i<= n; i++ ) {\n\t\tfor ( int j = 0 ; j <= 2001 ; j++ )\n\t\t\tdis[i][j] = INF , vis[i][j] = false ;\n\t}\t\n\tpriority_queue<Que> Q ;\n\tQue in , out ;\n\t\n\tin = Que( 0 , lea , s ) ;\n\tQ.push(in) ;\n\tdis[s][lea] = 0 ;\n\twhile (!Q.empty()) {\n\t\tout = Q.top() ;\n\t\tQ.pop() ;\n\n\t\tif ( vis[out.v][out.lea] ) continue ;\n\t\tvis[out.v][out.lea] = true ;\n\t\t\n\t\t//printf( \"%d %d\\n\" , out.v , out.dis ) ;\n\t\tif (out.v == t) {\n\t\t\treturn out.dis ;\n\t\t}\n\t\t\n\t\tfor ( int i = head[out.v] ; i != -1 ; i = edge[i].next ) {\n\t\t\tin.v = edge[i].v ;\n\t\t\tif ( out.lea < edge[i].val ) continue ;\t \t\n\t\t\tin.lea = is_sta[in.v] ? lea : out.lea - edge[i].val ;\n\t\t\tif ( dis[out.v][out.lea] + edge[i].val < dis[in.v][in.lea] ) {\n\t\t\t\t//printf(\"v = %d %d %d %d\\n\" , in.v , dis[out.v][out.lea] , edge[i].val, dis[in.v][in.lea] ) ;\n\t\t\t\tin.dis = dis[in.v][in.lea] = edge[i].val + dis[out.v][out.lea] ;\n\t\t\t\t\n\t\t\t\tQ.push(in) ;\n\t\t\t}  \n\t\t}\n\t}\n\treturn -1 ;\n}\n\nint main() {\n\tfreopen(\"data.in\" , \"r\" , stdin) ;\n\n\tint n , m , cap ;\n\twhile ( ~scanf(\"%d%d%d\", &n, &m, &cap) ) {\n\t\tif ( n == 0 && m==0 && cap == 0 ) break ;\n\t\t\n\t\tinit() ;\n\t\tmp.clear() ;\n\n\t\tNode s1 , s2 ;\n\t\tint id = 0 ;\n\t\tscanf( \"%s%s\" , s1.names , s2.names ) ;\n\t\tif ( !mp[s1] ) mp[s1] = ++id ; \t\n\t\tif ( !mp[s2] ) mp[s2] = ++id ;\n\t\t\n\t\tint src = mp[s1] , dest = mp[s2] , val ;\n\n\t\tfor ( int i = 1 ; i <= n; i++ ) {\n\t\t\tscanf( \"%s%s%d\", s1.names , s2.names , &val ) ;\n\t\t\tif (!mp[s1]) mp[s1] = ++id ;\n\t\t\tif (!mp[s2]) mp[s2] = ++id ;\n\t\t\tint u = mp[s1] , v = mp[s2] ;\t\t\t\n\t\t\taddedge( u , v , val ) ; \n\t\t\taddedge( v , u , val ) ;\t\t\n\t\t}\n\t\t\n\t\tmemset(is_sta , false ,sizeof(is_sta) ) ;\n\t\tfor ( int i = 1 ; i <= m; i++ ) {\n\t\t\tscanf( \"%s\", s1.names ) ;\n\t\t\tif ( !mp[s1] ) mp[s1] = ++id; \n\t\t\tis_sta[mp[s1]] = true ;\n\t\t}\n\n\t\tint res = Dijkstra( src , dest , id , 10*cap ) ;\n\t\tprintf(\"%d\\n\", res) ;\n\t\t//printf(\"res = %d \\n\" , res ) ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nmap<string, int> tbl;\nint getId(string& name) {\n\tif ( tbl.count(name) == 0 ) {\n\t\tint freshId = tbl.size();\n\t\treturn tbl[name] = freshId;\n\t}\n\treturn tbl[name];\n}\nstruct Edge {\n\tint from, to, cost;\n};\nstruct Node {\n\tint v, rest, cost;\n};\nbool operator>(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\nint dist[3010][2100];\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint E, M, cap;\n\twhile ( cin >> E >> M >> cap, E || M || cap ) {\n\t\ttbl.clear();\n\t\tint s, t;\n\t\t{\n\t\t\tstring src, dest; cin >> src >> dest;\n\t\t\ts = getId(src);\n\t\t\tt = getId(dest);\n\t\t}\n\t\tvector<Edge> edges;\n\t\tREP(i,E) {\n\t\t\tstring un, vn; cin >> un >> vn;\n\t\t\tint u = getId(un), v = getId(vn);\n\t\t\tint d; cin >> d;\n\t\t\tedges.pb({u, v, d});\n\t\t}\n\t\tint N = tbl.size();\n\t\tvector< vector<Edge> > G(N);\n\t\tEACH(e,edges) {\n\t\t\tG[e.from].pb(e);\n\t\t\tG[e.to].pb({e.to, e.from, e.cost});\n\t\t}\n\t\tvector<bool> lpg(N, false);\n\t\tREP(i,M) {\n\t\t\tstring s; cin >> s;\n\t\t\tint id = getId(s);\n\t\t\tlpg[id] = true;\n\t\t}\n\t\tfill(dist[0], dist[3010], inf); dist[s][cap] = 0;\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push({s, cap*10, 0});\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tint v = node.v, rest = node.rest, cost = node.cost;\n//\t\t\tcout << v << \" \" << rest << \" \" << cost << endl;\n\t\t\tif (cost > dist[v][rest]) continue;\n\t\t\tEACH(e,G[v]) {\n\t\t\t\tint r = rest - e.cost;\n\t\t\t\tif (r < 0) continue;\n\t\t\t\tif (lpg[e.to]) r = cap*10;\n//\t\t\t\tcout << e.to << \" \" << r << \" \" << cost+e.cost << \" \" << dist[e.to][r] << endl;\n\t\t\t\tif (cost+e.cost < dist[e.to][r]) {\n\t\t\t\t\tdist[e.to][r] = cost+e.cost;\n\t\t\t\t\tQ.push({e.to, r, dist[e.to][r]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tREP(i,cap*10+1) ans = min(ans, dist[t][i]);\n\t\tif (ans == inf) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Data{\n\tData(int arg_town,int arg_sum_dist,int arg_fuel){\n\t\ttown = arg_town;\n\t\tsum_dist = arg_sum_dist;\n\t\tfuel = arg_fuel;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t};\n\tint town,sum_dist,fuel;\n};\n\nchar town_table[3000][15];\nbool have_station[3000];\n\nint town_index,N,M,start = 0,goal = 1,capacity;\nint** min_dist;\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(){\n\n\ttown_index = 0;\n\n\tchar left[16],right[16];\n\tscanf(\"%s %s\",left,right);\n\n\tstrcpy(town_table[town_index++],left);\n\tstrcpy(town_table[town_index++],right);\n\n\tint dist;\n\n\tbool FLG;\n\tint left_index,right_index;\n\n\tvector<Info> V[3000];\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s %s %d\",left,right,&dist);\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\tFLG = true;\n\t\t\t\tleft_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tleft_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],left);\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int i = 0; i < town_index;i++){\n\t\t\tif(strCmp(town_table[i],right)){\n\t\t\t\tFLG = true;\n\t\t\t\tright_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\tright_index = town_index;\n\t\t\tstrcpy(town_table[town_index++],right);\n\t\t}\n\n\t\tV[left_index].push_back(Info(right_index,dist));\n\t\tV[right_index].push_back(Info(left_index,dist));\n\t}\n\n\tfor(int i = 0; i < town_index;i++)have_station[i] = false;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%s\",left);\n\t\tfor(int i = 0; i < town_index; i++){\n\t\t\tif(strCmp(town_table[i],left)){\n\t\t\t\thave_station[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < town_index; i++){\n\t\tfor(int k = 0; k <= 10*capacity; k++)min_dist[i][k] = BIG_NUM;\n\t}\n\n\tpriority_queue<Data> Q;\n\n\tmin_dist[0][10*capacity] = 0;\n\tQ.push(Data(0,0,10*capacity));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().town == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().town][Q.top().fuel]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().town].size(); i++){\n\t\t\t\tif(V[Q.top().town][i].dist <= Q.top().fuel){\n\t\t\t\t\t//?????????station?????????\n\t\t\t\t\tif(have_station[V[Q.top().town][i].to]){\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][10*capacity] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][10*capacity] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,10*capacity));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] > Q.top().sum_dist+V[Q.top().town][i].dist){\n\t\t\t\t\t\t\tmin_dist[V[Q.top().town][i].to][Q.top().fuel-V[Q.top().town][i].dist] = Q.top().sum_dist+V[Q.top().town][i].dist;\n\t\t\t\t\t\t\tQ.push(Data(V[Q.top().town][i].to,Q.top().sum_dist+V[Q.top().town][i].dist,Q.top().fuel-V[Q.top().town][i].dist));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\n\tfor(int i = 0; i <= 10*capacity; i++)ans = min(ans,min_dist[1][i]);\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main(){\n\n\tmin_dist = new int*[3000];\n\tfor(int i = 0; i < 3000; i++)min_dist[i] = new int[2001];\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&capacity);\n\t\tif(N == 0 && M == 0 && capacity == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst int NONE=-1;\n\nint main(){\n  int r,m,cap;\n  while(cin>>r>>m>>cap,r|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvp dist;\n    vs cities;\n    REP(i,r){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n        dist.push_back(vp());\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n        dist.push_back(vp());\n      }\n      dist[ai].push_back(make_pair(bi,d));\n      dist[bi].push_back(make_pair(ai,d));\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    int n=cities.size();\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(ii,dist[cnode.index].size()){\n        int i=dist[cnode.index][ii].first;\n        int dd=dist[cnode.index][ii].second;\n        if(i!=cnode.index&&dd!=NONE){\n          ll newcost=cnode.cost+dd;\n          int newgas=cnode.gas-dd;\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( nstat.size(), vector<int>( n, INF ) );\n\tfor( int from = 0; from < nstat.size(); ++from ){\n\t\tint n_from = nstat[from];\n\t\tdist[from][n_from] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, nstat[from] ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_f = p.second;\n\t\t\tif( dist[from][n_f] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_from].size(); ++i ){\n\t\t\t\tint n_to = road[n_from][i].first;\n\t\t\t\tint ds = p.first + road[n_from][i].second;\n\t\t\t\t\n\t\t\t\tif( ds <= cap && dist[from][n_to] > ds ){\n\t\t\t\t\tdist[from][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[from][n_to] <= cap && dp[to] > dp[from] + dist[from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct edge { int to, cost; };\ntypedef pair<int, int> P;\n\nconst int inf = 1000000000;\nconst int max_v = 6000;\nint V;\n//map<string, vector<edge> > G1;\nvector<edge> G1[max_v];\n//map<string, vector<edge> > G2;\nvector<edge> G2[max_v];\nset<string> allcities;\nmap<string, int> ind;\nint d[max_v];\n\n\nvoid dijkstra(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d+V, inf);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (edge e : G1[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nvoid dijkstra2(int s) {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d+V, inf);\n  d[s] = 0;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if (d[v] < p.first) continue;\n    for (edge e : G2[v]) {\n      if (d[e.to] > d[v] + e.cost) {\n\td[e.to] = d[v] + e.cost;\n\tque.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if (n == 0 && m == 0 && cap == 0) break;\n    string src, dest;\n    cin >> src >> dest;\n    for (int i = 0; i < n; i++) {\n      string c1, c2;\n      int dis;\n      cin >> c1 >> c2 >> dis;\n      int i1, i2;\n      if (allcities.find(c1) == allcities.end()) {\n\ti1 = allcities.size();\n\tallcities.insert(c1);\n\tind[c1] = i1;\n      } else {\n\ti1 = ind[c1];\n      }\n      if (allcities.find(c2) == allcities.end()) {\n\ti2 = allcities.size();\n\tallcities.insert(c2);\n\tind[c2] = i2;\n      } else {\n\ti2 = ind[c2];\n      }\n      G1[i1].push_back((edge){i2, dis});\n      G1[i2].push_back((edge){i1, dis});\n    }\n    V = allcities.size();\n    vector<int> lpg(m+2);\n    for (int i = 0; i < m; i++) {\n      string s;\n      cin >> s;\n      lpg[i] = ind[s];\n    }\n    lpg[m] = ind[src]; lpg[m+1] = ind[dest];\n    for (int i = 0; i < m+2; i++) {\n      dijkstra(lpg[i]);\n      for (int j = 0; j < m+2; j++) {\n\tif (j == i) continue;\n\tif (d[lpg[j]] <= 10 * cap)\n\t  G2[lpg[i]].push_back((edge){lpg[j], d[lpg[j]]});\n      }\n    }\n    dijkstra2(lpg[m]);\n    if (d[lpg[m+1]] >= inf)\n      cout << -1 << endl;\n    else\n      cout << d[lpg[m+1]] << endl;\n    for (int i = 0; i < V; i++) {\n      G1[i].clear();\n      G2[i].clear();\n    }\n    allcities.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n \nusing namespace std;\n \n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<14)\n#define EPS 1e-10\n#define MOD 1000000007\n \ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n \nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n \nint N,M,C, V;\nvector<Edge>G[6001];\nstring city[6001];\nchar gs[6001];\nshort dist[2001][6001];\nmap<string,int>recity;\n \nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n \n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    short cap = p.second.first, v = p.second.second, cost = p.first;\n \n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap) continue;\n      short tar = max(cap-e.d, gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n    dist[tar][e.to] = dist[cap][v] + e.d;\n    q.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n \nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n \n    rep(i,3005) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    C *= 10;\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n \n    rep(i,N){\n      string s1, s2; short d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n \n    rep(i,M){\n      string s;  cin >> s;\n      gs[recity[s]] = 1;\n    }\n \n    dijkstra(recity[src]);\n \n    short res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#define mod 1000000007\n#define INF 1<<30\n#define eps 1e-10\nusing namespace std;\nint n,m,cap,tot;\nmap<string,int> mm;\nchar s[20],t[20];\nchar s1[20],t1[20];\nbool flag[6002];\nint s2,t2;\nstruct node\n{\n    int t,ti;\n};\nstruct state\n{\n    short vex,ca;\n};\nvector<node> ve[6002];\nint dp[6002][2020];\nbool vis[6002][2020];\nbool operator < (const state& a,const state& b)\n{\n    return dp[a.vex][a.ca]<dp[b.vex][b.ca];\n}\n\nvoid dijkstra(int s,int t)\n{\n    priority_queue<state> q;\n    for(int i=1;i<tot;i++)\n    for(int j=0;j<=cap;j++) {dp[i][j]=INF;vis[i][j]=0;}\n    dp[s][cap]=0;state ss;ss.vex=s;ss.ca=cap;q.push(ss);\n    while(!q.empty())\n    {\n        ss=q.top();q.pop();\n        if(vis[ss.vex][ss.ca]) continue;\n        //cout<<ss.vex<<\" \"<<ss.ca<<\" \"<<dp[ss.vex][ss.ca]<<endl;\n        if(ss.vex==t) return;\n        vis[ss.vex][ss.ca]=1;\n        for(int i=0;i<ve[ss.vex].size();i++)\n        {\n            node no=ve[ss.vex][i];\n            if(ss.ca<no.ti) continue;\n            int cc=ss.ca-no.ti;\n            if(flag[no.t]) cc=cap;\n            if(dp[ss.vex][ss.ca]+no.ti<dp[no.t][cc])\n            {\n                dp[no.t][cc]=dp[ss.vex][ss.ca]+no.ti;\n                state ss2;ss2.vex=no.t;ss2.ca=cc;\n                q.push(ss2);\n            }\n        }\n    }\n}\nmain()\n{\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&n,&m,&cap),n+m+cap)\n    {\n        tot=1;int dd;cap*=10;\n        scanf(\"%s%s\",s1,t1);\n        memset(ve,0,sizeof(ve));\n        memset(flag,0,sizeof(flag));\n        mm.clear();\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%s%s%d\",s,t,&dd);int ss,tt;\n            if(mm[s]==0)\n            {\n                mm[s]=tot++;ss=tot-1;\n            }\n            else\n            ss=mm[s];\n            if(mm[t]==0)\n            {\n                mm[t]=tot++;tt=tot-1;\n            }\n            else\n            tt=mm[t];\n            node no;no.t=tt;no.ti=dd;ve[ss].push_back(no);\n            no.t=ss;ve[tt].push_back(no);\n        }\n        s2=mm[s1];t2=mm[t1];\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%s\",s);flag[mm[s]]=1;\n        }\n        dijkstra(s2,t2);\n        int ans=INF;\n        for(int i=0;i<=cap;i++)\n        ans=min(ans,dp[t2][i]);\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    while(1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvector<int> dijkstra(int n, int s, vector<vector<int>>& g){\n\tvector<int> dis(n,1e8);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tint cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis;\n}\n\nint main(){\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tmap<string,int> id;\n\t\tstring src, dist;\n\t\tcin >> src >> dist;\n\t\tid[src] = id.size();\n\t\tid[dist] = id.size();\n\n\t\tvector<string> a(n), b(n);\n\t\tvector<int> c(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tif(not id.count(a[i])) id[a[i]] = id.size();\n\t\t\tif(not id.count(b[i])) id[b[i]] = id.size();\n\t\t}\n\n\t\tvector<string> sta(m);\n\t\trep(i,m){\n\t\t\tcin >> sta[i];\n\t\t\tif(not id.count(sta[i])) id[sta[i]] = id.size();\n\t\t}\n\n\t\tvector<vector<int>> g(id.size(), vector<int>(id.size(), 1e8));\n\t\trep(i,n){\n\t\t\tint x = id[a[i]], y = id[b[i]];\n\t\t\tg[x][y] = g[y][x] = c[i];\n\t\t}\n\n\t\tvector<vector<int>> ng(id.size(), vector<int>(id.size(), 1e8));\n\t\trep(i,m){\n\t\t\tint x = id[sta[i]];\n\t\t\tvector<int> dis = dijkstra(id.size(), x, g);\n\t\t\trep(j,m){\n\t\t\t\tint y = id[sta[j]];\n\t\t\t\tif(dis[y] > cap) continue;\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t\tint y = id[dist];\n\t\t\tdis = dijkstra(id.size(), x, g);\n\t\t\tif(dis[y] <= cap){\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint x = id[src];\n\t\t\tvector<int> dis = dijkstra(id.size(), x, g);\n\t\t\trep(j,m){\n\t\t\t\tint y = id[sta[j]];\n\t\t\t\tif(dis[y] > cap) continue;\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t\tint y = id[dist];\n\t\t\tdis = dijkstra(id.size(), x, g);\n\t\t\tif(dis[y] <= cap){\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,id.size()){\n\t\t//\trep(j,id.size()){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint ans = dijkstra(id.size(), id[src], ng).at(id[dist]);\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tif(to == dst_id){\n\t  res = s.dist + dist;\n\t  break;\n\t}\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[301];\nint nodes[3001][3001];\nbool is_LPG[3001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 7000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\n\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint D[N][N];\nint dijkstra(){\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++) D[i][j]=INF;\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {\n      cin>>a;\n      if(M.count(a))ls[M[a]]=1;\n    }\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=p.s.s;\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[v][p.s.s]==INF || ( d[e.to][nc] > d[v][p.s.s]+e.cost)){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \tif(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d<p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d = 0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap < 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  d[v.cap][p.second] = d[u.cap][p.first] + m[p];\n\t  v.str = p.second;\n\t  v.cap = cap;\n\t  v.d = d[cap][p.second];\n\t  Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[300][22];\nint w[3000];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    vector<string> node;\n    scanf(\"%s%s\",s,t);\n    node.push_back(s);\n    node.push_back(t);\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    int sz = node.size();\n    g.clear();\n    cost.clear();\n    sta.clear();\n    g.resize(sz,vector<edge>());\n    cost.resize(sz,vector<int>(cap*10+1));\n    sta.resize(sz);\n    for( int i = 0; i < sz; i++ ) {\n      sta[i] = false;\n      for( int j = 0; j <= cap*10; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 6001;\nconst int MAX_CAP = 2002;\n\nstruct Edge {\n  int to, cost;\n  Edge() {}\n  Edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct State {\n  int p, cost, oil;\n  State() {}\n  State(int p, int cost, int oil) : p(p), cost(cost), oil(oil) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(oil != s.oil) return oil < s.oil;\n    return p < s.p;\n  }\n};\n\nint Cap, num, Src, Dist;\n\nmap<string, int> id;\nvector<Edge> E[MAX_N];\n\nbool existS[MAX_N];\nbool cost[MAX_N][MAX_CAP];\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = num++;\n  }\n  return id[s];\n}\n\n\nint solve() {\n  priority_queue<State> que;\n  State s(Src, 0, Cap);\n  que.push(s);\n  fill(cost[0], cost[num], 0);\n  while(!que.empty()) {\n\n    s = que.top(); que.pop();\n    //    cout << s.p << \", \" << s.cost << \", \" << s.oil << endl;\n    if(cost[s.p][s.oil]) continue;\n    cost[s.p][s.oil] = true;\n\n    if(s.p == Dist) return s.cost;\n\n    for(int i = 0; i < E[s.p].size(); ++i) {\n      int nextOil = s.oil - E[s.p][i].cost;\n      if(nextOil < 0) continue;\n      if(existS[E[s.p][i].to]) nextOil = Cap;\n      if(cost[E[s.p][i].to][nextOil]) continue;\n\n      que.push(State(E[s.p][i].to, s.cost + E[s.p][i].cost, nextOil));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M >> Cap && (N | M | Cap)) {\n    num = 0;\n    Cap *= 10;\n    id.clear();\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n\n    string src, dist;\n    cin >> src >> dist;\n    Src = getId(src);\n    Dist = getId(dist);\n    for(int i = 0; i < N; ++i) {\n      string from, to;\n      int d;\n      cin >> from >> to >> d;\n      E[getId(from)].push_back(Edge(getId(to), d));\n      E[getId(to)].push_back(Edge(getId(from), d));\n    }\n\n    fill(existS, existS+MAX_N, false);\n    for(int i = 0; i < M; ++i) {\n      string name;\n      cin >> name;\n      existS[getId(name)] = true;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> g[6000];\nbool f[6000];\n//int dist[6000][2010];\n\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tfor (int i = 0; i < 6000; i++) g[i].clear();\n\t\tmemset(f, 0, sizeof(f));\n\t\tcap *= 10;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tmap<string, int> mp;\n\t\tmp[src] = mp.size() - 1;\n\t\tmp[dst] = mp.size() - 1;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring a, b;\n\t\t\tint c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!mp.count(a)) mp[a] = mp.size() - 1;\n\t\t\tif (!mp.count(b)) mp[b] = mp.size() - 1;\n\t\t\tg[mp[a]].emplace_back(mp[b], c);\n\t\t\tg[mp[b]].emplace_back(mp[a], c);\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf[mp[s]] = true;\n\t\t}\n\t\tvector<vector<int>> dist(mp.size(), vector<int>(cap + 1, 1 << 28));\n\t\t//fill_n(*dist, 6000 * 2010, 1 << 28);\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\t\tdist[0][cap] = 0;\n\t\tpq.push(make_tuple(0, 0, cap));\n\t\tint goal = mp[dst];\n\t\tint res = -1;\n\t\twhile (pq.size()){\n\t\t\tint s, v, r;\n\t\t\ttie(s, v, r) = pq.top(); pq.pop();\n\t\t\tif (v == goal){\n\t\t\t\tres = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dist[v][r] < s) continue;\n\t\t\tif (f[v]) r = cap;\n\t\t\tfor (pair<int, int> &e : g[v]){\n\t\t\t\tif (r < e.second) continue;\n\t\t\t\tif (dist[e.first][r - e.second] > s + e.second){\n\t\t\t\t\tdist[e.first][r - e.second] = s + e.second;\n\t\t\t\t\tpq.push(make_tuple(s + e.second, e.first, r - e.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[now.id][now.c]-c);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<30;\n\nstruct P{\n    int s1;\n    int s2;\n    int d;\n    P(){}\n    ~P(){}\n    P(int a, int b, int c) : s1(a), s2(b), d(c) {}\n    P(const P& r) : s1(r.s1), s2(r.s2), d(r.d) {}\n    bool operator < (const P& r) const {\n        return (s1 == r.s1 ? s2 < r.s2 : s1 < r.s1);\n    }\n};\n\nstruct Q{\n    int pos;\n    int fuel;\n    int dist;\n    vector<int> visited;\n    Q(){}\n    ~Q(){\n        vector<int>().swap(visited);\n    }\n    Q(int p, int f, int d, vector<int> v) : pos(p), fuel(f), dist(d), visited(v) {}\n    Q(const Q& r) : pos(r.pos), fuel(r.fuel), dist(r.dist), visited(r.visited) {}\n};\n\ntypedef pair<int, int> PR;\n\nint main(){\n    int n, m, cap, x;\n    vector<int> EMPTY;\n    vector<P> path(6000);\n    while(cin >> n >> m >> cap, n||m||cap){\n        string src, dest;\n        cin >> src >> dest;\n        map<string, int> name;\n        name[src] = 0;\n        name[dest] = 1;\n        int nn = 2;\n        string c1, c2;\n        int d;\n        for(x = 0; x < n; x++){\n            cin >> c1 >> c2 >> d;\n            if( name.find(c1) == name.end() ){\n                name[c1] = nn++;\n            }\n            if( name.find(c2) == name.end() ){\n                name[c2] = nn++;\n            }\n            path.push_back( P(name[c1], name[c2], d) );\n            path.push_back( P(name[c2], name[c1], d) );\n        }\n        sort(path.begin(), path.end());\n        vector<bool> gs(nn, 0);\n        vector<int> mindist(nn, INF);\n        vector<int> withfuel(nn, 0);\n        mindist[0] = 0;\n        for(x = 0; x < m; x++){\n            cin >> c1;\n            gs[ name[c1] ] = 1;\n        }\n        queue< Q > que;\n        que.push( Q(0, cap*10, 0, EMPTY) );\n        while( !que.empty() ){\n            Q q = que.front();\n            que.pop();\n            vector<P>::iterator begin = lower_bound(path.begin(), path.end(),\n                                                    P(q.pos, -1, -1));\n            vector<P>::iterator end = lower_bound(path.begin(), path.end(),\n                                                  P(q.pos+1, -1, -1));\n            for(vector<P>::iterator nxt = begin;\n                    nxt != end; nxt++){\n                if( nxt->d > q.fuel ){ continue; }\n                if( q.dist + nxt->d < mindist[nxt->s2] ){\n                    mindist[nxt->s2] = q.dist + nxt->d;\n                    withfuel[nxt->s2] = (gs[nxt->s2]?cap*10:(q.fuel-nxt->d));\n                }else if( gs[nxt->s2] ){\n                    continue;\n                }else if( q.fuel-nxt->d < withfuel[nxt->s2] ){\n                    continue;\n                }\n                if( nxt->s2 == 1 ){ continue; }\n                bool ok = true;\n                for(vector<int>::iterator itr = q.visited.begin();\n                        itr != q.visited.end(); itr++){\n                    if( *itr == nxt->s2 ){\n                        ok = false;\n                        break;\n                    }\n                }\n                if( !ok ) continue;\n                vector<int> nv = q.visited;\n                nv.push_back(q.pos);\n                if( gs[ nxt->s2 ] ){\n                    que.push( Q(nxt->s2, cap*10, q.dist+nxt->d, nv) );\n                }else{\n                    que.push( Q(nxt->s2, q.fuel - nxt->d, q.dist+nxt->d, nv) );\n                }\n                vector<int>().swap(nv);\n            }\n        }\n        cout << ((mindist[1] == INF) ? -1 : mindist[1]) << endl;\n        vector<P>().swap(path);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVVP G;\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++,G.push_back(VP());\n  if(index.find(t) == index.end())index[t] = idx++,G.push_back(VP());\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      G.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++,G.push_back(VP());\n      index[sdest] = idx++,G.push_back(VP());\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx <= MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 100000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n     \n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n   \t\t d[e.to] = d[v]+e.cost;\n   \t\t que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1<<30\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1,c2;\nint d;\nstring s;\nbool gas[6100];\nint num;\nvector<P> G[6100];\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    cap *= 10;\n    map<string,int> id;\n    num = 0;\n    id[src] = num++; id[dest] = num++;\n\n    for(int i=0;i<6100;i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      cin >> c1 >> c2 >> d;\n      if(id.find(c1) == id.end())id[c1] = num++;\n      if(id.find(c2) == id.end())id[c2] = num++;\n      G[id[c1]].push_back(P(d,id[c2]));\n      G[id[c2]].push_back(P(d,id[c1]));\n    }\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s;\n      gas[id[s]] = true;\n    }\n\n    map<P,int> dis;\n    dis[P(id[src],cap)] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      int dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      if(pos == id[dest])break;\n\n      for(int i=0;i<G[pos].size();i++){\n\tint len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\tif(len > tank)continue;\n\tint ntank = tank - len;\n\tif(gas[nxt])ntank = cap;\n\tif(dis.find(P(nxt,ntank)) == dis.end()){\n\t  dis[P(nxt,ntank)] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++){\n      if(dis.find(P(id[dest],i)) != dis.end())ans = min(ans,dis[P(id[dest],i)]);\n    }\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\u0010#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6000];\nstring city[6000];\nint gs[6000];\nint dist[256][6000];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+2) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n    //    cout << cost << \" \" << v << \" \" << cap << endl;\n    if(dist[cap][v] < cost) continue;\n    //    cout << G[v].size() << endl;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      //      cout << e.d << \" \" << cap << endl;\n      if(e.d > cap*10) continue;\n      int tar = max(cap-(e.d/10 + (e.d%10?1:0)), gs[e.to]*C);\n      //      cout << tar << \" \" << e.to << \" \" << dist[tar][e.to] << \" \" << dist[cap][v] << \" \" << e.d << endl;\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\t//\tcout << tar << endl;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n    rep(i,6000) G[i].clear();\n    recity.clear();\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n    rep(i,M){\n      string s;\n      cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    /*    rep(i, V){\n      cout << city[i] << endl;\n      rep(j, G[i].size()) cout << G[i][j].to << \" \"; cout << endl;\n      }*/\n\n    dijkstra(recity[src]);\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 2010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 1; j < MAX_V; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> st;\n\t\tst.insert(src), st.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) st.insert(c1[i]), st.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : st) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(cnt);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n\nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n\nint n, m, cap, dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\n\ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      sid.emplace(s0, sid.size());\n      adj[sid.size()].clear();\n    }\n    if(!sid.count(s1)) {\n      sid.emplace(s1, sid.size());\n      adj[sid.size()].clear();\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  //cerr << \"# nodes = \" << mid << endl;\n  fill(dis, dis+mid, INF);\n  dis[0] = 0;\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    //cerr << \"cost \" << nxt0.F << \" id \" << nxt0.S << endl;\n\n    vector<int> tmp_dis(mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    if(tmp_dis[1] != INF)\n      return tmp_dis[1];\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  if(dis[1] == INF)\n    return -1;\n  else\n    return dis[1];\n}\n\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    dp[get_city_id(cities,src)][10*capacity] = true;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tif(to == dst_id){\n\t  res = s.dist + dist;\n\t  goto found;\n\t}\n\n\tif(dp[to][next_remaining_LPG]) continue;\n\tdp[to][next_remaining_LPG] = true;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\ntemplate <typename T>\nvector<int> dijkstra(const vector<vector<pair<int,T>>> &G,int s,T inf) {\n  vector<int> d(G.size(),inf);\n  d[s] = 0;\n  using P = pair<T,int>;\n  priority_queue<P,vector<P>,greater<P>> que;\n  que.emplace(0,s);\n  while (!que.empty()) {\n    T dd; int v;\n    tie(dd,v) = que.top(); que.pop();\n    if (d[v] < dd) continue;\n    for (auto e : G[v]) {\n      if (d[e.first] > d[v]+e.second) {\n        d[e.first] = d[v]+e.second;\n        que.emplace(d[e.first],e.first);\n      }\n    }\n  }\n  return d;\n}\n\nint N,M,cap;\nstring src,dst;\nstring c[2][3010];\nint d[3010];\nstring s[310];\nint dis[310][310];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> M >> cap, N) {\n    cin >> src >> dst;\n    map<string,int> mp;\n    mp[src] = mp.size();\n    mp[dst] = mp.size();\n    REP(i,N) {\n      cin >> c[0][i] >> c[1][i] >> d[i];\n      if (mp.count(c[0][i]) == 0) mp[c[0][i]] = mp.size();\n      if (mp.count(c[1][i]) == 0) mp[c[1][i]] = mp.size();\n    }\n    REP(i,M) {\n      cin >> s[i];\n      if (mp.count(s[i]) == 0) mp[s[i]] = mp.size();\n    }\n    vector<vector<pii>> G(3010);\n    REP(i,N) {\n      int u = mp[c[0][i]];\n      int v = mp[c[1][i]];\n      G[u].emplace_back(v,d[i]);\n      G[v].emplace_back(u,d[i]);\n    }\n    map<int,int> cnv;\n    vector<string> inv_cnv(310);\n    REP(i,M) {\n      inv_cnv[cnv.size()] = s[i];\n      cnv[mp[s[i]]] = cnv.size()-1;\n    }\n    if (cnv.count(mp[src]) == 0) {\n      inv_cnv[cnv.size()] = src;\n      cnv[mp[src]] = cnv.size()-1;\n    }\n    if (cnv.count(mp[dst]) == 0) {\n      inv_cnv[cnv.size()] = dst;\n      cnv[mp[dst]] = cnv.size()-1;\n    }\n    \n\n    MINF(dis);\n    int sz = G.size();\n    REP(i,cnv.size()) {\n      vector<int> dd = dijkstra<int>(G,mp[inv_cnv[i]],INF);\n      for (int j = 0; j < sz; j++) {\n        if (cnv.count(j) && dd[j] <= cap*10) {\n          dis[i][cnv[j]] = dis[cnv[j]][i] = dd[j];\n        }\n      }\n    }\n    REP(k,cnv.size()) REP(i,cnv.size()) REP(j,cnv.size()) {\n      CHMIN(dis[i][j],dis[i][k]+dis[k][j]);\n    }\n    int ans = dis[cnv[mp[src]]][cnv[mp[dst]]];\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nstruct Edge {\n  int dst, dist;\n  Edge(int dst, int dist): dst(dst), dist(dist) {}\n};\n\nstruct State {\n  int city, rest, cost;\n  State(int city, int rest, int cost): city(city), rest(rest), cost(cost) {}\n  bool operator<(const State& rhs) const { return cost > rhs.cost; }\n};\n\ninline int add_name(map<string, int>& name2id, const string& name) {\n  if (name2id.count(name)) {\n    return name2id[name];\n  } else {\n    int id = name2id.size();\n    return name2id[name] = id;\n  }\n}\n\nvector<Edge> edges[6010];\nbool has_lpg[6010];\nbool visit[6010][2010];\nint cost[6010][2010];\n\nint main() {\n  int N, M, cap;\n  while (scanf(\"%d%d%d\", &N, &M, &cap), N|M|cap) {\n    map<string, int> name2id;\n    string src_name, dst_name;\n\n    memset(has_lpg, false, sizeof(has_lpg));\n    memset(visit, false, sizeof(visit));\n    memset(cost, 0x0f, sizeof(cost));\n\n    cin >> src_name >> dst_name;\n    int src = add_name(name2id, src_name);\n    int dst = add_name(name2id, dst_name);\n    REP(i, N) {\n      int dist;\n      cin >> src_name >> dst_name >> dist;\n      int s = add_name(name2id, src_name);\n      int t = add_name(name2id, dst_name);\n      edges[s].push_back(Edge(t, dist));\n      edges[t].push_back(Edge(s, dist));\n    }\n    REP(i, M) {\n      cin >> src_name;\n      has_lpg[name2id[src_name]] = true;\n    }\n\n    priority_queue<State> Q;\n    Q.push(State(src, 10 * cap, 0));\n    cost[src][10 * cap] = 0;\n    int ans = -1;\n\n    while (!Q.empty()) {\n      int city = Q.top().city;\n      int rest = Q.top().rest;\n      Q.pop();\n\n      if (visit[city][rest]) { continue; }\n      visit[city][rest] = true;\n      if (city == dst) {\n        ans = cost[city][rest];\n        break;\n      }\n\n      FOREACH(it, edges[city]) {\n        int new_city = it->dst;\n        if (rest < it->dist) { continue; }\n        int new_rest = has_lpg[new_city] ? 10 * cap : rest - it->dist;\n        int new_cost = cost[city][rest] + it->dist;\n        if (new_cost >= cost[new_city][new_rest]) { continue; }\n        cost[new_city][new_rest] = new_cost;\n        Q.push(State(new_city, new_rest, new_cost));\n      }\n    }\n\n    cout << ans << endl;\n\n    REP(i, name2id.size()) { edges[i].clear(); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nconst int inf = numeric_limits<int>::max() / 3;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int to_,int cost_) : to(to_) , cost(cost_) {}\n};\n\nint N,M,cap;\nint src,dest;\nvector<edge> g[4000];\n\nvoid solve(){\n    for(int i=0;i<4000;i++) g[i] = vector<edge>();\n    string srcc,destt;\n    cap *= 10;\n    cin >> srcc >> destt;\n    int namecount=0;\n    map<string,int> names;\n    for(int i=0;i<N;i++){\n        string c1,c2;\n        int dist;\n        cin >> c1 >> c2 >> dist;\n        if(!names.count(c1)){\n            names[c1] = namecount++;\n        }\n        if(!names.count(c2)){\n            names[c2] = namecount++;\n        }\n\n        g[names[c1]].push_back(edge(names[c2],dist));\n        g[names[c2]].push_back(edge(names[c1],dist));\n    }\n\n    if(!names.count(srcc)){\n        names[srcc] = namecount++;\n    }\n    if(!names.count(destt)){\n        names[destt] = namecount++;\n    }\n    int src = names[srcc];\n    int dest = names[destt];\n\n    set<int> s;\n    for(int i=0;i<M;i++){\n        string ss;cin >> ss;\n        s.insert(names[ss]);\n    }\n\n    using Vertex = pair<int,int>; // ?????????????,???????????¨\n    using State = pair<int,Vertex>; // ????????????¢, ????????????? \n\n    // dist[?????????????][?????£?????????????¨??????????????¢???????\\] = ?????????????????????????¢\n    vector<vector<int>> dist(4000,vector<int>(300,inf));\n    \n    priority_queue<State,vector<State>,greater<State>> que;\n    que.push(State(0,Vertex(src,cap)));\n    dist[src][cap] = 0;\n\n    for(auto p : names) cerr << p.first << \" \" << p.second << endl;\n\n    while(!que.empty()){\n        int d = que.top().first;\n        Vertex v = que.top().second;\n        que.pop();\n        \n        int node = v.first;\n        int c = v.second;\n\n        cerr << node << \" \" << c << \" \" << d << endl;\n\n        if(s.count(node)){\n            c = cap;\n        }\n\n        for(edge& e : g[node]){\n            int ncap = c - e.cost;\n            cerr << \"e = \" << e.to << \" \" << e.cost << endl;\n            if(ncap < 0) continue;\n            if(dist[e.to][ncap] > d + e.cost){\n                cerr << \"push \" << e.to << \" \" << ncap << endl;\n                dist[e.to][ncap] = d + e.cost; \n                que.push(State(dist[e.to][ncap],Vertex(e.to,ncap)));\n            }\n        }\n    }\n\n    int ans = inf;\n    for(int i=0;i<300;i++) ans = min(ans,dist[dest][i]);\n\n    if(ans==inf) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N >> M >> cap;\n        if(N==0 and M==0 and cap==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\t// if(u == goal) dist[u][lpg];\n\t\t// printf(\"cost %d u %d lpg %d\\n\", cost, u, lpg);\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto& tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\t// printf(\"v %d di %d nlpg %d ncost %d\\n\", v, di, nlpg, ncost);\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\t// printf(\"dist[%d][%d] = %d\\n\", v, cap, ncost);\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\t// printf(\"dist[%d][%d] = %d\\n\", v, nlpg, ncost);\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap * 10 + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: 1412kid1412@UESTC\n*/\n\n#include <stdexcept>\n#include <cstdarg>\n#include <iostream>\n#include <fstream>\n#include <exception>\n#include <memory>\n#include <locale>\n#include <sstream>\n#include <set>\n#include <list>\n#include <bitset>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <string>\n#include <utility>\n#include <cctype>\n#include <climits>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <cstdlib>\n#include <stack>\n#include <iterator>\n#include <functional>\n#include <complex>\n#include <valarray>\nusing namespace std;\n\nint dis[3010][2010];\nint inq[3010][2010];\nmap<string,int> idx;\nmap<int,int>nidx;\nstruct Edge{\n\tint v,d;\n\tEdge(){\n\t}\n\tEdge(int v,int d):v(v),d(d){\n\t}\n};\nvector<Edge> G[6010];\nbool can[6010];\nbool reach[6010];\nvoid dfs(int u)\n{\n    reach[u]=1;\n    int sz=G[u].size();\n    for(int i=0;i<sz;i++)\n        if(!reach[G[u][i].v])\n    {\n        dfs(G[u][i].v);\n    }\n}\nint spfa(int s,int t,int cap){\n\tmemset(dis,63,sizeof(dis));\n\tmemset(inq,0,sizeof(inq));\n\tint ret=(dis[0][0]);\n\tint oo=ret;\n\tqueue<pair<int,int> > que;\n\tque.push(make_pair(s,cap));\n\tinq[nidx[s]][cap]=true;\n\tdis[nidx[s]][cap]=0;\n\n\twhile(!que.empty()){\n\t\tpair<int,int> u=que.front();\n\t\tque.pop();\n\t\tinq[nidx[u.first]][u.second]=false;\n\t\tint sz=G[u.first].size();\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tint v=G[u.first][i].v;\n\t\t\tif(!nidx.count(v))continue;\n\t\t\tif(u.second<=G[u.first][i].d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nowcap=u.second-G[u.first][i].d;\n\t\t\tif(can[v]){\n\t\t\t\tnowcap=cap;\n\t\t\t}\n\t\t\tif(dis[nidx[v]][nowcap]>dis[nidx[u.first]][u.second]+G[u.first][i].d){\n\t\t\t\tdis[nidx[v]][nowcap]=dis[nidx[u.first]][u.second]+G[u.first][i].d;\n\t\t\t\tif(!inq[nidx[v]][nowcap]){\n\t\t\t\t\tinq[nidx[v]][nowcap]=true;\n\t\t\t\t\tque.push(make_pair(v,nowcap));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=cap;i++){\n\t\tret=min(ret,dis[nidx[t]][i]);\n\t}\n\tif(ret==oo){\n\t\tret=-1;\n\t}\n\treturn ret;\n}\nint main(){\n\tint road,load,cap;\n\twhile(scanf(\"%d%d%d\",&road,&load,&cap)){\n \t\tidx.clear();\n   \t\tnidx.clear();\n     \tmemset(reach,0,sizeof(reach));\n\t\tcap*=10;\n\t\tif(0==road&&0==load&&0==cap){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(can,0,sizeof(can));\n\t\tfor(int i=0;i<=6000;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tint cnt=0;\n\t\tint S,T;\n\t\tstring a,b;\n\t\tcin>>a>>b;\n\t\tif(!idx.count(a)){\n\t\t\tidx[a]=cnt++;\n\t\t}\n\t\tif(!idx.count(b)){\n\t\t\tidx[b]=cnt++;\n\t\t}\n\t\tS=idx[a];\n\t\tT=idx[b];\n\t\tfor(int i=0;i<road;i++){\n\t\t\tstring a,b;\n\t\t\tint x;\n\t\t\tcin>>a>>b;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(!idx.count(a)){\n\t\t\t\tidx[a]=cnt++;\n\t\t\t}\n\t\t\tif(!idx.count(b)){\n\t\t\t\tidx[b]=cnt++;\n\t\t\t}\n\t\t\tint u=idx[a];\n\t\t\tint v=idx[b];\n\t\t\t//cout<<u<<\" \"<<v<<\" \"<<x<<endl;\n\t\t\tG[u].push_back(Edge(v,x));\n\t\t\tG[v].push_back(Edge(u,x));\n\t\t}\n\t\tfor(int i=0;i<load;i++){\n\t\t\tstring a;\n\t\t\tcin>>a;\n\t\t\tif(!idx.count(a)){\n\t\t\t\tidx[a]=cnt++;\n\t\t\t}\n\t\t\tint x=idx[a];\n\t\t\tcan[x]=true;\n\t\t}\n\t\tint ncnt=0;\n\t\tnidx[S]=ncnt++;\n\t\tnidx[T]=ncnt++;\n\t\tdfs(S);\n\t\tfor(int i=0;i<cnt;i++)\n          if(reach[i])\n        {\n         nidx[i]=ncnt++;\n        }\n\t\tprintf(\"%d\\n\",spfa(S,T,cap));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tint dis;\n\tint gas;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.dis> r.dis;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tcap *= 10;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tint num = 2;\n\t\tvector<vector<pair<int, int>>>edges(6000);\n\t\tstring sta, goa; cin >> sta >> goa; mp[sta] = 0; mp[goa] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring f, t; cin >> f >> t;\n\t\t\tint dis; cin >> dis;\n\t\t\tif (!mp.count(f)) {\n\t\t\t\tmp[f] = num++;\n\t\t\t}\n\t\t\tif (!mp.count(t)) {\n\t\t\t\tmp[t] = num++;\n\t\t\t}\n\t\t\tconst int fid = mp[f];\n\t\t\tconst int tid = mp[t];\n\t\t\tedges[fid].push_back(make_pair(tid, dis));\n\t\t\tedges[tid].push_back(make_pair(fid, dis));\n\t\t}\n\t\tedges.resize(mp.size());\n\t\tvector<bool>stat(edges.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\t\t\t\tstat[mp[st]] = true;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>mindiss(mp.size(), vector<int>(cap + 1, 99999999));\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,0,cap });\n\t\tmindiss[0][cap] = 0;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int pregas = atop.gas;\n\t\t\tconst int nowdis = atop.dis;\n\t\t\tif (atop.now == 1)break;\n\t\t\t\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (pregas >= i.second) {\n\t\t\t\t\tconst int newid = i.first;\n\t\t\t\t\tconst int newgas = stat[newid]?cap:atop.gas - i.second;\n\t\t\t\t\tconst int newdis = nowdis + i.second;\n\t\t\t\t\tif (mindiss[newid][newgas]> newdis) {\n\t\t\t\t\t\tmindiss[newid][newgas] = newdis;\n\t\t\t\t\t\tque.push(aa{ newid, newdis ,newgas });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\tfor (int i = 0; i < cap + 1; ++i) {\n\t\t\tans = min(mindiss[1][i], ans);\n\t\t}\n\t\tif (ans == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#include <climits>\n\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\nusing namespace boost;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n  int size() { return _m.size(); }\n};\n\nint main(){\n  int n, m, cap;\n\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> n >> m >> cap, n + m + cap){\n    IdMaker<string> idm;\n    vector<vector<pair<int, int> > > edge(2 * n);\n    string buff;\n    int src, dst;\n\n    cin >> buff; src = idm.getId(buff);\n    cin >> buff; dst = idm.getId(buff);\n\n    REP(i,n){\n      string a, b;\n      int l;\n      cin >> a >> b >> l;\n\n      int aa = idm.getId(a);\n      int bb = idm.getId(b);\n\n      edge[aa].push_back(make_pair(bb, l));\n      edge[bb].push_back(make_pair(aa, l));\n    }\n\n    edge.resize(idm.size());\n\n    vector<bool> gas(edge.size(), false);\n\n    REP(i,m){\n      cin >> buff;\n      gas[idm.getId(buff)] = true;\n    }\n\n    cap *= 10;\n    vector<vector<int> > memo(edge.size(), vector<int>(cap + 1, INT_MAX));\n    typedef boost::tuple<int, int, int> data;\n    const int distance = 0;\n    const int liter    = 1;\n    const int pos      = 2;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(make_tuple(0, cap, src));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n\n      int dd = d.get<distance>();\n      int lt = d.get<liter>();\n      int pp = d.get<pos>();\n\n      if(memo[pp][lt] < dd) continue;\n      memo[pp][lt] = dd;\n\n      if(pp == dst){\n        cout << dd << endl;\n        pq.push(make_tuple(0, 0, 0)); // dammy\n        break;\n      }\n\n      REP(i, edge[pp].size()){\n        int next = edge[pp][i].first;\n        int len  = edge[pp][i].second;\n        int llt  = lt - len;\n\n        if(llt >= 0){\n          if(gas[next]) llt = cap;\n          if(memo[next][llt] > dd + len){\n            memo[next][llt] = dd + len;\n            pq.push(make_tuple(dd + len, llt, next));\n          }\n        }\n      }\n    }\n\n    if(pq.empty()){\n      cout << \"-1\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\ntypedef vector<vector<Edge> > Graph;\n\nconst int MAXN = 6000;\nint cap, src, dst;\nGraph G;\nbool lpg[MAXN];\nmap<string, int> id;\n\nvoid init() {\n  id.clear();\n  G.clear();\n  memset(lpg, 0, sizeof(lpg));\n}\n\nint get_id(const string &s) {\n  if (!id.count(s)) {\n    int tmp = id.size();\n    id[s] = tmp;\n  }\n  return id[s];\n}\n\nvoid add_edge(int a, int b, int w) {\n  if (G.size() <= max(a, b)) {\n    G.resize(max(a, b) + 1);\n  }\n  G[a].push_back((Edge){b, w});\n  G[b].push_back((Edge){a, w});\n}\n\nstruct State {\n  int v, gas, w;\n  bool operator < (const State &s) const {\n    return w > s.w;\n  }\n};\n\nint dijkstra() {\n  const static int INF = 1<<28;\n  int N = G.size();\n  vector<vector<int> > cost(N, vector<int>(cap + 1, INF));\n  priority_queue<State> que;\n  cost[src][cap] = 0;\n  que.push((State){src, cap, 0});\n  while (que.size()) {\n    const State s = que.top();\n    que.pop();\n    if (cost[s.v][s.gas] < s.w) continue;\n    if (s.v == dst) return s.w;\n    for (int i = 0; i < G[s.v].size(); ++i) {\n      const Edge &e = G[s.v][i];\n      if (s.gas - e.w < 0) continue;\n      const State t = {e.v,\n                       lpg[e.v] ? cap : s.gas - e.w,\n                       s.w + e.w};\n      if (cost[t.v][t.gas] <= t.w) continue;\n      cost[t.v][t.gas] = t.w;\n      que.push(t);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  for(int n, m; cin >> n >> m >> cap && (n|m|cap); ) {\n    cap *= 10;\n    init();\n    string s, t;\n    cin >> s >> t;\n    src = get_id(s);\n    dst = get_id(t);\n    for (int i = 0, w; i < n; ++i) {\n      cin >> s >> t >> w;\n      add_edge(get_id(s), get_id(t), w);\n    }\n    for (int i = 0; i < m; ++i) {\n      cin >> s;\n      lpg[get_id(s)] = true;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <queue>\n \nusing namespace std;\n \nstruct edge{\n  int to;\n  int cost;\n};\n \nint d[2001][6011];\nvector<edge> G[6011];\nbool isGas[10001];\nmap<string,int> m;\nint idx;\nint st,gl;\n \nint N,M,cap;\nconst int INF=1<<30;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> Sit;\n \nint dijkstra(){\n  for(int i=0;i<2001;i++)\n    for(int j=0;j<6011;j++)\n      d[i][j]=INF;\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  pq.push(make_pair(0,pii(cap*10,st)));\n  d[cap*10][st]=0;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int ccost=p.first;\n    int ccap=p.second.first;\n    int cnode=p.second.second;\n    if(d[ccap][cnode]<ccost)continue;\n    for(int i=0;i<(int)G[cnode].size();i++){\n      edge &e=G[cnode][i];\n      int ncap=ccap-e.cost;\n      if(ncap<0)continue;\n      int nnode=e.to;\n      int ncost=ccost+e.cost;\n      if(isGas[nnode])ncap=cap*10;\n      if(d[ncap][nnode]>ncost){\n    d[ncap][nnode]=ncost;\n    pq.push(make_pair(ncost,pii(ncap,nnode)));\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<2001;i++)\n    res=min(res,d[i][gl]);\n  return res;\n}\n \nint main(){\n  while(cin>>N>>M>>cap&&(N|M|cap)){\n    memset(isGas,0,sizeof(isGas));\n    for(int i=0;i<6011;i++)G[i].clear();\n    m.clear();\n    idx=0;\n    string s,t;\n    cin>>s>>t;\n    if(m.count(s)==0)m[s]=idx++;\n    if(m.count(t)==0)m[t]=idx++;\n    st=m[s];gl=m[t];\n    for(int i=0;i<N;i++){\n      string a,b;\n      int c;\n      cin>>a>>b>>c;\n      if(m.count(a)==0)m[a]=idx++;\n      if(m.count(b)==0)m[b]=idx++;\n      int x,y;\n      x=m[a];y=m[b];\n      edge e;\n      e.to=y;\n      e.cost=c;\n      G[x].push_back(e);\n      e.to=x;\n      G[y].push_back(e);\n    }\n    for(int i=0;i<M;i++){\n      string s;\n      cin>>s;\n      if(m.count(s)==0)m[s]=idx++;\n      isGas[m[s]]=true;\n    }\n    int res=dijkstra();\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[3001][3001];\nbool is_LPG[3001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nint N, M, C, SZ;\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int cap){\n  return cap*SZ+u;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[src] = SZ++;\n\tcor[dest] = SZ++;\n\tC *= 10;\n\tvector<tuple<int,int,int>> mem;\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = SZ++;\n\t  if(!cor.count(s2)) cor[s2] = SZ++;\n\t  mem.PB(make_tuple(cor[s1],cor[s2],d));\n\t}\n\n\tGraph G(SZ*2100);\n\tfor(auto& tp: mem){\n\t  int u, v, d;\n\t  tie(u,v,d) = tp;\n\t  for(int j=d;j<=C;++j){\n\t\tG[idx(u,j)].PB(Edge(idx(v,j-d),d));\n\t\tG[idx(v,j)].PB(Edge(idx(u,j-d),d));\n\t  }\n\t}\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  for(int j=0;j<=C;++j)\n\t\tG[idx(cor[s],j)].PB(Edge(idx(cor[s],C),0));\t  \n\t}\n\n\tVI dist(SZ*2100);\n\tDijkstra(G,dist,idx(cor[src],C));\n\tint ans = INF;\n\tfor(int j=0;j<=C;++j)\n\t  ans = min(ans, dist[idx(cor[dest],j)]);\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[3001][2001];\nvector<pii> conn[3001];\nbool station[3001];\n\nstruct node {\n\tint p, gas;\n\tll cost;\n\tnode(int pp, ll cc, int gg) {\n\t\tp = pp;\n\t\tcost = cc;\n\t\tgas = gg;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nint main() {\n\tint n, m, c;\n\twhile(cin >> n >> m >> c, n) {\n\t\tc *= 10;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmemset(station, 0, sizeof(station));\n\t\trep(i,3001) conn[i].clear();\n\t\tmap<string, int> mp;\n\t\tint towns = 0;\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\tmp[start] = towns++;\n\t\tif( start != goal ) {\n\t\t\tmp[goal] = towns++;\n\t\t}\n\t\trep(i, n) {\n\t\t\tstring s, e;\n\t\t\tint d;\n\t\t\tcin >> s >> e >> d;\n\t\t\tif( mp.find(s) == mp.end() ) {\n\t\t\t\tmp[s] = towns++;\n\t\t\t}\n\t\t\tif( mp.find(e) == mp.end() ) {\n\t\t\t\tmp[e] = towns++;\n\t\t\t}\n\t\t\tconn[mp[s]].push_back(pii(mp[e], d));\n\t\t\tconn[mp[e]].push_back(pii(mp[s], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tstation[mp[in]] = true;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], 0, c) );\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top(); que.pop();\n\t\t\tif( nd.p == mp[goal] ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.gas] ) continue;\n\t\t\tvisit[nd.p][nd.gas] = true;\n\n\t\t\tif( station[nd.p] && !visit[nd.p][c] ) {\n\t\t\t\tque.push( node(nd.p, nd.cost, c) );\n\t\t\t}\n\n\t\t\tfor(int i=0; i<conn[nd.p].size(); i++) {\n\t\t\t\tif( nd.gas-conn[nd.p][i].second >= 0 && !visit[conn[nd.p][i].first][nd.gas-conn[nd.p][i].second] ) {\n\t\t\t\t\tque.push( node(conn[nd.p][i].first, nd.cost + conn[nd.p][i].second, nd.gas-conn[nd.p][i].second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint D[N][2001];\nint dijkstra(){\n  for(int i=0;i<n;i++)for(int j=0;j<=cap;j++) D[i][j]=INF;\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\nconst int maxm = 6100;\nconst int maxn = 8100;\nconst int INF =  0x3f3f3f3f;\nint n,m,cap,st,en;\nint top;\nint head[maxn];\nmap<string,int>has;\nbool gas[maxn];\nbool inq[maxn][2100];\nint dist[maxn][2100];\nstruct node\n{\n\tint next;\n\tint to;\n\tint weight;\n}edge[maxm*2];\nstruct point\n{\n\tint pos;\n\tint cost;\n};\nvoid addedge(int from,int to,int weight)\n{\n\tedge[top].to=to;\n\tedge[top].weight=weight;\n\tedge[top].next=head[from];\n\thead[from]=top++;\n}\nbool update(int pos,int ti,int to,int k,int len)\n{\n\tif(dist[to][k]>dist[pos][ti]+len){\n\t\tdist[to][k]=dist[pos][ti]+len;\n \t    return  true;\n \t}\n \treturn false;\n}\nvoid spfa()\n{\n\tpoint now;\n\tqueue<point>q;\n\tmemset(dist,0x3f,sizeof(dist));\n\tmemset(inq,0,sizeof(inq));\n\tdist[st][cap]=0;\n\tinq[st][cap]=1;\n\tnow.pos=st;\n\tnow.cost=cap;\n\tq.push(now);\n\twhile(!q.empty())\n\t{\n\t\tnow=q.front();\n\t\tq.pop();\n\t\t//printf(\"dsdsds\");\n\t\tinq[now.pos][now.cost]=0;\n\t\tint pos=now.pos;\n\t\tint ti=now.cost;\n\t\tif(gas[pos])\n\t\t{\n\t\t\tdist[pos][cap]=min(dist[pos][cap], dist[pos][ti]);\n\t\t\tti=cap;\n\t\t}\n\t\tfor(int k=head[pos];k!=-1;k=edge[k].next)\n\t\t{\n              int to=edge[k].to;\n              //printf(\"%d\\n\",k);\n              if(ti>=edge[k].weight&&update(pos,ti,to,ti-edge[k].weight,edge[k].weight))\n              {\n                //cout<<\"here\"<<endl;\n              \tnow.pos=to;\n              \tnow.cost=ti-edge[k].weight;\n              \tif(!inq[to][now.cost]){\n              \t   q.push(now);\n              \t   inq[now.pos][now.cost]=1;\n              \t}\n              }\n       }\n       //cout<<\"here\"<<endl;\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&cap)!=EOF)\n\t{\n\t\tstring a;string b;\n\t\tint cnt=1;\n\t\ttop=0;\n\t\thas.clear();\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(gas,0,sizeof(gas));\n\t\tcin>>a>>b;\n\t\tscanf(\"%d\",&cap);\n\t\tcap*=10;\n\t\tif(has.find(a)==has.end())\n\t\t\thas[a]=cnt++;\n\t\tif(has.find(b)==has.end())\n\t\t\thas[b]=cnt++;\n\t\tst=has[a];\n\t\ten=has[b];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tstring a;\n\t\t\tstring b;\n\t\t\tint weight;\n\t\t\tcin>>a>>b>>weight;\n\t\t\tif(has.find(a)==has.end())\n\t\t\t\thas[a]=cnt++;\n\t\t\tif(has.find(b)==has.end())\n\t\t\t\thas[b]=cnt++;\n\t\t\tint nowa=has[a];\n\t\t\tint nowb=has[b];\n\t\t\taddedge(nowa,nowb,weight);\n\t\t\taddedge(nowb,nowa,weight);\n\t\t}\n\t\t//printf(\"%d\",edge[0].next);\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tstring a;\n\t\t\tcin>>a;\n\t\t\tif(has.find(a)==has.end())\n\t\t\t\thas[a]=cnt++;\n\t\t\tint nowa=has[a];\n\t\t\tgas[nowa]=1;\n\t\t}\n\t\tspfa();\n\t\tint ans=INF;\n\t\t//printf(\"%d\\n\",cap);\n\t\tfor(int i=0;i<=cap;i++){\n\t\t   if(dist[en][i]<ans)\n\t\t        ans=dist[en][i];\n        }\n\n\t\tif(ans==INF)\n\t\tprintf(\"-1\\n\");\n\t\telse\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d<p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long W;\n\nconst W INF = 1LL << 50;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph& G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nW wf[310][310];\nstring a[3000], b[3000];\nW dist[3000];\nstring st_name[310];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N | M | cap) {\n\t\tmap<string, int> city;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tcity[src] = -1;\n\t\tcity[dst] = -1;\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> a[i] >> b[i] >> dist[i];\n\t\t\tcity[a[i]] = -1;\n\t\t\tcity[b[i]] = -1;\n\t\t}\n\n\t\tint C = 0;\n\t\tfor(auto& p : city) {\n\t\t\tcity[p.first] = C++;\n\t\t}\n\n\t\tmap<string, int> station;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tcin >> st_name[i];\n\t\t\tstation[st_name[i]] = i;\n\t\t}\n\t\tstation[src] = M;\n\t\tstation[dst] = M + 1;\n\t\tst_name[M] = src;\n\t\tst_name[M + 1] = dst;\n\t\tM += 2;\n\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t\twf[i][j] = i == j ? 0 : INF;\n\n\t\tGraph G(C);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tG[city[a[i]]].push_back(edge{ city[b[i]], dist[i] });\n\t\t\tG[city[b[i]]].push_back(edge{ city[a[i]], dist[i] });\n\t\t}\n\n\t\tvector<W> d(C);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tdijkstra(city[st_name[i]], G, d);\n\t\t\tfor(int j = 0; j < M; j++) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(d[city[st_name[j]]] <= cap * 10) {\n\t\t\t\t\twf[i][j] = wf[j][i] = d[city[st_name[j]]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < M; k++)\n\t\t\tfor(int i = 0; i < M; i++)\n\t\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\n\t\tW ans = wf[station[src]][station[dst]];\n\t\tif(ans == INF) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      // assert(0 <= c1 && c1 < N);\n      // assert(0 <= c2 && c2 < N);\n#if 0\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3030][3030];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3030; ++i) {\n      for(int j = 0; j < 3030; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\nint n,m,l,qq;\n#define MAXN 6001\nvector < pair<int,int> > a[MAXN],b[MAXN];\nconst int inf = 0x7fffffff;\nint d[MAXN];\nbool bo[MAXN],p[MAXN];\nmap <string , int> hash;\nvoid  spfa(int s )\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        d[i]=inf;\n    }\n    memset(bo,0,sizeof(bo));\n    d[s]=0;bo[s]=1;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();bo[now]=0;\n        for (int i =0; i < a[now].size(); ++i)\n        {\n            int v=a[now][i].first;\n            int abc=a[now][i].second;\n            if (d[v]-abc>d[now]) \n            {\n                d[v]=abc+d[now];\n                if (!bo[v])\n                {\n                    bo[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nvoid  spfa2(int s )\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        d[i]=inf;\n    }\n    memset(bo,0,sizeof(bo));\n    d[s]=0;bo[s]=1;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();bo[now]=0;\n        for (int i =0; i < b[now].size(); ++i)\n        {\n            int v=b[now][i].first;\n            int abc=b[now][i].second;\n            if (d[v]-abc>d[now]) \n            {\n                d[v]=abc+d[now];\n                if (!bo[v])\n                {\n                    bo[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\nstring temp,temp2;\nint main(int argc, char const *argv[])\n{\n   // freopen(\"input.txt\",\"r\",stdin);\n    while (scanf(\"%d%d%d\",&m,&qq,&l)!=EOF)\n    {\n        if (m==0 && qq==0 && l==0) break;\n        hash.clear();\n        l *= 10;\n        for (int i = 0; i < MAXN; ++i)\n        {\n            a[i].clear();\n            b[i].clear();\n        }\n        memset(p,0,sizeof(p));\n        n=0;\n        int s,t;\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        s=hash[temp];\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        t=hash[temp];\n        for (int i = 0; i < m; ++i)\n        {\n            cin>>temp>>temp2;\n            int x,y,z;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            if (!hash.count(temp2))\n            {\n                hash[temp2]=++n;\n            }\n            x=hash[temp];\n            y=hash[temp2];\n            cin>>z;\n            if (z <= l)\n            {\n                a[x].push_back(make_pair(y,z));\n                a[y].push_back(make_pair(x,z));\n            }\n        }\n        for (int i = 0; i < qq; ++i)\n        {\n            cin>>temp;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            int x=hash[temp];\n            p[x]=1;\n            spfa(x);\n            for (int i = 1; i <= n; ++i)\n            {\n                if (d[i]<=l && i!=x)\n                {\n                    b[x].push_back(make_pair(i,d[i]));\n                    b[i].push_back(make_pair(x,d[i]));\n                }\n            }\n        }\n        spfa2(s);\n        int ans=inf;\n        ans=d[t];\n        if (ans==inf)\n        {\n            puts(\"-1\");\n        }\n        else\n        {\n            printf(\"%d\\n\",ans );\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,cap;\n    while(cin>>n>>m>>cap, n){\n        string src,dest;cin>>src>>dest;\n        cap *= 10;\n        int idx=3;\n        map<string,int> mp;\n        mp[src]=1;mp[dest]=2;\n        vector<vector<int>> g(1000,vector<int>(1000,INF));\n        for(int i=0;i<n;i++){\n            string st,gt;cin>>st>>gt;\n            int d;cin>>d;\n            if(mp[st]==0){\n                mp[st]=idx;\n                idx++;\n            }\n            if(mp[gt]==0){\n                mp[gt]=idx;\n                idx++;\n            }\n            g[mp[st]][mp[gt]]=d;\n            g[mp[gt]][mp[st]]=d;\n        }\n        vector<int> v;\n        v.push_back(1);v.push_back(2);\n        for(int i=0;i<m;i++){\n            string s;cin>>s;\n            v.push_back(mp[s]);\n        }\n        for(int i=1;i<idx;i++) g[i][i]=0;\n        for(int k=1;k<idx;k++){\n            for(int i=1;i<idx;i++){\n                for(int j=1;j<idx;j++){\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n                }\n            }\n        }\n        vector<vector<int>> dis(idx,vector<int>(idx,INF));\n        int sz=v.size();\n        for(int i=0;i<sz;i++){\n            for(int j=i;j<sz;j++){\n                int st=v[i],gt=v[j];\n                if(g[st][gt]>cap) continue;\n                dis[st][gt]=dis[gt][st]=g[st][gt];\n            }\n        }\n        for(int k=1;k<idx;k++){\n            for(int i=1;i<idx;i++){\n                for(int j=1;j<idx;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        if(dis[1][2]>=INF) cout<<-1<<endl;\n        else cout<<dis[1][2]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\npriority_queue<State> pq;\nvector<pair<int,int> > v[6001];\nbool sta[6001];\nint dp[6001][2001];\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2+1;i++){\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(mp(M[b],c));\n      v[M[b]].push_back(mp(M[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.n][u.a]<u.dis)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tcontinue;\n      }\n\n      for(int i=0;i<v[u.n].size();i++){\n\n\tif(sta[u.n]){\n\t  if(v[u.n][i].s<cap){\n\t    int sum1=u.dis+v[u.n][i].s,sum2=cap-v[u.n][i].s;\n\t    if(sum1<dp[v[u.n][i].f][sum2]){\n\t      dp[v[u.n][i].f][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].f,sum2,sum1));\n\t    }\n\t  }\n\t}\n\telse {\n\t  if(v[u.n][i].s<u.a){\n\t    int sum1=u.dis+v[u.n][i].s,sum2=u.a-v[u.n][i].s;\n\t    if(sum1<dp[v[u.n][i].f][sum2]){\n\t      dp[v[u.n][i].f][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].f,sum2,sum1));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    vector<Node> nodes[6001];\n    map<string,int> cities;\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n    dp[get_city_id(cities,src)][10*capacity] = true;\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint size = 0;\n\t\tvector<vs> data(N, vs(3)); \n\t\tmap<string, int> index;\n\t\t{\n\t\t\tset<string> cities;\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, 2) {\n\t\t\t\t\tcin >> data[i][j];\n\t\t\t\t\tcities.insert(data[i][j]);\n\t\t\t\t}\n\t\t\t\tcin >> data[i][2];\n\t\t\t}\n\n\t\t\tset<string>::iterator it = cities.begin();\n\t\t\twhile(it != cities.end()) {\n\t\t\t\tindex[*it] = size;\n\t\t\t\tsize++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\n\t\tvvs dist(size, vsh(size, INF));\n\t\tREP(i, size) {\n\t\t\tREP(j, size) {\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvsh cost(size, INF);\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d]) {\n\t\t\t\t\t\tcost[d] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, dist;\n  edge(){}\n  edge(int to, int dist):to(to), dist(dist){}\n};\n\nint N, M, C;\nstring S, D;\nvector< tuple<string, string, int> > road;\nvector< vector<edge> > graph;\nmap<string, int> city;\nset<int> st;\nvector< vector<int> > mindist;\n\nstruct stat {\n  int now, dist, gas;\n  stat(){}\n  stat(int now, int dist, int gas):now(now), dist(dist), gas(gas){}\n  bool operator < (const stat s) const {\n    return dist > s.dist;\n  }\n};\n\nint dijkstra(int sz) {\n  mindist.clear();\n  mindist.resize(sz, vector<int>(C+1, inf));\n  priority_queue<stat> que;\n  mindist[0][C] = 0;\n  que.emplace(0, 0, C);\n  while(que.size()) {\n    stat s = que.top(); que.pop();\n    int now = s.now, dist = s.dist, gas = s.gas;\n    if(now == 1) return dist;\n    if(mindist[now][gas] < dist) continue;\n    for(edge& e : graph[now]) {\n      int ngas = gas - e.dist;\n      if(ngas < 0) continue;\n      if(st.count(e.to)) ngas = C;\n      if(e.dist + dist < mindist[e.to][ngas]) {\n\tmindist[e.to][ngas] = e.dist + dist;\n\tque.emplace(e.to, mindist[e.to][ngas], ngas);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> C, N || M || C) {\n    city.clear();\n    st.clear();\n    road.clear();\n    graph.clear();\n    C *= 10;\n    cin >> S >> D;\n    city[S] = 0;\n    city[D] = 1;\n    int cnt = 2;\n    rep(i, N) {\n      string a, b; int d;\n      cin >> a >> b >> d;\n      if(!city.count(a)) city[a] = cnt++;\n      if(!city.count(b)) city[b] = cnt++;\n      road.emplace_back(a, b, d);\n    }\n    graph.resize(cnt);\n    rep(i, N) {\n      string a, b; int d;\n      tie(a, b, d) = road[i];\n      graph[city[a]].emplace_back(city[b], d);\n      graph[city[b]].emplace_back(city[a], d);\n    }\n    rep(i, M) {\n      string s;\n      cin >> s;\n      st.insert(city[s]);\n    }\n    cout << dijkstra(cnt) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\nll dist[6010][2010];\nbool done[6010][2010];\n\nll solve()\n{\n\tvector<pair<int, int> > E[6010];\n\tset<int> gas;\n\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tstring src, dest;\n\tcin >> src >> dest;\n\tm[src] = 0; m[dest] = 1;\n\tidx = 2;\n\n\trep(i, 0, N)\n\t{\n\t\tstring a, b; cin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\trep(i, 0, M)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\trep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n#if 0\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <queue>\ntypedef long long ll;\n\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nstruct Edge {\n    int src, dst;\n    int weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n    Edge() {}\n};\n\nusing Graph = vector<vector<Edge>>;\n\nint V, E;\nint num_stand; // num of stands\nstring src, dst;\nint cap;\nGraph g;\n\nvector<string> c1, c2;\nvector<int> d;\nvector<string> s;\n\nmap<string, int> m;\n\nconst int inf = 1e9;\n\nint dist[310][210]; // at town i with gas j\nint canCharge[310];\n\nint dijkstra(int s, int t) {\n    fill((int*)begin(dist), (int*)end(dist), inf);\n    priority_queue<tuple<int,int, int>> q;// -dist, town, cap\n    \n    dist[s][cap] = 0;\n    q.emplace(0, s, cap);\n\n    while (q.size()) {\n        int d, v, rem;\n        tie(d, v,rem) = q.top();\n        q.pop();\n        d = -d;\n\n        if (v == t) return d;\n\n        if (dist[v][rem] < d) continue;\n        for (auto &e : g[v]) {\n            int nv = e.dst;\n            int nrem = rem - e.weight;\n            if (nrem < 0) continue;\n            if (canCharge[nv]) {\n                nrem = cap;\n            }\n            int nd = d + e.weight;\n            if (dist[nv][nrem] > nd) {\n                dist[nv][nrem] = nd;\n                q.emplace(-nd, nv, nrem);\n            }\n        }\n    }\n\n    return 1e9;\n}\n\nint main() {\n    while (cin >> E >> num_stand >> cap && E) {\n        m.clear();\n        V = 0;\n        c1.resize(E);\n        c2.resize(E);\n        d.resize(E);\n        cap *= 10;\n        cin >> src >> dst;\n        if (m.count(src) == 0) m[src] = V++;\n        if (m.count(dst) == 0) m[dst] = V++;\n\n        for (int i = 0; i < E; ++i) {\n            cin >> c1[i] >> c2[i] >> d[i];\n            if (m.count(c1[i]) == 0) m[c1[i]] = V++;\n            if (m.count(c2[i]) == 0) m[c2[i]] = V++;\n        }\n\n        memset(canCharge, 0, sizeof(canCharge));\n        s.resize(num_stand);\n        for (int i = 0; i < num_stand; ++i) {\n            cin >> s[i];\n            canCharge[m[s[i]]] = true;\n        }\n\n        g.assign(V, {});\n        for (int i = 0; i < E; ++i) {\n            int a = m[c1[i]];\n            int b = m[c2[i]];\n            g[a].emplace_back(a, b, d[i]);\n            g[b].emplace_back(b, a, d[i]);\n        }\n\n        int ans = dijkstra(m[src], m[dst]);\n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    cout << -1 << endl;\n    continue;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n \nusing namespace std;\n \n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n \nbool used[6000][2001];\nvector<pair<short, short> > edge[6000];\n \nint main() {\n  while (true) {\n    rep (i, 6000) edge[i].clear();\n    rep (i, 6000) rep (j, 2001) used[i][j] = false;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    int res = 1e9;\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (used[pos][f]) continue;\n      used[pos][f] = true;\n      if (mp[dest] == pos) {\n\tres = cost;\n\tbreak;\n      }\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (used[np][nf]) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\t// if(u == goal) dist[u][lpg];\n\t\t// printf(\"cost %d u %d lpg %d\\n\", cost, u, lpg);\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto& tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\t// printf(\"v %d di %d nlpg %d ncost %d\\n\", v, di, nlpg, ncost);\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\t// printf(\"dist[%d][%d] = %d\\n\", v, cap, ncost);\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\t// printf(\"dist[%d][%d] = %d\\n\", v, nlpg, ncost);\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap * 10 + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[3010][2010];\nvector<pii> conn[3010];\nbool station[3010];\n\nstruct node {\n\tint p, gas;\n\tll cost;\n\tnode(int pp, ll cc, int gg) {\n\t\tp = pp;\n\t\tcost = cc;\n\t\tgas = gg;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.cost > rhs.cost;\n}\n\nint main() {\n\tint n, m, c;\n\twhile(cin >> n >> m >> c, n) {\n\t\tc *= 10;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tmemset(station, 0, sizeof(station));\n\t\trep(i,3001) conn[i].clear();\n\t\tmap<string, int> mp;\n\t\tint towns = 0;\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\tmp[start] = towns++;\n\t\tif( start != goal ) {\n\t\t\tmp[goal] = towns++;\n\t\t}\n\t\trep(i, n) {\n\t\t\tstring s, e;\n\t\t\tint d;\n\t\t\tcin >> s >> e >> d;\n\t\t\tif( mp.find(s) == mp.end() ) {\n\t\t\t\tmp[s] = towns++;\n\t\t\t}\n\t\t\tif( mp.find(e) == mp.end() ) {\n\t\t\t\tmp[e] = towns++;\n\t\t\t}\n\t\t\tconn[mp[s]].push_back(pii(mp[e], d));\n\t\t\tconn[mp[e]].push_back(pii(mp[s], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tstation[mp[in]] = true;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], 0, c) );\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top(); que.pop();\n\t\t\tif( nd.p == mp[goal] ) {\n\t\t\t\tcout << nd.cost << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.gas] ) continue;\n\t\t\tvisit[nd.p][nd.gas] = true;\n\n\t\t\tif( station[nd.p] && !visit[nd.p][c] ) {\n\t\t\t\tque.push( node(nd.p, nd.cost, c) );\n\t\t\t}\n\n\t\t\tfor(int i=0; i<conn[nd.p].size(); i++) {\n\t\t\t\tif( nd.gas-conn[nd.p][i].second >= 0 && !visit[conn[nd.p][i].first][nd.gas-conn[nd.p][i].second] ) {\n\t\t\t\t\tque.push( node(conn[nd.p][i].first, nd.cost + conn[nd.p][i].second, nd.gas-conn[nd.p][i].second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#define int short\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,remain,cost;\n\tnode(int index,int remain,int cost):index(index),remain(remain),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nconst int MAX=(1<<14);\nconst int NONE=-1;\nint main() {\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        int nc=cities.size();\n        vvi g(nc,vi(nc,NONE));\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(nc);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n\n        priority_queue<node> q;\n        q.push(node(src_i,cap,0));\n        vvi cost(nc,vi(cap+1,MAX));\n        cost[0][cap]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.remain]<cnode.cost){\n                continue;\n\t\t    }\n            REP(i,nc){\n                if(g[cnode.index][i]!=NONE){\n                    int newremain=cnode.remain-g[cnode.index][i];\n                    int newcost=cnode.cost+g[cnode.index][i];\n                    if(newremain>=0){\n                        newremain=station[i] ? cap : newremain;\n\t\t\t\t\t\tif(cost[i][newremain]>newcost){\n                            cost[i][newremain]=newcost;\n                            q.push(node(i,newremain,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n        int ans=MAX;\n        REP(i,cap+1){\n            ans=min(ans,cost[dst_i][i]);\n\t    }\n        cout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define eps 1e-8\nmap<string,int>mp;\nint n,m,cap;\nint tot;\nstring st,ed;\nbool f[6005];\nint dis[6005];\nbool in[6005];\nstruct node\n{\n    int en;\n    int v;\n};\nvector<node>g[6005];\nvector<node>fin[6005];\nvoid spfa_ini(int root)\n{\n    memset(in,0,tot*sizeof(bool));\n    queue<int>q;\n    q.push(root);\n    for(int i=1;i<tot;i++) dis[i]=INF;\n    dis[root]=0;\n    in[root]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        in[now]=0;\n        for(int i=0;i<g[now].size();i++)\n        {\n            int temp=g[now][i].en;\n            int val=g[now][i].v;\n            if(dis[temp]>dis[now]+val)\n            {\n                dis[temp]=dis[now]+val;\n                if(!in[temp])   q.push(temp);\n            }\n        }\n    }\n    for(int i=1;i<tot;i++)\n    {\n        if(i==root) continue;\n        if(f[i]&&dis[i]<=cap*10)\n        {\n            node temp;\n            temp.en=i;\n            temp.v=dis[i];\n            fin[root].push_back(temp);\n        }\n    }\n}\n\nvoid spfa()\n{\n    queue<int>q;\n    for(int i=1;i<tot;i++)  dis[i]=INF;\n    dis[mp[st]]=0;\n    in[mp[st]]=1;\n    q.push(mp[st]);\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        in[now]=0;\n        for(int i=0;i<fin[now].size();i++)\n        {\n            int temp=fin[now][i].en;\n            int val=fin[now][i].v;\n            if(dis[temp]>dis[now]+val)\n            {\n                dis[temp]=dis[now]+val;\n                if(!in[temp])   q.push(temp);\n            }\n        }\n    }\n}\nvoid ini()\n{\n    mp.clear();\n    for(int i=1;i<tot;i++)\n    {\n        g[i].clear();\n        fin[i].clear();\n    }\n}\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d%d%d\",&n,&m,&cap);\n        if(n==0&&m==0&&cap==0)  break;\n        cin>>st>>ed;\n        mp[st]=1;\n        mp[ed]=2;\n        tot=3;\n        for(int i=0;i<n;i++)\n        {\n            string a,b;\n            int c;\n            cin>>a>>b>>c;\n            if(!mp[a])  mp[a]=tot++;\n            if(!mp[b])  mp[b]=tot++;\n            node temp;\n            temp.en=mp[b];\n            temp.v=c;\n            g[mp[a]].push_back(temp);\n            temp.en=mp[a];\n            g[mp[b]].push_back(temp);\n        }\n        memset(f,0,tot*sizeof(bool));\n        for(int i=0;i<m;i++)\n        {\n            string a;\n            cin>>a;\n            f[mp[a]]=1;\n        }\n        f[mp[ed]]=1;\n        f[mp[st]]=1;\n        for(int i=1;i<=n;i++)\n            if(f[i]&&i!=mp[ed])    spfa_ini(i);\n        spfa();\n        if(dis[mp[ed]]==INF)    printf(\"-1\\n\");\n        else printf(\"%d\\n\",dis[mp[ed]]);\n        ini();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<edge> g[6011];\n//vector<vector<edge> > g;\n\nvector<bool> sta;\n//vector<vector<int> > cost;\nunsigned short cost[6011][2001];\nint from,to;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    {\n      vector<string> node;\n      scanf(\"%s%s\",s,t);\n      node.push_back(s);\n      node.push_back(t);\n      for( int i = 0; i < n; i++ ) {\n        scanf(\"%s%s%d\",c[i],d[i],w+i);\n        node.push_back(c[i]);\n        node.push_back(d[i]);\n      }\n      for( int i = 0; i < m; i++ ) {\n        scanf(\"%s\",st[i]);\n        node.push_back(st[i]);\n      }\n      sort(node.begin(),node.end());\n      node.erase(unique(node.begin(),node.end()),node.end());\n      int sz = node.size();\n      //g.clear();\n      //cost.clear();\n      sta.clear();\n      //g.resize(sz,vector<edge>());\n      //cost.resize(sz,vector<int>(cap*10+1));\n      sta.resize(sz);\n      for( int i = 0; i < sz; i++ ) {\n        sta[i] = false;\n        g[i].clear();\n        for( int j = 0; j <= cap*10; j++ ) {\n          //cost[i][j] = 1919810893;\n          cost[i][j] = 65535;\n        }\n      }\n      for( int i = 0; i < n; i++ ) {\n        int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n        int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n        g[a].push_back(edge(b,w[i]));\n        g[b].push_back(edge(a,w[i]));\n      }\n      for( int i = 0; i < m; i++ ) {\n        sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n      }\n      from = lower_bound(node.begin(),node.end(),s)-node.begin();\n      to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    }\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      if( cost[p.n][p.cap] < p.c ) continue;\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 1000000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n     \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n   \t\t d[e.to] = d[v]+e.cost;\n   \t\t que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n \n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n    map<string,int>vnum;\n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 10000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tint dis;\n\tint gas;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.gas> r.gas;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tcap *= 10;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tint num = 2;\n\t\tvector<vector<pair<int, int>>>edges(6000);\n\t\tstring sta, goa; cin >> sta >> goa; mp[sta] = 0; mp[goa] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring f, t; cin >> f >> t;\n\t\t\tint dis; cin >> dis;\n\t\t\tif (!mp.count(f)) {\n\t\t\t\tmp[f] = num++;\n\t\t\t}\n\t\t\tif (!mp.count(t)) {\n\t\t\t\tmp[t] = num++;\n\t\t\t}\n\t\t\tconst int fid = mp[f];\n\t\t\tconst int tid = mp[t];\n\t\t\tedges[fid].push_back(make_pair(tid, dis));\n\t\t\tedges[tid].push_back(make_pair(fid, dis));\n\t\t}\n\t\tedges.resize(mp.size());\n\t\tvector<bool>stat(edges.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\t\t\t\tstat[mp[st]] = true;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>mindiss(mp.size(), vector<int>(cap + 1, 99999999));\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,0,cap });\n\t\tmindiss[0][cap] = 0;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int pregas = atop.gas;\n\t\t\tconst int nowdis = atop.dis;\n\t\t\t\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (pregas >= i.second) {\n\t\t\t\t\tconst int newid = i.first;\n\t\t\t\t\tconst int newgas = stat[newid]?cap:atop.gas - i.second;\n\t\t\t\t\tconst int newdis = nowdis + i.second;\n\t\t\t\t\tif (mindiss[newid][newgas]> newdis) {\n\t\t\t\t\t\tmindiss[newid][newgas] = newdis;\n\t\t\t\t\t\tque.push(aa{ newid, newdis ,newgas });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\tfor (int i = 0; i < cap + 1; ++i) {\n\t\t\tans = min(mindiss[1][i], ans);\n\t\t}\n\t\tif (ans == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n#include <set>\nusing namespace std;\n\nstruct Edge;\ntypedef vector<vector<Edge> > G;\n\nconst int INF = (1<<28);\n\nstruct Edge {\n  int to, cost;\n};\n\nstruct State {\n  int v, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvoid addEdge(int a, int b, int c, G *_g) {\n  G &g = *_g;\n  if(g.size() < max(a,b)+1) g.resize(max(a,b)+1);\n  g[a].push_back((Edge){b, c});\n  g[b].push_back((Edge){a, c});\n}\n\nvector<int> dijkstra(const G &g, int v) {\n  vector<int> res(g.size(), INF);\n  priority_queue<State> que;\n  State s = {v, 0};\n  res[v] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top();\n    que.pop();\n    if(s.cost > res[s.v]) continue;\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      const Edge &e = g[s.v][i];\n      int ncost = s.cost + e.cost;\n      if(ncost >= res[e.to]) continue;\n      res[e.to] = ncost;\n      que.push((State){e.to, ncost});\n    }\n  }\n  return res;\n}\n\nvoid wf(vector<vector<int> > *_v) {\n  vector<vector<int> > &v = *_v;\n  int n = v.size();\n  for(int k = 0; k < n; ++k) {\n    for(int i = 0; i < v.size(); ++i) {\n      for(int j = 0; j < v.size(); ++j) {\n        v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n      }\n    }\n  }\n}\n\ntemplate <class T>\nclass Convert {\nprivate:\n  map<T,int> id;\npublic:\n  int operator [](const T &s) {\n    if(!id.count(s)) {\n      id[s] = id.size()-1;\n    }\n    return id[s];\n  }\n\n  int count(const T &s) {\n    return id.count(s);\n  }\n\n  int size() {\n    return id.size();\n  }\n};\n\nint main() {\n  while(1) {\n    int N, M, cap, src, dest;\n    cin >> N >> M >> cap;\n    if(N == 0 && M == 0 && cap == 0) break;\n\n    Convert<string> conv;\n    G g;\n    {\n      string s, d;\n      cin >> s >> d;\n      src = conv[s];\n      dest = conv[d];\n    }\n\n    for(int i = 0; i < N; ++i) {\n      string a, b;\n      int d;\n      cin >> a >> b >> d;\n      addEdge(conv[a], conv[b], d, &g);\n    }\n\n    Convert<int> conv2;\n    conv2[src];\n    conv2[dest];\n    for(int i = 0; i < M; ++i) {\n      string s;\n      cin >> s;\n      conv2[conv[s]];\n    }\n\n    vector<vector<int> > T(conv2.size());\n    for(int i = 0; i < g.size(); ++i) {\n      if(conv2.count(i)) {\n        vector<int> v = dijkstra(g, i);\n        vector<int> t(conv2.size());\n        for(int j = 0; j < v.size(); ++j) {\n          if(conv2.count(j)) {\n            int &value = t[conv2[j]];\n            if(v[j] > cap*10) value = INF;\n            else value = v[j];\n          }\n        }\n        T[conv2[i]] = t;\n      }\n    }\n\n    wf(&T);\n    if(T[0][1] == INF) cout << -1 << endl;\n    else cout << T[0][1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\ntypedef ll Def;\nvi ga;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tDef to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tDef n,L;\n\tvector<vector<Def> >d;//distance\n//\tDef d[510][50][2];\n\tDIJ(Def size,Def l){\n\t\tn=size;\n\t\tL=l;//??????\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(Def a,Def b,Def c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(Def s,Def g){\n\t\td=vector<vector<Def> >(n,vector<Def>(L+1,inf));\n\t\td[s][L]=0;\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,s,L));\n\t\twhile(!q.empty()){\n\t\t\tDef cost,pos,t;\n\t\t\ttie(cost,pos,t)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(cost>d[pos][t])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tDef to=e.to;\n\t\t\t\tDef ncost=cost+e.cost;//??????\n\t\t\t\tDef nt=t-e.cost;//??????\n\t\t\t\tif(nt<0)continue;\n\t\t\t\tif(ga[to])nt=L;\n\t\t\t\tif(ncost<d[to][nt]){\n\t\t\t\t\td[to][nt]=ncost;\n\t\t\t\t\tq.push(tp(-ncost,to,nt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,L+1)out=min(out,d[g][i]);\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n};\nsigned main(){\n\tint m,w,cap;\n\tstring st,go;\n\twhile(cin>>m>>w>>cap,m){\n\t\tint n=0;\n\t\tcin>>st>>go;\n\t\tmap<string,int>ma;\n\t\tvvi in(m);\n\t\trep(i,m){\n\t\t\tstring s,t;\n\t\t\tcin>>s>>t;\n\t\t\tint d;\n\t\t\tcin>>d;\n\t\t\tif(ma[s]==0)ma[s]=++n;\n\t\t\tif(ma[t]==0)ma[t]=++n;\n\t\t\tin[i]={ma[s]-1,ma[t]-1,d};\n\t\t}\n\t\t\n\t\tDIJ dij(n,cap*10);\n\t\trep(i,m)dij.add_edge(in[i][0],in[i][1],in[i][2]);\n\t\tga=vi(n);\n\t\trep(i,w){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tga[ma[s]-1]=1;\n\t\t}\n\t\tdij.dij(ma[st]-1,ma[go]-1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#define mod 1000000007\n#define INF 1<<30\n#define eps 1e-10\nusing namespace std;\nint n,m,cap,tot;\nmap<string,int> mm;\nchar s[20],t[20];\nchar s1[20],t1[20];\nbool flag[6002];\nint s2,t2;\nstruct node\n{\n    short t,ti;\n};\nstruct state\n{\n    short vex,ca;\n};\nvector<node> ve[6002];\nint dp[6002][2002];\nbool vis[6002][2002];\npriority_queue<state> q;\nbool operator < (const state& a,const state& b)\n{\n    return dp[a.vex][a.ca]<dp[b.vex][b.ca];\n}\n\nvoid dijkstra(int s,int t)\n{\n    while(!q.empty()) q.pop();\n    for(int i=1;i<=tot;i++)\n    for(int j=0;j<=cap;j++) {dp[i][j]=INF;vis[i][j]=0;}\n    dp[s][cap]=0;state ss;ss.vex=s;ss.ca=cap;q.push(ss);\n    while(!q.empty())\n    {\n        ss=q.top();q.pop();\n        if(vis[ss.vex][ss.ca]) continue;\n        //cout<<ss.vex<<\" \"<<ss.ca<<\" \"<<dp[ss.vex][ss.ca]<<endl;\n        //if(ss.vex==t) return;\n        vis[ss.vex][ss.ca]=1;\n        for(int i=0;i<ve[ss.vex].size();i++)\n        {\n            node no=ve[ss.vex][i];\n            if(ss.ca<no.ti) continue;\n            int cc=ss.ca-no.ti;\n            if(flag[no.t]) cc=cap;\n            if(dp[ss.vex][ss.ca]+no.ti<dp[no.t][cc])\n            {\n                dp[no.t][cc]=dp[ss.vex][ss.ca]+no.ti;\n                state ss2;ss2.vex=no.t;ss2.ca=cc;\n                q.push(ss2);\n            }\n        }\n    }\n}\nmain()\n{\n    //freopen(\"test.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&n,&m,&cap),n+m+cap)\n    {\n        tot=1;int dd;cap*=10;\n        scanf(\"%s%s\",s1,t1);\n        memset(ve,0,sizeof(ve));\n        memset(flag,0,sizeof(flag));\n        mm.clear();\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%s%s%d\",s,t,&dd);int ss,tt;\n            if(mm[s]==0)\n            {\n                mm[s]=tot++;ss=tot-1;\n            }\n            else\n            ss=mm[s];\n            if(mm[t]==0)\n            {\n                mm[t]=tot++;tt=tot-1;\n            }\n            else\n            tt=mm[t];\n            if(cap>=dd)\n            {node no;no.t=tt;no.ti=dd;ve[ss].push_back(no);\n            no.t=ss;ve[tt].push_back(no);}\n        }\n        s2=mm[s1];t2=mm[t1];\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%s\",s);flag[mm[s]]=1;\n        }\n        dijkstra(s2,t2);\n        int ans=INF;\n        for(int i=0;i<=cap;i++)\n        ans=min(ans,dp[t2][i]);\n        //for(int i=0;i<=340;i++)\n        //cout<<dp[4][340]<<endl;\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    //while(1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int V = 6010;\nconst int E = 3010;\nint n, m, cap;\n\nstruct dot{\n\tint p, oil;\n}front, rear;\n\nstruct edge{\n\tint to, w;\n};\n\nvector<edge> G[V];\nchar s1[20], s2[20];\n\nvoid add_edge(int u, int v, int d){\n\tedge ee;\n\tee.to = v;\n\tee.w = d;\n\tG[u].push_back(ee);\n\tee.to = u;\n\tG[v].push_back(ee);\n}\n\nbool sta[V];\nint dis[V][2010];\nbool inq[V][2010];\n\nint main () { freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int> city;\n\t\tcap *= 10;\n\t\tscanf(\"%s %s\", s1, s2);\n\t\tcity[string(s1)] = 1;\n\t\tcity[string(s2)] = 2;\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t\tint u, v, d, cou = 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%s %s %d\", s1, s2, &d);\n\t\t\tif(!city[string(s1)]) city[string(s1)] = ++cou;\n\t\t\tif(!city[string(s2)]) city[string(s2)] = ++cou;\n\t\t\tu = city[string(s1)];\n\t\t\tv = city[string(s2)];\n\t\t\tadd_edge(u, v, d);\n\t\t}\n\t\tmemset(sta, 0, sizeof(sta));\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%s\", s1);\n\t\t\tif(!city[string(s1)]) continue;\n\t\t\telse sta[city[string(s1)]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint mmin  = 0x3f3f3f3f;\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tdis[1][cap] = 0;\n\t\tint ok = 0;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = false;\n\t\t\tif(front.p == 2) {ok = 1; if(dis[2][front.oil] < mmin) mmin = dis[2][front.oil]; continue; }\n\t\t\tfor(int i = 0; i < G[front.p].size(); i++){\n\t\t\t\tif(G[front.p][i].w > front.oil) continue;\n\t\t\t\trear.oil = front.oil -G[front.p][i].w;\n\t\t\t\trear.p = G[front.p][i].to;\n\t\t\t\tif(sta[rear.p]) rear.oil = cap;\n\t\t\t\tif(dis[rear.p][rear.oil] > dis[front.p][front.oil] + G[front.p][i].w){\n\t\t\t\t\tdis[rear.p][rear.oil] = dis[front.p][front.oil] + G[front.p][i].w;\n\t\t\t\t\tif(!inq[rear.p][rear.oil]){\n\t\t\t\t\t\tinq[rear.p][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(\"-1\");\n\t\telse printf(\"%d\\n\", mmin);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      rep(i,MAX)G[i].clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx <= MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n諤サ逧?庄莉・蠖堤コウ謌?荳牙?扈?x,y,z):\nx:逕ィ謗貞コ剰ァ」蜀ウ\ny:逕ィ謗貞コ丞刈cdq蛻?イサ隗」蜀ウ\nz:逕ィ譬醍憾謨ー扈?ァ」蜀ウ\n*/\n#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <ostream>\n#include <ios>\n#include <cstdlib>\nusing namespace std;\n\n#define wh while\n#define inf (int)(~0u/2)\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FOR1(i, n) for(int i = 1; i < n; i++)\n#define FOR2(i, n) for(int i = 0; i <= n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define FORI(it,n) for(typeof(n.begin()) it = n.begin(); it != n.end(); it++)\n#define sf scanf\n#define pf printf\n#define frs first\n#define sec second\n#define psh push_back\n#define mkp make_pair\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n#define lt(v) v << 1\n#define rt(v) v << 1 | 1\n#define mid ((l + r) >> 1)\n#define lson l, mid, v << 1\n#define rson mid + 1, r, v << 1 | 1\n\n#define fre freopen(\"1.txt\", \"r\", stdin)\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 3030;\nint N, M, cap;\nint st, ed, curcost;\nbool curvis;\nstruct NODE{\n    int to, cost;\n};\nvector<NODE> G[maxn];\nvector<NODE> G2[maxn];\nchar tmpA[20], tmpB[20];\nint oil[350];\nmap<string, int> mp;\nvoid dfs1(int cur, int fa, int curcost){\n    if(cur == fa){\n        if(curvis)\n            return ;\n        else\n            curvis = true;\n    }\n    if(cur != fa){\n        NODE c; c.to = cur; c.cost = curcost;\n        G2[fa].PB(c);\n    }\n    FOR(i, (int)G[cur].size()){\n        if(G[cur][i].cost + curcost <= cap * 10 && G[cur][i].to != fa)\n            dfs1(G[cur][i].to, fa, G[cur][i].cost + curcost);\n    }\n}\n\nstruct HeapNode {\n  int d, u;\n  bool operator < (const HeapNode& rhs) const {\n    return d > rhs.d;\n  }\n};\nstruct Dijkstra {\n    int n;\n    void init(int a){\n        n = a;\n    }\n    bool done[maxn];\n    int d[maxn];\n\n    void dijkstra(int s) {\n        priority_queue<HeapNode> Q;\n        REP(i, n){\n            d[i] = INF;\n        }\n        d[s] = 0;\n        memset(done, 0, sizeof(done));\n        Q.push((HeapNode){0, s});\n        while(!Q.empty()) {\n            HeapNode x = Q.top(); Q.pop();\n            int u = x.u;\n            if(done[u]) continue;\n            done[u] = true;\n            for(int i = 0; i < (int)G2[u].size(); i++) {\n                int curto = G2[u][i].to;\n                int curdist = G2[u][i].cost;\n                if(d[curto] > d[u] + curdist) {\n                    d[curto] = d[u] + curdist;\n                    Q.push((HeapNode){d[curto], curto});\n                }\n            }\n        }\n    }\n} djk;\nint main(){\n    wh(sf(\"%d%d%d\", &N, &M, &cap) != EOF){\n        if(!N && !M && !cap)\n            break;\n        int cnt = 0; mp.clear(); int oilcnt = 0;\n        REP(i, N)\n            G[i].clear();\n        REP(i, N)\n            G2[i].clear();\n        sf(\"%s\", tmpA); sf(\"%s\", tmpB);\n        mp[tmpA] = ++cnt;\n        st = mp[tmpA];\n        mp[tmpB] = ++cnt;\n        ed = mp[tmpB];\n        FOR(i, N){\n            sf(\"%s\", tmpA); sf(\"%s\", tmpB); sf(\"%d\", &curcost);\n            if(!mp[tmpA]) mp[tmpA] = ++cnt;\n            if(!mp[tmpB]) mp[tmpB] = ++cnt;\n            NODE nw; nw.cost = curcost; nw.to = mp[tmpB];\n            G[mp[tmpA]].PB(nw); nw.to = mp[tmpA];\n            G[mp[tmpB]].PB(nw);\n        }\n        bool exi = false;\n        FOR(i, M){\n            sf(\"%s\", tmpA);\n            if(mp[tmpA] == st)\n                exi = true;\n            oil[oilcnt++] = mp[tmpA];\n        }\n        if(!exi)\n            oil[oilcnt++] = st;\n        FOR(i, oilcnt){\n            curvis = false;\n            dfs1(oil[i], oil[i], 0);\n        }\n        djk.init(cnt);\n        djk.dijkstra(st);\n        if(djk.d[ed] == INF)\n            pf(\"-1\\n\");\n        else{\n            pf(\"%d\\n\", djk.d[ed]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( nstat.size(), vector<int>( n, INF ) );\n\tfor( int from = 0; from < nstat.size(); ++from ){\n\t\tint n_from = nstat[from];\n\t\tdist[from][n_from] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, nstat[from] ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_f = p.second;\n\t\t\tif( dist[from][n_f] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_f].size(); ++i ){\n\t\t\t\tint n_to = road[n_f][i].first;\n\t\t\t\tint ds = p.first + road[n_f][i].second;\n\t\t\t\t\n\t\t\t\tif( ds <= cap && dist[from][n_to] > ds ){\n\t\t\t\t\tdist[from][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[from][n_to] <= cap && dp[to] > dp[from] + dist[from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 3030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, n, m, cap, gg[MAX_V];\nvector <edge> G[MAX_V], GG[MAX_V];\nint d[MAX_V];\nvector <int> g(MAX_V);\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nmap <string, int> ma;\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &n, &m, &cap);\n\t\tif(n == 0 && m == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear(), GG[i].clear();\n\t\tg.clear();\n\t\tmemset(gg, 0, sizeof(gg));\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma.clear();\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t\t//cout <<ma[a] << ' ' << ma[b] << ' ' << k << endl;\n\t\t}\n\t\tg.push_back(0);\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tg.push_back(ma[a]);\n\t\t\tgg[ma[a]] = 1;\n\t\t\t//cout << ma[a] << endl;\n\t\t}\n\t\tg.push_back(1);\n\t\tfor(i = 0; i < g.size(); i++)\n\t\t{\n\t\t\tdijkstra1(g[i]);\n\t\t\tfor(j = 0; j < V; j++)\n\t\t\t{\n\t\t\t\tif(gg[j] && d[j] <= cap && j != g[i])\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(g[i], j, d[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<string>\n#include<map>\n#define maxn 30000+10\n#define maxe 10000+10\n#define inf 1000000000\nusing namespace std;\ntypedef struct Edge{\n\tint w;\n\tint to;\n\tint next;\n}Edge;\nEdge edge[maxe];\nint head[maxn];\nint dist[maxn][2000+10];\nbool inque[maxn][2000+10];\nint n,m,cap,cnt,cc;\nint is[10000];\nvoid add(int u,int v,int w)\n{\n    edge[cnt].w=w;edge[cnt].to=v;edge[cnt].next=head[u];\n    head[u]=cnt++;\n    return;\n}\ntypedef struct XH{\n    int p;\n    int has;\n}XH;\nbool spfa(int s)\n{\n\tint i,j;\n\tqueue<XH> q;\n\t//memset(outque,0,sizeof(outque));\n\tfor(i=1;i<=n;i++)\n        for(j=0;j<=cap;j++) {dist[i][j]=inf;inque[i][j]=0;}\n\tdist[s][cap]=0;\n\tinque[s][cap]=1;\n\tXH sr;sr.p=s;sr.has=cap;\n\tq.push(sr);\n\twhile(!q.empty())\n\t{\n\t\tXH tmp=q.front();q.pop();\n\t\tint u=tmp.p;\n\t\tint has=tmp.has;\n\t\tinque[u][has]=0;\n        for(i=head[u];i!=-1;i=edge[i].next)\n\t\t{\n\t\t\tint v=edge[i].to,w=edge[i].w;\n\t\t\tif(has-w<0) continue;\n\t\t\tint nowhas=has-w;\n\t\t\tif(is[v]) nowhas=cap;\n            if(dist[u][has]+w<dist[v][nowhas])\n            {\n                dist[v][nowhas]=dist[u][has]+w;\n\n                if(!inque[v][nowhas])\n                {\n                    XH xh;xh.p=v;xh.has=nowhas;\n                    q.push(xh);\n                    inque[v][nowhas]=1;\n                }\n            }\n\t\t}\n\t}\n\treturn true;\n}\nmap<string,int> city;\ntypedef struct Node{\n    int x,y,d;\n}Node;\nNode node[3100];\nint main()\n{\n    int i,j,w;\n    while(~scanf(\"%d%d%d\",&n,&m,&cap) && !(n==0 && m==0 && cap==0))\n    {\n        cnt=0;memset(head,-1,sizeof(head));\n        memset(is,0,sizeof(is));\n        if(!city.empty()) city.clear();\n        char s1[30],s2[30];\n        cc=0;\n        scanf(\"%s%s\",s1,s2);\n        city[(string)s1]=++cc;\n        city[(string)s2]=++cc;\n        string sr=s1,dest=s2;\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%s%s%d\",s1,s2,&w);\n            if(city.find((string)s1)==city.end())\n                city[(string)s1]=++cc;\n            if(city.find((string)s2)==city.end())\n                city[(string)s2]=++cc;\n            node[i].x=city[(string)s1];\n            node[i].y=city[(string)s2];\n            node[i].d=w;\n        }\n        n=cc;\n        char ss[400];\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%s\",ss);\n            is[city[(string)ss]]=1;\n        }\n        for(i=1;i<=n;i++)\n        {\n            int u=node[i].x,v=node[i].y,d=node[i].d;\n            add(u,v,d);add(v,u,d);\n        }\n        int s=city[(string)sr],t=city[(string)dest];\n        cap*=10;\n        spfa(s);\n        int ans=inf;\n        for(i=0;i<=cap;i++)\n            if(dist[t][i]<ans) ans=dist[t][i];\n        if(ans>=inf) printf(\"-1\\n\");\n        else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    dp[get_city_id(cities,src)][10*capacity] = true;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>v,from,to;\nvector<int>cost;\nmap<string,int>id;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<map<int, int>> min_dist(n);\n\n        int res = inf;\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(min_dist[v].find(rest) != end(min_dist[v])) continue;\n            min_dist[v][rest] = dist;\n\n            if(v == t){\n                res = dist;\n                break;\n            }\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv].find(nrest) != end(min_dist[nv])) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\nusing namespace std;\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nvector<pair<int,int> > v[6001];\nbool sta[6001];\nint dp[6001][2001];\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2+1;i++){\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(mp(M[b],c));\n      v[M[b]].push_back(mp(M[a],c));\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.n][u.a]<u.dis)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tbreak;\n      }\n\n      for(int i=0;i<v[u.n].size();i++){\n\n\tif(sta[u.n]){\n\t  if(v[u.n][i].s<cap){\n\t    int sum1=u.dis+v[u.n][i].s,sum2=cap-v[u.n][i].s;\n\t    if(sum1<dp[v[u.n][i].f][sum2]){\n\t      dp[v[u.n][i].f][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].f,sum2,sum1));\n\t    }\n\t  }\n\t}\n\telse {\n\t  if(v[u.n][i].s<u.a){\n\t    int sum1=u.dis+v[u.n][i].s,sum2=u.a-v[u.n][i].s;\n\t    if(sum1<dp[v[u.n][i].f][sum2]){\n\t      dp[v[u.n][i].f][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].f,sum2,sum1));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    long long int INF = 1e10, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n        else\n          dp1[n-1] = min(dp1[n-1], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n        else\n          dp2[n-1] = min(dp2[n-1], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\nstruct node{\n  int index,gas, cost;\n  node(int index,int gas,int cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst int MAX=INT_MAX/2-10;\nconst int NONE=-1;\n\nint main(){\n  int r,m,cap;\n  while(cin>>r>>m>>cap,r|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvp dist;\n    vs cities;\n    REP(i,r){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n        dist.push_back(vp());\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n        dist.push_back(vp());\n      }\n      dist[ai].push_back(make_pair(bi,d));\n      dist[bi].push_back(make_pair(ai,d));\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    int n=cities.size();\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvi cost(n,vi(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(ii,dist[cnode.index].size()){\n        int i=dist[cnode.index][ii].first;\n        int dd=dist[cnode.index][ii].second;\n        if(i!=cnode.index&&dd!=NONE){\n          int newcost=cnode.cost+dd;\n          int newgas=cnode.gas-dd;\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    int ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<ctype.h>\n#include<set>\n#include<map>\nusing namespace std;\nshort n,m,ca,num,p1,p2,a[3005][3005],dis[3005][3005],cap[3005];\nint ans[3005];\nint p[305][305];\nbool vis[305];\nmap<string,short> name;\nvoid spfa(short x,short cap_no){\n\tshort i,now,d[100000];int f[3005],head,tail;\n\tbool e[3005];\n\tfor (i=1;i<=num;i++){\n\t\tf[i]=0x7fffffff;\n\t\te[i]=false;\n\t}\n\thead=0;tail=1;\n\tf[x]=0;\n\te[x]=true;\n\td[1]=x;\n\twhile (head<tail){\n\t\thead++;\n\t\tnow=d[head];\n\t\tfor (i=1;i<=a[now][0];i++){\n\t\t\tif (f[now]+dis[now][i]<f[a[now][i]]) {\n\t\t\t\tf[a[now][i]]=f[now]+dis[now][i];\n\t\t\t\tif (e[a[now][i]]==false){\n\t\t\t\t\ttail++;\n\t\t\t\t\td[tail]=a[now][i];\n\t\t\t\t\te[a[now][i]]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te[now]=false;\n\t}\n\tfor (i=1;i<=m;i++) p[cap_no][i]=f[cap[i]];\n}\nvoid dfs(int t){\n\tshort i;\n\tfor (i=1;i<=m;i++) if (p[t][i]<=ca*10&&t!=i){\n\t\tans[i]=min(ans[i],ans[t]+p[t][i]);\n\t\tif (vis[i]==false){\n\t\t\tvis[i]=true;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\n\nint main()\n{\nwhile (1){\n\tscanf(\"%d%d%d\",&n,&m,&ca);\n\tif (0==n&&0==m&&ca==0) break;\n\tstring s,ss;\n\tcin>>s>>ss;\n\tnum=2;\n\tname.insert(pair<string,short>(s,1));\n\tname.insert(pair<string,short>(ss,3002));\n\ta[1][0]=0;\n\tfor (short i=0;i<n;i++){\n\t\tcin>>s;\n\t\tif (name.count(s)==0) {name.insert(pair<string,short>(s,num));\n\t\t\ta[num][0]=0;p1=num;num++;}\n\t\telse p1=name[s];\n\t\tcin>>s;\n\t\tif (name.count(s)==0) {name.insert(pair<string,short>(s,num));\n\t\t\ta[num][0]=0;p2=num;num++;}\n\t\telse p2=name[s];\n\t\ta[p1][0]++;\n\t\ta[p1][a[p1][0]]=p2;\n\t\ta[p2][0]++;\n\t\ta[p2][a[p2][0]]=p1;\n\t\tscanf(\"%d\",&dis[p1][a[p1][0]]);\n\t\tdis[p2][a[p2][0]]=dis[p1][a[p1][0]];\n\t}\n\tname[ss]=num;\n\tcap[1]=1;\n\tcap[m+2]=num;\n\tfor (short i=1;i<=a[3002][0];i++){a[num][i]=a[3002][i];dis[num][i]=dis[3002][i];}\n\tfor (short i=1;i<=num-1;i++){\n\tfor (short j=1;j<=a[i][0];j++)if (a[i][j]==3002) a[i][j]=num;\n\t}\n\tfor (short i=2;i<=m+1;i++){\n\tcin>>s;\n\tcap[i]=name[s];\n}\nm=m+2;\n\tfor (short i=1;i<=m;i++)\n\t\tspfa(cap[i],i);\n\tmemset(vis,0,sizeof(vis));\n\tfor (short i=1;i<=m;i++) ans[i]=0x7fffffff;\n\tans[1]=0;\n\tdfs(1);\nif (ans[m]==0x7fffffff)printf(\"%d\\n\",-1);\n\telse printf(\"%d\\n\",ans[m]);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6001];\nstring city[6001];\nbool gs[6001];\nint dist[2001][6001];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n\n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap) continue;\n      int tar = max(cap-e.d, gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n\n    rep(i,3005) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    C *= 10;\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n\n    rep(i,M){\n      string s;  cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    dijkstra(recity[src]);\n\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes(total_roads*2);\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\n\nint dijkstra(){\n  if(n>3000) return -1;\n  vector<vector<int> >D(n,vector<int>(n,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[now.id][now.c]+c);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[333][22], d[333][22];\nchar st[333][22];\nint w[333];\nvector<edge> g[666];\nbool sta[666];\nint cost[666][2222];\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    scanf(\"%s%s\",s,t);\n    vector<string> node;\n    for( int i = 0; i < 666; i++ ) {\n      g[i].clear();\n      sta[i] = false;\n      for( int j = 0; j < 2222; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      rep(i,MAX)\n\t{\n\t  G[i].clear();\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx <= MAX);\n   \n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nvector<pair<int, int> > E[6010];\nbool gas[6010];\nll dist[6010][3010];\nbool done[6010][3010];\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1) return q.second;\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas[nn]) nc = CAP;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nn * 10000 + nc, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tint idx = 0;\n\t\tmap<string, int> m;\n\n\t\tstring src, dest; cin >> src >> dest;\n\t\tm[src] = 0; m[dest] = 1;\n\t\tidx = 2;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\t\tint d; cin >> d;\n\t\t\tE[m[a]].push_back(make_pair(m[b], d));\n\t\t\tE[m[b]].push_back(make_pair(m[a], d));\n\t\t}\n\n\t\trep(i, 0, 6010) gas[i] = false;\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\t\tgas[m[s]] = true;\n\t\t}\n\n\t\trep(i, 0, 6010) rep(j, 0, 3010) dist[i][j] = INF;\n\t\trep(i, 0, 6010) rep(j, 0, 3010) done[i][j] = false;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    dp[get_city_id(cities,src)][10*capacity] = true;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n\ntypedef long long ll;\n\nusing namespace std;\nconst int max_n = 3030;\nvector < pair<int, int> > G[max_n];\nint g[max_n], n, m, cap;\nstruct node\n{\n\tint k;\n\tint res;\n\tint dis;\n\tfriend int operator < (node a, node b)\n\t{\n\t\treturn a.dis > b.dis;\n\t}\n};\nint bfs()\n{\n\tint vis[max_n] = {};\n\tpriority_queue <node> que;\n\tnode now , temp;\n\tnow.k = 0;\n\tnow.res = cap;\n\tnow.dis = 0;\n\tque.push(now);\n\tvis[0] = 1;\n\twhile(!que.empty())\n\t{\n\t\tnow = que.top();\n\t\tque.pop();\n\t\tif(now.k == 1)\n\t\t\treturn now.dis;\n\t\tfor(int i = 0; i < G[now.k].size(); i++)\n\t\t{\n\t\t\ttemp.res = now.res - G[now.k][i].second;\n\t\t\tif(temp.res >= 0)\n\t\t\t{\n\t\t\t\ttemp.k = G[now.k][i].first;\n\t\t\t\ttemp.dis = now.dis + G[now.k][i].second;\n\t\t\t\tif(g[G[now.k][i].first] && !vis[G[now.k][i].first])\n\t\t\t\t{\n\t\t\t\t\ttemp.res = cap;\n\t\t\t\t\tvis[G[now.k][i].first] = 1;\n\t\t\t\t\tque.push(temp);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tque.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &n, &m, &cap);\n\t\tif(n == 0 && m == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i <= n; i++)\n\t\t\tG[i].clear();\n\t\tmemset(g, 0, sizeof(g));\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k, num = 0;\n\t\tmap <string, int> ma;\n\t\tcin >> a >> b;\n\t\tma[a] = num++;\n\t\tma[b] = num++;\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = num++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = num++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tG[ma[a]].push_back(make_pair(ma[b], k));\n\t\t\t\tG[ma[b]].push_back(make_pair(ma[a], k));\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tg[ma[a]] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<int, int> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      int nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<int, int> >,vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<int, int> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      int pos = now.second.first;\n      int f = now.second.second;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tint np = edge[pos][i].first;\n\tint nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvector<int> dijkstra(int n, int s, vector<vector<int>>& g){\n\tvector<int> dis(n,1e8);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tint cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis;\n}\n\nconst int INF = 1e8;\n\npair<int,int> e[3005];\nint d[3005];\nint t[305];\n\nint input(int n, int m){\n\tmap<string,int> id;\n\n\tstring src, dist;\n\tcin >> src >> dist;\n\tid[src] = id.size();\n\tid[dist] = id.size();\n\n\trep(i,n){\n\t\tstring c1, c2;\n\t\tcin >> c1 >> c2 >> d[i];\n\t\tif(not id.count(c1)) id[c1] = id.size();\n\t\tif(not id.count(c2)) id[c2] = id.size();\n\t\te[i] = make_pair(id[c1], id[c2]);\n\t}\n\n\trep(i,m){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(not id.count(s)) id[s] = id.size();\n\t\tt[i] = id[s];\n\t}\n\n\tt[m] = id[src];\n\tt[m + 1] = id[dist];\n\treturn id.size();\n}\n\nint main(){\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tint v = input(n, m) + 5;\n\n\t\tvector<vector<int>> g(v, vector<int>(v, INF)), ng(v, vector<int>(v, INF));\n\t\trep(i,n){\n\t\t\tint x = e[i].first, y = e[i].second;\n\t\t\tg[x][y] = g[y][x] = d[i];\n\t\t}\n\n\t\trep(i,m + 2){\n\t\t\tint x = t[i];\n\t\t\tvector<int> dis = dijkstra(v, x, g);\n\t\t\trep(j,m + 2){\n\t\t\t\tint y = t[j];\n\t\t\t\tif(dis[y] > cap) continue;\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,v){\n\t\t//\trep(j,v){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint ans = dijkstra(v, t[m], ng).at(t[m + 1]);\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct E{\n  string t;\n  int d;\n};\n\nstruct S{\n  string v;\n  int r,d;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nint main(){\n  for(int n,mm,cap;cin>>n>>mm>>cap,n|mm|cap;){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    map<string,vector<E> > m;\n    for(int i=0;i<n;i++){\n      string c[2];\n      int d;\n      cin>>c[0]>>c[1]>>d;\n      for(int j=0;j<2;j++){\n\tE ce={c[j^1],d};\n\tm[c[j]].push_back(ce);\n      }\n    }\n    set<string> gs;\n    for(int i=0;i<mm;i++){\n      string s;\n      cin>>s;\n      gs.insert(s);\n    }\n    priority_queue<S> que;\n    S is={src,cap,0};\n    que.push(is);\n    map<string,map<int,int> > p;\n    while(!que.empty()){\n      S c=que.top();\n      if(c.v==dest)break;\n      que.pop();\n      map<int,int>::iterator it=p[c.v].lower_bound(c.r);\n      if(it!=p[c.v].end()&&it->second<=c.d)continue;\n      p[c.v][c.r]=c.d;\n      for(int i=0;i<m[c.v].size();i++){\n\tif(m[c.v][i].d<=c.r){\n\t  S n={m[c.v][i].t,c.r-m[c.v][i].d,c.d+m[c.v][i].d};\n\t  if(gs.count(n.v)){\n\t    n.r=cap;\n\t  }\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.top().d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][node.cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[3500];\nint d[3500][2005];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m, c;\n    cin >> n >> m >> c;\n    if(!n) break;\n    c *= 10;\n    string s, t;\n    cin >> s >> t;\n    map<string,int> mp;\n    int cnt = 0;\n    REP(i, 3500) g[i].clear();\n    REP(i, n) {\n      string x, y; int l;\n      cin >> x >> y >> l;\n      if(mp.find(x) == mp.end()) {\n        mp[x] = cnt++;\n      }\n      if(mp.find(y) == mp.end()) {\n        mp[y] = cnt++;\n      }\n      g[mp[x]].PB({mp[y], l});\n      g[mp[y]].PB({mp[x], l});\n    }\n    VI exist(cnt, 0);\n    REP(i, m) {\n      string str; cin >> str;\n      exist[mp[str]] = 1;\n    }\n    cout << exist << endl;\n\n    for(auto i: mp) cout << i << endl;\n\n    int src = mp[s], dst = mp[t];\n    REP(i, 3500) REP(j, 2005) d[i][j] = LLINF;\n    d[src][c] = 0;\n    priority_queue<VI, VVI, greater<VI>> que;\n    que.push({d[src][c], src, c});\n\n    while(que.size()) {\n      VI v = que.top(); que.pop();\n      // cout << v << endl;\n      if(v[0] > d[v[1]][v[2]]) continue;\n      if(v[1] == dst) break;\n      for(PII e: g[v[1]]) {\n        if(v[2]>=e.second && d[e.first][v[2]-e.second] > d[v[1]][v[2]] + e.second) {\n          int tmp = exist[e.first] == 1 ? c : v[2] - e.second;\n          d[e.first][tmp] = d[v[1]][v[2]] + e.second;\n          que.push({d[e.first][tmp], e.first, tmp});\n        }\n      }\n    }\n\n    int ans = LLINF;\n    REP(i, c+1) chmin(ans, d[dst][i]);\n    if(ans == LLINF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxm = 3001;\nconst int maxn = 3005;\nconst int INF = 0x3ffffff;\nstruct Side{\n\tint to,next,w;\n}side[maxm*2];\nint node[maxn],top;\nvoid add_side(int u,int v,int w){\n\tside[top]=(Side){v,node[u],w};node[u]=top++;\n\tside[top]=(Side){u,node[v],w};node[v]=top++;\n}\nint cap;\nmap<string,int>city;\nint cnt,start,end;\nbool is[maxn];\nint get_id(string str){\n\tif(city.count(str)==0)city[str]=++cnt;\n\treturn city[str];\n}\nint dis[maxn][2001];\nbool inqueue[maxn][2001];\nqueue<pair<int,int> >q;\nint get_dis(){\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int j=0;j<=cap;j++){\n\t\t\tinqueue[i][j]=false;\n\t\t\tdis[i][j]=INF;\n\t\t}\n\t}\n\tdis[start][cap]=0;\n\tpair<int,int>tmp=make_pair(start,cap);\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttmp=q.front();q.pop();\n\t\tint u=tmp.first;\n\t\tint c=tmp.second;\n\t\tinqueue[u][c]=false;\n\t\tif(c!=cap&&is[u]){\n\t\t\tif(dis[u][c]<dis[u][cap]){\n\t\t\t\tdis[u][cap]=dis[u][c];\n\t\t\t\tif(!inqueue[u][cap]){\n\t\t\t\t\tinqueue[u][cap]=true;\n\t\t\t\t\tq.push(make_pair(u,cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=node[u];i!=-1;i=side[i].next){\n\t\t\tint v=side[i].to;\n\t\t\tint last=c-side[i].w;\n\t\t\tif(last<0)continue;\n\t\t\tif(dis[u][c]+side[i].w<dis[v][last]){\n\t\t\t\tdis[v][last]=dis[u][c]+side[i].w;\n\t\t\t\tif(!inqueue[v][last]){\n\t\t\t\t\tinqueue[v][last]=true;\n\t\t\t\t\tq.push(make_pair(v,last));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(int i=0;i<=cap;i++){\n\t\tans=min(ans,dis[end][i]);\n\t}\n\treturn ans==INF?-1:ans;\n}\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d%d%d\",&m,&n,&cap)){\n\t\tif(m==0&&n==0&&cap==0)break;\n\t\tcap=cap*10;\n\t\tcity.clear();\n\t\ttop=0;\n\t\tcnt=0;\n\t\tmemset(node,-1,sizeof(node));\n\t\tmemset(is,false,sizeof(is));\n\t\tstring u,v;\n\t\tcin>>u>>v;\n\t\tstart=get_id(u);\n\t\tend=get_id(v);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v;\n\t\t\tint w;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tint x=get_id(u);\n\t\t\tint y=get_id(v);\n\t\t\tadd_side(x,y,w);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>u;\n\t\t\tis[get_id(u)]=true;\n\t\t}\n\t\tprintf(\"%d\\n\",get_dis());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<edge> g[6011];\n//vector<vector<edge> > g;\n\nvector<bool> sta;\n//vector<vector<int> > cost;\nint cost[6011][2001];\nint from,to;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    {\n      vector<string> node;\n      scanf(\"%s%s\",s,t);\n      node.push_back(s);\n      node.push_back(t);\n      for( int i = 0; i < n; i++ ) {\n        scanf(\"%s%s%d\",c[i],d[i],w+i);\n        node.push_back(c[i]);\n        node.push_back(d[i]);\n      }\n      for( int i = 0; i < m; i++ ) {\n        scanf(\"%s\",st[i]);\n        node.push_back(st[i]);\n      }\n      sort(node.begin(),node.end());\n      node.erase(unique(node.begin(),node.end()),node.end());\n      int sz = node.size();\n      //g.clear();\n      //cost.clear();\n      sta.clear();\n      //g.resize(sz,vector<edge>());\n      //cost.resize(sz,vector<int>(cap*10+1));\n      sta.resize(sz);\n      for( int i = 0; i < sz; i++ ) {\n        sta[i] = false;\n        g[i].clear();\n        for( int j = 0; j <= cap*10; j++ ) {\n          cost[i][j] = 1919810893;\n        }\n      }\n      for( int i = 0; i < n; i++ ) {\n        int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n        int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n        g[a].push_back(edge(b,w[i]));\n        g[b].push_back(edge(a,w[i]));\n      }\n      for( int i = 0; i < m; i++ ) {\n        sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n      }\n      from = lower_bound(node.begin(),node.end(),s)-node.begin();\n      to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    }\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<int> > dist( n, vector<int>( n, INF ) );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\tdist[a][b] = dist[b][a] = d[i];\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\n\tfor( int k = 0; k < n; ++k ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tfor( int j = 0; j < i; ++j ){\n\t\t\t\tif( dist[i][j] > dist[i][k] + dist[k][j] ){\n\t\t\t\t\tdist[i][j] = dist[j][i] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcap *= 10;\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\ttypedef pair<int,int> pii;\n\tpriority_queue< pii, deque<pii>, greater<pii> > pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[n_from][n_to] <= cap && dp[to] > dp[from] + dist[n_from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[n_from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<short, short> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      if (mp[dest] == pos) break;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\nint n,m,l,qq;\n#define MAXN 6001\nvector < pair<int,int> > a[MAXN],b[MAXN];\nconst int inf = 0x7fffffff;\nint d[MAXN];\nbool bo[MAXN],p[MAXN];\nmap <string , int> hash;\nvoid  spfa(int s )\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        d[i]=inf;\n    }\n    memset(bo,0,sizeof(bo));\n    d[s]=0;bo[s]=1;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();bo[now]=0;\n        for (int i =0; i < a[now].size(); ++i)\n        {\n            int v=a[now][i].first;\n            int abc=a[now][i].second;\n            if (d[v]-abc>d[now]) \n            {\n                d[v]=abc+d[now];\n                if (!bo[v])\n                {\n                    bo[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nvoid  spfa2(int s )\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        d[i]=inf;\n    }\n    memset(bo,0,sizeof(bo));\n    d[s]=0;bo[s]=1;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();bo[now]=0;\n        for (int i =0; i < b[now].size(); ++i)\n        {\n            int v=b[now][i].first;\n            int abc=b[now][i].second;\n            if (d[v]-abc>d[now]) \n            {\n                d[v]=abc+d[now];\n                if (!bo[v])\n                {\n                    bo[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\nstring temp,temp2;\nint main(int argc, char const *argv[])\n{\n   // freopen(\"input.txt\",\"r\",stdin);\n    while (scanf(\"%d%d%d\",&m,&qq,&l)!=EOF)\n    {\n        if (m==0 && qq==0 && l==0) break;\n        hash.clear();\n        l *= 10;\n        for (int i = 0; i < MAXN; ++i)\n        {\n            a[i].clear();\n            b[i].clear();\n        }\n        memset(p,0,sizeof(p));\n        n=0;\n        int s,t;\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        s=hash[temp];\n        cin>>temp;\n        if (!hash.count(temp))\n        {\n            hash[temp]=++n;\n        }\n        t=hash[temp];\n        for (int i = 0; i < m; ++i)\n        {\n            cin>>temp>>temp2;\n            int x,y,z;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            if (!hash.count(temp2))\n            {\n                hash[temp2]=++n;\n            }\n            x=hash[temp];\n            y=hash[temp2];\n            cin>>z;\n            if (z <= l)\n            {\n                a[x].push_back(make_pair(y,z));\n                a[y].push_back(make_pair(x,z));\n                //cout<<x<<' '<<y<<' '<<z<<endl;\n            }\n        }\n        int ans=inf;\n\n        for (int i = 0; i < qq; ++i)\n        {\n            cin>>temp;\n            if (!hash.count(temp))\n            {\n                hash[temp]=++n;\n            }\n            int x=hash[temp];\n            p[x]=1;\n        }\n        for (int i = 0; i <= n; ++i)\n        {\n            if (p[i])\n            {\n                spfa(i);\n                //cout<<i<<endl;\n                for (int j = 1; j <= n; ++j)\n                {\n                    if (d[j]<=l && j!=i && (p[j]|| j==t))\n                    {\n                        b[i].push_back(make_pair(j,d[j]));\n                        b[j].push_back(make_pair(i,d[j]));\n                    }\n                }\n            }\n        }\n        spfa(s);\n        for (int j = 1; j <= n; ++j)\n        {\n            if (d[j]<=l && j!=s && (p[j]|| j==t))\n            {\n                b[s].push_back(make_pair(j,d[j]));\n                b[j].push_back(make_pair(s,d[j]));\n            }\n        }\n        /*for (int i = 1; i <=n; ++i)\n        {\n            for (int j = 0; j < b[i].size(); ++j)\n            {\n                cout<<i<<\" \"<<b[i][j].first<<' '<<b[i][j].second<<endl;\n            }\n            cout<<endl;\n        }*/\n        spfa2(s);\n        //cout<<s<<' '<<t<<endl;\n        ans=d[t];\n        if (ans==inf)\n        {\n            puts(\"-1\");\n        }\n        else\n        {\n            printf(\"%d\\n\",ans );\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<map<int, int>> min_dist(n);\n\n        int res = inf;\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(min_dist[v].find(rest) != end(min_dist[v])) continue;\n            min_dist[v][rest] = dist;\n\n            if(v == t){\n                res = inf;\n                break;\n            }\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv].find(nrest) != end(min_dist[nv])) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define INF (1<<28)\n#define MAX_N 6005\n#define MAX_M 2005\n\nstruct state{\n  int pos,cost;\n  bool operator < ( const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint n,m,l,cnt;\nstring si,ti,str;\nvector<edge> G[MAX_N];\nmap<string,int> change;\nint T[MAX_M][MAX_M];\nint d[MAX_N];\n\nint A[MAX_M];\nint B[MAX_M];\n\nvoid solve(int si){\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  priority_queue< state > Q;\n  d[si]=0;\n  Q.push((state){si,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    if(s.cost>l)break;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(s.cost+e.cost<d[e.to]){\n        d[e.to]=s.cost+e.cost;\n        Q.push((state){e.to,d[e.to]});\n      }\n    }\n  }\n}\n\nvoid init(){\n  change.clear();\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l;\n    if(n==0&&m==0&&l==0)break;\n    l*=10;\n    \n    cin>>si>>ti;\n    init();\n    cnt=1;\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int a=change[str];\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int b=change[str];\n      int c;\n      cin>>c;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    vector<int> vec;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      vec.push_back(change[str]);\n    }\n\n    for(int i=0;i<m;i++){\n      solve(vec[i]);\n      for(int j=0;j<m;j++){\n        T[i][j]=d[vec[j]];\n      }\n    }\n\n\n    int ans=INF;\n    solve(change[si]);\n    for(int i=0;i<m;i++)A[i]=d[vec[i]];\n    if(d[change[ti]] <= l)ans=d[change[ti]];\n    \n    \n    solve(change[ti]);\n    for(int i=0;i<m;i++)B[i]=d[vec[i]];\n    \n    priority_queue< state > Q;\n    for(int i=0;i<m;i++){\n      d[i]=INF;\n      if(A[i]>l)continue;\n      d[i]=A[i];\n      Q.push((state){i,A[i]});\n    }\n\n    while(!Q.empty()){\n      state s=Q.top();Q.pop();\n      if(s.cost>d[s.pos])continue;\n      for(int i=0;i<m;i++){\n        if(T[s.pos][i]>l)continue;\n        if(s.cost+T[s.pos][i]<d[i]){\n          d[i]=s.cost+T[s.pos][i];\n          Q.push((state){i,d[i]});\n        }\n      }\n    }\n    \n\n\n    \n    for(int i=0;i<m;i++){\n      if(B[i]>l)continue;\n      ans=min(ans,d[i]+B[i]);\n    }\n\n    if(ans==INF)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nvector<string>v,from,to;\nvector<int>cost;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)G[i].clear();\n\n    static map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nvector<string>v,from,to;\nvector<int>cost;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,int> a, pair<int,int> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\n//int dist[6010][2010];\n//bool done[6010][2010];\n\n//vector<vector<int> > dist;\n//vector<vector<bool> > done;\n\n\n\nint solve()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tvector<vector<int> > dist;\n\tvector<vector<bool> > done;\n\n\tvector<pair<int, int> > E[6010];\n\tset<int> gas;\n\n\tstring src, dest;\n\tcin >> src >> dest;\n\tm[src] = 0; m[dest] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tstring a, b;\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\t//dist.resize(idx, vector<int>(CAP + 1, INF));\n\t//done.resize(idx, vector<bool>(CAP + 1, false));\n\n\tdist.resize(idx);\n\trep(i, 0, idx) dist[i] = vector<int>(CAP + 1);\n\trep(i, 0, idx) done[i] = vector<bool>(CAP + 1);\n\n\trep(i, 0, idx) rep(j, 0, CAP + 1) dist[i][j] = INF;\n\trep(i, 0, idx) rep(j, 0, CAP + 1) done[i][j] = false;\n\n\t/*rep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;*/\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tint ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nunordered_map<string, int> ids;\nvector<P> roads[6000];\nvector<int> st;\nint cap;\nint N;\nint M;\nint dist[6000];\nvector<P> road2[302];\nvoid exec()\n{\n\tfill(roads,roads+6000, vector<P>());\n\tfill(road2,road2+302, vector<P>());\n\tst.clear();\n\tids.clear();\n\tcin >> N >> M >> cap;\n\tcap*=10;\n\tif((N|M|cap)==0)exit(0);\n\tstring in;\n\tcin >> in;\n\tint id=0;\n\tids[in]=id++;\n\tcin >> in;\n\tids[in]=id++;\n\tfor(int i=0;i<N;i++){\n\t\tstring c;\n\t\tint d;\n\t\tcin >> in >> c >> d;\n\t\tif(ids.find(in)==ids.end())\n\t\t{\n\t\t\tids[in]=id++;\n\t\t}\n\t\tif(ids.find(c)==ids.end()){\n\t\t\tids[c]=id++;\n\t\t}\n\t\tint a=ids[in];\n\t\tint b=ids[c];\n\t\troads[a].push_back(P(b,d));\n\t\troads[b].push_back(P(a,d));\n\t\t//cout << a << \", \" << b << \":: \" << d << endl;\n\t}\n\t/*\n\tfor(auto a:ids)\n\t{\n\t\tcout << a.first << \": \" << a.second << endl;\n\t}*/\n\tst.push_back(0);\n\tst.push_back(1);\n\tfor(int i=0;i<M;i++){\n\t\tcin >> in;\n\t\tint a=ids[in];\n\t\tif(a>1){\n\t\t\tst.push_back(a);\n\t\t}\n\t}\n\tfor(int i=0;i<st.size();i++){\n\t\tfill(dist,dist+ids.size(),cap+1);\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P(0,st[i]));\n\t\tdist[st[i]]=0;\n\t\twhile(q.size()){\n\t\t\tint f=q.top().second;\n\t\t\tint d=q.top().first;\n\t\t\tq.pop();\n\t\t\tif(dist[f]<d)continue;\n\t\t\tfor(auto p:roads[f]){\n\t\t\t\tint b=p.first;\n\t\t\t\tint dd=d+p.second;\n\t\t\t\tif(dd<dist[b]){\n\t\t\t\t\tq.push(P(dd,b));\n\t\t\t\t\tdist[b]=dd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<st.size();j++){\n\t\t\tif(dist[st[j]]<=cap)\n\t\t\t{\n\t\t\t\troad2[i].push_back(P(j,dist[st[j]]));\n\t\t\t\t//cout << i << \", \" << j << \": \" << dist[st[j]] << \", \" << st[j] << \": \" << ids.size() << endl;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfill(dist,dist+st.size(),INT_MAX);\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P(0,0));\n\t\tdist[0]=0;\n\t\twhile(q.size()){\n\t\t\tint f=q.top().second;\n\t\t\tint d=q.top().first;\n\t\t\tq.pop();\n\t\t\tif(dist[f]<d)continue;\n\t\t\tfor(auto p:road2[f]){\n\t\t\t\tint b=p.first;\n\t\t\t\tint dd=d+p.second;\n\t\t\t\tif(dd<dist[b]){\n\t\t\t\t\tq.push(P(dd,b));\n\t\t\t\t\tdist[b]=dd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[1]<INT_MAX){\n\t\tcout << dist[1] << endl;\n\t}\n\telse\n\t{\n\t\tcout << -1 << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\n//map<int, ll> dist;\n//set<int> done;\n\nll dist[6010][2010];\nbool done[6010][2010];\nvector<pair<int, int> > E[6010];\nset<int> gas;\n\nstring a, b, s;\n\nvoid init()\n{\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tcin >> a >> b;\n\tm[a] = 0; m[b] = 1;\n\tidx = 2;\n\n\trep(i, 0, 6010) E[i].clear();\n\trep(i, 0, N)\n\t{\n\t\tcin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\tgas.clear();\n\trep(i, 0, M)\n\t{\n\t\tcin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\trep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n}\n\nll solve()\n{\n\tinit();\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\t//dist[CAP] = 0;\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\t/*if (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);*/\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\t/*if (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}*/\n\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#define int short\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,remain,cost;\n\tnode(int index,int remain,int cost):index(index),remain(remain),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nint g[6001][6001];\nint station[6001];\nint cost[6001][2001];\n\nconst int MAX=(1<<14);\nconst int NONE=-1;\n\n#define int int\nint main() {\n#define int short\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        int nc=cities.size();\n        REP(i,nc)REP(j,nc){\n            g[i][j]=NONE;\n\t\t}\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n\n        priority_queue<node> q;\n        q.push(node(src_i,cap,0));\n        REP(i,6001)REP(j,2001)cost[i][j]=MAX;\n        cost[0][cap]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.remain]<cnode.cost){\n                continue;\n\t\t    }\n            REP(i,nc){\n                if(g[cnode.index][i]!=NONE){\n                    int newremain=cnode.remain-g[cnode.index][i];\n                    int newcost=cnode.cost+g[cnode.index][i];\n                    if(newremain>=0){\n                        newremain=station[i] ? cap : newremain;\n\t\t\t\t\t\tif(cost[i][newremain]>newcost){\n                            cost[i][newremain]=newcost;\n                            q.push(node(i,newremain,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n        int ans=MAX;\n        REP(i,cap+1){\n            ans=min(ans,cost[dst_i][i]);\n\t    }\n        cout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N+1);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n#if 0\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nclass Edge{\npublic:\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost){};\n};\n\nvector<int> dijkstra(vector<vector<Edge>>& G, int s){\n    int N = G.size();\n    vector<int> d(N, INF);\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    d[s] = 0;\n    q.push(make_pair(d[s], s));\n    \n    while(!q.empty()){\n        pair<int, int> v = q.top(); q.pop();\n        if(v.first != d[v.second])\n            continue;\n        \n        for(Edge &e: G[v.second]){\n            if(e.cost + d[v.second] < d[e.to]){\n                d[e.to] = e.cost + d[v.second];\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\n\nint N, M, C;\n\nvoid solve(){\n    string src, dst;\n    cin >> src >> dst;\n    \n    map<string, int> stoi;\n    vector<string> cs(N), cd(N);\n    vector<int> ds(N);\n    for(int i=0; i<N; i++){\n        cin >> cs[i] >> cd[i] >> ds[i];\n        \n        if(stoi.find(cs[i]) == stoi.end())\n            stoi[cs[i]] = stoi.size();\n        if(stoi.find(cd[i]) == stoi.end())\n            stoi[cd[i]] = stoi.size();\n    }\n    \n    vector<int> gass(M);\n    for(int i=0; i<M; i++){\n        string s; cin >> s;\n        gass[i] = stoi[s];\n    }\n    gass.push_back(stoi[src]);\n    gass.push_back(stoi[dst]);\n    M = gass.size();\n    \n    vector<vector<Edge>> G(stoi.size());\n    for(int i=0; i<N; i++){\n        int si = stoi[cs[i]];\n        int di = stoi[cd[i]];\n        \n        G[si].emplace_back(di, ds[i]);\n        G[di].emplace_back(si, ds[i]);\n    }\n    \n    vector<vector<int>> mat(M, vector<int>(M, INF));\n    for(int i=0; i<M; i++)\n        mat[i][i] = 0;\n        \n    for(int i=0; i<M; i++){\n        int gs = gass[i];\n        auto d = dijkstra(G, gs);\n        for(int j=0; j<M; j++){\n            int gd = gass[j];\n            if(d[gd] <= C*10){\n                mat[i][j] = d[gd];\n                mat[j][i] = d[gd];\n            }\n        }\n    }\n    \n    for(int k=0; k<M; k++)\n        for(int i=0; i<M; i++)\n            for(int j=0; j<M; j++)\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n\n    cout << (mat[M-2][M-1] == INF? -1: mat[M-2][M-1]) << endl;\n}\n\nint main(){\n    while(cin >> N >> M >> C, N|M|C)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 6001;\nconst int MAX_CAP = 2002;\n\nstruct Edge {\n  int to, cost;\n  Edge() {}\n  Edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct State {\n  int p, cost, oil;\n  State() {}\n  State(int p, int cost, int oil) : p(p), cost(cost), oil(oil) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(oil != s.oil) return oil < s.oil;\n    return p < s.p;\n  }\n};\n\nint Cap, num, Src, Dist;\n\nmap<string, int> id;\nvector<Edge> E[MAX_N];\n\nbool existS[MAX_N];\nint cost[MAX_N][MAX_CAP];\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = num++;\n  }\n  return id[s];\n}\n\n\nint solve() {\n  priority_queue<State> que;\n  State s(Src, 0, Cap);\n  que.push(s);\n  fill(cost[0], cost[num], -1);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.oil] != -1) continue;\n    cost[s.p][s.oil] = s.cost;\n    if(s.p == Dist) return s.cost;\n    if(existS[s.p]) s.oil = Cap;\n    for(int i = 0; i < E[s.p].size(); ++i) {\n      int nextOil = s.oil - E[s.p][i].cost;\n      if(nextOil < 0) continue;\n      if(cost[E[s.p][i].to][nextOil] != -1) continue;\n      que.push(State(E[s.p][i].to, s.cost + E[s.p][i].cost, nextOil));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M >> Cap && (N | M | Cap)) {\n    num = 0;\n    Cap *= 10;\n    id.clear();\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n\n    string src, dist;\n    cin >> src >> dist;\n    Src = getId(src);\n    Dist = getId(dist);\n    for(int i = 0; i < N; ++i) {\n      string from, to;\n      int d;\n      cin >> from >> to >> d;\n      E[getId(from)].push_back(Edge(getId(to), d));\n      E[getId(to)].push_back(Edge(getId(from), d));\n    }\n\n    fill(existS, existS+MAX_N, false);\n    for(int i = 0; i < M; ++i) {\n      string name;\n      cin >> name;\n      existS[getId(name)] = true;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\nusing namespace std;\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nbool sta[3001];\nint dis[3001][3001],dp[3001][2001];\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++)dis[i][j]=inf;\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      dis[M[a]][M[b]]=c;dis[M[b]][M[a]]=c;\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.n][u.a]<u.dis)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tcontinue;\n      }\n\n      for(int i=0;i<n;i++){\n\tif(dis[u.n][i]==inf)continue;\n\tif(sta[u.n]){\n\t  if(dis[u.n][i]<cap){\n\t    int sum1=u.dis+dis[u.n][i],sum2=cap-dis[u.n][i];\n\t    if(sum1<dp[i][sum2]){\n\t      dp[i][sum2]=sum1;\n\t      pq.push(State(i,sum2,sum1));\n\t    }\n\t  }\n\t}\n\telse {\n\t  if(dis[u.n][i]<u.a){\n\t    int sum1=u.dis+dis[u.n][i],sum2=u.a-dis[u.n][i];\n\t    if(sum1<dp[i][sum2]){\n\t      dp[i][sum2]=sum1;\n\t      pq.push(State(i,sum2,sum1));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MT make_tuple\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nint N, M, C, SZ;\nvector<Edge> G[6001];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<string,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[src] = SZ++;\n\tcor[dest] = SZ++;\n\tC *= 10;\n\tREP(i,6010) G[i].clear();\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  if(!cor.count(s1)) cor[s1] = SZ++;\n\t  if(!cor.count(s2)) cor[s2] = SZ++;\n\t  int u = cor[s1], v = cor[s2];\n\t  G[u].PB(Edge(v,d));\n\t  G[v].PB(Edge(u,d));\n\t}\n\n\tset<int> LPG;\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  if(!cor.count(s)) continue;\n\t  LPG.insert(cor[s]);\n\t}\n\n\ttypedef tuple<int,int,int> Node;\n\tVVI dist(SZ+10, VI(C+10,INF));\n\tpriority_queue<Node, vector<Node>, greater<Node> > pq;\n\tdist[0][C] = 0;\n\tpq.push(MT(0,0,C));\n\n\tint ans = INF;\n\twhile(!pq.empty()){\n\t  auto tp = pq.top(); pq.pop();\n\t  int c, v, f;\n\t  tie(c,v,f) = tp;\n\t  if(v == 1){\n\t\tans = c; break;\n\t  }\n\t  if(dist[v][f] < c) continue;\n\t  for(int i=0;i<G[v].size();++i){\n\t\tconst Edge& e = G[v][i];\n\t\tint d = e.cost;\n\t\tif(f < d) continue;\n\t\tint nf = LPG.count(e.to)? C: f-d;\n\t\tif(dist[e.to][nf] > dist[v][f] + d){\n\t\t  dist[e.to][nf] = dist[v][f] + d;\n\t\t  pq.push(MT(dist[e.to][nf], e.to, nf));\n\t\t}\n\t  }\n\t}\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n \nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n \ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n \nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n \nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n \nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      string ssrc,sdest;\n      int src,dest;\n\n      idx = 0;\n      index.clear();\n      rep(i,MAX)G[i].clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n \n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n \n      assert(idx <= MAX);\n\n      rep(i,idx) \n\t{\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}    \n \n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n     \n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n \n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n       \n\t  if(ans <= pox.cost)continue;\n       \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      break;\n\t    }\n \n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next] && next != dest)continue;\n \n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    {        \n\t\t      que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t      for(int j=cap*10;j>=0;j--)mincost[next][j] = min(mincost[next][j],mincost[next][cap*10]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t      for(int j=fuelConsumption;j>=0;j--)mincost[next][j] = min(mincost[next][j],mincost[next][fuelConsumption]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n, m, cap; cin >> n >> m >> cap;\n        cap *= 10;\n        if (n == 0) break;\n\n        map<string,int> cities;\n        string src, dst; cin >> src >> dst;\n        cities[src] = cities[dst] = -1;\n\n        vector<string> u(n), v(n);\n        vector<int> d(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> u[i] >> v[i] >> d[i];\n            cities[u[i]] = cities[v[i]] = -1;\n        }\n        map<string,bool> s;\n        for (int i = 0; i < m; ++i) {\n            string t; cin >> t;\n            s[t] = true;\n            cities[t] = -1;\n        }\n\n        int cnt = 0;\n        for (auto& tp : cities) {\n            tp.second = cnt++;\n        }\n\n        map<int,string> citymap;\n        for (const auto& tp : cities) {\n            citymap[tp.second] = tp.first;\n        }\n\n        vector<vector<edge<int>>> G(cnt);\n        for (int i = 0; i < n; ++i) {\n            G[cities[u[i]]].emplace_back(cities[v[i]], d[i]);\n            G[cities[v[i]]].emplace_back(cities[u[i]], d[i]);\n        }\n\n        int ans = numeric_limits<int>::max();\n\n        auto dist = make_vector<int>(cnt, cap+1, numeric_limits<int>::max());\n        dist[cities[src]][cap] = 0;\n        using Pi = pair<int, pair<int,int>>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        que.emplace(0, make_pair(cities[src], cap));\n\n        while (!que.empty()) {\n            int cost; pair<int,int> p;\n            tie(cost, p) = que.top();\n            que.pop();\n            int v, cp; tie(v, cp) = p;\n            if (dist[v][cp] < cost) continue;\n            if (v == cities[dst]) {\n                ans = cost;\n                break;\n            }\n            for (auto &e : G[v]) {\n                int nxtCost = cost + e.cost,\n                    nxtCap = cp - e.cost;\n                if (nxtCap < 0) continue;\n                if (s[citymap[e.to]]) nxtCap = cap;\n                if (dist[e.to][nxtCap] > nxtCost) {\n                    dist[e.to][nxtCap] = nxtCost;\n                    que.emplace(nxtCost, make_pair(e.to, nxtCap));\n                }\n            }\n        }\n\n        cout << (ans == numeric_limits<int>::max() ? -1 : ans) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#define INF 1<<30\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint n,m,cap;\nstring src,dest;\nstring c1,c2;\nint d;\nstring s;\nbool gas[6100];\nint num;\nvector<P> G[6100];\nmap<P,int> dis;\nmap<string,int> id;\nmap<P,bool> spfa;\n\nint main(){\n  while(cin >> n >> m >> cap,n||m||cap){\n    cin >> src >> dest;\n    cap *= 10;\n    num = 0;\n    id.clear();\n    id[src] = num++; id[dest] = num++;\n\n    for(int i=0;i<6100;i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      cin >> c1 >> c2 >> d;\n      if(id.find(c1) == id.end())id[c1] = num++;\n      if(id.find(c2) == id.end())id[c2] = num++;\n      G[id[c1]].push_back(P(d,id[c2]));\n      G[id[c2]].push_back(P(d,id[c1]));\n    }\n\n    for(int i=0;i<num;i++)gas[i] = false;\n    for(int i=0;i<m;i++){\n      cin >> s;\n      gas[id[s]] = true;\n    }\n\n    dis.clear();\n    dis[P(id[src],cap)] = 0;\n    priority_queue<P2,vector<P2>,greater<P2> > q;\n    q.push(P2(0,P(id[src],cap)));\n    spfa.clear();\n\n    while(q.size()){\n      P2 p = q.top(); q.pop();\n      int dist = p.first;\n      int pos = p.second.first, tank = p.second.second;\n\n      spfa[P(pos,tank)] = true;\n      if(pos == id[dest])break;\n      \n      for(int i=0;i<G[pos].size();i++){\n\tint len = G[pos][i].first;\n\tint nxt = G[pos][i].second;\n\tif(len > tank)continue;\n\tint ntank = tank - len;\n\tif(gas[nxt])ntank = cap;\n\n\tif(spfa.find(P(nxt,ntank)) != spfa.end())continue;\n\n\tif(dis.find(P(nxt,ntank)) == dis.end()){\n\t  dis[P(nxt,ntank)] = dist + len;\n\t  q.push(P2(dist+len,P(nxt,ntank)));\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++){\n      if(dis.find(P(id[dest],i)) != dis.end())ans = min(ans,dis[P(id[dest],i)]);\n    }\n    if(ans == INF){\n      cout << -1 << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<string>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,d; };\n\nint main(){\n\tfor(int m,ng,cap;scanf(\"%d%d%d\",&m,&ng,&cap),m;){\n\t\tcap*=10;\n\n\t\tint n=0; // number of cities\n\t\tvector<edge> adj[7000];\n\t\tbool gas[7000]={};\n\n\t\tmap<string,int> id;\n\t\tchar ss[16],tt[16]; scanf(\"%s%s\",&ss,&tt);\n\t\tif(id.count(ss)==0) id[ss]=n++;\n\t\tif(id.count(tt)==0) id[tt]=n++;\n\t\tint s=id[ss],t=id[tt];\n\n\t\trep(i,m){\n\t\t\tchar a[16],b[16];\n\t\t\tint d; scanf(\"%s%s%d\",a,b,&d);\n\t\t\tif(id.count(a)==0) id[a]=n++;\n\t\t\tif(id.count(b)==0) id[b]=n++;\n\n\t\t\tint u=id[a],v=id[b];\n\t\t\tadj[u].push_back((edge){v,d});\n\t\t\tadj[v].push_back((edge){u,d});\n\t\t}\n\t\trep(i,ng){\n\t\t\tchar a[16]; scanf(\"%s\",a);\n\t\t\tif(id.count(a)) gas[id[a]]=true;\n\t\t}\n\n\t\tstatic int d[7000][2001];\n\t\trep(u,n) rep(c,cap+1) d[u][c]=INF;\n\t\td[s][cap]=0;\n\n\t\tint ans=-1;\n\t\tpriority_queue< pair<int,pii> > pq;\n\t\tpq.push(make_pair(0,make_pair(s,cap)));\n\t\twhile(!pq.empty()){\n\t\t\tint d_now=-pq.top().first;\n\t\t\tint u=pq.top().second.first;\n\t\t\tint c_now=pq.top().second.second;\n\t\t\tpq.pop();\n\n\t\t\tif(d[u][c_now]<d_now) continue;\n\n\t\t\tif(u==t){ ans=d_now; break; }\n\n\t\t\trep(i,adj[u].size()){\n\t\t\t\tedge e=adj[u][i];\n\t\t\t\tif(c_now<e.d) continue;\n\n\t\t\t\tint d_next=d_now+e.d;\n\t\t\t\tint c_next=(gas[e.v]?cap:c_now-e.d);\n\t\t\t\tif(d_next<d[e.v][c_next]){\n\t\t\t\t\td[e.v][c_next]=d_next;\n\t\t\t\t\tpq.push(make_pair(-d_next,make_pair(e.v,c_next)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 7000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[N];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    for (int i = 0; i < N; ++i) adj[i].clear(), adj2[i].clear();\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    set<int> good = {mp[src], mp[dest]};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      if (mp.count(s) == 0) continue;\n      good.insert(mp[s]);\n    }\n\n    vector<int> sources(good.begin(), good.end());\n    for (int source : sources) {\n      good.erase(source);\n      queue<pair<int, int>> q;\n      q.push({source, cap});\n      while (!q.empty()) {\n        int now = q.front().first, now_cap = q.front().second;\n        q.pop();\n        if (good.count(now)) {\n          adj2[source].emplace_back(now, cap - now_cap);\n          adj2[now].emplace_back(source, cap - now_cap);\n          continue;\n        }\n        for (auto& p : adj[now]) {\n          int child = p.first, d = p.second;\n          if (now_cap - d >= 0) q.push({child, now_cap - d});\n        }\n      }\n    }\n\n    int s = mp[src], t = mp[dest];\n    vector<bool> visit(mp.size(), false);\n    vector<int> dist(mp.size(), INT_MAX);\n    dist[s] = 0;\n    MinHeap<pair<int, int>> hp;\n    hp.push({0, s});\n    while (1) {\n      int now = -1;\n      while (!hp.empty() and visit[now = hp.top().second]) hp.pop();\n      if (now == -1 or visit[now]) break;\n      visit[now] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, d = p.second;\n        if (dist[child] > dist[now] + d) {\n          dist[child] = dist[now] + d;\n          hp.push({dist[child], child});\n        }\n      }\n    }\n\n    cout << (dist[t] == INT_MAX ? -1 : dist[t]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n  for(int i=0;i<=cap*10;i++)d[s][i]=0;\n\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n  \t  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]>=INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<edge> g[6666];\nbool sta[6666];\nint cost[6666][2222];\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    scanf(\"%s%s\",s,t);\n    vector<string> node;\n    for( int i = 0; i < 6666; i++ ) {\n      g[i].clear();\n      sta[i] = false;\n      for( int j = 0; j < 2222; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 6010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 1; j < MAX_V; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> st;\n\t\tst.insert(src), st.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) st.insert(c1[i]), st.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : st) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(110);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=6105,INF=1<<30;\nmap<string,int> MA;\nstruct edge{\n    int topos;\n    int cost;\n};\nvector<edge> G[MAX];\nbool ok[MAX];\n\nint dis[MAX][2005];\n\nvoid dijkstra(int spos,int scap,int maxi){\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> PQ;\n    \n    PQ.push(mp(0,mp(spos,scap)));\n    \n    while(!PQ.empty()){\n        auto u=PQ.top();PQ.pop();\n        \n        if(dis[u.se.fi][u.se.se]<u.fi) continue;\n        \n        if(ok[u.se.fi]){\n            if(chmin(dis[u.se.fi][maxi],dis[u.se.fi][u.se.se])){\n                PQ.push(mp(dis[u.se.fi][maxi],mp(u.se.fi,maxi)));\n            }\n        }\n        \n        for(auto to:G[u.se.fi]){\n            int a=to.topos,c=to.cost;\n            if(u.se.se-c>=0&&chmin(dis[a][u.se.se-c],dis[u.se.fi][u.se.se]+c)){\n                PQ.push(mp(dis[a][u.se.se-c],mp(a,u.se.se-c)));\n            }\n        }\n        \n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M,cap;cin>>N>>M>>cap;\n        cap*=10;\n        if(N+M+cap==0) break;\n        \n        string s,g;cin>>s>>g;\n        \n        for(int i=0;i<2*N+100;i++){\n            G[i].clear();\n            ok[i]=0;\n            for(int j=0;j<=cap;j++){\n                dis[i][j]=INF;\n            }\n        }\n        MA.clear();\n        \n        MA[s]=1;\n        MA[g]=1;\n        vector<pair<string,string>> E(N);\n        vector<int> D(N);\n        for(int i=0;i<N;i++){\n            cin>>E[i].fi>>E[i].se;\n            MA[E[i].fi]=1;\n            MA[E[i].se]=1;\n            cin>>D[i];\n        }\n        vector<string> P(M);\n        for(int i=0;i<M;i++){\n            cin>>P[i];\n            MA[P[i]]=1;\n        }\n        int id=0;\n        for(auto a:MA){\n            MA[a.fi]=id;\n            id++;\n        }\n        for(int i=0;i<N;i++){\n            int a=MA[E[i].fi],b=MA[E[i].se],c=D[i];\n            G[a].push_back(edge{b,c});\n            G[b].push_back(edge{a,c});\n        }\n        for(int i=0;i<M;i++){\n            int a=MA[P[i]];\n            ok[a]=1;\n        }\n        dis[MA[s]][cap]=0;\n        dijkstra(MA[s],cap,cap);\n        \n        int ans=INF;\n        for(int j=0;j<=cap;j++) chmin(ans,dis[MA[g]][j]);\n        \n        if(ans==INF) ans=-1;\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst,idx;\nset<int> LPG;\nvector<Edge> G[MAX];\n\nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  vector<vector<int> > dist(idx);\n  cap *= 10;\n \n  for(int i = 0 ; i < idx ; i++){\n    dist[i].resize(cap+1);\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nmap <string,int> MAP;\ntypedef struct Node{\n\tint to,dist;\n}NODE;\nNODE nd;\nvector <Node> v1[6005],v2[305];\nvector <int> gas;\nint dis[6005],in[6005];\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\t\n\tint N,n,M,m,i,j,cap,c,d;\n\twhile(cin >> N >> M >> cap,N){\n\t\tcap *= 10;\n\t\tfor(n=0;n<2*N+2;n++)\n\t\t\tv1[n].clear();\n\t\tfor(m=0;m<305;m++)\n\t\t\tv2[m].clear();\n\t\tMAP.clear();\n\t\tgas.clear();\n\t\tstring head,tail;\n\t\tcin >> head >> tail;\n\t\tc = 0;\n\t\tfor(n=0;n<N;n++){\n\t\t\tstring c1,c2;\n\t\t\tcin >> c1 >> c2 >> d;\n\t\t\tif(MAP.find(c1)==MAP.end())\tMAP[c1] = c++;\n\t\t\tif(MAP.find(c2)==MAP.end())\tMAP[c2] = c++;\n\t\t\tnd.to = MAP[c2];\n\t\t\tnd.dist = d;\n\t\t\tv1[MAP[c1]].push_back(nd);\n\t\t\tnd.to = MAP[c1];\n\t\t\tv1[MAP[c2]].push_back(nd);\n\t\t}\n\t\tfor(m=0;m<M;m++){\n\t\t\tstring c1;\n\t\t\tcin >> c1;\n\t\t\tgas.push_back(MAP[c1]);\n\t\t}\n\t\tif(MAP.find(head)==MAP.end()){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(MAP.find(tail)==MAP.end()){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint pos1=gas.size(),pos2=gas.size()+1;\n\t\tgas.push_back(MAP[head]);\n\t\tgas.push_back(MAP[tail]);\n\t\tfor(i=0;i<gas.size();i++){\n\t\t\tfor(j=0;j<6005;j++)\n\t\t\t\tdis[j] = 1e9;\n\t\t\tdis[gas[i]] = 0;\n\t\t\tmemset(in,0,sizeof(in));\n\t\t\tint st;\n\t\t\tqueue <int> q;\n\t\t\tq.push(gas[i]);\n\t\t\twhile(!q.empty()){\n\t\t\t\tst = q.front();\tq.pop();\n\t\t\t\tin[st] = 0;\n\t\t\t\tfor(j=0;j<v1[st].size();j++){\n\t\t\t\t\tif(dis[st]+v1[st][j].dist < dis[v1[st][j].to]){\n\t\t\t\t\t\tdis[v1[st][j].to] = dis[st]+v1[st][j].dist;\n\t\t\t\t\t\tif(in[v1[st][j].to] == 0){\n\t\t\t\t\t\t\tq.push(v1[st][j].to);\n\t\t\t\t\t\t\tin[v1[st][j].to] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<gas.size();j++){\n\t\t\t\tif(gas[j]==gas[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(dis[gas[j]]<=cap){\n\t\t\t\t\tnd.to = j;\n\t\t\t\t\tnd.dist = dis[gas[j]];\n\t\t\t\t\tv2[i].push_back(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<6005;j++)\n\t\t\tdis[j] = 1e9;\n\t\tmemset(in,0,sizeof(in));\n\t\tint st=pos1,ans=1e9;\n\t\tdis[st] = 0;\n\t\tqueue <int> q;\n\t\tq.push(st);\n\t\twhile(!q.empty()){\n\t\t\tst = q.front();\tq.pop();\n\t\t\tin[st] = 0;\n\t\t\tfor(i=0;i<v2[st].size();i++){\n\t\t\t\tif(dis[st]+v2[st][i].dist < dis[v2[st][i].to]){\n\t\t\t\t\tdis[v2[st][i].to] = dis[st]+v2[st][i].dist;\n\t\t\t\t\tif(in[v2[st][i].to]==0){\n\t\t\t\t\t\tin[v2[st][i].to] = 1;\n\t\t\t\t\t\tq.push(v2[st][i].to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dis[pos2]!=1e9)\n\t\t\tprintf(\"%d\\n\",dis[pos2]);\n\t\telse\n\t\t\tprintf(\"-1\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tint tmp=d[v][cap*10];\n  \tbool fg=false;\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t\tfg=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[v][p.s.s]==INF || (nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost)){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  \t\n  \tif(fg)d[v][p.s.s]=tmp;\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nstring SRC, DEST;\nstring C[3010][2];\nint D[3010];\nstring S[300];\n\nmap<string, int> m;\nmap<int, vector<pair<int, int> > >E;\nbool LPF[6010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tint initn = m[SRC] * 10000 + CAP;\n\tpair<int, ll> q;\n\t//pair<int, int> p;\n\tint n, c, nn, nc, nnn;\n\tll ncost;\n\n\tdist[initn] = 0;\n\tque.push(make_pair(initn, 0));\n\twhile (!que.empty())\n\t{\n\t\tq = que.top(); que.pop();\n\n\t\tn = q.first / 10000;\n\t\tc = q.first % 10000;\n\n\t\tif (n == m[DEST]) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tnn = p.first;\n\t\t\tnc = c - p.second;\n\t\t\tif (LPF[nn]) nc = CAP;\n\t\t\tnnn = nn * 10000 + nc;\n\n\t\t\tncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\t\tcin >> SRC >> DEST;\n\t\trep(i, 0, N) cin >> C[i][0] >> C[i][1] >> D[i];\n\t\trep(i, 0, M) cin >> S[i];\n\n\t\tm.clear();\n\t\tm[SRC] = m[DEST] = 0;\n\t\trep(i, 0, N) m[C[i][0]] = m[C[i][1]] = 0;\n\t\trep(i, 0, M) m[S[i]] = 0;\n\n\t\tint NN = 0;\n\t\tfor (auto p : m) m[p.first] = NN, NN++;\n\n\t\tE.clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a = C[i][0];\n\t\t\tstring b = C[i][1];\n\t\t\tE[m[a]].push_back(make_pair(m[b], D[i]));\n\t\t\tE[m[b]].push_back(make_pair(m[a], D[i]));\n\t\t}\n\n\t\trep(i, 0, 6010) LPF[i] = false;\n\t\trep(i, 0, M) LPF[m[S[i]]] = true;\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 110, MAX_CAP = 210;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 1; j < MAX_V; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> st;\n\t\tst.insert(src), st.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) st.insert(c1[i]), st.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : st) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(110);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d = 0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap < 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  d[v.cap][p.second] = d[u.cap][p.first] + m[p];\n\t  v.str = p.second;\n\t  v.cap = cap;\n\t  v.d = d[cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint size = 0;\n\t\tvector<vs> data(N, vs(3)); \n\t\tmap<string, int> index;\n\t\t{\n\t\t\tset<string> cities;\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, 2) {\n\t\t\t\t\tcin >> data[i][j];\n\t\t\t\t\tcities.insert(data[i][j]);\n\t\t\t\t}\n\t\t\t\tcin >> data[i][2];\n\t\t\t}\n\n\t\t\tset<string>::iterator it = cities.begin();\n\t\t\twhile(it != cities.end()) {\n\t\t\t\tindex[*it] = size;\n\t\t\t\tsize++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<pii>> dist(size);\n\t\tREP(i, N) {\n\t\t\tint c1 = index[data[i][0]];\n\t\t\tint c2 = index[data[i][1]];\n\t\t\tint cost = toInt(data[i][2]);\n\n\t\t\tdist[c1].push_back(make_pair(c2, cost));\n\t\t\tdist[c2].push_back(make_pair(c1, cost));\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvs cost(size, vsh(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, dist[st.p].size()) {\n\t\t\t\tint np = dist[st.p][d].first;\n\t\t\t\tint nc = st.c + dist[st.p][d].second;\n\t\t\t\tint ng = st.g - dist[st.p][d].second;\n\n\t\t\t\tif(ng < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(gas[np]) {\n\t\t\t\t\tng = cap*10;\n\t\t\t\t}\n\n\t\t\t\tif(nc < cost[np][ng]) {\n\t\t\t\t\tcost[np][ng] = nc;\n\t\t\t\t\tQ.push(state(np, nc, ng));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<string, int> dic;\nint n = 0;\n\ninline int s2i(string s){\n    if(dic.find(s) != end(dic)) return dic[s];\n    return (dic[s] = n++);\n}\n\nusing Edge = tuple<int, int>;\nusing State = tuple<int, int, int>;\n\nsigned main(void){\n    for(int m, Q, cap; cin >> m >> Q >> cap, m;){\n        cap *= 10;\n        n = 0;\n        dic = map<string, int>();\n\n        int s, t;\n        {\n            string S, T; cin >> S >> T;\n            s = s2i(S), t = s2i(T);\n        }\n\n        const int N = 6000;\n\n        vector<vector<Edge>> graph(N);\n        rep(loop, m){\n            string A, B; cin >> A >> B;\n            int dist; cin >> dist;\n\n            int a = s2i(A), b = s2i(B);\n            graph[a].push_back(Edge(b, dist));\n            graph[b].push_back(Edge(a, dist));\n        }\n\n        vi hasStation(N);\n        rep(loop, Q){\n            string S; cin >> S;\n            hasStation[s2i(S)] = true;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0, s, cap));\n        vector<vi> min_dist(n, vi(cap + 1, inf));\n\n        int res = inf;\n        while(q.size()){\n            State cur = q.top(); q.pop();\n            int dist, v, rest; tie(dist, v, rest) = cur;\n\n            if(not chmin(min_dist[v][rest], dist)) continue;\n\n            if(v == t){\n                res = dist;\n                break;\n            }\n\n            for(auto & e : graph[v]){\n                int nv, ddist;\n                tie(nv, ddist) = e;\n                \n                int ndist = dist + ddist;\n                int nrest = rest - ddist;\n                if(nrest < 0) continue;\n\n                if(hasStation[nv]) nrest = cap;\n                if(min_dist[nv][nrest] != inf) continue;\n\n                q.push(State(ndist, nv, nrest));\n            }\n        }\n\n        if(res == inf) res = -1;\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <complex>\n#include <ctime>\n#include <utility>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n#define EPS 1e-6\n#define LGE 0.434294481903//log10(e)\n#define lll __int64\n#define ll long long\n#define INF 0x7fffffff\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n\ntypedef pair<int,int> pii;\nconst int N=6002;\nconst int N2=6002;\nint node_num,edge_num,start_node,final_node;\nint gap_num,cap;\nint node_first[N],node_next[N2],node_begin[N2],node_end[N2],node_value[N2];\nint distance_[N],gap[N];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\nstruct jcc\n{\n    char cc[20];\n    bool operator < (const jcc& a) const\n    {\n        return strcmp(cc,a.cc)==1;//莉主、ァ蛻ー蟆?    }\n}ctm;\n\nmap<jcc,int> ma;\nmap<jcc,int>::iterator it;\nbool ggap[N];\n\nvoid dijkstra();\n\nint main()\n{\n    //freopen(\"D:\\\\input.in\",\"r\",stdin);\n    //freopen(\"D:\\\\output.out\",\"w\",stdout);\n    while(scanf(\"%d%d%d\",&edge_num,&gap_num,&cap)&&(edge_num||gap_num||cap)){\n        ma.clear();\n    start_node=1;\n    final_node=2;\n\n    int tj0=1;\n    scanf(\"%s\",ctm.cc);\n    ma.insert(pair<jcc,int>(ctm,tj0++));\n    scanf(\"%s\",ctm.cc);\n    ma.insert(pair<jcc,int>(ctm,tj0++));\n    node_num=edge_num*2;\n    rep(i,1,node_num)\n    {\n\n        node_first[i]=-1;\n    }\n    int t1,t2,t3;\n    rep(i,1,edge_num)\n    {\n        scanf(\"%s\",ctm.cc);\n        it=ma.find(ctm);\n        if(it!=ma.end())\n        {\n            t1=(*it).second;\n        }\n        else\n        {\n            t1=tj0;\n            ma.insert(pair<jcc,int>(ctm,tj0++));\n        }\n        scanf(\"%s\",ctm.cc);\n        it=ma.find(ctm);\n        if(it!=ma.end())\n        {\n            t2=(*it).second;\n        }\n        else\n        {\n            t2=tj0;\n            ma.insert(pair<jcc,int>(ctm,tj0++));\n        }\n        scanf(\"%d\",&t3);\n        node_begin[i]=t1;\n        node_end[i]=t2;\n        node_value[i]=t3;\n        node_next[i]=node_first[node_begin[i]];\n        node_first[node_begin[i]]=i;\n        node_begin[i+edge_num]=node_end[i];\n        node_end[i+edge_num]=node_begin[i];\n        node_value[i+edge_num]=node_value[i];\n        node_next[i+edge_num]=node_first[node_begin[i+edge_num]];\n        node_first[node_begin[i+edge_num]]=i+edge_num;\n    }\n    node_num=tj0-1;\n    rep(i,1,node_num)\n        ggap[i]=0;\n    rep(i,1,gap_num)\n    {\n        scanf(\"%s\",ctm.cc);\n        it=ma.find(ctm);\n        ggap[(*it).second]=1;\n    }\n    dijkstra();\n    if(distance_[final_node]==INF)  puts(\"-1\");\n    else\n    printf(\"%d\\n\",distance_[final_node]);\n    }\n    return 0;\n}\nvoid dijkstra()\n{\n    rep(i,1,node_num)   distance_[i]=INF;\n    distance_[start_node]=0;\n    rep(i,1,node_num)\n        gap[i]=0;\n    gap[start_node]=cap;\n    pq.push(make_pair(distance_[start_node],start_node));\n    while(!pq.empty())\n    {\n        pii pi=pq.top();\n        int x=pi.second;\n        pq.pop();\n        if(pi.first!=distance_[x]) continue;\n        for(int i=node_first[x];i!=-1;i=node_next[i])\n        {\n            if(gap[x]*10>=node_value[i]&&distance_[node_end[i]]>distance_[x]+node_value[i])\n            {\n                distance_[node_end[i]]=distance_[x]+node_value[i];\n                pq.push(make_pair(distance_[node_end[i]],node_end[i]));\n                if(ggap[node_end[i]]==0) gap[node_end[i]]=max(gap[node_end[i]],gap[x]*10-node_value[i])/10;\n                else    gap[node_end[i]]=cap;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[7001];\nvector<edge> GG[7001];\nmap<string,int> city;\nint dp[7000];\nbool flag[7000];\n\nvoid make_path(int v){\n\tfill(dp,dp+city.size(),cap+1);\n\tpriority_queue<data,vector<data>,greater<data> > que;\n\tque.push(data(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data,vector<data>,greater<data> > que;\n\tque.push(data(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<=city.size();i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<=city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<stack>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<set>\nusing namespace std;\nmap<string, int> ind;\nmap<string, bool> exi;\nbool gas[333333];\nbool can;\nint no=0;\nvector<int> route[333333];\nvector<int> roulen[333333];\nbool v[333333];\nint n,m,cap,lo;\nint ncap;\nstring start,dest,t1,t2;\nint destid;\nint ans=INT_MAX;\nvoid dfs(int now,int gass,int ta){\n\tif(gass<0||v[now])return;\n\tif(gas[now])gass=cap;\n\t//cout<<now<<\" \"<<gass<<\" \"<<ta<<\"\\n\";\n\tif(now==destid){\n\t\tans=min(ans,ta);\n\t\treturn;\n\t}\n\tv[now]=true;\n\tfor(int i=0;i<route[now].size();i++){\n\t\tdfs(route[now][i],gass-roulen[now][i],ta+roulen[now][i]);\n\t}\n}\nvoid solve(){\n\tcap*=10;\n\tncap=cap;\n\tind.clear();\n\tans=INT_MAX;\n\tfor(int i=0;i>333333;i++){\n\t\troute[i].clear();\n\t\troulen[i].clear();\n\t}\n\tmemset(v,0,sizeof(v));\n\tdfs(0,ncap,0);\n\tif(ans!=INT_MAX)cout<<ans<<\"\\n\";\n\telse cout<<\"-1\\n\";\n}\nint main(){\n\tios::sync_with_stdio(0);\n\twhile(cin>>n>>m>>cap&&n+m+cap>0){\n\t\tmemset(gas,0,sizeof(gas));\n\t\tcin>>start>>dest;\n\t\tif(!exi[start]){\n\t\t\tind[start]=no++;\n\t\t\texi[start]=true;\n\t\t}\n\t\tif(!exi[dest]){\n\t\t\tind[dest]=no++;\n\t\t\texi[dest]=true;\n\t\t}\n\t\tdestid=no-1;\n\t\twhile(n--){\n\t\t\tcin>>t1>>t2>>lo;\n\t\t\tif(!exi[t1]){\n\t\t\t\tind[t1]=no++;\n\t\t\t\texi[t1]=true;\n\t\t\t}\n\t\t\tif(!exi[t2]){\n\t\t\t\tind[t2]=no++;\n\t\t\t\texi[t2]=true;\n\t\t\t}\n\t\t\troute[ind[t1]].push_back(ind[t2]);\n\t\t\troulen[ind[t1]].push_back(lo);\n\t\t\troute[ind[t2]].push_back(ind[t1]);\n\t\t\troulen[ind[t2]].push_back(lo);\n\t\t}\n\t\twhile(m--){\n\t\t\tcin>>t1;\n\t\t\tgas[ind[t1]]=true;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto& tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\t\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[2501][2501];\nint gas[3005];\nint head[3005];\nbool visit[2001][2501];\nint dp[2001][2501];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[6005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num+2;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return dp[gasnum][u]=0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(visit[gasnum][v]&&val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            visit[gasnum][u]=false;;\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n            visit[gasnum][u]=true;\n        }\n    }\n    dp[gasnum][u]=ret;\n    return ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        memset(visit,true,sizeof visit);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n            u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        visit[cap*10][1]=false;\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n        printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n// -- loop macros -- //\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (int)(s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define FOREACH(i,container) for (auto &&i : container)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n\n// -- functors -- //\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV1(a,exp) [&](const auto & a) -> auto { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\n// -- typedefs -- //\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n\n// -- I/O Helper -- //\nstruct _Reader { _Reader(istream &cin) :cin(cin) {} istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { _Writer(ostream &cout) :cout(cout) {} ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\n// -- vevector -- //\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(size_t n = 0, size_t m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(size_t n = 0, size_t m = 0, size_t l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(size_t n = 0, size_t m = 0, size_t l = 0, size_t k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, iter_pair_t<T> v) { if (v.beg != v.end) { out << *v.beg++; while (v.beg != v.end) { out << \" \" << *v.beg++; } } return out; }\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\n\n// -- etc -- //\ntemplate <class T> T infinity_value();\n#define DEFINE_INFINITY_VALUE(T, val) template <> constexpr T infinity_value<T>() { return (val); }\nDEFINE_INFINITY_VALUE(int, 1 << 28);\nDEFINE_INFINITY_VALUE(uint, 1u << 28);\nDEFINE_INFINITY_VALUE(llong, 1ll << 60);\nDEFINE_INFINITY_VALUE(ullong, 1ull << 60);\nDEFINE_INFINITY_VALUE(double, HUGE_VAL);\nDEFINE_INFINITY_VALUE(float, HUGE_VAL);\n#define INF(T) infinity_value<T>()\n\ninline int sign_of(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ntemplate <class TInt> bool in_range(TInt val, TInt min, TInt max) { return val >= min && val < max; }\ntemplate <> bool in_range<double>(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ntemplate <> bool in_range<float>(float val, float min, float max) { return val - min > -EPS && val - max < EPS; }\ntemplate <class TInt> bool in_range2d(TInt x, TInt y, TInt w, TInt h) { return x >= 0 && x < w && y >= 0 && y < h; }\nvector<int> iotavn(int start, int count) { vector<int> r(count); iota(allof(r), start);\treturn r; }\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t//// for local debugging\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto classic_table = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> ctable(classic_table, classic_table + ctype<char>::table_size);\n\t//ctable[':'] |= ctype_base::space; // as delimitor\n\t//ctable['/'] |= ctype_base::space; // as delimitor\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(ctable.data())));\n\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n// idconv //\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N, M, cap);\n\t\tif (!N) { break; }\n\t\tidconv<string> idc;\n\t\tint start, goal;\n\t\t{\n\t\t\tREAD(string, a, b);\n\t\t\tstart = idc.get(a);\n\t\t\tgoal = idc.get(b);\n\t\t}\n\n\t\tstruct St\n\t\t{\n\t\t\tint pos, cost, fuel;\n\t\t\tbool operator >  (const St &_) const { return cost != _.cost ? cost > _.cost : fuel < _.fuel; }\n\t\t};\n\n\t\tvevector<St> roads(1000);\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(string, c1, c2); READ(int, cost);\n\t\t\troads[idc.get(c1)].push_back({ idc.get(c2), cost });\n\t\t\troads[idc.get(c2)].push_back({ idc.get(c1), cost });\n\t\t}\n\n\t\tvector<bool> gassta(1000);\n\t\tREP(i, M)\n\t\t{\n\t\t\tREAD(string, c);\n\t\t\tgassta[idc.get(c)] = true;\n\t\t}\n\n\t\tpriority_queue<St, vector<St>, greater<St>> q;\n\t\tvector<int> gas(1000);\n\t\tvector<int> cost(1000, INF(int));\n\n\t\tq.push({ start, 0, cap * 10 });\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tSt p = q.top(); q.pop();\n\t\t\tif (p.fuel < gas[p.pos]) { continue; }\n\t\t\tif (gassta[p.pos]) { p.fuel = cap * 10; }\n\t\t\t//DEBUG(idc.v[p.pos], \"cost\", p.cost, \"gas\", p.fuel);\n\n\t\t\tgas[p.pos] = p.fuel;\n\t\t\tcost[p.pos] = p.cost;\n\t\t\tif (p.pos == goal) { break; }\n\t\t\tFOREACH(r, roads[p.pos])\n\t\t\t{\n\t\t\t\tint to = r.pos;\n\t\t\t\tif (r.cost <= p.fuel)\n\t\t\t\t{\n\t\t\t\t\tif (gas[to] < p.fuel - r.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push({ r.pos, p.cost + r.cost, p.fuel - r.cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tWRITE(cost[goal] < INF(int) ? cost[goal] : -1);\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 2010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10; // 1L??§10km ????????§ 10???\n\n\t// ??????????????°????????????\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost; \n\t\t\t\t\tque.push(make_tuple(ncost, v, cap)); // ??¬????????????????????????\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 0; j <= cap; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\t\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> city;\n\t\tcity.insert(src), city.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) city.insert(c1[i]), city.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num; // ????????????????????????????????????\n\t\tfor(const auto& t : city) city2num[t] = cnt++;\n\n\t\tset<int> lpg; // lpg??????????????§??????????????????\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\n\t\t// ??°???????????????\n\t\tvector<vector<pair<int, int>> >  G(6010);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nvector<pair<int, int> > E[6010];\nbool gas[6010];\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1) return q.second;\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas[nn]) nc = CAP;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nn * 10000 + nc) == dist.end()) dist[nn * 10000 + nc] = INF;\n\t\t\tif (ncost < dist[nn * 10000 + nc])\n\t\t\t{\n\t\t\t\tdist[nn * 10000 + nc] = ncost;\n\t\t\t\tque.push(make_pair(nn * 10000 + nc, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tint idx = 0;\n\t\tmap<string, int> m;\n\n\t\tstring src, dest; cin >> src >> dest;\n\t\tm[src] = 0; m[dest] = 1;\n\t\tidx = 2;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\t\tint d; cin >> d;\n\t\t\tE[m[a]].push_back(make_pair(m[b], d));\n\t\t\tE[m[b]].push_back(make_pair(m[a], d));\n\t\t}\n\n\t\trep(i, 0, 6010) gas[i] = false;\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\t\tgas[m[s]] = true;\n\t\t}\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, cap;\nstring src, dest;\nint st, en;\nmap<string,int> ma;\nstring c[2][3000];\nint d[3000];\nint counter;\nvector<P> e[3000];\nvector<P> edge[3000];\nset<int> sta;\n\nvoid make_edge(){\n\trep(i,n){\n\t\tcin >> c[0][i] >> c[1][i] >> d[i];\n\t\tif(ma.count(c[0][i]) == 0){\n\t\t\tma[c[0][i]] = counter;\n\t\t\tcounter++;\n\t\t}\n\t\tif(ma.count(c[1][i]) == 0){\n\t\t\tma[c[1][i]] = counter;\n\t\t\tcounter++;\n\t\t}\n\t}\n\tst = ma[src]; en = ma[dest];\n\trep(i,n){\n\t\tint a = ma[c[0][i]], b = ma[c[1][i]];\n\t\te[a].push_back(P(b,d[i]));\n\t\te[b].push_back(P(a,d[i]));\n\t}\n}\n\nvoid dijkstra(int start){\n\tint dist[3000];\n\tPQ que;\n\trep(i,3000) dist[i] = INF;\n\tdist[start] = 0;\n\tque.push(P(0,start));\n\twhile(!que.empty()){\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dist[q.second]) continue;\n\t\trep(i,e[q.second].size()){\n\t\t\tP p = e[q.second][i];\n\t\t\tif(dist[p.first] > q.first+p.second && q.first+p.second <= cap*10){\n\t\t\t\tdist[p.first] = q.first+p.second;\n\t\t\t\tque.push(P(dist[p.first],p.first));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,counter){\n\t\tif(i == start) continue;\n\t\tif(sta.count(i) == 0) continue;\n\t\tif(dist[i] == INF) continue;\n\t\tedge[start].push_back(P(i,dist[i]));\n\t}\n}\n\nvoid dijkstra(){\n\tint dist[3000];\n\tPQ que;\n\trep(i,3000) dist[i] = INF;\n\tdist[st] = 0;\n\tque.push(P(0,st));\n\twhile(!que.empty()){\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dist[q.second]) continue;\n\t\trep(i,edge[q.second].size()){\n\t\t\tP p = edge[q.second][i];\n\t\t\tif(dist[p.first] > q.first+p.second){\n\t\t\t\tdist[p.first] = q.first+p.second;\n\t\t\t\tque.push(P(dist[p.first],p.first));\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[en] == INF) dist[en] = -1;\n\tcout << dist[en] << endl;\n}\n\nvoid solve(){\n\tma.clear();\n\tcounter = 0;\n\trep(i,3000) e[i].clear();\n\trep(i,3000) edge[i].clear();\n\tsta.clear();\n\tcounter = 0;\n\tcin >> src >> dest;\n\tmake_edge();\n\trep(i,m){\n\t\tstring tmp; cin >> tmp;\n\t\tsta.insert(ma[tmp]);\n\t}\n\tsta.insert(st); sta.insert(en);\n\trep(i,counter){\n\t\tif(sta.count(i) == 0) continue;\n\t\tdijkstra(i);\n\t}\n\tdijkstra();\n}\n\nint main(){\n\twhile(cin >> n >> m >> cap){\n\t\tif(n == 0 && m == 0 && cap == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost): to(to), cost(cost){}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool operator < (const Edge &e, const Edge &f){\n    return e.cost > f.cost;\n}\n\nvector<int> dijkstra(const Graph &g, int s){\n    vector<int> d(g.size(),INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,s)); // P(dis, pos)\n    while(!que.empty()){\n        int dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<dist) continue;\n        for(const auto &e: g[v]){\n            if(d[e.to]<=d[v]+e.cost) continue;\n            d[e.to] = d[v] + e.cost;\n            que.push(P(d[e.to], e.to));\n        }\n    }\n    return d;\n}\n\nstruct Road{\n    string from, to;\n    int d;\n    Road(string from, string to,int d): from(from), to(to), d(d) {}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m,cap;\n    while(cin>>n>>m>>cap, n){\n        string src,dest;cin>>src>>dest;\n        cap *= 10;\n        map<string,int> mp;\n        mp[src]=1;mp[dest]=2;\n        vector<vector<Edge>> g(6666);\n        vector<Road> roads;\n        for(int i=0;i<n;i++){\n            string st,gt;cin>>st>>gt;\n            int d;cin>>d;\n            roads.push_back(Road(st,gt,d));\n        }\n        vector<int> v;\n        v.push_back(1);v.push_back(2);\n        int idx=3;\n        for(int i=0;i<m;i++){\n            string s;cin>>s;\n            if(mp[s]!=0) continue;\n            mp[s] = idx;\n            v.push_back(idx);\n            idx++;\n        }\n        for(int i=0;i<n;i++){\n            string st=roads[i].from,gt=roads[i].to;\n            int d=roads[i].d;\n            if(mp[st]==0){\n                mp[st]=idx;\n                idx++;\n            }\n            if(mp[gt]==0){\n                mp[gt]=idx;\n                idx++;\n            }\n            g[mp[st]].push_back(Edge(mp[gt],d));\n            g[mp[gt]].push_back(Edge(mp[st],d));\n        }\n        int sz=v.size();\n        vector<vector<int>> dis(sz+1,vector<int>(sz+1,INF));\n        for(int i=1;i<=sz;i++) dis[i][i]=0;\n        for(int i=1;i<=sz;i++){\n            vector<int> tmp=dijkstra(g, i);\n            for(int j=i+1;j<=sz;j++){\n                if(tmp[j]>cap) continue;\n                dis[i][j]=dis[j][i]=tmp[j];\n            }\n        }\n        \n        for(int k=1;k<=sz;k++){\n            for(int i=1;i<=sz;i++){\n                for(int j=1;j<=sz;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        if(dis[1][2]>=INF) cout<<-1<<endl;\n        else cout<<dis[1][2]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<short, short> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      short nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    continue;\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      if (mp[dest] == pos) break;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n, m, k, p, dist[6007][2017], c[3000]; bool u[3000]; vector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<int, short, short>, vector<tuple<int, short, short>>, greater<tuple<int, short, short>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n//\t\tfor(i = 0; i < MAX_V; i++)\n//\t\tif(!G[i].empty())\n//\t\t\tG[i].clear();\n//\t\tfor(i = 0; i < MAX_V; i++)\n//\t\tif(!GG[i].empty())\n//\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n  \tvis[v][p.s.s]=true;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(p.s.s-e.cost>=0){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 3010\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nstatic int mincost[MAX][2010];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVVP G;\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++,G.push_back(VP());\n  if(index.find(t) == index.end())index[t] = idx++,G.push_back(VP());\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      G.clear();\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++,G.push_back(VP());\n      index[sdest] = idx++,G.push_back(VP());\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx < MAX);\n      rep(i,idx)\n\t{\n\t  LPG[i] = false;\n\t  rep(j,2010)mincost[i][j] = (1<<29);\n\t}\n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n    \n\n      int ans = (1<<29);\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  Pox pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      continue;\n\t    }\n\n\t  for(int i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      P p = G[pox.cur][i];\n\t      int fuelConsumption = pox.tank - p.d; \n\t      int next = p.to;\n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[next])continue;\n\n\t      if(mincost[next][fuelConsumption] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[next][fuelConsumption] = pox.cost + p.d;\n\t\t  if(LPG[next])\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],cap*10));\n\t\t  else\n\t\t    que.push(Pox(next,mincost[next][fuelConsumption],fuelConsumption));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(int tt = 0;;tt++){\n    int n, m, cap;\n    cin >> n >> m >> cap;\n    if(n == 0) break;\n    cap *= 10;\n    map<string,int> map;\n    string currN, destN;\n    cin >> currN >> destN;\n    auto mapping = [&map](const string &city) {\n      if(map.find(city) == map.end()) map.insert(make_pair(city, map.size()));\n      return map[city];\n    };\n    int curr = mapping(currN);\n    int dest = mapping(destN);\n    vector<vector<pair<int,int>>> es(6002,vector<pair<int,int>>());\n    for(int i = 0; i < n; i++) {\n      string src, tgt;\n      int d;\n      cin >> src >> tgt >> d;\n      int s = mapping(src);\n      int t = mapping(tgt);\n      es[s].push_back(make_pair(t, d));\n      es[t].push_back(make_pair(s, d));\n    }\n    vector<bool> gs(6002, false);\n    for(int i = 0; i < m; i++) {\n      string city;\n      cin >> city;\n      gs[mapping(city)] = true;\n    }\n    const int BIG = 6002*2000*2*2;\n    const int nn = map.size();\n\n    vector<vector<int>> ds(nn, vector<int>(cap+1, BIG));\n    vector<vector<bool>> fixed(nn, vector<bool>(cap+1, false));\n    priority_queue<pair<int, pair<int, int>>> que;\n    // Dijkstra\n    que.push(make_pair(-0, make_pair(curr, cap)));\n    while(que.size() > 0) {\n      auto dvc = que.top();\n      que.pop();\n      const int d = -dvc.first;\n      const int v = dvc.second.first;\n      const int c = dvc.second.second;\n      if(fixed[v][c]) continue;\n      fixed[v][c] = true;\n      ds[v][c] = d;\n      for(auto it = es[v].begin(); it != es[v].end(); it++) {\n        int cc = c - it->second;\n        if(cc >= 0) {\n          int i = it->first;\n          int dd = d + it->second;\n          if(gs[i]) cc = cap; // gas station\n          if(ds[i][cc] > dd){\n            ds[i][cc] = dd;\n            que.push(make_pair(-dd, make_pair(i, cc)));\n          }\n        }\n      }\n    }\n    int min = BIG;\n    for(int i = 0; i <= cap; i++) {\n      if(min > ds[dest][i]) {\n        min = ds[dest][i];\n      }\n    }\n    cout << (min == BIG ? -1 : min) << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct node{\n  int index,gas,cost;\n  node(int index,int gas,int cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\nint main(){\n  int n,m,cap;\n  while(cin>>n>>m>>cap,n|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start=0;\n    int goal=n-1;\n    vvi dist(n,vi(n,NONE));\n    vs cities;\n    REP(i,n){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai][bi]=d;\n      dist[bi][ai]=d;\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvi cost(n,vi(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(i,n){\n        if(i!=cnode.index&&dist[cnode.index][i]!=NONE){\n          int newcost=cnode.cost+dist[cnode.index][i];\n          int newgas=cnode.gas-dist[cnode.index][i];\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    int ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 1000000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end() || v==s)p.s.s=cap*10;\n     \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n   \t\t d[e.to] = d[v]+e.cost;\n   \t\t que.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n&m&cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n \n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n    map<string,int>vnum;\n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    vector<Edge> edges(total_roads);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges[road_idx] = Edge(from_num,to_num,dist);\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d<p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\nmap<string,int>id;\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tvector<pair<int, int> > E[6010];\n\tset<int> gas;\n\tmap<int, ll> dist;\n\tset<int> done;\n\n\tint idx = 0;\n\tmap<string, int> m;\n\n\tstring src, dest;\n\tcin >> src >> dest;\n\tm[src] = 0; m[dest] = 1;\n\tidx = 2;\n\n\trep(i, 0, N)\n\t{\n\t\tstring a, b; cin >> a >> b;\n\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\tint dd; cin >> dd;\n\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t}\n\n\trep(i, 0, M)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\tgas.insert(m[s]);\n\t}\n\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tcout << \"fuck\" << endl;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!G[i].empty())\n\t\t\tG[i].clear();\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\tif(!GG[i].empty())\n\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <string>\n#include <time.h>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pi acos(-1.0)\ntypedef long long ll;\nint n,m,cap;\nstring ssrc,sdest;\nint src,dest;\nset<string>s;\nstring ss;\nmap<string,int> mp;\nint des[3005];\nstring a[3000];\nstring b[3000];\n\nstruct node{\n\tint dis;\n\tint to;\n\tnode(int dis,int to):dis(dis),to(to){\n\t}\n};\nset<string>::iterator it;\n\nstruct node1{\n\tint go;\n\tint node;\n};\nqueue<node1>q;\n\n\nbool flag[3333];\nint dist[3333][2000];\nvector<node>p[3333];\nbool inq[3333][2000];\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(flag,0,sizeof(flag));\n\t\tmemset(inq,0,sizeof(inq));\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\ts.clear();\n\t\tmp.clear();\n\t\tcap*=10;\n\t\tcin>>ssrc>>sdest;\n\t\ts.insert(ssrc);\n\t\ts.insert(sdest);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i]>>b[i]>>des[i];\n\t\t\ts.insert(a[i]);\n\t\t\ts.insert(b[i]);\n\t\t}\n\t\tint num=0;\n\t\tfor(it=s.begin();it!=s.end();it++)\n\t\t{\n\t\t\tp[num].clear();\n\t\t\tmp[*it]=num;\n\t\t\tnum++;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tp[mp[a[i]]].push_back(node(des[i],mp[b[i]]));\n\t\t\tp[mp[b[i]]].push_back(node(des[i],mp[a[i]]));\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tcin>>ss;\n\t\t\tflag[mp[ss]]=1;\n\t\t}\n\t\t\n     \tsrc=mp[ssrc];\n    \tdest=mp[sdest];\n    \t\n    \tfor(int i=0;i<num;i++)\n    \t{\n    \t\tfor(int j=0;j<=cap;j++)\n    \t\tdist[i][j]=inf;\n    \t}\n    \tdist[src][cap]=0;\n    \tnode1 now,then;\n    \tnow.go=cap;\n    \tnow.node=src;\n    \tq.push(now);\n    \t\n    \twhile(!q.empty())\n    \t{\n    \t\tnow=q.front();\n    \t\tq.pop();\n    \t\tinq[now.node][now.go]=0;\n    \t\tthen.go=now.go;\n    \t\tif(flag[now.node]==1)\n    \t\t{\n    \t\t\tthen.go=cap;\n    \t\t}\n    \t\tif(then.go==0)continue;\n    \t\tfor(int i=0;i<p[now.node].size();i++)\n    \t\t{\n    \t\t\tint d=p[now.node][i].dis;\n    \t\t\tint t=p[now.node][i].to;\n    \t\t\tif(then.go>=d&&dist[t][then.go-d]>dist[now.node][now.go]+d)\n    \t\t\t{\n    \t\t\t\tdist[t][then.go-d]=dist[now.node][now.go]+d;\n    \t\t\t\tthen.go-=d;\n    \t\t\t\tthen.node=t;\n    \t\t\t\tif(!inq[then.node][then.go])q.push(then);\n    \t\t\t\tthen.go+=d;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint ans=inf;\n    \tfor(int i=0;i<=cap;i++)ans=min(dist[dest][i],ans);\n    \tif(ans!=inf)printf(\"%d\\n\",ans);else printf(\"-1\\n\");\n    \t\n    \n    \t\n    \t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\n\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(-1),dist(-1){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2005]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    vector<vector<Node> >  nodes(6001);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tif(to==-1) continue;\n\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvector<int> dijkstra(int n, int s, vector<vector<int>>& g){\n\tvector<int> dis(n,1e8);\n\tpriority_queue<int, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tint cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis;\n}\n\nconst int INF = 1e8;\n\nstring src, dist;\npair<int,int> e[3000];\nint d[3000];\nint t[302];\n\nint input(int n, int m){\n\tmap<string,int> id;\n\tcin >> src >> dist;\n\tid[src] = id.size();\n\tid[dist] = id.size();\n\trep(i,n){\n\t\tstring c1, c2;\n\t\tcin >> c1 >> c2 >> d[i];\n\t\tif(not id.count(c1)) id[c1] = id.size();\n\t\tif(not id.count(c2)) id[c2] = id.size();\n\t\te[i] = make_pair(id[c1], id[c2]);\n\t}\n\trep(i,m){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(not id.count(s)) id[s] = id.size();\n\t\tt[i] = id[s];\n\t}\n\tt[m] = id[src];\n\tt[m + 1] = id[dist];\n\treturn id.size();\n}\n\nint main(){\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n||m||cap){\n\t\tcap *= 10;\n\n\t\tint v = input(n, m);\n\n\t\tvector<vector<int>> g(v, vector<int>(v, INF)), ng(v, vector<int>(v, INF));\n\t\trep(i,n){\n\t\t\tint x = e[i].first, y = e[i].second;\n\t\t\tg[x][y] = g[y][x] = d[i];\n\t\t}\n\n\t\trep(i,m + 2){\n\t\t\tint x = t[i];\n\t\t\tvector<int> dis = dijkstra(v, x, g);\n\t\t\trep(j,m + 2){\n\t\t\t\tint y = t[j];\n\t\t\t\tif(dis[y] > cap) continue;\n\t\t\t\tng[x][y] = min(ng[x][y], dis[y]);\n\t\t\t\tng[y][x] = min(ng[y][x], dis[y]);\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,v){\n\t\t//\trep(j,v){\n\t\t//\t\tif(ng[i][j] == 1e8) cout << \"_ \";\n\t\t//\t\telse cout << ng[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint ans = dijkstra(v, t[m], ng).at(t[m + 1]);\n\t\tcout << (ans == 1e8 ? -1 : ans) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nint N, M, C, SZ;\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int cap){\n  return cap*SZ+u;\n}\n\nconst LL B1 = 1009, B2 = 1007, M1 = 1000000007, M2 = 1000000009;\npair<LL,LL> RollingHash(string& str){\n  int N = str.size();\n  pair<LL,LL> res = MP(0,0);\n  for(int i=0;i<N;++i){\n\tres.first = (res.first + str[i]) * B1 % M1;\n\tres.second = (res.second + str[i]) * B2 % M2;\n  }\n  return res;\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<pair<LL,LL>,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[RollingHash(src)] = SZ++;\n\tcor[RollingHash(dest)] = SZ++;\n\tC *= 10;\n\tvector<tuple<int,int,int>> mem;\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  pair<LL,LL> p1 = RollingHash(s1);\n\t  pair<LL,LL> p2 = RollingHash(s2);\n\t  if(!cor.count(p1)) cor[p1] = SZ++;\n\t  if(!cor.count(p2)) cor[p2] = SZ++;\n\t  mem.PB(make_tuple(cor[p1],cor[p2],d));\n\t}\n\n\tGraph G(SZ*2100);\n\tfor(auto& tp: mem){\n\t  int u, v, d;\n\t  tie(u,v,d) = tp;\n\t  for(int j=d;j<=C;++j){\n\t\tG[idx(u,j)].PB(Edge(idx(v,j-d),d));\n\t\tG[idx(v,j)].PB(Edge(idx(u,j-d),d));\n\t  }\n\t}\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  pair<LL,LL> p = RollingHash(s);\n\t  if(!cor.count(p)) continue;\n\t  for(int j=0;j<=C;++j)\n\t\tG[idx(cor[p],j)].PB(Edge(idx(cor[p],C),0));\t  \n\t}\n\n\tVI dist(SZ*2100);\n\tDijkstra(G,dist,idx(0,C));\n\tint ans = INF;\n\tfor(int j=0;j<=C;++j)\n\t  ans = min(ans, dist[idx(1,j)]);\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n      for(int j=0;j<=now.c-c;j++)\n        mincost[next][j]=min(mincost[next][j],mincost[now.id][now.c]);\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[MAX_V];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nmap <string, int> ma;\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tcin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tif(!G[i].empty())\n\t\t\t\tG[i].clear();\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tif(!GG[i].empty())\n\t\t\t\tGG[i].clear();\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tif(!ma.empty())\n\t\t\tma.clear();\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tif(!m.empty())\n\t\t\tm.clear();\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tif(ma.find(a) != ma.end())\n\t\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tVV = m.size();\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[3010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\t\tstring c1[6010], c2[6010];\n\t\tint d[6010];\n\t\tstring s[6010];\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tdijkstra(city2num[src], cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[city2num[dest]][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<stack>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<set>\nusing namespace std;\nmap<string, int> ind;\nmap<string, bool> exi;\nbool gas[3333];\nbool can;\nint no=0;\nvector<int> route[3333];\nvector<int> roulen[3333];\nint n,m,cap,lo;\nint ncap;\nstring start,dest,t1,t2;\nint destid;\nint ans=INT_MAX;\nvoid cp(bool *a,bool *b){\n\tfor(int i=0;i<3333;i++)\n\t\tb[i]=a[i];\n}\nvoid dfs(int now,int gass,int ta,bool *v){\n\tif(gass<0||v[now])return;\n\tif(gas[now])gass=cap;\n\t//cout<<now<<\" \"<<gass<<\" \"<<ta<<\"\\n\";\n\tif(now==destid){\n\t\tans=min(ans,ta);\n\t\treturn;\n\t}\n\tv[now]=true;\n\tbool t[3333];\n\tfor(int i=0;i<route[now].size();i++){\n\t\tcp(v,t);\n\t\tdfs(route[now][i],gass-roulen[now][i],ta+roulen[now][i],t);\n\t}\n}\nvoid solve(){\n\tcap*=10;\n\tncap=cap;\n\tind.clear();\n\tans=INT_MAX;\n\tfor(int i=0;i>3333;i++){\n\t\troute[i].clear();\n\t\troulen[i].clear();\n\t}\n\tbool v[3333];\n\tmemset(v,0,sizeof(v));\n\tdfs(0,ncap,0,v);\n\tif(ans!=INT_MAX)cout<<ans<<\"\\n\";\n\telse cout<<\"-1\\n\";\n}\nint main(){\n\twhile(cin>>n>>m>>cap&&n+m+cap>0){\n\t\tmemset(gas,0,sizeof(gas));\n\t\tcin>>start>>dest;\n\t\tif(!exi[start]){\n\t\t\tind[start]=no++;\n\t\t\texi[start]=true;\n\t\t}\n\t\tif(!exi[dest]){\n\t\t\tind[dest]=no++;\n\t\t\texi[dest]=true;\n\t\t}\n\t\tdestid=no-1;\n\t\twhile(n--){\n\t\t\tcin>>t1>>t2>>lo;\n\t\t\tif(!exi[t1]){\n\t\t\t\tind[t1]=no++;\n\t\t\t\texi[t1]=true;\n\t\t\t}\n\t\t\tif(!exi[t2]){\n\t\t\t\tind[t2]=no++;\n\t\t\t\texi[t2]=true;\n\t\t\t}\n\t\t\troute[ind[t1]].push_back(ind[t2]);\n\t\t\troulen[ind[t1]].push_back(lo);\n\t\t\troute[ind[t2]].push_back(ind[t1]);\n\t\t\troulen[ind[t2]].push_back(lo);\n\t\t}\n\t\twhile(m--){\n\t\t\tcin>>t1;\n\t\t\tgas[ind[t1]]=true;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 8000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return p.d<d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <string>\n#include <vector>\n#include <queue>\n#define inf 999999999\nusing namespace std;\nstruct xxx\n{\n    int y,c;\n};\nint n,m,cap,tot;\nint dis[7001];\nbool vi[7001],f[7001];\nstring st,en;\nmap <string,int> mp;\nvector <xxx> edge[7001],edge2[7001];\nqueue <int> q;\nvoid spfa(int p)\n{\n    while (!q.empty()) q.pop();\n    for (int i=1;i<=tot;i++)\n    {\n        dis[i]=inf;\n        vi[i]=0;\n    }\n    dis[p]=0;\n    vi[p]=1;\n    q.push(p);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        for (int i=0;i<edge[now].size();i++)\n        {\n            int y=edge[now][i].y;\n            if (dis[y]>dis[now]+edge[now][i].c)\n            {\n                dis[y]=dis[now]+edge[now][i].c;\n                if (!vi[y])\n                {\n                    vi[y]=1;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    for (int i=1;i<=tot;i++)\n    {\n        if (i==p) continue;\n        if (dis[i]<=cap*10&&f[i])\n        {\n            xxx news;\n            news.y=i;\n            news.c=dis[i];\n            edge2[p].push_back(news);\n            //printf(\"%d->%d\\n\",p,i);\n        }\n    }\n}\nvoid spfa1(int p)\n{\n    while (!q.empty()) q.pop();\n    for (int i=1;i<=tot;i++)\n    {\n        dis[i]=inf;\n        vi[i]=0;\n    }\n    dis[p]=0;\n    vi[p]=1;\n    q.push(p);\n    while (!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        for (int i=0;i<edge2[now].size();i++)\n        {\n            int y=edge2[now][i].y;\n            if (dis[y]>dis[now]+edge2[now][i].c)\n            {\n                dis[y]=dis[now]+edge2[now][i].c;\n                if (!vi[y])\n                {\n                    vi[y]=1;\n                    q.push(y);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d%d\",&n,&m,&cap))\n    {\n        if (n==0&&m==0&&cap==0) break;\n        for (int i=1;i<=n*2;i++)\n        {\n            edge[i].clear();\n            edge2[i].clear();\n        }\n        mp.clear();\n        tot=0;\n        cin>>st>>en;\n        mp[st]=++tot;\n        mp[en]=++tot;\n        for (int i=1;i<=n;i++)\n        {\n            int len;\n            string s1,s2;\n            cin>>s1>>s2>>len;\n            if (!mp[s1]) mp[s1]=++tot;\n            if (!mp[s2]) mp[s2]=++tot;\n            int n1,n2;\n            n1=mp[s1];\n            n2=mp[s2];\n            xxx pp;\n            pp.c=len;\n            pp.y=n2;\n            edge[n1].push_back(pp);\n            pp.y=n1;\n            edge[n2].push_back(pp);\n        }\n        memset(f,0,sizeof(f));\n        for (int i=1;i<=m;i++)\n        {\n            string ss;\n            cin>>ss;\n            if (!mp[ss]) mp[ss]=++tot;\n            f[mp[ss]]=1;\n        }\n        f[1]=f[2]=1;\n        for (int i=1;i<=tot;i++)\n            if (f[i]) spfa(i);\n        spfa1(1);\n        if (dis[2]<inf) printf(\"%d\\n\",dis[2]);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct E{\n  string t;\n  int d;\n};\n\nstruct S{\n  string v;\n  int r,d;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nint main(){\n  for(int n,mm,cap;cin>>n>>mm>>cap,n|mm|cap;){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    map<string,vector<E> > m;\n    for(int i=0;i<n;i++){\n      string c[2];\n      int d;\n      cin>>c[0]>>c[1]>>d;\n      for(int j=0;j<2;j++){\n\tE ce={c[j^1],d};\n\tm[c[j]].push_back(ce);\n      }\n    }\n    set<string> gs;\n    for(int i=0;i<mm;i++){\n      string s;\n      cin>>s;\n      gs.insert(s);\n    }\n    priority_queue<S> que;\n    S is={src,cap,0};\n    que.push(is);\n    map<string,map<int,int> > p;\n    while(!que.empty()){\n      S c=que.top();\n      if(c.v==dest)break;\n      que.pop();\n      map<int,int>::iterator it=p[c.v].upper_bound(c.r-1);\n      if(it!=p[c.v].end()&&it->second<=c.d)continue;\n      p[c.v][c.r]=c.d;\n      for(int i=0;i<m[c.v].size();i++){\n\tif(m[c.v][i].d<=c.r){\n\t  S n={m[c.v][i].t,c.r-m[c.v][i].d,c.d+m[c.v][i].d};\n\t  if(gs.count(n.v)){\n\t    n.r=cap;\n\t  }\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.top().d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3000][22], d[3000][22];\nchar st[333][22];\nint w[3000];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    vector<string> node;\n    scanf(\"%s%s\",s,t);\n    node.push_back(s);\n    node.push_back(t);\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    int sz = node.size();\n    g.clear();\n    cost.clear();\n    sta.clear();\n    g.resize(sz,vector<edge>());\n    cost.resize(sz,vector<int>(cap*10+1));\n    sta.resize(sz);\n    for( int i = 0; i < sz; i++ ) {\n      sta[i] = false;\n      for( int j = 0; j <= cap*10; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    node.clear();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int tt=0,int cc=0){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge& e1)const{\n\t\treturn c<e1.c;\n\t}\n};\n\ntypedef edge data;\n\nint n,m,cap;\n\nvector<edge> G[5001];\nvector<edge> GG[5001];\nmap<string,int> city;\nint dp[5000];\nbool flag[5000];\n\nvoid make_path(int v){\n\tfill(dp,dp+n,cap+1);\n\tpriority_queue<data> que;\n\tque.push(edge(v,0));\n\tdp[v]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t!=v && flag[q.t]){\n\t\t\tGG[v].push_back(edge(q.t,q.c));\n\t\t\tGG[q.t].push_back(edge(v,q.c));\n\t\t}\n\t\tfor(int i=0;i<G[q.t].size();i++){\n\t\t\tedge e=G[q.t][i];\n\t\t\tif(dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dijk(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(edge(f,0));\n\tdp[f]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.t]<q.c)continue;\n\t\tif(q.t==t)return dp[q.t];\n\t\tfor(int i=0;i<GG[q.t].size();i++){\n\t\t\tedge e=GG[q.t][i];\n\t\t\tif(dp[e.t]==-1 || dp[e.t]>dp[q.t]+e.c){\n\t\t\t\tdp[e.t]=dp[q.t]+e.c;\n\t\t\t\tque.push(data(e.t,dp[e.t]));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tif(n+m+cap==0)break;\n\t\tcap*=10;\n\t\tstring s,g;\n\t\tcin >> s >> g;\n\t\tif(city.find(s)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(s,city.size()));\n\t\t}\n\t\tif(city.find(g)==city.end()){\n\t\t\tcity.insert(map<string,int>::value_type(g,city.size()));\n\t\t}\n\t\tflag[city[s]]=true;\n\t\tflag[city[g]]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tint c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tif(city.find(f)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(f,city.size()));\n\t\t\t}\n\t\t\tif(city.find(t)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(t,city.size()));\n\t\t\t}\n\t\t\tG[city[f]].push_back(edge(city[t],c));\n\t\t\tG[city[t]].push_back(edge(city[f],c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(city.find(str)==city.end()){\n\t\t\t\tcity.insert(map<string,int>::value_type(str,city.size()));\n\t\t\t}\n\t\t\tflag[city[str]]=true;\n\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(flag[i])make_path(i);\n\t\t}\n\t\tprintf(\"%d\\n\",dijk(city[s],city[g]));\n\t\tmemset(flag,false,sizeof(flag));\n\t\tfor(int i=0;i<city.size();i++){\n\t\t\tG[i].clear();\n\t\t\tGG[i].clear();\n\t\t}\n\t\tcity.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define maxn 305\n#define maxm 6010\nconst int INF=1000000000;\n\nint n,m,d,num;\nstruct node\n{\n    int v,next,w;\n}e[maxm],e2[maxm];\nint ecnt,ecn,pre[3005],pr[3005];\nchar st[20],str[20];\nmap<string,int> mp;\nint dis[3005][3005];\nbool ok[3005];\nvoid add(int u,int v,int w)\n{\n    e[ecnt].v=v;\n    e[ecnt].next=pre[u];\n    e[ecnt].w=w;\n    pre[u]=ecnt++;\n}\nvoid add2(int u,int v,int w)\n{\n    e2[ecn].v=v;\n    e2[ecn].w=w;\n    e2[ecn].next=pr[u];\n    pr[u]=ecn++;\n}\nbool vis[3005];\nvoid spfa(int s)\n{\n    for (int i=1;i<=num;i++)\n    {\n        dis[s][i]=INF;\n        vis[i]=0;\n    }\n    dis[s][s]=0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        vis[u]=0;\n        for (int i=pre[u];i!=-1;i=e[i].next)\n        {\n            int v=e[i].v;\n            if (dis[s][v]>dis[s][u]+e[i].w)\n            {\n                dis[s][v]=dis[s][u]+e[i].w;\n                if (!vis[v]&&!ok[v])\n                {\n                    vis[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    for (int i=1;i<=num;i++)\n        if (ok[i]&&dis[s][i]<=d)\n            add2(s,i,dis[s][i]);\n}\nvoid spfa2()\n{\n    for (int i=1;i<=num;i++)\n    {\n        dis[1][i]=INF;\n        vis[i]=0;\n    }\n    dis[1][1]=0;\n    queue<int> q;\n    q.push(1);\n    while (!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        vis[u]=0;\n        for (int i=pr[u];i!=-1;i=e2[i].next)\n        {\n            int v=e2[i].v;\n            if (dis[1][v]>dis[1][u]+e2[i].w)\n            {\n                dis[1][v]=dis[1][u]+e2[i].w;\n                if (!vis[v])\n                {\n                    vis[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (dis[1][2]==INF) printf(\"-1\\n\");\n    else printf(\"%d\\n\",dis[1][2]);\n}\nint main()\n{\n    //freopen(\"/home/moor/Code/input2\",\"r\",stdin);\n    int w,tmp;\n    while (scanf(\"%d%d%d\",&m,&n,&d)!=-1)\n    {\n        if (!m&&!n&&!d) break;\n        mp.clear();\n        ecn=ecnt=0;\n        memset(pr,-1,sizeof(pr));\n        memset(pre,-1,sizeof(pre));\n        scanf(\"%s%s\",st,str);\n        d*=10;\n        mp[st]=1,mp[str]=2;\n        num=2;\n        for (int i=1;i<=m;i++)\n        {\n            scanf(\"%s%s%d\",st,str,&w);\n            if (mp.find(st)==mp.end()) mp[st]=++num;\n            if (mp.find(str)==mp.end()) mp[str]=++num;\n            int u=mp[st],v=mp[str];\n            add(u,v,w);\n            add(v,u,w);\n        }\n        memset(ok,0,sizeof(ok));\n        for (int i=1;i<=n;i++)\n        {\n            scanf(\"%s\",st);\n            ok[mp[st]]=1;\n        }\n        ok[1]=ok[2]=1;\n        for (int i=1;i<=num;i++)\n            if (ok[i])\n                spfa(i);\n        spfa2();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\nconst int maxn = 6010;\nconst int maxm = 20010;\nconst int inf  = 0x3f3f3f3f;\n\nstruct Edge {\n    int u, v, w, next;\n    Edge() {}\n    Edge(int t_u, int t_v, int t_w, int t_next) : u(t_u), v(t_v), w(t_w), next(t_next) {}\n}edges1[maxm], edges2[maxm];\n\nint head1[maxn], edge_sum1;\nint head2[maxn], edge_sum2;\n\nvoid init_graph() {\n    edge_sum1 = edge_sum2 = 0;\n    memset(head1, -1, sizeof(head1));\n    memset(head2, -1, sizeof(head2));\n}\n\nvoid addEdge1(int u, int v, int w) {\n    edges1[edge_sum1].u = u;\n    edges1[edge_sum1].v = v;\n    edges1[edge_sum1].w = w;\n    edges1[edge_sum1].next = head1[u];\n    head1[u] = edge_sum1++;\n}\n\nvoid addEdge2(int u, int v, int w) {\n    edges2[edge_sum2].u = u;\n    edges2[edge_sum2].v = v;\n    edges2[edge_sum2].w = w;\n    edges2[edge_sum2].next = head2[u];\n    head2[u] = edge_sum2++;\n}\n\nmap<string, int> myMap;\nint n, m, cap, ncount;\n//string source, sink;\n//char source[110], sink[110];\nstring source, sink;\nbool mark[maxn];\nint  dis[maxn];\nbool visit[maxn];\n\nvoid SPFA(int s, Edge edges[], int head[]) {\n    memset(dis, inf, sizeof(dis));\n    memset(visit, false, sizeof(visit));\n    queue<int> Q;\n    Q.push(s); visit[s] = true; dis[s] = 0;\n    while(!Q.empty()) {\n        int u = Q.front(); Q.pop(); visit[u] = false;\n        for(int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].v;\n            if(dis[v] > dis[u] + edges[i].w) {\n                dis[v] = dis[u] + edges[i].w;\n                if(!visit[v]) {\n                    visit[v] = true;\n                    Q.push(v);\n                }\n            }\n        }\n    }\n    return ;\n}\n\nint main() {\n\n    //freopen(\"aa.in\", \"r\", stdin);\n\n    char str1[110], str2[110];\n    string strr1, strr2;\n    int w;\n    while(scanf(\"%d %d %d\", &n, &m, &cap) && n + m + cap) {\n        //cin >> source >> sink;\n        scanf(\"%s %s\", str1, str2);\n        source = str1; sink = str2;\n        init_graph(); ncount = 0; myMap.clear();\n        if(myMap.count(source) == 0) {\n            myMap[source] = ++ncount;\n        }\n        if(myMap.count(sink) == 0) {\n            myMap[sink] = ++ncount;\n        }\n        for(int i = 0; i < n; ++i) {\n            scanf(\"%s %s %d\", str1, str2, &w);\n            //cin >> str1 >> str2 >> w;\n            strr1 = str1; strr2 = str2;\n            if(myMap.count(strr1) == 0) {\n                myMap[strr1] = ++ncount;\n            }\n            if(myMap.count(strr2) == 0) {\n                myMap[strr2] = ++ncount;\n            }\n            addEdge1(myMap[strr1], myMap[strr2], w);\n            addEdge1(myMap[strr2], myMap[strr1], w);\n        }\n        memset(mark, false, sizeof(mark));\n        for(int i = 0; i < m; ++i) {\n            scanf(\"%s\", str1);\n            strr1 = str1;\n            //cin >> str1;\n            if(myMap.count(strr1) == 0) {\n                myMap[strr1] = ++ncount;\n            }\n            mark[myMap[strr1]] = true;\n        }\n\n        SPFA(myMap[source], edges1, head1);\n        for(int i = 1; i <= ncount; ++i) {\n            if(dis[i] <= cap*10 && i != myMap[source]) {\n                addEdge2(myMap[source], i, dis[i]);\n            }\n        }\n\n        for(int i = 1; i <= ncount; ++i) {\n            if(mark[i] && i != myMap[source]) {\n                SPFA(i, edges1, head1);\n                for(int j = 1; j <= ncount; ++j) {\n                    if(dis[j] <= cap*10 && j != i) {\n                        addEdge2(i, j, dis[j]);\n                    }\n                }\n            }\n        }\n        SPFA(myMap[source], edges2, head2);\n        int ans = dis[myMap[sink]];\n        if(ans == inf) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n#if 0\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n#endif\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nvector<pair<int, int> > E[6010];\nbool gas[6010];\nll dist[6010][2010];\nbool done[6010][2010];\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[0][CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1) return q.second;\n\n\t\tif (done[n][c]) continue;\n\t\tdone[n][c] = true;\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas[nn]) nc = CAP;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (ncost < dist[nn][nc])\n\t\t\t{\n\t\t\t\tdist[nn][nc] = ncost;\n\t\t\t\tque.push(make_pair(nn * 10000 + nc, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tint idx = 0;\n\t\tmap<string, int> m;\n\n\t\tstring src, dest; cin >> src >> dest;\n\t\tm[src] = 0; m[dest] = 1;\n\t\tidx = 2;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\t\tint d; cin >> d;\n\t\t\tE[m[a]].push_back(make_pair(m[b], d));\n\t\t\tE[m[b]].push_back(make_pair(m[a], d));\n\t\t}\n\n\t\trep(i, 0, 6010) gas[i] = false;\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\t\tgas[m[s]] = true;\n\t\t}\n\n\t\trep(i, 0, 6010) rep(j, 0, 2010) dist[i][j] = INF;\n\t\trep(i, 0, 6010) rep(j, 0, 2010) done[i][j] = false;\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nvoid Dijkstra(const Graph& g,int v,vi& dist)\n{\n\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\tpq.emplace(-1,v,0);\n\twhile(pq.size()){\n\t\tEdge cur=pq.top(); pq.pop();\n\t\tif(dist[cur.dst]!=INF) continue;\n\t\tdist[cur.dst]=cur.weight;\n\t\tfor(Edge e:g[cur.dst])\n\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t}\n}\n\nint main()\n{\n\tfor(int r,m,cap;cin>>r>>m>>cap && r|m|cap;){\n\t\tcap*=10;\n\t\tmap<string,int> f;\n\t\tstring src,dst; cin>>src>>dst;\n\t\tf[src]=0,f[dst]=1;\n\t\tGraph g(2);\n\t\trep(i,r){\n\t\t\tstring s,t; int w; cin>>s>>t>>w;\n\t\t\tif(!f.count(s)) f.insert(mp(s,f.size())),g.resize(g.size()+1);\n\t\t\tif(!f.count(t)) f.insert(mp(t,f.size())),g.resize(g.size()+1);\n\t\t\tint u=f[s],v=f[t];\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tint n=f.size();\n\t\t\n\t\tvi lpg(m);\n\t\trep(i,m){\n\t\t\tstring s; cin>>s;\n\t\t\tlpg[i]=f[s];\n\t\t}\n\t\t\n\t\tvvi dists(m+2,vi(n,INF));\n\t\trep(i,m) Dijkstra(g,lpg[i],dists[i]);\n\t\trep(i,2) Dijkstra(g,i,dists[m+i]);\n\t\t\n\t\tvvi dp(m+2,vi(m+2,INF));\n\t\trep(i,m+2){\n\t\t\trep(j,m) if(dists[i][lpg[j]]<=cap)\n\t\t\t\tdp[i][j]=dists[i][lpg[j]];\n\t\t\trep(j,2) if(dists[i][j]<=cap)\n\t\t\t\tdp[i][m+j]=dists[i][j];\n\t\t}\n\t\t\n\t\trep(k,m+2) rep(i,m+2) rep(j,m+2)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tif(dp[m][m+1]==INF)\n\t\t\tcout<<-1<<endl;\n\t\telse\n\t\t\tcout<<dp[m][m+1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\n\nint N, M, C, SZ;\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint idx(int u, int cap){\n  return cap*SZ+u;\n}\n\nconst LL B1 = 1009, B2 = 1007, M1 = 1000000007, M2 = 1000000009;\npair<LL,LL> RollingHash(string& str){\n  int N = str.size();\n  pair<LL,LL> res = MP(0,0);\n  for(int i=0;i<N;++i){\n\tres.first = (res.first + str[i]) * B1 % M1;\n\tres.second = (res.second + str[i]) * B2 % M2;\n  }\n  return res;\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M>>C,N){\n\tmap<pair<LL,LL>,int> cor;\n\tstring src, dest; cin >> src >> dest;\n\tSZ = 0;\n\tcor[RollingHash(src)] = SZ++;\n\tcor[RollingHash(dest)] = SZ++;\n\tC *= 10;\n\tvector<tuple<int,int,int>> mem;\n\tREP(i,N){\n\t  string s1, s2; int d;\n\t  cin >> s1 >> s2 >> d;\n\t  pair<LL,LL> p1 = RollingHash(s1);\n\t  pair<LL,LL> p2 = RollingHash(s2);\n\t  if(!cor.count(p1)) cor[p1] = SZ++;\n\t  if(!cor.count(p2)) cor[p2] = SZ++;\n\t  mem.PB(make_tuple(cor[p1],cor[p2],d));\n\t}\n\n\tGraph G(SZ*(C+1));\n\tfor(auto& tp: mem){\n\t  int u, v, d;\n\t  tie(u,v,d) = tp;\n\t  for(int j=d;j<=C;++j){\n\t\tG[idx(u,j)].PB(Edge(idx(v,j-d),d));\n\t\tG[idx(v,j)].PB(Edge(idx(u,j-d),d));\n\t  }\n\t}\n\tREP(i,M){\n\t  string s; cin >> s;\n\t  pair<LL,LL> p = RollingHash(s);\n\t  if(!cor.count(p)) continue;\n\t  for(int j=0;j<=C;++j)\n\t\tG[idx(cor[p],j)].PB(Edge(idx(cor[p],C),0));\t  \n\t}\n\n\tVI dist(SZ*(C+1));\n\tDijkstra(G,dist,idx(0,C));\n\tint ans = INF;\n\tfor(int j=0;j<=C;++j)\n\t  ans = min(ans, dist[idx(1,j)]);\n\n\tcout << (ans==INF? -1: ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n諤サ逧?庄莉・蠖堤コウ謌?荳牙?扈?x,y,z):\nx:逕ィ謗貞コ剰ァ」蜀ウ\ny:逕ィ謗貞コ丞刈cdq蛻?イサ隗」蜀ウ\nz:逕ィ譬醍憾謨ー扈?ァ」蜀ウ\n*/\n#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <ostream>\n#include <ios>\n#include <cstdlib>\nusing namespace std;\n\n#define wh while\n#define inf (int)(~0u/2)\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FOR1(i, n) for(int i = 1; i < n; i++)\n#define FOR2(i, n) for(int i = 0; i <= n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define FORI(it,n) for(typeof(n.begin()) it = n.begin(); it != n.end(); it++)\n#define sf scanf\n#define pf printf\n#define frs first\n#define sec second\n#define psh push_back\n#define mkp make_pair\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n#define lt(v) v << 1\n#define rt(v) v << 1 | 1\n#define mid ((l + r) >> 1)\n#define lson l, mid, v << 1\n#define rson mid + 1, r, v << 1 | 1\n\n#define fre freopen(\"1.txt\", \"r\", stdin)\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 6030;\nint N, M, cap;\nint st, ed, curcost;\nbool curvis;\nstruct NODE{\n    int to, cost;\n};\n\nbool isadd[maxn];\nvector<NODE> G[maxn];\nvector<NODE> G2[maxn];\nchar tmpA[20], tmpB[20];\nint oil[350];\nmap<string, int> mp;\nvoid dfs1(int cur, int fa, int curcost){\n    if(cur == fa){\n        if(curvis)\n            return ;\n        else\n            curvis = true;\n    }\n    if(cur != fa){\n        NODE c; c.to = cur; c.cost = curcost;\n        if(!isadd[cur]){\n            G2[fa].PB(c);\n            isadd[cur] = true;\n        }\n    }\n    FOR(i, (int)G[cur].size())\n        if(G[cur][i].cost + curcost <= cap * 10 && G[cur][i].to != fa)\n            dfs1(G[cur][i].to, fa, G[cur][i].cost + curcost);\n}\n\nstruct HeapNode {\n  int d, u;\n  bool operator < (const HeapNode& rhs) const {\n    return d > rhs.d;\n  }\n};\nstruct Dijkstra {\n    int n;\n    void init(int a){\n        n = a;\n    }\n    bool done[maxn];\n    int d[maxn];\n\n    void dijkstra(int s) {\n        priority_queue<HeapNode> Q;\n        REP(i, n){\n            d[i] = INF;\n        }\n        d[s] = 0;\n        memset(done, 0, sizeof(done));\n        Q.push((HeapNode){0, s});\n        while(!Q.empty()) {\n            HeapNode x = Q.top(); Q.pop();\n            int u = x.u;\n            if(done[u]) continue;\n            done[u] = true;\n            for(int i = 0; i < (int)G2[u].size(); i++) {\n                int curto = G2[u][i].to;\n                int curdist = G2[u][i].cost;\n                if(d[curto] > d[u] + curdist) {\n                    d[curto] = d[u] + curdist;\n                    Q.push((HeapNode){d[curto], curto});\n                }\n            }\n        }\n    }\n} djk;\nint main(){\n    wh(sf(\"%d%d%d\", &N, &M, &cap) != EOF){\n        if(!N && !M && !cap)\n            break;\n        int cnt = 0; mp.clear(); int oilcnt = 0;\n        REP(i, N * 2)\n            G[i].clear();\n        REP(i, N * 2)\n            G2[i].clear();\n        sf(\"%s\", tmpA); sf(\"%s\", tmpB);\n        mp[tmpA] = ++cnt;\n        st = mp[tmpA];\n        mp[tmpB] = ++cnt;\n        ed = mp[tmpB];\n        FOR(i, N){\n            sf(\"%s\", tmpA); sf(\"%s\", tmpB); sf(\"%d\", &curcost);\n            if(!mp[tmpA]) mp[tmpA] = ++cnt;\n            if(!mp[tmpB]) mp[tmpB] = ++cnt;\n            NODE nw; nw.cost = curcost; nw.to = mp[tmpB];\n            G[mp[tmpA]].PB(nw); nw.to = mp[tmpA];\n            G[mp[tmpB]].PB(nw);\n        }\n        bool exi = false;\n        FOR(i, M){\n            sf(\"%s\", tmpA);\n            if(mp[tmpA] == st)\n                exi = true;\n            oil[oilcnt++] = mp[tmpA];\n        }\n        if(!exi)\n            oil[oilcnt++] = st;\n        FOR(i, oilcnt){\n            curvis = false;\n            clr(isadd, 0);\n            dfs1(oil[i], oil[i], 0);\n        }\n        djk.init(cnt);\n        djk.dijkstra(st);\n        if(djk.d[ed] == INF)\n            pf(\"-1\\n\");\n        else{\n            pf(\"%d\\n\", djk.d[ed]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    vector<Node> nodes[6001];\n    map<string,int> cities;\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\nint N,M,cap;\nstruct edge{\n\tint v,w;\n\tedge(int _v,int _w):v(_v),w(_w){\n\n\t}\n};\nvector<edge> ve[3005];\nbool hasGas[3005];\nbool visited[3005];\nint res;\nvoid DFS(int u,int t,int cur,int total){\n\tif(u==t){\n\t\tres = min(res,total);\n\t}\n\tvisited[u]=true;\n\tif(hasGas[u])\n\t\tcur = cap*10;\n\tfor(int j=0;j<ve[u].size();j++){\n\t\tedge e = ve[u][j];\n\t\tif(!visited[e.v] && cur - e.w >= 0)\n\t\t\tDFS(e.v,t,cur-e.w,total+e.w);\n\t}\n}\n\n\n\n\nint main()\n{\n\t// freopen(\"5854.in\",\"r\",stdin);\n\twhile(scanf(\"%d%d%d \",&N,&M,&cap) && (N+M+cap)){\n\t\tfor(int i=0;i<3005;i++) ve[i].clear();\n\t\tint noCnt=0;\n\t\tmap<string,int> no;\n\t\tstring start,end;\n\t\tcin >> start >> end;\n\t\tstring p1,p2;\n\t\tint u,v,w;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> p1 >> p2;\n\t\t\tif(no.find(p1)==no.end())\n\t\t\t\tno[p1]=noCnt++;\n\t\t\tif(no.find(p2)==no.end())\n\t\t\t\tno[p2]=noCnt++;\n\t\t\tu = no[p1]; v = no[p2];\n\t\t\tscanf(\"%d \",&w);\n\t\t\tve[u].push_back(edge(v,w));\n\t\t\tve[v].push_back(edge(u,w));\n\t\t}\n\t\tmemset(hasGas,0,sizeof(hasGas));\n\t\tstring gasName;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> gasName;\n\t\t\thasGas[no[gasName]]=true;\n\t\t}\n\t\tint s = no[start],t = no[end];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tres = 1e8;\n\t\tDFS(s,t,cap*10,0);\n\t\tif(res==1e8)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<string,int> con;\nvector<pii> graph[6010];\nvi dist[6010];\nbool station[6010];\n\ntypedef tuple<int,int,int> state;\n\ninline bool update(int c,int v,int g){\n\tif(g>=0&&(dist[v][g]==-1||dist[v][g]>c)){\n\t\tdist[v][g]=c;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint dijkstra(int cap){\n\tdist[0][cap]=0;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\tstate init(0,0,cap);\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tint c,v,g;\n\t\ttie(c,v,g)=cur;\n\n\t\tif(v==1) return c;\n\n\t\tif(dist[v][g]<c)\n\t\t\tcontinue;\n\n\t\tif(station[v]){\n\t\t\tg=cap;\n\t\t\tdist[v][g]=c;\n\t\t}\n\t\tfor(auto &v2:graph[v]){\n\t\t\tint nc=c+v2.second;\n\t\t\tint ng=g-v2.second;\n\t\t\tif(update(nc,v2.first,ng)){\n\t\t\t\tstate next(nc,v2.first,ng);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tint n,m,cap;\n\twhile(cin >> n >> m >> cap){\n\t\tif(n==0&&m==0&&cap==0)\n\t\t\tbreak;\n\t\tint nmax=0;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tcon[src]=nmax++,con[dest]=nmax++;\n\t\trep(i,n){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif(con.find(a)==con.end()) con[a]=nmax++;\n\t\t\tif(con.find(b)==con.end()) con[b]=nmax++;\n\t\t\tint aa,bb,c; cin >> c;\n\t\t\taa=con[a],bb=con[b];\n\t\t\tpii in(bb,c);graph[aa].pb(in);\n\t\t\tin.first=aa,graph[bb].pb(in);\n\t\t}\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstation[con[s]]=true;\n\t\t}\n\t\tcap*=10;\n\t\trep(i,nmax) dist[i].assign(cap+1,-1);\n\t\tint ans=dijkstra(cap);\n\t\tcout << ans << endl;\n\t\tcon.clear();\n\t\trep(i,nmax) graph[i].clear();\n\t\trep(i,nmax) dist[i].clear();\n\t\tclr(station,false);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  int used[N]={};\n  vector<vector<int> >D(cap+1,vector<int>(n,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  D[cap][0]=0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n\n    if(pos==1) return d;\n    if(D[c][pos]<d||used[pos]>c)continue;\n    used[pos]=c;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nc][nx]>nd)Q.push(PP(nd,P(nc,nx))),D[nc][nx]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n \n \nclass DP{\npublic:\n    int cost, gas, state;\n     \n    DP(){}\n    DP(int st, int g, int cc){\n        cost = cc;state=st;gas=g;\n    }\n     \n    bool operator< (const DP &opp) const {\n        return cost>opp.cost;\n    }\n};\n \nstruct edge{\n    int to;\n    int dist;\n};\n \nint N, M, C;\n\nbool visit[6000][2001];\nmain(){\n    int i,j;\n    while(cin >> N >> M >> C, N){\n        string ss,gg;\n        int s, g;\n        cin >> ss >> gg;\n        vector< vector<edge> > E;\n        map<string, int> idx;\n        set<int> stations;\n        for(i=0;i<N;i++){\n            string from, to;\n            int dist;\n            cin >> from >> to >> dist;\n            if(!idx.count(from)){\n                idx[from] = idx.size() - 1;\n                E.push_back(vector<edge>(0));\n            }\n            if(!idx.count(to)){\n                idx[to] = idx.size() - 1;\n                E.push_back(vector<edge>(0));\n            }\n            E[idx[from]].push_back((edge){idx[to], dist});\n            E[idx[to]].push_back((edge){idx[from], dist});\n        }\n        for(i=0;i<M;i++){\n            string sta;\n            cin >> sta;\n            stations.insert(idx[sta]);\n        }\n        s = idx[ss];g = idx[gg];\n         \n        priority_queue<DP> dp;\n        DP S;\n        dp.push(DP(s, C*10, 0));\n        REP(i, idx.size()) REP(j, C*10+1) visit[i][j] = false;\n        visit[s][C*10] = true;\n        while(!dp.empty()){\n            S = dp.top();\n            dp.pop();\n            if(S.state == g) break;\n            FOR(it, E[S.state]){\n                DP T=S;\n                if(T.gas < it->dist) continue;\n                T.state = it->to;\n                if(stations.count(it->to)) T.gas = C*10;\n                else T.gas -= it->dist;\n                T.cost += it->dist;\n                if(!visit[it->to][T.gas]){\n                    dp.push(T);\n                    visit[it->to][T.gas] = true;\n                }\n            }\n        }\n        cout << ((S.state == g) ? S.cost : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct Edge {\n  int town, cost;\n};\n\nstruct P {\n  int town, cost;\n  int distance;\n\n  bool operator >(const P& p) const {\n    return cost > p.cost;\n  }\n};\n\nconst int MAX_CAPACITY = 200;\nconst int INF = (int)1e9;\n\nstruct Edgestr {\n  string from, to;\n  int cost;\n};\n\nint main() {\n  int town_n, gas_n, capacity;\n  string src, dst;\n  while(cin >> town_n >> gas_n >> capacity, town_n | gas_n | capacity) {\n    cin >> src >> dst;\n\n    vector<vector<Edge>> E(town_n + 1);\n    vb isgas(town_n + 1);\n\n    map<string, int> id;\n    map<int, string> ids;\n    vector<Edgestr> edgestring(town_n);\n    REP(i, town_n){\n      string from, to;\n      int cost;\n      cin >> from >> to >> cost;\n      if (!EXIST(id, from)) id[from] = id.size();\n      if (!EXIST(id, to)) id[to] = id.size();\n      ids[id[from]] = from;\n      ids[id[to]] = to;\n      E[id[from]].push_back({id[to], cost});\n      E[id[to]].push_back({id[from], cost});\n    }\n    REP(i, gas_n){\n      string town;\n      cin >> town;\n      isgas[id[town]] = true;\n    }\n    int start = id[src];\n    int goal = id[dst];\n\n    vvi G(town_n+1, vi(capacity * 10 + 1, INF));\n    G[start][0];\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push({start, 0, 0});\n\n    int res = -1;\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      LOG(\"%10s %3d %d\\n\", ids[p.town].c_str(), p.cost, p.distance);\n      if(p.town == goal) {\n        res = p.cost;\n        break;\n      }\n\n      for(Edge e:E[p.town]) {\n        int next_dist = p.distance + e.cost;\n        LOG(\"%s -->> %s%s %d/%d\\n\",ids[p.town].c_str(),isgas[e.town]?\"*\":\"\", ids[e.town].c_str() , next_dist, capacity * 10);\n        if(next_dist > capacity * 10) continue;\n        if(isgas[e.town]) next_dist = 0;\n        int next_cost = p.cost + e.cost;\n        if (G[e.town][next_dist] > next_cost) {\n          G[e.town][next_dist] = next_cost;\n          que.push({e.town, next_cost, next_dist});\n        }\n      }\n    }\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\nstruct node{\n  int index,gas;\n  ll cost;\n  node(int index,int gas,ll cost):index(index),gas(gas),cost(cost){}\n  bool operator<(const node& other)const{\n    return cost>other.cost;\n  }\n};\nconst ll MAX=LLONG_MAX/10;\nconst int NONE=-1;\n\nint main(){\n  int r,m,cap;\n  while(cin>>r>>m>>cap,r|m|cap){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    int start;\n    int goal;\n    vvp dist(2*r);\n    vs cities;\n    REP(i,r){\n      string a,b;\n      cin>>a>>b;\n      int d;\n      cin>>d;\n      int ai,bi;\n      vs::iterator it_a=find(ALL(cities),a);\n      if(it_a!=cities.end()){\n        ai=it_a-cities.begin();\n      }else{\n        cities.push_back(a);\n        ai=cities.size()-1;\n      }\n      vs::iterator it_b=find(ALL(cities),b);\n      if(it_b!=cities.end()){\n        bi=it_b-cities.begin();\n      }else{\n        cities.push_back(b);\n        bi=cities.size()-1;\n      }\n      dist[ai].push_back(make_pair(bi,d));\n      dist[bi].push_back(make_pair(ai,d));\n      if(a==src){ start=ai; }\n      if(b==src){ start=bi; }\n      if(a==dest){ goal=ai; }\n      if(b==dest){ goal=bi; }\n    }\n    int n=cities.size();\n    vi is_station(n);\n    REP(i,m){\n      string s;\n      cin>>s;\n      vs::iterator it=find(ALL(cities),s);\n      if(it!=cities.end()){\n        is_station[it-cities.begin()]=1;\n      }\n    }\n\n    priority_queue<node> q;\n    q.push(node(start,cap,0));\n    vvl cost(n,vl(cap+1,MAX));\n    cost[start][cap]=0;\n    while(!q.empty()){\n      node cnode=q.top();q.pop();\n      if(cost[cnode.index][cnode.gas]<cnode.cost){\n        continue;\n      }\n      REP(ii,dist[cnode.index].size()){\n        int i=dist[cnode.index][ii].first;\n        int dd=dist[cnode.index][ii].second;\n        if(i!=cnode.index&&dd!=NONE){\n          ll newcost=cnode.cost+dd;\n          int newgas=cnode.gas-dd;\n          if(newgas>=0){\n            if(is_station[i]){\n              newgas=cap;\n            }\n            if(cost[i][newgas]>newcost){\n              cost[i][newgas]=newcost;\n              q.push(node(i,newgas,newcost));\n            }\n          }\n        }\n      }\n    }\n    ll ans=MAX;\n    REP(i,cap+1){\n      ans=min(ans,cost[goal][i]);\n    }\n\n    cout<<(ans==MAX?-1:ans)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge {\n  int t,c;\n  edge(){}\n  edge(int t,int c):t(t),c(c){}\n};\n\nstruct state {\n  int n,cap,c;\n  state(){}\n  state(int n,int cap,int c):n(n),cap(cap),c(c){}\n  bool operator>(const state& e)const{\n    return c>e.c;\n  }\n};\n\nchar s[22],t[22];\nchar c[3333][22], d[3333][22];\nchar st[333][22];\nint w[3333];\nvector<vector<edge> > g;\nvector<bool> sta;\nvector<vector<int> > cost;\n\nint main(void)\n{\n  int n,m,cap;\n  for(;;) {\n    scanf(\"%d%d%d\",&n,&m,&cap); if(n+m+cap==0)break;\n    vector<string> node;\n    scanf(\"%s%s\",s,t);\n    node.push_back(s);\n    node.push_back(t);\n    for( int i = 0; i < n; i++ ) {\n      scanf(\"%s%s%d\",c[i],d[i],w+i);\n      node.push_back(c[i]);\n      node.push_back(d[i]);\n    }\n    for( int i = 0; i < m; i++ ) {\n      scanf(\"%s\",st[i]);\n      node.push_back(st[i]);\n    }\n    sort(node.begin(),node.end());\n    node.erase(unique(node.begin(),node.end()),node.end());\n    int sz = node.size();\n    g.clear();\n    cost.clear();\n    sta.clear();\n    g.resize(sz,vector<edge>());\n    cost.resize(sz,vector<int>(cap*10+1));\n    sta.resize(sz);\n    for( int i = 0; i < sz; i++ ) {\n      sta[i] = false;\n      for( int j = 0; j <= cap*10; j++ ) {\n        cost[i][j] = 1919810893;\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      int a = lower_bound(node.begin(),node.end(),c[i])-node.begin();\n      int b = lower_bound(node.begin(),node.end(),d[i])-node.begin();\n      g[a].push_back(edge(b,w[i]));\n      g[b].push_back(edge(a,w[i]));\n    }\n    for( int i = 0; i < m; i++ ) {\n      sta[lower_bound(node.begin(),node.end(),st[i])-node.begin()] = true;\n    }\n    int from,to;\n    from = lower_bound(node.begin(),node.end(),s)-node.begin();\n    to = lower_bound(node.begin(),node.end(),t)-node.begin();\n    priority_queue<state,vector<state>,greater<state> > q;\n    q.push(state(from,cap*10,0));\n    cost[from][cap*10] = 0;\n    int res = -1;\n    while( !q.empty() ) {\n      state p = q.top(); q.pop();\n      //printf(\"%d %d\\n\",p.c,p.cap);\n      if( p.n == to ) {\n        res = p.c;\n        break;\n      }\n      for( int i = 0; i < int(g[p.n].size()); i++ ) {\n        edge& e = g[p.n][i];\n        int c = p.c+e.c;\n        int ncap = p.cap-e.c;\n        if( ncap < 0 ) continue;\n        if( sta[e.t] ) ncap = cap*10;\n        if( cost[e.t][ncap] > c ) {\n          cost[e.t][ncap] = c;\n          q.push(state(e.t,ncap,c));\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( nstat.size(), vector<int>( n, INF ) );\n\tfor( int first = 0; first < nstat.size(); ++first ){\n\t\tint n_first = nstat[first];\n\t\tdist[first][n_first] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, n_first ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_from = p.second;\n\t\t\tif( dist[first][n_from] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_from].size(); ++i ){\n\t\t\t\tint n_to = road[n_from][i].first;\n\t\t\t\tint ds = p.first + road[n_from][i].second;\n\t\t\t\t\n\t\t\t\tif( ds <= cap && dist[first][n_to] > ds ){\n\t\t\t\t\tdist[first][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[from][n_to] <= cap && dp[to] > dp[from] + dist[from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d;\n  short cap;\n  string str;\n  Data(int d = 0,short c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2;\n  short cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\n\tpair<string,string> p2 = p;\n\tif(m[p2] == 0) swap(p2.first,p2.second);\n\n\tv.cap -= m[p2];\n\tif(v.cap < 0) continue;\n\tif(m[p2] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p2] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p2];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p2] < d[v.cap][p.second]){\n\t  for(int i=0;i<=v.cap;i++){\n\t    d[i][p.second] = d[u.cap][p.first] + m[p2];\n\t  }\n\t  v.str = p.second;\n\t  v.d = d[v.cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tset<string> cities;\n\t\tvector<vs> data(N, vs(3)); \n\t\tREP(i, N) {\n\t\t\tREP(j, 2) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tcities.insert(data[i][j]);\n\t\t\t}\n\t\t\tcin >> data[i][2];\n\t\t}\n\n\t\tmap<string, int> index;\n\t\tset<string>::iterator it = cities.begin();\n\t\tint size = 0;\n\t\twhile(it != cities.end()) {\n\t\t\tindex[*it] = size;\n\t\t\tsize++;\n\t\t\tit++;\n\t\t}\n\n\t\tvvs dist(size, vsh(size, INF));\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvs cost(size, vsh(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d][ng]) {\n\t\t\t\t\t\tcost[d][ng] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    while (1) {\n        int N, M, cap;\n        cin >> N >> M >> cap;\n        if (N == 0 && M == 0 && cap == 0) break;\n\n        cap *= 10;\n        int S, T;\n\n        map<string, int> node;\n        map<int, string> inv_node;\n        int idx = 0;\n        auto regi = [&](string name) {\n            if (CONTAIN(node, name)) return;\n            node[name] = idx;\n            inv_node[idx] = name;\n            idx++;\n        };\n\n        vector<vector<int>> edge(N);\n        vector<int> gas(M);\n        {\n            string src, dest;\n            cin >> src >> dest;\n            regi(src);\n            regi(dest);\n            S = node[src];\n            T = node[dest];\n        \n            REP(i, N) {\n                string a, b;\n                int d;\n                cin >> a >> b >> d;\n                regi(a); regi(b);\n                edge[i] = {node[a], node[b], d};\n            }\n            REP(i, M) {\n                string s;\n                cin >> s;\n                regi(s);\n                gas[i] = node[s];\n            }\n        }\n\n        int V = SZ(node);\n\n        vector<vector<pii>> g(V);\n        FORE(e, edge) {\n            int a = e[0], b = e[1], d = e[2];\n            g[a].push_back({b, d});\n            g[b].push_back({a, d});\n        }\n        vector<bool> has_gas(V, false);\n        FORE(v, gas) {\n            has_gas[v] = true;\n        }\n\n        vector<vector<int>> dist(2001, vector<int>(V, INF));\n        dist[cap][S] = 0;\n        heap<pair<int, pii>> hp;\n        hp.push({0, {cap, S}});\n        while (!hp.empty()) {\n            int c = hp.top().second.first;\n            int v = hp.top().second.second; hp.pop();\n            FORE(e, g[v]) {\n                int w = e.first;\n                int cost = e.second;\n                if (c < cost) continue;\n                if (has_gas[w]) {\n                    if (chmin(dist[cap][w], dist[c][v] + cost)) {\n                        hp.push({dist[cap][w], {cap, w}});\n                    }\n                } else {\n                    if (chmin(dist[c - cost][w], dist[c][v] + cost)) {\n                        hp.push({dist[c - cost][w], {c - cost, w}});\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        REP(i, 2001) chmin(ans, dist[i][T]);\n        if (ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 3030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, VV, N, M, cap;\nvector <edge> G[MAX_V],  GG[303];\nint d[MAX_V];\nmap <int, int> m;\nvoid add_edge1(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tG[x].push_back(te);\n\tte.to = x;\n\tG[y].push_back(te);\n}\n\nvoid add_edge2(int x, int y, int k)\n{\n\tedge te;\n\tte.to = y;\n\tte.cost = k;\n\tGG[x].push_back(te);\n\tte.to = x;\n\tGG[y].push_back(te);\n}\nvoid dijkstra1(int s)\n{\n\tpriority_queue <P, vector <P>, greater <P> > q;\n\tfill(d, d + V, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dijkstra2(int s)\n{\n\tpriority_queue <P, vector<P>, greater <P> > q;\n\tfill(d, d + VV, INF);\n\td[s] = 0;\n\tq.push(P(0, s));\n\n\twhile(!q.empty())\n\t{\n\t\tP p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < GG[v].size(); i++)\n\t\t{\n\t\t\tedge e = GG[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\t\tfor(i = 0; i < 303; i++)\n\t\t\tGG[i].clear();\n\t\tmap <string, int> ma;\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma.clear();\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tVV = M + 2;\n\t\tm[0] = 0;\n\t\tm[1] = 1;\n\t\tfor(i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tm[i + 2] = ma[a];\n\t\t}\n\t\tfor(i = 0; i < VV; i++)\n\t\t{\n\t\t\tdijkstra1(m[i]);\n\t\t\tfor(j = 0; j < VV; j++)\n\t\t\t{\n\t\t\t\tif(d[m[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(i, j, d[m[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dijkstra2(0);\n\t\tif(d[1] == INF)\n\t\t\td[1] = -1;\n\t\tprintf(\"%d\\n\", d[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[4000];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    lpg[getnum(s)]=1;\n  }\n\n  memset(vis,0,sizeof(vis));\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nc=ca-co;\n      if(vis[to][nc])continue;\n      q.push(mp(-cc-co,mp(nc,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>cap,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][node.cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std ;\n\nconst int INF = 0x3fffffff ;\nconst int MAXN = 3005 ;\nconst int Csize = 2005 ;\nconst int msize = 305 ;\nstruct Edge {\n\tint v, next ;\n\tint val ;\n} edge[MAXN*2] ; \nint head[MAXN] ;\nint ind ;\n\nint dis[MAXN][Csize];\nbool vis[MAXN][Csize] , is_sta[MAXN] ;\n\nstruct Node {\n\tchar names[20] ;\n\tbool operator < ( const Node &b) const {\n\t\treturn strcmp( names , b.names ) < 0 ;\n\t}\n} ;\nmap<Node , int> mp ;\n\ninline void init() {\n\tind = 0 ; \n \tmemset( head , -1 ,sizeof(head) ) ;\n}\n\ninline void addedge( int u , int v , int val ){\n\tedge[ind].v = v ; \n\tedge[ind].val = val  ;\n\tedge[ind].next = head[u] ;\n\thead[u] = ind++ ;\n}\n\nstruct Que {\n\tint dis , lea ;\n\tint v ;\n\tQue(){}\n\tQue(int _d , int _l , int _v):dis(_d),lea(_l),v(_v){}\n\tbool operator < (const Que& b) const {\n\t\treturn dis > b.dis ;\n\t}\n} ;\n\n\nint Dijkstra( int s , int t  , int n , int lea ) {\n\tfor ( int i = 0 ;  i<= n; i++ ) {\n\t\tfor ( int j = 0 ; j <= 2001 ; j++ )\n\t\t\tdis[i][j] = INF , vis[i][j] = false ;\n\t}\t\n\tpriority_queue<Que> Q ;\n\tQue in , out ;\n\t\n\tin = Que( 0 , lea , s ) ;\n\tQ.push(in) ;\n\tdis[s][lea] = 0 ;\n\twhile (!Q.empty()) {\n\t\tout = Q.top() ;\n\t\tQ.pop() ;\n\n\t\tif ( vis[out.v][out.lea] ) continue ;\n\t\tvis[out.v][out.lea] = true ;\n\t\t \n\t\tif (out.v == t) {\n\t\t\treturn out.dis ;\n\t\t}\n\t\t\n\t\tfor ( int i = head[out.v] ; i != -1 ; i = edge[i].next ) {\n\t\t\tin.v = edge[i].v ;\n\t\t\tif ( out.lea < edge[i].val ) continue ;\t \t\n\t\t\tin.lea = is_sta[in.v] ? lea : out.lea - edge[i].val ;\n\t\t\tif ( dis[out.v][out.lea] + edge[i].val < dis[in.v][in.lea] ) { \n\t\t\t\tin.dis = dis[in.v][in.lea] = edge[i].val + dis[out.v][out.lea] ; \n\t\t\t\tQ.push(in) ;\n\t\t\t}  \n\t\t}\n\t}\n\treturn -1 ;\n}\n\nint main() {\n\t//freopen(\"data.in\" , \"r\" , stdin) ;\n\n\tint n , m , cap ;\n\twhile ( ~scanf(\"%d%d%d\", &n, &m, &cap) ) {\n\t\tif ( n == 0 && m==0 && cap == 0 ) break ;\n\t\t\n\t\tinit() ;\n\t\tmp.clear() ;\n\n\t\tNode s1 , s2 ;\n\t\tint id = 0 ;\n\t\tscanf( \"%s%s\" , s1.names , s2.names ) ;\n\t\tif ( !mp[s1] ) mp[s1] = ++id ; \t\n\t\tif ( !mp[s2] ) mp[s2] = ++id ;\n\t\t\n\t\tint src = mp[s1] , dest = mp[s2] , val ;\n\n\t\tfor ( int i = 1 ; i <= n; i++ ) {\n\t\t\tscanf( \"%s%s%d\", s1.names , s2.names , &val ) ;\n\t\t\tif (!mp[s1]) mp[s1] = ++id ;\n\t\t\tif (!mp[s2]) mp[s2] = ++id ;\n\t\t\tint u = mp[s1] , v = mp[s2] ;\t\t\t\n\t\t\taddedge( u , v , val ) ; \n\t\t\taddedge( v , u , val ) ;\t\t\n\t\t}\n\t\t\n\t\tmemset(is_sta , false ,sizeof(is_sta) ) ;\n\t\tfor ( int i = 1 ; i <= m; i++ ) {\n\t\t\tscanf( \"%s\", s1.names ) ;\n\t\t\tif ( !mp[s1] ) mp[s1] = ++id; \n\t\t\tis_sta[mp[s1]] = true ;\n\t\t}\n\n\t\tint res = Dijkstra( src , dest , id , 10*cap ) ;\n\t\tprintf(\"%d\\n\", res) ; \n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n\n    if(vis[v][p.s.s])continue;\n\n  \tvis[v][p.s.s]=true;\n\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\tvis[v][p.s.s]=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n      if(nc>=0 && !vis[e.to][nc]){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<Edge> edges(total_roads);\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges[road_idx] = Edge(from_num,to_num,dist);\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n// -- loop macros -- //\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (int)(s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define FOREACH(i,container) for (auto &&i : container)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n\n// -- functors -- //\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV1(a,exp) [&](const auto & a) -> auto { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\n// -- typedefs -- //\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n\n// -- I/O Helper -- //\nstruct _Reader { _Reader(istream &cin) :cin(cin) {} istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { _Writer(ostream &cout) :cout(cout) {} ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\n// -- vevector -- //\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(size_t n = 0, size_t m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(size_t n = 0, size_t m = 0, size_t l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(size_t n = 0, size_t m = 0, size_t l = 0, size_t k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, iter_pair_t<T> v) { if (v.beg != v.end) { out << *v.beg++; while (v.beg != v.end) { out << \" \" << *v.beg++; } } return out; }\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\n\n// -- etc -- //\ntemplate <class T> T infinity_value();\n#define DEFINE_INFINITY_VALUE(T, val) template <> constexpr T infinity_value<T>() { return (val); }\nDEFINE_INFINITY_VALUE(int, 1 << 28);\nDEFINE_INFINITY_VALUE(uint, 1u << 28);\nDEFINE_INFINITY_VALUE(llong, 1ll << 60);\nDEFINE_INFINITY_VALUE(ullong, 1ull << 60);\nDEFINE_INFINITY_VALUE(double, HUGE_VAL);\nDEFINE_INFINITY_VALUE(float, HUGE_VAL);\n#define INF(T) infinity_value<T>()\n\ninline int sign_of(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ntemplate <class TInt> bool in_range(TInt val, TInt min, TInt max) { return val >= min && val < max; }\ntemplate <> bool in_range<double>(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ntemplate <> bool in_range<float>(float val, float min, float max) { return val - min > -EPS && val - max < EPS; }\ntemplate <class TInt> bool in_range2d(TInt x, TInt y, TInt w, TInt h) { return x >= 0 && x < w && y >= 0 && y < h; }\nvector<int> iotavn(int start, int count) { vector<int> r(count); iota(allof(r), start);\treturn r; }\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t//// for local debugging\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto classic_table = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> ctable(classic_table, classic_table + ctype<char>::table_size);\n\t//ctable[':'] |= ctype_base::space; // as delimitor\n\t//ctable['/'] |= ctype_base::space; // as delimitor\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(ctable.data())));\n\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\n// idconv //\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N, M, cap);\n\t\tif (!N) { break; }\n\t\tidconv<string> idc;\n\t\tint start, goal;\n\t\t{\n\t\t\tREAD(string, a, b);\n\t\t\tstart = idc.get(a);\n\t\t\tgoal = idc.get(b);\n\t\t}\n\n\t\tstruct St\n\t\t{\n\t\t\tint pos, cost, fuel;\n\t\t\tbool operator >  (const St &_) const { return cost != _.cost ? cost > _.cost : fuel < _.fuel; }\n\t\t};\n\n\t\tvevector<St> roads(5000);\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(string, c1, c2); READ(int, cost);\n\t\t\troads[idc.get(c1)].push_back({ idc.get(c2), cost });\n\t\t\troads[idc.get(c2)].push_back({ idc.get(c1), cost });\n\t\t}\n\n\t\tvector<bool> gassta(5000);\n\t\tREP(i, M)\n\t\t{\n\t\t\tREAD(string, c);\n\t\t\tgassta[idc.get(c)] = true;\n\t\t}\n\n\t\tpriority_queue<St, vector<St>, greater<St>> q;\n\t\tvector<int> gas(5000);\n\t\tvector<int> cost(5000, INF(int));\n\n\t\tq.push({ start, 0, cap * 10 });\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tSt p = q.top(); q.pop();\n\t\t\tif (p.fuel < gas[p.pos]) { continue; }\n\t\t\tif (gassta[p.pos]) { p.fuel = cap * 10; }\n\t\t\t//DEBUG(idc.v[p.pos], \"cost\", p.cost, \"gas\", p.fuel);\n\n\t\t\tgas[p.pos] = p.fuel;\n\t\t\tcost[p.pos] = p.cost;\n\t\t\tif (p.pos == goal) { break; }\n\t\t\tFOREACH(r, roads[p.pos])\n\t\t\t{\n\t\t\t\tint to = r.pos;\n\t\t\t\tif (r.cost <= p.fuel)\n\t\t\t\t{\n\t\t\t\t\tif (gas[to] < p.fuel - r.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push({ r.pos, p.cost + r.cost, p.fuel - r.cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tWRITE(cost[goal] < INF(int) ? cost[goal] : -1);\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <set>\n#include <map>\n#define INF 1000000007\n#define MAX_V 5030\ntypedef long long ll;\n\nusing namespace std;\nstruct edge{int to, cost;};\ntypedef pair < int, int> P;//first 譛?洒霍晉ヲサ second鬘カ轤ケ郛門捷\nint V, n, m, cap, gg[MAX_V];\nvector <edge>  GG[MAX_V];\nint dd[MAX_V][MAX_V];\nint d[MAX_V][MAX_V];\nvector <int> g(MAX_V);\nvoid add_edge1(int x, int y, int k)\n{\n\tdd[x][y] = k;\n\tdd[y][x] = k;\n}\nvoid add_edge2(int x, int y, int k)\n{\n\td[x][y] = k;\n\td[y][x] = k;\n}\nvoid floyd_warshall1()\n{\n        int i, j, k;\n        for(k = 0;k < V; k++)\n                for(i= 0; i < V; i++)\n                        for(j = 0; j < V; j++)\n                                dd[i][j] = min(dd[i][j], dd[i][k] + dd[k][j]);\n}\nvoid floyd_warshall2()\n{\n        int i, j, k;\n        for(k = 0;k < g.size(); k++)\n                for(i= 0; i < g.size(); i++)\n                        for(j = 0; j < g.size(); j++)\n                                d[g[i]][g[j]] = min(d[g[i]][g[j]], d[g[i]][g[k]] + d[g[k]][g[j]]);\n}\nmap <string, int> ma;\nint main()\n{\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\tint i, j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\", &n, &m, &cap);\n\t\tif(n == 0 && m == 0 && cap == 0)\n\t\t\treturn 0;\n\t\tfor(i = 0; i < MAX_V; i++)\n\t\t{\n\t\t\t GG[i].clear();\n\t\t\tfor(j = 0; j < MAX_V; j++)\n\t\t\t\tdd[i][j] = INF;\n\t\t}\n\t\tg.clear();\n\t\tmemset(gg, 0, sizeof(gg));\n\t\tcap *= 10;\n\t\tstring a, b;\n\t\tint k;\n\t\tV = 0;\n\t\tcin >> a >> b;\n\t\tma.clear();\n\t\tma[a] = V++;\n\t\tma[b] = V++;\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> a >> b >> k;\n\t\t\tif(ma.find(a) == ma.end())\n\t\t\t\tma[a] = V++;\n\t\t\tif(ma.find(b) == ma.end())\n\t\t\t\tma[b] = V++;\n\t\t\tif(k <= cap)\n\t\t\t{\n\t\t\t\tadd_edge1(ma[a], ma[b], k);\n\t\t\t}\n\t\t}\n\t\tg.push_back(0);\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tg.push_back(ma[a]);\n\t\t\tgg[ma[a]] = 1;\n\t\t}\n\t\tg.push_back(1);\n\t\tfloyd_warshall1();\n\t\tfor(i = 0; i < g.size(); i++)\n\t\t{\n\t\t\t//cout << g[i] << \":  \";\n\t\t\tfor(j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\tif(dd[g[i]][g[j]] <= cap)\n\t\t\t\t{\n\t\t\t\t\tadd_edge2(g[i], g[j], dd[g[i]][g[j]]);\n\t\t\t\t\t//cout << g[j] << \":\"<< dd[g[i]][g[j]] <<' ';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tadd_edge2(g[i], g[j] , INF);\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tfloyd_warshall2();\n//\t\tfor(i = 0; i < g.size(); i++)\n//\t\t\tcout << g[i] <<':' << d[g[i]] << ' ' ;\n//\t\tcout << endl;\n\t\tif(d[0][1] == INF)\n\t\t\td[0][1] = -1;\n\t\tprintf(\"%d\\n\", d[0][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nstring s1,s2;\nstruct Edge{\n    int v,val;\n    Edge(){}\n    Edge(int _v,int _val):v(_v),val(_val){}\n};\nvector<Edge>q[70300];\nvector<int>G;\nmap<string,int>mp;\n int d[7030];\nvoid spfa(int s){\n\n    bool vis[7030];\n    memset(vis,0,sizeof(vis));\n    memset(d,0x3f,sizeof(d));\n    d[s] = 0;\n    queue<int>que;\n    que.push(s);\n    vis[s] = false;\n    while(!que.empty()){\n        int u = que.front();\n        que.pop();\n        vis[u] = false;\n        for(int j = 0; j < q[u].size(); j++){\n            int v = q[u][j].v;\n            int val = q[u][j].val;\n            if(d[v] > d[u] + val){\n                d[v] = d[u] + val;\n                if(!vis[v]){\n                    que.push(v);\n                    vis[v] = true;\n                }\n            }\n        }\n    }\n}\nint dp[400][400];\nint main(){\n    int N,M,cap,ct = 0;\n    while(cin>>N>>M>>cap){\n        if(N == 0 && M == 0 && cap == 0) break;\n        for(int i = 0; i <= 6000; i++ ) q[i].clear();\n        mp.clear();\n        cin>>s1>>s2;\n        mp[s1] = ct++;\n        mp[s2] = ct++;\n        for(int i = 1; i <= N; i++){\n            int val;\n            cin>>s1>>s2>>val;\n            if(mp.find(s1) == mp.end()){\n                mp[s1] = ct++;\n            }\n            if(mp.find(s2) == mp.end()) mp[s2] = ct++;\n            int x = mp[s1],y = mp[s2];\n            q[x].push_back(Edge(y,val));\n            q[y].push_back(Edge(x,val));\n            //cout<<mp[s1]<<\" \"<<mp[s2]<<\" \"<<val<<endl;\n        }\n        G.clear();\n        G.push_back(0);\n        G.push_back(1);\n        for(int i = 1; i <= M; i++){\n            cin>>s1;\n            if(mp[s1] > 1)\n                G.push_back(mp[s1]);\n        }\n//        memset(dp,0x3f,sizeof(dp));\n//        for(int i = 0; i < G.size(); i++){\n//                int u = G[i];\n//                spfa(u);\n//                for(int j = 0; j  < G.size(); j++){\n//                    int tmp = G[j];\n//                    if(d[tmp]  <= cap * 10){\n//                        dp[i][j] = d[tmp];\n//                    }\n//                }\n//        }\n//        for(int k = 0; k < G.size(); k++)\n//            for(int i = 0; i < G.size(); i++)\n//                for(int j = 0; j < G.size(); j++){\n//                    dp[i][j] = min(dp[i][j] , dp[i][k] + dp[k][j]);\n//                }\n//        if(dp[0][1] == inf) dp[0][1] = -1;\n//        cout<<dp[0][1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\n#define pb push_back \n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\nusing namespace std;\ntypedef pair <int,int> P;\nint c;\nmap<string,int> city;\nvector<P> root[6000];\nbool sup[6000];\n\nstruct node{\n\tint cur,dis,cap;\n\tbool operator <(node a)const{\n    \treturn dis < a.dis;\n  \t}\n};\n\nint dijkstra(void){\n\tnode s;\n\ts.cur=0,s.dis=0,s.cap=c*10;\n\tpriority_queue<node> q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tnode cur;\n\t\tcur=q.top();q.pop();\n\t\tint state=cur.cur;\n\t//\tcout << cur.cur << \" \" << cur.dis <<\" \" << cur.cap << endl;\n\t\tif(cur.cap < 0||cur.cap >c*10)\n\t\t\tcontinue;\n\t\tif(state==1)\n\t\t\treturn cur.dis;\n\t\tfor(int i=0;i<root[state].size();i++){\n\t\t\tnode next;\n\t\t\tif(cur.cap>=root[state][i].second){\n\t\t\t\tnext.cur=root[state][i].first;\n\t\t\t\tnext.dis=cur.dis+root[state][i].second;\n\t\t\t\tif(sup[next.cur])\n\t\t\t\t\tnext.cap=c*10;\n\t\t\t\telse\n\t\t\t\t\tnext.cap-=root[state][i].second;\n\t\t\t\tq.push(next);\n\t\t\t\t//cout << next.cur << \" \" << next.dis <<\" \" << next.cap << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m >> c,n|m|c){\n\t\tcity.erase( city.begin(), city.end() );\n\t\tfor(int i=0;i<6000;i++){\n\t\t\troot[i].erase(root[i].begin(),root[i].end());\n\t\t\tsup[i]=false;\n\t\t}\n\t\tstring src,dest;\n\t\tint cnum=2;\n\t\tcin >> src >> dest;\n\t\tcity[src]=0;\n\t\tcity[dest]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring f,t;\n\t\t\tcin >> f >> t;\n\t\t\tif(city.find(f)==city.end())\n\t\t\t\tcity[f]=cnum++;\n\t\t\tif(city.find(t)==city.end())\n\t\t\t\tcity[t]=cnum++;\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\tP next;\n\t\t\tnext.first=city[t];next.second=d;\n\t\t\troot[city[f]].pb(next);\n\t\t\tnext.first=city[f];next.second=d;\n\t\t\troot[city[t]].pb(next);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tsup[city[s]]=true;\n\t\t}\n\t\tint ans=dijkstra();\n\t\tcout << ans << endl;\n\t\t//cout << root[0][0].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int N=6002,M=302;\nconst int INF=123456789;\n\nstruct edge{int to,cost;};\nvector<edge> G[N], g[M];\n\nint d[N];\nvoid dijkstra(int start)\n{\n    fill(d,d+N,INF);\n\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    d[start]=0;\n    que.push(pi(0,start));\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint solve()\n{\n    fill(d,d+M,INF);\n\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    d[0]=0;\n    que.push(pi(0,0));\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,g[v].size())\n        {\n            edge e=g[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n\n    return d[1];\n}\n\nvoid init()\n{\n    rep(i,N) G[i].clear();\n    rep(i,M) g[i].clear();\n}\n\nint main()\n{\n    int n,m,cap;\n    while(cin >>n >>m >>cap,n)\n    {\n        init();\n\n        string src,dest;\n        cin >>src >>dest;\n\n        map<string,int> name_to_id;\n        name_to_id[src]=0;\n        name_to_id[dest]=1;\n\n        int now=2;\n        rep(i,n)\n        {\n            string a,b;\n            int D;\n            cin >>a >>b >>D;\n\n            if(name_to_id.find(a) == name_to_id.end()) name_to_id[a]=now++;\n            if(name_to_id.find(b) == name_to_id.end()) name_to_id[b]=now++;\n\n            int A=name_to_id[a], B=name_to_id[b];\n            G[A].pb(edge{B,D});\n            G[B].pb(edge{A,D});\n        }\n\n        vector<string> st(m);\n        rep(i,m) cin >>st[i];\n\n        dijkstra(0);\n        rep(i,m)\n        {\n            int s=name_to_id[st[i]];\n            if(s<=1) continue;\n\n            if(d[s] <= cap*10) g[0].pb(edge{i+2,d[s]});\n\n        }\n        if(d[1] <= cap*10) g[0].pb(edge{1,d[1]});\n\n        rep(i,m)\n        {\n            int s=name_to_id[st[i]];\n            if(s<=1) continue;\n\n            dijkstra(s);\n            rep(j,m)\n            {\n                int t=name_to_id[st[j]];\n                if(t<=1) continue;\n\n                if(d[t] <= cap*10) g[i+2].pb(edge{j+2,d[t]});\n            }\n            if(d[1] <= cap*10) g[i+2].pb(edge{1,d[1]});\n        }\n\n        int ans=solve();\n        if(ans==INF) ans=-1;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define INF (1<<28)\n#define MAX_N 6005\n#define MAX_L 2005\n#define MAX_M 2005\n\nstruct state{\n  int pos,cost;\n  bool operator < ( const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint n,m,l,cnt;\nstring si,ti,str;\nvector<edge> G[MAX_N];\nbool flg[MAX_N];\nmap<string,int> change;\nint T[MAX_M][MAX_M];\nint d[MAX_N];\n\nint A[MAX_M];\nint B[MAX_M];\n\nvoid solve(int si){\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  priority_queue< state > Q;\n  d[si]=0;\n  Q.push((state){si,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(s.cost+e.cost<d[e.to]){\n        d[e.to]=s.cost+e.cost;\n        Q.push((state){e.to,d[e.to]});\n      }\n    }\n  }\n}\n\nvoid init(){\n  change.clear();\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    flg[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l;\n    if(n==0&&m==0&&l==0)break;\n    l*=10;\n    \n    cin>>si>>ti;\n    init();\n    cnt=1;\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int a=change[str];\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int b=change[str];\n      int c;\n      cin>>c;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    vector<int> vec;\n    for(int i=0;i<m;i++){\n      cin>>str;\n      flg[change[str]]=true;\n      vec.push_back(change[str]);\n    }\n\n    for(int i=0;i<m;i++){\n      solve(vec[i]);\n      for(int j=0;j<m;j++){\n        T[i][j]=d[vec[j]];\n      }\n    }\n\n    solve(change[si]);\n    for(int i=0;i<m;i++)A[i]=d[vec[i]];\n    solve(change[ti]);\n    for(int i=0;i<m;i++)B[i]=d[vec[i]];\n    \n    priority_queue< state > Q;\n    for(int i=0;i<m;i++){\n      d[i]=INF;\n      if(A[i]>l)continue;\n      d[i]=A[i];\n      Q.push((state){i,A[i]});\n    }\n\n    while(!Q.empty()){\n      state s=Q.top();Q.pop();\n      if(s.cost>d[s.pos])continue;\n      for(int i=0;i<m;i++){\n        if(T[s.pos][i]>l)continue;\n        if(s.cost+T[s.pos][i]<d[i]){\n          d[i]=s.cost+T[s.pos][i];\n          Q.push((state){i,d[i]});\n        }\n      }\n    }\n    \n    int ans=INF;\n    for(int i=0;i<m;i++){\n      if(B[i]>l)continue;\n      ans=min(ans,d[i]+B[i]);\n    }\n\n    if(ans==INF)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long ll;\n#define INF 1LL<<60\n\nint N, M, CAP;\nvector<pair<int, int> > E[6010];\nset<int> gas;\nmap<int, ll> dist;\nset<int> done;\n\nstruct Comp {\n\tbool operator() (pair<int,ll> a, pair<int,ll> b) {\n\t\treturn a.second > b.second;\n\t}\n};\n\nll solve()\n{\n\tpriority_queue<pair<int, ll>, vector<pair<int, ll> >, Comp> que;\n\n\tdist[CAP] = 0;\n\tque.push(make_pair(CAP, 0));\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top(); que.pop();\n\n\t\tint n = q.first / 10000;\n\t\tint c = q.first % 10000;\n\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn q.second;\n\t\t}\n\n\t\tif (done.find(q.first) != done.end()) continue;\n\t\tdone.insert(q.first);\n\n\t\tfor (auto p : E[n])\n\t\t{\n\t\t\tif (c < p.second) continue;\n\n\t\t\tint nn = p.first;\n\t\t\tint nc = c - p.second;\n\t\t\tif (gas.find(nn) != gas.end()) nc = CAP;\n\t\t\tint nnn = nn * 10000 + nc;\n\n\t\t\tll ncost = q.second + p.second;\n\t\t\tif (dist.find(nnn) == dist.end()) dist[nnn] = INF;\n\t\t\tif (ncost < dist[nnn])\n\t\t\t{\n\t\t\t\tdist[nnn] = ncost;\n\t\t\t\tque.push(make_pair(nnn, ncost));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M >> CAP)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tCAP *= 10;\n\n\t\tint idx = 0;\n\t\tmap<string, int> m;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tm[src] = 0; m[dest] = 1;\n\t\tidx = 2;\n\n\t\trep(i, 0, 6010) E[i].clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (m.find(a) == m.end()) m[a] = idx, idx++;\n\t\t\tif (m.find(b) == m.end()) m[b] = idx, idx++;\n\t\t\tint dd; cin >> dd;\n\t\t\tE[m[a]].push_back(make_pair(m[b], dd));\n\t\t\tE[m[b]].push_back(make_pair(m[a], dd));\n\t\t}\n\n\t\tgas.clear();\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (m.find(s) == m.end()) m[s] = idx, idx++;\n\t\t\tgas.insert(m[s]);\n\t\t}\n\n\t\tdist.clear();\n\t\tdone.clear();\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n \n#define MAX_V 6001\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n\n      if(nc>=0 && d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nshort n, m, k, p, dist[6007][2017], c[3000]; bool u[3000];\nvector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<short, short, short>, vector<tuple<short, short, short>>, greater<tuple<short, short, short>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, (int)dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<map>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nint tot;\nmap<string,int> mp;\nstring s,s1,s2;\nvector<int> station;\nconst int maxn = 10010;\nconst int maxm = 10010;\nconst int inf = 1000000000;\nbool vis[maxn];\nint que[maxn];\nint d[maxn],d2[maxn];\nbool use[maxn];\nint n,m,C;\nstruct EE\n{\n    int to,ne,w;\n}e[maxm * 2];\nint L,head[maxn];\nvoid adde(int u,int v,int w)\n{\n    //cout<<u<<' '<<v<<' '<<w<<endl;\n    e[L].to = v;\n    e[L].w = w;\n    e[L].ne = head[u];\n    head[u] = L++;\n}\nvoid spfa(int t)\n{\n    int l,r;\n    l = r = 0;\n    for (int i = 1; i <= tot; i++)\n        vis[i] = false;\n    que[r++] = t;\n    vis[t] = true;\n    while (l != r) {\n        int u = que[l++];\n        vis[u] = false;\n        l %= maxn;\n        for (int i = head[u]; i != -1; i = e[i].ne) {\n            int v = e[i].to;\n            if (d2[v] > d2[u] + e[i].w) {\n                d2[v] = d2[u] + e[i].w;\n                if (!vis[v]) {\n                    que[r++] = v;\n                    r %= maxn;\n                    vis[v] = true;\n                }\n            }\n        }\n    }\n}\nvoid work()\n{\n    for (int i = 1; i <= tot; i++) {\n        d2[i] = inf;\n    }\n    int t,tp;\n    tp = inf;\n    for (int j = 0; j < station.size(); j++)\n    if (!use[j] && d[station[j]] < tp) {\n        t = j;\n        tp = d[station[j]];\n    }\n    //cout<<d[station[0]]<<endl;\n    if (tp == inf) return;\n    //cout<<t<<endl;\n    use[t] = true;\n    t = station[t];\n    d2[t] = 0;\n    spfa(t);\n    //cout<<C<<endl;\n    //for (int j = 1; j <= tot; j++)\n    //   cout<<j<<' '<<d2[j]<<endl;\n    //cout<<t<<endl;\n    for (int j = 1; j <= tot; j++)\n    if (d2[j] <= C * 10)\n        d[j] = min(d[j],d2[j] + d[t]);\n}\nint main()\n{\n    while (scanf(\"%d%d%d\",&n,&m,&C) != EOF) {\n        if (n == 0 && m == 0) break;\n        L = 0;\n        memset(head,-1,sizeof(head));\n        mp.clear();\n        tot = 0;\n        cin>>s1>>s2;\n        mp[s1] = ++tot;\n        mp[s2] = ++tot;\n        for (int i = 0; i < n; i++) {\n            cin>>s1>>s2;\n            if (mp.find(s1) == mp.end()) {\n                mp[s1] = ++tot;\n            }\n            if (mp.find(s2) == mp.end()) {\n                mp[s2] = ++tot;\n            }\n            int d;\n            scanf(\"%d\",&d);\n            adde(mp[s1],mp[s2],d);\n            adde(mp[s2],mp[s1],d);\n        }\n        station.clear();\n        station.push_back(1);\n        for (int i = 0; i < m; i++) {\n            cin>>s1;\n            station.push_back(mp[s1]);\n        }\n        for (int i = 0; i <= tot; i++)\n            d[i] = inf;\n        d[1] = 0;\n        for (int i = 0; i < station.size(); i++)\n            use[i] = false;\n        for (int i = 0; i <= m; i++) {\n            work();\n        }\n        if (d[2] == inf)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",d[2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n};\n\nstruct aa {\n\tint now;\n\tint fuel;\n\tint cost;\n};\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.cost> r.cost;\n\t}\n};\n\n\nint main() {\n\t\n\twhile (1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif (!N)break;\n\t\tcap *= 10;\n\t\tstring st, fi; cin >> st >> fi;\n\t\tmap<string, int>mp;\n\t\tmp[st] = 0;\n\t\tmp[fi] = 1;\n\t\tint num = 2;\n\t\tvector<vector<edge>>edges(2*N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a, b; cin >> a >> b;\n\t\t\tif (mp.count(a)) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp.emplace(a, num);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tif (mp.count(b)) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp.emplace(b, num);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint co; cin >> co;\n\t\t\tedges[mp[a]].push_back(edge{ mp[a],mp[b],co });\n\t\t\tedges[mp[b]].push_back(edge{ mp[b],mp[a],co });\n\t\t}\n\t\tvector<bool>stands(mp.size(),false);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.count(st)) {\n\n\t\t\t\tstands[mp[st]] = true;\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,cap,0 });\n\t\tvector<vector<int>>memo(mp.size(), vector<int>(cap + 1,99999999));\n\t\tmemo[0][cap] = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tif (atop.now == 1)break;\n\t\t\tque.pop();\n\t\t\tfor (auto i : edges[atop.now]) {\n\t\t\t\tif (atop.fuel >= i.cost) {\n\t\t\t\t\tint nexfuel;\n\t\t\t\t\tif (stands[i.to]) {\n\t\t\t\t\t\tnexfuel = cap;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnexfuel = atop.fuel - i.cost;\n\t\t\t\t\t}\n\t\t\t\t\tif (memo[i.to][atop.fuel - i.cost]>atop.cost + i.cost) {\n\t\t\t\t\t\tque.push({ i.to,nexfuel,atop.cost + i.cost });\n\t\t\t\t\t\tmemo[i.to][nexfuel] = atop.cost + i.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amin = 99999999;\n\t\tfor (int i = 0; i <= cap; ++i) {\n\t\t\tamin = min(amin, memo[1][i]);\n\t\t}\n\t\tif (amin == 99999999) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << amin << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, cap;\nstring src, dest;\nint st, en;\nmap<string,int> ma;\nstring c[2][8000];\nint d[8000];\nint counter;\nvector<P> e[8000];\nvector<P> edge[8000];\nset<int> sta;\n\nvoid make_edge(){\n\trep(i,n){\n\t\tcin >> c[0][i] >> c[1][i] >> d[i];\n\t\tif(ma.count(c[0][i]) == 0){\n\t\t\tma[c[0][i]] = counter;\n\t\t\tcounter++;\n\t\t}\n\t\tif(ma.count(c[1][i]) == 0){\n\t\t\tma[c[1][i]] = counter;\n\t\t\tcounter++;\n\t\t}\n\t}\n\tst = ma[src]; en = ma[dest];\n\trep(i,n){\n\t\tint a = ma[c[0][i]], b = ma[c[1][i]];\n\t\te[a].push_back(P(b,d[i]));\n\t\te[b].push_back(P(a,d[i]));\n\t}\n}\n\nvoid dijkstra(int start){\n\tint dist[8000];\n\tPQ que;\n\trep(i,8000) dist[i] = INF;\n\tdist[start] = 0;\n\tque.push(P(0,start));\n\twhile(!que.empty()){\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dist[q.second]) continue;\n\t\trep(i,e[q.second].size()){\n\t\t\tP p = e[q.second][i];\n\t\t\tif(dist[p.first] > q.first+p.second && q.first+p.second <= cap*10){\n\t\t\t\tdist[p.first] = q.first+p.second;\n\t\t\t\tque.push(P(dist[p.first],p.first));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,counter){\n\t\tif(i == start) continue;\n\t\tif(sta.count(i) == 0) continue;\n\t\tif(dist[i] == INF) continue;\n\t\tedge[start].push_back(P(i,dist[i]));\n\t}\n}\n\nvoid dijkstra(){\n\tint dist[8000];\n\tPQ que;\n\trep(i,8000) dist[i] = INF;\n\tdist[st] = 0;\n\tque.push(P(0,st));\n\twhile(!que.empty()){\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dist[q.second]) continue;\n\t\trep(i,edge[q.second].size()){\n\t\t\tP p = edge[q.second][i];\n\t\t\tif(dist[p.first] > q.first+p.second){\n\t\t\t\tdist[p.first] = q.first+p.second;\n\t\t\t\tque.push(P(dist[p.first],p.first));\n\t\t\t}\n\t\t}\n\t}\n\tif(dist[en] == INF) dist[en] = -1;\n\tcout << dist[en] << endl;\n}\n\nvoid solve(){\n\tma.clear();\n\tcounter = 0;\n\trep(i,8000) e[i].clear();\n\trep(i,8000) edge[i].clear();\n\tsta.clear();\n\tcounter = 0;\n\tcin >> src >> dest;\n\tmake_edge();\n\trep(i,m){\n\t\tstring tmp; cin >> tmp;\n\t\tsta.insert(ma[tmp]);\n\t}\n\tsta.insert(st); sta.insert(en);\n\trep(i,counter){\n\t\tif(sta.count(i) == 0) continue;\n\t\tdijkstra(i);\n\t}\n\tdijkstra();\n}\n\nint main(){\n\twhile(cin >> n >> m >> cap){\n\t\tif(n == 0 && m == 0 && cap == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int ME = 3010;\nconst int MV = 6010;\nint fir[MV], rfir[MV];\nint n, m, cap, u[ME], v[ME], nex[ME], rnex[ME], w[ME];\nint dis[MV][2010];\nbool oil_sta[MV];\n\nstruct dot{\n\tint oil, p;\n}rear, front;\n\nint main () {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n//\t\tprintf(\"%d %d %d\\n\", n, m, cap);\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int>city;\n\t\tstring start, des;\n\t\tcin >> start >> des;\n\t\tcity[start] = 1; city[des] = 2;\n\t\tint d;\n\t\tstring x, y;\n\t\tint cou = 2;\n\t\tmemset(fir, -1, sizeof(fir));\n\t\tmemset(rfir, -1, sizeof(rfir));\n\t\t//int ee = 0;\n\t\tfor(int ee = 0; ee < n; ee++) {\n\t\t\tcin >> x >> y >> d;\n\t\t\tif(city[x] == 0) city[x] = ++cou;\n\t\t\tif(city[y] == 0) city[y] = ++cou;\n\t\t\t//if(d > cap * 10 ) continue; \n\t\t\tu[ee] = city[x];\n\t\t\tv[ee] = city[y];\n\t\t\tw[ee] = d;\n\t\t\tnex[ee] = fir[u[ee]]; fir[u[ee]] = ee;\n\t\t\trnex[ee] = rfir[v[ee]]; rfir[v[ee]] = ee;\n\t\t\t//ee++;\n\t\t}\n\t\tmemset(oil_sta, 0, sizeof(oil_sta));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin>>x;\n\t\t\tif(!city[x]) continue;\n\t\t\toil_sta[city[x]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap * 10;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint ok = 0;\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t//\tmemset(inq, 0, sizeof(inq));\n\t\tdis[1][cap*10] = 0;\n\t//\tinq[1][cap*10] = 1;\n\t\tint mmin = 0x3f3f3f3f;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t//\tinq[front.p][front.oil] = 0;\n\t\t\tif(front.p == 2 && !ok) { ok = 1; continue; }\n\t\t\tfor(int e = fir[front.p]; e != -1; e = nex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = v[e];\n\t\t\t\tif(oil_sta[v[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[v[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[v[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t//\t\tif(!inq[v[e]][rear.oil]){\n\t\t\t//\t\t\tinq[v[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t//\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int e = rfir[front.p]; e != -1; e = rnex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = u[e];\n\t\t\t\tif(oil_sta[u[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[u[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[u[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t//\tif(!inq[u[e]][rear.oil]){\n\t\t\t\t\t//\tinq[u[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t//\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tfor(int i = 0; i <= cap*10; i++) if(dis[2][i] < mmin) mmin = dis[2][i];\n\t\t\tprintf(\"%d\\n\", mmin);\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\ntypedef long long ll;\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\n\nstruct Task{\n    int prev,pos;Cost c;\n    Task(int prev,int pos,Cost c)\n        :prev(prev),pos(pos),c(c){};\n    bool operator>(const Task& r) const{ return c > r.c;}\n};\n\nvector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n    const int V=g.size();\n    vector<Cost> d(V,CINF);d[s]=0;\n    fill(ALL(prev), -2);\n    \n    priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));// [ ,e,,f, ] <=> e.cost < e.cost\n    vector<bool> visited(V);\n    while(!que.empty()){\n        Task task=que.top();que.pop();\n        if(visited[task.pos])continue;\n        visited[task.pos]=true;\n        prev[task.pos]=task.prev;\n        EACH(e,g[task.pos])if(d[e->t]>d[e->f]+e->c){\n            d[e->t]=d[e->f]+e->c;\n            que.push(Task(e->f,e->t,d[e->t]));\n        }   \n    }\n    return d;\n}\nvector<Cost> dijkstra(const Graph& g,const int s){\n    vector<int> prev(g.size());return dijkstra(g,s,prev);\n}\n\n\nint main() {\n\tcout <<fixed<<setprecision(15);\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tint N,M,cap;cin >> N >> M >> cap;if(N==0)break;\n\t\t\n\t\tmap<string,int> m;int S=0;\n\t\tint s;\n\t\t{\n\t\t\tstring src;cin >> src;\n\t\t\tif(!m.count(src))m[src]=s=S++;\n\t\t}\n\t\tint t;\n\t\t{\n\t\t\tstring dist;cin >> dist;\n\t\t\tif(!m.count(dist))m[dist]=t=S++;\t\t\t\n\t\t}\n\t\tvector<tuple<int,int,int>> es;\n\t\tREP(i,N){\n\t\t\tstring f,t;int c;cin >> f >> t >> c;\n\t\t\tif(!m.count(f))m[f]=S++;\n\t\t\tif(!m.count(t))m[t]=S++;\n\t\t\tes.emplace_back(m[f],m[t],c);\n\t\t}\n\t\tvector<int> ss;\n\t\tREP(i,M){\n\t\t\tstring s;cin >>s;\n\t\t\tif(!m.count(s))m[s]=S++;\n\t\t\tss.push_back(m[s]);\n\t\t}\n\t\tmap<int,int> stoi;int I=0;\n\t\tif(!stoi.count(s))stoi[s]=I++;\n\t\tif(!stoi.count(t))stoi[t]=I++;\n\t\tREP(i,M)if(!stoi.count(ss[i])){\n\t\t\tstoi[ss[i]]=I++;\n\t\t}\n\t\tmap<int,int> itoS;EACH(it,stoi)itoS[it->second]=it->first;\n\n\t\tGraph g(S);\n\t\tREP(i,N){\n\t\t\tcerr << es[i] <<endl;\n\t\t\tg[get<0>(es[i])].emplace_back(get<0>(es[i]),get<1>(es[i]),get<2>(es[i]));\n\t\t\tg[get<1>(es[i])].emplace_back(get<1>(es[i]),get<0>(es[i]),get<2>(es[i]));\n\t\t}\n\t\tGraph gc(I);\n\t\tREP(i,I){\n\t\t\tvector<Cost> cs=dijkstra(g,itoS[i]);\n\t\t\tREP(j,S)if(stoi.count(j)){\n\t\t\t\tint ji=stoi[j];\n\t\t\t\tif(cs[j]<=10*cap)gc[i].emplace_back(i,ji,cs[j]);\n\t\t\t}\n\t\t}\n\t\tvector<Cost> cs=dijkstra(gc,s);\n\n\t\tif(cs[t]>=CINF) cout << -1<<endl;\n\t\telse cout << cs[t]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tcap *= 10;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tmap<string, int> mp;\n\t\tmp[src] = mp.size() - 1;\n\t\tmp[dst] = mp.size() - 1;\n\t\tvector<vector<pair<int, int>>> g(6000);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring a, b;\n\t\t\tint c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!mp.count(a)) mp[a] = mp.size() - 1;\n\t\t\tif (!mp.count(b)) mp[b] = mp.size() - 1;\n\t\t\tg[mp[a]].emplace_back(mp[b], c);\n\t\t\tg[mp[b]].emplace_back(mp[a], c);\n\t\t}\n\t\tg.resize(mp.size());\n\t\tvector<bool> f(g.size(), false);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf[mp[s]] = true;\n\t\t}\n\t\tvector<vector<int>> dist(g.size(), vector<int>(cap * 10 + 1, 1 << 28));\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\t\tdist[0][cap] = 0;\n\t\tpq.push(make_tuple(0, 0, cap));\n\t\tint res = -1;\n\t\twhile (pq.size()){\n\t\t\tint s, v, r;\n\t\t\ttie(s, v, r) = pq.top(); pq.pop();\n\t\t\tif (v == mp[dst]){\n\t\t\t\tres = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dist[v][r] < s) continue;\n\t\t\tif (f[v]) r = cap;\n\t\t\tfor (pair<int, int> &e : g[v]){\n\t\t\t\tif (r < e.second) continue;\n\t\t\t\tif (dist[e.first][r - e.second] > s + e.second){\n\t\t\t\t\tdist[e.first][r - e.second] = s + e.second;\n\t\t\t\t\tpq.push(make_tuple(s + e.second, e.first, r - e.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nmap<string, int> city2num;\nset<int> LPG;\n\nvector<pair<int, int>> G[6010];\nint dist[6010][2010]; // dist[i][j] := ??????i?????§??????LPG???j??§??\\????????????????????¢\nusing tup = tuple<int, int, int>;\n\nvoid dijkstra(int start, int cap){\n\trep(i, 6010)rep(j, 2010) dist[i][j] = INF;\n\tcap *= 10;\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup> >  que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\twhile(!que.empty()){\n\t\tint cost, u, lpg;\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\t\tif(dist[u][lpg] < cost) continue;\n\t\tfor (auto& tmp : G[u]){\n\t\t\tint v = tmp.first, di = tmp.second;\n\t\t\tint nlpg = lpg - di;\n\t\t\tint ncost = cost + di;\n\t\t\tif(nlpg < 0) continue;\n\t\t\tif(LPG.count(v)) {\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tfor (int i = nlpg; i <= cap; ++i){\n\t\t\t\t\tif(dist[v][i] > ncost) {\n\t\t\t\t\t\tdist[v][i] = ncost;\n\t\t\t\t\t\tque.push(make_tuple(ncost, v, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstring c1[6010], c2[6010];\nint d[6010];\nstring s[6010];\nint main(void) {\n\twhile(1){\n\t\tcity2num.clear(); LPG.clear();\n\t\trep(i, 6010) G[i].clear();\n\n\t\tint N, M, cap; scanf(\"%d %d %d\", &N, &M, &cap);\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\t\tstring src, dest; cin >> src >> dest;\n\n\t\trep(i, N) cin >> c1[i] >> c2[i] >> d[i];\n\t\trep(i, M) cin >> s[i];\n\n\t\tset<string> city;\n\t\trep(i, N) city.insert(c1[i]), city.insert(c2[i]);\n\t\tint cnt = 0;\n\t\tfor(auto& u : city) {\n\t\t\tcity2num[u] = cnt++;\n\t\t}\n\t\trep(i, M) LPG.insert(city2num[s[i]]);\n\n\t\trep(i, N) G[city2num[c1[i]]].pb(mp(city2num[c2[i]], d[i])), G[city2num[c2[i]]].pb(mp(city2num[c1[i]], d[i]));\n\t\tint ns = city2num[src], nd = city2num[dest];\n\t\tdijkstra(ns, cap);\n\t\tll ans = INF;\n\t\trep(i, cap + 1) chmin(ans, dist[nd][i]);\n\t\tif(ans != INF)printf(\"%lld\\n\", ans);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n    while(1){\n        int n,m,cap;\n        cin >> n >> m >> cap;\n        cap *= 10;\n        if(n==0) break;\n\n        string src, dest;\n        cin >> src >> dest;\n        vector<int> c1(n), c2(n), d(n);\n        map<string, int> city;\n        city[src] = 0;\n        city[dest] = 1;\n        int count = 2;\n        for(int i=0; i<n; i++){\n            string s1,s2;\n            cin >> s1 >> s2 >> d[i];\n            if(city.count(s1)==0){\n                city[s1] = count;\n                count++;\n            }\n            if(city.count(s2)==0){\n                city[s2] = count;\n                count++;\n            }\n            c1[i] = city[s1];\n            c2[i] = city[s2];\n        }\n\n        vector<vector<pair<int, int> > > adj(count);\n        for(int i=0; i<n; i++){\n            adj[c1[i]].push_back(make_pair(c2[i], d[i]));\n            adj[c2[i]].push_back(make_pair(c1[i], d[i]));\n        }\n        vector<bool> sta(count, false);\n        for(int i=0; i<m; i++){\n            string s;\n            cin >> s;\n            sta[city[s]] = true;\n        }\n\n        priority_queue<pair<int, pair<int, int> > > wait;\n        wait.push(make_pair(0, make_pair(0, cap)));\n        vector<vector<int> > mindist(count, vector<int>(cap+1, inf));\n        mindist[0][cap] = 0;\n        int ans = -1;\n        while(!wait.empty()){\n            int dist = -wait.top().first;\n            int pos = wait.top().second.first;\n            int gas = wait.top().second.second;\n            wait.pop();\n            if(dist > mindist[pos][gas]) continue;\n            if(pos == 1){\n                ans = dist;\n                break;\n            }\n            for(int i=0; i<(int)adj[pos].size(); i++){\n                int ndist = adj[pos][i].second;\n                int npos = adj[pos][i].first;\n                int ngas = (sta[npos])? cap: gas-ndist;\n                if(gas >= ndist && dist+ndist < mindist[npos][ngas]){\n                    wait.push(make_pair(-(dist+ndist), make_pair(npos, ngas)));\n                    mindist[npos][ngas] = dist+ndist;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int ME = 3010;\nconst int MV = 6010;\nint fir[MV], rfir[MV];\nint n, m, cap, u[ME], v[ME], nex[ME], rnex[ME], w[ME];\nint dis[MV][2010];\nbool inq[MV][2010], oil_sta[MV];\n\nstruct dot{\n\tint oil, p;\n}rear, front;\n\nint main () {\n\tfreopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tprintf(\"%d %d %d\\n\", n, m, cap);\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int>city;\n\t\tstring start, des;\n\t\tcin >> start >> des;\n\t\tcity[start] = 1; city[des] = 2;\n\t\tint d;\n\t\tstring x, y;\n\t\tint cou = 2;\n\t\tmemset(fir, -1, sizeof(fir));\n\t\tmemset(rfir, -1, sizeof(rfir));\n\t\t//int ee = 0;\n\t\tfor(int ee = 0; ee < n; ee++) {\n\t\t\tcin >> x >> y >> d;\n\t\t\tif(city[x] == 0) city[x] = ++cou;\n\t\t\tif(city[y] == 0) city[y] = ++cou;\n\t\t\t//if(d > cap * 10 ) continue; \n\t\t\tu[ee] = city[x];\n\t\t\tv[ee] = city[y];\n\t\t\tw[ee] = d;\n\t\t\tnex[ee] = fir[u[ee]]; fir[u[ee]] = ee;\n\t\t\trnex[ee] = rfir[v[ee]]; rfir[v[ee]] = ee;\n\t\t\t//ee++;\n\t\t}\n\t\tmemset(oil_sta, 0, sizeof(oil_sta));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin>>x;\n\t\t\tif(!city[x]) continue;\n\t\t\toil_sta[city[x]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap * 10;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint ok = 0;\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tdis[1][cap*10] = 0;\n\t\tinq[1][cap*10] = 1;\n\t\tint mmin = 0x3f3f3f3f;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = 0;\n\t\t\tif(front.p == 2 && !ok) { ok = 1; continue; }\n\t\t\tfor(int e = fir[front.p]; e != -1; e = nex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = v[e];\n\t\t\t\tif(oil_sta[v[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[v[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[v[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[v[e]][rear.oil]){\n\t\t\t\t\t\tinq[v[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int e = rfir[front.p]; e != -1; e = rnex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = u[e];\n\t\t\t\tif(oil_sta[u[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[u[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[u[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[u[e]][rear.oil]){\n\t\t\t\t\t\tinq[u[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tfor(int i = 0; i <= cap*10; i++) if(dis[2][i] < mmin) mmin = dis[2][i];\n\t\t\tprintf(\"%d\\n\", mmin);\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,d[MAX_V][2001],cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\n map<string,int>vnum;\n \n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d[0], d[MAX_V], INF);\n\t\n\tfor(int i=0;i<=cap*10;i++)d[s][i]=0;\n  d[s][cap*10] = 0;\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n  \t\n    if(d[v][p.s.s] < p.first)continue;\n\n  \td[v][p.s.s]=p.f;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\td[v][p.s.s]=p.f;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n    \tif(nc<0)continue;\n      if(d[e.to][nc]==INF || d[e.to][nc] > d[v][p.s.s]+e.cost){\n   \t\t d[e.to][nc] = d[v][p.s.s]+e.cost;\n   \t\t que.push(P3(d[e.to][nc], P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n    \tif(vnum.count(name))\n      \t\tst.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int ME = 3010;\nconst int MV = 6010;\nint fir[MV], rfir[MV];\nint n, m, cap, u[ME], v[ME], nex[ME], rnex[ME], w[ME];\nint dis[MV][2010];\nbool inq[MV][2010], oil_sta[MV];\n\nstruct dot{\n\tint oil, p;\n}rear, front;\n\nint main () {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n//\t\tprintf(\"%d %d %d\\n\", n, m, cap);\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int>city;\n\t\tstring start, des;\n\t\tcin >> start >> des;\n\t\tcity[start] = 1; city[des] = 2;\n\t\tint d;\n\t\tstring x, y;\n\t\tint cou = 2;\n\t\tmemset(fir, -1, sizeof(fir));\n\t\tmemset(rfir, -1, sizeof(rfir));\n\t\t//int ee = 0;\n\t\tfor(int ee = 0; ee < n; ee++) {\n\t\t\tcin >> x >> y >> d;\n\t\t\tif(city[x] == 0) city[x] = ++cou;\n\t\t\tif(city[y] == 0) city[y] = ++cou;\n\t\t\t//if(d > cap * 10 ) continue; \n\t\t\tu[ee] = city[x];\n\t\t\tv[ee] = city[y];\n\t\t\tw[ee] = d;\n\t\t\tnex[ee] = fir[u[ee]]; fir[u[ee]] = ee;\n\t\t\trnex[ee] = rfir[v[ee]]; rfir[v[ee]] = ee;\n\t\t\t//ee++;\n\t\t}\n\t\tmemset(oil_sta, 0, sizeof(oil_sta));\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin>>x;\n\t\t\tif(!city[x]) continue;\n\t\t\toil_sta[city[x]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap * 10;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint ok = 0;\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tmemset(inq, 0, sizeof(inq));\n\t\tdis[1][cap*10] = 0;\n\t\tinq[1][cap*10] = 1;\n\t\tint mmin = 0x3f3f3f3f;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t\tinq[front.p][front.oil] = 0;\n\t\t\tif(front.p == 2 && !ok) { ok = 1; continue; }\n\t\t\tfor(int e = fir[front.p]; e != -1; e = nex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = v[e];\n\t\t\t\tif(oil_sta[v[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[v[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[v[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[v[e]][rear.oil]){\n\t\t\t\t\t\tinq[v[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int e = rfir[front.p]; e != -1; e = rnex[e]){\n\t\t\t\tif(front.oil < w[e]) continue;\n\t\t\t\trear.oil = front.oil - w[e];\n\t\t\t\trear.p = u[e];\n\t\t\t\tif(oil_sta[u[e]]) rear.oil = cap * 10;\n\t\t\t\tif(dis[u[e]][rear.oil] > dis[front.p][front.oil] + w[e]){\n\t\t\t\t\tdis[u[e]][rear.oil] = dis[front.p][front.oil] + w[e];\n\t\t\t\t\tif(!inq[u[e]][rear.oil]){\n\t\t\t\t\t\tinq[u[e]][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tfor(int i = 0; i <= cap*10; i++) if(dis[2][i] < mmin) mmin = dis[2][i];\n\t\t\tprintf(\"%d\\n\", mmin);\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint N, M, cap;\n\nusing Graph = vector< vector< pair<int, int> > >;\n\nconst int INF = 1 << 29;\nint dist[6010][2010];\n\nstruct Elem {\n    int pos, tot, cost;\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n\n\nint solve(Graph &G, vector<int>& is_station, int S, int T) {\n    fill(dist[0], dist[6010], INF);\n    dist[S][0] = 0;\n\n    priority_queue<Elem> que;\n    que.push(Elem{S, 0, 0});\n\n    while(que.size()) {\n        Elem cur = que.top(); que.pop();\n\n        int u = cur.pos, pre_tot = cur.tot, pre_cost = cur.cost;\n        if(dist[u][pre_tot] < pre_cost) continue;\n\n        for(auto e : G[u]) {\n            int v = e.first, cost = e.second;\n\n            int nxt_cost = pre_cost + cost;\n            int nxt_tot  = pre_tot  + cost;\n            if(nxt_tot > cap) continue;\n            if(is_station[v]) nxt_tot = 0;\n\n            if(dist[v][nxt_tot] > nxt_cost) {\n                dist[v][nxt_tot] = nxt_cost;\n                que.push(Elem{v, nxt_tot, nxt_cost});\n            }\n        }\n    }\n\n    int ret = *min_element(dist[T], dist[T] + cap + 1);\n    return (ret == INF ? -1 : ret);\n}\n\nint main() {\n    while(cin >> N >> M >> cap, N) {\n        cap *= 10;\n        string st, gl; cin >> st >> gl;\n\n        vector<string> u(N), v(N);\n        vector<int> d(N);\n\n        map<string, int> to_int_id;\n        for(int i=0; i<N; i++) {\n            cin >> u[i] >> v[i] >> d[i];\n            to_int_id[ u[i] ]++;\n            to_int_id[ v[i] ]++;\n        }\n\n        int id = 0;\n        for(auto &e : to_int_id) {\n            e.second = id++;\n        }\n\n        Graph G(id);\n        for(int i=0; i<N; i++) {\n            int x = to_int_id[ u[i] ];\n            int y = to_int_id[ v[i] ];\n            G[x].push_back(make_pair(y, d[i]));\n            G[y].push_back(make_pair(x, d[i]));\n        }\n\n        vector<int> is_station(id);\n        for(int i=0; i<M; i++) {\n            string s; cin >> s;\n            int s_id = to_int_id[s];\n\n            is_station[s_id] = true;\n        }\n\n        int start_v = to_int_id[st];\n        int goal_v  = to_int_id[gl];\n        cout << solve(G, is_station, start_v, goal_v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tset<string> cities;\n\t\tvector<vs> data(N, vs(3)); \n\t\tREP(i, N) {\n\t\t\tREP(j, 2) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tcities.insert(data[i][j]);\n\t\t\t}\n\t\t\tcin >> data[i][2];\n\t\t}\n\n\t\tmap<string, int> index;\n\t\tset<string>::iterator it = cities.begin();\n\t\tint size = 0;\n\t\twhile(it != cities.end()) {\n\t\t\tindex[*it] = size;\n\t\t\tsize++;\n\t\t\tit++;\n\t\t}\n\n\t\tvvi dist(size, vi(size, INF));\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvi cost(size, vi(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d][ng]) {\n\t\t\t\t\t\tcost[d][ng] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n \n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n \n#define MAX_V 8000\n#define INF 100000000\n \nusing namespace std;\n \nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n \nint V,cap;\nstring dest;\nvector<edge>G[MAX_V];\nset<int>st;\nmap<string,int>vnum;\nbool vis[MAX_V][2001];\n \nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(vis[0], vis[MAX_V], false);\n\t\n  que.push(P3(0, P(s,cap*10)));\n \n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n\n    if(vis[v][p.s.s])continue;\n\n  \tvis[v][p.s.s]=true;\n  \t\n  \tif(v==vnum[dest]){\n  \t\tcout << p.f << endl;\n  \t\treturn ;\n  \t}\n  \t\n  \tif(st.find(v)!=st.end()){\t\n  \t\tp.s.s=cap*10;\n  \t\tvis[v][p.s.s]=true;\n  \t}\n  \t\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      int nc=p.s.s-e.cost;\n      if(nc>=0 && !vis[e.to][nc]){\n   \t\t que.push(P3(p.f+e.cost, P(e.to,nc)));\n      }\n    }\n  }\n\tcout << -1 << endl;\n}\n \nint main(void){\n \n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n \n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n  \tvnum.clear();\n  \t\n    cin >> src >> dest;\n     \n    node.pb(src);\n    node.pb(dest);\n \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n \n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n \n \n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n     \n    for(int i=0;i<V;i++)G[i].clear();    \n \n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n \n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n \n \n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      if(vnum.count(name))\n      \t st.insert(vnum[name]);\n    }\n \n    dijkstra(vnum[src]);\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[3010];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    reach[mp[dest]] = reach.size();\n    vector<bool> visit(mp.size(), false);\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (visit[now]) continue;\n      if (reach.count(now) == 0) reach[now] = reach.size();\n      visit[now] = true;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) adj[i].clear();\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    mp.clear();\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<vector<bool>> visit2(reach.size(), vector<bool>(cap + 1, false));\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and\n             visit2[now = hp.top().second][now_cap = hp.top().first.second])\n        hp.pop();\n      if (now == -1 or visit2[now][now_cap]) break;\n      visit2[now][now_cap] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n    for (int i = 0; i < (int)reach.size(); ++i) adj2[i].clear();\n\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[301];\nint nodes[6001][6001];\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P, string> sP;\n\nvoid solve(int N, int M, int C) {\n    string start, goal;\n    cin >> start >> goal;\n    map<string,map<string, int>> m;\n    for (int i = 0; i < N; i++) {\n        string s, t;\n        cin >> s >> t;\n        int d;\n        cin >> d;\n        m[s][t] = d;\n        m[t][s] = d;\n    }\n\n    vector<string> store(M);\n    for (auto& i : store) cin >> i;\n    \n\n    map<string,map<int,int>> dp;\n    dp[start][C*10] = 0;\n\n    priority_queue<sP, vector<sP>, greater<sP>> que;\n    que.push(sP(P(0, C*10), start));\n\n    while (que.size() > 0) {\n        auto sp = que.top(); que.pop();\n        string now = sp.second;\n        int cost = sp.first.first;\n        int cap = sp.first.second;\n\n        if (dp.find(now) != dp.end()\n            && dp[now].find(cap) != dp[now].end()\n            && dp[now][cap] < cost) continue;\n\n        for (auto city : m[now]) {\n            string next = city.first;\n            int dist = city.second;\n            int _cap = cap - dist;\n\n            if (_cap < 0) continue;\n            if (find(store.begin(), store.end(), next) != store.end()) _cap = C * 10;\n            \n            if (dp.find(next) == dp.end() || dp[next].find(_cap) == dp[next].end()) {\n                dp[next][_cap] = cost + dist;\n                que.push(sP(P(cost + dist, _cap), next));\n            } else if (dp[next][_cap] > cost + dist) {\n                dp[next][_cap] = cost + dist;\n                que.push(sP(P(cost + dist, _cap), next));\n            }\n        }\n    }\n\n    if (dp.find(goal) == dp.end()) cout << -1 << endl;\n    else {\n        int ans = 1 << 28;\n        for (auto i : dp[goal]) ans = min(ans, i.second);\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    int N, M, C;\n    while (cin >> N >> M >> C, N || M || C) solve(N, M, C);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n};\nstruct state {\n\tint pos, cost, c;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint N, M, T, s, g, cap, a[3009]; string s1, s2, s3[3009], s4[3009];\nint main() {\n\twhile (cin >> M >> T >> cap, M) {\n\t\tvector<string> l;\n\t\tcin >> s1 >> s2;\n\t\tl.push_back(s1);\n\t\tl.push_back(s2);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> s3[i] >> s4[i] >> a[i];\n\t\t\tl.push_back(s3[i]);\n\t\t\tl.push_back(s4[i]);\n\t\t}\n\t\tsort(l.begin(), l.end());\n\t\tl.erase(unique(l.begin(), l.end()), l.end());\n\t\tN = l.size();\n\t\ts = lower_bound(l.begin(), l.end(), s1) - l.begin();\n\t\tg = lower_bound(l.begin(), l.end(), s2) - l.begin();\n\t\tvector<vector<edge> > G(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint p1 = lower_bound(l.begin(), l.end(), s3[i]) - l.begin();\n\t\t\tint p2 = lower_bound(l.begin(), l.end(), s4[i]) - l.begin();\n\t\t\tG[p1].push_back(edge{ p2, a[i] });\n\t\t\tG[p2].push_back(edge{ p1, a[i] });\n\t\t}\n\t\tvector<bool> isok(N);\n\t\tfor (int i = 0; i < T; i++) {\n\t\t\tcin >> s1;\n\t\t\tisok[lower_bound(l.begin(), l.end(), s1) - l.begin()] = true;\n\t\t}\n\t\tcap *= 10;\n\t\tvector<vector<int> > dist(N, vector<int>(cap + 1, 999999999)); dist[s][cap] = 0;\n\t\tpriority_queue<state> que; que.push(state{ s, 0, cap });\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (edge e : G[u.pos]) {\n\t\t\t\tint f = u.c - e.cost;\n\t\t\t\tif (f < 0) continue;\n\t\t\t\tif (isok[e.to]) f = cap;\n\t\t\t\tif (dist[e.to][f] > dist[u.pos][u.c] + e.cost) {\n\t\t\t\t\tdist[e.to][f] = dist[u.pos][u.c] + e.cost;\n\t\t\t\t\tque.push(state{ e.to, -dist[e.to][f], f });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(dist[g].begin(), dist[g].end());\n\t\tcout << (ret == 999999999 ? -1 : ret) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tint size = 0;\n\t\tvector<vs> data(N, vs(3)); \n\t\tmap<string, int> index;\n\t\t{\n\t\t\tset<string> cities;\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, 2) {\n\t\t\t\t\tcin >> data[i][j];\n\t\t\t\t\tcities.insert(data[i][j]);\n\t\t\t\t}\n\t\t\t\tcin >> data[i][2];\n\t\t\t}\n\n\t\t\tset<string>::iterator it = cities.begin();\n\t\t\twhile(it != cities.end()) {\n\t\t\t\tindex[*it] = size;\n\t\t\t\tsize++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<pii> > dist(size);\n\t\tREP(i, N) {\n\t\t\tint c1 = index[data[i][0]];\n\t\t\tint c2 = index[data[i][1]];\n\t\t\tint cost = toInt(data[i][2]);\n\n\t\t\tdist[c1].push_back(make_pair(c2, cost));\n\t\t\tdist[c2].push_back(make_pair(c1, cost));\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvvi cost(size, vi(cap*10+1, INF));\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]][cap*10] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, dist[st.p].size()) {\n\t\t\t\tint np = dist[st.p][d].first;\n\t\t\t\tint nc = st.c + dist[st.p][d].second;\n\t\t\t\tint ng = st.g - dist[st.p][d].second;\n\n\t\t\t\tif(ng < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(gas[np]) {\n\t\t\t\t\tng = cap*10;\n\t\t\t\t}\n\n\t\t\t\tif(nc < cost[np][ng]) {\n\t\t\t\t\tcost[np][ng] = nc;\n\t\t\t\t\tQ.push(state(np, nc, ng));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct NODE{\n\tint src,dst,cap,weight;\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.weight > b.weight;\n}\nmap<string,int> dic;\nint get(string s){\n\tif( dic.count(s) ) return dic[s];\n\tint k = dic.size();\n\treturn dic[s] = k;\n}\n\nint main(){\n\tint n,m,cap;\n\twhile( cin >> n >> m >> cap&& n ){\n\t\tvector<NODE> g[6010];\n\t\tint LPG[6010] = {};\n\t\tdic.clear();\n\t\tstring s_,g_;\n\t\tcin >> s_ >> g_;\n\t\tint s = get(s_);\n\t\tint gg = get(g_);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a_,b_;\n\t\t\tcin >> a_ >> b_;\n\t\t\tint a = get(a_);\n\t\t\tint b = get(b_);\n\t\t\tint c; cin >> c;\n\t\t\tg[a].push_back({a,b,0,c});\n\t\t\tg[b].push_back({b,a,0,c});\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring x_; cin >> x_;\n\t\t\tint x = get(x_);\n\t\t\tLPG[x] = true;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\tset< pair<int,int> > done;\n\t\tQ.push({s,-114514,cap*10,0});\n\t\twhile( Q.size() ){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.cap < 0 ) continue;\n\t\t\tif( q.src == gg ){\n\t\t\t\tcout << q.weight << endl;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t\tif( done.count(make_pair(q.src,q.cap)) ) continue;\n\t\t\telse done.insert(make_pair(q.src,q.cap));\n\t\t\tif( LPG[q.src] ){\n\t\t\t\tQ.push({q.src,-114514,cap*10,q.weight});\n\t\t\t}\n\t\t\tfor( auto e : g[q.src] ){\n\t\t\t\tQ.push({e.dst,-114514,q.cap-e.weight,q.weight+e.weight});\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tok:;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INF 1000000000000LL\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nlong long dis[6100];\nvector<P> g[6100];\nlong long g2[310][310];\nmap<string,int> id;\nvector<int> gas;\nint n,m,cap,d;\nstring a,b;\n\nint main(){\n  while(scanf(\"%d%d%d\",&n,&m,&cap)!=EOF,n||m||cap){\n    id.clear(); gas.clear();\n    for(int i=0;i<6100;i++)g[i].clear();\n    \n    cin >> a >> b;\n    id[a] = id.size(); id[b] = id.size();\n    gas.push_back(1); gas.push_back(2);\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b >> d;\n      if(id.find(a) == id.end())id[a] = id.size();\n      if(id.find(b) == id.end())id[b] = id.size();\n      g[id[a]].push_back(P(d,id[b]));\n      g[id[b]].push_back(P(d,id[a]));\n    }\n    for(int i=0;i<m;i++){\n      cin >> a;\n      gas.push_back(id[a]);\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<gas.size();j++)g2[i][j] = INF;\n      g2[i][i] = 0;\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<=id.size();j++)dis[j] = INF;\n      dis[gas[i]] = 0;\n      priority_queue<P,vector<P>,greater<P> > q;\n      q.push(P(0,gas[i]));\n      \n      while(q.size()){\n\tP p = q.top();q.pop();\n\tlong long dist = p.first;\n\tint pos = p.second;\n\t\n\tfor(int x=0;x<g[pos].size();x++){\n\t  int tdis = dist + g[pos][x].first;\n\t  int nxt = g[pos][x].second;\n\t  if(dis[nxt] > tdis){\n\t    dis[nxt] = tdis;\n\t    q.push(P(tdis,nxt));\n\t  }\n\t}\n      }\n      for(int j=0;j<gas.size();j++){\n\tif(cap*10<dis[gas[j]])continue;\n\tg2[i][j] = dis[gas[j]];\t\n      }\n    }\n\n    for(int k=0;k<gas.size();k++)\n      for(int i=0;i<gas.size();i++)\n\tfor(int j=0;j<gas.size();j++)\n\t  g2[i][j] = min(g2[i][j],g2[i][k] + g2[k][j]);\n\n    if(g2[0][1] == INF)cout << -1 << endl;\n    else cout << g2[0][1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    author:  gantheory\n *    created: 2018-07-19 23:18:57\n */\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6000 + 10;\n\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\nint n, m, cap;\nstring src, dest;\nvector<pair<int, int>> adj[N], adj2[N];\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.setf(ios::fixed), cout.precision(9);\n  while (cin >> n >> m >> cap) {\n    if (n + m + cap == 0) break;\n\n    for (int i = 0; i < N; ++i) adj[i].clear(), adj2[i].clear();\n\n    cap *= 10;\n    cin >> src >> dest;\n    map<string, int> mp;\n    mp[src] = mp.size(), mp[dest] = mp.size();\n    for (int i = 0; i < n; ++i) {\n      string foo, bar;\n      int c;\n      cin >> foo >> bar >> c;\n      int u = (mp.count(foo) ? mp[foo] : mp[foo] = mp.size());\n      int v = (mp.count(bar) ? mp[bar] : mp[bar] = mp.size());\n      adj[u].emplace_back(v, c), adj[v].emplace_back(u, c);\n    }\n    vector<string> cand = {src, dest};\n    for (int i = 0; i < m; ++i) {\n      string s;\n      cin >> s;\n      cand.push_back(s);\n    }\n\n    map<int, int> reach;\n    reach[mp[dest]] = reach.size();\n    vector<bool> visit(mp.size(), false);\n    queue<int> q;\n    q.push(mp[src]);\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      if (visit[now]) continue;\n      if (reach.count(now) == 0) reach[now] = reach.size();\n      visit[now] = true;\n      for (auto& p : adj[now]) q.push(p.first);\n    }\n    for (int i = 0; i < (int)mp.size(); ++i) {\n      if (reach.count(i) == 0) continue;\n      for (auto& p : adj[i])\n        adj2[reach[i]].emplace_back(reach[p.first], p.second);\n    }\n    set<int> good;\n    for (string& s : cand)\n      if (mp.count(s) and reach.count(mp[s])) good.insert(reach[mp[s]]);\n\n    int s = reach[mp[src]], t = reach[mp[dest]];\n    vector<vector<int>> d(reach.size(), vector<int>(cap + 1, INT_MAX));\n    vector<vector<bool>> visit2(reach.size(), vector<bool>(cap + 1, false));\n    d[s][cap] = 0;\n    MinHeap<pair<pair<int, int>, int>> hp;\n    hp.push({{0, cap}, s});\n    while (1) {\n      int now = -1, now_cap = -1;\n      while (!hp.empty() and\n             visit2[now = hp.top().second][now_cap = hp.top().first.second])\n        hp.pop();\n      if (now == -1 or visit2[now][now_cap]) break;\n      visit2[now][now_cap] = true;\n      for (auto& p : adj2[now]) {\n        int child = p.first, w = p.second;\n        if (now_cap - w >= 0) {\n          int nxt_cap = (good.count(child) ? cap : now_cap - w);\n          if (d[now][now_cap] + w < d[child][nxt_cap]) {\n            d[child][nxt_cap] = d[now][now_cap] + w;\n            hp.push({{d[child][nxt_cap], nxt_cap}, child});\n          }\n        }\n      }\n    }\n    cout << (d[t][cap] == INT_MAX ? -1 : d[t][cap]) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <queue>\ntypedef long long ll;\n\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nstruct Edge {\n    int src, dst;\n    int weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n    Edge() {}\n};\n\nusing Graph = vector<vector<Edge>>;\n\nint V, E;\nint num_stand; // num of stands\nstring src, dst;\nint cap;\nGraph g;\n\nvector<string> c1, c2;\nvector<int> d;\nvector<string> s;\n\nmap<string, int> m;\n\nconst int inf = 1e9;\n\nint dist[310][2100]; // at town i with gas j\nint canCharge[310];\n\nint dijkstra(int s, int t) {\n    fill((int*)begin(dist), (int*)end(dist), inf);\n    priority_queue<tuple<int,int, int>> q;// -dist, town, cap\n    \n    dist[s][cap] = 0;\n    q.emplace(0, s, cap);\n\n    while (q.size()) {\n        int d, v, rem;\n        tie(d, v,rem) = q.top();\n        q.pop();\n        d = -d;\n\n        if (v == t) return d;\n\n        if (dist[v][rem] < d) continue;\n        for (auto &e : g[v]) {\n            int nv = e.dst;\n            int nrem = rem - e.weight;\n            if (nrem < 0) continue;\n            if (canCharge[nv]) {\n                nrem = cap;\n            }\n            int nd = d + e.weight;\n            if (dist[nv][nrem] > nd) {\n                dist[nv][nrem] = nd;\n                q.emplace(-nd, nv, nrem);\n            }\n        }\n    }\n\n    return 1e9;\n}\n\nint main() {\n    while (cin >> E >> num_stand >> cap && E) {\n        m.clear();\n        V = 0;\n        c1.resize(E);\n        c2.resize(E);\n        d.resize(E);\n        cap *= 10;\n        cin >> src >> dst;\n        if (m.count(src) == 0) m[src] = V++;\n        if (m.count(dst) == 0) m[dst] = V++;\n\n        for (int i = 0; i < E; ++i) {\n            cin >> c1[i] >> c2[i] >> d[i];\n            if (m.count(c1[i]) == 0) m[c1[i]] = V++;\n            if (m.count(c2[i]) == 0) m[c2[i]] = V++;\n        }\n\n        memset(canCharge, 0, sizeof(canCharge));\n        s.resize(num_stand);\n        for (int i = 0; i < num_stand; ++i) {\n            cin >> s[i];\n            canCharge[m[s[i]]] = true;\n        }\n\n        g.assign(V, {});\n        for (int i = 0; i < E; ++i) {\n            int a = m[c1[i]];\n            int b = m[c2[i]];\n            g[a].emplace_back(a, b, d[i]);\n            g[b].emplace_back(b, a, d[i]);\n        }\n\n        int ans = dijkstra(m[src], m[dst]);\n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    vector<string>v,from,to;\n    vector<int>cost;\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  double gas;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n  Edge(int src, int dst, Weight weight, double gas) :\n    src(src), dst(dst), weight(weight), gas(gas) { }\n\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint main() {\n  int n, m, cap;\n  while(cin>>n>>m>>cap,n||m||cap) {\n    map<string, int> id;\n    int idnum = 0;\n    string src,dst;\n    cin >> src >> dst;\n    id[src] = idnum++;\n    id[dst] = idnum++;\n    string a[n], b[n];\n    int c[n];\n    REP(i, n) {\n      cin>>a[i]>>b[i]>>c[i];\n      if (id.count(a[i])==0) id[a[i]] = idnum++;\n      if (id.count(b[i])==0) id[b[i]] = idnum++;\n    }\n    Graph g(idnum);\n    REP(i, n) {\n      g[id[a[i]]].push_back(Edge(id[a[i]], id[b[i]], c[i]));\n      g[id[b[i]]].push_back(Edge(id[b[i]], id[a[i]], c[i]));\n    }\n    set<int> station;\n    REP(i, m) {\n      string tmp;\n      cin >> tmp;\n      station.insert(id[tmp]);\n    }\n\n    cap *= 10;\n    vector<vector<Weight> > dist(g.size(), vector<Weight>(cap+1, INF));\n    dist[id[src]][cap] = 0;\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, id[src], 0, cap)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (dist[e.dst][e.gas] < e.weight) continue;\n      //cout << e.dst << endl;\n      FOR(f,g[e.dst]) {\n        int nextgas = e.gas - f->weight;\n        //cout << \"dst : \" << f->dst << \" \" << nextgas << endl;\n        if (nextgas < 0) continue;\n        if (station.count(f->dst)) nextgas = cap;\n        //cout << nextgas << endl;\n        if (dist[f->dst][nextgas] > e.weight+f->weight) {\n          dist[f->dst][nextgas] = e.weight+f->weight;\n          Q.push(Edge(f->src, f->dst, e.weight+f->weight, nextgas));\n          //cout << \": \" << f->dst << endl;\n        }\n      }\n    }\n    int ans = *min_element(ALL(dist[id[dst]]));\n    if (ans == INF)\n      cout << -1 << endl;\n    else\n      cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint E, V, m, cap;\nstring start, goal;\nmap<string, int> mp;\nset<string> st;\nconst int MAX_E = 6000;\nconst int INF = 1e12;\n\nstruct edge{\n\tint to, cost;\n\tedge(int to, int cost):to(to), cost(cost){}\n};\n\nvector<edge> G[MAX_E];\nvector<int> use;\n\nint d[MAX_E];\nvoid dijkstra(int s){\n\tfill(d, d + MAX_E, INF);\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(d[s], s));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint from = p.second;\n\t\tint cost = p.first;\n\t\tif(d[from] < cost) continue;\n\t\trep(i, 0, G[from].size()){\n\t\t\tedge e = G[from][i];\n\t\t\tint next = e.to;\n\t\t\tint newCost = e.cost + cost;\n\t\t\tif(d[next] > newCost){\n\t\t\t\td[next] = newCost;\n\t\t\t\tq.push(P(newCost, next));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main(){\n\twhile(1){\n\t\tcin >> V >> m >> cap;\n\t\tif(V == 0 && m == 0 && cap == 0) break;\n\t\tmp.clear(); st.clear(); use.clear();\n\t\trep(i, 0, MAX_E) G[i].clear();\n\t\tcin >> start >> goal;\n\t\tst.insert(start);\n\t\tst.insert(goal);\n\t\tmp[start] = 0;\n\t\tmp[goal] = 1;\n\t\tuse.push_back(0);\n\t\tuse.push_back(1);\n\t\trep(i, 0, V){\n\t\t\tstring s, t; int cost;\n\t\t\tcin >> s >> t >> cost;\n\t\t\tif(!st.count(s)){\n\t\t\t\tmp[s] = st.size();\n\t\t\t\tst.insert(s);\n\t\t\t}\n\t\t\tif(!st.count(t)){\n\t\t\t\tmp[t] = st.size();\n\t\t\t\tst.insert(t);\n\t\t\t}\n\t\t\tG[mp[s]].push_back(edge(mp[t], cost));\n\t\t\tG[mp[t]].push_back(edge(mp[s], cost));\n\t\t}\n\t\t/*for(map<string, int>::iterator it = mp.begin(); it != mp.end(); it++){\n\t\t\tcout << it -> first << \" \" << it -> second << endl;\n\t\t}*/\n\t\trep(i, 0, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif(mp[s] > 1) use.push_back(mp[s]);\n\t\t}\n\t\tvector<edge> tmp[MAX_E];\n\t\trep(i, 0, use.size()){\n\t\t\tdijkstra(use[i]);\n\t\t\trep(j, i + 1, use.size()){\n\t\t\t//cout << use[i] << \" \" << use[j] << \" \" << d[use[j]] << endl;\n\t\t\t\tif(d[use[j]] <= cap * 10){\n\t\t\t\t\t//cout << use[i] << \" \" << use[j] << endl;\n\t\t\t\t\ttmp[i].push_back(edge(j, d[use[j]]));\n\t\t\t\t\ttmp[j].push_back(edge(i, d[use[j]]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, 0, use.size()) cout << use[i] << \" \";\n\t\t//cout << endl;\n\t\trep(i, 0, MAX_E){\n\t\t\tG[i] = tmp[i];\n\t\t}\n\t\tdijkstra(0);\n\t\t//rep(i, 0, 6) cout << d[i] << \" \";\n\t\t//cout << endl;\n\t\tcout << (d[1] == INF ? -1 : d[1]) << endl;\t\t\n\t}\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nint n, m, k, p, dist[7000][2500], c[3000]; bool u[3000]; vector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nusing Graph = vector<vector<edge>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, int c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\nvi dijkstra(const Graph& G, int s) {\n    int n = G.size();\n    using State = pair<int, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    vector<int> d(n, inf);\n    d[s] = 0;\n    pq.push(State(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(State(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, M, cap;\n    while (cin >> N >> M >> cap, N) {\n        string ss, tt;\n        cin >> ss >> tt;\n        map<string, int> mp;\n        vector<string> a(N), b(N);\n        vector<int> c(N);\n        rep(i, N) {\n            cin >> a[i] >> b[i] >> c[i];\n            mp[a[i]];\n            mp[b[i]];\n        }\n        vector<string> stations(M);\n        rep(i, M) cin >> stations[i];\n\n        {\n            int i = 0;\n            for (auto& p : mp) {\n                p.second = i++;\n            }\n        }\n\n        int num_town = mp.size();\n        Graph G(num_town);\n        const int s = mp[ss], t = mp[tt];\n        rep(i, N) {\n            addEdge(G, mp[a[i]], mp[b[i]], c[i]);\n        }\n\n        stations.emplace_back(ss);\n        stations.emplace_back(tt);\n        M += 2;\n\n        Graph H(num_town);\n        rep(i, M) {\n            auto d = dijkstra(G, mp[stations[i]]);\n            rep2(j, i + 1, M) {\n                if (d[mp[stations[j]]] <= 10 * cap) {\n                    addEdge(H, mp[stations[i]], mp[stations[j]], d[mp[stations[j]]]);\n                }\n            }\n        }\n\n        auto d = dijkstra(H, s);\n        cout << (d[t] == inf ? -1 : d[t]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint D[N][N];\npriority_queue<PP,vector<PP>,greater<PP> > Q;\nint dijkstra(){\n  while(!Q.empty())Q.pop();\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++) D[i][j]=INF;\n\n  Q.push(PP(0,P(cap,0)));\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n    if(pos==1) return d;\n    if(D[pos][c]<d)continue;\n    if(ls[pos])c=cap;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&D[nx][nc]>nd)Q.push(PP(nd,P(nc,nx))),D[nx][nc]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<30\nusing namespace std;\n\nint n,m,cap;\nint s=0,d=1,c;\nmap<string,int> M;\nbool sta[6001];\nint dp[6001][2001];\n\nclass edge{\npublic:\n  int to,dis;\n  edge(int to,int dis):to(to),dis(dis){}\n};\n\nvector<edge> v[6001];\n\nclass State{\npublic:\n  int n,a,dis;\n  State(int n,int a,int dis):n(n),a(a),dis(dis){}\n  bool operator<(State s)const{\n    return s.dis<dis;\n  }\n};\n\nvoid init(){\n  M.clear();\n  for(int i=0;i<n*2+1;i++){\n    for(int j=0;j<2001;j++)dp[i][j]=inf;\n    sta[i]=false;\n    v[i].clear();\n  }\n}\n\nint main()\n{\n  string a,b;\n\n  while(1){\n    cin>>n>>m>>cap;\n    if(n+m+cap==0)break;\n    cap*=10;\n    init();\n    cin>>a>>b;\n    M[a]=s;M[b]=d;\n    int num=2;\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      if(M.find(a)==M.end()){\n\tM[a]=num;\n\tnum++;\n      }\n      if(M.find(b)==M.end()){\n\tM[b]=num;\n\tnum++;\n      }\n      v[M[a]].push_back(edge(M[b],c));\n      v[M[b]].push_back(edge(M[a],c));\n\n    }\n    for(int i=0;i<m;i++){\n      cin>>a;\n      sta[M[a]]=true;\n    }\n\n    dp[0][cap]=0;\n    priority_queue<State> pq;\n    pq.push(State(0,cap,0));\n    int ans=inf;\n\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(dp[u.n][u.a]<u.dis)continue;\n      if(u.n==d){\n\tans=min(ans,u.dis);\n\tcontinue;\n      }\n\n      for(int i=0;i<v[u.n].size();i++){\n\n\tif(sta[u.n]){\n\t  if(v[u.n][i].dis<cap){\n\t    int sum1=u.dis+v[u.n][i].dis,sum2=cap-v[u.n][i].dis;\n\t    if(sum1<dp[v[u.n][i].to][sum2]){\n\t      dp[v[u.n][i].to][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].to,sum2,sum1));\n\t    }\n\t  }\n\t}\n\telse {\n\t  if(v[u.n][i].dis<u.a){\n\t    int sum1=u.dis+v[u.n][i].dis,sum2=u.a-v[u.n][i].dis;\n\t    if(sum1<dp[v[u.n][i].to][sum2]){\n\t      dp[v[u.n][i].to][sum2]=sum1;\n\t      pq.push(State(v[u.n][i].to,sum2,sum1));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans!=inf)cout<<ans<<endl;\n    else cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> g[6000];\nbool f[6000];\nint dist[6000][2010];\n\nint main()\n{\n\tint n, m, cap;\n\twhile (cin >> n >> m >> cap, n){\n\t\tfor (int i = 0; i < 6000; i++) g[i].clear();\n\t\tmemset(f, 0, sizeof(f));\n\t\tcap *= 10;\n\t\tstring src, dst;\n\t\tcin >> src >> dst;\n\t\tmap<string, int> mp;\n\t\tmp[src] = mp.size() - 1;\n\t\tmp[dst] = mp.size() - 1;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring a, b;\n\t\t\tint c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!mp.count(a)) mp[a] = mp.size() - 1;\n\t\t\tif (!mp.count(b)) mp[b] = mp.size() - 1;\n\t\t\tg[mp[a]].emplace_back(mp[b], c);\n\t\t\tg[mp[b]].emplace_back(mp[a], c);\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf[mp[s]] = true;\n\t\t}\n\t\tfill_n(*dist, 6000 * 2010, 1 << 28);\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n\t\tdist[0][cap] = 0;\n\t\tpq.push(make_tuple(0, 0, cap));\n\t\tint goal = mp[dst];\n\t\tint res = -1;\n\t\twhile (pq.size()){\n\t\t\tint s, v, r;\n\t\t\ttie(s, v, r) = pq.top(); pq.pop();\n\t\t\tif (v == goal){\n\t\t\t\tres = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dist[v][r] < s) continue;\n\t\t\tif (f[v]) r = cap;\n\t\t\tfor (pair<int, int> &e : g[v]){\n\t\t\t\tif (r < e.second) continue;\n\t\t\t\tif (dist[e.first][r - e.second] > s + e.second){\n\t\t\t\t\tdist[e.first][r - e.second] = s + e.second;\n\t\t\t\t\tpq.push(make_tuple(s + e.second, e.first, r - e.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntypedef int weight;\nstruct edge {\n\tint to;\n\tweight cost;\n\tedge(int t, weight c):to(t), cost(c){}\n};\ntypedef pair<weight, int> P;\nconstexpr int INF = 0xfffffff;\n\nvector<int> dijkstra(int s, int cap, const vector<vector<edge>>& es) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INF);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst P p = que.top();\n\t\tque.pop();\n\t\tconst int v = p.second;\n\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < (int)es[v].size(); ++i) {\n\t\t\tconst edge& e = es[v][i];\n\t\t\tconst weight next_dist = dist[v] + e.cost;\n\t\t\tif(next_dist > cap * 10) continue;\n\n\t\t\tif(dist[e.to] > next_dist) {\n\t\t\t\tdist[e.to] = next_dist;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nunordered_map<string, int> en;\ninline int encode(const string& s) {\n\tif(!en.count(s)) en.insert(make_pair(s, en.size()));\n\treturn en[s];\n}\n\ninline int input_city() {\n\tstring s;\n\tcin >> s;\n\treturn encode(s);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, cap; cin >> n >> m >> cap && n;) {\n\t\ten.clear();\n\t\tconst int s = input_city();\n\t\tconst int t = input_city();\n\n\t\tvector<tuple<int, int, int>> edges;\n\t\tedges.reserve(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int a = input_city();\n\t\t\tconst int b = input_city();\n\t\t\tint cost;\n\t\t\tcin >> cost;\n\t\t\tedges.emplace_back(a, b, cost);\n\t\t}\n\n\t\tconst int number_of_city = static_cast<int>(en.size());\n\t\tvector<vector<edge>> es(number_of_city);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint a, b, cost;\n\t\t\ttie(a, b, cost) = edges[i];\n\t\t\tes[a].emplace_back(b, cost);\n\t\t\tes[b].emplace_back(a, cost);\n\t\t}\n\n\t\tvector<int> dist = dijkstra(s, cap, es);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tconst int next = input_city();\n\t\t\tvector<int> tmp = dijkstra(next, cap, es);\n\t\t\tfor(int i = 0; i < number_of_city; ++i) {\n\t\t\t\tchmin(dist[i], dist[next] + tmp[i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[t] == INF ? -1 : dist[t]) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 4000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d>p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<=now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i, 0, n)\n\nstruct node{\n    int index,remain,cost;\n\tnode(int index,int remain,int cost):index(index),remain(remain),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n\t}\n};\n\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint main() {\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n|m|cap){\n        cap*=10;\n        string src,dst;\n        cin>>src>>dst;\n        vvi g(n,vi(n,NONE));\n\n        vs cities;\n        vs from(n),to(n);\n        vi d(n);\n        REP(i,n){\n            cin>>from[i]>>to[i]>>d[i];\n            if(find(ALL(cities),from[i])==cities.end()){\n                cities.push_back(from[i]);\n\t\t    }\n            if(find(ALL(cities),to[i])==cities.end()){\n                cities.push_back(to[i]);\n\t\t    }\n        }\n        REP(i,n){\n            int f=find(ALL(cities),from[i])-cities.begin();\n            int t=find(ALL(cities),to[i])-cities.begin();\n            g[f][t]=d[i];\n            g[t][f]=d[i];\n        }\n        vi station(n);\n        REP(i,m){\n            string s;\n            cin>>s;\n            station[find(ALL(cities),s)-cities.begin()]=1;\n        }\n\n        int src_i=find(ALL(cities),src)-cities.begin();\n        int dst_i=find(ALL(cities),dst)-cities.begin();\n        priority_queue<node> q;\n        q.push(node(src_i,cap,0));\n        vvi cost(n,vi(cap+1,MAX));\n        cost[0][cap]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.remain]<cnode.cost){\n                continue;\n\t\t    }\n            REP(i,n){\n                if(g[cnode.index][i]!=NONE){\n                    int newremain=cnode.remain-g[cnode.index][i];\n                    int newcost=cnode.cost+g[cnode.index][i];\n                    if(newremain>=0){\n                        newremain=station[i] ? cap : newremain;\n\t\t\t\t\t\tif(cost[i][newremain]>newcost){\n                            cost[i][newremain]=newcost;\n                            q.push(node(i,newremain,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t    }\n        int ans=MAX;\n        REP(i,cap+1){\n            ans=min(ans,cost[dst_i][i]);\n\t    }\n        cout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d;\n  Edge(int to, int d):to(to),d(d){}\n};\n\nint N,M,C, V;\nvector<Edge>G[6005];\nstring city[6005];\nint gs[6005];\nint dist[2048][6010];\nmap<string,int>recity;\n\nvoid dijkstra(int s){\n  rep(i,C+1) fill(dist[i], dist[i]+V, INF);\n  dist[C][s] = 0;\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(MP(0, MP(C, s)));\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int cap = p.second.first, v = p.second.second, cost = p.first;\n\n    if(dist[cap][v] < cost) continue;\n    rep(i, G[v].size()){\n      Edge e = G[v][i];\n      if(e.d > cap) continue;\n      int tar = max(cap-e.d, gs[e.to]*C);\n      if(dist[tar][e.to] > dist[cap][v] + e.d){\n\tdist[tar][e.to] = dist[cap][v] + e.d;\n\tq.push(MP(dist[tar][e.to], MP(tar, e.to)));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N>>M>>C, N||M||C){\n\n    rep(i,3005) G[i].clear();\n    memset(gs, 0, sizeof gs);\n    recity.clear();\n    C *= 10;\n    V = 0;\n    string src, dest;\n    cin >> src >> dest;\n\n    rep(i,N){\n      string s1, s2; int d,u,v;\n      cin >> s1 >> s2 >> d;\n      if(recity.find(s1) == recity.end()){ recity[s1] = V; city[V++] = s1;}\n      if(recity.find(s2) == recity.end()){ recity[s2] = V; city[V++] = s2;}\n      u = recity[s1];\n      v = recity[s2];\n      G[u].push_back(Edge(v,d));\n      G[v].push_back(Edge(u,d));\n    }\n\n    rep(i,M){\n      string s;  cin >> s;\n      gs[recity[s]] = 1;\n    }\n\n    dijkstra(recity[src]);\n\n    int res = INF;\n    rep(i, C+1) res = min(res, dist[i][recity[dest]]);\n    cout <<(res==INF?-1:res)  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvector<PII> g[6010];\nint d[6010][2010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m, cap;\n    cin >> n >> m >> cap; cap *= 10;\n    if(!n) break;\n    string src, dst;\n    cin >> src >> dst;\n    int V = 0;\n    map<string,int> mp;\n    REP(i, 6010) g[i].clear();\n    REP(i, n) {\n      int l;\n      string s, t;\n      cin >> s >> t >> l;\n      if(mp.find(s) == mp.end()) {\n        mp[s] = V++;\n      }\n      if(mp.find(t) == mp.end()) {\n        mp[t] = V++;\n      }\n      g[mp[s]].PB({mp[t], l});\n      g[mp[t]].PB({mp[s], l});\n      // cout << mp[s] << \" \" << mp[t] << \" \" << l << endl;\n    }\n    VI exist(V, 0);\n    REP(i, m) {\n      string s;\n      cin >> s;\n      exist[mp[s]] = 1;\n    }\n    int start = mp[src], goal = mp[dst];\n    // cout << V << endl;\n\n    REP(i, V) REP(j, cap+1) d[i][j] = LLINF;\n    d[start][cap] = 0;\n    priority_queue<VI, VVI, greater<VI>> que;\n    que.push({d[start][cap], start, cap});\n\n    while(que.size()) {\n      VI v = que.top(); que.pop();\n      // cout << v << endl;\n      int dist = v[0], place = v[1], gas = v[2];\n      if(dist > d[place][gas]) continue;\n      for(PII &p: g[place]) {\n        int rest = exist[p.first]?cap:gas-p.second;\n        if(gas >= p.second && d[p.first][rest] > d[place][gas] + p.second) {\n          d[p.first][rest] = d[place][gas] + p.second;\n          que.push({d[p.first][rest], p.first, rest});\n        }\n      }\n    }\n\n    int ans = LLINF;\n    REP(i, cap+1) chmin(ans, d[goal][i]);\n    if(ans==LLINF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int> > v[6005],v2[6005];\nmap<string,int> mp;\nint mpn,n,m,k;\nbool c[6005];\nunsigned dis[6005];\nchar a[20];\nint b[305];\nqueue<int> q;\n\ninline int s2i(string x)\n{\n    if(!mp.count(x))\n        return mp[x]=mpn++;\n    return mp[x];\n}\n\nvoid spfa(int st)\n{\n    int i,j,x,y;\n    memset(dis,-1,sizeof(dis));\n    dis[st]=0;\n    q.push(st);\n    while(!q.empty())\n    {\n        x=q.front();\n        q.pop();\n        for(i=0,j=v[x].size();i<j;i++)\n        {\n            y=v[x][i].first;\n            if(dis[x]+v[x][i].second>(unsigned)k||dis[x]+v[x][i].second>dis[y])\n                continue;\n            dis[y]=dis[x]+v[x][i].second;\n            q.push(y);\n        }\n    }\n    for(i=0;i<n;i++)\n        if(c[i]&&i!=st&&dis[i]!=-1)\n            v2[st].push_back(make_pair(i,dis[i]));\n}\n\nint main()\n{\n    int st,ed,i,j,x,y,w;\n    while(~scanf(\"%d%d%d\",&n,&m,&k)&&(n+m+k))\n    {\n        memset(c,0,sizeof(c));\n        mpn=0;k*=10;\n        scanf(\"%s\",a);st=s2i(a);\n        scanf(\"%s\",a);ed=s2i(a);\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%s\",a);x=s2i(a);\n            scanf(\"%s\",a);y=s2i(a);\n            scanf(\"%d\",&w);\n            v[x].push_back(make_pair(y,w));\n            v[y].push_back(make_pair(x,w));\n        }\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s\",a);\n            c[b[i]=s2i(a)]=1;\n        }\n        c[st]=c[ed]=1;\n        spfa(st);\n        for(i=0;i<m;i++)\n            spfa(b[i]);\n        memset(dis,-1,sizeof(dis));\n        dis[st]=0;\n        q.push(st);\n        while(!q.empty())\n        {\n            x=q.front();\n            q.pop();\n            for(i=0,j=v2[x].size();i<j;i++)\n            {\n                y=v2[x][i].first;\n                if(dis[x]+v2[x][i].second<dis[y])\n                {\n                    dis[y]=dis[x]+v2[x][i].second;\n                    q.push(y);\n                }\n            }\n        }\n        printf(\"%d\\n\",dis[ed]);\n        for(i=0;i<mpn;i++)\n            v[i].clear(),v2[i].clear();\n        mp.clear();\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tif(to == dst_id){\n\t  res = s.dist + dist;\n\t  goto found;\n\t}\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint min_consumed_LPG[6001];\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(min_consumed_LPG,0x3f,sizeof(min_consumed_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 3000) continue;\n\tif(min_consumed_LPG[to] <= next_consumed_LPG) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tmin_consumed_LPG[to] = next_consumed_LPG;\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef struct\n{\n    int nam;\n    int dis;\n    int cans;\n    int teps;\n}Node;\nNode que[10010000];\nint fro,las;\n\ntypedef struct\n{\n    int u,v;\n    int dis;\n    int nex;\n}NN;\nNN edge[500100];\nint first[500100];\nint tot;\n\nvoid add(int u,int v,int d)\n{\n    edge[tot].u=u;\n    edge[tot].v=v;\n    edge[tot].dis=d;\n    edge[tot].nex=first[u];\n    first[u]=tot++;\n}\n\nchar str[100],str2[100];\nint n,m,cap,d,ns;\nbool hav[500010];\nint vis[500010];\nmap<string,int>num;\n\nint bfs()\n{\n    Node now,nex;\n    int ans=999999999;\n    now.nam=1;now.dis=0;now.cans=cap*10;now.teps=1;\n    las=fro=0;\n    que[las++]=now;\n    while(las!=fro)\n    {\n        now=que[fro++];\n        if(now.nam==2)\n        {\n            ans=min(ans,now.dis);\n            continue;\n        }\n        for(int i=first[now.nam];i!=-1;i=edge[i].nex)\n        {\n            if(hav[edge[i].v])\n            {\n                if(vis[edge[i].v]) continue;\n                else if(now.cans>=edge[i].dis&&vis[edge[i].v]==0)\n                {\n                    vis[edge[i].v]=1;\n                    nex.nam=edge[i].v;\n                    nex.dis=now.dis+edge[i].dis;\n                    nex.teps=now.teps+1;\n                    nex.cans=cap*10;\n                    que[las++]=nex;\n                }\n            }\n            else if(vis[edge[i].v]!=now.teps&&now.cans>=edge[i].dis)\n            {\n                vis[edge[i].v]=now.teps;\n                nex.nam=edge[i].v;\n                nex.dis=now.dis+edge[i].dis;\n                nex.teps=now.teps;\n                nex.cans=now.cans-edge[i].dis;\n                que[las++]=nex;\n            }\n        }\n    }\n    if(ans==999999999)return -1;\n    else return ans;\n}\n\nint main()\n{\n    while(true)\n    {\n        scanf(\"%d %d %d\",&n,&m,&cap);\n        if(n+m+cap==0) break;\n        num.clear();\n        memset(first,-1,sizeof(first));\n        memset(hav,false,sizeof(hav));\n        memset(vis,0,sizeof(vis));\n        ns=tot=0;\n        scanf(\"%s\",str); if(!num[str]) num[str]=++ns;\n        scanf(\"%s\",str2); if(!num[str2]) num[str2]=++ns;\n        //printf(\"%s=%d  %s=%d\\n\",str,num[str],str2,num[str2]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",str);  if(!num[str]) num[str]=++ns;\n            scanf(\"%s\",str2); if(!num[str2]) num[str2]=++ns;\n            scanf(\"%d\",&d);\n            //printf(\"%s=%d  %s=%d d=%d\\n\",str,num[str],str2,num[str2],d);\n            add(num[str],num[str2],d);\n            add(num[str2],num[str],d);\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%s\",str); if(!num[str]) num[str]=++ns;\n            //printf(\"%s=%d\\n\",str,num[str]);\n            hav[num[str]]=true;\n        }\n        printf(\"%d\\n\",bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\nconst int INF = 1<<28;\n\nclass DP{\npublic:\n\tint cost, state;\n\t\n\tDP(){}\n\tDP(int st, int cc){\n\t\tcost = cc;state=st;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tint dist;\n};\n\nint N, M, C;\n\nvector<int> dijkstra(int s, const vector< vector<edge> > &E){\n\tvector<int> dist(E.size(), INF);\n\tpriority_queue<DP> dp;\n\tDP S;\n\tdp.push(DP(s, 0));\n\tset<int> visit;\n\twhile(!dp.empty()){\n\t\tS = dp.top();\n\t\tdp.pop();\n\t\tFOR(it, E[S.state]){\n\t\t\tif(!visit.count(it->to)){\n\t\t\t\tdist[it->to] = S.cost + it->dist;\n\t\t\t\tdp.push(DP(it->to, dist[it->to]));\n\t\t\t\tvisit.insert(it->to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvoid dijkstra2(int s, vector< vector<int> > &E){\n\tpriority_queue<DP> dp;\n\tDP S;\n\tdp.push(DP(s, 0));\n\tset<int> visit;\n\twhile(!dp.empty()){\n\t\tS = dp.top();\n\t\tdp.pop();\n\t\tREP(i, E[S.state].size()){\n\t\t\tif(!visit.count(i)){\n\t\t\t\tE[s][i] = min(E[s][i], S.cost + E[S.state][i]);\n\t\t\t\tdp.push(DP(i, E[s][i]));\n\t\t\t\tvisit.insert(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E;\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)){\n\t\t\t\tidx[from] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tif(!idx.count(to)){\n\t\t\t\tidx[to] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n//\t\t\tcout << idx[from] << \" \" << idx[to] << \" \" << dist << endl;\n\t\t}\n\t\tvector<int> stv;\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(idx[sta]);\n//\t\t\tcout << idx[sta] << endl;\n\t\t\tstv.push_back(idx[sta]);\n\t\t}\n\t\tvector<int> sdist, gdist;\n\t\tvector< vector<int> > stg(stations.size(), vector<int>(stations.size(), INF));\n\t\ts = idx[ss];g = idx[gg];\n\t\tfor(i=0;i<E.size();i++){\n\t\t\tvector<int> dist = dijkstra(i, E);\n\t\t\tif(i == s) sdist = dist;\n\t\t\tif(i == g) gdist = dist;\n\t\t\tif(stations.count(i)){\n\t\t\t\tint j = 0;\n\t\t\t\tFOR(it, stv){\n\t\t\t\t\tif(i == *it) break;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tint k = 0;\n\t\t\t\tFOR(it, stv){\n\t\t\t\t\tif(k == j) stg[k][j] = 0;\n\t\t\t\t\telse if(dist[*it] <= C*10) stg[j][k] = stg[k][j] = dist[*it];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<stations.size();i++) dijkstra2(i, stg);\n\t\tint ans = INF;\n\t\tfor(int i=0;i<stations.size();i++){\n\t\t\tfor(int j=0;j<stations.size();j++){\n\t\t\t\tif(sdist[stv[i]] > C*10 || gdist[stv[j]] > C*10) continue;\n\t\t\t\tans = min(ans, sdist[stv[i]] + stg[i][j] + gdist[stv[j]]);\n//\t\t\t\tprintf(\"->%d->%d-> %d\\n\", i, j, sdist[stv[i]] + stg[i][j] + gdist[stv[j]]);\n\t\t\t}\n\t\t}\n\t\tcout << ((ans < INF) ? ans : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct E{\n  string t;\n  int d;\n};\n\nstruct S{\n  string v;\n  int r,d;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nint main(){\n  for(int n,mm,cap;cin>>n>>mm>>cap,n|mm|cap;){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    map<string,vector<E> > m;\n    for(int i=0;i<n;i++){\n      string c[2];\n      int d;\n      cin>>c[0]>>c[1]>>d;\n      for(int j=0;j<2;j++){\n\tE ce={c[j^1],d};\n\tm[c[j]].push_back(ce);\n      }\n    }\n    set<string> gs;\n    for(int i=0;i<mm;i++){\n      string s;\n      cin>>s;\n      gs.insert(s);\n    }\n    priority_queue<S> que;\n    S is={src,cap,0};\n    que.push(is);\n    map<string,map<int,int> > p;\n    while(!que.empty()){\n      S c=que.top();\n      if(c.v==dest)break;\n      que.pop();\n      map<int,int>::iterator it=p[c.v].upper_bound(c.r);\n      if(it!=p[c.v].end()&&it->second<=c.d)continue;\n      p[c.v][c.r]=c.d;\n      for(int i=0;i<m[c.v].size();i++){\n\tif(m[c.v][i].d<=c.r){\n\t  S n={m[c.v][i].t,c.r-m[c.v][i].d,c.d+m[c.v][i].d};\n\t  if(gs.count(n.v)){\n\t    n.r=cap;\n\t  }\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.top().d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>pi;\n\nstruct edge\n{\n    int to,dist;\n};\n\nint dp[6001][2001];\nbool ok[6001];\nvector<edge> G[6001];\nmap<string,int> mp;\nint id,n,m,cap,s,g;\n\nvoid Dijkstra()\n{\n    rep(i,id){\n        rep(j,cap+1){\n            dp[i][j] = INF;\n        }\n    }\n    priority_queue<pi,vector<pi>,greater<pi> > que;\n    dp[s][cap] = 0;\n    que.push(pi(P(0,s),cap));\n    while(!que.empty()){\n        auto pp = que.top();\n        que.pop();\n        P p = pp.fi;\n        int q = pp.se;\n        if(dp[p.se][q] < p.fi) continue;\n        if(p.se == g){\n            cout << p.fi << \"\\n\";\n            return;\n        }\n        for(auto& e : G[p.se]){\n            if(q >= e.dist){\n                int nx = q-e.dist;\n                if(ok[e.to]) nx = cap;\n                if(dp[e.to][nx] > p.fi+e.dist){\n                    dp[e.to][nx] = p.fi+e.dist;\n                    que.push(pi(P(dp[e.to][nx],e.to),nx));\n                }\n            }\n        }\n    }\n    cout << \"-1\\n\";\n}\n\n\nint main()\n{\n    while(1){\n        cin >> n >> m >> cap;\n        if(n == 0){\n            break;\n        }\n        cap *= 10;\n        mp.clear();\n        id = 0;\n        string p,q;\n        cin >> p >> q;\n        if(mp.find(p) == mp.end()){\n            mp[p] = id++;\n        }\n        if(mp.find(q) == mp.end()){\n            mp[q] = id++;\n        }\n        s = mp[p], g = mp[q];\n        rep(i,6001){\n            G[i].clear();\n        }\n        rep(i,n){\n            string x,y;\n            int z;\n            cin >> x >> y >> z;\n            if(mp.find(x) == mp.end()){\n                mp[x] = id++;\n            }\n            if(mp.find(y) == mp.end()){\n                mp[y] = id++;\n            }\n            G[mp[x]].push_back((edge){mp[y],z});\n            G[mp[y]].push_back((edge){mp[x],z});\n        }\n        rep(i,id){\n            ok[i] = false;\n        }\n        rep(i,m){\n            string s;\n            cin >> s;\n            ok[mp[s]] = true;\n        }\n        Dijkstra();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Edge {\npublic:\n  int from;\n  int to;\n  int dist;\n  Edge() {}\n  Edge(int _f,int _t,int _d) : from(_f),to(_t),dist(_d){}\n};\n\nbool is_LPG[3005];\nbool dp[3005][2005]; //dp[city_id][remaining_LPG] = dist;\nstatic int gCity_idx = 0;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    cities[city] = gCity_idx++;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n    gCity_idx = 0;\n\n    map<string,int> cities;\n    vector<Edge> edges;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      edges.push_back(Edge(from_num,to_num,dist));\n      edges.push_back(Edge(to_num,from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    vector<vector<Edge> > nodes(cities.size());\n    for(int i=0; i<edges.size(); i++){\n      Edge e = edges[i];\n      nodes[e.from].push_back(Edge(e.from, e.to, e.dist));\n      nodes[e.to].push_back(Edge(e.to, e.from, e.dist));\n    }\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_V = 6010, MAX_CAP = 6010;\n\nint dist[MAX_V][MAX_CAP]; // ?????? ??????????????????\nusing tup = tuple<int, int, int>;\n\nint dijkstra(int start, int goal, int cap, const vector<vector<pair<int, int>>>& G, const set<int>& LPG) {\n\n    for (int i = 0; i < MAX_V; ++i) for (int j = 0; j < MAX_CAP; ++j) dist[i][j] = INF;\n\tcap *= 10;\n\n\tdist[start][cap] = 0;\n\tpriority_queue<tup, vector<tup>, greater<tup>> que; // ?????¢ ?????? ?????????LPG\n\tque.push(make_tuple(0, start, cap));\n\n\twhile(!que.empty()){\n\n\t\tint cost, u, lpg; // ?????¢ ?????? ?????????LPG\n\t\ttie(cost, u, lpg) = que.top(); que.pop();\n\n\t\tif(dist[u][lpg] < cost) continue; // ?????????????????????????¶????\n\n\t\tfor (const auto& tmp : G[u]){\n\t\t\tint v = tmp.first, e = tmp.second;\n\t\t\tint nlpg = lpg - e; // ??????v?????§?????£??????????????????LPG\n\t\t\tint ncost = cost + e; // ??????v?????§?????£??????????????????????????¢\n\t\t\tif(nlpg < 0) continue; // LPG????¶??????????\n\n\t\t\tif(LPG.count(v)) { // ??????v???LPG??????????????§???\n\t\t\t\tif(dist[v][cap] > ncost) {\n\t\t\t\t\tdist[v][cap] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, cap));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dist[v][nlpg] > ncost) {\n\t\t\t\t\tdist[v][nlpg] = ncost;\n\t\t\t\t\tque.push(make_tuple(ncost, v, nlpg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = INF;\n\tfor(int j = 1; j < MAX_V; j++) ans = min(ans, dist[goal][j]);\n\treturn (ans != INF) ? ans : -1;\n\n}\n\nint main(void) {\n\n\twhile(1) {\n\t\tint N, M, cap; cin >> N >> M >> cap;\n\t\tif(N == 0 && M == 0 && cap == 0) break;\n\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\n\t\tvector<string> c1(N), c2(N);\n\t\tvector<int> d(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> c1[i] >> c2[i] >> d[i];\n\n\t\tvector<string> s(M);\n\t\tfor (int i = 0; i < M; ++i) cin >> s[i];\n\t\t\n\t\tset<string> st;\n\t\tst.insert(src), st.insert(dest);\n\t\tfor (int i = 0; i < N; ++i) st.insert(c1[i]), st.insert(c2[i]);\n\n\t\tint cnt = 0;\n\t\tmap<string, int> city2num;\n\t\tfor(const auto& t : st) city2num[t] = cnt++;\n\n\t\tset<int> lpg;\n\t\tfor (int i = 0; i < M; ++i) lpg.insert(city2num[s[i]]);\n\t\tvector<vector<pair<int, int>> >  G(110);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG[city2num[c1[i]]].push_back(make_pair(city2num[c2[i]], d[i]));\n\t\t\tG[city2num[c2[i]]].push_back(make_pair(city2num[c1[i]], d[i]));\n\t\t}\n\n\t\tcout << dijkstra(city2num[src], city2num[dest], cap, G, lpg) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <queue>\ntypedef long long ll;\n\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nstruct Edge {\n    int src, dst;\n    int weight;\n    Edge(int s, int d, int w) : src(s), dst(d), weight(w) {}\n    Edge() {}\n};\n\nusing Graph = vector<vector<Edge>>;\n\nint V, E;\nint num_stand; // num of stands\nstring src, dst;\nint cap;\nGraph g;\n\nvector<string> c1, c2;\nvector<int> d;\nvector<string> s;\n\nmap<string, int> m;\n\nconst int inf = 1e9;\n\nint dist[6010][2100]; // at town i with gas j\nint canCharge[6010];\n\nint dijkstra(int s, int t) {\n    fill((int*)begin(dist), (int*)end(dist), inf);\n    priority_queue<tuple<int,int, int>> q;// -dist, town, cap\n    \n    dist[s][cap] = 0;\n    q.emplace(0, s, cap);\n\n    while (q.size()) {\n        int d, v, rem;\n        tie(d, v,rem) = q.top();\n        q.pop();\n        d = -d;\n\n        if (v == t) return d;\n\n        if (dist[v][rem] < d) continue;\n        for (auto &e : g[v]) {\n            int nv = e.dst;\n            int nrem = rem - e.weight;\n            if (nrem < 0) continue;\n            if (canCharge[nv]) {\n                nrem = cap;\n            }\n            int nd = d + e.weight;\n            if (dist[nv][nrem] > nd) {\n                dist[nv][nrem] = nd;\n                q.emplace(-nd, nv, nrem);\n            }\n        }\n    }\n\n    return 1e9;\n}\n\nint main() {\n    while (cin >> E >> num_stand >> cap && E) {\n        m.clear();\n        V = 0;\n        c1.resize(E);\n        c2.resize(E);\n        d.resize(E);\n        cap *= 10;\n        cin >> src >> dst;\n        if (m.count(src) == 0) m[src] = V++;\n        if (m.count(dst) == 0) m[dst] = V++;\n\n        for (int i = 0; i < E; ++i) {\n            cin >> c1[i] >> c2[i] >> d[i];\n            if (m.count(c1[i]) == 0) m[c1[i]] = V++;\n            if (m.count(c2[i]) == 0) m[c2[i]] = V++;\n        }\n\n        memset(canCharge, 0, sizeof(canCharge));\n        s.resize(num_stand);\n        for (int i = 0; i < num_stand; ++i) {\n            cin >> s[i];\n            canCharge[m[s[i]]] = true;\n        }\n\n        g.assign(V, {});\n        for (int i = 0; i < E; ++i) {\n            int a = m[c1[i]];\n            int b = m[c2[i]];\n            g[a].emplace_back(a, b, d[i]);\n            g[b].emplace_back(b, a, d[i]);\n        }\n\n        int ans = dijkstra(m[src], m[dst]);\n        if (ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\n#define INF 100000000\n\nint dist[310][310];\nint dp2[6010];\nvector<int> st;\nvector<int> e[6010];\nvector<int> c[6010];\nmap<string,int> id;\nint n,m,cap;\nint to[310];\nint from[310];\nbool is[6010];\nint wh[6010];\n\n\nvoid solve(int x) {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\tfor (int i=0; i<m; i++) dist[wh[x]][i] = INF;\n\tto[wh[x]] = INF;\n\tfrom[wh[x]] = INF;\n\tdp2[x] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,x));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (is[p] && cur<=cap) {\n\t\t\tdist[wh[x]][wh[p]] = min(cur,dist[wh[x]][wh[p]]);\n\t\t}\n\t\tif (p==0) from[wh[x]] = min(cur,from[wh[x]]);\n\t\tif (p==1) to[wh[x]] = min(cur,to[wh[x]]);;\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nint solve2() {\n\tfor (int i=0; i<n; i++) dp2[i] = INF;\n\n\tdp2[0] = 0;\n\tpriority_queue<pair<int,int> > q;\n\tq.push(mp(0,0));\n\t\n\twhile (!q.empty()) {\n\t\tint p = q.top().second;\n\t\tint cur = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif (p==1) {\n\t\t\treturn cur;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<e[p].size(); i++) {\n\t\t\tint u = e[p][i];\n\t\t\tint w = c[p][i];\n\t\t\t\n\t\t\tif (dp2[u] > w + dp2[p]) {\n\t\t\t\tdp2[u] = w + dp2[p];\n\t\t\t\tq.push(make_pair(-dp2[u],u));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn INF;\n}\n\t\t\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&n,&m,&cap) && n!=0) {\n\t\tid.clear();\n\t\tcap *= 10;\n\t\tfor (int i=0; i<2*n; i++) e[i].clear();\n\t\tfor (int i=0; i<2*n; i++) c[i].clear();\n\t\tint cnt = 2;\n\t\tst.clear();\n\t\tstring src, dest;\n\t\tcin>>src>>dest;\n\t\tid[src] = 0;\n\t\tid[dest] = 1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tstring s1,s2;\n\t\t\tcin>>s1>>s2;\n\t\t\tif (id.find(s1)==id.end()) id[s1] = cnt++;\n\t\t\tif (id.find(s2)==id.end()) id[s2] = cnt++;\n\t\t\tint h;\n\t\t\tcin>>h;\n\t\t\te[id[s1]].push_back(id[s2]);\n\t\t\te[id[s2]].push_back(id[s1]);\n\t\t\tc[id[s1]].push_back(h);\n\t\t\tc[id[s2]].push_back(h);\n\t\t}\n\t\tfor (int i=0; i<2*n; i++) is[i] = 0;\n\t\tfor (int i=0; i<2*n; i++) wh[i] = 0;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif (id.find(s)==id.end()) continue;\n\t\t\tst.push_back(id[s]);\n\t\t\tis[id[s]] = 1;\n\t\t\twh[id[s]] = i;\n\t\t}\n\t\tn = cnt;\n\t\t\n\t\tfor (int i=0; i<st.size(); i++) {\n\t\t\tsolve(st[i]);\n\t\t}\n\t\t\n\t\t//for (int i=0; i<m; i++) {\n\t\t//\tfor (int j=0; j<m; j++) cout<<dist[i][j]<<\" \";\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t\n\t\tint ans = solve2();\n\t\t\n\t\tif (ans>cap) ans = INF;\n\t\t\n\t\tfor (int k=0; k<m; k++) for (int i=0; i<m; i++) for (int j=0; j<m; j++) \n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tfor (int i=0; i<m; i++) for (int j=0; j<m; j++) {\n\t\t\tif (from[i]<=cap && to[j]<=cap) {\n\t\t\t\tans = min(ans, from[i] + to[j] + dist[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans==INF) cout<<-1<<endl; \n\t\telse cout<<ans<<endl;\n\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF 100000000\n\nusing namespace std;\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+MAX_V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>F,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    F.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    node.pb(src);\n    node.pb(dest);\n\n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      F.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<V;i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[F[i]]].pb(e);\n\n      e.to=vnum[F[i]];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() {}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nbool is_LPG[6001];\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nint get_city_id(map<string,int>& cities,const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(cin >> total_roads >> total_LPG_stations >>capacity){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    map<string,int> cities;\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(cities,src);\n    get_city_id(cities,dst);\n\n    vector<Node> nodes[6001];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(cities,from_str);\n      int to_num = get_city_id(cities,to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(cities,city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(cities,src),0,10*capacity));\n\n    int dst_id = get_city_id(cities,dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      if(dp[s.city_id][s.remaining_LPG]) continue;\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(s.remaining_LPG < dist) continue;\n\n\tint next_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\nconst int INF = 1<<28;\n\nclass DP{\npublic:\n\tint cost, state;\n\t\n\tDP(){}\n\tDP(int st, int cc){\n\t\tcost = cc;state=st;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tint dist;\n};\n\nint N, M, C;\n\nvector<int> dijkstra(int s, const vector< vector<edge> > &E){\n\tvector<int> dist(E.size(), INF);\n\tpriority_queue<DP> dp;\n\tDP S;\n\tdp.push(DP(s, 0));\n\tset<int> visit;\n\twhile(!dp.empty()){\n\t\tS = dp.top();\n\t\tdp.pop();\n\t\tFOR(it, E[S.state]){\n\t\t\tDP T=S;\n\t\t\tif(!visit.count(it->to)){\n\t\t\t\tT.state = it->to;\n\t\t\t\tT.cost += it->dist;\n\t\t\t\tdp.push(T);\n\t\t\t\tvisit.insert(it->to);\n\t\t\t\tdist[it->to] = T.cost;\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> N >> M >> C, N){\n\t\tstring ss,gg;\n\t\tint s, g;\n\t\tcin >> ss >> gg;\n\t\tvector< vector<edge> > E;\n\t\tmap<string, int> idx;\n\t\tset<int> stations;\n\t\tfor(i=0;i<N;i++){\n\t\t\tstring from, to;\n\t\t\tint dist;\n\t\t\tcin >> from >> to >> dist;\n\t\t\tif(!idx.count(from)){\n\t\t\t\tidx[from] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tif(!idx.count(to)){\n\t\t\t\tidx[to] = idx.size() - 1;\n\t\t\t\tE.push_back(vector<edge>(0));\n\t\t\t}\n\t\t\tE[idx[from]].push_back((edge){idx[to], dist});\n\t\t\tE[idx[to]].push_back((edge){idx[from], dist});\n//\t\t\tcout << idx[from] << \" \" << idx[to] << \" \" << dist << endl;\n\t\t}\n\t\tvector<int> stv;\n\t\tfor(i=0;i<M;i++){\n\t\t\tstring sta;\n\t\t\tcin >> sta;\n\t\t\tstations.insert(idx[sta]);\n//\t\t\tcout << idx[sta] << endl;\n\t\t\tstv.push_back(idx[sta]);\n\t\t}\n\t\tvector<int> sdist, gdist;\n\t\tvector< vector<int> > stg(stations.size(), vector<int>(stations.size(), INF));\n\t\ts = idx[ss];g = idx[gg];\n\t\tfor(i=0;i<E.size();i++){\n\t\t\tvector<int> dist = dijkstra(i, E);\n\t\t\tif(i == s) sdist = dist;\n\t\t\tif(i == g) gdist = dist;\n\t\t\tif(stations.count(i)){\n\t\t\t\tint j = 0;\n\t\t\t\tFOR(it, stv){\n\t\t\t\t\tif(i == *it) break;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tint k = 0;\n\t\t\t\tFOR(it, stv){\n\t\t\t\t\tif(k == j) stg[k][j] = 0;\n\t\t\t\t\telse if(dist[*it] <= C*10) stg[j][k] = stg[k][j] = dist[*it];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<stations.size();k++)\n\t\t  for(int i=0;i<stations.size();i++)\n\t\t    for(int j=0;j<stations.size();j++)\n\t\t\t  stg[i][j] = min(stg[i][j], stg[i][k] + stg[k][j]);\n\t\tint ans = INF;\n\t\tfor(int i=0;i<stations.size();i++){\n\t\t\tfor(int j=0;j<stations.size();j++){\n\t\t\t\tif(sdist[stv[i]] > C*10 || gdist[stv[j]] > C*10) continue;\n\t\t\t\tans = min(ans, sdist[stv[i]] + stg[i][j] + gdist[stv[j]]);\n//\t\t\t\tprintf(\"->%d->%d-> %d\\n\", i, j, sdist[stv[i]] + stg[i][j] + gdist[stv[j]]);\n\t\t\t}\n\t\t}\n\t\tcout << ((ans < INF) ? ans : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 3000; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    cout << -1 << endl;\n    continue;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,0x3f,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG] <= s.dist + dist) continue;\n\n\tdp[to][next_remaining_LPG] = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      res = min(dp[dst_id][remaining_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nint dp[6001][2001]; //dp[city_id][consumed_LPG] = dist;\nmap<int,vector<Node> > nodes;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    if(dist == s.dist){\n      return consumed_LPG < s.consumed_LPG;\n    }\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    if(dist == s.dist){\n      return consumed_LPG < s.consumed_LPG;\n    }\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tif(capacity*10 < s.consumed_LPG + dist) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + dist));\n\n\tif(next_consumed_LPG > 2000) continue;\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + dist) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + dist;\n\tif(to == dst_id) break;\n\tque.push(State(to,s.dist + dist,next_consumed_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 2000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\nvector<string> ash;\nint x,n,m,cap,inf=1e8,gas[302],dgas[302][302],d[6000];\nstring cst[3000][2];\nstruct edge{int to,cost;};\nvector<edge> G[6000];\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,x) d[i]=inf;\n\td[s]=0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc;\n\t\tif(d[v]<p.fs) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> m >> cap;\n\t\tif(n==0) break;\n\t\tstring src,dest;\n\t\tcin >> src >> dest;\n\t\tash.clear();\n\t\trep(i,n){\n\t\t\tcin >> cst[i][0] >> cst[i][1] >> d[i];\n\t\t\tash.push_back(cst[i][0]);\n\t\t\tash.push_back(cst[i][1]);\n\t\t}\n\t\tsort(ash.begin(),ash.end());\n\t\tash.erase(unique(ash.begin(),ash.end()),ash.end());\n\t\tx=ash.size();\n//\t\trep(i,x) cout << i << \" = \" << ash[i] << endl;\n//\t\tcout << endl;\n\t\trep(i,x) G[i].clear();\n\t\trep(i,n){\n\t\t\tint c0=lower_bound(ash.begin(),ash.end(),cst[i][0])-ash.begin();\n\t\t\tint c1=lower_bound(ash.begin(),ash.end(),cst[i][1])-ash.begin();\n\t\t\tG[c0].push_back({c1,d[i]});\n\t\t\tG[c1].push_back({c0,d[i]});\n\t\t}\n\t\trep(i,m){\n\t\t\tstring sst;\n\t\t\tcin >> sst;\n\t\t\tgas[i]=lower_bound(ash.begin(),ash.end(),sst)-ash.begin();\n\t\t}\n\t\tgas[m]=lower_bound(ash.begin(),ash.end(),src)-ash.begin();\n\t\tgas[m+1]=lower_bound(ash.begin(),ash.end(),dest)-ash.begin();\n\t\trep(i,m+2){\n\t\t\tcout << \"gas[i] = \" << ash[gas[i]] << endl;\n\t\t}\n\t\trep(i,m+2){\n\t\t\tdijkstra(gas[i]);\n\t\t\trep(j,m+2){\n\t\t\t\tif(d[gas[j]]<=cap*10) dgas[i][j]=d[gas[j]];\n\t\t\t\telse dgas[i][j]=inf;\n\t\t\t}\n\t\t}\n\t\trep(i,m+2){\n\t\t\trep(j,m+2) cout << dgas[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\trep(i,m+2) rep(j,m+2) rep(k,m+2) dgas[j][k]=min(dgas[j][k],dgas[j][i]+dgas[i][k]);\n\t\tif(dgas[m][m+1]==inf) dgas[m][m+1]=-1;\n\t\tcout << dgas[m][m+1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,m,cap;\nvector<PI> G[4000];\nbool lpg[4000];\nbool vis[4000][4000];\n\nmap<string,int> stoi;\nint getnum(string s){\n  if(stoi.count(s))return stoi[s];\n  int sz=SZ(stoi);\n  return stoi[s]=sz;\n}\n\nvoid solve(){\n  stoi.clear();\n  memset(lpg,0,sizeof(lpg));\n  string src,dest;\n  cin>>src>>dest;\n  int st=getnum(src),go=getnum(dest);\n  \n  rep(i,n+1)G[i].clear();\n  rep(i,n){\n    string p,q;\n    int c;\n    cin>>p>>q>>c;\n    int u=getnum(p);\n    int v=getnum(q);\n    G[u].pb(mp(v,c));\n    G[v].pb(mp(u,c));\n  }\n  rep(i,m){\n    string s;\n    cin>>s;\n    lpg[getnum(s)]=1;\n  }\n\n  memset(vis,0,sizeof(vis));\n  priority_queue<pair<int,PI> >q;\n  q.push(mp(0,mp(cap*10,st)));\n  while(!q.empty()){\n    int cc=-q.top().F;\n    int ca=q.top().S.F;\n    int cv=q.top().S.S;\n\n    q.pop();\n    if(lpg[cv])ca=cap*10;\n    if(vis[cv][ca])continue;\n    vis[cv][ca]=true;\n    if(cv==go){\n      cout<<cc<<endl;\n      return;\n    }\n\n    rep(i,SZ(G[cv])){\n      int to=G[cv][i].F;\n      int co=G[cv][i].S;\n      if(co>ca)continue;\n      int nca=ca-co;\n      if(to>4000 || nca>4000)break;\n      if(vis[to][nca])continue;\n      q.push(mp(-cc-co,mp(nca,to)));\n    }\n  }\n  cout<<-1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>cap,n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 6001\n#define MAX_CP 2001\n#define INF 1e9\n\nstruct State{\n  int dist,v,cap;\n  State(int dist,int v,int cap) \n    : dist(dist),v(v),cap(cap) {}\n\n  bool operator > (const State &s)const{\n    return dist > s.dist;\n  }\n};\n\nstruct Edge{\n  int to,dist;\n  Edge(int to,int dist) : to(to),dist(dist) {}\n};\n\nint N,M,cap,src,dst,idx;\nint dist[MAX][MAX_CP];\nset<int> LPG;\nvector<Edge> G[MAX];\n\nvoid init(){\n  idx = 1;\n  LPG.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    G[i].clear();\n  }\n}\n\nint dijkstra(){\n  cap *= 10;\n \n\n  for(int i = 0 ; i < idx ; i++){\n    for(int j = 0 ; j <= cap ; j++){\n      dist[i][j] = INF;\n    }\n  }\n\n  dist[src][cap] = 0;\n\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(0,src,cap));\n\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v,c = s.cap;\n    \n    if(dist[v][c] < s.dist) continue;\n    \n    if(v == dst){\n      return dist[v][c];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      Edge e = G[v][i];\n      int nc = (LPG.find(v) != LPG.end()) ? cap : c;\n      if(e.dist <= nc){\n        nc -= e.dist;\n        if(dist[v][c] + e.dist < dist[e.to][nc]){\n          dist[e.to][nc] = dist[v][c] + e.dist;\n          Q.push(State(dist[e.to][nc],e.to,nc));\n        }                           \n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int d;\n  string a,b;\n  \n  while(cin >> N >> M >> cap, N){\n    init();\n    map<string,int> mp; \n    cin >> a; mp[a] = src = idx++; \n    cin >> a; mp[a] = dst = idx++; \n    for(int i = 0 ; i < N ; i++){\n      cin >> a >> b >> d;\n      if(mp.find(a) == mp.end()){\n        mp[a] = idx++;\n      }\n      if(mp.find(b) == mp.end()){\n        mp[b] = idx++;\n      }\n      G[mp[a]].push_back(Edge(mp[b],d));\n      G[mp[b]].push_back(Edge(mp[a],d));\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> a;\n      LPG.insert(mp[a]);\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\nshort n, m, k, p, dist[6007][2017], c[3000]; bool u[3000];\nvector<string>v; string a[3000], b[3000], s1, s2; vector<pair<int, int>>x[7000];\nint s(string Y) { return lower_bound(v.begin(), v.end(), Y) - v.begin(); }\nint main() {\n\twhile (true) {\n\t\tcin >> m >> k >> p; p *= 10; if (m + k + p == 0)return 0; v.clear(); cin >> s1 >> s2;\n\t\tfor (int i = 0; i < m; i++) { cin >> a[i] >> b[i] >> c[i]; v.push_back(a[i]); v.push_back(b[i]); }\n\t\tsort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); n = v.size();\n\t\tfor (int i = 0; i < n; i++) { x[i].clear(); u[i] = false; for (int j = 0; j <= p; j++)dist[i][j] = 1e9; }\n\t\tfor (int i = 0; i < m; i++) { int pos1 = s(a[i]), pos2 = s(b[i]); x[pos1].push_back(make_pair(pos2, c[i])); x[pos2].push_back(make_pair(pos1, c[i])); }\n\t\tpriority_queue<tuple<short, short, short>, vector<tuple<short, short, short>>, greater<tuple<short, short, short>>>Q;\n\t\tfor (int i = 0; i < k; i++) { string U; cin >> U; u[s(U)] = true; }\n\t\t\n\t\tQ.push(make_tuple(0, s(s1), p)); dist[s(s1)][p] = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = get<0>(Q.top()), a2 = get<1>(Q.top()), a3 = get<2>(Q.top()); Q.pop();\n\t\t\tfor (pair<int, int>i : x[a2]) {\n\t\t\t\tint cap = a3 - i.second; if (cap < 0)continue; if (u[i.first] == true)cap = p;\n\t\t\t\tif (dist[i.first][cap] > dist[a2][a3] + i.second) {\n\t\t\t\t\tdist[i.first][cap] = dist[a2][a3] + i.second; Q.push(make_tuple(dist[i.first][cap], i.first, cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 1e9; for (int i = 0; i <= p; i++)maxn = min(maxn, (int)dist[s(s2)][i]); if (maxn > 1e8)maxn = -1;\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <string>\n#include <time.h>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pi acos(-1.0)\ntypedef long long ll;\nint n,m,cap;\nstring ssrc,sdest;\nint src,dest;\nstring ss;\nmap<string,int> mp;\nint des[3010];\nstring a[3010];\nstring b[3010];\nstruct node{\n\tint dis;\n\tint to;\n\tnode(int dis,int to):dis(dis),to(to){\n\t}\n};\nset<string>::iterator it;\n\nstruct node1{\n\tint go;\n\tint node;\n};\nqueue<node1>q;\nint num; \nbool flag[6666];\nint dist[6666][2010];\nvector<node>p[6666];\nbool inq[6666][2010];\nvoid getid(string city){\n\tif (mp.find(city) != mp.end())return;\n\tp[num].clear();\n\tmp[city] = num;\n\tnum++;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(flag,0,sizeof(flag));\n\t\tmemset(inq,0,sizeof(inq));\n\t\tscanf(\"%d %d %d\",&n,&m,&cap);\n\t\tnum=0;\n\t\tif(n+m+cap==0)break;\n\t\tmp.clear();\n\t\tcap*=10;\n\t\tcin>>ssrc>>sdest;\n\t\tgetid(ssrc);\n\t\tgetid(sdest);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>a[i]>>b[i]>>des[i];\n             getid(a[i]);\n\t\t\t getid(b[i]);  \n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tp[mp[a[i]]].push_back(node(des[i],mp[b[i]]));\n\t\t\tp[mp[b[i]]].push_back(node(des[i],mp[a[i]]));\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tcin>>ss;\n\t\t\tflag[mp[ss]]=1;\n\t\t}\n     \tsrc=mp[ssrc];\n    \tdest=mp[sdest];\n    \t\n    \t\n    \tfor(int i=0;i<num;i++)\n    \t{\n    \t\tfor(int j=0;j<=cap;j++)\n    \t\tdist[i][j]=inf;\n    \t}\n    \tdist[src][cap]=0;\n    \tnode1 now,then;\n    \tnow.go=cap;\n    \tnow.node=src;\n    \tq.push(now);\n    \t\n    \twhile(!q.empty())\n    \t{\n    \t\tnow=q.front();\n    \t\tq.pop();\n    \t\tinq[now.node][now.go]=0;\n    \t\tthen.go=now.go;\n    \t\tif(flag[now.node]==1)\n    \t\t{\n    \t\t\tthen.go=cap;\n    \t\t}\n    \t\tif(then.go==0)continue;\n    \t\tfor(int i=0;i<p[now.node].size();i++)\n    \t\t{\n    \t\t\tint d=p[now.node][i].dis;\n    \t\t\tint t=p[now.node][i].to;\n    \t\t\tif(then.go>=d&&dist[t][then.go-d]>dist[now.node][now.go]+d)\n    \t\t\t{\n    \t\t\t\tdist[t][then.go-d]=dist[now.node][now.go]+d;\n    \t\t\t\tthen.go-=d;\n    \t\t\t\tthen.node=t;\n    \t\t\t\tif(!inq[then.node][then.go])\n\t\t\t\t\t {\n\t\t\t\t\t q.push(then);\n\t\t\t\t\t inq[then.node][then.go]=1;\n\t\t\t\t      }\n    \t\t\t\tthen.go+=d;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint ans=inf;\n    \tfor(int i=0;i<=cap;i++)ans=min(dist[dest][i],ans);\n    \tif(ans!=inf)printf(\"%d\\n\",ans);else printf(\"-1\\n\");\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int V = 6010;\nconst int E = 3010;\nint n, m, cap;\n\nstruct dot{\n\tint p, oil;\n}front, rear;\n\nstruct edge{\n\tint to, w;\n};\n\nvector<edge> G[V];\nchar s1[20], s2[20];\n\nvoid add_edge(int u, int v, int d){\n\tedge ee;\n\tee.to = v;\n\tee.w = d;\n\tG[u].push_back(ee);\n\tee.to = u;\n\tG[v].push_back(ee);\n}\n\nbool sta[V];\nint dis[V][2010];\n//bool inq[V][2010];\n\nint main () { //freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d%d\", &n, &m, &cap)){\n\t\tif(!n && !m && !cap) break;\n\t\tmap<string, int> city;\n\t\tcap *= 10;\n\t\tscanf(\"%s %s\", s1, s2);\n\t\tcity[string(s1)] = 1;\n\t\tcity[string(s2)] = 2;\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t\tint u, v, d, cou = 2;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%s %s %d\", s1, s2, &d);\n\t\t\tif(!city[string(s1)]) city[string(s1)] = ++cou;\n\t\t\tif(!city[string(s2)]) city[string(s2)] = ++cou;\n\t\t\tu = city[string(s1)];\n\t\t\tv = city[string(s2)];\n\t\t\tadd_edge(u, v, d);\n\t\t}\n\t\tmemset(sta, 0, sizeof(sta));\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%s\", s1);\n\t\t\tif(!city[string(s1)]) continue;\n\t\t\telse sta[city[string(s1)]] = 1;\n\t\t}\n\t\tqueue<dot>q;\n\t\tfront.oil = cap;\n\t\tfront.p = 1;\n\t\tq.push(front);\n\t\tint mmin  = 0x3f3f3f3f;\n\t\t//memset(inq, 0, sizeof(inq));\n\t\tmemset(dis, 0x3f, sizeof(dis));\n\t\tdis[1][cap] = 0;\n\t\tint ok = 0;\n\t\twhile(!q.empty()){\n\t\t\tfront = q.front();\n\t\t\tq.pop();\n\t\t//\tinq[front.p][front.oil] = false;\n\t\t\tif(front.p == 2) {ok = 1; if(dis[2][front.oil] < mmin) mmin = dis[2][front.oil]; continue; }\n\t\t\tfor(int i = 0; i < G[front.p].size(); i++){\n\t\t\t\tif(G[front.p][i].w > front.oil) continue;\n\t\t\t\trear.oil = front.oil -G[front.p][i].w;\n\t\t\t\trear.p = G[front.p][i].to;\n\t\t\t\tif(sta[rear.p]) rear.oil = cap;\n\t\t\t\tif(dis[rear.p][rear.oil] > dis[front.p][front.oil] + G[front.p][i].w){\n\t\t\t\t\tdis[rear.p][rear.oil] = dis[front.p][front.oil] + G[front.p][i].w;\n\t\t\t\t\t//if(!inq[rear.p][rear.oil]){\n\t\t\t\t\t//\tinq[rear.p][rear.oil] = 1;\n\t\t\t\t\t\tq.push(rear);\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(\"-1\");\n\t\telse printf(\"%d\\n\", mmin);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxm = 3001;\nconst int maxn = 3105;\nconst int INF = 0x3ffffff;\nstruct Side{\n\tint to,next,w;\n}side[maxm*2],side1[maxm*2];\nint node1[maxn*2],top,top1,node[maxn];\nvoid add_side(int u,int v,int w){\n\tside[top]=(Side){v,node[u],w};node[u]=top++;\n}\n \nvoid add_side1(int u,int v,int w){\n\tside1[top1]=(Side){v,node1[u],w};node1[u]=top1++;\n\tside1[top1]=(Side){u,node1[v],w};node1[v]=top1++;\n}\nint cap;\nmap<string,int>city;\nint cnt1,cnt,start,end;\nbool is1[maxn],is[maxn];\nint get_id(string str){\n\tif(city.count(str)==0)city[str]=++cnt1;\n\treturn city[str];\n}\nint dis[maxn][2001];\nbool inqueue[maxn][2001];\nqueue<pair<int,int> >q;\nint get_dis(){\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int j=0;j<=cap;j++){\n\t\t\tinqueue[i][j]=false;\n\t\t\tdis[i][j]=INF;\n\t\t}\n\t}\n\tdis[start][cap]=0;\n\tpair<int,int>tmp=make_pair(start,cap);\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttmp=q.front();q.pop();\n\t\tint u=tmp.first;\n\t\tint c=tmp.second;\n\t\tinqueue[u][c]=false;\n\t\tif(c!=cap&&is[u]){\n\t\t\tif(dis[u][c]<dis[u][cap]){\n\t\t\t\tdis[u][cap]=dis[u][c];\n\t\t\t\tif(!inqueue[u][cap]){\n\t\t\t\t\tinqueue[u][cap]=true;\n\t\t\t\t\tq.push(make_pair(u,cap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=node[u];i!=-1;i=side[i].next){\n\t\t\tint v=side[i].to;\n\t\t\tint last=c-side[i].w;\n\t\t\tif(last<0)continue;\n\t\t\tif(dis[u][c]+side[i].w<dis[v][last]){\n\t\t\t\tdis[v][last]=dis[u][c]+side[i].w;\n\t\t\t\tif(!inqueue[v][last]){\n\t\t\t\t\tinqueue[v][last]=true;\n\t\t\t\t\tq.push(make_pair(v,last));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(int i=0;i<=cap;i++){\n\t\tans=min(ans,dis[end][i]);\n\t}\n\treturn ans==INF?-1:ans;\n}\nbool vis[6001];\nint id[maxn*2];\nvoid dfs(int u){\n\tfor(int i=node1[u];i!=-1;i=side1[i].next){\n\t\tint v=side1[i].to;\n\t\tif(!vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d%d%d\",&m,&n,&cap)){\n\t\tif(m==0&&n==0&&cap==0)break;\n\t\tcap=cap*10;\n\t\tcity.clear();\n\t\ttop=0;\n\t\tcnt=0;\n\t\tcnt1=0;\n\t\ttop1=0;\n\t\tmemset(node,-1,sizeof(node));\n\t\tmemset(node1,-1,sizeof(node1));\n\t\tmemset(is,false,sizeof(is));\n\t\tmemset(is1,false,sizeof(is1));\n\t\tmemset(vis,false,sizeof(vis));\n\t\tstring u,v;\n\t\tcin>>u>>v;\n\t\tstart=get_id(u);\n\t\tend=get_id(v);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v;\n\t\t\tint w;\n\t\t\tscanf(\"%d\",&w);\n\t\t\tint x=get_id(u);\n\t\t\tint y=get_id(v);\n\t\t\tadd_side1(x,y,w);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>u;\n\t\t\tis1[get_id(u)]=true;\n\t\t}\n\t\tvis[start]=true;\n\t\tdfs(start);\n\t\tif(!vis[end])printf(\"-1\\n\");\n\t\telse{\n\t\t\tfor(int i=1;i<=cnt1;i++){\n\t\t\t\tif(!vis[i])continue;\n\t\t\t\tid[i]=++cnt;\n\t\t\t}\n\t\t\tfor(int u=1;u<=cnt1;u++){\n\t\t\t\tif(!vis[u])continue;\n\t\t\t\tfor(int i=node1[u];i!=-1;i=side1[i].next){\n\t\t\t\t\tint v=side1[i].to;\n\t\t\t\t\tif(!vis[v])continue;\n\t\t\t\t\tadd_side(id[u],id[v],side1[i].w);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=cnt1;i++){\n\t\t\t\tif(vis[i]&&is1[i])is[id[i]]=true;\n\t\t\t}\n\t\t\tstart=id[start];\n\t\t\tend=id[end];\n\t\t\tprintf(\"%d\\n\",get_dis());\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n,m,cap;\n    cin>>n>>m>>cap;\n    if(!n)break;\n    cap *= 10;\n    set<string> cities;\n    string src,dest;\n    cin>>src>>dest;\n    cities.insert(src);\n    cities.insert(dest);\n    vector<string> fr(n);\n    vector<string> to(n);\n    vector<int> dist(n);\n    REP(i,n){\n      cin>>fr[i]>>to[i]>>dist[i];\n      cities.insert(fr[i]);\n      cities.insert(to[i]);\n    }\n    vector<string> vcty;\n    for(auto& c:cities)vcty.push_back(c);\n    Graph g(vcty.size());\n    int N=vcty.size();\n    REP(i,n){\n      int fi = lower_bound(begin(vcty),end(vcty),fr[i]) - begin(vcty);\n      int ti = lower_bound(begin(vcty),end(vcty),to[i]) - begin(vcty);\n      g[fi].push_back({fi,ti,dist[i]});\n      g[ti].push_back({ti,fi,dist[i]});\n    }\n    vector<int> gas(m);\n    REP(i,m){\n      string nm;\n      cin>>nm;\n      gas[i] = lower_bound(begin(vcty),end(vcty),nm) - begin(vcty);\n    }\n    int bs = lower_bound(begin(vcty),end(vcty), src) - begin(vcty);\n    int bd = lower_bound(begin(vcty),end(vcty), dest) - begin(vcty);\n    Matrix mat(m+2,Array(m+2,INF));\n    REP(i,m){\n      Array d(N);\n      dijkstra(g, d, gas[i]);\n      REP(j,m){\n        if (d[gas[j]] <= cap)\n          mat[i][j] = min(mat[i][j], d[gas[j]]);\n      }\n      if (d[bs] <= cap)\n        mat[i][m] = min(mat[i][m], d[bs]);\n      if (d[bd] <= cap)\n        mat[i][m+1] = min(mat[i][m+1], d[bd]);\n    }\n    {\n      Array d(N);\n      dijkstra(g, d, bs);\n      REP(j,m){\n        if (d[gas[j]] <= cap)\n          mat[m][j] = min(mat[m][j], d[gas[j]]);\n      }\n      if (d[bs] <= cap)\n        mat[m][m] = min(mat[m][m], d[bs]);\n      if (d[bd] <= cap)\n        mat[m][m+1] = min(mat[m][m+1], d[bd]);\n    }\n    {\n      Array d(N);\n      dijkstra(g, d, bd);\n      REP(j,m){\n        if (d[gas[j]] <= cap)\n          mat[m+1][j] = min(mat[m+1][j], d[gas[j]]);\n      }\n      if (d[bs] <= cap)\n        mat[m+1][m] = min(mat[m+1][m], d[bs]);\n      if (d[bd] <= cap)\n        mat[m+1][m+1] = min(mat[m+1][m+1], d[bd]);\n    }\n    REP(k,m+2)REP(i,m+2)REP(j,m+2)\n      mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n    if (mat[m][m+1] < INF)\n      cout << mat[m][m+1] << endl;\n    else\n      cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct E{\n  string t;\n  int d;\n};\n\nstruct S{\n  string v;\n  int r,d;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nint main(){\n  for(int n,mm,cap;cin>>n>>mm>>cap,n|mm|cap;){\n    cap*=10;\n    string src,dest;\n    cin>>src>>dest;\n    map<string,vector<E> > m;\n    for(int i=0;i<n;i++){\n      string c[2];\n      int d;\n      cin>>c[0]>>c[1]>>d;\n      for(int j=0;j<2;j++){\n\tE ce={c[j^1],d};\n\tm[c[j]].push_back(ce);\n      }\n    }\n    set<string> gs;\n    for(int i=0;i<mm;i++){\n      string s;\n      cin>>s;\n      gs.insert(s);\n    }\n    priority_queue<S> que;\n    S is={src,cap,0};\n    que.push(is);\n    map<string,map<int,int> > p;\n    while(!que.empty()){\n      S c=que.top();\n      if(c.v==dest)break;\n      que.pop();\n      if(p[c.v].count(c.r)&&p[c.v][c.r]<=c.d)continue;\n      p[c.v][c.r]=c.d;\n      for(int i=0;i<m[c.v].size();i++){\n\tif(m[c.v][i].d<=c.r){\n\t  S n={m[c.v][i].t,c.r-m[c.v][i].d,c.d+m[c.v][i].d};\n\t  if(gs.count(n.v)){\n\t    n.r=cap;\n\t  }\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.top().d)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nclass Edge{\npublic:\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost){};\n};\n\nvector<int> dijkstra(vector<vector<Edge>>& G, int s){\n    int N = G.size();\n    vector<int> d(N, INF);\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    d[s] = 0;\n    q.push(make_pair(d[s], s));\n    \n    while(!q.empty()){\n        pair<int, int> v = q.top(); q.pop();\n        if(v.first != d[v.second])\n            continue;\n        \n        for(Edge &e: G[v.second]){\n            if(e.cost + d[v.second] < d[e.to]){\n                d[e.to] = e.cost + d[v.second];\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\n\nint N, M, C;\n\nvoid solve(){\n    string src, dst;\n    cin >> src >> dst;\n    \n    map<string, int> stoi;\n    vector<string> cs(N), cd(N);\n    vector<int> ds(N);\n    for(int i=0; i<N; i++){\n        cin >> cs[i] >> cd[i] >> ds[i];\n        \n        if(stoi.find(cs[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cs[i]] = x;\n        }\n        if(stoi.find(cd[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cd[i]] = x;\n        }\n    }\n    \n    vector<int> gass(M);\n    for(int i=0; i<M; i++){\n        string s; cin >> s;\n        gass[i] = stoi[s];\n    }\n    gass.push_back(stoi[src]);\n    gass.push_back(stoi[dst]);\n    M = gass.size();\n    \n    vector<vector<Edge>> G(stoi.size());\n    for(int i=0; i<N; i++){\n        int si = stoi[cs[i]];\n        int di = stoi[cd[i]];\n        \n        G[si].emplace_back(di, ds[i]);\n        G[di].emplace_back(si, ds[i]);\n    }\n    \n    vector<vector<int>> mat(M, vector<int>(M, INF));\n    for(int i=0; i<M; i++)\n        mat[i][i] = 0;\n        \n    for(int i=0; i<M; i++){\n        int gs = gass[i];\n        auto d = dijkstra(G, gs);\n        for(int j=0; j<M; j++){\n            int gd = gass[j];\n            if(d[gd] <= C*10){\n                mat[i][j] = d[gd];\n                mat[j][i] = d[gd];\n            }\n        }\n    }\n    \n    for(int k=0; k<M; k++)\n        for(int i=0; i<M; i++)\n            for(int j=0; j<M; j++)\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n\n    cout << (mat[M-2][M-1] == INF? -1: mat[M-2][M-1]) << endl;\n}\n\nint main(){\n    while(cin >> N >> M >> C, N|M|C)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#define F first\n#define S second\n#define G0(x) get<0>(x)\n#define G1(x) get<1>(x)\n#define G2(x) get<2>(x)\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef tuple<int, int, int> PIII;\n\nconstexpr int N = 3000, M = 300, INF = INT_MAX;\n\nint n, m, cap, dis[2*N+2], tmp_dis[2*N+2];\nunordered_map<string, int> sid;\nvector<PII> adj[2*N+2];\nbool is_lpg[2*N+2];\n\ninline void init() {\n  sid.clear();\n  cap *= 10;\n  memset(is_lpg, 0, sizeof(is_lpg));\n}\ninline int solve() {\n  init();\n  string s0, s1;\n  cin >> s0 >> s1;\n  sid.emplace(s0, 0);\n  adj[0].clear();\n  sid.emplace(s1, 1);\n  adj[1].clear();\n  for(int i = 0; i<n; ++i) {\n    int d;\n    cin >> s0 >> s1 >> d;\n    if(!sid.count(s0)) {\n      adj[sid.size()].clear();\n      sid.emplace(s0, sid.size());\n    }\n    if(!sid.count(s1)) {\n      adj[sid.size()].clear();\n      sid.emplace(s1, sid.size());\n    }\n    int id0 = sid[s0], id1 = sid[s1];\n    adj[id0].emplace_back(id1, d);\n    adj[id1].emplace_back(id0, d);\n  }\n  is_lpg[0] = is_lpg[1] = true;\n  for(int i = 0; i<m; ++i) {\n    cin >> s0;\n    is_lpg[sid[s0]] = true;\n  }\n  int mid = sid.size();\n  fill(dis, dis+mid, INF);\n  priority_queue<PII, vector<PII>, greater<PII>> pq0;\n  pq0.emplace(0, 0);\n  while(!pq0.empty()) {\n    PII nxt0 = pq0.top(); pq0.pop();\n    fill(tmp_dis, tmp_dis+mid, INF);\n    tmp_dis[nxt0.S] = nxt0.F;\n    priority_queue<PIII, vector<PIII>, greater<PIII>> pq1;\n    pq1.emplace(nxt0.F, cap, nxt0.S);\n    while(!pq1.empty()) {\n      PIII nxt1 = pq1.top(); pq1.pop();\n      for(auto &v : adj[G2(nxt1)])\n        if(G1(nxt1) >= v.S && G0(nxt1) + v.S < tmp_dis[v.F]) {\n          tmp_dis[v.F] = G0(nxt1) + v.S;\n          pq1.emplace(tmp_dis[v.F], G1(nxt1)-v.S, v.F);\n        }\n    }\n    for(int i = 0; i<mid; ++i)\n      if(is_lpg[i] && tmp_dis[i] < dis[i]) {\n        dis[i] = tmp_dis[i];\n        pq0.emplace(dis[i], i);\n      }\n  }\n  return (dis[1] == INF) ? -1 : dis[1];\n}\nint main() {\n  while(scanf(\"%d %d %d\", &n, &m, &cap) == 3 && n)\n    printf(\"%d\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct NODE{\n\tint src,dst,cap,weight;\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.weight > b.weight;\n}\nmap<string,int> dic;\nint get(string s){\n\tif( dic.count(s) ) return dic[s];\n\tint k = dic.size();\n\treturn dic[s] = k;\n}\n\nint main(){\n\tint n,m,cap;\n\twhile( cin >> n >> m >> cap&& n ){\n\t\tvector<NODE> g[6010];\n\t\tint LPG[6010] = {};\n\t\tdic.clear();\n\t\tstring s_,g_;\n\t\tcin >> s_ >> g_;\n\t\tint s = get(s_);\n\t\tint gg = get(g_);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a_,b_;\n\t\t\tcin >> a_ >> b_;\n\t\t\tint a = get(a_);\n\t\t\tint b = get(b_);\n\t\t\tint c; cin >> c;\n\t\t\tg[a].push_back({a,b,0,c});\n\t\t\tg[b].push_back({b,a,0,c});\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring x_; cin >> x_;\n\t\t\tint x = get(x_);\n\t\t\tLPG[x] = true;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\tint done[6010]={};\n\t\tfor(int i = 0 ; i < 6010 ; i++) done[i] = -1;\n\t\tQ.push({s,-114514,cap*10,0});\n\t\twhile( Q.size() ){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.cap < 0 ) continue;\n\t\t\tif( q.src == gg ){\n\t\t\t\tcout << q.weight << endl;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t\tif( done[q.src] < q.cap ){\n\t\t\t\tdone[q.src] = q.cap;\n\t\t\t}else continue;\n\t\t\tif( cap*10 != q.cap && LPG[q.src] ){\n\t\t\t\tQ.push({q.src,-114514,cap*10,q.weight});\n\t\t\t}else{\n\t\t\t\tfor( auto e : g[q.src] ){\n\t\t\t\t\tQ.push({e.dst,-114514,q.cap-e.weight,q.weight+e.weight});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tok:;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cassert>\n#define MAX 6000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nstruct P\n{\n  int to,d;\n  P(int to=-1,int d=-1):to(to),d(d){}\n};\n\nstruct Pox\n{\n  int cur,cost,tank;\n  Pox(int cur = -1,int cost = -1,int tank = -1):cur(cur),cost(cost),tank(tank){}\n  bool operator < (const Pox& a)const\n  {\n    if(cost != a.cost)return cost > a.cost;\n    if(tank != a.tank)return tank > a.tank;\n    return cur < a.cur;\n  }\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\n\nbool LPG[MAX];\nint mincost[MAX][2001];\nint N,M,cap;\nstring ssrc,sdest;\nint src,dest;\nVP G[MAX];\nmap<string,int> index;\nint idx;\n\nvoid add_edge(string s,string t,int d)\n{\n  if(index.find(s) == index.end())index[s] = idx++;\n  if(index.find(t) == index.end())index[t] = idx++;\n  int sindex = index[s];\n  int tindex = index[t];\n  G[sindex].push_back(P(tindex,d));\n  G[tindex].push_back(P(sindex,d));\n}\n\n\nint main()\n{\n  while(cin >> N >> M >> cap,N|M|cap)\n    {\n      idx = 0;\n      index.clear();\n      rep(i,MAX)\n\t{\n\t  G[i].clear();\n\t  LPG[i] = false;\n\t  rep(j,2001)mincost[i][j] = (1<<29);\n\t}\n      cin >> ssrc >> sdest;\n      index[ssrc] = idx++;\n      index[sdest] = idx++;\n      src = 0,dest = 1;\n\n      rep(i,N)\n\t{\n\t  string c1,c2;\n\t  int d;\n\t  cin >> c1 >> c2 >> d;\n\t  add_edge(c1,c2,d);\n\t}\n\n      assert(idx <= MAX);\n   \n\n      rep(i,M)\n\t{\n\t  string s;\n\t  cin >> s;\n\t  LPG[index[s]] = true;\n\t}\n\n      int ans = (1<<29);\n      P p;\n      Pox pox;\n      int i;\n      priority_queue<Pox> que;\n      que.push(Pox(src,0,cap*10));\n      mincost[src][cap*10] = 0;\n\n      while(!que.empty())\n\t{\n\t  pox = que.top(); que.pop();\n\t  \n\t  if(ans <= pox.cost)continue;\n\t  \n\t  if(pox.cur == dest)\n\t    {\n\t      ans = min(ans,pox.cost);\n\t      break;\n\t    }\n\n\t  for(i=0;i<G[pox.cur].size();i++)\n\t    {\n\t      p = G[pox.cur][i];\n\t  \n\t      if(p.d > pox.tank)continue;\n\t      if(p.d == pox.tank && !LPG[p.to])continue;\n\n\t      if(mincost[p.to][pox.tank-p.d] > pox.cost + p.d)\n\t\t{\n\t\t  mincost[p.to][pox.tank-p.d] = pox.cost + p.d;\n\t\t  if(LPG[p.to])\n\t\t    que.push(Pox(p.to,mincost[p.to][pox.tank-p.d],cap*10));\n\t\t  else\n\t\t    que.push(Pox(p.to,mincost[p.to][pox.tank-p.d],pox.tank-p.d));\n\t\t    \n\n\t\t}\n\t    }\n\t}\n      ans == (1<<29)?cout << -1 << endl:cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <limits>\n\nusing Bool = bool;\nusing Int = long long int;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n\nBool solve() {\n    Int m, l, cap;\n    std::cin >> m >> l >> cap;\n    if (m == 0) return false;\n    cap *= 10;\n\n    String ss, gs;\n    std::cin >> ss >> gs;\n\n    Int n;\n    Graph<Int> graph;\n\n    Map<String, Int> rev;\n\n    {\n        Vector<String> strs;\n        Vector<Tuple<String, String, Int>> edges(m);\n        for (auto& e : edges) {\n            String us, vs;\n            Int d;\n            std::cin >> us >> vs >> d;\n            e = std::make_tuple(us, vs, d);\n            strs.push_back(us), strs.push_back(vs);\n        }\n\n        std::sort(strs.begin(), strs.end());\n        strs.erase(std::unique(strs.begin(), strs.end()), strs.end());\n        n = strs.size();\n        for (Int i = 0; i < n; ++i) rev[strs[i]] = i;\n\n        graph.resize(n);\n        for (auto& e : edges) {\n            String us, vs;\n            Int d;\n            std::tie(us, vs, d) = e;\n            Int u = rev[us], v = rev[vs];\n\n            graph[u].emplace_back(u, v, d);\n            graph[v].emplace_back(v, u, d);\n        }\n    }\n\n    Int s = rev[ss], g = rev[gs];\n\n    Set<Int> tanks;\n    for (Int i = 0; i < l; ++i) {\n        String vs;\n        std::cin >> vs;\n        tanks.insert(rev[vs]);\n    }\n\n    Vector<Vector<Int>> dist(n, Vector<Int>((cap + 1), INF));\n    dist[s][cap] = 0;\n    MinHeap<Tuple<Int, Int, Int>> heap;\n    heap.emplace(0, s, cap);\n\n    while (!heap.empty()) {\n        Int d, v, c;\n        std::tie(d, v, c) = heap.top();\n        heap.pop();\n        if (dist[v][c] < d) continue;\n\n        for (auto e : graph[v]) {\n            if (e.cost > c ||\n                dist[e.dst][c - e.cost] <= dist[e.src][c] + e.cost) continue;\n            dist[e.dst][c - e.cost] = dist[e.src][c] + e.cost;\n            heap.emplace(dist[e.dst][c - e.cost], e.dst, c - e.cost);\n        }\n\n        if (tanks.count(v) && dist[v][cap] > dist[v][c]) {\n            dist[v][cap] = dist[v][c];\n            heap.emplace(dist[v][cap], v, cap);\n        }\n    }\n\n    Int ans = *std::min_element(dist[g].begin(), dist[g].end());\n\n    std::cout << (ans < INF ? ans : -1) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_V = 4000*2;\nconst int MAX_C = 200*10;\nconst int INF = 1<<29;\n\nint V, C, S, G;\nint dist[MAX_V][MAX_C+1];\nbool has_station[MAX_V];\n\nstruct edge{\n\tint to, cost;\n};\n\nvector<edge> graph[MAX_V];\n\nstruct state{\n\tint v, res, dist;\n};\n\nbool operator<(const state& lhs, const state& rhs){\n\treturn lhs.dist > rhs.dist;\n}\n\nbool init(){\n\tint N, M;\n\tscanf(\"%d%d%d \", &N, &M, &C);\n\tif(N==0 && M==0 && C==0){\n\t\treturn false;\n\t}\n\tC *= 10;\n\tmemset(has_station, false, sizeof(has_station));\n\tfor(int i=0; i<MAX_V; i++){\n\t\tgraph[i].clear();\n\t}\n\n\tchar buf1[20], buf2[20];\n\tscanf(\"%s %s \", buf1, buf2);\n\tstring  start(buf1), goal(buf2);\n\t\n\tmap<string, int> dict;\n\tV = 0;\n\tif(dict.find( start ) == dict.end()){\n\t\tdict[start] = V++;\n\t}\n\tif(dict.find( goal ) == dict.end()){\n\t\tdict[goal] = V++;\n\t}\n\n\tfor(int i=0; i<N; i++){\n\t\tint d;\n\t\tscanf(\"%s %s %d \", buf1, buf2, &d);\n\t\tstring s1(buf1), s2(buf2);\n\t\tif(dict.find( s1 ) == dict.end()){\n\t\t\tdict[s1] = V++;\n\t\t}\n\t\tif(dict.find( s2 ) == dict.end()){\n\t\t\tdict[s2] = V++;\n\t\t}\n\t\tgraph[dict[s1]].push_back( (edge) { dict[s2], d } );\n\t\tgraph[dict[s2]].push_back( (edge) { dict[s1], d } );\n\t}\n\n\tfor(int i=0; i<M; i++){\n\t\tscanf(\"%s \", buf1);\n\t\tstring s(buf1);\n\t\tif(dict.find( s ) == dict.end()){\n\t\t\tdict[s] = V++;\n\t\t}\n\t\thas_station[dict[s]] = true;\n\t}\n\tS = dict[start];\n\tG = dict[goal];\n\treturn true;\n}\n\nint solve(){\n\tfor(int i=0; i<V; i++){\n\t\tfill(dist[i], dist[i]+MAX_C+1, INF);\n\t}\n\t\n\tpriority_queue<state> que;\n\tque.push( (state){S, C, 0} );\n\tdist[S][C] = 0;\n\n\twhile(!que.empty()){\n\t\tstate tp = que.top(); que.pop();\n\t\tint v = tp.v, d = tp.dist, res = tp.res;\n\t\tif(dist[v][res] < d){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<(int)graph[v].size(); i++){\n\t\t\tint u = graph[v][i].to, nd = d + graph[v][i].cost;\n\t\t\tif(res < graph[v][i].cost){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nres = has_station[u] ? C : res - graph[v][i].cost;\n\t\t\tif(nd < dist[u][nres]){\n\t\t\t\tdist[u][nres] = nd;\n\t\t\t\tque.push( (state){u, nres, nd} );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = *min_element(dist[G], dist[G]+C+1);\n\t\n\treturn ans == INF ? -1 : ans;\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n#include<string>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){}\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){}\n  bool operator < (const State &p)const{\n    return d<p.d;\n  }\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint mincost[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(mincost[0],mincost[MAX_V],INF);\n  mincost[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n    if(mincost[now.id][now.c]<now.d)continue;\n    mincost[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      int next=G[now.id][i].to;\n      if(now.c<c)continue;\n\n      que.push(State(now.d+c,now.c-c,next));\n    }\n  }\n  return -1;\n}\n\nvector<string>from,to;\nvector<int>cost;\nmap<string,int>id;\nset<string>v;\n\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear(),from.clear(),to.clear();\n    cost.clear(),id.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.insert(s),v.insert(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.insert(f),v.insert(t);\n    }\n\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n\n    set<string>::iterator it=v.begin();\n    for(int j=0;it!=v.end();it++,j++)id[*it]=j;\n\n\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define f first\n#define s second\n\n#define MAX_V 6000\n#define INF (1<<29)\n\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int to,int cost):to(to),cost(cost){};\n};\n\nstruct State{\n  int d,c,id;\n  State(int d,int c,int id):d(d),c(c),id(id){};\n  bool operator < (const State &p)const{\n    return d>p.d;\n  };\n};\n\nvector<edge>G[MAX_V];\nset<int>st;\nint d[MAX_V][2001];\n\nint dijkstra(int s,int g,int cap){\n\n  priority_queue<State>que;\n  que.push(State(0,cap*10,s));\n  fill(d[0],d[MAX_V],INF);\n  d[s][cap*10]=0;\n\n  while(!que.empty()){\n    State now=que.top();\n    que.pop();\n\n    if(now.d>d[now.id][now.c])continue;\n    if(now.id==g)return now.d;\n    if(st.count(now.id))now.c=cap*10;\n\n    d[now.id][now.c]=now.d;\n\n    for(int i=0;i<G[now.id].size();i++){\n      int c=G[now.id][i].cost;\n      if(now.c-c>=0)\n        que.push(State(now.d+c,now.c-c,G[now.id][i].to));\n    }\n  }\n  return -1;\n}\n\nmap<string,int>id;\nvector<string>v,from,to;\nvector<int>cost;\nint main(void){\n\n  int n,m,c;\n  while(cin >> n >> m >> c,n|m|c){\n\n    string s,dst,f,t;\n    v.clear();\n    from.clear();\n    to.clear();\n    cost.clear();\n    int in;\n\n    cin >> s >> dst;\n    v.pb(s),v.pb(dst);\n\n    for(int i=0;i<n;i++){\n      cin >> f >> t >> in;\n      from.pb(f),to.pb(t),cost.pb(in);\n      v.pb(f),v.pb(t);\n    }\n    sort(all(v));\n    v.erase(unique(all(v)),v.end());\n\n    map<string,int>id;\n    for(int i=0;i<v.size();i++)id[v[i]]=i;\n    for(int i=0;i<v.size();i++)G[i].clear();\n    for(int i=0;i<n;i++){\n      G[id[from[i]]].pb(edge(id[to[i]],cost[i]));\n      G[id[to[i]]].pb(edge(id[from[i]],cost[i]));\n    }\n\n    string a;\n    st.clear();\n    for(int i=0;i<m;i++){\n      cin >> a;\n      if(id.count(a))st.insert(id[a]);\n    }\n\n    cout << dijkstra(id[s],id[dst],c) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    map<int,vector<Node> > nodes;\n    map<int,int> dp[6001]; //dp[city_id][remaining_LPG] = dist;\n\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][0] = 0;\n\n    int dst_id = get_city_id(dst);\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tmap<int,int>::iterator it = dp[to].find(next_remaining_LPG);\n\tif(it != dp[to].end() \n\t   && dp[to][next_remaining_LPG] <= s.dist + dist) continue;\n\n\tit->second = s.dist + dist;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    int res = INF;\n    for(int remaining_LPG = 0;remaining_LPG <= 2000; remaining_LPG++){\n      map<int,int>::iterator it = dp[dst_id].find(remaining_LPG);\n      if(it == dp[dst_id].end()) continue;\n      res = min(it->second,res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<map>\n#include<set>\n\n#define pb push_back\n#define all(a) (a).begin(),a.end()\n#define f first\n#define s second\n#define foreach(it, c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\n#define MAX_V 10000\n#define INF INT_MAX\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\ntypedef pair<int,P>P3;\n//dist,to,cap\n\nint V,d[MAX_V],cap;\nvector<edge>G[MAX_V];\nset<int>st;\n\nvoid dijkstra(int s){\n  priority_queue<P3, vector<P3>, greater<P3> >que;\n  fill(d, d+V, INF);\n  d[s] = 0;\n  que.push(P3(0, P(s,cap*10)));\n\n  while(!que.empty()){\n    P3 p = que.top();\n    que.pop();\n    int v = p.s.f;\n    if(d[v] < p.first)continue;\n    if(st.find(v)!=st.end())p.s.s=cap*10;\n    \n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(d[e.to] > d[v]+e.cost && p.s.s-e.cost>=0){\n\td[e.to] = d[v]+e.cost;\n\tque.push(P3(d[e.to], P(e.to,p.s.s-e.cost)));\n      }\n    }\n  }\n}\n\nint main(void){\n\n  int n,m,cost;\n  string src,dest,to,from;\n  vector<string>node;\n  vector<string>f,t;\n  vector<int>c;\n\n  while(cin >> n >> m >> cap,n|m|cap){\n    node.clear();\n    f.clear();\n    t.clear();\n    c.clear();\n    st.clear();\n\n    cin >> src >> dest;\n    \n    for(int i=0;i<n;i++){\n      cin >> from >> to >> cost;\n      f.pb(from);\n      t.pb(to);\n      c.pb(cost);\n      node.pb(from);\n      node.pb(to);\n    }\n\n    sort(all(node));\n    node.erase(unique(all(node)),node.end());\n\n    V=node.size();\n\n    map<string,int>vnum;\n\n    for(int i=0;i<node.size();i++){\n      vnum[node[i]]=i;\n    }\n    \n    for(int i=0;i<10000;i++)G[i].clear();    \n\n    for(int i=0;i<n;i++){\n      edge e;\n      e.to=vnum[t[i]];\n      e.cost=c[i];\n      G[vnum[f[i]]].pb(e);\n\n      e.to=vnum[from];\n      G[vnum[t[i]]].pb(e);\n    }\n\n\n    for(int i=0;i<m;i++){\n      string name;\n      cin >> name;\n      st.insert(vnum[name]);\n    }\n\n    dijkstra(vnum[src]);\n\n    if(d[vnum[dest]]==INF)cout << -1 << endl;\n    else cout << d[vnum[dest]] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\nconst int maxm = 8005;\nconst int maxn = 6005;\nconst int INF =  0x3f3f3f3f;\nint n,m,cap,st,en;\nint top;\nint head[maxn];\nmap<string,int>has;\nbool gas[maxn];\nbool inq[maxn][2005];\nint dist[maxn][2005];\nint next[maxm];\nint mto[maxm];\nint weight[maxm];\n\nstruct point\n{\n\tint pos;\n\tint cost;\n};\nqueue<point>q;\nvoid addedge(int from,int to,int weightt)\n{\n\tmto[top]=to;\n\tweight[top]=weightt;\n\tnext[top]=head[from];\n\thead[from]=top++;\n}\nbool update(int pos,int ti,int to,int k,int len)\n{\n\tif(dist[to][k]>dist[pos][ti]+len){\n\t\tdist[to][k]=dist[pos][ti]+len;\n \t    return  true;\n \t}\n \treturn false;\n}\nvoid spfa()\n{\n\tpoint now;\n    q=queue<point>();\n\tmemset(dist,0x3f,sizeof(dist));\n\tdist[st][cap]=0;\n\tinq[st][cap]=1;\n\tnow.pos=st;\n\tnow.cost=cap;\n\tq.push(now);\n\twhile(!q.empty())\n\t{\n\t\tnow=q.front();\n\t\tq.pop();\n\t\tinq[now.pos][now.cost]=0;\n\t\tint pos=now.pos;\n\t\tint ti=now.cost;\n\t\tif(gas[pos])\n\t\t{\n\t\t\tdist[pos][cap]=min(dist[pos][cap], dist[pos][ti]);\n\t\t\tti=cap;\n\t\t}\n\t\tfor(int k=head[pos];k!=-1;k=next[k])\n\t\t{\n              int to=mto[k];\n              if(ti>weight[k]&&update(pos,ti,to,ti-weight[k],weight[k]))\n              {\n              \tnow.pos=to;\n              \tnow.cost=ti-weight[k];\n              \tif(!inq[to][now.cost]){\n              \t   q.push(now);\n              \t   inq[now.pos][now.cost]=1;\n              \t}\n              }\n       }\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&cap),(n+m+cap))\n\t{\n\t\tstring a;string b;\n\t\tint cnt=1;\n\t\ttop=0;\n\t\thas.clear();\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(gas,0,sizeof(gas));\n\t\tcin>>a>>b;\n\t\tscanf(\"%d\",&cap);\n\t\tcap*=10;\n\t\tif(has.find(a)==has.end())\n\t\t\thas[a]=cnt++;\n\t\tif(has.find(b)==has.end())\n\t\t\thas[b]=cnt++;\n\t\tst=has[a];\n\t\ten=has[b];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint weight;\n\t\t\tcin>>a>>b>>weight;\n\t\t\tif(has.find(a)==has.end())\n\t\t\t\thas[a]=cnt++;\n\t\t\tif(has.find(b)==has.end())\n\t\t\t\thas[b]=cnt++;\n\t\t\tint nowa=has[a];\n\t\t\tint nowb=has[b];\n\t\t\taddedge(nowa,nowb,weight);\n\t\t\taddedge(nowb,nowa,weight);\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tcin>>a;\n\t\t\tif(has.find(a)==has.end())\n\t\t\t\thas[a]=cnt++;\n\t\t\tint nowa=has[a];\n\t\t\tgas[nowa]=1;\n\t\t}\n\t\tspfa();\n\t\tint ans=INF;\n\t\tfor(int i=0;i<=cap;i++){\n\t\t   if(dist[en][i]<ans)\n\t\t        ans=dist[en][i];\n        }\n\t\tif(ans==INF)\n\t\tprintf(\"-1\\n\");\n\t\telse\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\n\nint N, M, C;\n\ntypedef struct _Edge{\n    int to, dist;\n    _Edge(int to, int dist): to(to), dist(dist){};\n}Edge;\n\ntypedef struct _Node{\n    int v, gas, d;\n    _Node(int v, int gas, int d): v(v), gas(gas), d(d){};\n    bool operator<(const _Node& n)const{return d>n.d;}\n}Node;\n\nint dijkstra(vector<vector<Edge>> &G, set<int> &gass, int src, int dst){\n    int N = G.size();\n    map<pair<int, int>, int> d;\n    set<pair<int, int>> done; //v, gas\n    \n    priority_queue<Node> que;\n    \n    d[{src, C*10}] = 0;\n    que.push(Node(src, C*10, 0));\n    \n    while(!que.empty()){\n        auto node = que.top(); que.pop();\n        if(node.v == dst)\n            return node.d;\n        \n        auto p = make_pair(node.v, node.gas);\n        \n        if(done.find(p) != done.end())\n            continue;\n        done.insert(p);\n             \n        for(auto e: G[node.v]){\n            if(node.gas < e.dist)\n                continue;\n            \n            pair<int, int> np;\n            np.first = e.to;\n            if(gass.find(e.to) != gass.end())\n                np.second = C*10;\n            else\n                np.second = node.gas - e.dist;\n            \n            if(d.find(np) == d.end() || d[p] + e.dist < d[np]){\n                d[np] = d[p] + e.dist;\n                que.push(Node(np.first, np.second, d[np]));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    string src, dst;\n    cin >> src >> dst;\n    \n    map<string, int> stoi;\n    vector<string> cs(N), cd(N);\n    vector<int> ds(N);\n    for(int i=0; i<N; i++){\n        cin >> cs[i] >> cd[i] >> ds[i];\n        \n        if(stoi.find(cs[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cs[i]] = x;\n        }\n        if(stoi.find(cd[i]) == stoi.end()){\n            int x = stoi.size();\n            stoi[cd[i]] = x;\n        }\n    }\n    \n    set<int> gass;\n    for(int i=0; i<M; i++){\n        string s; cin >> s;\n        gass.insert(stoi[s]);\n    }\n    \n    vector<vector<Edge>> G(stoi.size());\n    for(int i=0; i<N; i++){\n        int si = stoi[cs[i]];\n        int di = stoi[cd[i]];\n        \n        G[si].emplace_back(di, ds[i]);\n        G[di].emplace_back(si, ds[i]);\n    }\n    \n    cout << dijkstra(G, gass, stoi[src], stoi[dst]) << endl;\n}\n\nint main(){\n    while(cin >> N >> M >> C, N|M|C)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define inf 999999999\nint ID=0;\nmap<string ,int>mp;\nstring str;\nint n,m,cap,size,len;\nint val[3005][3005];\nint gas[3005];\nint head[3005];\nint dp[2001][3005];\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int V,int NEXT):v(V),next(NEXT){}\n}edge[3005];\nvoid Init(int num)\n{\n    for(int i=1;i<=num;++i)\n    {\n        head[i]=-1;\n    }\n    ID=0;\n    size=0;\n}\n\nvoid InsertEdge(int u,int v)\n{\n    edge[size]=Edge(v,head[u]);\n    head[u]=size++;\n}\n\nint dfs(int u,int father,int gasnum)\n{\n    ///蜉?イケ遶?    if(gas[u])\n        gasnum=cap*10;\n    if(dp[gasnum][u]!=-1)\n        return dp[gasnum][u];\n    /// 扈育せ\n    if(u==2)\n        return dp[gasnum][u]=0;\n    int ret=inf;\n    for(int i=head[u];i != -1;i=edge[i].next)\n    {\n        ///荳倶ク?クェ闃らせ\n        int v=edge[i].v;\n        if(v == father)\n        continue;\n        ///閭ス蛻ー霎セv\n        if(val[u][v]!=-1&&gasnum>=val[u][v])\n        {\n            int ans=dfs(v,u,gasnum-val[u][v])+val[u][v];\n            if(ans<ret)\n            ret=ans;\n        }\n    }\n    return dp[gasnum][u]=ret;\n}\n\nint main()\n{\n    ///freopen(\"in.txt\",\"r\",stdin);\n    int u,v;\n    while(scanf(\"%d%d%d\",&n,&m,&cap)&&(n+m+cap)!=0)\n    {\n        mp.clear();\n        Init(n);\n        cin>>str;\n        mp[str]=1;\n        cin>>str;\n        mp[str]=2;\n        ID=2;\n        memset(val,-1,sizeof val);\n        memset(gas,0,sizeof gas);\n        memset(dp,-1,sizeof dp);\n        while(n--)\n        {\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                u=ID;\n            }\n            else\n                u=mp[str];\n            cin>>str;\n            if(mp[str]==0)\n            {\n                ID++;\n                mp[str]=ID;\n                v=ID;\n            }\n            else\n                v=mp[str];\n            cin>>len;\n            val[u][v]=val[v][u]=len;\n            InsertEdge(u,v);\n            InsertEdge(v,u);\n        }\n        while(m--)\n        {\n            cin>>str;\n            gas[mp[str]]=1;\n        }\n        int ans=dfs(1,-1,cap*10);\n        if(ans==inf)\n            printf(\"-1\\n\");\n        else\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int src,dest;\n    int w;\n};\nusing Graph=vector<vector<Edge>>;\nconst int INF=1e9;\nvector<int> Dijkstra(int s,Graph& g){\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> que;\n    int n=g.size();\n    vector<int> res(n,INF);\n    res[s]=0;\n    que.push({0,s});\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        int v=tmp.second;\n        if(res[v]<tmp.first) continue;\n        for(auto &e:g[v]){\n            if(res[v]+e.w<res[e.dest]){\n                res[e.dest]=res[v]+e.w;\n                que.push({res[e.dest],e.dest});\n            }\n        }\n    }\n    return res;\n}\nint solve(int cap,int s,int d,Graph &g,set<int> &gas){\n    int n=g.size();\n    // for(int i=0;i<n;i++){\n    //     for(int j=0;j<g[i].size();j++){\n    //         cerr<<\"#\"<<i<<\" \"<<g[i][j].dest<<endl;\n    //     }\n    // }\n    Graph sg(n);\n    for(auto v:gas){\n        vector<int> d=Dijkstra(v,g);\n        // cerr<<\"##\"<<v<<endl;\n        // for(int i=0;i<n;i++){\n        //      cerr<<\"#\"<<d[i]<<endl;\n        // }\n        for(auto to:gas){\n            if(d[to]<=cap){\n                sg[v].push_back(Edge{v,to,d[to]});\n            }\n        }\n    }\n    return Dijkstra(s,sg)[d];\n}\nint main(){\n    int n,m,cap;\n    while(cin>>n>>m>>cap,n){\n        cap*=10;\n        map<string,int> dict;\n        int idx=0;\n        auto index=[&](string name){\n            if(dict.count(name)) return dict[name];\n            else return dict[name]=idx++;\n        };\n        string src,dest;\n        cin>>src>>dest;\n        int s=index(src),d=index(dest);\n        vector<Edge> edges(n);\n        for(int i=0;i<n;i++){\n            string a,b;\n            int w;\n            cin>>a>>b>>w;\n            int x=index(a),y=index(b);\n            edges[i].src=x,edges[i].dest=y,edges[i].w=w;\n        }\n        Graph g(idx);\n        for(int i=0;i<n;i++){\n            g[edges[i].src].push_back(edges[i]);\n            swap(edges[i].src,edges[i].dest);\n            g[edges[i].src].push_back(edges[i]);\n        }\n        set<int> gas;\n        for(int i=0;i<m;i++){\n            string name;\n            cin>>name;\n            gas.insert(index(name));\n        }\n        gas.insert(s);\n        gas.insert(d);\n        int ret=solve(cap,s,d,g,gas);\n        cout<<(ret==INF ? -1 : ret)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <complex>\n#include <ctime>\n#include <utility>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n#define EPS 1e-6\n#define LGE 0.434294481903//log10(e)\n#define lll __int64\n#define ll long long\n#define INF 0x7fffffff\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n\ntypedef pair<int,int> pii;\nconst int N=6002;\nconst int N2=6002;\nint node_num,edge_num,start_node,final_node;\nint gap_num,cap;\nint node_first[N],node_next[N2],node_begin[N2],node_end[N2],node_value[N2];\nint distance_[N];\ndouble gap[N];\npriority_queue<pii,vector<pii>,greater<pii> > pq;\nstruct jcc\n{\n    char cc[20];\n    bool operator < (const jcc& a) const\n    {\n        return strcmp(cc,a.cc)==1;//莉主、ァ蛻ー蟆?    }\n};\njcc ctms;\n\nmap<jcc,int> ma;\nmap<jcc,int>::iterator it;\nbool ggap[N];\n\nvoid dijkstra()\n{\n    rep(i,1,node_num)   distance_[i]=INF;\n    distance_[start_node]=0;\n    rep(i,1,node_num)\n    gap[i]=0;\n    gap[start_node]=cap;\n    pq.push(make_pair(distance_[start_node],start_node));\n    while(!pq.empty())\n    {\n        pii pi=pq.top();\n        int x=pi.second;\n        pq.pop();\n        if(pi.first!=distance_[x]) continue;\n        for(int i=node_first[x]; i!=-1; i=node_next[i])\n        {\n            if(gap[x]*10>=node_value[i]&&distance_[node_end[i]]>distance_[x]+node_value[i])\n            {\n                distance_[node_end[i]]=distance_[x]+node_value[i];\n                pq.push(make_pair(distance_[node_end[i]],node_end[i]));\n                if(ggap[node_end[i]]==0) gap[node_end[i]]=(double)max(gap[node_end[i]],gap[x]*10-node_value[i])/10;\n                else    gap[node_end[i]]=cap;\n            }\n        }\n    }\n}\n\nint main()\n{\n    //freopen(\"D:\\\\input.in\",\"r\",stdin);\n    //freopen(\"D:\\\\output.out\",\"w\",stdout);\n    while(scanf(\"%d%d%d\",&edge_num,&gap_num,&cap)&&(edge_num||gap_num||cap))\n    {\n        ma.clear();\n        start_node=1;\n        final_node=2;\n\n        int tj0=1;\n        scanf(\"%s\",ctms.cc);\n        ma.insert(pair<jcc,int>(ctms,tj0++));\n        scanf(\"%s\",ctms.cc);\n        ma.insert(pair<jcc,int>(ctms,tj0++));\n        node_num=edge_num*2;\n        rep(i,1,node_num)\n        {\n            node_first[i]=-1;\n        }\n        int t1,t2,t3;\n        rep(i,1,edge_num)\n        {\n            scanf(\"%s\",ctms.cc);\n            it=ma.find(ctms);\n            if(it!=ma.end())\n            {\n                t1=(*it).second;\n            }\n            else\n            {\n                t1=tj0;\n                ma.insert(pair<jcc,int>(ctms,tj0++));\n            }\n            scanf(\"%s\",ctms.cc);\n            it=ma.find(ctms);\n            if(it!=ma.end())\n            {\n                t2=(*it).second;\n            }\n            else\n            {\n                t2=tj0;\n                ma.insert(pair<jcc,int>(ctms,tj0++));\n            }\n            scanf(\"%d\",&t3);\n            node_begin[i]=t1;\n            node_end[i]=t2;\n            node_value[i]=t3;\n            node_next[i]=node_first[node_begin[i]];\n            node_first[node_begin[i]]=i;\n            node_begin[i+edge_num]=node_end[i];\n            node_end[i+edge_num]=node_begin[i];\n            node_value[i+edge_num]=node_value[i];\n            node_next[i+edge_num]=node_first[node_begin[i+edge_num]];\n            node_first[node_begin[i+edge_num]]=i+edge_num;\n        }\n        node_num=tj0-1;\n        rep(i,1,node_num)\n        ggap[i]=0;\n        rep(i,1,gap_num)\n        {\n            scanf(\"%s\",ctms.cc);\n            it=ma.find(ctms);\n            ggap[(*it).second]=1;\n        }\n        dijkstra();\n        if(distance_[final_node]==INF)  puts(\"-1\");\n        else printf(\"%d\\n\",distance_[final_node]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[3001][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    map<string, int> str2int;\n    vector<vector<Edge>> graph(N);\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n#if 1\n      int c1, c2;\n      if(str2int.count(c1_s)) {\n        c1 = str2int[c1_s];\n      }\n      else {\n        c1 = str2int.size();\n        str2int[c1_s] = c1;\n      }\n      if(str2int.count(c2_s)) {\n        c2 = str2int[c2_s];\n      }\n      else {\n        c2 = str2int.size();\n        str2int[c2_s] = c2;\n      }\n      graph[c1].emplace_back(c2, d);\n      graph[c2].emplace_back(c1, d);\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      LPG.insert(str2int[s]);\n    }\n    cout << -1 << endl;\n    continue;\n    int src = str2int[src_s];\n    int dst = str2int[dst_s];\n    for(int i = 0; i < 3000 + 1; ++i) {\n      for(int j = 0; j < 2000 + 1; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(node.v == dst) break;\n      int curcap = node.cap;\n      if(LPG.count(node.v)) {\n        // cerr << \"cap\" << endl;\n        curcap = cap;\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = curcap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N,M,Cap;\nstring S,D;\n\nstruct Node{\n\tdouble rem,total;\n};\n\nbool operator < (Node a,Node b){\n\treturn a.total>b.total;\n}\n\nstruct Info{\n\tNode node;\n\tint pos;\n};\n\nbool operator < (Info a,Info b){\n\treturn a.node.total>b.node.total;\n}\n\nint cost[6000][6000];\nbool sta[6000];\n\nvoid solve(){\n\tmemset(cost,-1,sizeof(cost));\n\tmemset(sta,false,sizeof(sta));\n\tmap<string,int> Idx;\n\tcin>>S>>D;\n\tIdx[S]=1;Idx[D]=2;\n\tint size=2;\n\n\tvector<vector<int> > Cost(2);\n\n\tfor(int i=0;i<N;i++){\n\t\tstring in,out; int d;\n\t\tcin>>in>>out; cin>>d;\n\t\tif(Idx[in]==0) Idx[in]=++size;\n\t\tif(Idx[out]==0) Idx[out]=++size;\n\t\tcost[Idx[in]-1][Idx[out]-1]=cost[Idx[out]-1][Idx[in]-1]=d;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tstring t;cin>>t;\n\t\tsta[Idx[t]-1]=true;\n\t}\n\n\tvector<vector<Node> > V(size);\n\tpriority_queue<Info> Q;\n\tInfo f;\n\tf.node.rem=Cap;\n\tf.node.total=0;\n\tf.pos=Idx[S]-1;\n\tQ.push(f);\n\n\twhile(!Q.empty()){\n\t\tInfo now=Q.top();\n\t\tQ.pop();\n\t\tif(now.pos==1){cout<<now.node.total<<endl;return;}\n\n\t\tbool ok=true;\n\t\tfor(int i=0;i<V[now.pos].size();i++){\n\t\t\tif(now.node.rem<V[now.pos][i].rem && now.node.total>=V[now.pos][i].total){\n\t\t\t\tok=false; break;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tV[now.pos].push_back(now.node);\n\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(cost[now.pos][i]<0) continue;\n\t\t\tInfo next;\n\t\t\tif(sta[now.pos]){\n\t\t\t\tnext.node.rem=Cap;\n\t\t\t\tnext.node.total=now.node.total+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.node.rem=now.node.rem-(double)cost[now.pos][i]/10.0;\n\t\t\t\tif(next.node.rem<0) continue; \n\t\t\t\tnext.node.total=now.node.total+cost[now.pos][i];\n\t\t\t\tnext.pos=i;\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n\nint main()\n{\n\twhile(cin>>N>>M>>Cap){\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist > s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist < s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(s.city_id == dst_id){\n\tres = s.dist;\n\tgoto found;\n      }\n      dp[s.city_id][s.remaining_LPG] = true;\n\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n  found:;\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> HP(N);\n    for(int i = 0; i < N; ++i){\n      cin >> HP[i];\n    }\n    int M;\n    cin >> M;\n    vector<int> single_d, single_mp, all_d, all_mp;\n    string name, target;\n    int mp, damege;\n    for(int i = 0; i < M; ++i){\n      cin >> name >> mp >> target >> damege;\n      if(target == \"Single\"){\n        single_d.push_back(damege);\n        single_mp.push_back(mp);\n      }else{\n        all_d.push_back(damege);\n        all_mp.push_back(mp);\n      }\n    }\n    long long int INF = 1e10, n = 2e5;\n    vector<int> dp1(n,INF), dp2(n,INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < single_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp1[j] >= INF) continue;\n        if(j + single_d[i] < n)\n          dp1[j + single_d[i]] = min(dp1[j + single_d[i]], dp1[j] + single_mp[i]);\n        else\n          dp1[n-1] = min(dp1[n-1], dp1[j] + single_mp[i]);\n      }\n    }\n    for(int i = n-2; i >= 0; --i) dp1[i] = min(dp1[i], dp1[i+1]);\n    for(int i = n-2; i >= 0; --i) dp2[i] = min(dp2[i], dp2[i+1]);\n    \n    for(int i = 0; i < all_d.size(); ++i){\n      for(int j = 0; j < n; ++j){\n        if(dp2[j] >= INF) continue;\n        if(j + all_d[i] < n)\n          dp2[j + all_d[i]] = min(dp2[j + all_d[i]], dp2[j] + all_mp[i]);\n        else\n          dp2[n-1] = min(dp2[n-1], dp2[j] + all_mp[i]);\n      }\n    }\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      if(dp2[i] >= INF) continue;\n      long long int t = dp2[i];\n      for(int j = 0; j < N; ++j){\n        t += dp1[max(0,HP[j] - i)];\n      }\n      ans = min(ans,t);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 3001;\nconst int MAX_CAP = 202;\n\nstruct Edge {\n  int to, cost;\n  Edge() {}\n  Edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct State {\n  int p, cost, oil;\n  State() {}\n  State(int p, int cost, int oil) : p(p), cost(cost), oil(oil) {}\n  bool operator < (const State &s) const {\n    if(cost != s.cost) return cost > s.cost;\n    if(oil != s.oil) return oil < s.oil;\n    return p < s.p;\n  }\n};\n\nint Cap, num, Src, Dist;\n\nmap<string, int> id;\nvector<Edge> E[MAX_N];\n\nbool existS[MAX_N];\nint cost[MAX_N][MAX_CAP];\n\nint getId(string s) {\n  if(id.find(s) == id.end()) {\n    id[s] = num++;\n  }\n  return id[s];\n}\n\n\nint solve() {\n  priority_queue<State> que;\n  State s(Src, 0, Cap);\n  que.push(s);\n  fill(cost[0], cost[num], -1);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.oil] != -1) continue;\n    cost[s.p][s.oil] = s.cost;\n    if(s.p == Dist) return s.cost;\n    if(existS[s.p]) s.oil = Cap;\n\n    for(int i = 0; i < E[s.p].size(); ++i) {\n      int nextOil = s.oil - E[s.p][i].cost;\n      if(nextOil < 0) continue;\n      if(cost[E[s.p][i].to][nextOil] != -1) continue;\n      que.push(State(E[s.p][i].to, s.cost + E[s.p][i].cost, nextOil));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int N, M;\n  while(cin >> N >> M >> Cap && (N | M | Cap)) {\n    num = 0;\n    Cap *= 10;\n    id.clear();\n    for(int i = 0; i < MAX_N; ++i) E[i].clear();\n\n    string src, dist;\n    cin >> src >> dist;\n    Src = getId(src);\n    Dist = getId(dist);\n    for(int i = 0; i < N; ++i) {\n      string from, to;\n      int d;\n      cin >> from >> to >> d;\n      E[getId(from)].push_back(Edge(getId(to), d));\n      E[getId(to)].push_back(Edge(getId(from), d));\n    }\n\n    fill(existS, existS+num, false);\n    for(int i = 0; i < M; ++i) {\n      string name;\n      cin >> name;\n      existS[getId(name)] = true;\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nmap<string,int> cities;\nint dp[301][3001]; //dp[city_id][consumed_LPG] = dist;\nint nodes[3001][3001];\nbool is_LPG[3001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int consumed_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    consumed_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    memset(nodes,0x3f,sizeof(nodes));\n    memset(dp,0x3f,sizeof(dp));\n    memset(is_LPG,false,sizeof(is_LPG));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n      nodes[from_num][to_num] = dist;\n      nodes[to_num][from_num] = dist;\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,0));\n    dp[get_city_id(src)][0] = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to=0;to<cities.size();to++){\n\tif(nodes[s.city_id][to] >= INF) continue;\n\tif(capacity*10 < s.consumed_LPG + nodes[s.city_id][to]) continue;\n\tint next_consumed_LPG = (is_LPG[to] ? 0 : (s.consumed_LPG + nodes[s.city_id][to]));\n\n\tif(dp[to][next_consumed_LPG]\n\t   <= s.dist + nodes[s.city_id][to]) continue;\n\n\tdp[to][next_consumed_LPG] = s.dist + nodes[s.city_id][to];\n\tque.push(State(to,s.dist + nodes[s.city_id][to],next_consumed_LPG));\n      }\n    }\n\n    int dst_id = get_city_id(dst);\n    int res = INF;\n    for(int consumed_LPG = 0;consumed_LPG <= 3000; consumed_LPG++){\n      res = min(dp[dst_id][consumed_LPG],res);\n    }\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n \n \nclass DP{\npublic:\n    int cost, gas, state;\n     \n    DP(){}\n    DP(int st, int g, int cc){\n        cost = cc;state=st;gas=g;\n    }\n     \n    bool operator< (const DP &opp) const {\n        return cost>opp.cost;\n    }\n};\n \nstruct edge{\n    int to;\n    int dist;\n};\n \nint N, M, C;\n\nbool visit[6000][2001];\nmain(){\n    int i,j;\n    while(cin >> N >> M >> C, N){\n        string ss,gg;\n        int s, g;\n        cin >> ss >> gg;\n        vector< vector<edge> > E(N*2);\n        map<string, int> idx;\n        set<int> stations;\n        for(i=0;i<N;i++){\n            string from, to;\n            int dist;\n            cin >> from >> to >> dist;\n            if(!idx.count(from)){\n                idx[from] = idx.size() - 1;\n            }\n            if(!idx.count(to)){\n                idx[to] = idx.size() - 1;\n            }\n            E[idx[from]].push_back((edge){idx[to], dist});\n            E[idx[to]].push_back((edge){idx[from], dist});\n        }\n        for(i=0;i<M;i++){\n            string sta;\n            cin >> sta;\n            stations.insert(idx[sta]);\n        }\n        s = idx[ss];g = idx[gg];\n         \n        priority_queue<DP> dp;\n        DP S;\n        dp.push(DP(s, C*10, 0));\n        REP(i, N*2) REP(j, C*10+1) visit[i][j] = false;\n        visit[s][C*10] = true;\n        while(!dp.empty()){\n            S = dp.top();\n            dp.pop();\n            if(S.state == g) break;\n            FOR(it, E[S.state]){\n                if(S.gas < it->dist) continue;\n                DP T=S;\n                T.state = it->to;\n                if(stations.count(it->to)) T.gas = C*10;\n                else T.gas -= it->dist;\n                T.cost += it->dist;\n                if(!visit[it->to][T.gas]){\n                    dp.push(T);\n                    visit[it->to][T.gas] = true;\n                }\n            }\n        }\n        cout << ((S.state == g) ? S.cost : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dis[6100];\nvector<P> g[6100];\nint g2[310][310];\nmap<string,int> id;\nvector<int> gas;\nint n,m,cap,d;\nstring a,b;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> n >> m >> cap,n||m||cap){\n    id.clear(); gas.clear();\n    for(int i=0;i<6100;i++)g[i].clear();\n    \n    cin >> a >> b;\n    id[a] = id.size(); id[b] = id.size();\n    gas.push_back(1); gas.push_back(2);\n\n    for(int i=0;i<n;i++){\n      cin >> a >> b >> d;\n      if(id.find(a) == id.end())id[a] = id.size();\n      if(id.find(b) == id.end())id[b] = id.size();\n      g[id[a]].push_back(P(d,id[b]));\n      g[id[b]].push_back(P(d,id[a]));\n    }\n    for(int i=0;i<m;i++){\n      cin >> a;\n      gas.push_back(id[a]);\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<gas.size();j++)g2[i][j] = INF;\n      g2[i][i] = 0;\n    }\n\n    for(int i=0;i<gas.size();i++){\n      for(int j=0;j<=id.size();j++)dis[j] = INF;\n      dis[gas[i]] = 0;\n      priority_queue<P,vector<P>,greater<P> > q;\n      q.push(P(0,gas[i]));\n      \n      while(q.size()){\n\tP p = q.top();q.pop();\n\tint dist = p.first;\n\tint pos = p.second;\n\t\n\tfor(int x=0;x<g[pos].size();x++){\n\t  int tdis = dist + g[pos][x].first;\n\t  int nxt = g[pos][x].second;\n\t  if(dis[nxt] > tdis){\n\t    dis[nxt] = tdis;\n\t    q.push(P(tdis,nxt));\n\t  }\n\t}\n      }\n      for(int j=0;j<gas.size();j++){\n\tif(cap*10<dis[gas[j]])continue;\n\tg2[i][j] = dis[gas[j]];\t\n      }\n    }\n\n    for(int k=0;k<gas.size();k++)\n      for(int i=0;i<gas.size();i++)\n\tfor(int j=0;j<gas.size();j++)\n\t  g2[i][j] = min(g2[i][j],g2[i][k] + g2[k][j]);\n\n    if(g2[0][1] == INF)cout << -1 << endl;\n    else cout << g2[0][1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<set>\n#include<map>\n#include<limits>\nusing namespace std;\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define output freopen(\"output.txt\",\"w\",stdout)\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_NULL(a) memset(a,NULL,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define ll long long\n#define eps\n#define MOD\n#define MAXN\n#define N 3010\n#define M\nstruct Pre\n{\n    int cost;\n    int realcost;\n}pre[N][N];\nint len[N];\nstruct Vertex\n{\n    int realcost;\n    int cost;\n    int id;\n    friend bool operator<(const Vertex a,const Vertex b)\n    {\n        if(a.cost!=b.cost) return a.cost>b.cost;\n        else return a.realcost>b.realcost;\n    }\n}v,newv,vt;\npriority_queue<Vertex>q;\nstruct Edge\n{\n    int from;\n    int next;\n    int to;\n    int cost;\n}edge[2*N];\nbool oil[N];\nint head[N];\nint cost[N];\nint realcost[N];\nint n,m,cap;\nint mostdis;\nint ans;\nmap<string,int>m1;\nmap<int,string>m2;\nstring sta;\nstring des;\nbool is_ok(int id,int nowcost,int nowrealcost)\n{\n    int l=len[id];\n    if(l==0) return true;\n    repin(i,1,l)\n    {\n        if(nowcost>=pre[id][i].cost && nowrealcost>=pre[id][i].realcost) continue;\n        return true;\n    }\n    return false;\n}\nvoid dijkstra()\n{\n    clr_queue(q);\n    v.id=1;\n    v.cost=0;\n    v.realcost=0;\n    q.push(v);\n    clr_INT(cost);\n    cost[1]=0;\n    clr_INT(realcost);\n    cost[1]=0;\n    int i,now,to,cos;\n    clr(len);\n    len[1]++;\n    pre[1][len[1]].cost=0;\n    pre[1][len[1]].realcost=0;\n    while(!q.empty())\n    {\n        v=q.top();\n        q.pop();\n        now=v.id;\n        for(i=head[now];i!=-1;i=edge[i].next)\n        {\n            to=edge[i].to;\n            cos=edge[i].cost;\n            if(v.cost+cos<=mostdis)\n            {\n                newv.id=to;\n                newv.cost=v.cost+cos;\n                if(oil[to]) newv.cost=0;\n                newv.realcost=v.realcost+cos;\n                if(!is_ok(to,newv.cost,newv.realcost)) continue;\n                q.push(newv);\n                len[to]++;\n                pre[to][len[to]].cost=newv.cost;\n                pre[to][len[to]].realcost=newv.realcost;\n            }\n        }\n    }\n}\nint main()\n{\n//    input;\n    string cc1,cc2;\n    int d,w,a,c1=1,c2=1,t;\n    while(~scanf(\"%d %d %d\",&n,&m,&cap) && (n+m+cap))\n    {\n        mostdis=cap*10;\n        w=0;\n        a=0;\n        clr_minus1(head);\n        m1.clear();\n        m2.clear();\n        cin>>sta>>des;\n        a++;\n        m1[sta]=a;\n        m2[a]=sta;\n        a++;\n        m1[des]=a;\n        m2[a]=des;\n        repin(i,1,n)\n        {\n            cin>>cc1>>cc2;\n            if(!m1[cc1])\n            {\n                a++;\n                c1=a;\n                m1[cc1]=a;\n                m2[a]=cc1;\n            }\n            else c1=m1[cc1];\n            if(!m1[cc2])\n            {\n                a++;\n                c2=a;\n                m1[cc2]=a;\n                m2[a]=cc2;\n            }\n            else c2=m1[cc2];\n            scanf(\"%d\",&d);\n            edge[w].from=c1;\n            edge[w].to=c2;\n            edge[w].cost=d;\n            edge[w].next=head[c1];\n            head[c1]=w++;\n            \n            edge[w].from=c2;\n            edge[w].to=c1;\n            edge[w].cost=d;\n            edge[w].next=head[c2];\n            head[c2]=w++;\n        }\n        clr_false(oil);\n        repin(i,1,m)\n        {\n            cin>>cc1;\n            t=m1[cc1];\n            oil[t]=true;\n        }\n        dijkstra();\n        ans=INT;\n        repin(i,1,len[2])\n        {\n            ans=min(ans,pre[2][i].realcost);\n        }\n        if(ans==INT) cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{int to,cost;};\n#define INF (1<<28)\n#define MAX_N 6005\n#define MAX_L 2005\nstruct state{\n  int pos,pos2,cost;\n  bool operator < ( const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nint n,m,l,cnt;\nstring si,ti,str;\nvector<edge> G[MAX_N];\nbool flg[MAX_N];\nmap<string,int> change;\n\nint d[MAX_N][MAX_L];\n\nint solve(int si,int ti){\n  for(int i=0;i<cnt;i++)\n    for(int j=0;j<=l*10;j++)\n      d[i][j]=INF;\n  d[1][l*10]=0;\n  priority_queue< state > Q;\n  Q.push((state){si,l*10,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.pos==ti)return s.cost;\n    if(s.cost>d[s.pos][s.pos2])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      int ncost=s.cost+e.cost;\n      int npos=e.to;\n      int npos2=s.pos2-e.cost;\n      if(npos2<0)continue;\n      \n      if(flg[npos])npos2=l*10;\n      if(ncost<d[npos][npos2]){\n        d[npos][npos2]=ncost;\n        Q.push((state){npos,npos2,ncost});\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  change.clear();\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    flg[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l;\n    if(n==0&&m==0&&l==0)break;\n    cin>>si>>ti;\n    init();\n    cnt=1;\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int a=change[str];\n      cin>>str;\n      if(change[str]==0)\n        change[str]=cnt++;\n      int b=change[str];\n      int c;\n      cin>>c;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<m;i++){\n      cin>>str;\n      flg[change[str]]=true;\n    }\n    cout<<solve(change[si],change[ti])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nbool dp[6001][2001]; //dp[city_id][remaining_LPG] = dist;\n\nclass Node {\npublic:\n  int to;\n  int dist;\n  Node() : to(0),dist(0){}\n  Node(int _t,int _d) : to(_t),dist(_d){}\n};\n\nmap<string,int> cities;\nbool is_LPG[6001];\n\nint get_city_id(const string& city){\n  if(cities.find(city) == cities.end()){\n    int idx = cities.size();\n    cities[city] = idx;\n  }\n  return cities[city];\n}\n\nclass State {\npublic:\n  int city_id;\n  int dist;\n  int remaining_LPG;\n  State(int _city_id,int _dist,int _con){\n    city_id = _city_id;\n    dist = _dist;\n    remaining_LPG = _con;\n  }\n\n  bool operator <(const State& s) const{\n    return (dist < s.dist);\n  }\n\n  bool operator >(const State& s) const{\n    return (dist > s.dist);\n  }\n};\n\nint main(){\n  int total_roads;\n  int total_LPG_stations;\n  int capacity;\n  while(~scanf(\"%d %d %d\",\n\t       &total_roads,\n\t       &total_LPG_stations,\n\t       &capacity)){\n    if(total_roads == 0\n       && total_LPG_stations == 0\n       && capacity == 0) break;\n\n    cities.clear();\n\n    vector<Node> nodes[6001];\n\n    memset(is_LPG,false,sizeof(is_LPG));\n    memset(dp,false,sizeof(dp));\n\n    string src,dst;\n    cin >> src >> dst;\n    get_city_id(src);\n    get_city_id(dst);\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      string from_str,to_str;\n      int dist;\n\n      cin >> from_str >> to_str >> dist;\n      int from_num = get_city_id(from_str);\n      int to_num = get_city_id(to_str);\n\n      nodes[from_num].push_back(Node(to_num,dist));\n      nodes[to_num].push_back(Node(from_num,dist));\n    }\n\n    for(int LPG_idx = 0; LPG_idx < total_LPG_stations; LPG_idx++){\n      string city;\n      cin >> city;\n      is_LPG[get_city_id(city)] = true;\n    }\n\n    is_LPG[get_city_id(dst)] = true;\n    \n    priority_queue<State,vector<State>, greater<State> > que;\n    que.push(State(get_city_id(src),0,10*capacity));\n    dp[get_city_id(src)][10*capacity] = true;\n\n    int dst_id = get_city_id(dst);\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      for(int to_idx=0;to_idx<nodes[s.city_id].size();to_idx++){\n\tint to = nodes[s.city_id][to_idx].to;\n\tint dist = nodes[s.city_id][to_idx].dist;\n\tint next_remaining_LPG = s.remaining_LPG - dist;\n\tif(next_remaining_LPG < 0) continue;\n\n\tnext_remaining_LPG = (is_LPG[to] ? 10 * capacity : s.remaining_LPG - dist);\n\tif(dp[to][next_remaining_LPG]) continue;\n\n\tif(to == dst_id){\n\t  res = s.dist + dist;\n\t  break;\n\t}\n\tdp[to][next_remaining_LPG] = true;\n\tque.push(State(to,s.dist + dist,next_remaining_LPG));\n      }\n    }\n\n    printf(\"%d\\n\",res >= INF ? -1 : res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Node {\n  int v, cap, cost;\n  Node(int v_, int cap_, int cost_) : v(v_), cap(cap_), cost(cost_) { }\n  bool operator >(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nstruct Edge {\n  int to, cost;\n  Edge(int to_, int cost_) : to(to_), cost(cost_) { }\n};\n\nint D[6000][2001];\n\nint main() {\n  while(true) {\n    int N, M, cap;\n    cin >> N >> M >> cap;\n    cap *= 10;\n    if(N == 0 && M == 0) break;\n    string src_s, dst_s;\n    cin >> src_s >> dst_s;\n    vector<pair<pair<string,string>,int>> edges;\n    vector<string> names;\n    for(int i = 0; i < N; ++i) {\n      string c1_s, c2_s; int d;\n      cin >> c1_s >> c2_s >> d;\n      edges.push_back(make_pair(make_pair(c1_s, c2_s), d));\n      names.push_back(c1_s);\n      names.push_back(c2_s);\n    }\n    names.push_back(src_s);\n    names.push_back(dst_s);\n    sort(names.begin(), names.end());\n    names.erase(unique(names.begin(), names.end()), names.end());\n#if 0\n    for(int i = 0; i < (int)names.size(); ++i) {\n      cerr << \"names[\" << i << \"] = \" << names[i] << endl;\n    }\n#endif\n    vector<vector<Edge>> graph(names.size());\n    for(int i = 0; i < N; ++i) {\n      int c1 = lower_bound(names.begin(), names.end(), edges[i].first.first) - names.begin();\n      int c2 = lower_bound(names.begin(), names.end(), edges[i].first.second) - names.begin();\n      int d = edges[i].second;\n#if 1\n      graph[c1].push_back(Edge(c2, d));\n      graph[c2].push_back(Edge(c1, d));\n#endif\n    }\n#if 0\n    for(auto item : str2int) {\n      cerr << item.first << \" -> \" << item.second << endl;\n    }\n    for(int i = 0; i < (int)graph.size(); ++i) {\n      for(int j = 0; j < (int)graph[i].size(); ++j) {\n        cerr << i << \" \" << graph[i][j].to << \" \" << graph[i][j].cost << endl;\n      }\n    }\n#endif\n    set<int> LPG;\n    for(int i = 0; i < M; ++i) {\n      string s; cin >> s;\n      int k = lower_bound(names.begin(), names.end(), s) - names.begin();\n      LPG.insert(k);\n    }\n    int src = lower_bound(names.begin(), names.end(), src_s) - names.begin();\n    int dst = lower_bound(names.begin(), names.end(), dst_s) - names.begin();\n    for(int i = 0; i < 6000; ++i) {\n      for(int j = 0; j < 2001; ++j) {\n        D[i][j] = INF;\n      }\n    }\n    priority_queue<Node, vector<Node>, greater<Node>> Q;\n    D[src][cap] = 0;\n    Q.emplace(src, cap, 0);\n    while(!Q.empty()) {\n      Node node = Q.top(); Q.pop();\n      // cerr << \"(\" << node.v << \",\" << node.cap << \",\" << node.cost << \")\" << endl;\n      if(LPG.count(node.v)) {\n        if(D[node.v][cap] > D[node.v][node.cap]) {\n          D[node.v][cap] = D[node.v][node.cap];\n          Q.emplace(node.v, cap, D[node.v][cap]);\n        }\n      }\n      for(Edge &e : graph[node.v]) {\n        int newcap = node.cap - e.cost;\n        // cerr << \"move \" << e.to << \" \" << newcap << endl;\n        if(newcap < 0) continue;\n        if(D[e.to][newcap] > D[node.v][node.cap] + e.cost) {\n          // cerr << \"push\" << endl;\n          D[e.to][newcap] = D[node.v][node.cap] + e.cost;\n          Q.emplace(e.to, newcap, D[e.to][newcap]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i <= cap; ++i) {\n      ans = min(ans, D[dst][i]);\n    }\n    if(ans == INF) {\n      cout << -1 << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nbool visit[6001][2001];\nvector<pii> edge[6001];\n//vector<int> mst;\nbool mst[6001];\nstruct node {\n\tint id, cap, dist;\n\tnode(int i, int c, int d) {\n\t\tid = i;\n\t\tcap = c;\n\t\tdist = d;\n\t}\n};\n\nbool operator<(const node& lhs, const node& rhs) {\n\treturn lhs.dist > rhs.dist;\n}\n\nint main() {\n\tint n, m, cap;\n\twhile(cin >> n >> m >> cap, n and m and cap) {\n\t\tmemset(visit, 0, sizeof(visit));\n//\t\tmst.clear();\n\t\tmemset(mst, 0, sizeof(mst));\n\t\tcap *= 10;\n\t\tmap<string, int> mp;\n\t\trep(i, 2*n) edge[i].clear();\n\t\tstring start, goal;\n\t\tcin >> start >> goal;\n\t\trep(i, n) {\n\t\t\tstring a, b;\n\t\t\tint d;\n\t\t\tcin >> a >> b >> d;\n\t\t\tif( mp.find(a) == mp.end() ) mp[a] = mp.size();\n\t\t\tif( mp.find(b) == mp.end() ) mp[b] = mp.size();\n\t\t\tedge[ mp[a] ].push_back(pii(mp[b], d));\n\t\t\tedge[ mp[b] ].push_back(pii(mp[a], d));\n\t\t}\n\t\trep(i, m) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n//\t\t\tmst.push_back(mp[s]);\n\t\t\tmst[mp[s]] = true;\n\t\t}\n//\t\tsort(mst.begin(), mst.end());\n\t\tpriority_queue<node> que;\n\t\tque.push( node(mp[start], cap, 0) );\n\t\tbool found = false;\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( visit[ nd.id ][ nd.cap ] ) continue;\n\t\t\tvisit[nd.id][nd.cap] = true;\n\t\t\tif( nd.id == mp[goal] ) {\n\t\t\t\tcout << nd.dist << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( /*binary_search(mst.begin(), mst.end(), nd.id)*/ mst[nd.id] and !visit[nd.id][cap] ) {\n\t\t\t\tque.push( node(nd.id, cap, nd.dist) );\n\t\t\t}\n\t\t\trep(i, edge[nd.id].size()) {\n\t\t\t\tpii p = edge[nd.id][i];\n\t\t\t\tif( nd.cap >= p.second && !visit[p.first][nd.cap-p.second] ) {\n\t\t\t\t\tque.push( node(p.first, nd.cap-p.second, nd.dist + p.second) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[6010][2010];\nvector<pair<int, int> > edge[6010];\n\nint main() {\n  while (true) {\n    rep (i, 6010) edge[i].clear();\n    rep (i, 6010) rep (j, 2010) dis[i][j] = 1e9;\n    int n, m, cap;\n    string src, dest;\n    cin >> n >> m >> cap;\n    cap *= 10;\n    if (n == 0) break;\n    cin >> src >> dest;\n    map<string, int> mp;\n    rep (i, n) {\n      string c1, c2;\n      int d;\n      cin >> c1 >> c2 >> d;\n      int nc1, nc2;\n      if (mp.count(c1)) {\n\tnc1 = mp[c1];\n      } else {\n\tnc1 = mp.size();\n\tmp[c1] = nc1;\n      }\n      if (mp.count(c2)) {\n\tnc2 = mp[c2];\n      } else {\n\tnc2 = mp.size();\n\tmp[c2] = nc2;\n      }\n      edge[nc1].push_back(make_pair(nc2, d));\n      edge[nc2].push_back(make_pair(nc1, d));\n    }\n    set<int> st;\n    rep (i, m) {\n      string s;\n      cin >> s;\n      st.insert(mp[s]);\n    }\n    priority_queue<pair<int, pair<short, short> >,vector<pair<int, pair<short, short> > >, greater<pair<int, pair<short, short> > > > que;\n    que.push(make_pair(0, make_pair(mp[src], cap)));\n    while (!que.empty()) {\n      pair<int, pair<short, short> > now = que.top();\n      que.pop();\n      int cost = now.first;\n      short pos = now.second.first;\n      short f = now.second.second;\n      if (dis[pos][f] <= cost) continue;\n      dis[pos][f] = cost;\n      if (mp[dest] == pos) break;\n      rep (i, edge[pos].size()) {\n\tint nc = cost + edge[pos][i].second;\n\tshort np = edge[pos][i].first;\n\tshort nf = f - edge[pos][i].second;\n\tif (nf < 0) continue;\n\tif (st.count(np)) nf = cap;\n\tif (dis[np][nf] <= nc) continue;\n\tque.push(make_pair(nc, make_pair(np, nf)));\n      }\n    }\n    int res = 1e9;\n    rep (i, 2010) res = min(res, dis[mp[dest]][i]);\n    if (res == 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, M, cap;\nstring cityfrom, cityto;\nstring cityname[3000][2];\nstring citystat[300];\nint d[3000];\n\ntypedef pair<int,int> pii;\ntypedef priority_queue<pii,deque<pii>,greater<pii> > pq_t;\n\nint solve(){\n\tmap<string,int> m_city;\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tm_city.insert( make_pair( cityname[i][0], m_city.size() ) );\n\t\tm_city.insert( make_pair( cityname[i][1], m_city.size() ) );\n\t}\n\t\n\tint n = m_city.size();\n\tvector< vector<pii> > road( n );\n\t\n\tfor( int i = 0; i < N; ++i ){\n\t\tint a = m_city[ cityname[i][0] ];\n\t\tint b = m_city[ cityname[i][1] ];\n\t\troad[a].push_back( pii( b, d[i] ) );\n\t\troad[b].push_back( pii( a, d[i] ) );\n\t\t\n\t\tcityname[i][0] = cityname[i][1] = string();\n\t}\n\t\n\t\n\tvector<int> nstat( M + 2 );\n\t\t//スタンドの番号。\n\t\t//ただし最初2つは出発地と目的地の番号としておく。\n\t\n\tnstat[0] = m_city[ cityfrom ];\n\tnstat[1] = m_city[ cityto ];\n\tfor( int i = 0; i < M; ++i ){\n\t\tnstat[i + 2] = m_city[ citystat[i] ];\n\t}\n\n\tcap *= 10;\n\n\tvector< vector<int> > dist( n, vector<int>( n, INF ) );\n\tfor( int from = 0; from < nstat.size(); ++from ){\n\t\tint n_from = nstat[from];\n\t\tdist[n_from][n_from] = 0;\n\t\tpq_t pq;\n\t\tpq.push( pii( 0, nstat[from] ) );\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint n_f = p.second;\n\t\t\tif( dist[n_from][n_f] != p.first ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < road[n_from].size(); ++i ){\n\t\t\t\tint n_to = road[n_from][i].first;\n\t\t\t\tint ds = p.first + road[n_from][i].second;\n\t\t\t\t\n\t\t\t\tif( ds < cap && dist[n_from][n_to] > ds ){\n\t\t\t\t\tdist[n_from][n_to] = ds;\n\t\t\t\t\tpq.push( pii( ds, n_to ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> dp( nstat.size(), INF );\n\tdp[0] = 0;\n\t\n\tpq_t pq;\n\n\tpq.push( make_pair( 0, 0 ) );\n\twhile( !pq.empty() ){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\n\t\tint from = p.second;\n\t\tif( dp[from] != p.first ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint n_from = nstat[from];\n\t\tfor( int to = 0; to < nstat.size(); ++to ){\n\t\t\tint n_to = nstat[to];\n\t\t\tif( dist[n_from][n_to] <= cap && dp[to] > dp[from] + dist[n_from][n_to] ){\n\t\t\t\tdp[to] = dp[from] + dist[n_from][n_to];\n\t\t\t\tpq.push( make_pair( dp[to], to ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif( dp[1] == INF ){\n\t\treturn -1;\n\t}\n\treturn dp[1];\n}\n\nint main(){\n\tfor( ; cin >> N >> M >> cap >> cityfrom >> cityto; ){\n\t\tfor( int i = 0; i < N; ++i ){\n\t\t\tcin >> cityname[i][0] >> cityname[i][1] >> d[i];\n\t\t}\n\t\tfor( int i = 0; i < M; ++i ){\n\t\t\tcin >> citystat[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n//const int INF = INT_MAX/10;\n\nconst int INF = SHRT_MAX/10;\ntypedef vector<short> vsh;\ntypedef vector<vsh> vvs;\n\nstruct state {\n\tint p, c, g;\n\tstate(int p, int c, int g) : p(p), c(c), g(g) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint N, M, cap;\n\twhile(cin >> N >> M >> cap, N) {\n\t\tstring src, dest;\n\t\tcin >> src >> dest;\n\t\tset<string> cities;\n\t\tvector<vs> data(N, vs(3)); \n\t\tREP(i, N) {\n\t\t\tREP(j, 2) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tcities.insert(data[i][j]);\n\t\t\t}\n\t\t\tcin >> data[i][2];\n\t\t}\n\n\t\tmap<string, int> index;\n\t\tset<string>::iterator it = cities.begin();\n\t\tint size = 0;\n\t\twhile(it != cities.end()) {\n\t\t\tindex[*it] = size;\n\t\t\tsize++;\n\t\t\tit++;\n\t\t}\n\n\t\tvvs dist(size, vsh(size, INF));\n\t\tREP(i, size) {\n\t\t\tREP(j, size) {\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tstring c1 = data[i][0];\n\t\t\tstring c2 = data[i][1];\n\t\t\tint cost = toInt(data[i][2]);\n\t\t\tdist[index[c1]][index[c2]] = dist[index[c2]][index[c1]] = cost;\n\t\t}\n\n\t\tvi gas(size);\n\t\tstring s;\n\t\tREP(i, M) {\n\t\t\tcin >> s;\n\t\t\tgas[index[s]] = 1;\n\t\t}\n\n\t\tvsh cost(size, INF);\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(index[src], 0, cap*10));\n\t\tcost[index[src]] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == index[dest]) {\n\t\t\t\tcout << st.c << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tREP(d, size) {\n\t\t\t\tif(st.p != d && dist[st.p][d] != INF) {\n\t\t\t\t\tint nc = st.c + dist[st.p][d];\n\t\t\t\t\tint ng = st.g - dist[st.p][d];\n\t\t\t\t\tif(ng < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas[d]) {\n\t\t\t\t\t\tng = cap*10;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(nc < cost[d]) {\n\t\t\t\t\t\tcost[d] = nc;\n\t\t\t\t\t\tQ.push(state(d, nc, ng));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << -1 << endl;\n\t\tend:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 6001\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint n,m,cap,ls[N];\nvoid add_edge(int a,int b,int d){\n  G[a].push_back(P(b,d));\n  G[b].push_back(P(a,d));\n}\n\nint dijkstra(){\n  map<P,int> D;\n  int used[N]={};\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(cap,0)));\n  \n  D[P(cap,0)]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int d=t.first,c=t.second.first,pos=t.second.second;\n\n    if(pos==1) return d;\n    if(D[P(c,pos)]<d)continue;\n    if(ls[pos])c=cap;\n    if(used[pos]>c) continue;\n    used[pos]=c;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int nd=d+G[pos][i].second;\n      int nx=G[pos][i].first;\n      int nc=c-G[pos][i].second;\n      if(nc>=0&&(!D.count(P(nc,nx))||D[P(nc,nx)]>nd))\n\tQ.push(PP(nd,P(nc,nx))),D[P(nc,nx)]=nd;\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m>>cap;cap*=10;\n    if(!n&&!m&&!cap)break;\n    for(int i=0;i<N;i++)G[i].clear(),ls[i]=0;\n    \n    map<string,int> M;\n    string a,b;\n    cin>>a>>b;\n    M[a]=0,M[b]=1;\n    int _n=2;\n    for(int i=0,d;i<n;i++){\n      cin>>a>>b>>d;\n      if(!M.count(a)) M[a]=_n++;\n      if(!M.count(b)) M[b]=_n++;\n      add_edge(M[a],M[b],d);\n    }\n    n=_n;\n    for(int i=0;i<m;i++) {cin>>a;if(M.count(a))ls[M[a]]=1;}\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass Data{\npublic:\n  int d,cap;\n  string str;\n  Data(int d = 0, int c=0):d(d),cap(c){}\n  bool operator < (const Data &a) const {\n    return d > a.d;\n  }\n};\n\nint main(){\n  int n,n2,cap;\n  while(cin >> n >> n2 >> cap && n && n2 && cap){\n    cap *= 10;\n    map<pair<string,string>,int> m;\n    string src,dest;\n    set<string> s,sta;\n    map<string,int> d[2001];\n\n    cin >> src >> dest;\n    for(int i=0;i<n;i++){\n      int a;\n      pair<string,string> p;\n      cin >> p.first >> p.second >> a;\n      s.insert(p.first);\n      s.insert(p.second);\n      m[p] = a;\n      swap(p.first,p.second);\n      m[p] = a;\n    }\n    for(int i=0;i<n2;i++){\n      string str;\n      cin >> str;\n      sta.insert(str);\n    }\n\n    set<string>::iterator it = s.begin();\n    for(;it != s.end();it++) for(int i=0;i<=cap;i++) d[i][*it] = INF;\n\n    priority_queue<Data> Q;\n    Data u,v;\n    u.cap = cap;\n    u.str = src;\n    Q.push(u);\n    for(int i = cap;i >= 0;i--) d[i][src] = 0;\n\n    while(!Q.empty()){\n      u = Q.top();\n      Q.pop();\n\n      it = s.begin();\n      for(;it != s.end();it++){\n\tv = u;\n\tif(*it == u.str) continue;\n\tpair<string,string> p;\n\tp.first = u.str;\n\tp.second = *it;\n\tv.cap -= m[p];\n\tif(v.cap < 0) continue;\n\tif(m[p] == 0) continue;\n\tif(sta.find(p.second) != sta.end()){\n\t  if(d[u.cap][p.first] + m[p] < d[cap][p.second]){\n\t    d[cap][p.second] = d[u.cap][p.first] + m[p];\n\t    v.str = p.second;\n\t    v.cap = cap;\n\t    v.d = d[cap][p.second];\n\t    if(p.second != dest) Q.push(v);\n\t  }\n\t}\n\telse if(v.cap > 0 && d[u.cap][p.first] + m[p] < d[v.cap][p.second]){\n\t  for(int i=0;i<=v.cap;i++){\n\t    d[i][p.second] = d[u.cap][p.first] + m[p];\n\t  }\n\t  v.str = p.second;\n\t  v.cap = cap;\n\t  v.d = d[v.cap][p.second];\n\t  if(p.second != dest) Q.push(v);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<=cap;i++) ans = min(ans,d[i][dest]);\n    if(ans >= INF) cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<30;\n\nstruct P{\n    int s1;\n    int s2;\n    int d;\n    P(){}\n    ~P(){}\n    P(int a, int b, int c) : s1(a), s2(b), d(c) {}\n    P(const P& r) : s1(r.s1), s2(r.s2), d(r.d) {}\n    bool operator < (const P& r) const {\n        return (s1 == r.s1 ? s2 < r.s2 : s1 < r.s1);\n    }\n};\n\nstruct Q{\n    int pos;\n    int fuel;\n    int dist;\n    vector<int> visited;\n    Q(){}\n    ~Q(){\n        vector<int>().swap(visited);\n    }\n    Q(int p, int f, int d, vector<int> v) : pos(p), fuel(f), dist(d), visited(v) {}\n    Q(const Q& r) : pos(r.pos), fuel(r.fuel), dist(r.dist), visited(r.visited) {}\n};\n\ntypedef pair<int, int> PR;\n\nint main(){\n    int n, m, cap, x;\n    vector<int> EMPTY;\n    vector<P> path(6000);\n    while(cin >> n >> m >> cap, n||m||cap){\n        string src, dest;\n        cin >> src >> dest;\n        map<string, int> name;\n        name[src] = 0;\n        name[dest] = 1;\n        int nn = 2;\n        string c1, c2;\n        int d;\n        for(x = 0; x < n; x++){\n            cin >> c1 >> c2 >> d;\n            if( name.find(c1) == name.end() ){\n                name[c1] = nn++;\n            }\n            if( name.find(c2) == name.end() ){\n                name[c2] = nn++;\n            }\n            path.push_back( P(name[c1], name[c2], d) );\n            path.push_back( P(name[c2], name[c1], d) );\n        }\n        sort(path.begin(), path.end());\n        vector<bool> gs(nn, 0);\n        vector<int> mindist(nn, INF);\n        mindist[0] = 0;\n        for(x = 0; x < m; x++){\n            cin >> c1;\n            gs[ name[c1] ] = 1;\n        }\n        queue< Q > que;\n        que.push( Q(0, cap*10, 0, EMPTY) );\n        while( !que.empty() ){\n            Q q = que.front();\n            que.pop();\n            vector<P>::iterator begin = lower_bound(path.begin(), path.end(),\n                                                    P(q.pos, -1, -1));\n            vector<P>::iterator end = lower_bound(path.begin(), path.end(),\n                                                  P(q.pos+1, -1, -1));\n            for(vector<P>::iterator nxt = begin;\n                    nxt != end; nxt++){\n                if( nxt->d > q.fuel ){ continue; }\n                if( q.dist + nxt->d < mindist[nxt->s2] ){\n                    mindist[nxt->s2] = q.dist + nxt->d;\n                }else if( !gs[nxt->s2] ){\n                    continue;\n                }\n                if( nxt->s2 == 1 ){ continue; }\n                bool ok = true;\n                for(vector<int>::iterator itr = q.visited.begin();\n                        itr != q.visited.end(); itr++){\n                    if( *itr == nxt->s2 ){\n                        ok = false;\n                        break;\n                    }\n                }\n                if( !ok ) continue;\n                vector<int> nv = q.visited;\n                nv.push_back(q.pos);\n                if( gs[ nxt->s2 ] ){\n                    que.push( Q(nxt->s2, cap*10, q.dist+nxt->d, nv) );\n                }else{\n                    que.push( Q(nxt->s2, q.fuel - nxt->d, q.dist+nxt->d, nv) );\n                }\n                vector<int>().swap(nv);\n            }\n        }\n        cout << ((mindist[1] == INF) ? -1 : mindist[1]) << endl;\n        vector<P>().swap(path);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n// Hash table for string\n#define HASHSIZ   35023\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n \nint insert(char *s, int id)\n{\n    unsigned long long i;\n    char *p;\n    HASH *tp;\n \n    i = 0, p = s; while (*p) i = (i<<6) + *p++;\n    tp = hash + (int)(i % HASHSIZ);\n    while (tp->s != NULL) {\n        if (!strcmp(tp->s, s)) return tp->id;\n        if (++tp == hashend) tp = hash;\n    }\n    tp->s = s, tp->id = id;\n    return -1;\n}\n \n#define QMAX 6002\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n \n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n \nvoid min_heapify(int i)\n{\n    int l, r, min;\n    QUE qt;\n \n    l = LEFT(i), r = RIGHT(i);\n    if (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n    if (r < qsize && que[r].t < que[min].t) min = r;\n    if (min != i) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        min_heapify(min);\n    }\n}\n \nvoid deq()\n{\n    que[0] = que[--qsize];\n    min_heapify(0);\n}\n\nvoid enq(short s, int t, short c)\n{\n    int i, min;\n    QUE qt;\n \n    i = qsize++;\n    que[i].s = s, que[i].t = t, que[i].c = c;\n    while (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        i = min;\n    }\n}\n \n//#define getchar_unlocked()  getchar()\nint in()\n{\n    int n = 0;\n    int c = getchar_unlocked();\n    do n = 10*n + (c & 0xf), c = getchar_unlocked();\n    while (c >= '0');\n    return n;\n}\n \nvoid ins(char *buf)\n{\n    while ((*buf = getchar_unlocked()) > ' ') buf++;\n    *buf = 0;\n}\n \n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nchar mk[MAX][2002];\n \nint dijkstra(int n, int cap, int start, int goal)\n{\n    int i, s, e, c, nc, d;\n \n    memset(mk, 0, sizeof(mk));\n    qsize = 0;\n    enq(start, 0, cap); mk[start][cap] = 1;\n    while (qsize) {\n        s = que[0].s, d = que[0].t, c = que[0].c, deq();\n        if (s == goal) return d;\n \n        if (LPG[s]) c = cap;\n\t\tmemset(mk[s], 1, c);\n\n        for (i = 0; i < hi[s]; i++) {\n\t\t\tif ((nc = c - dd[s][i]) < 0) continue;\n            e = to[s][i];\n            if (mk[e][nc]) continue;\n\t\t\tmk[e][nc] = 1, enq(e, d+dd[s][i], nc);\n        }\n    }\n    return -1;\n}\n \nint main()\n{\n    int N, M, cap, i, j, a, b, c;\n    char buf[20];\n \n    while (N = in()) {\n        for (a = 0; a < sz; a++) {\n            if (hi[a]) free(to[a]), free(dd[a]);\n        }\n \n        M = in(), cap = 10*in();\n        memset(hash, 0, sizeof(hash));\n \n        ins(city[0]), ins(city[1]);\n        insert(city[0], 0), insert(city[1], 1);\n \n        memset(hi, 0, sizeof(hi));\n        sz = 2;\n        j = 0, i = N; while (i--) {\n\t\t\tins(city[sz]), a = insert(city[sz], sz);\n            if (a < 0) a = sz++;\n            memo[j++] = a, hi[a]++;\n            ins(city[sz]), b = insert(city[sz], sz);\n            if (b < 0) b = sz++;\n            memo[j++] = b, hi[b]++;\n            memo[j++] = in();\n        }\n        for (a = 0; a < sz; a++) if (hi[a]) {\n            to[a] = malloc(hi[a] << 1);\n            dd[a] = malloc(hi[a] << 1);\n        }\n        memset(hi, 0, sz << 1);\n        j = 0; while (N--) {\n            a = memo[j++], b = memo[j++], c = memo[j++];\n            i = hi[a]++, to[a][i] = b, dd[a][i] = c;\n            i = hi[b]++, to[b][i] = a, dd[b][i] = c;\n        }\n        memset(LPG, 0, sz);\n        for (i = 0; i < M; i++) {\n            ins(buf), a = insert(buf, -1);\n            if (a >= 0) LPG[a] = 1;\n        }\n \n        printf(\"%d\\n\", dijkstra(sz, cap, 1, 0));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <map>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef struct\n{\n    int nam;\n    int dis;\n    int cans;\n    int teps;\n}Node;\nNode que[1001000];\nint fro,las;\n\ntypedef struct\n{\n    int u,v;\n    int dis;\n    int nex;\n}NN;\nNN edge[5000];\nint first[5000];\nint tot;\n\nvoid add(int u,int v,int d)\n{\n    edge[tot].u=u;\n    edge[tot].v=v;\n    edge[tot].dis=d;\n    edge[tot].nex=first[u];\n    first[u]=tot++;\n}\n\nchar str[100],str2[100];\nint n,m,cap,d,ns;\nbool hav[5000];\nint vis[5000];\nmap<string,int>num;\n\nint bfs()\n{\n    Node now,nex;\n    int ans=999999999;\n    now.nam=1;now.dis=0;now.cans=cap*10;now.teps=1;\n    las=fro=0;\n    que[las++]=now;\n    while(las!=fro)\n    {\n        now=que[fro++];\n        if(now.nam==2)\n        {\n            ans=min(ans,now.dis);\n            continue;\n        }\n        for(int i=first[now.nam];i!=-1;i=edge[i].nex)\n        {\n            if(hav[edge[i].v])\n            {\n                if(vis[edge[i].v]) continue;\n                else if(now.cans>=edge[i].dis&&vis[edge[i].v]==0)\n                {\n                    vis[edge[i].v]=1;\n                    nex.nam=edge[i].v;\n                    nex.dis=now.dis+edge[i].dis;\n                    nex.teps=now.teps+1;\n                    nex.cans=cap*10;\n                    que[las++]=nex;\n                }\n            }\n            else if(vis[edge[i].v]!=now.teps&&now.cans>=edge[i].dis)\n            {\n                vis[edge[i].v]=now.teps;\n                nex.nam=edge[i].v;\n                nex.dis=now.dis+edge[i].dis;\n                nex.teps=now.teps;\n                nex.cans=now.cans-edge[i].dis;\n                que[las++]=nex;\n            }\n        }\n    }\n    if(ans==999999999)return -1;\n    else return ans;\n}\n\nint main()\n{\n    while(true)\n    {\n        scanf(\"%d %d %d\",&n,&m,&cap);\n        if(n+m+cap==0) break;\n        num.clear();\n        memset(first,-1,sizeof(first));\n        memset(hav,false,sizeof(hav));\n        memset(vis,0,sizeof(vis));\n        ns=tot=0;\n        scanf(\"%s\",str); if(!num[str]) num[str]=++ns;\n        scanf(\"%s\",str2); if(!num[str2]) num[str2]=++ns;\n        //printf(\"%s=%d  %s=%d\\n\",str,num[str],str2,num[str2]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",str);  if(!num[str]) num[str]=++ns;\n            scanf(\"%s\",str2); if(!num[str2]) num[str2]=++ns;\n            scanf(\"%d\",&d);\n            //printf(\"%s=%d  %s=%d d=%d\\n\",str,num[str],str2,num[str2],d);\n            add(num[str],num[str2],d);\n            add(num[str2],num[str],d);\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%s\",str); if(!num[str]) num[str]=++ns;\n            //printf(\"%s=%d\\n\",str,num[str]);\n            hav[num[str]]=true;\n        }\n        printf(\"%d\\n\",bfs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n// Hash table for string\n#define HASHSIZ   29989\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n \nint insert(char *s, int id)\n{\n    unsigned long long i;\n    char *p;\n    HASH *tp;\n \n    i = 0, p = s; while (*p) i = (i<<6) + *p++;\n    tp = hash + (int)(i % HASHSIZ);\n    while (tp->s != NULL) {\n        if (!strcmp(tp->s, s)) return tp->id;\n        if (++tp == hashend) tp = hash;\n    }\n    tp->s = s, tp->id = id;\n    return -1;\n}\n \n#define QMAX 200000\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n \n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n \nvoid min_heapify(int i)\n{\n    int l, r, min;\n    QUE qt;\n \n    l = LEFT(i), r = RIGHT(i);\n    if (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n    if (r < qsize && que[r].t < que[min].t) min = r;\n    if (min != i) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        min_heapify(min);\n    }\n}\n \nvoid deq()\n{\n    que[0] = que[--qsize];\n    min_heapify(0);\n}\n \nvoid enq(short s, int t, short c)\n{\n    int i, min;\n    QUE qt;\n \n    i = qsize++;\n    que[i].s = s, que[i].t = t, que[i].c = c;\n    while (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        i = min;\n    }\n}\n \n//#define getchar_unlocked()  getchar()\nint in()\n{\n    int n = 0;\n    int c = getchar_unlocked();\n    do n = 10*n + (c & 0xf), c = getchar_unlocked();\n    while (c >= '0');\n    return n;\n}\n \nvoid ins(char *buf)\n{\n    while ((*buf = getchar_unlocked()) > ' ') buf++;\n    *buf = 0;\n}\n \n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nchar mk[MAX][2002];\n \nint dijkstra(int n, int cap, int start, int goal)\n{\n    int i, s, e, c, nc, d;\n \n    memset(mk, 0, sizeof(mk));\n    qsize = 0;\n    enq(start, 0, cap), mk[start][cap] = 1;\n    while (qsize) {\n        s = que[0].s, d = que[0].t, c = que[0].c, deq();\n        if (s == goal) return d;\n \n        if (LPG[s]) c = cap;\n        for (i = 0; i < hi[s]; i++) {\n\t\t\tif ((nc = c - dd[s][i]) < 0) continue;\n            e = to[s][i];\n            if (mk[e][nc]) continue;\n            mk[e][nc] = 1, enq(e, d + dd[s][i], nc);\n        }\n    }\n    return -1;\n}\n \nint main()\n{\n    int N, M, cap, i, j, a, b, c;\n    char buf[20];\n \n    while (N = in()) {\n        for (a = 0; a < sz; a++) {\n            if (hi[a]) free(to[a]), free(dd[a]);\n        }\n \n        M = in(), cap = 10*in();\n        memset(hash, 0, sizeof(hash));\n \n        ins(city[0]), ins(city[1]);\n        insert(city[0], 0), insert(city[1], 1);\n \n        memset(hi, 0, sizeof(hi));\n        sz = 2;\n        j = 0, i = N; while (i--) {\n            ins(city[sz]), a = insert(city[sz], sz);\n            if (a < 0) a = sz++;\n            memo[j++] = a, hi[a]++;\n            ins(city[sz]), b = insert(city[sz], sz);\n            if (b < 0) b = sz++;\n            memo[j++] = b, hi[b]++;\n            memo[j++] = in();\n        }\n        for (a = 0; a < sz; a++) if (hi[a]) {\n            to[a] = malloc(hi[a] << 1);\n            dd[a] = malloc(hi[a] << 1);\n        }\n        memset(hi, 0, sizeof(hi));\n        j = 0; while (N--) {\n            a = memo[j++], b = memo[j++], c = memo[j++];\n            i = hi[a]++, to[a][i] = b, dd[a][i] = c;\n            i = hi[b]++, to[b][i] = a, dd[b][i] = c;\n        }\n        memset(LPG, 0, sz);\n        for (i = 0; i < M; i++) {\n            ins(buf), a = insert(buf, -1);\n            if (a >= 0) LPG[a] = 1;\n        }\n \n        printf(\"%d\\n\", dijkstra(sz, cap, 1, 0));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Hash table for string\n#define HASHSIZ   29989\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s; while (*p) i = (i<<6) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define QMAX 1200000\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short s, int t, short c)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *buf)\n{\n\twhile ((*buf = getchar_unlocked()) > ' ') buf++;\n\t*buf = 0;\n}\n\n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nint dist[MAX][2002];\n\nint dijkstra(int n, int cap, int start, int goal)\n{\n\tint i, s, e, c, nc, d, nd;\n\n\tmemset(dist, 0x10, sizeof(dist));\n\tqsize = 0;\n\tenq(start, 0, cap); dist[start][cap] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, c = que[0].c, deq();\n\t\tif (s == goal) return d;\n\n\t\tif (dist[s][c] < d) continue;\n\n\t\tif (LPG[s]) c = cap;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], nd = d + dd[s][i], nc = c - dd[s][i];\n\t\t\tif (nc < 0) continue;\n\t\t\tif (dist[e][nc] > nd) dist[e][nc] = nd, enq(e, nd, nc);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N, M, cap, i, j, a, b, c;\n\tchar buf[20];\n\n\twhile (N = in()) {\n\t\tM = in(), cap = 10*in();\n\t\tmemset(hash, 0, sizeof(hash));\n\n\t\tins(city[0]), ins(city[1]);\n\t\tinsert(city[0], 0), insert(city[1], 1);\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tsz = 2;\n\t\tj = 0, i = N; while (i--) {\n\t\t\tins(city[sz]), a = insert(city[sz], sz);\n\t\t\tif (a < 0) a = sz++;\n\t\t\tmemo[j++] = a, hi[a]++;\n\t\t\tins(city[sz]), b = insert(city[sz], sz);\n\t\t\tif (b < 0) b = sz++;\n\t\t\tmemo[j++] = b, hi[b]++;\n\t\t\tmemo[j++] = in();\n\t\t}\n\t\tfor (a = 0; a < sz; a++) if (hi[a]) {\n\t\t\tto[a] = malloc(hi[a] << 1);\n\t\t\tdd[a] = malloc(hi[a] << 1);\n\t\t}\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tj = 0; while (N--) {\n\t\t\ta = memo[j++], b = memo[j++], c = memo[j++];\n\t\t\ti = hi[a]++, to[a][i] = b, dd[a][i] = c;\n\t\t\ti = hi[b]++, to[b][i] = a, dd[b][i] = c;\n\t\t}\n\t\tmemset(LPG, 0, sz);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tins(buf), a = insert(buf, -1);\n\t\t\tif (a >= 0) LPG[a] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\", dijkstra(sz, cap, 0, 1));\n\n\t\tfor (a = 0; a < sz; a++) {\n\t\t\tif (hi[a]) free(to[a]), free(dd[a]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n// Hash table for string\n#define HASHSIZ   35023\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n \nint insert(char *s, int id)\n{\n    unsigned long long i;\n    char *p;\n    HASH *tp;\n \n    i = 0, p = s; while (*p) i = (i<<6) + *p++;\n    tp = hash + (int)(i % HASHSIZ);\n    while (tp->s != NULL) {\n        if (!strcmp(tp->s, s)) return tp->id;\n        if (++tp == hashend) tp = hash;\n    }\n    tp->s = s, tp->id = id;\n    return -1;\n}\n \n#define QMAX 6002\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n \n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n \nvoid min_heapify(int i)\n{\n    int l, r, min;\n    QUE qt;\n \n    l = LEFT(i), r = RIGHT(i);\n    if (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n    if (r < qsize && que[r].t < que[min].t) min = r;\n    if (min != i) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        min_heapify(min);\n    }\n}\n \nvoid deq()\n{\n    que[0] = que[--qsize];\n    min_heapify(0);\n}\n\nvoid enq(short s, int t, short c)\n{\n    int i, min;\n    QUE qt;\n \n    i = qsize++;\n    que[i].s = s, que[i].t = t, que[i].c = c;\n    while (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n        qt = que[i], que[i] = que[min], que[min] = qt;\n        i = min;\n    }\n}\n \n//#define getchar_unlocked()  getchar()\nint in()\n{\n    int n = 0;\n    int c = getchar_unlocked();\n    do n = 10*n + (c & 0xf), c = getchar_unlocked();\n    while (c >= '0');\n    return n;\n}\n \nvoid ins(char *buf)\n{\n    while ((*buf = getchar_unlocked()) > ' ') buf++;\n    *buf = 0;\n}\n \n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nshort mk[MAX][2002];\n \nint dijkstra(int n, int cap, int start, int goal)\n{\n    int i, s, e, c, nc, d;\n \n    memset(mk, -1, sizeof(mk));\n    qsize = 0;\n    enq(start, 0, cap);\n    while (qsize) {\n        s = que[0].s, d = que[0].t, c = que[0].c, deq();\n        if (s == goal) return d;\n \n        if (LPG[s]) c = cap;\n\t\tif (mk[s][c] >= 0) continue;\n\t\tfor (i = c+1; i <= cap; i++) if (mk[s][i] >= 0 && mk[s][i] < d) break;\n\t\tif (i <= cap) continue;\n\t\tmk[s][c] = d;\n\n        for (i = 0; i < hi[s]; i++) {\n\t\t\tif ((nc = c - dd[s][i]) < 0) continue;\n            e = to[s][i];\n            if (mk[e][nc] >= 0) continue;\n\t\t\tenq(e, d+dd[s][i], nc);\n        }\n    }\n    return -1;\n}\n \nint main()\n{\n    int N, M, cap, i, j, a, b, c;\n    char buf[20];\n \n    while (N = in()) {\n        for (a = 0; a < sz; a++) {\n            if (hi[a]) free(to[a]), free(dd[a]);\n        }\n \n        M = in(), cap = 10*in();\n        memset(hash, 0, sizeof(hash));\n \n        ins(city[0]), ins(city[1]);\n        insert(city[0], 0), insert(city[1], 1);\n \n        memset(hi, 0, sizeof(hi));\n        sz = 2;\n        j = 0, i = N; while (i--) {\n\t\t\tins(city[sz]), a = insert(city[sz], sz);\n            if (a < 0) a = sz++;\n            memo[j++] = a, hi[a]++;\n            ins(city[sz]), b = insert(city[sz], sz);\n            if (b < 0) b = sz++;\n            memo[j++] = b, hi[b]++;\n            memo[j++] = in();\n        }\n        for (a = 0; a < sz; a++) if (hi[a]) {\n            to[a] = malloc(hi[a] << 1);\n            dd[a] = malloc(hi[a] << 1);\n        }\n        memset(hi, 0, sz << 1);\n        j = 0; while (N--) {\n            a = memo[j++], b = memo[j++], c = memo[j++];\n            i = hi[a]++, to[a][i] = b, dd[a][i] = c;\n            i = hi[b]++, to[b][i] = a, dd[b][i] = c;\n        }\n        memset(LPG, 0, sz);\n        for (i = 0; i < M; i++) {\n            ins(buf), a = insert(buf, -1);\n            if (a >= 0) LPG[a] = 1;\n        }\n \n        printf(\"%d\\n\", dijkstra(sz, cap, 1, 0));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Hash table for string\n#define HASHSIZ   29989\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\tint inc;\n\n\ti = 0, p = s; while (*p) i = (i<<6) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\tinc = *s + (*(s + 1) << 1);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\ttp += inc; if (tp >= hashend) tp -= HASHSIZ;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define QMAX 1200000\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short s, int t, short c)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *buf)\n{\n\twhile ((*buf = getchar_unlocked()) > ' ') buf++;\n\t*buf = 0;\n}\n\n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nchar mk[MAX][2002];\n\nint dijkstra(int n, int cap, int start, int goal)\n{\n\tint i, s, e, c, nc, d;\n\n\tmemset(mk, 0, sizeof(mk));\n\tqsize = 0;\n\tenq(start, 0, cap); mk[start][cap] = 1;\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, c = que[0].c, deq();\n\t\tif (s == goal) return d;\n\n\t\tif (LPG[s]) c = cap;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], nc = c - dd[s][i];\n\t\t\tif (nc < 0 || mk[e][nc]) continue;\n\t\t\tmk[e][nc] = 1, enq(e, d + dd[s][i], nc);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N, M, cap, i, j, a, b, c;\n\tchar buf[20];\n\n\twhile (N = in()) {\n\t\tfor (a = 0; a < sz; a++) {\n\t\t\tif (hi[a]) free(to[a]), free(dd[a]);\n\t\t}\n\n\t\tM = in(), cap = 10*in();\n\t\tmemset(hash, 0, sizeof(hash));\n\n\t\tins(city[0]), ins(city[1]);\n\t\tinsert(city[0], 0), insert(city[1], 1);\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tsz = 2;\n\t\tj = 0, i = N; while (i--) {\n\t\t\tins(city[sz]), a = insert(city[sz], sz);\n\t\t\tif (a < 0) a = sz++;\n\t\t\tmemo[j++] = a, hi[a]++;\n\t\t\tins(city[sz]), b = insert(city[sz], sz);\n\t\t\tif (b < 0) b = sz++;\n\t\t\tmemo[j++] = b, hi[b]++;\n\t\t\tmemo[j++] = in();\n\t\t}\n\t\tfor (a = 0; a < sz; a++) if (hi[a]) {\n\t\t\tto[a] = malloc(hi[a] << 1);\n\t\t\tdd[a] = malloc(hi[a] << 1);\n\t\t}\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tj = 0; while (N--) {\n\t\t\ta = memo[j++], b = memo[j++], c = memo[j++];\n\t\t\ti = hi[a]++, to[a][i] = b, dd[a][i] = c;\n\t\t\ti = hi[b]++, to[b][i] = a, dd[b][i] = c;\n\t\t}\n\t\tmemset(LPG, 0, sz);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tins(buf), a = insert(buf, -1);\n\t\t\tif (a >= 0) LPG[a] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\", dijkstra(sz, cap, 1, 0));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1318 Long Distance Taxi\n// 2018.3.2 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Hash table for string\n#define HASHSIZ   29989\ntypedef struct { char *s; short id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tchar *p;\n\tHASH *tp;\n\tint inc;\n\n\ti = 0, p = s; while (*p) i = (i<<6) + *p++;\n\ttp = hash + (int)(i % HASHSIZ);\n\tinc = *s + (*(s + 1) << 1);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\ttp += inc; if (tp >= hashend) tp -= HASHSIZ;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define QMAX 1200000\ntypedef struct { int t; short s, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short s, int t, short c)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].c = c;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *buf)\n{\n\twhile ((*buf = getchar_unlocked()) > ' ') buf++;\n\t*buf = 0;\n}\n\n#define MAX 6002\nshort memo[3002*3];\nshort hi[MAX], *to[MAX], *dd[MAX];\nchar city[MAX][17]; int sz;\nchar LPG[MAX];\nchar mk[MAX][2002];\n\nint dijkstra(int n, int cap, int start, int goal)\n{\n\tint i, s, e, c, nc, d;\n\n\tmemset(mk, 0, sizeof(mk));\n\tqsize = 0;\n\tenq(start, 0, cap); mk[start][cap] = 1;\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, c = que[0].c, deq();\n\t\tif (s == goal) return d;\n\n\t\tif (LPG[s]) c = cap;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], nc = c - dd[s][i];\n\t\t\tif (nc < 0 || mk[e][nc]) continue;\n\t\t\tmk[e][nc] = 1, enq(e, d + dd[s][i], nc);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint N, M, cap, i, j, a, b, c;\n\tchar buf[20];\n\n\twhile (N = in()) {\n\t\tfor (a = 0; a < sz; a++) {\n\t\t\tif (hi[a]) free(to[a]), free(dd[a]);\n\t\t}\n\n\t\tM = in(), cap = 10*in();\n\t\tmemset(hash, 0, sizeof(hash));\n\n\t\tins(city[0]), ins(city[1]);\n\t\tinsert(city[0], 0), insert(city[1], 1);\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tsz = 2;\n\t\tj = 0, i = N; while (i--) {\n\t\t\tins(city[sz]), a = insert(city[sz], sz);\n\t\t\tif (a < 0) a = sz++;\n\t\t\tmemo[j++] = a, hi[a]++;\n\t\t\tins(city[sz]), b = insert(city[sz], sz);\n\t\t\tif (b < 0) b = sz++;\n\t\t\tmemo[j++] = b, hi[b]++;\n\t\t\tmemo[j++] = in();\n\t\t}\n\t\tfor (a = 0; a < sz; a++) if (hi[a]) {\n\t\t\tto[a] = malloc(hi[a] << 1);\n\t\t\tdd[a] = malloc(hi[a] << 1);\n\t\t}\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tj = 0; while (N--) {\n\t\t\ta = memo[j++], b = memo[j++], c = memo[j++];\n\t\t\ti = hi[a]++, to[a][i] = b, dd[a][i] = c;\n\t\t\ti = hi[b]++, to[b][i] = a, dd[b][i] = c;\n\t\t}\n\t\tmemset(LPG, 0, sz);\n\t\tfor (i = 0; i < M; i++) {\n\t\t\tins(buf), a = insert(buf, -1);\n\t\t\tif (a >= 0) LPG[a] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\", dijkstra(sz, cap, 0, 1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint src = sc.next().hashCode();\n\t\t\tint dest = sc.next().hashCode();\n\t\t\tint[] list = new int[6000];\n\t\t\tint[][] a = new int[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next().hashCode();\n\t\t\t\ta[i][1] = sc.next().hashCode();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tadd(list, a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = map(list, src);\n\t\t\tint gg = map(list, dest);\n\t\t\tint lvl = size(list);\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(map(list,a[i][0]), map(list,a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = map(list, sc.next().hashCode());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n\tpublic static void add(int[] l,int x) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == x) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (l[i] == 0) {\n\t\t\t\tl[i] = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int map(int[] l,int x) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static int size(int[] l) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tV[] G; int size, cap;\n\tboolean[] gas;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(); cap = sc.nextInt();\n\t\t\tif((n|m|cap) == 0 )  break;\n\t\t\t\n\t\t\tHashMap<String, Integer> str2ind = new HashMap<String, Integer>();\n\t\t\tsize = 2;\n\t\t\tstr2ind.put(sc.next(), 0); str2ind.put(sc.next(), 1);\n\t\t\tArrayList<E> es = new ArrayList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString from = sc.next(), to = sc.next(); int c = sc.nextInt(), f = size, t = size;\n\t\t\t\tif(str2ind.containsKey(from)) f = str2ind.get(from);\n\t\t\t\telse {\n\t\t\t\t\tf = size; str2ind.put(from, size++);\n\t\t\t\t}\n\t\t\t\tif(str2ind.containsKey(to)) t = str2ind.get(to);\n\t\t\t\telse {\n\t\t\t\t\tt = size; str2ind.put(to, size++);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tes.add(new E(f, t, c));\n\t\t\t}\n\t\t\t\n\t\t\tG = new V[size];\n\t\t\tfor(int i=0;i<size;i++) G[i] = new V();\n\t\t\t\n\t\t\tfor(E e: es) {\n\t\t\t\tG[e.f].add(new E(e.f, e.t, e.c));\n\t\t\t\tG[e.t].add(new E(e.t, e.f, e.c));\n\t\t\t}\n\t\t\t\n\t\t\tgas = new boolean[size];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString p = sc.next();\n\t\t\t\tif(str2ind.containsKey(p)) gas[str2ind.get(p)] = true;\n\t\t\t}\n\t\t\tstr2ind.clear();\n\t\t\tes.clear();\n\t\t\t\n\t\t\tSystem.out.println(dijkstra()); \n\t\t}\n\t}\n\t\n\tint dijkstra() {\n\t\t\n\t\tHashMap<P, Integer> d = new HashMap<P, Integer>();\n\t\t\n\t\tPriorityQueue<S> que = new PriorityQueue<S>();\n\t\tque.add(new S(0, cap*10, 0)); d.put(new P(0, cap*10), 0);\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tS cur = que.remove();\n\t\t\tif(d.get(new P(cur.p, cur.l) ) != cur.c) continue;\n\t\t\tif(cur.p == 1) return cur.c;\n\t\t\t\n\t\t\tfor(E e: G[cur.p]) {\n\t\t\t\tP p = new P(e.t, cur.l-e.c);\n\t\t\t\t\n\t\t\t\tif( d.containsKey(p) ) {\n\t\t\t\t\t\n\t\t\t\t\tif(cur.l >= e.c) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(gas[e.t]) {\n\t\t\t\t\t\t\tif(!d.containsKey(new P(e.t, cap*10)) || d.get(new P(e.t, cap*10)) > cur.c + e.c) {\n\t\t\t\t\t\t\t\td.put(new P(e.t, cap * 10), cur.c + e.c);\n\t\t\t\t\t\t\t\tque.add(new S(e.t, cap * 10, cur.c + e.c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif( d.get( p ) > cur.c + e.c ) {\n\t\t\t\t\t\t\t\td.put(p, cur.c + e.c);\n\t\t\t\t\t\t\t\tque.add(new S(e.t, cur.l - e.c, cur.c + e.c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cur.l >= e.c) {\n\t\t\t\t\t\tif(gas[e.t]) {\n\t\t\t\t\t\t\tif(!d.containsKey(new P(e.t, cap*10)) || d.get(new P(e.t, cap*10)) > cur.c + e.c) {\n\t\t\t\t\t\t\t\td.put(new P(e.t, cap * 10), cur.c + e.c);\n\t\t\t\t\t\t\t\tque.add(new S(e.t, cap * 10, cur.c + e.c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\td.put(p, cur.c + e.c);\n\t\t\t\t\t\t\tque.add(new S(e.t, cur.l - e.c, cur.c + e.c));\t\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass P {\n\t\tint p, l;\n\t\tP(int p, int l) {\n\t\t\tthis.p = p;\n\t\t\tthis.l = l;\n\t\t}\n\t\t\n\t\tpublic int hashCode() {\n\t\t\treturn p * 10000 + l;\n\t\t}\n\t\t\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP po = (P) o;\n\t\t\t\treturn p == po.p && l == po.l;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tclass S implements Comparable<S>{\n\t\tint p, l, c;\n\t\tS(int p, int l, int c) {\n\t\t\tthis.p = p;this.l = l;this.c = c;\n\t\t}\n\t\t\n\t\tpublic int compareTo(S arg0) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - arg0.c;\n\t\t}\n\t}\n\t\n\tclass V extends ArrayList<E>{}\n\t\n\tclass E {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.t = t;this.f = f;this.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString src = sc.next();\n\t\t\tString dest = sc.next();\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\tString[][] a = new String[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next();\n\t\t\t\ta[i][1] = sc.next();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tV[] G; int size, cap;\n\tboolean[] gas;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(); cap = sc.nextInt();\n\t\t\tif((n|m|cap) == 0 )  break;\n\t\t\t\n\t\t\tHashMap<String, Integer> str2ind = new HashMap<String, Integer>();\n\t\t\tsize = 2;\n\t\t\tstr2ind.put(sc.next(), 0); str2ind.put(sc.next(), 1);\n\t\t\tArrayList<E> es = new ArrayList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString from = sc.next(), to = sc.next(); int c = sc.nextInt(), f = size, t = size;\n\t\t\t\tif(str2ind.containsKey(from)) f = str2ind.get(from);\n\t\t\t\telse {\n\t\t\t\t\tf = size; str2ind.put(from, size++);\n\t\t\t\t}\n\t\t\t\tif(str2ind.containsKey(to)) t = str2ind.get(to);\n\t\t\t\telse {\n\t\t\t\t\tt = size; str2ind.put(to, size++);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tes.add(new E(f, t, c));\n\t\t\t}\n\t\t\t\n\t\t\tG = new V[size];\n\t\t\tfor(int i=0;i<size;i++) G[i] = new V();\n\t\t\t\n\t\t\tfor(E e: es) {\n\t\t\t\tG[e.f].add(new E(e.f, e.t, e.c));\n\t\t\t\tG[e.t].add(new E(e.t, e.f, e.c));\n\t\t\t}\n\t\t\t\n\t\t\tgas = new boolean[size];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString p = sc.next();\n\t\t\t\tif(str2ind.containsKey(p)) gas[str2ind.get(p)] = true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dijkstra()); \n\t\t}\n\t}\n\t\n\tint dijkstra() {\n\t\t\n\t\tint[][] d = new int[size][cap * 10 + 1];\n\t\tfor(int[] a: d) fill(a, INF);\n\t\t\n\t\tPriorityQueue<S> que = new PriorityQueue<S>();\n\t\tque.add(new S(0, cap*10, 0)); d[0][cap*10] = 0;\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tS cur = que.remove();\n\t\t\tif(d[cur.p][cur.l] != cur.c) continue;\n\t\t\tif(cur.p == 1) return cur.c;\n\t\t\t\n\t\t\tfor(E e: G[cur.p]) {\n\t\t\t\tif(cur.l >= e.c && d[e.t][cur.l - e.c] > cur.c + e.c) {\n\t\t\t\t\td[e.t][cur.l - e.c] = cur.c + e.c;\n\t\t\t\t\tif(gas[e.t]) {\n\t\t\t\t\t\td[e.t][cap * 10] = cur.c + e.c;\n\t\t\t\t\t\tque.add(new S(e.t, cap * 10, cur.c + e.c));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\td[e.t][cur.l - e.c] = cur.c + e.c;\n\t\t\t\t\t\tque.add(new S(e.t, cur.l - e.c, cur.c + e.c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass S implements Comparable<S>{\n\t\tint p, l, c;\n\t\tS(int p, int l, int c) {\n\t\t\tthis.p = p;this.l = l;this.c = c;\n\t\t}\n\t\t\n\t\tpublic int compareTo(S arg0) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - arg0.c;\n\t\t}\n\t}\n\t\n\tclass V extends ArrayList<E>{}\n\t\n\tclass E {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.t = t;this.f = f;this.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID, INF = 1<<29, M = 2001;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tSet<E>[] adj;\n\tint[] d;\n\tboolean[] gas;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\td = new int[6000*2001];\n\t\tadj = new Set[6000];\n\t\tgas = new boolean[6000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tint S = reg(sc.next()), T = reg(sc.next());\n\t\t\tfor(int i=0;i<6000;i++)adj[i]=new HashSet<E>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint s = reg(sc.next()), t = reg(sc.next()), D = sc.nextInt();\n\t\t\t\tadj[s].add(new E(t, D)); adj[t].add(new E(s, D));\n\t\t\t}\n\t\t\tArrays.fill(gas, false);\n\t\t\twhile(m--!=0)gas[reg(sc.next())]=true;\n\t\t\tfor(int i=0;i<ID;i++)for(int j=0;j<=10*cap;j++)d[i*M+j]=INF;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\td[S*M+10*cap] = 0;\n\t\t\tq.add(S*M+10*cap);\n\t\t\tint res = INF;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tint p = v/M, c = v%M;\n\t\t\t\tif(p==T){\n\t\t\t\t\tres = Math.min(res, d[v]); break;\n\t\t\t\t}\n\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\tif(c-e.c<=0)continue;\n\t\t\t\t\tint w = d[v]+e.c;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < d[e.t*M+10*cap]){\n\t\t\t\t\t\t\td[e.t*M+10*cap] = w; q.add(e.t*M+10*cap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < d[e.t*M+c-e.c]){\n\t\t\t\t\t\t\td[e.t*M+c-e.c] = w; q.add(e.t*M+c-e.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n//\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tint[] min = new int[ID];\n\t\t\tArrays.fill(min, INF);\n\t\t\tmin[src.id] = 0;\n\n\t\t\t//\t\t\tdist = new int[ID][10*cap+1];\n//\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\t//\t\t\tdist[src.id][0] = 0;\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = time; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d||min[e.t]<=c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tmin[e.t] = 0;\n\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> es;\n\tHashSet<Integer> gas;\n\tHashMap<Integer, HashSet<Integer>> gasmap;\n\t\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tes = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tgas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tgasmap = new HashMap<Integer, HashSet<Integer>>();\n\t\t\tfor(int a : gas){\n\t\t\t\tgasmap.put(a, new HashSet<Integer>());\n\t\t\t\tdfs(a, tank, a);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(to == now.now) continue;\n\t\t\t\t\tif(! gasmap.get(now.now).contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int now, int tank, int start) {\n\t\t\n\t\tfor(int i = 0; i < es.get(now).size(); i++){\n\t\t\tint to = es.get(now).get(i).to;\n\t\t\tint cost = es.get(now).get(i).cost;\n\t\t\tif(tank - cost < 0) continue;\n\t\t\tif(gasmap.get(start).contains(to)) continue;\n\t\t\t\n\t\t\tif(gas.contains(to)){\n\t\t\t\tgasmap.get(start).add(to);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(to, tank - cost, start);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n\tMap<Integer, Integer>[] dist;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tdist = new HashMap[ID];\n\t\t\tfor(int i=0;i<ID;i++)dist[i]=new HashMap<Integer, Integer>();\n\t\t\tdist[src.id].put(0, 0);\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = INF;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = Math.min(res, time);\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(!dist[e.t].containsKey(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dist[e.t].containsKey(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID, INF = 1<<29, M = 2001;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tSet<E>[] adj;\n\tint[] d;\n\tboolean[] gas;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\td = new int[6000*2001];\n\t\tadj = new Set[6000];\n\t\tgas = new boolean[6000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tint S = reg(sc.next()), T = reg(sc.next());\n\t\t\tfor(int i=0;i<6000;i++)adj[i]=new HashSet<E>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint s = reg(sc.next()), t = reg(sc.next()), D = sc.nextInt();\n\t\t\t\tadj[s].add(new E(t, D)); adj[t].add(new E(s, D));\n\t\t\t}\n\t\t\tArrays.fill(gas, false);\n\t\t\twhile(m--!=0)gas[reg(sc.next())]=true;\n\t\t\tfor(int i=0;i<ID;i++)for(int j=0;j<=10*cap;j++)d[i*M+j]=INF;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\td[S*M+10*cap] = 0;\n\t\t\tq.add(S*M+10*cap);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tint p = v/M, c = v%M;\n\t\t\t\tif(p==T){\n\t\t\t\t\tres = d[v]; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\tif(c-e.c<0)continue;\n\t\t\t\t\tint w = d[v]+e.c;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < d[e.t*M+10*cap]){\n\t\t\t\t\t\t\td[e.t*M+10*cap] = w; q.add(e.t*M+10*cap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < d[e.t*M+c-e.c]){\n\t\t\t\t\t\t\td[e.t*M+c-e.c] = w; q.add(e.t*M+c-e.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\tint N, M, cap;\n\tHashMap<String, Integer> cityToId;\n\tHashSet<Integer> gasstand;\n\t\n\t\n\tpublic void solve() {\n\t\tcityToId = new HashMap<>();\n\t\tgasstand = new HashSet<>();\n\t\twhile(true){\n\t\t\tN = nextInt();\n\t\t\tM = nextInt();\n\t\t\tcap = nextInt();\n\t\t\tif(N == 0) break;\n\t\t\tcityToId.clear();\n\t\t\tgasstand.clear();\n\t\t\tGraph g1 = new Graph(N * 2);\n\t\t\tGraph g2 = new Graph(N * 2);\n\t\t\tint srcId = toId(next());\n\t\t\tint dstId = toId(next());\n\t\t\tgasstand.add(srcId);\n\t\t\tgasstand.add(dstId);\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tint i1 = toId(next());\n\t\t\t\tint i2 = toId(next());\n\t\t\t\tint w = nextInt();\n\t\t\t\tg1.addBiEdge(i1, i2, w);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\tgasstand.add(toId(next()));\n\t\t\t}\n\t\t\tint[] dist = new int[cityToId.size()];\n\t\t\t\n\t\t\tfor(int v1 : gasstand){\n\t\t\t\tdijkstra(g1, v1, dist);\n\t\t\t\tfor(int v2 : gasstand){\n\t\t\t\t\tif(v1 == v2) continue;\n\t\t\t\t\tif(dist[v2] <= cap * 10){\n\t\t\t\t\t\tg2.addEdge(v1, v2, dist[v2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdijkstra(g2, srcId, dist);\n\t\t\tif(dist[dstId] == Integer.MAX_VALUE){\n\t\t\t\tout.println(-1);\n\t\t\t}else{\n\t\t\t\tout.println(dist[dstId]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void dijkstra(Graph g, int src, int[] dist){\n\t\tArrays.fill(dist, Integer.MAX_VALUE);\n\t\tPriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\n\t\tqueue.offer(new int[]{0, src});\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] nn = queue.poll();\n\t\t\tif(dist[nn[1]] > nn[0]){\n\t\t\t\tdist[nn[1]] = nn[0];\n\t\t\t\tfor(Edge e : g.nodes[nn[1]]){\n\t\t\t\t\tint d = nn[0] + e.weight;\n\t\t\t\t\tif(d < dist[e.to.idx]){\n\t\t\t\t\t\tqueue.offer(new int[]{d, e.to.idx});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int toId(String city){\n\t\tInteger val = cityToId.get(city);\n\t\tif(val == null){\n\t\t\tint nid = cityToId.size();\n\t\t\tcityToId.put(city, nid);\n\t\t\treturn nid;\n\t\t}\n\t\treturn val.intValue();\n\t}\n\n\t\n\tclass Graph{\n\t\tNode[] nodes;\n\t\tpublic Graph(int n){\n\t\t\tnodes = new Node[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tnodes[i] = new Node(i);\n\t\t\t}\n\t\t}\n\t\tpublic void addEdge(int from, int to, int weight){\n\t\t\tnodes[from].add(new Edge(nodes[from], nodes[to], weight));\n\t\t}\n\t\tpublic void addBiEdge(int n1, int n2, int weight){\n\t\t\taddEdge(n1, n2, weight);\n\t\t\taddEdge(n2, n1, weight);\n\t\t}\n\t}\n\n\tclass Node extends ArrayList<Edge>{\n\t\tint idx;\n\t\tpublic Node(int idx){\n\t\t\tthis.idx = idx;\n\t\t}\n\t\t\n\t}\n\n\tclass Edge{\n\t\tNode from;\n\t\tNode to;\n\t\tint weight;\n\t\tpublic Edge(Node from, Node to, int weight){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.weight = weight;\n\t\t}\n\t}\n\n\t\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(; i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(; i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return(bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n//\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tint[] min = new int[ID];\n\t\t\tArrays.fill(min, INF);\n\t\t\tmin[src.id] = 0;\n\n\t\t\t//\t\t\tdist = new int[ID][10*cap+1];\n//\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\t//\t\t\tdist[src.id][0] = 0;\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = time; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d||min[e.t]<=c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tmin[e.t] = 0;\n\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmin[e.t] = c+e.d;\n\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int cap = sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            String src = sc.next();\n            String dest = sc.next();\n            HashMap<String, Integer> hm = new HashMap<String, Integer>();\n            String[][] a = new String[n][2];\n            int[] d = new int[n];\n            for(int i=0;i<n;i++) {\n                a[i][0] = sc.next();\n                a[i][1] = sc.next();\n                d[i] = sc.nextInt();\n            }\n            for(int i=0;i<n;i++) {\n                for(int j=0;j<2;j++) {\n                    if (!hm.containsKey(a[i][j])) {\n                        hm.put(a[i][j], hm.size());\n                    }\n                }\n            }\n            int ss = hm.get(src);\n            int gg = hm.get(dest);\n            int v = hm.size();\n            Graph g1 = new Graph(v);\n            Graph g2 = new Graph(m+3);\n            for(int i=0;i<n;i++) {\n                g1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n            }\n            int[] s = new int[m+2];\n            for(int i=0;i<m;i++) {\n                s[i] = hm.get(sc.next());\n            }\n            s[m] = ss;\n            s[m+1] = gg;\n            for(int i=0;i<m+1;i++) {\n                int[] dist = g1.minDistDijkstra(s[i]);\n                for(int j=i+1;j<m+2;j++) {\n                    if (dist[s[j]] <= cap * 10) {\n                        g2.addBidirectionalEdge(i, j, dist[s[j]]);\n                    }\n                }\n            }\n            int ans = g2.minDistDijkstra(m)[m+1];\n            System.out.println(ans >= Graph.INF ? -1 : ans);\n            System.gc();\n        }\n    }\n \n}\n \nclass Graph {\n    public static final int INF = 1<<29;\n    int n;\n    ArrayList<Edge>[] graph;\n \n    @SuppressWarnings(\"unchecked\")\n    public Graph(int n) {\n        this.n = n;\n        this.graph = new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i] = new ArrayList<Edge>();\n        }\n    }\n \n    public void addBidirectionalEdge(int from,int to,int cost) {\n        addEdge(from,to,cost);\n        addEdge(to,from,cost);\n    }\n    public void addEdge(int from,int to,int cost) {\n        graph[from].add(new Edge(to, cost));\n    }\n \n    //dijkstra O(ElogV)\n    public int[] minDistDijkstra(int s) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, INF);\n        dist[s] = 0;\n        PriorityQueue<Node> q = new PriorityQueue<Node>();\n        q.offer(new Node(0, s));\n        while(!q.isEmpty()) {\n            Node node = q.poll();\n            int v = node.id;\n            if (dist[v] < node.dist) {\n                continue;\n            }\n            for(Edge e:graph[v]) {\n                if (dist[e.to] > dist[v] + e.cost) {\n                    dist[e.to] = dist[v] + e.cost;\n                    q.add(new Node(dist[e.to], e.to));\n                }\n            }\n        }\n        return dist;\n    }\n \n    //O(E) all cost is 0 or 1\n    public int[] minDistQueue(int s) {\n        int[] d = new int[n];\n        Arrays.fill(d, INF);\n        ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n        q.add(s);\n        d[s] = 0;\n        while(!q.isEmpty()) {\n            int v = q.pollFirst();\n            for(Edge e:graph[v]) {\n                int u = e.to;\n                if (d[v] + e.cost < d[u]) {\n                    d[u] = d[v] + e.cost;\n                    if (e.cost == 0) {\n                        q.addFirst(u);\n                    }else{\n                        q.addLast(u);\n                    }\n                }\n            }\n        }\n        return d;\n    }\n \n    //topologicalSort O(V+E)\n    public ArrayList<Integer> topologicalSort() {\n        ArrayList<Integer> order = new ArrayList<Integer>();\n        int[] col = new int[n];\n        for(int u=0;u<n;u++) {\n            if (col[u] == 0 && !visitTS(order, col, u)) {\n                return null;\n            }\n        }\n        Collections.reverse(order);\n        return order;\n    }\n    private boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n        col[v] = 1;\n        for(Edge e:graph[v]) {\n            if (col[e.to] == 2) {\n                continue;\n            }\n            if (col[e.to] == 1) {\n                return false;\n            }\n            if (!visitTS(order, col, e.to)) {\n                return false;\n            }\n        }\n        order.add(v);\n        col[v] = 2;\n        return true;\n    }\n \n    //longest Path in DAG\n    public ArrayList<Integer> longestPathInDAG(int s,int g) {\n        int[] dist = new int[n];\n        int[] bef = new int[n];\n        Arrays.fill(dist, -INF);\n        Arrays.fill(bef, -1);\n        ArrayList<Integer> order = topologicalSort();\n        if (order == null) {\n            return null;\n        }\n        dist[s] = 0;\n        for(int i=0;i<n;i++) {\n            int u = order.get(i);\n            for(Edge e:graph[u]) {\n                int v = e.to;\n                if (dist[v] < dist[u] + e.cost) {\n                    dist[v] = dist[u] + e.cost;\n                    bef[v] = u;\n                }\n            }\n        }\n        ArrayList<Integer> path = new ArrayList<Integer>();\n        int now = g;\n        while(true) {\n            path.add(now);\n            if (bef[now] != -1) {\n                now = bef[now];\n                if (now == s) {\n                    break;\n                }\n            }else{\n                return null;\n            }\n        }\n        path.add(now);\n        Collections.reverse(path);\n        return path;\n    }\n    public int longestPathLengthInDAG() {\n        int[] dist = new int[n];\n        Arrays.fill(dist, 0);\n        ArrayList<Integer> order = topologicalSort();\n        if (order == null) {\n            return -1;\n        }\n        int max = 0;\n        for(int i=0;i<n;i++) {\n            int u = order.get(i);\n            for(Edge e:graph[u]) {\n                int v = e.to;\n                if (dist[v] < dist[u] + e.cost) {\n                    dist[v] = dist[u] + e.cost;\n                    max = Math.max(max,dist[v]);\n                }\n            }\n        }\n        return max;\n    }\n \n    public ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n        ArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n        int[] num = new int[n];\n        int[] low = new int[n];\n        ArrayDeque<Integer> s = new ArrayDeque<Integer>();\n        boolean[] inS = new boolean[n];\n        int time = 0;\n        for(int u=0;u<n;u++) {\n            if (num[u] == 0) {\n                visitSCC(u,scc,s,inS,low,num,time);\n            }\n        }\n        return scc;\n    }\n    private void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n            ArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n        low[v] = num[v] = ++time;\n        s.push(v);\n        inS[v] = true;\n        for(Edge e:graph[v]) {\n            int w = e.to;\n            if (num[w] == 0) {\n                visitSCC(w,scc,s,inS,low,num,time);\n                low[v] = Math.min(low[v],low[w]);\n            }else if (inS[w]) {\n                low[v] = Math.min(low[v],num[w]);\n            }\n        }\n        if (low[v] == num[v]) {\n            ArrayList<Integer> scc1 = new ArrayList<Integer>();\n            while(true) {\n                int w = s.poll();\n                inS[w] = false;\n                scc1.add(w);\n                if (v == w) {\n                    break;\n\t\t\t\t}\n            }\n            scc.add(scc1);\n        }\n    }\n \n    //dont' remove multiple edge\n    public Graph noSCCGraph(int[] map) {\n        ArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n        int m = scc.size();\n        for(int i=0;i<m;i++) {\n            ArrayList<Integer> l = scc.get(i);\n            for(int v: l) {\n                map[v] = i;\n            }\n        }\n        Graph h = new Graph(m);\n        for(int u=0;u<n;u++) {\n            for(Edge e:graph[u]) {\n                h.addEdge(map[u], map[e.to], e.cost);\n            }\n        }\n        return h;\n    }\n \n    class Edge {\n        int to;\n        int cost;\n        public Edge(int to,int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n    class Node implements Comparable<Node>{\n        int dist;\n        int id;\n        public Node(int dist,int i) {\n            this.dist = dist;\n            this.id = i;\n        }\n        public int compareTo(Node o) {\n            return (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tV[] G; int size, cap;\n\tArrayList<Integer> gas;\n\tint[][] dist;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(); cap = sc.nextInt();\n\t\t\tif((n|m|cap) == 0 )  break;\n\n\t\t\tHashMap<String, Integer> str2ind = new HashMap<String, Integer>();\n\t\t\tsize = 2;\n\t\t\tstr2ind.put(sc.next(), 0); str2ind.put(sc.next(), 1);\n\t\t\tArrayList<E> es = new ArrayList<E>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString from = sc.next(), to = sc.next(); int c = sc.nextInt(), f = size, t = size;\n\t\t\t\tif(str2ind.containsKey(from)) f = str2ind.get(from);\n\t\t\t\telse {\n\t\t\t\t\tf = size; str2ind.put(from, size++);\n\t\t\t\t}\n\t\t\t\tif(str2ind.containsKey(to)) t = str2ind.get(to);\n\t\t\t\telse {\n\t\t\t\t\tt = size; str2ind.put(to, size++);\n\t\t\t\t}\n\n\t\t\t\tes.add(new E(f, t, c));\n\t\t\t}\n\n\t\t\tG = new V[size];\n\t\t\tfor(int i=0;i<size;i++) G[i] = new V();\n\n\t\t\tfor(E e: es) {\n\t\t\t\tG[e.f].add(new E(e.f, e.t, e.c));\n\t\t\t\tG[e.t].add(new E(e.t, e.f, e.c));\n\t\t\t}\n\t\t\tgas = new ArrayList<Integer>();\n\t\t\tgas.add(0); gas.add(1);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString p = sc.next();\n\t\t\t\tif(str2ind.containsKey(p)) gas.add(str2ind.get(p));\n\t\t\t}\n\n\t\t\tstr2ind.clear();\n\t\t\tes.clear();\n\n\t\t\tdist = new int[gas.size()][];\n\t\t\tfor(int i=0;i<gas.size();i++) dist[i] = dijkstra(gas.get(i));\n\t\t\tsize = gas.size();\n\t\t\tgas.clear();\n\t\t\tfor(V v: G) v.clear();\n\t\t\tG = new V[]{};\n\t\t\t\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tint[] d = new int[size]; fill(d, INF); d[0] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(0, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\t\t\tif(cur.p == 1) return cur.d;\n\n\t\t\tfor(int i=0;i<size;i++) if(dist[cur.p][i] <= cap * 10 && d[i] > cur.d + dist[cur.p][i]) {\n\t\t\t\tque.add(new P(i, cur.d + dist[cur.p][i]));\n\t\t\t\td[i] = cur.d + dist[cur.p][i];\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tint[] dijkstra(int s) {\n\t\tint[] d = new int[size];\n\t\tfill(d, INF); d[s] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(s, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\n\t\t\tfor(E next: G[cur.p]) if(d[next.t] > next.c + cur.d) {\n\t\t\t\td[next.t] = next.c + cur.d;\n\t\t\t\tque.add(new P(next.t, next.c + cur.d));\n\t\t\t}\n\t\t}\n\n\t\tint[] ret = new int[gas.size()];\n\t\tfor(int i=0;i<gas.size();i++) ret[i] = d[gas.get(i)];\n\t\treturn ret;\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint p, d;\n\t\tP(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn d-o.d;\n\t\t}\n\t}\n\n\tclass V extends ArrayList<E>{}\n\n\tclass E {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.t = t;this.f = f;this.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tArrayList<ArrayList<Edge>> es = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tHashSet<Integer> gas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tHashSet<Integer> canddest = new HashSet<Integer>();\n\t\t\t\tLinkedList<State> open2 = new LinkedList<State>();\n\t\t\t\topen2.add(new State(now.now, tank));\n\t\t\t\twhile(! open2.isEmpty()){\n\t\t\t\t\tState op2now = open2.poll();\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < es.get(op2now.now).size(); i++){\n\t\t\t\t\t\tint op2to = es.get(op2now.now).get(i).to;\n\t\t\t\t\t\tint op2cost = es.get(op2now.now).get(i).cost;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(op2now.cost - op2cost < 0) continue;\n\t\t\t\t\t\tif(op2to == now.now) continue;\n\t\t\t\t\t\tif(canddest.contains(op2to)) continue;\n\t\t\t\t\t\tif(gas.contains(op2to)){\n\t\t\t\t\t\t\tcanddest.add(op2to);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen2.add(new State(op2to, op2now.cost - op2cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(! canddest.contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, tank, cost;\n\n\t\tpublic State(int now, int tank, int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.tank = tank;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint [][] pass = new int[6000][6000];\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\tfor(int i = 0; i < 6000; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t}\n\t\t\ttank *= 10;\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\tpass[inds][indt] = cost;\n\t\t\t\tpass[indt][inds] = cost;\n\t\t\t}\n\t\t\tint v = table.size();\n\t\t\t\n\t\t\tHashSet<Integer> gas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tgas.add(table.get(sc.next()));\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind, tank, 0));\n\t\t\tint [][] close = new int[v][tank + 1];\n\t\t\t\n\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t}\n\t\t\tclose[startind][tank] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\t\tif(pass[now.now][i] == INF) continue;\n\t\t\t\t\tint nextcost = now.cost + pass[now.now][i];\n\t\t\t\t\tint nexttank = now.tank - pass[now.now][i];\n\t\t\t\t\tif(nexttank < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas.contains(i)){\n\t\t\t\t\t\tnexttank = tank;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(close[i][nexttank] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(i, nexttank, nextcost));\n\t\t\t\t\tclose[i][nexttank] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tV[] G; int size, cap;\n\tArrayList<Integer> gas;\n\tint[][] dist;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(); cap = sc.nextInt();\n\t\t\tif((n|m|cap) == 0 )  break;\n\n\t\t\tHashMap<String, Integer> str2ind = new HashMap<String, Integer>();\n\t\t\tsize = 2;\n\t\t\tstr2ind.put(sc.next(), 0); str2ind.put(sc.next(), 1);\n\t\t\tArrayList<E> es = new ArrayList<E>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString from = sc.next(), to = sc.next(); int c = sc.nextInt(), f = size, t = size;\n\t\t\t\tif(str2ind.containsKey(from)) f = str2ind.get(from);\n\t\t\t\telse {\n\t\t\t\t\tf = size; str2ind.put(from, size++);\n\t\t\t\t}\n\t\t\t\tif(str2ind.containsKey(to)) t = str2ind.get(to);\n\t\t\t\telse {\n\t\t\t\t\tt = size; str2ind.put(to, size++);\n\t\t\t\t}\n\n\t\t\t\tes.add(new E(f, t, c));\n\t\t\t}\n\n\t\t\tG = new V[size];\n\t\t\tfor(int i=0;i<size;i++) G[i] = new V();\n\n\t\t\tfor(E e: es) {\n\t\t\t\tG[e.f].add(new E(e.f, e.t, e.c));\n\t\t\t\tG[e.t].add(new E(e.t, e.f, e.c));\n\t\t\t}\n\t\t\tgas = new ArrayList<Integer>();\n\t\t\tgas.add(0); gas.add(1);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString p = sc.next();\n\t\t\t\tif(str2ind.containsKey(p)) gas.add(str2ind.get(p));\n\t\t\t}\n\t\t\tstr2ind.clear();\n\t\t\tes.clear();\n\n\t\t\tdist = new int[gas.size()][];\n\t\t\tfor(int i=0;i<gas.size();i++) dist[i] = dijkstra(gas.get(i));\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tint[] d = new int[gas.size()]; fill(d, INF); d[0] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(0, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\t\t\tif(cur.p == 1) return cur.d;\n\n\t\t\tfor(int i=0;i<gas.size();i++) if(dist[cur.p][i] <= cap * 10 && d[i] > cur.d + dist[cur.p][i]) {\n\t\t\t\tque.add(new P(i, cur.d + dist[cur.p][i]));\n\t\t\t\td[i] = cur.d + dist[cur.p][i];\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tint[] dijkstra(int s) {\n\t\tint[] d = new int[size];\n\t\tfill(d, INF); d[s] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(s, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\n\t\t\tfor(E next: G[cur.p]) if(d[next.t] > next.c + cur.d) {\n\t\t\t\td[next.t] = next.c + cur.d;\n\t\t\t\tque.add(new P(next.t, next.c + cur.d));\n\t\t\t}\n\t\t}\n\n\t\tint[] ret = new int[gas.size()];\n\t\tfor(int i=0;i<gas.size();i++) ret[i] = d[gas.get(i)];\n\t\treturn ret;\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint p, d;\n\t\tP(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn d-o.d;\n\t\t}\n\t}\n\n\tclass V extends ArrayList<E>{}\n\n\tclass E {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.t = t;this.f = f;this.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass Edge {\n\t\tint to;\n\t\tint c;\n\n\t\tEdge(int to, int c) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + to + \" \" + c + \")\";\n\t\t}\n\t}\n\t\n\tint[] dijkstra(ArrayList<Edge>[] g, int from) {\n\t\tint n = g.length;\n\t\tfinal int[] res = new int[n];\n\t\tArrays.fill(res, INF);\n\t\tres[from] = 0;\n\t\t\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>(10, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\treturn res[a] - res[b];\n\t\t\t}\n\t\t});\n\t\tpq.add(from);\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint u = pq.poll();\n\t\t\t\n\t\t\tfor (Edge e : g[u]) {\n\t\t\t\tif (res[u] + e.c < res[e.to]) {\n\t\t\t\t\tres[e.to] = res[u] + e.c;\n\t\t\t\t\tpq.add(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tint INF = 100000000;\n\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), cap = in.nextInt() * 10;\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tmap.clear();\n\t\t\tint size = 0;\n\t\t\tString src = in.next(), dst = in.next();\n\t\t\tmap.put(src, size++);\n\t\t\tmap.put(dst, size++);\n\t\t\t\n\t\t\tint[] u = new int[N];\n\t\t\tint[] v = new int[N];\n\t\t\tint[] d = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tString from = in.next(), to = in.next();\n\t\t\t\td[i] = in.nextInt();\n\t\t\t\t\n\t\t\t\tif (map.containsKey(from)) {\n\t\t\t\t\tu[i] = map.get(from);\n\t\t\t\t} else {\n\t\t\t\t\tu[i] = size;\n\t\t\t\t\tmap.put(from, size++);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (map.containsKey(to)) {\n\t\t\t\t\tv[i] = map.get(to);\n\t\t\t\t} else {\n\t\t\t\t\tv[i] = size;\n\t\t\t\t\tmap.put(to, size++);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Edge>[] g = new ArrayList[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tg[i] = new ArrayList<Edge>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[u[i]].add(new Edge(v[i], d[i]));\n\t\t\t\tg[v[i]].add(new Edge(u[i], d[i]));\n\t\t\t}\n\t\t\t\n\t\t\tint[] s = new int[M + 2];\n\t\t\tfor (int i = 1; i <= M; i++) {\n\t\t\t\tString name = in.next();\n\t\t\t\ts[i] = map.get(name);\n\t\t\t}\n\t\t\tint S = map.get(src), T = map.get(dst);\n\t\t\ts[0] = S;\n\t\t\ts[M+1] = T;\n\n\t\t\tArrayList<Edge>[] minCost = new ArrayList[M+2];\n\t\t\tfor (int i = 0; i < M + 2; i++) {\n\t\t\t\tminCost[i] = new ArrayList<Edge>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < M + 2; i++) {\n\t\t\t\tint[] cost = dijkstra(g, s[i]);\n\t\t\t\tfor (int j = 0; j < M + 2; j++) {\n\t\t\t\t\tminCost[i].add(new Edge(j, (cost[s[j]] <= cap) ? cost[s[j]] : INF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] res = dijkstra(minCost, 0);\n\t\t\tSystem.out.println(res[M+1] == INF ? -1 : res[M+1]);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint src = sc.next().hashCode();\n\t\t\tint dest = sc.next().hashCode();\n\t\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\tint[][] a = new int[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next().hashCode();\n\t\t\t\ta[i][1] = sc.next().hashCode();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next().hashCode());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> es;\n\tHashSet<Integer> gas;\n\tHashMap<Integer, HashSet<Integer>> gasmap;\n\t\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tes = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tgas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tgasmap = new HashMap<Integer, HashSet<Integer>>();\n\t\t\tfor(int a : gas){\n\t\t\t\tgasmap.put(a, new HashSet<Integer>());\n\t\t\t\tdfs(a, tank, a);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < gasmap.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(to == now.now) continue;\n\t\t\t\t\tif(! gasmap.get(now.now).contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int now, int tank, int start) {\n\t\t\n\t\tfor(int i = 0; i < es.get(now).size(); i++){\n\t\t\tint to = es.get(now).get(i).to;\n\t\t\tint cost = es.get(now).get(i).cost;\n\t\t\tif(tank - cost < 0) continue;\n\t\t\t\n\t\t\tif(gas.contains(to)){\n\t\t\t\tgasmap.get(start).add(to);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(to, tank - cost, start);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString src = sc.next();\n\t\t\tString dest = sc.next();\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\tString[][] a = new String[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next();\n\t\t\t\ta[i][1] = sc.next();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, tank, cost;\n\n\t\tpublic State(int now, int tank, int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.tank = tank;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tArrayList<ArrayList<Edge>> es = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tHashSet<Integer> gas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind, tank, 0));\n\t\t\tint [][] close = new int[v][tank + 1];\n\t\t\tint INF = 1 << 24;\n\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t}\n\t\t\tclose[startind][tank] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\tint nexttank = now.tank - cost;\n\t\t\t\t\tif(nexttank < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(gas.contains(to)){\n\t\t\t\t\t\tnexttank = tank;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(close[to][nexttank] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nexttank, nextcost));\n\t\t\t\t\tclose[to][nexttank] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tR[] town;\n\tint ID, M = 10000, INF = 1<<29;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\t\n\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tdist = new int[ID][10*cap+1];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn dist[o1/M][o1%M]-dist[o2/M][o2%M];\n\t\t\t\t}\n\t\t\t});\n\t\t\tdist[src.id][0] = 0;\n\t\t\tq.add(src.id*M);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint a = q.poll();\n\t\t\t\tint v = a/M, c = a%M;\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = dist[v][c]; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = dist[v][c] + e.d;\n\t\t\t\t\tif(10*cap<c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < dist[e.t][0]){\n\t\t\t\t\t\t\tdist[e.t][0] = w;\n\t\t\t\t\t\t\tq.add(e.t*M);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < dist[e.t][c+e.d]){\n\t\t\t\t\t\t\tdist[e.t][c+e.d] = w;\n\t\t\t\t\t\t\tq.add(e.t*M+c+e.d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tHashSet<Integer> canddest;\n\tArrayList<ArrayList<Edge>> es;\n\tHashSet<Integer> gas;\n\t\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tes = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tgas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcanddest = new HashSet<Integer>();\n\t\t\t\tdfs(now.now, tank);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(to == now.now) continue;\n\t\t\t\t\tif(! canddest.contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int now, int tank) {\n\t\t\n\t\tfor(int i = 0; i < es.get(now).size(); i++){\n\t\t\tint to = es.get(now).get(i).to;\n\t\t\tint cost = es.get(now).get(i).cost;\n\t\t\tif(tank - cost < 0) continue;\n\t\t\tif(canddest.contains(to)) continue;\n\t\t\t\n\t\t\tif(gas.contains(to)){\n\t\t\t\tcanddest.add(to);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(to, tank - cost);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tScanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK = 8*1024*1024;\n\t\tnew Thread(null, new AOJ1318(), \"RUN\", STACK).start();\n\t}\n\t\n\tclass AOJ1318 implements Runnable{\n\t\tAOJ1318(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tCAP=sc.nextInt()*10;\n\t\t\t\tif((N|(CAP))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N,M,CAP,Node;\n\t\tfinal int INF = 1<<29;\n\t\tHashMap<String,Integer> dic;\n\t\tArrayList<ArrayList<Edge>> g;\n\t\t\n\t\tvoid solve(){\n\t\t\tString src=sc.next(),dest=sc.next();\n\t\t\tdic = new HashMap<String,Integer>();\n\t\t\tArrayList<In> input = new ArrayList<In>();\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tString a=sc.next(),b=sc.next();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tif(!dic.containsKey(a))\tdic.put(a, dic.size());\n\t\t\t\tif(!dic.containsKey(b))\tdic.put(b, dic.size());\n\t\t\t\tinput.add(new In(a,b,d));\n\t\t\t}\n\t\t\t\n\t\t\tNode = dic.size();\n\t\t\t\n\t\t\tboolean[] chg = new boolean[Node];\n\t\t\tfor(int i=0; i<M; ++i)\tchg[dic.get(sc.next())]=true;\n\t\t\t\n\t\t\tg = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0; i<Node; ++i)\tg.add(new ArrayList<Edge>());\n\t\t\tfor(In i:input){\n\t\t\t\tint a=dic.get(i.a),b=dic.get(i.b);\n\t\t\t\tg.get(a).add(new Edge(b, i.d, chg[b]));\n\t\t\t\tg.get(b).add(new Edge(a, i.d, chg[a]));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println( Dijkstra(dic.get(src), dic.get(dest)) );\n\t\t\t\n\t\t}\n\t\t\n\t\tint Dijkstra(int src,int to){\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\topen.add(new State(src, 0, CAP));\n\t\t\t\n\t\t\tint[][] closed = new int[Node][CAP+1];\n\t\t\tfor(int i=0; i<Node; ++i)for(int j=0; j<=CAP; ++j)closed[i][j]=INF;\n\t\t\tfor(int i=0; i<=CAP; ++i)closed[src][i]=0;\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState now=open.poll();\n\t\t\t\tif(now.p==to)\treturn now.d;\n\t\t\t\t\n\t\t\t\tArrayList<Edge> cand = g.get(now.p);\n\t\t\t\tfor(Edge e:cand){\n\t\t\t\t\tif(now.c < e.dis)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tint nextCap = e.ch? CAP : now.c-e.dis,\n\t\t\t\t\t\tnextDis = now.d + e.dis;\n\t\t\t\t\t\n\t\t\t\t\tif(closed[e.to][nextCap] <= nextDis)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i=nextCap; i>=0; --i){\n\t\t\t\t\t\tif(closed[e.to][i] <= nextDis)\tbreak;\n\t\t\t\t\t\tclosed[e.to][i] = nextDis;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new State(e.to, nextDis, nextCap));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tclass State implements Comparable<State>{\n\t\t\tint p,d,c;\n\t\t\tState(int p,int d,int c){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(State o){\n\t\t\t\treturn this.d-o.d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass In{\n\t\t\tString a,b;\n\t\t\tint d;\n\t\t\tIn(String a,String b,int d){\n\t\t\t\tthis.a=a;\n\t\t\t\tthis.b=b;\n\t\t\t\tthis.d=d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass Edge{\n\t\t\tint to,dis;\n\t\t\tboolean ch;\n\t\t\tEdge(int to,int dis,boolean ch){\n\t\t\t\tthis.to=to;\n\t\t\t\tthis.dis=dis;\n\t\t\t\tthis.ch=ch;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID, INF = 1<<29, M = 2001;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tSet<E>[] adj;\n\tint[] d;\n\tboolean[] gas;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\td = new int[6000*2001];\n\t\tadj = new Set[6000];\n\t\tgas = new boolean[6000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tint S = reg(sc.next()), T = reg(sc.next());\n\t\t\tfor(int i=0;i<6000;i++)adj[i]=new HashSet<E>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint s = reg(sc.next()), t = reg(sc.next()), D = sc.nextInt();\n\t\t\t\tadj[s].add(new E(t, D)); adj[t].add(new E(s, D));\n\t\t\t}\n\t\t\tArrays.fill(gas, false);\n\t\t\twhile(m--!=0)gas[reg(sc.next())]=true;\n\t\t\tfor(int i=0;i<ID;i++)for(int j=0;j<=10*cap;j++)d[i*M+j]=INF;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\td[S*M+10*cap] = 0;\n\t\t\tq.add(S*M+10*cap);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tint p = v/M, c = v%M;\n\t\t\t\tif(p==T){\n\t\t\t\t\tres = d[v]; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\tif(c-e.c<=0)continue;\n\t\t\t\t\tint w = d[v]+e.c;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < d[e.t*M+10*cap]){\n\t\t\t\t\t\t\td[e.t*M+10*cap] = w; q.add(e.t*M+10*cap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < d[e.t*M+c-e.c]){\n\t\t\t\t\t\t\td[e.t*M+c-e.c] = w; q.add(e.t*M+c-e.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tArrayList<ArrayList<Edge>> es = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tHashSet<Integer> gas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tHashSet<Integer> canddest = new HashSet<Integer>();\n\t\t\t\tLinkedList<State> open2 = new LinkedList<State>();\n\t\t\t\topen2.add(new State(now.now, tank));\n\t\t\t\twhile(! open2.isEmpty()){\n\t\t\t\t\tState op2now = open2.poll();\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < es.get(op2now.now).size(); i++){\n\t\t\t\t\t\tint op2to = es.get(op2now.now).get(i).to;\n\t\t\t\t\t\tint op2cost = es.get(op2now.now).get(i).cost;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(op2now.cost - op2cost < 0) continue;\n\t\t\t\t\t\tif(op2to == now.now) continue;\n\t\t\t\t\t\tif(gas.contains(op2to)){\n\t\t\t\t\t\t\tcanddest.add(op2to);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen2.add(new State(op2to, op2now.cost - op2cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(! canddest.contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class CopyOfMain {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint src = sc.next().hashCode();\n\t\t\tint dest = sc.next().hashCode();\n\t\t\tint[] list = new int[6000];\n\t\t\tint[][] a = new int[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next().hashCode();\n\t\t\t\ta[i][1] = sc.next().hashCode();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tadd(list, a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = map(list, src);\n\t\t\tint gg = map(list, dest);\n\t\t\tint lvl = size(list);\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(map(list,a[i][0]), map(list,a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = map(list, sc.next().hashCode());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n\tpublic static void add(int[] l,int x) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == x) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (l[i] == 0) {\n\t\t\t\tl[i] = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int map(int[] l,int x) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static int size(int[] l) {\n\t\tint n = l.length;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (l[i] == 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString src = sc.next();\n\t\t\tString dest = sc.next();\n\t\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\tint[][] a = new int[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next().hashCode();\n\t\t\t\ta[i][1] = sc.next().hashCode();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next().hashCode());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString src = sc.next();\n\t\t\tString dest = sc.next();\n\t\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\tint[][] a = new int[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next().hashCode();\n\t\t\t\ta[i][1] = sc.next().hashCode();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next().hashCode());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint[] dist = g1.minDistDijkstra(s[i]);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = g2.minDistDijkstra(m)[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID, INF = 1<<29, M = 2001;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tSet<E>[] adj;\n\tint[] d;\n\tboolean[] gas;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\td = new int[6000*2001];\n\t\tadj = new Set[6000];\n\t\tgas = new boolean[6000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tint S = reg(sc.next()), T = reg(sc.next());\n\t\t\tfor(int i=0;i<6000;i++)adj[i]=new HashSet<E>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint s = reg(sc.next()), t = reg(sc.next()), D = sc.nextInt();\n\t\t\t\tadj[s].add(new E(t, D)); adj[t].add(new E(s, D));\n\t\t\t}\n\t\t\tArrays.fill(gas, false);\n\t\t\twhile(m--!=0)gas[reg(sc.next())]=true;\n\t\t\tfor(int i=0;i<ID;i++)for(int j=0;j<=10*cap;j++)d[i*M+j]=INF;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\td[S*M+10*cap] = 0;\n\t\t\tq.add(S*M+10*cap);\n\t\t\tint res = INF;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tint p = v/M, c = v%M;\n\t\t\t\tif(p==T){\n\t\t\t\t\tres = Math.min(res, d[v]); break;\n\t\t\t\t}\n\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\tif(c-e.c<0)continue;\n\t\t\t\t\tint w = d[v]+e.c;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < d[e.t*M+10*cap]){\n\t\t\t\t\t\t\td[e.t*M+10*cap] = w; q.add(e.t*M+10*cap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < d[e.t*M+c-e.c]){\n\t\t\t\t\t\t\td[e.t*M+c-e.c] = w; q.add(e.t*M+c-e.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tV[] G; int size, cap;\n\tArrayList<Integer> gas;\n\tArrayList<E> es = new ArrayList<E>();\n\tHashMap<String, Integer> str2ind;\n\tint[][] dist;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString from, to; int c, f, t, n, m;\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt(); m = sc.nextInt(); cap = sc.nextInt();\n\t\t\tif((n|m|cap) == 0 )  break;\n\n\t\t\tstr2ind = new HashMap<String, Integer>();\n\t\t\tsize = 2;\n\t\t\tstr2ind.put(sc.next(), 0); str2ind.put(sc.next(), 1);\n\t\t\tes = new ArrayList<E>();\n\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfrom = sc.next(); to = sc.next(); c = sc.nextInt(); f = size; t = size;\n\t\t\t\tif(str2ind.containsKey(from)) f = str2ind.get(from);\n\t\t\t\telse {\n\t\t\t\t\tf = size; str2ind.put(from, size++);\n\t\t\t\t}\n\t\t\t\tif(str2ind.containsKey(to)) t = str2ind.get(to);\n\t\t\t\telse {\n\t\t\t\t\tt = size; str2ind.put(to, size++);\n\t\t\t\t}\n\n\t\t\t\tes.add(new E(f, t, c));\n\t\t\t}\n\n\t\t\tG = new V[size];\n\t\t\tfor(int i=0;i<size;i++) G[i] = new V();\n\n\t\t\tfor(E e: es) {\n\t\t\t\tG[e.f].add(new E(e.f, e.t, e.c));\n\t\t\t\tG[e.t].add(new E(e.t, e.f, e.c));\n\t\t\t}\n\t\t\tgas = new ArrayList<Integer>();\n\t\t\tgas.add(0); gas.add(1);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString p = sc.next();\n\t\t\t\tif(str2ind.containsKey(p)) gas.add(str2ind.get(p));\n\t\t\t}\n\n\t\t\tstr2ind.clear();\n\t\t\tes.clear();\n\n\t\t\tdist = new int[gas.size()][];\n\t\t\tfor(int i=0;i<gas.size();i++) dist[i] = dijkstra(gas.get(i));\n\t\t\tsize = gas.size();\n\t\t\tgas.clear();\n\t\t\tfor(V v: G) v.clear();\n\t\t\tG = new V[]{};\n\t\t\t\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tint[] d = new int[size]; fill(d, INF); d[0] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(0, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\t\t\tif(cur.p == 1) return cur.d;\n\n\t\t\tfor(int i=0;i<size;i++) if(dist[cur.p][i] <= cap * 10 && d[i] > cur.d + dist[cur.p][i]) {\n\t\t\t\tque.add(new P(i, cur.d + dist[cur.p][i]));\n\t\t\t\td[i] = cur.d + dist[cur.p][i];\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tint[] dijkstra(int s) {\n\t\tint[] d = new int[size];\n\t\tfill(d, INF); d[s] = 0;\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(s, 0));\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP cur = que.remove();\n\t\t\tif(d[cur.p] != cur.d) continue;\n\n\t\t\tfor(E next: G[cur.p]) if(d[next.t] > next.c + cur.d) {\n\t\t\t\td[next.t] = next.c + cur.d;\n\t\t\t\tque.add(new P(next.t, next.c + cur.d));\n\t\t\t}\n\t\t}\n\n\t\tint[] ret = new int[gas.size()];\n\t\tfor(int i=0;i<gas.size();i++) ret[i] = d[gas.get(i)];\n\t\treturn ret;\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint p, d;\n\t\tP(int p, int d) {\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn d-o.d;\n\t\t}\n\t}\n\n\tclass V extends ArrayList<E>{}\n\n\tclass E {\n\t\tint f, t, c;\n\t\tE(int f, int t, int c) {\n\t\t\tthis.t = t;this.f = f;this.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n\tMap<Integer, Integer>[] dist;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tdist = new HashMap[ID];\n\t\t\tfor(int i=0;i<ID;i++)dist[i]=new HashMap<Integer, Integer>();\n\t\t\tdist[src.id].put(0, 0);\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = time; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(!dist[e.t].containsKey(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dist[e.t].containsKey(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tArrayList<ArrayList<Edge>> es;\n\tHashSet<Integer> gas;\n\tHashMap<Integer, HashSet<Integer>> gasmap;\n\t\n\tclass Edge{\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t\t\n\t}\n\t\n\tclass State implements Comparable<State>{\n\t\tint now, cost;\n\n\t\tpublic State(int now,int cost) {\n\t\t\tthis.now = now;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [now=\" + now + \", cost=\" + cost + \"]\";\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint tank = sc.nextInt();\n\t\t\tif((m|n|tank) ==0) break;\n\t\t\ttank *= 10;\n\t\t\tes = new ArrayList<ArrayList<Main.Edge>>();\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tString start = sc.next();\n\t\t\tString end = sc.next();\n\t\t\tint startind = -1, endind = -1;\n\t\t\tif(table.containsKey(start)){\n\t\t\t\tstartind = table.get(start);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartind = table.size();\n\t\t\t\ttable.put(start, table.size());\n\t\t\t}\n\t\t\tif(table.containsKey(endind)){\n\t\t\t\tendind= table.get(end);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tendind = table.size();\n\t\t\t\ttable.put(end, table.size());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tString t = sc.next();\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tint inds = -1, indt = -1;\n\t\t\t\tif(table.containsKey(s)){\n\t\t\t\t\tinds = table.get(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinds = table.size();\n\t\t\t\t\ttable.put(s, table.size());\n\t\t\t\t}\n\t\t\t\tif(table.containsKey(t)){\n\t\t\t\t\tindt = table.get(t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tindt = table.size();\n\t\t\t\t\ttable.put(t, table.size());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= inds){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\twhile(es.size()<= indt){\n\t\t\t\t\tes.add(new ArrayList<Main.Edge>());\n\t\t\t\t}\n\t\t\t\tes.get(inds).add(new Edge(inds, indt, cost));\n\t\t\t\tes.get(indt).add(new Edge(indt, inds, cost));\n\t\t\t}\n\t\t\tint v = es.size();\n\t\t\t\n\t\t\tgas = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint ind = table.get(sc.next());\n\t\t\t\tgas.add(ind);\n\t\t\t}\n\t\t\tgas.add(startind);gas.add(endind);\n\t\t\t\n\t\t\tgasmap = new HashMap<Integer, HashSet<Integer>>();\n\t\t\tfor(int a : gas){\n\t\t\t\tgasmap.put(a, new HashSet<Integer>());\n\t\t\t\tdfs(a, tank, a);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(startind,0));\n\t\t\tint [] close = new int[v];\n\t\t\tArrays.fill(close, INF);\n\t\t\tclose[startind] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(now.now == endind){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < es.get(now.now).size(); i++){\n\t\t\t\t\tint to = es.get(now.now).get(i).to;\n\t\t\t\t\tif(to == now.now) continue;\n\t\t\t\t\tif(! gasmap.get(now.now).contains(to)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint cost = es.get(now.now).get(i).cost;\n\t\t\t\t\tint nextcost = now.cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tif(close[to] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(to, nextcost));\n\t\t\t\t\tclose[to] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int now, int tank, int start) {\n\t\t\n\t\tfor(int i = 0; i < es.get(now).size(); i++){\n\t\t\tint to = es.get(now).get(i).to;\n\t\t\tint cost = es.get(now).get(i).cost;\n\t\t\tif(tank - cost < 0) continue;\n\t\t\t\n\t\t\tif(gas.contains(to)){\n\t\t\t\tgasmap.get(start).add(to);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(to, tank - cost, start);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tMap<String, Integer> ref;\n\tint ID, INF = 1<<29, M = 2001;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tSet<E>[] adj;\n\tint[] d;\n\tboolean[] gas;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\td = new int[6000*2001];\n\t\tadj = new Set[6000];\n\t\tgas = new boolean[6000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tint S = reg(sc.next()), T = reg(sc.next());\n\t\t\tfor(int i=0;i<6000;i++)adj[i]=new HashSet<E>();\n\t\t\twhile(n--!=0){\n\t\t\t\tint s = reg(sc.next()), t = reg(sc.next()), D = sc.nextInt();\n\t\t\t\tadj[s].add(new E(t, D)); adj[t].add(new E(s, D));\n\t\t\t}\n\t\t\tArrays.fill(gas, false);\n\t\t\twhile(m--!=0)gas[reg(sc.next())]=true;\n\t\t\tfor(int i=0;i<ID;i++)for(int j=0;j<=10*cap;j++)d[i*M+j]=INF;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(ID, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\td[S*M+10*cap] = 0;\n\t\t\tq.add(S*M+10*cap);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tint p = v/M, c = v%M;\n\t\t\t\tif(p==T){\n\t\t\t\t\tres = d[v]; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\tif(c-e.c<0)continue;\n\t\t\t\t\tint w = d[v]+e.c;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(w < d[e.t*M+10*cap]){\n\t\t\t\t\t\t\td[e.t*M+10*cap] = w; q.add(e.t*M+10*cap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(w < d[e.t*M+c-e.c]){\n\t\t\t\t\t\t\td[e.t*M+c-e.c] = w; q.add(e.t*M+c-e.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n\tMap<Integer, Integer>[] dist;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tdist = new HashMap[ID];\n\t\t\tfor(int i=0;i<ID;i++)dist[i]=new HashMap<Integer, Integer>();\n\t\t\tdist[src.id].put(0, 0);\n\t\t\tint[] min = new int[ID], best = new int[ID];\n\t\t\tArrays.fill(min, INF); Arrays.fill(best, INF);\n\t\t\tmin[src.id] = 0; best[src.id] = 0;\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = time; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d)continue;\n\t\t\t\t\tif(min[e.t]<c+e.d&&best[e.t]<w)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(!dist[e.t].containsKey(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t\tmin[e.t] = Math.min(min[e.t], 0);\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(0)){\n\t\t\t\t\t\t\tdist[e.t].put(0, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t\tmin[e.t] = Math.min(min[e.t], 0);\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dist[e.t].containsKey(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t\tmin[e.t] = Math.min(min[e.t], c+e.d);\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<dist[e.t].get(c+e.d)){\n\t\t\t\t\t\t\tdist[e.t].put(c+e.d, w);\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t\tmin[e.t] = Math.min(min[e.t], c+e.d);\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n\t//\tint[][] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tint[] min = new int[ID];\n\t\t\tint[] rec = new int[ID];\n\t\t\tArrays.fill(min, INF);\n\t\t\tArrays.fill(rec, INF);\n\t\t\tmin[src.id] = 0;\n\t\t\trec[src.id] = 0;\n\t\t\t//\t\t\tdist = new int[ID][10*cap+1];\n\t\t\t//\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\t//\t\t\tdist[src.id][0] = 0;\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = -1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = time; break;\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d||min[e.t]<c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(0<min[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tmin[e.t] = 0;\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==min[e.t]&&w<rec[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(c+e.d<min[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tmin[e.t] = c+e.d;\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c+e.d==min[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int[] dist = new int[6000];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint cap = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString src = sc.next();\n\t\t\tString dest = sc.next();\n\t\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\tString[][] a = new String[n][2];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i][0] = sc.next();\n\t\t\t\ta[i][1] = sc.next();\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<2;j++) {\n\t\t\t\t\tif (!hm.containsKey(a[i][j])) {\n\t\t\t\t\t\thm.put(a[i][j], hm.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ss = hm.get(src);\n\t\t\tint gg = hm.get(dest);\n\t\t\tint lvl = hm.size();\n\t\t\tGraph g1 = new Graph(lvl);\n\t\t\tGraph g2 = new Graph(m+3);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tg1.addBidirectionalEdge(hm.get(a[i][0]), hm.get(a[i][1]), d[i]);\n\t\t\t}\n\t\t\tint[] s = new int[m];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\ts[i] = hm.get(sc.next());\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tg1.minDistDijkstra(s[i],dist);\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (dist[j] <= cap * 10) {\n\t\t\t\t\t\tg2.addBidirectionalEdge(i, j, dist[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[ss] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m, dist[ss]);\n\t\t\t\t}\n\t\t\t\tif (dist[gg] <= cap * 10) {\n\t\t\t\t\tg2.addBidirectionalEdge(i, m+1, dist[gg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tg2.minDistDijkstra(m,dist);\n\t\t\tint ans = dist[m+1];\n\t\t\tSystem.out.println(ans >= Graph.INF ? -1 : ans);\n\t\t}\n\t}\n\n}\n\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s,int[] dist) {\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\t//O(E) all cost is 0 or 1\n\tpublic int[] minDistQueue(int s) {\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\td[s] = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint v = q.pollFirst();\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tint u = e.to;\n\t\t\t\tif (d[v] + e.cost < d[u]) {\n\t\t\t\t\td[u] = d[v] + e.cost;\n\t\t\t\t\tif (e.cost == 0) {\n\t\t\t\t\t\tq.addFirst(u);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.addLast(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t//topologicalSort O(V+E)\n\tpublic ArrayList<Integer> topologicalSort() {\n\t\tArrayList<Integer> order = new ArrayList<Integer>();\n\t\tint[] col = new int[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (col[u] == 0 && !visitTS(order, col, u)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(order);\n\t\treturn order;\n\t}\n\tprivate boolean visitTS(ArrayList<Integer> order,int[] col ,int v) {\n\t\tcol[v] = 1;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tif (col[e.to] == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (col[e.to] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visitTS(order, col, e.to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\torder.add(v);\n\t\tcol[v] = 2;\n\t\treturn true;\n\t}\n\n\t//longest Path in DAG\n\tpublic ArrayList<Integer> longestPathInDAG(int s,int g) {\n\t\tint[] dist = new int[n];\n\t\tint[] bef = new int[n];\n\t\tArrays.fill(dist, -INF);\n\t\tArrays.fill(bef, -1);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn null;\n\t\t}\n\t\tdist[s] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tbef[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tint now = g;\n\t\twhile(true) {\n\t\t\tpath.add(now);\n\t\t\tif (bef[now] != -1) {\n\t\t\t\tnow = bef[now];\n\t\t\t\tif (now == s) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tpath.add(now);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\tpublic int longestPathLengthInDAG() {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, 0);\n\t\tArrayList<Integer> order = topologicalSort();\n\t\tif (order == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint u = order.get(i);\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] < dist[u] + e.cost) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tmax = Math.max(max,dist[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tint time = 0;\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int time) {\n\t\tlow[v] = num[v] = ++time;\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\t//dont' remove multiple edge\n\tpublic Graph noSCCGraph(int[] map) {\n\t\tArrayList<ArrayList<Integer>> scc = stronglyConnectedComponents();\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph h = new Graph(m);\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\th.addEdge(map[u], map[e.to], e.cost);\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Long Distance Taxi\npublic class Main{\n\n\tclass R{\n\t\tint id;\n\t\tSet<E> adj;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new HashSet<E>();\n\t\t}\n\t}\n\tclass E{\n\t\tint t, d;\n\t\tpublic E(int t, int d) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tR[] town;\n\tint ID, INF = 1<<29;\n\tlong M = 10000, MM = 100000000;\n\tMap<String, R> ref;\n\tR get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tR r = new R(ID);\n\t\tref.put(s, r);\n\t\treturn town[ID++] = r;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), cap = sc.nextInt();\n\t\t\tif((n|m|cap)==0)break;\n\t\t\tref = new HashMap<String, R>();\n\t\t\tID = 0;\n\t\t\ttown = new R[2*n];\n\t\t\tR src = get(sc.next()), dest = get(sc.next());\n\t\t\twhile(n--!=0){\n\t\t\t\tR s = get(sc.next()), t = get(sc.next());\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\ts.adj.add(new E(t.id, d));\n\t\t\t\tt.adj.add(new E(s.id, d));\n\t\t\t}\n\t\t\tboolean[] gas = new boolean[ID];\n\t\t\twhile(m--!=0){\n\t\t\t\tR r = get(sc.next());\n\t\t\t\tgas[r.id] = true;\n\t\t\t}\n\t\t\tint[] min = new int[ID];\n\t\t\tint[] rec = new int[ID];\n\t\t\tint[] best = new int[ID];\n\t\t\tArrays.fill(min, INF);\n\t\t\tArrays.fill(rec, INF);\n\t\t\tArrays.fill(best, INF);\n\t\t\tbest[src.id] = 0;\n\t\t\tmin[src.id] = 0;\n\t\t\trec[src.id] = 0;\n\t\t\tPriorityQueue<Long> q = new PriorityQueue<Long>(ID, new Comparator<Long>() {\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\treturn (int) Math.signum((o1%M)-(o2%M));\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(src.id*MM);\n\t\t\tint res = INF;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tlong a = q.poll();\n\t\t\t\tint v = (int) (a/MM), c = (int) ((a%MM)/M), time = (int) (a%M);\n\t\t\t\tif(v==dest.id){\n\t\t\t\t\tres = Math.min(res, time);\n\t\t\t\t}\n\t\t\t\tfor(E e:town[v].adj){\n\t\t\t\t\tint w = time + e.d;\n\t\t\t\t\tif(10*cap<c+e.d||min[e.t]<c+e.d)continue;\n\t\t\t\t\tif(gas[e.t]){\n\t\t\t\t\t\tif(0<min[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tmin[e.t] = 0;\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==min[e.t]&&w<rec[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<best[e.t]){\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t\tq.add(e.t*MM+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(c+e.d<min[e.t]){\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t\tmin[e.t] = c+e.d;\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c+e.d==min[e.t]&&w<rec[e.t]){\n\t\t\t\t\t\t\tbest[e.t] = Math.min(best[e.t], w);\n\t\t\t\t\t\t\trec[e.t] = w;\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(w<best[e.t]){\n\t\t\t\t\t\t\tbest[e.t] = w;\n\t\t\t\t\t\t\tq.add(e.t*MM+(c+e.d)*M+w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res==INF?-1:res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass Edge {\n\t\tint to;\n\t\tint c;\n\n\t\tEdge(int to, int c) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + to + \" \" + c + \")\";\n\t\t}\n\t}\n\t\n\tint[] dijkstra(ArrayList<Edge>[] g, int from) {\n\t\tint n = g.length;\n\t\tfinal int[] res = new int[n];\n\t\tArrays.fill(res, INF);\n\t\tres[from] = 0;\n\t\t\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>(10, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\treturn res[a] - res[b];\n\t\t\t}\n\t\t});\n\t\tpq.add(from);\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint u = pq.poll();\n\t\t\t\n\t\t\tfor (Edge e : g[u]) {\n\t\t\t\tif (res[u] + e.c < res[e.to]) {\n\t\t\t\t\tres[e.to] = res[u] + e.c;\n\t\t\t\t\tpq.add(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tint INF = 100000000;\n\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), cap = in.nextInt() * 10;\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tmap.clear();\n\t\t\tint size = 0;\n\t\t\tString src = in.next(), dst = in.next();\n\t\t\tmap.put(src, size++);\n\t\t\tmap.put(dst, size++);\n\t\t\t\n\t\t\tint[] u = new int[N];\n\t\t\tint[] v = new int[N];\n\t\t\tint[] d = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tString from = in.next(), to = in.next();\n\t\t\t\td[i] = in.nextInt();\n\t\t\t\t\n\t\t\t\tif (map.containsKey(from)) {\n\t\t\t\t\tu[i] = map.get(from);\n\t\t\t\t} else {\n\t\t\t\t\tu[i] = size;\n\t\t\t\t\tmap.put(from, size++);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (map.containsKey(to)) {\n\t\t\t\t\tv[i] = map.get(to);\n\t\t\t\t} else {\n\t\t\t\t\tv[i] = size;\n\t\t\t\t\tmap.put(to, size++);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<Edge>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[u[i]].add(new Edge(v[i], d[i]));\n\t\t\t\tg[v[i]].add(new Edge(u[i], d[i]));\n\t\t\t}\n\t\t\t\n\t\t\tint[] s = new int[M + 3];\n\t\t\tfor (int i = 1; i <= M; i++) {\n\t\t\t\tString name = in.next();\n\t\t\t\ts[i] = map.get(name);\n\t\t\t}\n\t\t\tint S = map.get(src), T = map.get(dst);\n\t\t\ts[0] = S;\n\t\t\ts[M+1] = T;\n\n\t\t\tArrayList<Edge>[] minCost = new ArrayList[M+2];\n\t\t\tfor (int i = 0; i < M + 2; i++) {\n\t\t\t\tminCost[i] = new ArrayList<Edge>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= M + 1; i++) {\n\t\t\t\tint[] cost = dijkstra(g, s[i]);\n\t\t\t\tfor (int j = 0; j < M + 2; j++) {\n\t\t\t\t\tminCost[i].add(new Edge(j, (cost[s[j]] <= cap) ? cost[s[j]] : INF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] res = dijkstra(minCost, 0);\n\t\t\tSystem.out.println(res[M+1] == INF ? -1 : res[M+1]);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass Edge {\n\t\tint to;\n\t\tint c;\n\n\t\tEdge(int to, int c) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + to + \" \" + c + \")\";\n\t\t}\n\t}\n\t\n\tint[] dijkstra(ArrayList<Edge>[] g, int from) {\n\t\tint n = g.length;\n\t\tint[] res = new int[n];\n\t\tArrays.fill(res, INF);\n\t\tres[from] = 0;\n\t\t\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>(10, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\treturn res[a] - res[b];\n\t\t\t}\n\t\t});\n\t\tpq.add(from);\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint u = pq.poll();\n\t\t\t\n\t\t\tfor (Edge e : g[u]) {\n\t\t\t\tif (res[u] + e.c < res[e.to]) {\n\t\t\t\t\tres[e.to] = res[u] + e.c;\n\t\t\t\t\tpq.add(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tint INF = 100000000;\n\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt(), cap = in.nextInt() * 10;\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tmap.clear();\n\t\t\tint size = 0;\n\t\t\tString src = in.next(), dst = in.next();\n\t\t\tmap.put(src, size++);\n\t\t\tmap.put(dst, size++);\n\t\t\t\n\t\t\tint[] u = new int[N];\n\t\t\tint[] v = new int[N];\n\t\t\tint[] d = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tString from = in.next(), to = in.next();\n\t\t\t\td[i] = in.nextInt();\n\t\t\t\t\n\t\t\t\tif (map.containsKey(from)) {\n\t\t\t\t\tu[i] = map.get(from);\n\t\t\t\t} else {\n\t\t\t\t\tu[i] = size;\n\t\t\t\t\tmap.put(from, size++);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (map.containsKey(to)) {\n\t\t\t\t\tv[i] = map.get(to);\n\t\t\t\t} else {\n\t\t\t\t\tv[i] = size;\n\t\t\t\t\tmap.put(to, size++);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<Edge>();\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[u[i]].add(new Edge(v[i], d[i]));\n\t\t\t\tg[v[i]].add(new Edge(u[i], d[i]));\n\t\t\t}\n\t\t\t\n\t\t\tint[] s = new int[M + 3];\n\t\t\tfor (int i = 1; i <= M; i++) {\n\t\t\t\tString name = in.next();\n\t\t\t\ts[i] = map.get(name);\n\t\t\t}\n\t\t\tint S = map.get(src), T = map.get(dst);\n\t\t\ts[0] = S;\n\t\t\ts[M+1] = T;\n\n\t\t\tArrayList<Edge>[] minCost = new ArrayList[M+2];\n\t\t\tfor (int i = 0; i < M + 2; i++) {\n\t\t\t\tminCost[i] = new ArrayList<Edge>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= M + 1; i++) {\n\t\t\t\tint[] cost = dijkstra(g, s[i]);\n\t\t\t\tfor (int j = 0; j < M + 2; j++) {\n\t\t\t\t\tminCost[i].add(new Edge(j, (cost[s[j]] <= cap) ? cost[s[j]] : INF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] res = dijkstra(minCost, 0);\n\t\t\tSystem.out.println(res[M+1] == INF ? -1 : res[M+1]);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\n//using static System.Math;\nnamespace Program {\n    public class Solver {\n        //Random rnd = new Random();\n        public void Solve() {\n            for (; ; )\n            {\n                var n = ri; var m = ri;\n                var cap = ri * 10;\n                if (n == 0) return;\n                var src = rs;\n                var sink = rs;\n                Debug.WriteLine(src);\n                Debug.WriteLine(sink);\n                var from = new string[n];\n                var to = new string[n];\n                var w = new int[n];\n                for (int i = 0; i < n; i++)\n                {\n                    from[i] = rs;\n                    to[i] = rs;\n                    w[i] = ri;\n                }\n                var special = new string[m];\n                for (int i = 0; i < m; i++)\n                    special[i] = rs;\n                var s = new List<string>() { src, sink };\n                s.AddRange(from); s.AddRange(to); s.AddRange(special);\n                s = s.Distinct().ToList();\n                var f = from.Select(x => s.FindIndex(y => y == x)).ToArray();\n                var t = to.Select(x => s.FindIndex(y => y == x)).ToArray();\n                var sp = new bool[s.Count];\n                foreach (var x in special)\n                    sp[s.FindIndex(y => y == x)] = true;\n                solve(s.Count,\n                s.FindIndex(y => y == src),\n                s.FindIndex(y => y == sink),\n                f, t, w, cap, sp);\n            }\n        }\n        void solve(int n, int src, int sink, int[] f, int[] t, int[] w, int c, bool[] sp) {\n            var G = Enumerate(n, x => new List<KeyValuePair<int, int>>());\n            for (int i = 0; i < f.Length; i++)\n            {\n                G[f[i]].Add(new KeyValuePair<int, int>(t[i], w[i]));\n                G[t[i]].Add(new KeyValuePair<int, int>(f[i], w[i]));\n            }\n            var dist = new int[n, c + 1];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j <= c; j++)\n                    dist[i, j] = 1000000000;\n            dist[src, c] = 0;\n            var pq = new PriorityQueue<KeyValuePair<int, int>>((l, r) => l.Value.CompareTo(r.Value));\n            pq.Enqueue(new KeyValuePair<int, int>(src * 10000 + c, 0));\n            while (pq.Any())\n            {\n                var p = pq.Dequeue();\n                var pos = p.Key / 10000;\n                var cap = p.Key % 10000;\n                if (dist[pos, cap] < p.Value) continue;\n                if (pos == sink)\n                {\n                    Console.WriteLine(p.Value); return;\n                }\n                //Debug.WriteLine($\"{pos} {cap} {p.Value}\");\n                foreach (var e in G[pos])\n                {\n                    var to = e.Key;\n                    var nc = cap - e.Value;\n                    if (nc < 0) continue;\n                    if (sp[to]) nc = c;\n                    var nw = p.Value + e.Value;\n                    if (nc >= 0 && dist[to, nc] > nw)\n                    {\n                        dist[to, nc] = nw;\n                        pq.Enqueue(new KeyValuePair<int, int>(to * 10000 + nc, nw));\n\n                    }\n                }\n            }\n            Console.WriteLine(-1);\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    /*\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }*/\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region BinaryHeap\npublic class PriorityQueue<T> {\n    readonly List<T> heap = new List<T>();\n    readonly Comparison<T> compare;\n    public PriorityQueue() { compare = Comparer<T>.Default.Compare; }\n\n    public PriorityQueue(Comparison<T> comparison) { compare = comparison; }\n    public PriorityQueue(IComparer<T> comparer) { compare = comparer.Compare; }\n\n    public void Enqueue(T item) {\n        var pos = heap.Count;\n        heap.Add(item);\n        while (pos > 0)\n        {\n            var par = (pos - 1) / 2;\n            if (compare(heap[par], item) <= 0)\n                break;\n            heap[pos] = heap[par];\n            pos = par;\n        }\n        heap[pos] = item;\n\n    }\n\n    public T Dequeue() {\n        var ret = heap[0];\n        var pos = 0;\n        var x = heap[heap.Count - 1];\n\n        while (pos * 2 + 1 < heap.Count - 1)\n        {\n            var lch = pos * 2 + 1;\n            var rch = pos * 2 + 2;\n            if (rch < heap.Count - 1 && compare(heap[rch], heap[lch]) < 0) lch = rch;\n            if (compare(heap[lch], x) >= 0)\n                break;\n            heap[pos] = heap[lch];\n            pos = lch;\n        }\n        heap[pos] = x;\n        heap.RemoveAt(heap.Count - 1);\n        return ret;\n\n    }\n    public T Peek() { return heap[0]; }\n    public int Count { get { return heap.Count; } }\n    public bool Any() { return heap.Count > 0; }\n\n    public T[] Items {\n        get {\n            var ret = heap.ToArray();\n            Array.Sort(ret, compare);\n            return ret;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start, max_dist = Float::INFINITY)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tbreak if key > max_dist\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\n\nloop {\n\tm, n, $l = gets.split.map &:to_i\n\tbreak if n == 0\n\t$l *= 10\n\n\tstart, goal = gets.chomp.split\n\n\t$g = Graph.new\n\tnodes = {start => $g.add_node, goal => $g.add_node}\n\torig_edges = []\n\n\tm.times {\n\t\ts, t, d = gets.chomp.split\n\t\td = d.to_i\n\t\t$g.add_edge(nodes[s] ||= $g.add_node, nodes[t] ||= $g.add_node, {:length => d}) if d <= $l\n\t}\n\n\t$stations = [nodes[start], nodes[goal]]\n\tn.times {\n\t\t$stations << (nodes[gets.chomp] ||= $g.add_node)\n\t}\n\n\tinclude Graphical\n\tdef each_out_connection_of(u)\n\t\tdist = $g.dijkstra([u], $l)\n\t\t$stations.each{|v|\n\t\t\tnext if u == v\n\t\t\tyield(v, dist[v]) if dist[v]\n\t\t}\n\tend\n\talias :each_in_connection_of :each_out_connection_of\n\n\tp bidir_dijkstra(nodes[start], nodes[goal]) || -1\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop {\n\tm, n, l = gets.split.map &:to_i\n\tbreak if n == 0\n\tl *= 10\n\n\tstart, goal = gets.chomp.split\n\n\tg = Graph.new\n\tnodes = {}\n\torig_edges = []\n\n\tm.times {\n\t\ts, t, d = gets.chomp.split\n\t\td = d.to_i\n\t\torig_edges << g.add_edge(nodes[s] ||= g.add_node, nodes[t] ||= g.add_node, {:length => d}) if d <= l\n\t}\n\n\tstations = [nodes[start], nodes[goal]]\n\tn.times {\n\t\tstations << (nodes[gets.chomp] ||= g.add_node)\n\t}\n\n\tstations.each{|u|\n\t\tdist = g.dijkstra([u])\n\t\tstations.each{|v|\n\t\t\tg.add_edge(u, v, {:length => dist[v]}) if dist[v] && dist[v] <= l\n\t\t}\n\t}\n\torig_edges.each{|e|\n\t\tg.del_edge(e)\n\t}\n\n\tp g.dijkstra([nodes[start]]){|v| v == nodes[goal]} || -1\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\n### main\n\nloop do\n  n, m, cap = gets.split.map(&:to_i)\n  break if (n | m | cap) == 0\n\n  scty, dcty = gets.strip.split\n\n  nc = 0\n  chash = {}\n  rds = []\n  \n  n.times do\n    cti0, cti1, di = gets.strip.split\n\n    if chash[cti0].nil?\n      chash[cti0] = nc\n      nc += 1\n    end\n    if chash[cti1].nil?\n      chash[cti1] = nc\n      nc += 1\n    end\n\n    c0 = chash[cti0]\n    c1 = chash[cti1]\n    di = di.to_i\n\n    rds << [c0, c1, di]\n  end\n\n  edges = Array.new(nc){Array.new(nc){nil}}\n  nbrs = Array.new(nc){[]}\n\n  rds.each do |c0, c1, di|\n    edges[c0][c1] = edges[c1][c0] = di\n    nbrs[c0] << c1\n    nbrs[c1] << c0\n  end\n  #p edges\n  #p nbrs\n\n  gss = Array.new(nc){false}\n  m.times do\n    gss[chash[gets.strip]] = true\n  end\n  #p gss\n\n  sc = chash[scty]\n  dc = chash[dcty]\n  #p [sc, dc]\n\n  max_d = cap * 10\n\n  dists = Array.new(nc){Array.new(max_d + 1){INF}}\n  dists[sc][0] = 0\n  q = [[sc, 0]]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a[0]][a[1]] <=> dists[b[0]][b[1]]}\n    q.delete(u)\n\n    uc, ug = u\n    next if uc == dc\n\n    ud = dists[uc][ug]\n    ug = 0 if gss[uc]\n    \n    for vc in nbrs[uc]\n      vg = ug + edges[uc][vc]\n      next if vg > max_d\n\n      nvd = ud + edges[uc][vc]\n      if dists[vc][vg] > nvd\n        dists[vc][vg] = nvd\n        q << [vc, vg]\n      end\n    end\n  end\n\n  min_d = dists[dc].min\n  puts (min_d >= INF ? -1 : min_d)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nvoid main() {\n    int N, M, Cap;\n    int src, dst;\n    int V;\n    int[string] id;\n    Edge[][] G;\n    bool[] hasGas;\n    int[] gas;\n    int[int] gasId;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &Cap);\n        if (N == 0 && M == 0 && Cap == 0) return false;\n        Cap *= 10;\n        id.destroy;\n        gasId.destroy;\n        G = new Edge[][N * 2 + 2];\n        hasGas = new bool[N * 2 + 2];\n        gas.destroy;\n        auto xs = readln.chomp.split;\n        string src_s = xs[0],\n               dst_s = xs[1];\n        int cid = 0;\n        id[src_s] = cid++;\n        id[dst_s] = cid++;\n        foreach (i; 0 .. N) {\n            xs = readln.chomp.split;\n            string from_s = xs[0],\n                     to_s = xs[1];\n            int      cost = xs[2].to!int;\n            if (from_s !in id) id[from_s] = cid++;\n            if (to_s !in id) id[to_s] = cid++;\n            int from = id[from_s],\n                  to = id[to_s];\n            G[from] ~= Edge(from, to, cost);\n            G[to]   ~= Edge(to, from, cost);\n        }\n        int gid = 0;\n        src = id[src_s];\n        hasGas[src] = true;\n        gas ~= src;\n        gasId[src] = gid++;\n        dst = id[dst_s];\n        hasGas[dst] = true;\n        gas ~= dst;\n        gasId[dst] = gid++;\n        foreach (i; 0 .. M) {\n            string s = readln.chomp;\n            int v = id[s];\n            hasGas[v] = true;\n            gas ~= v;\n            if (v !in gasId) {\n                gasId[v] = gid++;\n            }\n        }\n        V = cid;\n        return true;\n    }\n    const INF = int.max / 2;\n    Edge[][] GG;\n    struct S {\n        int v, cost;\n    }\n    void Dijkstra(int v) {\n        static int D[6002];\n        D[0 .. V] = INF;\n        BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n        PQ.insert(S(v, 0));\n        D[v] = 0;\n        while (!PQ.empty) {\n            S s = PQ.front; PQ.removeFront;\n            foreach (e; G[s.v]) {\n                auto next = S(e.to, s.cost + e.cost);\n                if (next.cost > Cap) continue;\n                if (D[next.v] <= next.cost) continue;\n                D[next.v] = next.cost;\n                PQ.insert(next);\n            }\n        }\n        foreach (g; gas) {\n            if (D[g] < INF) {\n                GG[ gasId[v] ] ~= Edge(gasId[v], gasId[g], D[g]);\n            }\n        }\n    }\n    void solve() {\n        const X = M + 2;\n        GG = new Edge[][V];\n        foreach (g; gas) Dijkstra(g);\n        BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n        PQ.insert(S(gasId[src], 0));\n        auto D = new int[X];\n        D[] = INF;\n        D[ gasId[src] ] = 0;\n        while (!PQ.empty) {\n            S s = PQ.front; PQ.removeFront;\n            //writeln(s);\n            foreach (ref e; GG[s.v]) {\n                auto next = S(e.to, s.cost + e.cost);\n                //writeln(\"next: \", next);\n                if (D[next.v] <= next.cost) continue;\n                D[next.v] = next.cost;\n                PQ.insert(next);\n            }\n        }\n        writeln(D[dst] == INF ? -1 : D[dst]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nvoid main() {\n    int N, M, Cap;\n    int src, dst;\n    int V;\n    int[string] id;\n    Edge[][] G;\n    bool[] hasGas;\n    int[] gas;\n    int[int] gasId;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &Cap);\n        if (N == 0 && M == 0 && Cap == 0) return false;\n        Cap *= 10;\n        id.destroy;\n        gasId.destroy;\n        G = new Edge[][N * 2 + 2];\n        hasGas = new bool[N * 2 + 2];\n        gas.destroy;\n        auto xs = readln.chomp.split;\n        string src_s = xs[0],\n               dst_s = xs[1];\n        int cid = 0;\n        id[src_s] = cid++;\n        id[dst_s] = cid++;\n        foreach (i; 0 .. N) {\n            xs = readln.chomp.split;\n            string from_s = xs[0],\n                     to_s = xs[1];\n            int      cost = xs[2].to!int;\n            if (from_s !in id) id[from_s] = cid++;\n            if (to_s !in id) id[to_s] = cid++;\n            int from = id[from_s],\n                  to = id[to_s];\n            G[from] ~= Edge(from, to, cost);\n            G[to]   ~= Edge(to, from, cost);\n        }\n        int gid = 0;\n        src = id[src_s];\n        hasGas[src] = true;\n        gas ~= src;\n        gasId[src] = gid++;\n        dst = id[dst_s];\n        hasGas[dst] = true;\n        gas ~= dst;\n        gasId[dst] = gid++;\n        foreach (i; 0 .. M) {\n            string s = readln.chomp;\n            int v = id[s];\n            hasGas[v] = true;\n            gas ~= v;\n            if (v !in gasId) {\n                gasId[v] = gid++;\n            }\n        }\n        V = cid;\n        return true;\n    }\n    const INF = int.max / 2;\n    int[][] GG;\n    void Dijkstra(int v) {\n        struct S {\n            int v, cost;\n        }\n        static int D[6002];\n        D[0 .. V] = INF;\n        BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n        PQ.insert(S(v, 0));\n        D[v] = 0;\n        foreach (g; gas) {\n            if (GG[ gasId[v] ][ gasId[g] ] != INF) {\n                D[g] = GG[ gasId[v] ][ gasId[g] ];\n                PQ.insert(S(g, D[g]));\n            }\n        }\n        while (!PQ.empty) {\n            S s = PQ.front; PQ.removeFront;\n            foreach (e; G[s.v]) {\n                auto next = S(e.to, s.cost + e.cost);\n                if (next.cost > Cap) continue;\n                if (D[next.v] <= next.cost) continue;\n                D[next.v] = next.cost;\n                PQ.insert(next);\n            }\n        }\n        foreach (g; gas) {\n            GG[ gasId[v] ][ gasId[g] ] = D[g];\n            GG[ gasId[g] ][ gasId[v] ] = D[g];\n        }\n    }\n    void solve() {\n        GG = new int[][](M + 2, M + 2);\n        foreach (i; 0 .. M + 2) GG[i][] = INF;\n        foreach (g; gas) Dijkstra(g);\n        const X = M + 2;\n        foreach (k; 0 .. X) {\n            foreach (i; 0 .. X) {\n                foreach (j; 0 .. X) {\n                    GG[i][j] = min(GG[i][j], GG[i][k] + GG[k][j]);\n                }\n            }\n        }\n        writeln(GG[src][dst] == INF ? -1 : GG[src][dst]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nvoid main() {\n    int N, M, Cap;\n    int src, dst;\n    int V;\n    int[string] id;\n    Edge[][] G;\n    bool[] hasGas;\n    int[] gas;\n    int[int] gasId;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &Cap);\n        if (N == 0 && M == 0 && Cap == 0) return false;\n        Cap *= 10;\n        id.destroy;\n        gasId.destroy;\n        G = new Edge[][N * 2 + 2];\n        hasGas = new bool[N * 2 + 2];\n        gas.destroy;\n        auto xs = readln.chomp.split;\n        string src_s = xs[0],\n               dst_s = xs[1];\n        int cid = 0;\n        id[src_s] = cid++;\n        id[dst_s] = cid++;\n        foreach (i; 0 .. N) {\n            xs = readln.chomp.split;\n            string from_s = xs[0],\n                     to_s = xs[1];\n            int      cost = xs[2].to!int;\n            if (from_s !in id) id[from_s] = cid++;\n            if (to_s !in id) id[to_s] = cid++;\n            int from = id[from_s],\n                  to = id[to_s];\n            G[from] ~= Edge(from, to, cost);\n            G[to]   ~= Edge(to, from, cost);\n        }\n        int gid = 0;\n        src = id[src_s];\n        hasGas[src] = true;\n        gas ~= src;\n        gasId[src] = gid++;\n        dst = id[dst_s];\n        hasGas[dst] = true;\n        gas ~= dst;\n        gasId[dst] = gid++;\n        foreach (i; 0 .. M) {\n            string s = readln.chomp;\n            int v = id[s];\n            hasGas[v] = true;\n            gas ~= v;\n            if (v !in gasId) {\n                gasId[v] = gid++;\n            }\n        }\n        V = cid;\n        return true;\n    }\n    const INF = int.max / 2;\n    int[][] GG;\n    void Dijkstra(int v) {\n        struct S {\n            int v, cost;\n        }\n        auto D = new int[V];\n        D[] = INF;\n        BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n        PQ.insert(S(v, 0));\n        D[v] = 0;\n        while (!PQ.empty) {\n            S s = PQ.front; PQ.removeFront;\n            foreach (e; G[s.v]) {\n                auto next = S(e.to, s.cost + e.cost);\n                if (next.cost > Cap) continue;\n                if (D[next.v] <= next.cost) continue;\n                D[next.v] = next.cost;\n                PQ.insert(next);\n            }\n        }\n        foreach (g; gas) {\n            GG[ gasId[v] ][ gasId[g] ] = D[g];\n        }\n    }\n    void solve() {\n        GG = new int[][](M + 2, M + 2);\n        foreach (g; gas) Dijkstra(g);\n        const X = M + 2;\n        foreach (k; 0 .. X) {\n            foreach (i; 0 .. X) {\n                foreach (j; 0 .. X) {\n                    GG[i][j] = min(GG[i][j], GG[i][k] + GG[k][j]);\n                }\n            }\n        }\n        writeln(GG[src][dst] == INF ? -1 : GG[src][dst]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nvoid main() {\n    int N, M, Cap;\n    int src, dst;\n    int V;\n    int[string] id;\n    Edge[][] G;\n    bool[] hasGas;\n    int[] gas;\n    int[int] gasId;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &N, &M, &Cap);\n        if (N == 0 && M == 0 && Cap == 0) return false;\n        Cap *= 10;\n        id.destroy;\n        gasId.destroy;\n        G = new Edge[][N * 2 + 2];\n        hasGas = new bool[N * 2 + 2];\n        gas.destroy;\n        auto xs = readln.chomp.split;\n        string src_s = xs[0],\n               dst_s = xs[1];\n        int cid = 0;\n        id[src_s] = cid++;\n        id[dst_s] = cid++;\n        foreach (i; 0 .. N) {\n            xs = readln.chomp.split;\n            string from_s = xs[0],\n                     to_s = xs[1];\n            int      cost = xs[2].to!int;\n            if (from_s !in id) id[from_s] = cid++;\n            if (to_s !in id) id[to_s] = cid++;\n            int from = id[from_s],\n                  to = id[to_s];\n            G[from] ~= Edge(from, to, cost);\n            G[to]   ~= Edge(to, from, cost);\n        }\n        int gid = 0;\n        src = id[src_s];\n        hasGas[src] = true;\n        gas ~= src;\n        gasId[src] = gid++;\n        dst = id[dst_s];\n        hasGas[dst] = true;\n        gas ~= dst;\n        gasId[dst] = gid++;\n        foreach (i; 0 .. M) {\n            string s = readln.chomp;\n            int v = id[s];\n            hasGas[v] = true;\n            gas ~= v;\n            if (v !in gasId) {\n                gasId[v] = gid++;\n            }\n        }\n        V = cid;\n        return true;\n    }\n    const INF = int.max / 2;\n    int[][] GG;\n    void Dijkstra(int v) {\n        struct S {\n            int v, cost;\n        }\n        static int D[6002];\n        D[0 .. V] = INF;\n        BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n        PQ.insert(S(v, 0));\n        D[v] = 0;\n        while (!PQ.empty) {\n            S s = PQ.front; PQ.removeFront;\n            foreach (e; G[s.v]) {\n                auto next = S(e.to, s.cost + e.cost);\n                if (next.cost > Cap) continue;\n                if (D[next.v] <= next.cost) continue;\n                D[next.v] = next.cost;\n                PQ.insert(next);\n            }\n        }\n        foreach (g; gas) {\n            GG[ gasId[v] ][ gasId[g] ] = D[g];\n        }\n    }\n    void solve() {\n        GG = new int[][](M + 2, M + 2);\n        foreach (g; gas) Dijkstra(g);\n        const X = M + 2;\n        foreach (k; 0 .. X) {\n            foreach (i; 0 .. X) {\n                foreach (j; 0 .. X) {\n                    GG[i][j] = min(GG[i][j], GG[i][k] + GG[k][j]);\n                }\n            }\n        }\n        writeln(GG[src][dst] == INF ? -1 : GG[src][dst]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ninputs = lambda:map(int, raw_input().split())\nwhile 1:\n    n, m, cap = inputs()\n    if n==0:\n        break\n    src, dest = raw_input().split()\n    G = {}\n    f = set([src, dest])\n    for i in xrange(n):\n        c1, c2, d = raw_input().split()\n        d = int(d)\n        G.setdefault(c1, {})[c2] = d\n        G.setdefault(c2, {})[c1] = d\n    for i in xrange(m):\n        s = raw_input()\n        f.add(s)\n    cap *= 10\n\n    def dijkstra(src, G):\n        dist = {src: 0}\n        que = [(0, src)]\n        while que:\n            co, v = heappop(que)\n            if dist[v] < co:\n                continue\n            for t, d in G.get(v, {}).items():\n                if t not in dist:\n                    dist[t] = co+d\n                    heappush(que, (co+d, t))\n        return dist\n\n    H = {}\n    def ss(u):\n        for v, cost in dijkstra(u, G).items():\n            if v in f and cost <= cap:\n                H.setdefault(u, {})[v] = cost\n                H.setdefault(v, {})[u] = cost\n\n    for e in f: ss(e)\n\n    ans = dijkstra(src, H)\n    print ans.get(dest, -1)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\ninputs = lambda:map(int, raw_input().split())\nwhile 1:\n    n, m, cap = inputs()\n    if n==0:\n        break\n    src, dest = raw_input().split()\n    G = {}\n    LPG = set()\n    for i in xrange(n):\n        c1, c2, d = raw_input().split()\n        d = int(d)\n        G.setdefault(c1, {})[c2] = d\n        G.setdefault(c2, {})[c1] = d\n    for i in xrange(m):\n        s = raw_input()\n        LPG.add(s)\n    cap *= 10\n\n    ans = {}\n    dist = {(src, cap): 0}\n    que = [(0, src, cap)]\n    ans[src] = 0\n    while que:\n        co, v, rest = heappop(que)\n        if dist[v, rest] < co:\n            continue\n        if v in LPG:\n            rest = cap\n        for t, d in G[v].items():\n            if rest < d:\n                continue\n            n_key = (t, cap-d)\n            if n_key not in dist:\n                dist[n_key] = co+d\n                heappush(que, (co+d, t, cap-d))\n                ans[t] = min(ans.get(t, 10**18), co+d)\n    print ans.get(dest, -1)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nwhile 1:\n    n, m, cap = map(int, raw_input().split())\n    if n==0:\n        break\n    src, dest = raw_input().split()\n    G = {}\n    for i in xrange(n):\n        c1, c2, d = raw_input().split()\n        d = int(d)\n        G.setdefault(c1, {})[c2] = d\n        G.setdefault(c2, {})[c1] = d\n    S = {raw_input() for i in xrange(m)} | {src, dest}\n\n    INF = 10**18\n    cap *= 10\n\n    def dijkstra(s, G):\n        dist = {s: 0}\n        que = [(0, s)]\n        while que:\n            co, v = heappop(que)\n            if dist.get(v, INF) < co:\n                continue\n            for t, cost in G[v].items():\n                if co+cost < dist.get(t, INF):\n                    dist[t] = co+cost\n                    heappush(que, (co+cost, t))\n        return dist\n\n    H = {}\n    for s in S:\n        dist = dijkstra(s, G)\n        for k, v in dist.items():\n            if k in S and v <= cap:\n                H.setdefault(s, {})[k] = v\n    dist = dijkstra(src, H)\n    print dist.get(dest, -1)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nn, m, cap = map(int, raw_input().split())\nsrc, dest = raw_input().split()\nG = {}\nfor i in xrange(n):\n    c1, c2, d = raw_input().split()\n    d = int(d)\n    G.setdefault(c1, {})[c2] = d\n    G.setdefault(c2, {})[c1] = d\nS = {raw_input() for i in xrange(m)} | {src, dest}\n\nINF = 10**18\ncap *= 10\n\ndef dijkstra(s, G):\n    dist = {s: 0}\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist.get(v, INF) < co:\n            continue\n        for t, cost in G[v].items():\n            if co+cost < dist.get(t, INF):\n                dist[t] = co+cost\n                heappush(que, (co+cost, t))\n    return dist\n\nH = {}\nfor s in S:\n    dist = dijkstra(s, G)\n    for k, v in dist.items():\n        if k in S and v <= cap:\n            H.setdefault(s, {})[k] = v\ndist = dijkstra(src, H)\nprint dist.get(dest, -1)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m,cap):\n        cap *= 10\n        s,t = LS()\n        e = collections.defaultdict(list)\n        for _ in range(n):\n            a,b,c = LS()\n            c = int(c)\n            e[a].append((b,c))\n            e[b].append((a,c))\n        cs = set([S() for _ in range(m)])\n\n        def search(s,t):\n            d = collections.defaultdict(lambda: inf)\n            d[(s,cap)] = 0\n            q = []\n            heapq.heappush(q, (0, (s,cap)))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if u[0] == t:\n                    return k\n\n                for uv, ud in e[u[0]]:\n                    uc = u[1] - ud\n                    if uc < 0:\n                        continue\n                    if uv in cs:\n                        uc = cap\n                    uv = (uv, uc)\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return None\n\n        r = search(s,t)\n        if r is None:\n            return -1\n\n        return r\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]