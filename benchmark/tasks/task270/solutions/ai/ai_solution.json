[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n#define MAX_STATIONS 100\n\ntypedef struct {\n    int city;\n    int distance;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_CITIES];\n    int edge_count;\n} City;\n\nCity cities[MAX_CITIES];\nint lpg_stations[MAX_STATIONS];\nint lpg_station_count = 0;\nint tank_capacity;\nint start_city, end_city;\nint city_count;\n\nint is_lpg_station(int city) {\n    for (int i = 0; i < lpg_station_count; i++) {\n        if (lpg_stations[i] == city) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint dijkstra() {\n    int distance[MAX_CITIES][tank_capacity + 1];\n    int visited[MAX_CITIES][tank_capacity + 1];\n\n    for (int i = 0; i < city_count; i++) {\n        for (int j = 0; j <= tank_capacity; j++) {\n            distance[i][j] = INT_MAX;\n            visited[i][j] = 0;\n        }\n    }\n\n    distance[start_city][tank_capacity] = 0;\n\n    while (1) {\n        int min_dist = INT_MAX;\n        int current_city = -1;\n        int current_gas = -1;\n\n        for (int i = 0; i < city_count; i++) {\n            for (int j = 0; j <= tank_capacity; j++) {\n                if (!visited[i][j] && distance[i][j] < min_dist) {\n                    min_dist = distance[i][j];\n                    current_city = i;\n                    current_gas = j;\n                }\n            }\n        }\n\n        if (current_city == -1) break;\n        if (current_city == end_city) return min_dist;\n\n        visited[current_city][current_gas] = 1;\n\n        for (int i = 0; i < cities[current_city].edge_count; i++) {\n            Edge edge = cities[current_city].edges[i];\n            int next_city = edge.city;\n            int edge_dist = edge.distance;\n\n            if (current_gas >= edge_dist) {\n                int remaining_gas = current_gas - edge_dist;\n                if (distance[next_city][remaining_gas] > distance[current_city][current_gas] + edge_dist) {\n                    distance[next_city][remaining_gas] = distance[current_city][current_gas] + edge_dist;\n                }\n            }\n        }\n\n        if (is_lpg_station(current_city)) {\n            for (int i = 0; i < cities[current_city].edge_count; i++) {\n                Edge edge = cities[current_city].edges[i];\n                int edge_dist = edge.distance;\n                if (tank_capacity >= edge_dist) {\n                    if (distance[current_city][tank_capacity] > distance[current_city][current_gas]) {\n                        distance[current_city][tank_capacity] = distance[current_city][current_gas];\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int road_count;\n    scanf(\"%d %d\", &city_count, &road_count);\n    scanf(\"%d %d\", &start_city, &end_city);\n    scanf(\"%d\", &tank_capacity);\n\n    scanf(\"%d\", &lpg_station_count);\n    for (int i = 0; i < lpg_station_count; i++) {\n        scanf(\"%d\", &lpg_stations[i]);\n    }\n\n    for (int i = 0; i < road_count; i++) {\n        int from, to, dist;\n        scanf(\"%d %d %d\", &from, &to, &dist);\n        cities[from].edges[cities[from].edge_count].city = to;\n        cities[from].edges[cities[from].edge_count].distance = dist;\n        cities[from].edge_count++;\n        cities[to].edges[cities[to].edge_count].city = from;\n        cities[to].edges[cities[to].edge_count].distance = dist;\n        cities[to].edge_count++;\n    }\n\n    int result = dijkstra();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int distance;\n    Edge(int t, int d) : to(t), distance(d) {}\n};\n\nstruct Node {\n    int city;\n    int gas;\n    int total_distance;\n    Node(int c, int g, int t) : city(c), gas(g), total_distance(t) {}\n    bool operator>(const Node& other) const {\n        return total_distance > other.total_distance;\n    }\n};\n\nint main() {\n    int N, M, cap, start, end;\n    cin >> N >> M >> cap >> start >> end;\n    \n    vector<vector<Edge>> roads(N);\n    for (int i = 0; i < M; ++i) {\n        int from, to, distance;\n        cin >> from >> to >> distance;\n        roads[from].emplace_back(to, distance);\n        roads[to].emplace_back(from, distance);\n    }\n    \n    int S;\n    cin >> S;\n    vector<bool> has_station(N, false);\n    for (int i = 0; i < S; ++i) {\n        int station;\n        cin >> station;\n        has_station[station] = true;\n    }\n    \n    vector<vector<int>> dist(N, vector<int>(cap + 1, INT_MAX));\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    pq.emplace(start, cap, 0);\n    dist[start][cap] = 0;\n    \n    int answer = INT_MAX;\n    \n    while (!pq.empty()) {\n        Node current = pq.top();\n        pq.pop();\n        \n        if (current.city == end) {\n            answer = current.total_distance;\n            break;\n        }\n        \n        if (current.total_distance > dist[current.city][current.gas]) {\n            continue;\n        }\n        \n        for (const Edge& edge : roads[current.city]) {\n            int required_gas = edge.distance;\n            if (required_gas > current.gas) {\n                continue;\n            }\n            int remaining_gas = current.gas - required_gas;\n            int new_distance = current.total_distance + edge.distance;\n            \n            if (new_distance < dist[edge.to][remaining_gas]) {\n                dist[edge.to][remaining_gas] = new_distance;\n                pq.emplace(edge.to, remaining_gas, new_distance);\n            }\n        }\n        \n        if (has_station[current.city]) {\n            int new_gas = cap;\n            if (new_gas != current.gas) {\n                if (dist[current.city][new_gas] > current.total_distance) {\n                    dist[current.city][new_gas] = current.total_distance;\n                    pq.emplace(current.city, new_gas, current.total_distance);\n                }\n            }\n        }\n    }\n    \n    if (answer != INT_MAX) {\n        cout << answer << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to;\n    int distance;\n\n    Edge(int to, int distance) {\n        this.to = to;\n        this.distance;\n    }\n}\n\nclass Node implements Comparable<Node> {\n    int city;\n    int gasLeft;\n    int totalDistance;\n\n    Node(int city, int gasLeft, int totalDistance) {\n        this.city = city;\n        this.gasLeft = gasLeft;\n        this.totalDistance = totalDistance;\n    }\n\n    @Override\n    public int compareTo(Node other) {\n        return Integer.compare(this.totalDistance, other.totalDistance);\n    }\n}\n\npublic class TaxiRoute {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int tankCapacity = scanner.nextInt();\n        int start = scanner.nextInt();\n        int destination = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        Set<Integer> lpgStations = new HashSet<>();\n        for (int i = 0; i < K; i++) {\n            lpgStations.add(scanner.nextInt());\n        }\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int from = scanner.nextInt();\n            int to = scanner.nextInt();\n            int distance = scanner.nextInt();\n            graph.get(from).add(new Edge(to, distance));\n            graph.get(to).add(new Edge(from, distance));\n        }\n\n        int[][] dist = new int[N + 1][tankCapacity + 1];\n        for (int[] row : dist) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        dist[start][tankCapacity] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.add(new Node(start, tankCapacity, 0));\n\n        int result = -1;\n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int city = current.city;\n            int gas = current.gasLeft;\n            int totalDist = current.totalDistance;\n\n            if (city == destination) {\n                result = totalDist;\n                break;\n            }\n\n            if (totalDist > dist[city][gas]) continue;\n\n            for (Edge edge : graph.get(city)) {\n                int nextCity = edge.to;\n                int distance = edge.distance;\n\n                if (gas >= distance) {\n                    int remainingGas = gas - distance;\n                    if (dist[nextCity][remainingGas] > totalDist + distance) {\n                        dist[nextCity][remainingGas] = totalDist + distance;\n                        pq.add(new Node(nextCity, remainingGas, dist[nextCity][remainingGas]));\n                    }\n                }\n\n                if (lpgStations.contains(city)) {\n                    int newGas = tankCapacity;\n                    int newDist = totalDist;\n                    if (gas >= distance) {\n                        remainingGas = newGas - distance;\n                        if (dist[nextCity][remainingGas] > newDist + distance) {\n                            dist[nextCity][remainingGas] = newDist + distance;\n                            pq.add(new Node(nextCity, remainingGas, dist[nextCity][remainingGas]));\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 20:52:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int findShortestRoute(int totalDistance, int tankCapacity, int[] stations) {\n        PriorityQueue<Integer> availableStations = new PriorityQueue<>(Collections.reverseOrder());\n        int currentFuel = tankCapacity;\n        int currentPosition = 0;\n        int refuels = 0;\n\n        for (int station : stations) {\n            while (!availableStations.isEmpty() && currentFuel < station) {\n                currentFuel += availableStations.poll();\n                refuels++;\n            }\n\n            if (currentFuel < station) {\n                return -1;\n            }\n\n            currentFuel -= (station - currentPosition);\n            availableStations.offer(station - currentPosition);\n            currentPosition = station;\n        }\n\n        while (!availableStations.isEmpty() && currentFuel < totalDistance) {\n            currentFuel += availableStations.poll();\n            refuels++;\n        }\n\n        return currentFuel >= totalDistance ? refuels : -1;\n    }\n\n    public static void main(String[] args) {\n        int totalDistance = 100;\n        int tankCapacity = 50;\n        int[] stations = {25, 50, 75};\n        \n        int result = findShortestRoute(totalDistance, tankCapacity, stations);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 20:52:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_CITIES 1000\n#define MAX_STATIONS 100\n\ntypedef struct {\n    int distance;\n    int gas_stations;\n} Road;\n\nRoad roads[MAX_CITIES][MAX_CITIES];\nint tank_capacity;\nint num_cities;\nint num_stations;\nint lpg_stations[MAX_STATIONS];\n\nint dijkstra(int start, int destination) {\n    int distances[MAX_CITIES];\n    bool visited[MAX_CITIES];\n    \n    for (int i = 0; i < num_cities; i++) {\n        distances[i] = INT_MAX;\n        visited[i] = false;\n    }\n    \n    distances[start] = 0;\n    \n    for (int count = 0; count < num_cities - 1; count++) {\n        int min_dist = INT_MAX;\n        int current_city = -1;\n        \n        for (int v = 0; v < num_cities; v++) {\n            if (!visited[v] && distances[v] < min_dist) {\n                min_dist = distances[v];\n                current_city = v;\n            }\n        }\n        \n        if (current_city == -1) break;\n        \n        visited[current_city] = true;\n        \n        for (int next_city = 0; next_city < num_cities; next_city++) {\n            if (!visited[next_city] && \n                roads[current_city][next_city].distance > 0 && \n                roads[current_city][next_city].distance <= tank_capacity) {\n                \n                int new_distance = distances[current_city] + roads[current_city][next_city].distance;\n                \n                if (new_distance < distances[next_city]) {\n                    distances[next_city] = new_distance;\n                }\n            }\n        }\n    }\n    \n    return distances[destination] != INT_MAX ? distances[destination] : -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &num_cities, &tank_capacity, &num_stations);\n    \n    for (int i = 0; i < num_stations; i++) {\n        scanf(\"%d\", &lpg_stations[i]);\n    }\n    \n    int road_connections;\n    scanf(\"%d\", &road_connections);\n    \n    for (int i = 0; i < road_connections; i++) {\n        int from, to, distance;\n        scanf(\"%d %d %d\", &from, &to, &distance);\n        \n        roads[from][to].distance = distance;\n        roads[to][from].distance = distance;\n    }\n    \n    int start, destination;\n    scanf(\"%d %d\", &start, &destination);\n    \n    int shortest_path = dijkstra(start, destination);\n    \n    printf(\"%d\\n\", shortest_path);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Station {\n    int location;\n    int fuel;\n};\n\nint findShortestRoute(int totalDistance, int tankCapacity, vector<Station>& stations) {\n    int n = stations.size();\n    stations.push_back({totalDistance, 0});\n    \n    vector<vector<int>> dp(n + 1, vector<int>(tankCapacity + 1, INT_MAX));\n    dp[0][0] = 0;\n    \n    for (int i = 0; i < n + 1; i++) {\n        for (int j = 0; j <= tankCapacity; j++) {\n            if (dp[i][j] == INT_MAX) continue;\n            \n            for (int k = i + 1; k < n + 1; k++) {\n                int distance = stations[k].location - stations[i].location;\n                \n                if (distance > tankCapacity) break;\n                \n                if (j >= distance) {\n                    dp[k][j - distance] = min(dp[k][j - distance], dp[i][j]);\n                }\n                \n                if (j < distance) {\n                    int additionalFuel = distance - j;\n                    if (stations[i].fuel >= additionalFuel) {\n                        dp[k][0] = min(dp[k][0], dp[i][j] + additionalFuel);\n                    }\n                }\n            }\n        }\n    }\n    \n    int minCost = INT_MAX;\n    for (int j = 0; j <= tankCapacity; j++) {\n        minCost = min(minCost, dp[n][j]);\n    }\n    \n    return minCost == INT_MAX ? -1 : minCost;\n}\n\nint main() {\n    int totalDistance, tankCapacity, stationCount;\n    cin >> totalDistance >> tankCapacity >> stationCount;\n    \n    vector<Station> stations(stationCount);\n    for (int i = 0; i < stationCount; i++) {\n        cin >> stations[i].location >> stations[i].fuel;\n    }\n    \n    sort(stations.begin(), stations.end(), [](const Station& a, const Station& b) {\n        return a.location < b.location;\n    });\n    \n    int result = findShortestRoute(totalDistance, tankCapacity, stations);\n    \n    if (result == -1) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(graph, start, end, max_gas, stations):\n    queue = [(0, start, max_gas)]\n    best = {(start, max_gas): 0}\n\n    while queue:\n        dist, current, gas_left = heappop(queue)\n        \n        if current == end:\n            return dist\n        \n        if best.get((current, gas_left), float('inf')) < dist:\n            continue\n\n        if current in stations:\n            gas_left = max_gas\n\n        for neighbor, road_dist in graph[current]:\n            if gas_left >= road_dist:\n                new_gas = gas_left - road_dist\n                new_dist = dist + road_dist\n                if new_dist < best.get((neighbor, new_gas), float('inf')):\n                    best[(neighbor, new_gas)] = new_dist\n                    heappush(queue, (new_dist, neighbor, new_gas))\n    \n    return -1\n\ndef add_road(graph, u, v, dist):\n    graph[u].append((v, dist))\n    graph[v].append((u, dist))\n\ndef find_shortest_route(n, roads, stations, max_gas, start, end):\n    graph = defaultdict(list)\n    \n    for (u, v, dist) in roads:\n        add_road(graph, u, v, dist)\n    \n    return dijkstra(graph, start, end, max_gas, set(stations))\n\n# Example usage\ncities = 5\nroads = [\n    (0, 1, 10),\n    (1, 2, 10),\n    (2, 3, 10),\n    (3, 4, 10),\n    (0, 4, 25),\n]\nstations = [1, 3]\nmax_gas = 20\nstart_city = 0\nend_city = 4\n\nshortest_distance = find_shortest_route(cities, roads, stations, max_gas, start_city, end_city)\nprint(shortest_distance)",
    "timestamp": "2025-08-13 03:48:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass City {\n    int id;\n    int distance;\n    int lpgCapacity;\n\n    City(int id, int distance, int lpgCapacity) {\n        this.id = id;\n        this.distance = distance;\n        this.lpgCapacity = lpgCapacity;\n    }\n}\n\nclass Solution {\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int findShortestPath(int numCities, int[][] roads, int[] lpgStations, int tankCapacity, int startCity, int endCity) {\n        List<List<City>> graph = new ArrayList<>();\n        \n        for (int i = 0; i < numCities; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] road : roads) {\n            graph.get(road[0]).add(new City(road[1], road[2], lpgStations[road[1]]));\n            graph.get(road[1]).add(new City(road[0], road[2], lpgStations[road[0]]));\n        }\n        \n        int[][] minDist = new int[numCities][tankCapacity + 1];\n        for (int i = 0; i < numCities; i++) {\n            Arrays.fill(minDist[i], INF);\n        }\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.offer(new int[]{startCity, 0, tankCapacity});\n        minDist[startCity][tankCapacity] = 0;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int city = current[0], distance = current[1], gas = current[2];\n            \n            if (city == endCity) {\n                return distance;\n            }\n            \n            for (City neighbor : graph.get(city)) {\n                int remainingGas = gas - neighbor.distance;\n                \n                if (remainingGas >= 0) {\n                    int newDist = distance + neighbor.distance;\n                    int maxGas = Math.min(tankCapacity, remainingGas + neighbor.lpgCapacity);\n                    \n                    if (newDist < minDist[neighbor.id][maxGas]) {\n                        minDist[neighbor.id][maxGas] = newDist;\n                        pq.offer(new int[]{neighbor.id, newDist, maxGas});\n                    }\n                }\n            }\n        }\n        \n        return INF;\n    }\n    \n    public static void main(String[] args) {\n        int numCities = 5;\n        int[][] roads = {\n            {0, 1, 10},\n            {1, 2, 10},\n            {0, 3, 20},\n            {3, 4, 10},\n            {4, 2, 10}\n        };\n        int[] lpgStations = {0, 20, 30, 0, 10}; // LPG capacities at each city\n        int tankCapacity = 30;\n        int startCity = 0;\n        int endCity = 2;\n        \n        int result = findShortestPath(numCities, roads, lpgStations, tankCapacity, startCity, endCity);\n        System.out.println(\"The shortest possible journey distance is: \" + (result == INF ? \"Impossible\" : result));\n    }\n}",
    "timestamp": "2025-08-13 03:48:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n#define MAX_DISTANCES 10000\n\ntypedef struct {\n    int city1;\n    int city2;\n    int distance;\n} Road;\n\ntypedef struct {\n    int city;\n    int capacity;\n} LPGStation;\n\nint minDistance(int dist[], int visited[], int n) {\n    int minIndex = -1;\n    int minValue = INT_MAX;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i] && dist[i] < minValue) {\n            minValue = dist[i];\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}\n\nint shortestPath(int n, Road roads[], int roadCount, int start, int end, LPGStation stations[], int stationCount, int tankCapacity) {\n    int dist[MAX_CITIES];\n    int visited[MAX_CITIES];\n    int adj[MAX_CITIES][MAX_CITIES];\n\n    for (int i = 0; i < MAX_CITIES; i++) {\n        for (int j = 0; j < MAX_CITIES; j++) {\n            adj[i][j] = MAX_DISTANCES;\n        }\n    }\n\n    for (int i = 0; i < roadCount; i++) {\n        adj[roads[i].city1][roads[i].city2] = roads[i].distance;\n        adj[roads[i].city2][roads[i].city1] = roads[i].distance;\n    }\n\n    for (int i = 0; i < n; i++) {\n        dist[i] = MAX_DISTANCES;\n        visited[i] = 0;\n    }\n\n    dist[start] = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        int minIndex = minDistance(dist, visited, n);\n        visited[minIndex] = 1;\n\n        for (int v = 0; v < n; v++) {\n            int stationAvailable = 0;\n            for (int s = 0; s < stationCount; s++) {\n                if (stations[s].city == v && stations[s].capacity >= tankCapacity) {\n                    stationAvailable = 1;\n                    break;\n                }\n            }\n\n            if (!visited[v] && adj[minIndex][v] != MAX_DISTANCES && dist[minIndex] + adj[minIndex][v] < dist[v] && stationAvailable) {\n                dist[v] = dist[minIndex] + adj[minIndex][v];\n            }\n        }\n    }\n    return dist[end];\n}\n\nint main() {\n    int n = 5; // number of cities\n    Road roads[] = {\n        {0, 1, 10},\n        {1, 2, 10},\n        {2, 3, 10},\n        {3, 4, 10},\n        {0, 4, 50}\n    };\n    int roadCount = sizeof(roads) / sizeof(Road);\n\n    LPGStation stations[] = {\n        {1, 20}, \n        {3, 15}, \n        {4, 25}\n    };\n    int stationCount = sizeof(stations) / sizeof(LPGStation);\n\n    int startCity = 0;\n    int endCity = 4;\n    int tankCapacity = 15;\n\n    int result = shortestPath(n, roads, roadCount, startCity, endCity, stations, stationCount, tankCapacity);\n\n    if (result < MAX_DISTANCES) {\n        printf(\"Shortest distance: %d\\n\", result);\n    } else {\n        printf(\"No path available\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:48:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_shortest_route(road_network, gas_stations, start_city, destination_city, tank_capacity):\n    # Initialize distances and previous nodes for Dijkstra's algorithm\n    distances = {city: float('inf') for city in road_network}\n    distances[start_city] = 0\n    previous = {city: None for city in road_network}\n    unvisited = set(road_network.keys())\n    \n    # Set of LPG stations\n    lpg_stations = set(gas_stations)\n    \n    while unvisited:\n        # Find unvisited city with minimum distance\n        current_city = min(unvisited, key=lambda city: distances[city])\n        \n        # If destination reached, return distance\n        if current_city == destination_city:\n            return distances[destination_city]\n        \n        unvisited.remove(current_city)\n        \n        # Check neighboring cities\n        for neighbor, distance in road_network[current_city].items():\n            # Check if can reach neighbor with current gas\n            if distances[current_city] + distance <= tank_capacity:\n                # Calculate potential new distance\n                new_distance = distances[current_city] + distance\n                \n                # Refuel if at LPG station\n                if neighbor in lpg_stations:\n                    new_distance = 0\n                \n                # Update if shorter path found\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current_city\n    \n    # No route found\n    return -1\n\n# Example usage\nroad_network = {\n    'Tokyo': {'Osaka': 500, 'Nagoya': 250},\n    'Osaka': {'Tokyo': 500, 'Kyoto': 50},\n    'Nagoya': {'Tokyo': 250, 'Kyoto': 200},\n    'Kyoto': {'Osaka': 50, 'Nagoya': 200}\n}\n\ngas_stations = ['Osaka', 'Nagoya']\nstart_city = 'Tokyo'\ndestination_city = 'Kyoto'\ntank_capacity = 300\n\nshortest_route = find_shortest_route(road_network, gas_stations, start_city, destination_city, tank_capacity)\nprint(shortest_route)",
    "timestamp": "2025-08-13 03:48:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    cap = int(data[idx])\n    idx += 1\n    start = int(data[idx])\n    idx += 1\n    end = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        d = int(data[idx])\n        idx += 1\n        adj[a].append((b, d))\n        adj[b].append((a, d))\n    \n    K = int(data[idx])\n    idx += 1\n    stations = set()\n    for _ in range(K):\n        s = int(data[idx])\n        idx += 1\n        stations.add(s)\n    \n    INF = float('inf')\n    dist = [[INF] * (cap + 1) for _ in range(N + 1)]\n    dist[start][0] = 0\n    heap = []\n    heapq.heappush(heap, (0, start, 0))\n    \n    while heap:\n        current_dist, u, fuel = heapq.heappop(heap)\n        if u == end:\n            print(current_dist)\n            return\n        if current_dist > dist[u][fuel]:\n            continue\n        for v, d in adj[u]:\n            if fuel >= d:\n                if dist[v][fuel - d] > current_dist + d:\n                    dist[v][fuel - d] = current_dist + d\n                    heapq.heappush(heap, (dist[v][fuel - d], v, fuel - d))\n            if u in stations:\n                new_fuel = cap\n                remaining = new_fuel - d\n                if remaining >= 0:\n                    if dist[v][remaining] > current_dist + d:\n                        dist[v][remaining] = current_dist + d\n                        heapq.heappush(heap, (dist[v][remaining], v, remaining))\n    \n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 03:53:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nconstexpr int INF = std::numeric_limits<int>::max();\n\nstruct Edge {\n    int to, distance;\n};\n\nstruct Node {\n    int city, fuel, distance;\n    bool operator<(const Node& other) const {\n        return distance > other.distance;\n    }\n};\n\nint findShortestPath(int n, int m, int tankCapacity, const std::vector<std::vector<Edge>>& roads, const std::vector<bool>& lpgCities, int start, int destination) {\n    std::priority_queue<Node> pq;\n    std::vector<std::vector<int>> dist(n, std::vector<int>(tankCapacity + 1, INF));\n    \n    pq.push({start, tankCapacity, 0});\n    dist[start][tankCapacity] = 0;\n\n    while (!pq.empty()) {\n        Node node = pq.top();\n        pq.pop();\n\n        if (node.city == destination) return node.distance;\n        if (dist[node.city][node.fuel] < node.distance) continue;\n\n        for (const Edge& edge : roads[node.city]) {\n            int nextFuel = node.fuel - edge.distance;\n            if (nextFuel >= 0 && dist[edge.to][nextFuel] > node.distance + edge.distance) {\n                dist[edge.to][nextFuel] = node.distance + edge.distance;\n                pq.push({edge.to, nextFuel, node.distance + edge.distance});\n            }\n        }\n\n        if (lpgCities[node.city] && dist[node.city][tankCapacity] > node.distance) {\n            dist[node.city][tankCapacity] = node.distance;\n            pq.push({node.city, tankCapacity, node.distance});\n        }\n    }\n    \n    return -1; // No valid path found\n}\n\nint main() {\n    int n, m, tankCapacity, start, destination;\n    std::cin >> n >> m >> tankCapacity >> start >> destination;\n\n    std::vector<std::vector<Edge>> roads(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, d;\n        std::cin >> u >> v >> d;\n        roads[u].push_back({v, d});\n        roads[v].push_back({u, d});\n    }\n\n    std::vector<bool> lpgCities(n, false);\n    int lpgCount;\n    std::cin >> lpgCount;\n    for (int i = 0; i < lpgCount; ++i) {\n        int city;\n        std::cin >> city;\n        lpgCities[city] = true;\n    }\n\n    int result = findShortestPath(n, m, tankCapacity, roads, lpgCities, start, destination);\n    if (result != -1) {\n        std::cout << \"Shortest Path Distance: \" << result << std::endl;\n    } else {\n        std::cout << \"No valid path found.\" << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:15:13"
  }
]